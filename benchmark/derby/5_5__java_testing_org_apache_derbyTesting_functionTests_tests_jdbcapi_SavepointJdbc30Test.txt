1:c1d0f1d: /*
1:c1d0f1d:  *
1:c1d0f1d:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi/SavepointJdbc30Test
1:c1d0f1d:  *
1:c1d0f1d:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:c1d0f1d:  * contributor license agreements.  See the NOTICE file distributed with
1:c1d0f1d:  * this work for additional information regarding copyright ownership.
1:c1d0f1d:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:c1d0f1d:  * (the "License"); you may not use this file except in compliance with
1:c1d0f1d:  * the License.  You may obtain a copy of the License at
1:c1d0f1d:  *
1:c1d0f1d:  *    http://www.apache.org/licenses/LICENSE-2.0
1:c1d0f1d:  *
1:c1d0f1d:  * Unless required by applicable law or agreed to in writing,
1:c1d0f1d:  * software distributed under the License is distributed on an
1:c1d0f1d:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:c1d0f1d:  * either express or implied. See the License for the specific
1:c1d0f1d:  * language governing permissions and limitations under the License.
1:c1d0f1d:  */
1:a95545d: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
3:a95545d: 
1:a95545d: import java.lang.reflect.Method;
1:a95545d: import java.sql.Connection;
1:a95545d: import java.sql.ResultSet;
1:a95545d: import java.sql.SQLException;
1:a95545d: import java.sql.Savepoint;
1:a95545d: import java.sql.Statement;
1:a95545d: import junit.framework.Test;
1:a95545d: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a95545d: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:696e42e: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:a95545d: import org.apache.derbyTesting.junit.JDBC;
1:a95545d: import org.apache.derbyTesting.junit.TestConfiguration;
1:a95545d: 
1:a95545d: /**
1:a95545d:  * Test the new class Savepoint in JDBC 30. Also, test some mix and match of
1:a95545d:  * defining savepoints through JDBC and SQL testing both callable and prepared
1:a95545d:  * statements meta data
1:a95545d:  * 
1:a95545d:  */
1:a95545d: 
1:a95545d: public class SavepointJdbc30Test extends BaseJDBCTestCase {
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Create a test
1:a95545d:      * 
1:a95545d:      * @param name
1:a95545d:      */
1:a95545d:     public SavepointJdbc30Test(String name) {
1:a95545d:         super(name); 
1:a95545d:     }
1:a95545d: 
1:1146825:     /**
1:a95545d:      * Set up the test suite for embedded mode, client mode, and embedded mode
1:a95545d:      * with XADataSources 
1:a95545d:      * 
1:d2719a2:      * @return A suite containing embedded, client and embedded with XA suites
1:a95545d:      */
1:a95545d:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("SavepointJdbc30_JSR169Test suite");
1:a95545d: 
1:a95545d:         // Get the tests for embedded
1:1ae02c9:         BaseTestSuite embedded = new BaseTestSuite(
1:a95545d:                 "SavepointJdbc30_JSR169Test:embedded");
2:a95545d:         embedded.addTestSuite(SavepointJdbc30Test.class);
2:a95545d:         embedded.addTest(getEmbeddedSuite("SavepointJdbc30_JSR169Test:"
1:a95545d:                 + "embedded only"));
1:a95545d:         suite.addTest(embedded);
1:a95545d: 
1:a95545d:         // Get the tests for client.
1:1ae02c9:         BaseTestSuite client =
1:1ae02c9:             new BaseTestSuite("SavepointJdbc30_JSR169Test:client");
1:1ae02c9: 
1:a95545d:         client.addTestSuite(SavepointJdbc30Test.class);
1:a95545d:         suite.addTest(TestConfiguration.clientServerDecorator(client));
1:a95545d: 
1:a95545d:         // Repeat the embedded tests obtaining a connection from
1:a95545d:         // an XA data source if it is supported. This is not supported
1:c1d0f1d:         // under JSR169.
1:a95545d:         if (JDBC.vmSupportsJDBC3()) {
1:1ae02c9:             embedded = new BaseTestSuite(
1:c1d0f1d:             "SavepointJdbc30_JSR169Test:embedded XADataSource");
1:c1d0f1d:             embedded.addTestSuite(SavepointJdbc30Test.class);
1:c1d0f1d:             embedded.addTest(getEmbeddedSuite("SavepointJdbc30_JSR169Test:"
1:a95545d:         			+ "embedded only XADataSource"));
1:c1d0f1d:             suite.addTest(TestConfiguration.connectionXADecorator(embedded));
1:c1d0f1d:             //        	 Repeat the client tests obtaining a connection from
1:c1d0f1d:             // an XA data source if it is supported. This is not supported
1:c1d0f1d:             // under JSR169.
1:1ae02c9:             client = new BaseTestSuite(
1:1ae02c9:                 "SavepointJdbc30_JSR169Test:client XADatasource");
1:1ae02c9: 
1:c1d0f1d:             client.addTestSuite(SavepointJdbc30Test.class);
1:c1d0f1d:             suite.addTest(TestConfiguration.clientServerDecorator(TestConfiguration.connectionXADecorator(client)));        	
1:a95545d:         }	
1:696e42e: 
1:696e42e:         return new CleanDatabaseTestSetup(
1:696e42e:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 1, 2)) {
1:a95545d:             /**
1:a95545d:              * Creates the database objects used in the test cases.
1:a95545d:              * 
1:a95545d:              * @throws SQLException
1:a95545d:              */
1:a95545d:             protected void decorateSQL(Statement s) throws SQLException {
1:a95545d:                 /* Create a table */
1:a95545d:                 s.execute("create table t1 (c11 int, c12 smallint)");
1:a95545d:                 s.execute("create table t2 (c11 int)");
1:a95545d:                 getConnection().commit();
1:a95545d: 
1:a95545d:             }
1:a95545d:         };
1:a95545d: 
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Create a testsuite containing the tests that can only run in embedded
1:a95545d:      * mode. These tests have names starting with x and are added automatically.
1:a95545d:      */
1:a95545d:     private static Test getEmbeddedSuite(String name) {
1:1ae02c9:         BaseTestSuite embedded = new BaseTestSuite(name);
1:a95545d:         Method[] methods = SavepointJdbc30Test.class.getMethods();
1:a95545d:         for (int i = 0; i < methods.length; i++) {
1:a95545d:             Method m = methods[i];
1:a95545d:             if (m.getParameterTypes().length > 0
1:a95545d:                     || !m.getReturnType().equals(Void.TYPE)) {
1:a95545d:                 continue;
1:a95545d:             }
1:a95545d:             String methodName = m.getName();
1:a95545d:             if (methodName.startsWith("x")) {
1:a95545d:                 embedded.addTest(new SavepointJdbc30Test(methodName));
1:a95545d:             }
1:a95545d:         }
1:a95545d:         return embedded;
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:6401861:      * Set up the test environment.
1:a95545d:      */
1:a95545d:     protected void setUp() throws Exception {
1:a95545d:         super.setUp();
1:a95545d:         // Keep Autocommit off
1:a95545d:         getConnection().setAutoCommit(false);
1:6401861:         // Clear the tables created by the decorator
1:6401861:         Statement s = createStatement();
1:6401861:         s.execute("truncate table t1");
1:6401861:         s.execute("truncate table t2");
1:6401861:         commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test1. It should not be possible to set a savepoint if autocommit is on.
1:a95545d:      */
1:a95545d:     public void testNoSavepointsIfAutoCommit() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         con.setAutoCommit(true);
1:a95545d:         try {
1:a95545d:             con.setSavepoint(); // will throw exception because auto commit is
1:a95545d:             // true
1:a95545d:             fail("No unnamed savepoints allowed if autocommit is true");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XJ010", se);
1:a95545d:         }
1:a95545d:         // Test 1a
1:a95545d:         try {
1:a95545d:             con.setSavepoint("notallowed"); // will throw exception because auto
1:a95545d:             // commit is true
1:a95545d:             fail("No named savepoints allowed if autocommit is true");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XJ010", se);
1:a95545d:         }
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test2 - After releasing a savepoint, should be able to reuse it.
1:a95545d:      */
1:a95545d:     public void testReusingSavepoints() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         con.setSavepoint("s1");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test3 - Named savepoints can't pass null for name
1:a95545d:      */
1:a95545d:     public void testNullName() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         try {
1:a95545d:             con.setSavepoint(null);
1:a95545d:             fail("FAIL 3 Null savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XJ011", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test4 - Verify names/ids of named/unnamed savepoints named savepoints
1:a95545d:      * don't have an id. unnamed savepoints don't have a name (internally, all
1:a95545d:      * our savepoints have names, but for unnamed savepoint, that is not exposed
1:a95545d:      * through jdbc api)
1:a95545d:      * 
1:a95545d:      * @throws SQLException
1:a95545d:      */
1:a95545d:     public void testNamesAndIds() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         try {
2:a95545d:             Savepoint savepoint1 = con.setSavepoint();
1:a95545d:             savepoint1.getSavepointId();
1:a95545d:             // following should throw exception for unnamed savepoint
1:a95545d:             savepoint1.getSavepointName();
1:a95545d:             fail("FAIL 4 getSavepointName on id savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XJ014", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:         try {
1:a95545d:             Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:             savepoint1.getSavepointName();
1:a95545d:             // following should throw exception for named savepoint
1:a95545d:             savepoint1.getSavepointId();
1:a95545d:             fail("FAIL 4 getSavepointId on named savepoint ");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XJ013", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * TEST 5a and 5b for bug 4465 test 5a - create two savepoints in two
1:a95545d:      * different transactions and release the first one in the subsequent
1:a95545d:      * transaction
1:a95545d:      */
1:a95545d:     public void testBug4465() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         con.commit();
1:a95545d:         // The following savepoint was earlier named s1. Changed it to s2 while
1:a95545d:         // working on DRDA support
1:a95545d:         // for savepoints. The reason for that is as follows
1:a95545d:         // The client translates all savepoint jdbc calls to equivalent sql and
1:a95545d:         // hence
1:a95545d:         // if the 2 savepoints in
1:a95545d:         // different connections are named the same, then the release savepoint
1:a95545d:         // below will get converted to
1:a95545d:         // RELEASE TO SAVEPOINT s1 and that succeeds because the 2nd connection
1:a95545d:         // does have a savepoint named s1.
1:a95545d:         // Hence we don't really check what we intended to check which is trying
1:a95545d:         // to release a savepoint created
1:a95545d:         // in a different transaction
1:a95545d:         con.setSavepoint("s2");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         try {
1:a95545d:             con.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 5a - release savepoint from a different transaction "
1:a95545d:                     + "did not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d: 
1:a95545d:         // test 5b - create two savepoints in two different transactions
1:a95545d:         // and rollback the first one in the subsequent transaction
1:a95545d:         savepoint1 = con.setSavepoint("s1");
1:a95545d:         con.commit();
1:a95545d:         // The following savepoint was earlier named s1. Changed it to s2 while
1:a95545d:         // working on DRDA support
1:a95545d:         // for savepoints. The reason for that is as follows
1:a95545d:         // The client translates all savepoint jdbc calls to equivalent sql and
1:a95545d:         // hence
1:a95545d:         // if the 2 savepoints in
1:a95545d:         // different connections are named the same, then the rollback savepoint
1:a95545d:         // below will get converted to
1:a95545d:         // ROLLBACK TO SAVEPOINT s1 and that succeeds because the 2nd connection
1:a95545d:         // does have a savepoint named s1.
1:a95545d:         // Hence we don't really check what we intended to check which is trying
1:a95545d:         // to rollback a savepoint created
1:a95545d:         // in a different transaction
1:a95545d:         con.setSavepoint("s2");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint1);
1:a95545d:             fail("FAIL 5b - rollback savepoint from a different transaction "
1:a95545d:                     + "did not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * test 6a - create a savepoint release it and then create another with the
1:a95545d:      * same name. and release the first one
1:a95545d:      */
1:a95545d:     public void testReleaseReleasedSavepoint() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         // The following savepoint was earlier named s1. Changed it to s2 while
1:a95545d:         // working on DRDA support
1:a95545d:         // for savepoints. The reason for that is as follows
1:a95545d:         // The client translates all savepoint jdbc calls to equivalent sql and
1:a95545d:         // hence
1:a95545d:         // if the 2 savepoints in
1:a95545d:         // a transaction are named the same, then the release savepoint below
1:a95545d:         // will get converted to
1:a95545d:         // RELEASE TO SAVEPOINT s1 and that succeeds because there is a valid
1:a95545d:         // savepoint named s1.
1:a95545d:         con.setSavepoint("s2");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         try {
1:a95545d:             con.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 6a - releasing a released savepoint did not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * test 6b - create a savepoints release it and then create another with the
1:a95545d:      * same name. and rollback the first one
1:a95545d:      */
1:a95545d:     public void testRollbackReleasedSavepoint() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         // The following savepoint was earlier named s1. Changed it to s2 while
1:a95545d:         // working on DRDA support
1:a95545d:         // for savepoints. The reason for that is as follows
1:a95545d:         // The client translates all savepoint jdbc calls to equivalent sql and
1:a95545d:         // hence
1:a95545d:         // if the 2 savepoints in
1:a95545d:         // a transaction are named the same, then the rollback savepoint below
1:a95545d:         // will get converted to
1:a95545d:         // ROLLBACK TO SAVEPOINT s1 and that succeeds because there is a valid
1:a95545d:         // savepoint named s1.
1:a95545d:         con.setSavepoint("s2");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint1);
1:a95545d:             fail("FAIL 6b - rollback a released savepoint did not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 6c: TEST case just for bug 4467 // Test 10 - create a named
1:a95545d:      * savepoint with the a generated name savepoint1 =
1:a95545d:      * con2.setSavepoint("SAVEPT0"); // what exactly is the correct behaviour
1:a95545d:      * here? try { savepoint2 = con2.setSavepoint(); } catch (SQLException se) {
1:a95545d:      * System.out.println("Expected Exception is " + se.getMessage()); }
1:a95545d:      * con2.commit();
1:a95545d:      */
1:a95545d:     public void testReleaseSavepointFromOtherTransaction() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         Connection con2 = openDefaultConnection();
1:a95545d:         try {
1:a95545d:             con2.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 6c - releasing another transaction's savepoint did "
1:a95545d:                     + "not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("XJ010", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("XJ008", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:         con2.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 7a: BUG 4468 - should not be able to pass a savepoint from a
1:a95545d:      * different transaction for release/rollback
1:a95545d:      */
1:a95545d:     public void testSwapSavepointsAcrossConnectionAndRelease()
1:a95545d:             throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Connection con2 = openDefaultConnection();
1:a95545d:         con2.setAutoCommit(false);
1:a95545d:         Savepoint savepoint1 = con2.setSavepoint("s1");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         con.setSavepoint("s1");
1:a95545d:         try {
1:a95545d:             con.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 7a - releasing a another transaction's savepoint did "
1:a95545d:                     + "not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B502", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("XJ097", se);
1:a95545d:             }
1:a95545d: 
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:         con2.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 7b - swap savepoints across connections
1:a95545d:      */
1:a95545d:     public void testSwapSavepointsAcrossConnectionsAndRollback()
1:a95545d:             throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Connection con2 = openDefaultConnection();
1:a95545d:         con2.setAutoCommit(false);
1:a95545d:         Savepoint savepoint1 = con2.setSavepoint("s1");
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         con.setSavepoint("s1");
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint1);
1:a95545d:             fail("FAIL 7b - rolling back a another transaction's savepoint "
1:a95545d:                     + "did not raise error");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B502", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("XJ097", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:         con.commit();
1:a95545d:         con2.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /*
1:a95545d:      * following section attempts to call statement in a method to do a negative
1:a95545d:      * test because savepoints are not supported in a trigger however, this
1:a95545d:      * cannot be done because a call is not supported in a trigger. leaving the
1:a95545d:      * test here for later reference for when we support the SQL version // bug
1:a95545d:      * 4507 - Test 8 test all 4 savepoint commands inside the trigger code
1:a95545d:      * System.out.println("Test 8a set savepoint(unnamed) command inside the
1:a95545d:      * trigger code"); s.executeUpdate("create trigger trig1 before insert on t1
1:a95545d:      * for each statement call
1:a95545d:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionSetSavepointUnnamed()");
1:a95545d:      * try {
1:a95545d:      * 
1:a95545d:      * s.executeUpdate("insert into t1 values(1,1)"); System.out.println("FAIL
1:a95545d:      * 8a set savepoint(unnamed) command inside the trigger code"); } catch
1:a95545d:      * (SQLException se) { System.out.println("Expected Exception is " +
1:a95545d:      * se.getMessage()); } s.executeUpdate("drop trigger trig1");
1:a95545d:      * 
1:a95545d:      * System.out.println("Test 8b set savepoint(named) command inside the
1:a95545d:      * trigger code"); s.executeUpdate("create trigger trig2 before insert on t1
1:a95545d:      * for each statement call
1:a95545d:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionSetSavepointNamed()");
1:a95545d:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:a95545d:      * System.out.println("FAIL 8b set savepoint(named) command inside the
1:a95545d:      * trigger code"); } catch (SQLException se) { System.out.println("Expected
1:a95545d:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:a95545d:      * trig2");
1:a95545d:      * 
1:a95545d:      * System.out.println("Test 8c release savepoint command inside the trigger
1:a95545d:      * code"); s.executeUpdate("create trigger trig3 before insert on t1 for
1:a95545d:      * each statement call
1:a95545d:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionReleaseSavepoint()");
1:a95545d:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:a95545d:      * System.out.println("FAIL 8c release savepoint command inside the trigger
1:a95545d:      * code"); } catch (SQLException se) { System.out.println("Expected
1:a95545d:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:a95545d:      * trig3");
1:a95545d:      * 
1:a95545d:      * System.out.println("Test 8d rollback savepoint command inside the trigger
1:a95545d:      * code"); s.executeUpdate("create trigger trig4 before insert on t1 for
1:a95545d:      * each statement call
1:a95545d:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionRollbackSavepoint()");
1:a95545d:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:a95545d:      * System.out.println("FAIL 8d rollback savepoint command inside the trigger
1:a95545d:      * code"); } catch (SQLException se) { System.out.println("Expected
1:a95545d:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:a95545d:      * trig4"); con.rollback();
1:a95545d:      */// end commented out test 8
1:a95545d:     /**
1:a95545d:      * Test 9 test savepoint name and verify case sensitivity
1:a95545d:      */
1:a95545d:     public void testSavepointName() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("myname");
1:a95545d:         String savepointName = savepoint1.getSavepointName();
1:a95545d:         assertEquals(savepointName, "myname");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 10 test savepoint name case sensitivity
1:a95545d:      */
1:a95545d:     public void testNameCaseSensitivity() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:a95545d:         String savepointName = savepoint1.getSavepointName();
1:a95545d:         assertEquals(savepointName, "MyName");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 11 rolling back a savepoint multiple times - should work
1:a95545d:      */
1:a95545d:     public void testRollbackMultipleTimes() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:a95545d:         con.rollback(savepoint1);
1:a95545d:         con.rollback(savepoint1);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 12 releasing a savepoint multiple times - should not work
1:a95545d:      */
1:a95545d:     public void testReleaseMultipleTimes() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         try {
1:a95545d:             con.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 12 releasing a savepoint multiple times should fail");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 13 shouldn't be able to use a savepoint from earlier transaction
1:a95545d:      * after setting autocommit on and off
1:a95545d:      */
1:a95545d:     public void testSavepointFromEarlierTransactionAfterToggleAutocommit()
1:a95545d:             throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:a95545d:         con.setAutoCommit(true);
1:a95545d:         con.setAutoCommit(false);
1:a95545d:         Savepoint savepoint2 = con.setSavepoint("MyName1");
1:a95545d:         try {// shouldn't be able to use savepoint from earlier tranasaction
1:a95545d:             // after setting autocommit on and off
1:a95545d:             con.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 13 shouldn't be able to use a savepoint from earlier "
1:a95545d:                     + "transaction after setting autocommit on and off");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.releaseSavepoint(savepoint2);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 14 cause a transaction rollback and that should release the internal
1:a95545d:      * savepoint array
1:a95545d:      */
1:a95545d:     public void testRollbackReleasesSavepointArray() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Connection con2 = openDefaultConnection();
1:a95545d:         con2.setAutoCommit(false);
1:a95545d:         Statement s1, s2;
1:a95545d:         s1 = createStatement();
1:a95545d:         s1.executeUpdate("insert into t1 values(1,1)");
1:a95545d:         s1.executeUpdate("insert into t1 values(2,0)");
1:a95545d:         con.commit();
1:a95545d:         s1.executeUpdate("update t1 set c11=c11+1 where c12 > 0");
1:a95545d:         s2 = con2.createStatement();
1:a95545d:         Savepoint savepoint1 = con2.setSavepoint("MyName");
1:a95545d:         try {// following will get lock timeout which will rollback
1:a95545d:             // transaction on c2
1:a95545d:             s2.executeUpdate("update t1 set c11=c11+1 where c12 < 1");
1:a95545d:             fail("FAIL 14 should have gotten lock time out");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("40XL1", se);
1:a95545d:         }
1:a95545d:         try {// the transaction rollback above should have removed the
1:a95545d:             // savepoint MyName
1:a95545d:             con2.releaseSavepoint(savepoint1);
1:a95545d:             fail("FAIL 14 A non-user initiated transaction rollback should "
1:a95545d:                     + "release the internal savepoint array");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:         con2.rollback();
1:a95545d:         s1.execute("delete from t1");
1:a95545d:         con.commit();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 15 Check savepoints in batch */
1:a95545d:     public void testSavepointsInBatch() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.execute("delete from t1");
1:a95545d:         s.addBatch("insert into t1 values(1,1)");
1:a95545d:         s.addBatch("insert into t1 values(2,2)");
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         s.addBatch("insert into t1 values(3,3)");
1:a95545d:         s.executeBatch();
1:a95545d:         con.rollback(savepoint1);
1:a95545d: 
1:a95545d:         assertTableRowCount("T1", 0);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 16 grammar check for savepoint sq1 */
1:a95545d:     public void testGrammarCheck() throws SQLException {
1:a95545d:         Statement s = getConnection().createStatement();
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS");
1:a95545d:             fail("FAIL 16 Should have gotten exception for missing ON ROLLBACK "
1:a95545d:                     + "RETAIN CURSORS");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42X01", se);
1:a95545d:         }
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 UNIQUE ON ROLLBACK RETAIN CURSORS "
1:a95545d:                     + "ON ROLLBACK RETAIN CURSORS");
1:a95545d:             fail("FAIL 16 Should have gotten exception for multiple ON ROLLBACK "
1:a95545d:                     + "RETAIN CURSORS");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42613", se);
1:a95545d:         }
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:a95545d:                     + " RETAIN LOCKS");
1:a95545d:             fail("FAIL 16 Should have gotten exception for multiple ON ROLLBACK "
1:a95545d:                     + "RETAIN LOCKS");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42613", se);
1:a95545d:         }
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 UNIQUE UNIQUE ON ROLLBACK RETAIN "
1:a95545d:                     + "LOCKS ON ROLLBACK RETAIN CURSORS");
1:a95545d:             fail("FAIL 16 Should have gotten exception for multiple UNIQUE keywords");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42613", se);
1:a95545d:         }
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN CURSORS ON ROLLBACK "
1:a95545d:                 + "RETAIN LOCKS");
1:a95545d:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 17 */
1:a95545d:     public void testNoNestedSavepointsWhenUsingSQL() throws SQLException {
1:a95545d:         Statement s = getConnection().createStatement();
1:a95545d:         s.executeUpdate("SAVEPOINT s1 UNIQUE ON ROLLBACK RETAIN LOCKS ON "
1:a95545d:                 + "ROLLBACK RETAIN CURSORS");
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s2 UNIQUE ON ROLLBACK RETAIN "
1:a95545d:                     + "LOCKS ON ROLLBACK RETAIN CURSORS");
1:a95545d:             fail("FAIL 17a Should have gotten exception for nested savepoints");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d:         }
1:a95545d:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:a95545d:         s.executeUpdate("SAVEPOINT s2 UNIQUE ON ROLLBACK RETAIN LOCKS ON "
1:a95545d:                 + "ROLLBACK RETAIN CURSORS");
1:a95545d:         getConnection().rollback();
1:a95545d: 
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON "
1:a95545d:                     + "ROLLBACK RETAIN CURSORS");
1:a95545d:             fail("FAIL 17b Should have gotten exception for nested savepoints");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d:         }
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 18 */
1:a95545d:     public void testNoNestedSavepointsInsideJdbcSavepoint() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         Statement s = getConnection().createStatement();
1:a95545d:         // Following SQL savepoint will fail because we are trying to nest it
1:a95545d:         // inside JDBC savepoint
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:a95545d:                     + " RETAIN CURSORS");
1:a95545d:             fail("FAIL 18 shouldn't be able set SQL savepoint nested inside "
1:a95545d:                     + "JDBC savepoints");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d:         }
1:a95545d:         // rollback the JDBC savepoint. Now since there are no user defined
1:a95545d:         // savepoints, we can define SQL savepoint
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON "
1:a95545d:                 + "ROLLBACK RETAIN CURSORS");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 19 */
1:a95545d:     public void testNoNestedSavepointsInsideSqlSavepoint() throws SQLException {
1:a95545d:         Statement s = getConnection().createStatement();
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s2 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:a95545d:                     + " RETAIN CURSORS");
1:a95545d:             fail("FAIL 19 shouldn't be able set SQL savepoint nested inside "
1:a95545d:                     + "SQL savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d:         }
1:a95545d:         // rollback the SQL savepoint. Now since there are no user defined
1:a95545d:         // savepoints, we can define SQL savepoint
1:a95545d:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:a95545d:         s.executeUpdate("SAVEPOINT s2 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 20 */
1:a95545d:     public void testRollbackSqlSavepointSameAsJdbc() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("DELETE FROM T1");
1:a95545d:         con.commit();
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:a95545d:         // Rollback to SQL savepoint and should see changes rolledback
1:a95545d:         s.execute("ROLLBACK TO SAVEPOINT s1");
1:a95545d: 
1:a95545d:         ResultSet rs1 = s.executeQuery("select count(*) from t1");
1:a95545d:         rs1.next();
1:a95545d:         assertEquals(rs1.getInt(1), 0);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 21 */
1:a95545d:     public void testReleaseSqlSavepointAndRollback() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(3,1)");
1:a95545d:         // Release the SQL savepoint and then rollback the transaction and
1:a95545d:         // should see changes rolledback
1:a95545d:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:a95545d:         con.rollback();
1:a95545d:         ResultSet rs1 = s.executeQuery("select count(*) from t1");
1:a95545d:         rs1.next();
1:a95545d:         assertEquals(rs1.getInt(1), 0);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 22 */
1:a95545d:     public void testNoSqlSavepointStartingWithSYS() throws SQLException {
1:a95545d:         Statement s = createStatement();
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT SYSs2 ON ROLLBACK RETAIN LOCKS ON "
1:a95545d:                     + "ROLLBACK RETAIN CURSORS");
1:a95545d:             fail("FAIL 22 shouldn't be able to create a SQL savepoint starting "
1:a95545d:                     + "with name SYS");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42939", se);
1:a95545d:         }
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 23 - bug 5817 - make savepoint and release non-reserved keywords
1:a95545d:      */
1:a95545d:     public void testBug5817() throws SQLException {
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.execute("create table savepoint (savepoint int, release int)");
1:a95545d:         ResultSet rs1 = s.executeQuery("select count(*) from savepoint");
1:a95545d:         rs1.next();
1:a95545d:         assertEquals(" There should have been 0 rows in the table, but found "
1:a95545d:                 + rs1.getInt(1), rs1.getInt(1), 0);
1:a95545d: 
1:a95545d:         s.execute("SAVEPOINT savepoint ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         s.executeUpdate("INSERT INTO savepoint VALUES(1,1)");
1:a95545d:         s.execute("RELEASE SAVEPOINT savepoint");
1:a95545d:         rs1 = s.executeQuery("select count(*) from savepoint");
1:a95545d:         rs1.next();
1:a95545d:         assertEquals("There should have been 1 rows in the table, but found "
1:a95545d:                 + rs1.getInt(1), rs1.getInt(1), 1);
1:a95545d: 
1:a95545d:         s.execute("SAVEPOINT release ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         s.executeUpdate("INSERT INTO savepoint VALUES(2,1)");
1:a95545d:         s.execute("ROLLBACK TO SAVEPOINT release");
1:a95545d:         rs1 = s.executeQuery("select count(*) from savepoint");
1:a95545d:         rs1.next();
1:a95545d:         assertEquals(
1:a95545d:                 "ERROR: There should have been 1 rows in the table, but found "
1:a95545d:                         + rs1.getInt(1), rs1.getInt(1), 1);
1:a95545d: 
1:a95545d:         s.execute("RELEASE SAVEPOINT release");
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 24 Savepoint name can't exceed 128 characters
1:a95545d:      */
1:a95545d:     public void testNameLengthMax128Chars() throws SQLException {
1:a95545d:         try {
1:a95545d:             getConnection()
1:a95545d:                     .setSavepoint(
1:a95545d:                             "MyName12345678901234567890123456789"
1:a95545d:                                     + "01234567890123456789012345678901234567890123456789012345"
1:a95545d:                                     + "678901234567890123456789012345678901234567890");
1:a95545d:             fail("FAIL 24 shouldn't be able to create a SQL savepoint with "
1:a95545d:                     + "name exceeding 128 characters");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42622", se);
1:a95545d:         }
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /** Test 25 */
1:a95545d:     public void testNoSqlSavepointStartingWithSYSThroughJdbc()
1:a95545d:             throws SQLException {
1:a95545d:         try {
1:a95545d:             getConnection().setSavepoint("SYSs2");
1:a95545d:             fail("FAIL 25 shouldn't be able to create a SQL savepoint starting with name SYS through jdbc");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("42939", se);
1:a95545d:         }
1:a95545d:         getConnection().rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * bug 4451 - Test 26a pass Null value to rollback bug 5374 - Passing a null
1:a95545d:      * savepoint to rollback or release method used to give a npe in JCC it
1:a95545d:      * should give a SQLException aying "Cannot rollback to a null savepoint"
1:a95545d:      */
1:a95545d:     public void testRollbackNullSavepoint() throws SQLException {
1:a95545d:         try {
1:a95545d:             getConnection().rollback((Savepoint) null);
1:a95545d:             fail("FAIL 26a rollback of null savepoint did not raise error ");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B001", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("3B502", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 26b pass Null value to releaseSavepoint
1:a95545d:      */
1:a95545d:     public void testReleaseNullSavepoint() throws SQLException {
1:a95545d:         try {
1:a95545d:             getConnection().releaseSavepoint((Savepoint) null);
1:a95545d:             fail("FAIL 26b release of null savepoint did not raise error ");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B001", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("3B502", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:1146825:      * Test that savepoint names can have double-quote characters. The client
1:1146825:      * driver used to fail with a syntax error when the names contained such
1:1146825:      * characters. DERBY-5170.
1:1146825:      */
1:1146825:     public void testQuotes() throws SQLException {
1:1146825:         setAutoCommit(false);
1:1146825:         Statement s = createStatement();
1:1146825:         s.execute("create table test_quotes(x int)");
1:1146825:         s.execute("insert into test_quotes values 1");
1:1146825: 
1:1146825:         Savepoint sp = getConnection().setSavepoint("a \" b ' c");
1:1146825: 
1:1146825:         s.execute("insert into test_quotes values 2");
1:1146825: 
1:1146825:         getConnection().rollback(sp);
1:1146825: 
1:1146825:         JDBC.assertSingleValueResultSet(
1:1146825:                 s.executeQuery("select * from test_quotes"),
1:1146825:                 "1");
1:1146825: 
1:1146825:         getConnection().releaseSavepoint(sp);
1:1146825:     }
1:1146825: 
1:a95545d:     /** ********************* */
1:a95545d: 
1:a95545d:     /*
1:a95545d:      * The following tests have nested savepoints through JDBC calls. When
1:a95545d:      * coming through the network client these nested JDBC savepoint calls are
1:a95545d:      * translated into equivalent SQL savepoint statements. But we do not allow
1:a95545d:      * nested savepoints coming through SQL statements and hence these tests
1:a95545d:      * can't be run under DRDA framework.
1:a95545d:      */
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test40 - We internally generate a unique name for unnamed savepoints. If
1:a95545d:      * a named savepoint uses the currently used internal savepoint name, we
1:a95545d:      * won't get an exception thrown for it because we prepend external saves
1:a95545d:      * with "e." to avoid name conflicts.
1:a95545d:      */
1:a95545d:     public void xtestNoConflictWithGeneratedName() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d: 
1:a95545d:         con.setSavepoint();
1:a95545d:         con.setSavepoint("i.SAVEPT0");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test41 - Rolling back to a savepoint will release all the savepoints
1:a95545d:      * created after that savepoint.
1:a95545d:      */
1:a95545d:     public void xtestRollbackWillReleaseLaterSavepoints() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:1079036:         
1:a95545d:         Statement s = createStatement();
1:1079036: 
1:1079036:         // Make sure T1 is empty (testcase running order might have left content!):
1:1079036:         s.execute("DELETE FROM T1");
1:1079036:         
1:1079036:         Savepoint savepoint1 = con.setSavepoint();
1:1079036: 
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:a95545d: 
1:a95545d:         Savepoint savepoint2 = con.setSavepoint("s1");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:a95545d: 
1:a95545d:         Savepoint savepoint3 = con.setSavepoint("s2");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(3,1)");
1:a95545d: 
1:a95545d:         // Rollback to first named savepoint s1. This will internally release
1:a95545d:         // the second named savepoint s2.
1:a95545d:         con.rollback(savepoint2);
1:a95545d:         assertTableRowCount("T1", 1);
1:a95545d: 
1:a95545d:         // Trying to release second named savepoint s2 should throw exception.
1:a95545d:         try {
1:a95545d:             con.releaseSavepoint(savepoint3);
1:a95545d:             fail("FAIL 41a release of rolled back savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:         // Trying to rollback second named savepoint s2 should throw exception.
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint3);
1:a95545d:             fail("FAIL 41b release of rolled back savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d: 
1:a95545d:         // Release the unnamed named savepoint.
1:a95545d:         con.rollback(savepoint1);
1:a95545d:         assertTableRowCount("T1", 0);
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test42 - Rollback on a connection will release all the savepoints created
1:a95545d:      * for that transaction
1:a95545d:      */
1:a95545d:     public void xtestRollbackWillReleaseActiveSavepoints() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         con.rollback();
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint1);
1:a95545d:             fail("FAIL 42 release of rolled back savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test42a - Commit on a connection will release all the savepoints created
1:a95545d:      * for that transaction
1:a95545d:      */
1:a95545d:     public void xtestCommitWillReleaseActiveSavepoints() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         con.commit();
1:a95545d:         try {
1:a95545d:             con.rollback(savepoint1);
1:a95545d:             fail("FAIL 42a Rollback after commit.");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B001", se);
1:a95545d:         }
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test43 - After releasing a savepoint, should be able to reuse it.
1:a95545d:      */
1:a95545d:     public void xtestReuseNameAfterRelease() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("s1");
1:a95545d:         try {
1:a95545d:             con.setSavepoint("s1");
1:a95545d:             fail("Should not be able to set two savepoints with the same name");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B501", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("3B002", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:         con.releaseSavepoint(savepoint1);
1:a95545d:         con.setSavepoint("s1");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 45 reuse savepoint name after rollback - should not work
1:a95545d:      */
1:a95545d:     public void xtestReuseNameAfterRollback() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:a95545d:         con.rollback(savepoint1);
1:a95545d:         try {
1:a95545d:             con.setSavepoint("MyName");
1:a95545d:             fail("FAIL 45 reuse of savepoint name after rollback should fail");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             if (usingEmbedded()) {
1:a95545d:                 assertSQLState("3B501", se);
1:a95545d:             } else if (usingDerbyNetClient()) {
1:a95545d:                 assertSQLState("3B002", se);
1:a95545d:             }
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 46 bug 5145 Cursors declared before and within the savepoint unit
1:a95545d:      * will be closed when rolling back the savepoint
1:a95545d:      */
1:a95545d:     public void xtestCursorsCloseOnRollback() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Statement sWithHold = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:a95545d:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:a95545d:         Statement s = createStatement();
1:a95545d:         s.executeUpdate("DELETE FROM T1");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(19,1)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(19,2)");
1:a95545d:         s.executeUpdate("INSERT INTO T1 VALUES(19,3)");
1:a95545d:         ResultSet rs1 = s.executeQuery("select * from t1");
1:a95545d:         rs1.next();
1:a95545d:         ResultSet rs1WithHold = sWithHold.executeQuery("select * from t1");
1:a95545d:         rs1WithHold.next();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         ResultSet rs2 = s.executeQuery("select * from t1");
1:a95545d:         rs2.next();
1:a95545d:         ResultSet rs2WithHold = sWithHold.executeQuery("select * from t1");
1:a95545d:         rs2WithHold.next();
1:a95545d:         con.rollback(savepoint1);
1:a95545d:         try {// resultset declared outside the savepoint unit should be
1:a95545d:             // closed at this point after the rollback to savepoint
1:a95545d:             rs1.next();
1:a95545d:             fail("FAIL 46 shouldn't be able to use a resultset (declared "
1:a95545d:                     + "before the savepoint unit) after the rollback to savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XCL16", se);
1:a95545d:         }
1:a95545d:         try {// holdable resultset declared outside the savepoint unit should
1:a95545d:             // be closed at this point after the rollback to savepoint
1:a95545d:             rs1WithHold.next();
1:a95545d:             fail("FAIL 46 shouldn't be able to use a holdable resultset "
1:a95545d:                     + "(declared before the savepoint unit) after the rollback "
1:a95545d:                     + "to savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XCL16", se);
1:a95545d:         }
1:a95545d:         try {// resultset declared within the savepoint unit should be closed
1:a95545d:             // at this point after the rollback to savepoint
1:a95545d:             rs2.next();
1:a95545d:             fail("FAIL 46 shouldn't be able to use a resultset (declared within "
1:a95545d:                     + "the savepoint unit) after the rollback to savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XCL16", se);
1:a95545d:         }
1:a95545d:         try {// holdable resultset declared within the savepoint unit should
1:a95545d:             // be closed at this point after the rollback to savepoint
1:a95545d:             rs2WithHold.next();
1:a95545d:             fail("FAIL 46 shouldn't be able to use a holdable resultset "
1:a95545d:                     + "(declared within the savepoint unit) after the rollback "
1:a95545d:                     + "to savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("XCL16", se);
1:a95545d:         }
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 47 multiple tests for getSavepointId()
1:a95545d:      */
1:a95545d:     public void xtestGetSavepoint() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         Savepoint savepoint2 = con.setSavepoint();
1:a95545d:         savepoint1.getSavepointId();
1:a95545d:         savepoint2.getSavepointId();
1:a95545d:         con.releaseSavepoint(savepoint2);
1:a95545d:         savepoint2 = con.setSavepoint();
1:a95545d:         savepoint2.getSavepointId();
1:a95545d:         con.commit();
1:a95545d:         savepoint2 = con.setSavepoint();
1:a95545d:         savepoint2.getSavepointId();
1:a95545d:         con.rollback();
1:a95545d:         savepoint2 = con.setSavepoint();
1:a95545d:         savepoint2.getSavepointId();
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d:     /**
1:a95545d:      * Test 48
1:a95545d:      */
1:a95545d:     public void xtestNestedSavepoints() throws SQLException {
1:a95545d:         Connection con = getConnection();
1:a95545d:         Savepoint savepoint1 = con.setSavepoint();
1:a95545d:         Savepoint savepoint2 = con.setSavepoint();
1:a95545d:         Statement s = createStatement();
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:a95545d:                     + " RETAIN CURSORS");
1:a95545d:             fail("FAIL 48 shouldn't be able set SQL savepoint nested inside "
1:a95545d:                     + "JDBC/SQL savepoints");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d:         }
1:a95545d:         // rollback JDBC savepoint but still can't have SQL savepoint because
1:a95545d:         // there is still one JDBC savepoint
1:a95545d:         con.releaseSavepoint(savepoint2);
1:a95545d:         try {
1:a95545d:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:a95545d:                     + " RETAIN CURSORS");
1:a95545d:             fail("FAIL 48 Should have gotten exception for nested SQL savepoint");
1:a95545d:         } catch (SQLException se) {
1:a95545d:             // Expected exception.
1:a95545d:             assertSQLState("3B002", se);
1:a95545d: 
1:a95545d:         }
1:a95545d:         con.releaseSavepoint(savepoint1); // rollback last JDBC savepoint and
1:a95545d:         // now try SQL savepoint again
1:a95545d:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:a95545d:                 + "RETAIN CURSORS");
1:a95545d:         con.rollback();
1:a95545d:     }
1:a95545d: 
1:a95545d: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("SavepointJdbc30_JSR169Test suite");
1:         BaseTestSuite embedded = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite client =
1:             new BaseTestSuite("SavepointJdbc30_JSR169Test:client");
1: 
/////////////////////////////////////////////////////////////////////////
1:             embedded = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:             client = new BaseTestSuite(
1:                 "SavepointJdbc30_JSR169Test:client XADatasource");
1: 
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite embedded = new BaseTestSuite(name);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1146825
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that savepoint names can have double-quote characters. The client
1:      * driver used to fail with a syntax error when the names contained such
1:      * characters. DERBY-5170.
1:      */
1:     public void testQuotes() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         s.execute("create table test_quotes(x int)");
1:         s.execute("insert into test_quotes values 1");
1: 
1:         Savepoint sp = getConnection().setSavepoint("a \" b ' c");
1: 
1:         s.execute("insert into test_quotes values 2");
1: 
1:         getConnection().rollback(sp);
1: 
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from test_quotes"),
1:                 "1");
1: 
1:         getConnection().releaseSavepoint(sp);
1:     }
1: 
commit:6401861
/////////////////////////////////////////////////////////////////////////
1:      * Set up the test environment.
1:         // Clear the tables created by the decorator
1:         Statement s = createStatement();
1:         s.execute("truncate table t1");
1:         s.execute("truncate table t2");
1:         commit();
commit:696e42e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1: 
1:         return new CleanDatabaseTestSetup(
1:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 1, 2)) {
author:Ole Solberg
-------------------------------------------------------------------------------
commit:1079036
/////////////////////////////////////////////////////////////////////////
1:         
1: 
1:         // Make sure T1 is empty (testcase running order might have left content!):
1:         s.execute("DELETE FROM T1");
1:         
1:         Savepoint savepoint1 = con.setSavepoint();
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c1d0f1d
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi/SavepointJdbc30Test
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
/////////////////////////////////////////////////////////////////////////
1:         // under JSR169.
0:             embedded = new TestSuite(
1:             "SavepointJdbc30_JSR169Test:embedded XADataSource");
1:             embedded.addTestSuite(SavepointJdbc30Test.class);
1:             embedded.addTest(getEmbeddedSuite("SavepointJdbc30_JSR169Test:"
1:             suite.addTest(TestConfiguration.connectionXADecorator(embedded));
1:             //        	 Repeat the client tests obtaining a connection from
1:             // an XA data source if it is supported. This is not supported
1:             // under JSR169.
0:             client = new TestSuite("SavepointJdbc30_JSR169Test:client XADatasource");
1:             client.addTestSuite(SavepointJdbc30Test.class);
1:             suite.addTest(TestConfiguration.clientServerDecorator(TestConfiguration.connectionXADecorator(client)));        	
commit:a95545d
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.lang.reflect.Method;
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test the new class Savepoint in JDBC 30. Also, test some mix and match of
1:  * defining savepoints through JDBC and SQL testing both callable and prepared
1:  * statements meta data
1:  * 
1:  */
1: 
1: public class SavepointJdbc30Test extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Create a test
1:      * 
1:      * @param name
1:      */
1:     public SavepointJdbc30Test(String name) {
1:         super(name); 
1:     }
1: 
1:     /**
1:      * Set up the test suite for embedded mode, client mode, and embedded mode
1:      * with XADataSources 
1:      * 
0:      * @return
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("SavepointJdbc30_JSR169Test suite");
1: 
1:         // Get the tests for embedded
0:         TestSuite embedded = new TestSuite(
1:                 "SavepointJdbc30_JSR169Test:embedded");
1:         embedded.addTestSuite(SavepointJdbc30Test.class);
1:         embedded.addTest(getEmbeddedSuite("SavepointJdbc30_JSR169Test:"
1:                 + "embedded only"));
1:         suite.addTest(embedded);
1: 
1:         // Get the tests for client.
0:         TestSuite client = new TestSuite("SavepointJdbc30_JSR169Test:client");
1:         client.addTestSuite(SavepointJdbc30Test.class);
1:         suite.addTest(TestConfiguration.clientServerDecorator(client));
1: 
1:         // Repeat the embedded tests obtaining a connection from
1:         // an XA data source if it is supported. This is not supported
0:         // under JSR169
1:         if (JDBC.vmSupportsJDBC3()) {
0:         	embedded = new TestSuite(
0:         	"SavepointJdbc30_JSR169Test:embedded XADataSource");
1:         	embedded.addTestSuite(SavepointJdbc30Test.class);
1:         	embedded.addTest(getEmbeddedSuite("SavepointJdbc30_JSR169Test:"
1:         			+ "embedded only XADataSource"));
0:         	suite.addTest(TestConfiguration.connectionXADecorator(embedded));
1:         }	
0:         // return suite;
0:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the database objects used in the test cases.
1:              * 
1:              * @throws SQLException
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 /* Create a table */
1:                 s.execute("create table t1 (c11 int, c12 smallint)");
1:                 s.execute("create table t2 (c11 int)");
1:                 getConnection().commit();
1: 
1:             }
1:         };
1: 
1:     }
1: 
1:     /**
1:      * Create a testsuite containing the tests that can only run in embedded
1:      * mode. These tests have names starting with x and are added automatically.
1:      */
1:     private static Test getEmbeddedSuite(String name) {
0:         TestSuite embedded = new TestSuite(name);
1:         Method[] methods = SavepointJdbc30Test.class.getMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             Method m = methods[i];
1:             if (m.getParameterTypes().length > 0
1:                     || !m.getReturnType().equals(Void.TYPE)) {
1:                 continue;
1:             }
1:             String methodName = m.getName();
1:             if (methodName.startsWith("x")) {
1:                 embedded.addTest(new SavepointJdbc30Test(methodName));
1:             }
1:         }
1:         return embedded;
1:     }
1: 
1:     /**
0:      * setUp: Just keep AutoCommit off.
1:      */
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         // Keep Autocommit off
1:         getConnection().setAutoCommit(false);
1:     }
1: 
1:     /**
1:      * Test1. It should not be possible to set a savepoint if autocommit is on.
1:      */
1:     public void testNoSavepointsIfAutoCommit() throws SQLException {
1:         Connection con = getConnection();
1:         con.setAutoCommit(true);
1:         try {
1:             con.setSavepoint(); // will throw exception because auto commit is
1:             // true
1:             fail("No unnamed savepoints allowed if autocommit is true");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XJ010", se);
1:         }
1:         // Test 1a
1:         try {
1:             con.setSavepoint("notallowed"); // will throw exception because auto
1:             // commit is true
1:             fail("No named savepoints allowed if autocommit is true");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XJ010", se);
1:         }
1:     }
1: 
1:     /**
1:      * Test2 - After releasing a savepoint, should be able to reuse it.
1:      */
1:     public void testReusingSavepoints() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         con.releaseSavepoint(savepoint1);
1:         con.setSavepoint("s1");
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test3 - Named savepoints can't pass null for name
1:      */
1:     public void testNullName() throws SQLException {
1:         Connection con = getConnection();
1:         try {
1:             con.setSavepoint(null);
1:             fail("FAIL 3 Null savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XJ011", se);
1:         }
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test4 - Verify names/ids of named/unnamed savepoints named savepoints
1:      * don't have an id. unnamed savepoints don't have a name (internally, all
1:      * our savepoints have names, but for unnamed savepoint, that is not exposed
1:      * through jdbc api)
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testNamesAndIds() throws SQLException {
1:         Connection con = getConnection();
1:         try {
1:             Savepoint savepoint1 = con.setSavepoint();
1:             savepoint1.getSavepointId();
1:             // following should throw exception for unnamed savepoint
1:             savepoint1.getSavepointName();
1:             fail("FAIL 4 getSavepointName on id savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XJ014", se);
1:         }
1:         con.rollback();
1:         try {
1:             Savepoint savepoint1 = con.setSavepoint("s1");
1:             savepoint1.getSavepointName();
1:             // following should throw exception for named savepoint
1:             savepoint1.getSavepointId();
1:             fail("FAIL 4 getSavepointId on named savepoint ");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XJ013", se);
1:         }
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * TEST 5a and 5b for bug 4465 test 5a - create two savepoints in two
1:      * different transactions and release the first one in the subsequent
1:      * transaction
1:      */
1:     public void testBug4465() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         con.commit();
1:         // The following savepoint was earlier named s1. Changed it to s2 while
1:         // working on DRDA support
1:         // for savepoints. The reason for that is as follows
1:         // The client translates all savepoint jdbc calls to equivalent sql and
1:         // hence
1:         // if the 2 savepoints in
1:         // different connections are named the same, then the release savepoint
1:         // below will get converted to
1:         // RELEASE TO SAVEPOINT s1 and that succeeds because the 2nd connection
1:         // does have a savepoint named s1.
1:         // Hence we don't really check what we intended to check which is trying
1:         // to release a savepoint created
1:         // in a different transaction
1:         con.setSavepoint("s2");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         try {
1:             con.releaseSavepoint(savepoint1);
1:             fail("FAIL 5a - release savepoint from a different transaction "
1:                     + "did not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.commit();
1: 
1:         // test 5b - create two savepoints in two different transactions
1:         // and rollback the first one in the subsequent transaction
1:         savepoint1 = con.setSavepoint("s1");
1:         con.commit();
1:         // The following savepoint was earlier named s1. Changed it to s2 while
1:         // working on DRDA support
1:         // for savepoints. The reason for that is as follows
1:         // The client translates all savepoint jdbc calls to equivalent sql and
1:         // hence
1:         // if the 2 savepoints in
1:         // different connections are named the same, then the rollback savepoint
1:         // below will get converted to
1:         // ROLLBACK TO SAVEPOINT s1 and that succeeds because the 2nd connection
1:         // does have a savepoint named s1.
1:         // Hence we don't really check what we intended to check which is trying
1:         // to rollback a savepoint created
1:         // in a different transaction
1:         con.setSavepoint("s2");
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         try {
1:             con.rollback(savepoint1);
1:             fail("FAIL 5b - rollback savepoint from a different transaction "
1:                     + "did not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.commit();
1:     }
1: 
1:     /**
1:      * test 6a - create a savepoint release it and then create another with the
1:      * same name. and release the first one
1:      */
1:     public void testReleaseReleasedSavepoint() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         con.releaseSavepoint(savepoint1);
1:         // The following savepoint was earlier named s1. Changed it to s2 while
1:         // working on DRDA support
1:         // for savepoints. The reason for that is as follows
1:         // The client translates all savepoint jdbc calls to equivalent sql and
1:         // hence
1:         // if the 2 savepoints in
1:         // a transaction are named the same, then the release savepoint below
1:         // will get converted to
1:         // RELEASE TO SAVEPOINT s1 and that succeeds because there is a valid
1:         // savepoint named s1.
1:         con.setSavepoint("s2");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         try {
1:             con.releaseSavepoint(savepoint1);
1:             fail("FAIL 6a - releasing a released savepoint did not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.commit();
1:     }
1: 
1:     /**
1:      * test 6b - create a savepoints release it and then create another with the
1:      * same name. and rollback the first one
1:      */
1:     public void testRollbackReleasedSavepoint() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         con.releaseSavepoint(savepoint1);
1:         // The following savepoint was earlier named s1. Changed it to s2 while
1:         // working on DRDA support
1:         // for savepoints. The reason for that is as follows
1:         // The client translates all savepoint jdbc calls to equivalent sql and
1:         // hence
1:         // if the 2 savepoints in
1:         // a transaction are named the same, then the rollback savepoint below
1:         // will get converted to
1:         // ROLLBACK TO SAVEPOINT s1 and that succeeds because there is a valid
1:         // savepoint named s1.
1:         con.setSavepoint("s2");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         try {
1:             con.rollback(savepoint1);
1:             fail("FAIL 6b - rollback a released savepoint did not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.commit();
1:     }
1: 
1:     /**
1:      * Test 6c: TEST case just for bug 4467 // Test 10 - create a named
1:      * savepoint with the a generated name savepoint1 =
1:      * con2.setSavepoint("SAVEPT0"); // what exactly is the correct behaviour
1:      * here? try { savepoint2 = con2.setSavepoint(); } catch (SQLException se) {
1:      * System.out.println("Expected Exception is " + se.getMessage()); }
1:      * con2.commit();
1:      */
1:     public void testReleaseSavepointFromOtherTransaction() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         Connection con2 = openDefaultConnection();
1:         try {
1:             con2.releaseSavepoint(savepoint1);
1:             fail("FAIL 6c - releasing another transaction's savepoint did "
1:                     + "not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("XJ010", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("XJ008", se);
1:             }
1:         }
1:         con.commit();
1:         con2.commit();
1:     }
1: 
1:     /**
1:      * Test 7a: BUG 4468 - should not be able to pass a savepoint from a
1:      * different transaction for release/rollback
1:      */
1:     public void testSwapSavepointsAcrossConnectionAndRelease()
1:             throws SQLException {
1:         Connection con = getConnection();
1:         Connection con2 = openDefaultConnection();
1:         con2.setAutoCommit(false);
1:         Savepoint savepoint1 = con2.setSavepoint("s1");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         con.setSavepoint("s1");
1:         try {
1:             con.releaseSavepoint(savepoint1);
1:             fail("FAIL 7a - releasing a another transaction's savepoint did "
1:                     + "not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B502", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("XJ097", se);
1:             }
1: 
1:         }
1:         con.commit();
1:         con2.commit();
1:     }
1: 
1:     /**
1:      * Test 7b - swap savepoints across connections
1:      */
1:     public void testSwapSavepointsAcrossConnectionsAndRollback()
1:             throws SQLException {
1:         Connection con = getConnection();
1:         Connection con2 = openDefaultConnection();
1:         con2.setAutoCommit(false);
1:         Savepoint savepoint1 = con2.setSavepoint("s1");
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         con.setSavepoint("s1");
1:         try {
1:             con.rollback(savepoint1);
1:             fail("FAIL 7b - rolling back a another transaction's savepoint "
1:                     + "did not raise error");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B502", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("XJ097", se);
1:             }
1:         }
1:         con.commit();
1:         con2.commit();
1:     }
1: 
1:     /*
1:      * following section attempts to call statement in a method to do a negative
1:      * test because savepoints are not supported in a trigger however, this
1:      * cannot be done because a call is not supported in a trigger. leaving the
1:      * test here for later reference for when we support the SQL version // bug
1:      * 4507 - Test 8 test all 4 savepoint commands inside the trigger code
1:      * System.out.println("Test 8a set savepoint(unnamed) command inside the
1:      * trigger code"); s.executeUpdate("create trigger trig1 before insert on t1
1:      * for each statement call
1:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionSetSavepointUnnamed()");
1:      * try {
1:      * 
1:      * s.executeUpdate("insert into t1 values(1,1)"); System.out.println("FAIL
1:      * 8a set savepoint(unnamed) command inside the trigger code"); } catch
1:      * (SQLException se) { System.out.println("Expected Exception is " +
1:      * se.getMessage()); } s.executeUpdate("drop trigger trig1");
1:      * 
1:      * System.out.println("Test 8b set savepoint(named) command inside the
1:      * trigger code"); s.executeUpdate("create trigger trig2 before insert on t1
1:      * for each statement call
1:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionSetSavepointNamed()");
1:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:      * System.out.println("FAIL 8b set savepoint(named) command inside the
1:      * trigger code"); } catch (SQLException se) { System.out.println("Expected
1:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:      * trig2");
1:      * 
1:      * System.out.println("Test 8c release savepoint command inside the trigger
1:      * code"); s.executeUpdate("create trigger trig3 before insert on t1 for
1:      * each statement call
1:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionReleaseSavepoint()");
1:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:      * System.out.println("FAIL 8c release savepoint command inside the trigger
1:      * code"); } catch (SQLException se) { System.out.println("Expected
1:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:      * trig3");
1:      * 
1:      * System.out.println("Test 8d rollback savepoint command inside the trigger
1:      * code"); s.executeUpdate("create trigger trig4 before insert on t1 for
1:      * each statement call
1:      * org.apache.derbyTesting.functionTests.tests.jdbcapi.savepointJdbc30::doConnectionRollbackSavepoint()");
1:      * try { s.executeUpdate("insert into t1 values(1,1)");
1:      * System.out.println("FAIL 8d rollback savepoint command inside the trigger
1:      * code"); } catch (SQLException se) { System.out.println("Expected
1:      * Exception is " + se.getMessage()); } s.executeUpdate("drop trigger
1:      * trig4"); con.rollback();
1:      */// end commented out test 8
1:     /**
1:      * Test 9 test savepoint name and verify case sensitivity
1:      */
1:     public void testSavepointName() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("myname");
1:         String savepointName = savepoint1.getSavepointName();
1:         assertEquals(savepointName, "myname");
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 10 test savepoint name case sensitivity
1:      */
1:     public void testNameCaseSensitivity() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:         String savepointName = savepoint1.getSavepointName();
1:         assertEquals(savepointName, "MyName");
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 11 rolling back a savepoint multiple times - should work
1:      */
1:     public void testRollbackMultipleTimes() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:         con.rollback(savepoint1);
1:         con.rollback(savepoint1);
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 12 releasing a savepoint multiple times - should not work
1:      */
1:     public void testReleaseMultipleTimes() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:         con.releaseSavepoint(savepoint1);
1:         try {
1:             con.releaseSavepoint(savepoint1);
1:             fail("FAIL 12 releasing a savepoint multiple times should fail");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 13 shouldn't be able to use a savepoint from earlier transaction
1:      * after setting autocommit on and off
1:      */
1:     public void testSavepointFromEarlierTransactionAfterToggleAutocommit()
1:             throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:         con.setAutoCommit(true);
1:         con.setAutoCommit(false);
1:         Savepoint savepoint2 = con.setSavepoint("MyName1");
1:         try {// shouldn't be able to use savepoint from earlier tranasaction
1:             // after setting autocommit on and off
1:             con.releaseSavepoint(savepoint1);
1:             fail("FAIL 13 shouldn't be able to use a savepoint from earlier "
1:                     + "transaction after setting autocommit on and off");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.releaseSavepoint(savepoint2);
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 14 cause a transaction rollback and that should release the internal
1:      * savepoint array
1:      */
1:     public void testRollbackReleasesSavepointArray() throws SQLException {
1:         Connection con = getConnection();
1:         Connection con2 = openDefaultConnection();
1:         con2.setAutoCommit(false);
1:         Statement s1, s2;
1:         s1 = createStatement();
1:         s1.executeUpdate("insert into t1 values(1,1)");
1:         s1.executeUpdate("insert into t1 values(2,0)");
1:         con.commit();
1:         s1.executeUpdate("update t1 set c11=c11+1 where c12 > 0");
1:         s2 = con2.createStatement();
1:         Savepoint savepoint1 = con2.setSavepoint("MyName");
1:         try {// following will get lock timeout which will rollback
1:             // transaction on c2
1:             s2.executeUpdate("update t1 set c11=c11+1 where c12 < 1");
1:             fail("FAIL 14 should have gotten lock time out");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("40XL1", se);
1:         }
1:         try {// the transaction rollback above should have removed the
1:             // savepoint MyName
1:             con2.releaseSavepoint(savepoint1);
1:             fail("FAIL 14 A non-user initiated transaction rollback should "
1:                     + "release the internal savepoint array");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         con.rollback();
1:         con2.rollback();
1:         s1.execute("delete from t1");
1:         con.commit();
1:     }
1: 
1:     /** Test 15 Check savepoints in batch */
1:     public void testSavepointsInBatch() throws SQLException {
1:         Connection con = getConnection();
1:         Statement s = createStatement();
1:         s.execute("delete from t1");
1:         s.addBatch("insert into t1 values(1,1)");
1:         s.addBatch("insert into t1 values(2,2)");
1:         Savepoint savepoint1 = con.setSavepoint();
1:         s.addBatch("insert into t1 values(3,3)");
1:         s.executeBatch();
1:         con.rollback(savepoint1);
1: 
1:         assertTableRowCount("T1", 0);
1:         con.rollback();
1:     }
1: 
1:     /** Test 16 grammar check for savepoint sq1 */
1:     public void testGrammarCheck() throws SQLException {
1:         Statement s = getConnection().createStatement();
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS");
1:             fail("FAIL 16 Should have gotten exception for missing ON ROLLBACK "
1:                     + "RETAIN CURSORS");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42X01", se);
1:         }
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 UNIQUE ON ROLLBACK RETAIN CURSORS "
1:                     + "ON ROLLBACK RETAIN CURSORS");
1:             fail("FAIL 16 Should have gotten exception for multiple ON ROLLBACK "
1:                     + "RETAIN CURSORS");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42613", se);
1:         }
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:                     + " RETAIN LOCKS");
1:             fail("FAIL 16 Should have gotten exception for multiple ON ROLLBACK "
1:                     + "RETAIN LOCKS");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42613", se);
1:         }
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 UNIQUE UNIQUE ON ROLLBACK RETAIN "
1:                     + "LOCKS ON ROLLBACK RETAIN CURSORS");
1:             fail("FAIL 16 Should have gotten exception for multiple UNIQUE keywords");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42613", se);
1:         }
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN CURSORS ON ROLLBACK "
1:                 + "RETAIN LOCKS");
1:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:         getConnection().rollback();
1:     }
1: 
1:     /** Test 17 */
1:     public void testNoNestedSavepointsWhenUsingSQL() throws SQLException {
1:         Statement s = getConnection().createStatement();
1:         s.executeUpdate("SAVEPOINT s1 UNIQUE ON ROLLBACK RETAIN LOCKS ON "
1:                 + "ROLLBACK RETAIN CURSORS");
1:         try {
1:             s.executeUpdate("SAVEPOINT s2 UNIQUE ON ROLLBACK RETAIN "
1:                     + "LOCKS ON ROLLBACK RETAIN CURSORS");
1:             fail("FAIL 17a Should have gotten exception for nested savepoints");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1:         }
1:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:         s.executeUpdate("SAVEPOINT s2 UNIQUE ON ROLLBACK RETAIN LOCKS ON "
1:                 + "ROLLBACK RETAIN CURSORS");
1:         getConnection().rollback();
1: 
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON "
1:                     + "ROLLBACK RETAIN CURSORS");
1:             fail("FAIL 17b Should have gotten exception for nested savepoints");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1:         }
1:         getConnection().rollback();
1:     }
1: 
1:     /** Test 18 */
1:     public void testNoNestedSavepointsInsideJdbcSavepoint() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         Statement s = getConnection().createStatement();
1:         // Following SQL savepoint will fail because we are trying to nest it
1:         // inside JDBC savepoint
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:                     + " RETAIN CURSORS");
1:             fail("FAIL 18 shouldn't be able set SQL savepoint nested inside "
1:                     + "JDBC savepoints");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1:         }
1:         // rollback the JDBC savepoint. Now since there are no user defined
1:         // savepoints, we can define SQL savepoint
1:         con.releaseSavepoint(savepoint1);
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON "
1:                 + "ROLLBACK RETAIN CURSORS");
1:         con.rollback();
1:     }
1: 
1:     /** Test 19 */
1:     public void testNoNestedSavepointsInsideSqlSavepoint() throws SQLException {
1:         Statement s = getConnection().createStatement();
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         try {
1:             s.executeUpdate("SAVEPOINT s2 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:                     + " RETAIN CURSORS");
1:             fail("FAIL 19 shouldn't be able set SQL savepoint nested inside "
1:                     + "SQL savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1:         }
1:         // rollback the SQL savepoint. Now since there are no user defined
1:         // savepoints, we can define SQL savepoint
1:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:         s.executeUpdate("SAVEPOINT s2 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         getConnection().rollback();
1:     }
1: 
1:     /** Test 20 */
1:     public void testRollbackSqlSavepointSameAsJdbc() throws SQLException {
1:         Connection con = getConnection();
1:         Statement s = createStatement();
1:         s.executeUpdate("DELETE FROM T1");
1:         con.commit();
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:         // Rollback to SQL savepoint and should see changes rolledback
1:         s.execute("ROLLBACK TO SAVEPOINT s1");
1: 
1:         ResultSet rs1 = s.executeQuery("select count(*) from t1");
1:         rs1.next();
1:         assertEquals(rs1.getInt(1), 0);
1:         con.rollback();
1:     }
1: 
1:     /** Test 21 */
1:     public void testReleaseSqlSavepointAndRollback() throws SQLException {
1:         Connection con = getConnection();
1:         Statement s = createStatement();
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(3,1)");
1:         // Release the SQL savepoint and then rollback the transaction and
1:         // should see changes rolledback
1:         s.executeUpdate("RELEASE TO SAVEPOINT s1");
1:         con.rollback();
1:         ResultSet rs1 = s.executeQuery("select count(*) from t1");
1:         rs1.next();
1:         assertEquals(rs1.getInt(1), 0);
1:         con.rollback();
1:     }
1: 
1:     /** Test 22 */
1:     public void testNoSqlSavepointStartingWithSYS() throws SQLException {
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("SAVEPOINT SYSs2 ON ROLLBACK RETAIN LOCKS ON "
1:                     + "ROLLBACK RETAIN CURSORS");
1:             fail("FAIL 22 shouldn't be able to create a SQL savepoint starting "
1:                     + "with name SYS");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42939", se);
1:         }
1:         getConnection().rollback();
1:     }
1: 
1:     /**
1:      * Test 23 - bug 5817 - make savepoint and release non-reserved keywords
1:      */
1:     public void testBug5817() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table savepoint (savepoint int, release int)");
1:         ResultSet rs1 = s.executeQuery("select count(*) from savepoint");
1:         rs1.next();
1:         assertEquals(" There should have been 0 rows in the table, but found "
1:                 + rs1.getInt(1), rs1.getInt(1), 0);
1: 
1:         s.execute("SAVEPOINT savepoint ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         s.executeUpdate("INSERT INTO savepoint VALUES(1,1)");
1:         s.execute("RELEASE SAVEPOINT savepoint");
1:         rs1 = s.executeQuery("select count(*) from savepoint");
1:         rs1.next();
1:         assertEquals("There should have been 1 rows in the table, but found "
1:                 + rs1.getInt(1), rs1.getInt(1), 1);
1: 
1:         s.execute("SAVEPOINT release ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         s.executeUpdate("INSERT INTO savepoint VALUES(2,1)");
1:         s.execute("ROLLBACK TO SAVEPOINT release");
1:         rs1 = s.executeQuery("select count(*) from savepoint");
1:         rs1.next();
1:         assertEquals(
1:                 "ERROR: There should have been 1 rows in the table, but found "
1:                         + rs1.getInt(1), rs1.getInt(1), 1);
1: 
1:         s.execute("RELEASE SAVEPOINT release");
1:         getConnection().rollback();
1:     }
1: 
1:     /**
1:      * Test 24 Savepoint name can't exceed 128 characters
1:      */
1:     public void testNameLengthMax128Chars() throws SQLException {
1:         try {
1:             getConnection()
1:                     .setSavepoint(
1:                             "MyName12345678901234567890123456789"
1:                                     + "01234567890123456789012345678901234567890123456789012345"
1:                                     + "678901234567890123456789012345678901234567890");
1:             fail("FAIL 24 shouldn't be able to create a SQL savepoint with "
1:                     + "name exceeding 128 characters");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42622", se);
1:         }
1:         getConnection().rollback();
1:     }
1: 
1:     /** Test 25 */
1:     public void testNoSqlSavepointStartingWithSYSThroughJdbc()
1:             throws SQLException {
1:         try {
1:             getConnection().setSavepoint("SYSs2");
1:             fail("FAIL 25 shouldn't be able to create a SQL savepoint starting with name SYS through jdbc");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("42939", se);
1:         }
1:         getConnection().rollback();
1:     }
1: 
1:     /**
1:      * bug 4451 - Test 26a pass Null value to rollback bug 5374 - Passing a null
1:      * savepoint to rollback or release method used to give a npe in JCC it
1:      * should give a SQLException aying "Cannot rollback to a null savepoint"
1:      */
1:     public void testRollbackNullSavepoint() throws SQLException {
1:         try {
1:             getConnection().rollback((Savepoint) null);
1:             fail("FAIL 26a rollback of null savepoint did not raise error ");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B001", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("3B502", se);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Test 26b pass Null value to releaseSavepoint
1:      */
1:     public void testReleaseNullSavepoint() throws SQLException {
1:         try {
1:             getConnection().releaseSavepoint((Savepoint) null);
1:             fail("FAIL 26b release of null savepoint did not raise error ");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B001", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("3B502", se);
1:             }
1:         }
1:     }
1: 
1:     /** ********************* */
1: 
1:     /*
1:      * The following tests have nested savepoints through JDBC calls. When
1:      * coming through the network client these nested JDBC savepoint calls are
1:      * translated into equivalent SQL savepoint statements. But we do not allow
1:      * nested savepoints coming through SQL statements and hence these tests
1:      * can't be run under DRDA framework.
1:      */
1: 
1:     /**
1:      * Test40 - We internally generate a unique name for unnamed savepoints. If
1:      * a named savepoint uses the currently used internal savepoint name, we
1:      * won't get an exception thrown for it because we prepend external saves
1:      * with "e." to avoid name conflicts.
1:      */
1:     public void xtestNoConflictWithGeneratedName() throws SQLException {
1:         Connection con = getConnection();
1: 
1:         con.setSavepoint();
1:         con.setSavepoint("i.SAVEPT0");
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test41 - Rolling back to a savepoint will release all the savepoints
1:      * created after that savepoint.
1:      */
1:     public void xtestRollbackWillReleaseLaterSavepoints() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         Statement s = createStatement();
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,1)");
1: 
1:         Savepoint savepoint2 = con.setSavepoint("s1");
1:         s.executeUpdate("INSERT INTO T1 VALUES(2,1)");
1: 
1:         Savepoint savepoint3 = con.setSavepoint("s2");
1:         s.executeUpdate("INSERT INTO T1 VALUES(3,1)");
1: 
1:         // Rollback to first named savepoint s1. This will internally release
1:         // the second named savepoint s2.
1:         con.rollback(savepoint2);
1:         assertTableRowCount("T1", 1);
1: 
1:         // Trying to release second named savepoint s2 should throw exception.
1:         try {
1:             con.releaseSavepoint(savepoint3);
1:             fail("FAIL 41a release of rolled back savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:         // Trying to rollback second named savepoint s2 should throw exception.
1:         try {
1:             con.rollback(savepoint3);
1:             fail("FAIL 41b release of rolled back savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1: 
1:         // Release the unnamed named savepoint.
1:         con.rollback(savepoint1);
1:         assertTableRowCount("T1", 0);
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test42 - Rollback on a connection will release all the savepoints created
1:      * for that transaction
1:      */
1:     public void xtestRollbackWillReleaseActiveSavepoints() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         con.rollback();
1:         try {
1:             con.rollback(savepoint1);
1:             fail("FAIL 42 release of rolled back savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:     }
1: 
1:     /**
1:      * Test42a - Commit on a connection will release all the savepoints created
1:      * for that transaction
1:      */
1:     public void xtestCommitWillReleaseActiveSavepoints() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         con.commit();
1:         try {
1:             con.rollback(savepoint1);
1:             fail("FAIL 42a Rollback after commit.");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B001", se);
1:         }
1:     }
1: 
1:     /**
1:      * Test43 - After releasing a savepoint, should be able to reuse it.
1:      */
1:     public void xtestReuseNameAfterRelease() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("s1");
1:         try {
1:             con.setSavepoint("s1");
1:             fail("Should not be able to set two savepoints with the same name");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B501", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("3B002", se);
1:             }
1:         }
1:         con.releaseSavepoint(savepoint1);
1:         con.setSavepoint("s1");
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 45 reuse savepoint name after rollback - should not work
1:      */
1:     public void xtestReuseNameAfterRollback() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint("MyName");
1:         con.rollback(savepoint1);
1:         try {
1:             con.setSavepoint("MyName");
1:             fail("FAIL 45 reuse of savepoint name after rollback should fail");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             if (usingEmbedded()) {
1:                 assertSQLState("3B501", se);
1:             } else if (usingDerbyNetClient()) {
1:                 assertSQLState("3B002", se);
1:             }
1:         }
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 46 bug 5145 Cursors declared before and within the savepoint unit
1:      * will be closed when rolling back the savepoint
1:      */
1:     public void xtestCursorsCloseOnRollback() throws SQLException {
1:         Connection con = getConnection();
1:         Statement sWithHold = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         Statement s = createStatement();
1:         s.executeUpdate("DELETE FROM T1");
1:         s.executeUpdate("INSERT INTO T1 VALUES(19,1)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(19,2)");
1:         s.executeUpdate("INSERT INTO T1 VALUES(19,3)");
1:         ResultSet rs1 = s.executeQuery("select * from t1");
1:         rs1.next();
1:         ResultSet rs1WithHold = sWithHold.executeQuery("select * from t1");
1:         rs1WithHold.next();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         ResultSet rs2 = s.executeQuery("select * from t1");
1:         rs2.next();
1:         ResultSet rs2WithHold = sWithHold.executeQuery("select * from t1");
1:         rs2WithHold.next();
1:         con.rollback(savepoint1);
1:         try {// resultset declared outside the savepoint unit should be
1:             // closed at this point after the rollback to savepoint
1:             rs1.next();
1:             fail("FAIL 46 shouldn't be able to use a resultset (declared "
1:                     + "before the savepoint unit) after the rollback to savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XCL16", se);
1:         }
1:         try {// holdable resultset declared outside the savepoint unit should
1:             // be closed at this point after the rollback to savepoint
1:             rs1WithHold.next();
1:             fail("FAIL 46 shouldn't be able to use a holdable resultset "
1:                     + "(declared before the savepoint unit) after the rollback "
1:                     + "to savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XCL16", se);
1:         }
1:         try {// resultset declared within the savepoint unit should be closed
1:             // at this point after the rollback to savepoint
1:             rs2.next();
1:             fail("FAIL 46 shouldn't be able to use a resultset (declared within "
1:                     + "the savepoint unit) after the rollback to savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XCL16", se);
1:         }
1:         try {// holdable resultset declared within the savepoint unit should
1:             // be closed at this point after the rollback to savepoint
1:             rs2WithHold.next();
1:             fail("FAIL 46 shouldn't be able to use a holdable resultset "
1:                     + "(declared within the savepoint unit) after the rollback "
1:                     + "to savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("XCL16", se);
1:         }
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 47 multiple tests for getSavepointId()
1:      */
1:     public void xtestGetSavepoint() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         Savepoint savepoint2 = con.setSavepoint();
1:         savepoint1.getSavepointId();
1:         savepoint2.getSavepointId();
1:         con.releaseSavepoint(savepoint2);
1:         savepoint2 = con.setSavepoint();
1:         savepoint2.getSavepointId();
1:         con.commit();
1:         savepoint2 = con.setSavepoint();
1:         savepoint2.getSavepointId();
1:         con.rollback();
1:         savepoint2 = con.setSavepoint();
1:         savepoint2.getSavepointId();
1:         con.rollback();
1:     }
1: 
1:     /**
1:      * Test 48
1:      */
1:     public void xtestNestedSavepoints() throws SQLException {
1:         Connection con = getConnection();
1:         Savepoint savepoint1 = con.setSavepoint();
1:         Savepoint savepoint2 = con.setSavepoint();
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:                     + " RETAIN CURSORS");
1:             fail("FAIL 48 shouldn't be able set SQL savepoint nested inside "
1:                     + "JDBC/SQL savepoints");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1:         }
1:         // rollback JDBC savepoint but still can't have SQL savepoint because
1:         // there is still one JDBC savepoint
1:         con.releaseSavepoint(savepoint2);
1:         try {
1:             s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK"
1:                     + " RETAIN CURSORS");
1:             fail("FAIL 48 Should have gotten exception for nested SQL savepoint");
1:         } catch (SQLException se) {
1:             // Expected exception.
1:             assertSQLState("3B002", se);
1: 
1:         }
1:         con.releaseSavepoint(savepoint1); // rollback last JDBC savepoint and
1:         // now try SQL savepoint again
1:         s.executeUpdate("SAVEPOINT s1 ON ROLLBACK RETAIN LOCKS ON ROLLBACK "
1:                 + "RETAIN CURSORS");
1:         con.rollback();
1:     }
1: 
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d2719a2
/////////////////////////////////////////////////////////////////////////
1:      * @return A suite containing embedded, client and embedded with XA suites
============================================================================