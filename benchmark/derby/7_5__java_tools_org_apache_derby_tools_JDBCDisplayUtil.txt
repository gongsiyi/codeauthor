1:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.tools.JDBCDisplayUtil
1:985fc85: 
1:3dc2ce4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:3dc2ce4:    contributor license agreements.  See the NOTICE file distributed with
1:3dc2ce4:    this work for additional information regarding copyright ownership.
1:3dc2ce4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:3dc2ce4:    (the "License"); you may not use this file except in compliance with
1:3dc2ce4:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:fe77ca5: 
3:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package org.apache.derby.tools;
1:fe77ca5: 
1:fe77ca5: import java.io.PrintStream;
1:fe77ca5: import java.io.PrintWriter;
1:fe77ca5: import java.io.File;
1:fe77ca5: import java.io.FileNotFoundException;
1:fe77ca5: import java.io.IOException;
1:fe77ca5: 
1:663dfd3: import java.security.AccessController;
1:fe77ca5: import java.sql.Connection;
1:fe77ca5: import java.sql.SQLException;
1:fe77ca5: import java.sql.SQLWarning;
1:fe77ca5: import java.sql.Statement;
1:fe77ca5: import java.sql.PreparedStatement;
1:fe77ca5: import java.sql.ResultSet;
1:fe77ca5: import java.sql.ResultSetMetaData;
1:fe77ca5: import java.sql.Types;
1:fe77ca5: 
1:fe77ca5: import java.util.Properties;
1:fe77ca5: import java.util.Enumeration;
1:7b5fc1e: import java.util.ArrayList;
1:7b5fc1e: import java.util.List;
1:fe77ca5: import java.util.Vector;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.impl.tools.ij.ijException;
1:fe77ca5: 
3:fe77ca5: /**
1:fe77ca5: 	
1:fe77ca5: 	This class contains utility methods for displaying JDBC objects and results.
1:fe77ca5: 	
1:fe77ca5: 	<p>
1:fe77ca5: 	All of the methods are static. The output stream
1:fe77ca5: 	to write to is always passed in, along with the
1:fe77ca5: 	JDBC objects to display.
1:fe77ca5: 
1:fe77ca5:  */
1:a8ff4fd: public class JDBCDisplayUtil {
1:fe77ca5: 
1:fe77ca5: 	// used to control display
1:fe77ca5: 	static final private int MINWIDTH = 4;
1:fe77ca5: 	static private int maxWidth = 128;
1:80d6162:     static private boolean showSelectCount = false;
1:fe77ca5: 
1:fe77ca5:     static {
1:fe77ca5:         // initialize the locale support functions to default value of JVM 
1:fe77ca5:         LocalizedResource.getInstance();
1:fe77ca5:     }
1:fe77ca5: 
2:fe77ca5: 	//-----------------------------------------------------------------
1:80d6162: 	// Accessors
1:80d6162: 
1:80d6162:     public  static  boolean getShowSelectCount() { return showSelectCount; }
1:80d6162:     public  static  void    setShowSelectCount( boolean newValue ) { showSelectCount = newValue; }
1:80d6162: 
1:80d6162: 	//-----------------------------------------------------------------
1:fe77ca5: 	// Methods for displaying and checking errors
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print information about the exception to the given PrintWriter.
1:fe77ca5: 		For non-SQLExceptions, does a stack trace. For SQLExceptions,
1:fe77ca5: 		print a standard error message and walk the list, if any.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param e the exception to display
1:fe77ca5: 	 */
1:fe77ca5: 	static public void ShowException(PrintWriter out, Throwable e) {
1:fe77ca5: 		if (e == null) return;
1:fe77ca5: 
1:fe77ca5: 		if (e instanceof SQLException)
1:fe77ca5: 			ShowSQLException(out, (SQLException)e);
1:fe77ca5: 		else
1:fe77ca5: 			e.printStackTrace(out);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print information about the SQL exception to the given PrintWriter.
1:fe77ca5: 		Walk the list of exceptions, if any.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param e the exception to display
1:fe77ca5: 	 */
1:fe77ca5: 	static public void ShowSQLException(PrintWriter out, SQLException e) {
1:fe77ca5: 		String errorCode;
1:fe77ca5: 
1:663dfd3: 		if (getSystemBoolean("ij.showErrorCode")) {
1:fe77ca5: 			errorCode = LocalizedResource.getMessage("UT_Error0", LocalizedResource.getNumber(e.getErrorCode()));
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			errorCode = "";
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		while (e!=null) {
1:fe77ca5: 			String p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst"));
1:fe77ca5: 			String p2 = mapNull(e.getMessage(),LocalizedResource.getMessage("UT_NoMessa"));
1:fe77ca5: 			out.println(LocalizedResource.getMessage("UT_Error012", p1, p2,errorCode));
1:fe77ca5: 			doTrace(out, e);
1:fe77ca5: 			e=e.getNextException();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print information about the SQL warnings for the connection
1:fe77ca5: 		to the given PrintWriter.
1:fe77ca5: 		Walks the list of exceptions, if any.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param theConnection the connection that may have warnings.
1:fe77ca5: 	 */
1:fe77ca5: 	static public void ShowWarnings(PrintWriter out, Connection theConnection) {
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET CONNECTION WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (theConnection != null) {
1:fe77ca5: 			ShowWarnings(out, theConnection.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (theConnection != null) {
1:fe77ca5: 			theConnection.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowWarnings
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param warning the SQLWarning
1:fe77ca5: 	*/
1:fe77ca5: 	static public void ShowWarnings(PrintWriter out, SQLWarning warning) {
1:fe77ca5: 		while (warning != null) {
1:fe77ca5: 			String p1 = mapNull(warning.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst_7"));
1:fe77ca5: 			String p2 = mapNull(warning.getMessage(),LocalizedResource.getMessage("UT_NoMessa_8"));
1:fe77ca5: 			out.println(LocalizedResource.getMessage("UT_Warni01", p1, p2));
1:fe77ca5: 			warning = warning.getNextWarning();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print information about the SQL warnings for the ResultSet
1:fe77ca5: 		to the given PrintWriter.
1:fe77ca5: 		Walk the list of exceptions, if any.
1:fe77ca5: 	
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param rs the ResultSet that may have warnings on it
1:fe77ca5: 	 */
1:fe77ca5: 	static public void ShowWarnings(PrintWriter out, ResultSet rs) {
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET RESULTSET WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (rs != null) {
1:fe77ca5: 			ShowWarnings(out, rs.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (rs != null) {
1:fe77ca5: 			rs.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowResultSetWarnings
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print information about the SQL warnings for the Statement
1:fe77ca5: 		to the given PrintWriter.
1:fe77ca5: 		Walks the list of exceptions, if any.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param s the Statement that may have warnings on it
1:fe77ca5: 	 */
1:fe77ca5: 	static public void ShowWarnings(PrintWriter out, Statement s)
1:fe77ca5: 	{
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET STATEMENT WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (s != null) {
1:fe77ca5: 			ShowWarnings(out, s.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (s != null) {
1:fe77ca5: 			s.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowStatementWarnings
1:fe77ca5: 
1:fe77ca5: 	//-----------------------------------------------------------------
1:fe77ca5: 	// Methods for displaying and checking results
1:fe77ca5: 
1:fe77ca5: 	// REMIND: make this configurable...
1:fe77ca5: 	static final private int MAX_RETRIES = 0;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Pretty-print the results of a statement that has been executed.
1:fe77ca5: 		If it is a select, gathers and prints the results.  Display
1:fe77ca5: 		partial results up to the first error.
1:fe77ca5: 		If it is not a SELECT, determine if rows were involved or not,
1:fe77ca5: 		and print the appropriate message.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param stmt the Statement to display
1:fe77ca5: 		@param conn the Connection against which the statement was executed
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException on JDBC access failure
1:fe77ca5: 	 */
1:fe77ca5: 	static public void DisplayResults(PrintWriter out, Statement stmt, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayResults( out, stmt, conn, 0, null, null);			
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static private void indent_DisplayResults
1:a9217e9: 	(PrintWriter out, Statement stmt, Connection conn, int indentLevel,
1:a9217e9: 	 int[] displayColumns, int[] displayColumnWidths)
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:fe77ca5: 		checkNotNull(stmt, "Statement");
1:fe77ca5: 
1:fe77ca5: 		ResultSet rs = stmt.getResultSet();
1:fe77ca5: 		if (rs != null) {
1:a9217e9: 			indent_DisplayResults(out, rs, conn, indentLevel, 
1:a9217e9: 								  displayColumns, displayColumnWidths);
1:fe77ca5: 			rs.close(); // let the result set go away
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out,stmt);
1:fe77ca5: 	} // DisplayResults
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param count the update count to display
1:fe77ca5: 		@param indentLevel number of tab stops to indent line
1:fe77ca5: 	 */
1:fe77ca5: 	static void DisplayUpdateCount(PrintWriter out, int count, int indentLevel ) {
1:fe77ca5: 		if (count == 1) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowInserUpdatDelet"));
1:fe77ca5: 		}
1:fe77ca5: 		else if (count >= 0) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_0RowsInserUpdatDelet", LocalizedResource.getNumber(count)));
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_StateExecu"));
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:a9217e9: 	    Calculates column display widths from the default widths of the
1:a9217e9: 	    result set.
1:fe77ca5: 	 */
1:a9217e9: 	static private int[] getColumnDisplayWidths(ResultSetMetaData rsmd, int[] dispColumns,
1:a9217e9: 												boolean localizedOutput)
1:fe77ca5: 		throws SQLException {
1:a9217e9: 		int count = (dispColumns == null) ? rsmd.getColumnCount() : dispColumns.length;
1:a9217e9: 		int[] widths = new int[count];
1:fe77ca5: 
1:a9217e9: 		for(int i=0; i<count; i++) {
1:a9217e9: 			int colnum = (dispColumns == null) ? (i + 1) : dispColumns[i];
1:a9217e9: 			int dispsize = localizedOutput
1:a9217e9: 				? LocalizedResource.getInstance().getColumnDisplaySize(rsmd, colnum)
1:a9217e9:                 : rsmd.getColumnDisplaySize(colnum);
1:a9217e9: 			widths[i] = Math.min(maxWidth,
1:a9217e9: 				Math.max((rsmd.isNullable(colnum) == ResultSetMetaData.columnNoNulls)?
1:a9217e9: 				0 : MINWIDTH, dispsize));
1:fe77ca5: 		}
1:a9217e9: 		return widths;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     /**
1:fe77ca5:        @param out the place to write to
1:e5ca925:        @param resultSets list of <code>ResultSet</code>s to display
1:e5ca925:        @param conn the connection against which the <code>ResultSet</code>s
1:e5ca925:             were retrieved
1:e5ca925:        @param displayColumns column numbers to display, <code>null</code> if all
1:e5ca925:        @param displayColumnWidths column widths, in characters, if
1:e5ca925:             <code>displayColumns</code> is specified
1:fe77ca5: 
1:fe77ca5:        @exception SQLException on JDBC access failure
1:fe77ca5:     */
1:16d3334:     static public void DisplayMultipleResults(PrintWriter out, List<ResultSet> resultSets,
1:7b5fc1e:                                               Connection conn,
1:7b5fc1e:                                               int[] displayColumns,
1:7b5fc1e:                                               int[] displayColumnWidths)
1:fe77ca5:         throws SQLException
1:fe77ca5:     {
1:e5ca925:         indent_DisplayResults( out, resultSets, conn, 0, displayColumns,
1:7b5fc1e:                                displayColumnWidths);
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5:     /**
2:7b5fc1e:        @param out the place to write to
1:e5ca925:        @param rs the <code>ResultSet</code> to display
1:e5ca925:        @param conn the connection against which the <code>ResultSet</code>
1:e5ca925:             was retrieved
1:e5ca925:        @param displayColumns column numbers to display, <code>null</code> if all
1:e5ca925:        @param displayColumnWidths column widths, in characters, if
1:e5ca925:             <code>displayColumns</code> is specified
1:fe77ca5: 
2:7b5fc1e:        @exception SQLException on JDBC access failure
1:fe77ca5:     */
1:a9217e9: 	static public void DisplayResults(PrintWriter out, ResultSet rs, Connection conn,
1:a9217e9: 									  int[] displayColumns, int[] displayColumnWidths)
1:7b5fc1e: 		throws SQLException
1:7b5fc1e: 	{
1:a9217e9: 		indent_DisplayResults( out, rs, conn, 0, displayColumns, 
1:a9217e9: 							   displayColumnWidths);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:     static private void indent_DisplayResults
1:e5ca925:         (PrintWriter out, ResultSet rs, Connection conn, int indentLevel,
1:7b5fc1e:          int[] displayColumns, int[] displayColumnWidths)
1:7b5fc1e:         throws SQLException {
1:16d3334:         List<ResultSet> resultSets = new ArrayList<ResultSet>();
1:7b5fc1e:         resultSets.add(rs);
1:7b5fc1e:         indent_DisplayResults( out, resultSets, conn, 0, displayColumns, 
1:7b5fc1e:                                displayColumnWidths);
1:fe77ca5:     }
1:fe77ca5: 
2:7b5fc1e:     static private void indent_DisplayResults
1:16d3334:         (PrintWriter out, List<ResultSet> resultSets, Connection conn, int indentLevel,
1:7b5fc1e:          int[] displayColumns, int[] displayColumnWidths)
1:7b5fc1e:         throws SQLException {
1:fe77ca5: 
1:7b5fc1e:         ResultSetMetaData rsmd = null;
1:e5ca925: 
1:7b5fc1e:         //get metadata from the first ResultSet
1:7b5fc1e:         if (resultSets != null && resultSets.size() > 0)
1:16d3334:             rsmd = (resultSets.get(0)).getMetaData();
1:e5ca925: 
1:fe77ca5:         checkNotNull(rsmd, "ResultSetMetaData");
1:16d3334:         Vector<ResultSet> nestedResults;
1:fe77ca5:         int numberOfRowsSelected = 0;
1:fe77ca5: 
1:fe77ca5:         // autocommit must be off or the nested cursors
1:fe77ca5:         // are closed when the outer statement completes.
1:fe77ca5:         if (!conn.getAutoCommit())
1:16d3334:             nestedResults = new Vector<ResultSet>();
1:fe77ca5:         else
1:fe77ca5:             nestedResults = null;
1:fe77ca5: 
1:7b5fc1e:         if(displayColumnWidths == null)
1:7b5fc1e:             displayColumnWidths = getColumnDisplayWidths(rsmd,
1:e5ca925:                                                          displayColumns,true);
1:fe77ca5: 
1:7b5fc1e:         int len = indent_DisplayBanner(out,rsmd, indentLevel, displayColumns,
1:7b5fc1e:                                        displayColumnWidths);
1:7b5fc1e: 
1:fe77ca5:         // When displaying rows, keep going past errors
1:fe77ca5:         // unless/until the maximum # of errors is reached.
1:fe77ca5:         int retry = 0;
7:7b5fc1e: 
1:7b5fc1e:         ResultSet rs = null;
1:fe77ca5:         boolean doNext = true;
1:7b5fc1e:         for (int i = 0; i< resultSets.size(); i++) {
1:16d3334:             rs = resultSets.get(i);
1:7b5fc1e:             doNext = true;
1:7b5fc1e:             while (doNext){
1:fe77ca5:                 try {
1:fe77ca5:                     doNext = rs.next();
1:fe77ca5:                     if (doNext) {
1:fe77ca5: 
1:e5ca925:                         DisplayRow(out, rs, rsmd, len, nestedResults, conn,
1:e5ca925:                                    indentLevel, displayColumns,
1:7b5fc1e:                                    displayColumnWidths);
1:fe77ca5:                         ShowWarnings(out, rs);
1:fe77ca5:                         numberOfRowsSelected++;
1:fe77ca5:                     }
1:fe77ca5:                 } catch (SQLException e) {
1:fe77ca5:                     // REVISIT: might want to check the exception
1:fe77ca5:                     // and for some, not bother with the retry.
1:fe77ca5:                     if (++retry > MAX_RETRIES)
1:fe77ca5:                         throw e;
1:fe77ca5:                     else
1:fe77ca5:                         ShowSQLException(out, e);
1:fe77ca5:                 }
1:fe77ca5:             }
1:fe77ca5:         }
1:fe77ca5:         if (showSelectCount == true) {
1:fe77ca5:             if (numberOfRowsSelected == 1) {
1:fe77ca5:                 out.println();
1:e5ca925:                 indentedPrintLine(out, indentLevel,
1:e5ca925:                                   LocalizedResource.getMessage("UT_1RowSelec"));
1:fe77ca5:             } else if (numberOfRowsSelected >= 0) {
1:fe77ca5:                 out.println();
1:e5ca925:                 indentedPrintLine(out, indentLevel,
1:e5ca925:                         LocalizedResource.getMessage("UT_0RowsSelec",
1:e5ca925:                             LocalizedResource.getNumber(numberOfRowsSelected)));
1:fe77ca5:             }
1:fe77ca5:         }
1:fe77ca5: 
1:fe77ca5:         DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5:         nestedResults = null;
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param nr the vector of results
2:fe77ca5: 		@param conn the Connection against which the ResultSet was retrieved
1:fe77ca5: 		@param indentLevel number of tab stops to indent line
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException thrown on access error
1:fe77ca5: 	 */
1:16d3334: 	static private void DisplayNestedResults(PrintWriter out, Vector<ResultSet> nr, Connection conn, int indentLevel )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:fe77ca5: 		if (nr == null) return;
1:fe77ca5: 
1:fe77ca5: 		String b=LocalizedResource.getMessage("UT_JDBCDisplayUtil_16");
1:fe77ca5: 		String oldString="0";
1:fe77ca5: 
1:fe77ca5: 		for (int i=0; i < nr.size(); i++) {
1:fe77ca5: 			LocalizedResource.OutputWriter().println();
1:fe77ca5: 
1:fe77ca5: 			//just too clever to get the extra +s
1:fe77ca5: 			String t = Integer.toString(i);
1:fe77ca5: 			if (t.length() > oldString.length()) {
1:fe77ca5: 				oldString = t;
1:fe77ca5: 				b=b+LocalizedResource.getMessage("UT_JDBCDisplayUtil_17");
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			LocalizedResource.OutputWriter().println(b);
1:fe77ca5: 			LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("UT_Resul0", LocalizedResource.getNumber(i)));
1:fe77ca5: 			LocalizedResource.OutputWriter().println(b);
1:a9217e9: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn,
1:a9217e9: 								  indentLevel, null, null);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Fetch the next row of the result set, and if it
1:fe77ca5: 		exists format and display a banner and the row.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param rs the ResultSet in use
1:fe77ca5: 		@param conn the Connection against which the ResultSet was retrieved
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException on JDBC access failure
1:fe77ca5: 	 */
1:fe77ca5: 	static public void DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null
1:a9217e9: 							   : getColumnDisplayWidths(rs.getMetaData(), null, true));
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private void indent_DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel,
1:a9217e9: 											  int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:16d3334: 		Vector<ResultSet> nestedResults;
1:fe77ca5: 
1:fe77ca5: 		// autocommit must be off or the nested cursors
1:fe77ca5: 		// are closed when the outer statement completes.
1:fe77ca5: 		if (!conn.getAutoCommit())
1:16d3334: 			nestedResults = new Vector<ResultSet>();
1:fe77ca5: 		else
1:fe77ca5: 			nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 		checkNotNull(rs, "ResultSet");
1:fe77ca5: 
2:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		checkNotNull(rsmd, "ResultSetMetaData");
1:fe77ca5: 
1:fe77ca5: 		// Only print stuff out if there is a row to be had.
1:fe77ca5: 		if (rs.next()) {
1:a9217e9: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:a9217e9:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1:a9217e9: 					   null, null );
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out, rs);
1:fe77ca5: 
1:fe77ca5: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5: 		nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 	} // DisplayNextRow
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Display the current row of the result set along with
1:fe77ca5: 		a banner. Assume the result set is on a row.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param rs the ResultSet in use
1:fe77ca5: 		@param conn the Connection against which the ResultSet was retrieved
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException on JDBC access failure
1:fe77ca5: 	 */
1:fe77ca5: 	static public void DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null
1:a9217e9: 								  : getColumnDisplayWidths(rs.getMetaData(), null, true) );
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private void indent_DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn, 
1:a9217e9: 												 int indentLevel, int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:16d3334: 		Vector<ResultSet> nestedResults;
1:fe77ca5: 
1:fe77ca5: 		if (rs == null) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
1:fe77ca5: 			return;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// autocommit must be off or the nested cursors
1:fe77ca5: 		// are closed when the outer statement completes.
1:fe77ca5: 		if (!conn.getAutoCommit())
1:16d3334: 			nestedResults = new Vector<ResultSet>();
1:fe77ca5: 		else
1:fe77ca5: 			nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		checkNotNull(rsmd, "ResultSetMetaData");
1:fe77ca5: 
1:a9217e9: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:a9217e9:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1:a9217e9: 				   displayColumns, displayColumnWidths );
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out, rs);
1:fe77ca5: 
1:fe77ca5: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5: 		nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 	} // DisplayNextRow
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print a banner containing the column labels separated with '|'s
1:fe77ca5: 		and a line of '-'s.  Each field is as wide as the display
1:fe77ca5: 		width reported by the metadata.
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param rsmd the ResultSetMetaData to use
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException on JDBC access failure
1:fe77ca5: 	 */
1:fe77ca5: 	static public int DisplayBanner(PrintWriter out, ResultSetMetaData rsmd )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		return indent_DisplayBanner( out, rsmd, 0, null, 
1:a9217e9: 									 getColumnDisplayWidths(rsmd, null, true) );
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private int indent_DisplayBanner(PrintWriter out, ResultSetMetaData rsmd, int indentLevel,
1:a9217e9: 											int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException	{
1:fe77ca5: 
1:fe77ca5: 		StringBuffer buf = new StringBuffer();
1:fe77ca5: 
1:a9217e9: 		int numCols = displayColumnWidths.length;
1:fe77ca5: 		int rowLen;
1:fe77ca5: 
1:fe77ca5: 		// do some precalculation so the buffer is allocated only once
1:fe77ca5: 		// buffer is twice as long as the display length plus one for a newline
1:fe77ca5: 		rowLen = (numCols - 1); // for the column separators
1:a9217e9: 		for (int i=1; i <= numCols; i++)
1:a9217e9: 			rowLen += displayColumnWidths[i-1];
1:fe77ca5: 		buf.ensureCapacity(rowLen);
1:fe77ca5: 
1:fe77ca5: 		// get column header info
1:fe77ca5: 		// truncate it to the column display width
1:fe77ca5: 		// add a bar between each item.
2:fe77ca5: 		for (int i=1; i <= numCols; i++) {
1:a9217e9: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1:fe77ca5: 
1:fe77ca5: 			if (i>1)
1:fe77ca5: 				buf.append('|');
1:fe77ca5: 
1:a9217e9: 			String s = rsmd.getColumnLabel(colnum);
1:fe77ca5: 
1:a9217e9: 			int w = displayColumnWidths[i-1];
1:fe77ca5: 
1:fe77ca5: 			if (s.length() < w) {
1:23ddbc8: 				
1:23ddbc8: 				buf.append(s);
1:fe77ca5: 
1:fe77ca5: 				// try to paste on big chunks of space at a time.
1:23ddbc8: 				int k = w - s.length();
1:23ddbc8: 				for (; k >= 64; k -= 64)
1:23ddbc8: 					buf.append(
1:fe77ca5:           "                                                                ");
1:23ddbc8: 				for (; k >= 16; k -= 16)
1:23ddbc8: 					buf.append("                ");
1:23ddbc8: 				for (; k >= 4; k -= 4)
1:23ddbc8: 					buf.append("    ");
1:23ddbc8: 				for (; k > 0; k--)
1:23ddbc8: 					buf.append(' ');
1:fe77ca5: 			}
1:fe77ca5: 			else if (s.length() > w)  {
1:fe77ca5: 				if (w > 1) 
1:fe77ca5: 					buf.append(s.substring(0,w-1));
1:fe77ca5: 				if (w > 0) 
1:fe77ca5: 					buf.append('&');
1:fe77ca5: 			}
1:fe77ca5: 			else {
1:fe77ca5: 				buf.append(s);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		buf.setLength(Math.min(rowLen, 1024));
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 		// now print a row of '-'s
1:fe77ca5: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
1:fe77ca5: 			buf.setCharAt(i, '-');
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 		buf = null;
1:fe77ca5: 
1:fe77ca5: 		return rowLen;
1:fe77ca5: 	} // DisplayBanner
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Print one row of a result set, padding each field to the
1:fe77ca5: 		display width and separating them with '|'s
1:fe77ca5: 
1:fe77ca5: 		@param out the place to write to
1:fe77ca5: 		@param rs the ResultSet to use
1:fe77ca5: 		@param rsmd the ResultSetMetaData to use
1:fe77ca5: 		@param rowLen
1:fe77ca5: 		@param nestedResults
1:fe77ca5: 		@param conn
1:fe77ca5: 		@param indentLevel number of tab stops to indent line
1:a9217e9: 	    @param displayColumns A list of column numbers to display
1:a9217e9: 	    @param displayColumnWidths If displayColumns is set, the width of
1:a9217e9: 								columns to display, in characters.
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException thrown on JDBC access failure
1:fe77ca5: 	 */
1:16d3334: 	static private void DisplayRow(PrintWriter out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector<ResultSet> nestedResults, Connection conn, int indentLevel,
1:a9217e9: 								   int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:fe77ca5: 		StringBuffer buf = new StringBuffer();
1:fe77ca5: 		buf.ensureCapacity(rowLen);
1:fe77ca5: 
1:a9217e9: 		int numCols = displayColumnWidths.length;
1:fe77ca5: 		int i;
1:fe77ca5: 
1:fe77ca5: 		// get column header info
1:fe77ca5: 		// truncate it to the column display width
1:fe77ca5: 		// add a bar between each item.
1:fe77ca5: 		for (i=1; i <= numCols; i++){
1:a9217e9: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1:fe77ca5: 			if (i>1)
1:fe77ca5: 				buf.append('|');
1:fe77ca5: 
1:fe77ca5: 			String s;
1:a9217e9: 			switch (rsmd.getColumnType(colnum)) {
1:fe77ca5: 			default:
1:a9217e9: 				s = LocalizedResource.getInstance().getLocalizedString(rs, rsmd, colnum );
1:fe77ca5: 				break;
1:1a4ea31: 			case Types.JAVA_OBJECT:
1:fe77ca5: 			case Types.OTHER:
1:fe77ca5: 			{
1:a9217e9: 				Object o = rs.getObject(colnum);
1:fe77ca5: 				if (o == null) { s = "NULL"; }
1:fe77ca5: 				else if (o instanceof ResultSet && nestedResults != null)
1:fe77ca5: 				{
1:fe77ca5: 					s = LocalizedResource.getMessage("UT_Resul0_20", LocalizedResource.getNumber(nestedResults.size()));
1:16d3334: 					nestedResults.addElement( (ResultSet) o);
1:fe77ca5: 				}
1:fe77ca5: 				else
1:fe77ca5: 				{
1:fe77ca5: 					try {
1:a9217e9: 						s = rs.getString(colnum);
1:fe77ca5: 					} catch (SQLException se) {
1:fe77ca5: 						// oops, they don't support refetching the column
1:fe77ca5: 						s = o.toString();
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 			break;
1:fe77ca5: 			}
1:fe77ca5: 			if (s==null) s = "NULL";
1:fe77ca5: 
1:a9217e9: 			int w = displayColumnWidths[i-1];
1:fe77ca5: 			if (s.length() < w) {
1:fe77ca5: 				StringBuffer fullS = new StringBuffer(s);
1:fe77ca5: 				fullS.ensureCapacity(w);
1:fe77ca5: 				for (int k=s.length(); k<w; k++)
1:fe77ca5: 					fullS.append(' ');
1:fe77ca5: 				s = fullS.toString();
1:fe77ca5: 			}
1:fe77ca5: 			else if (s.length() > w)
1:fe77ca5: 				// add the & marker to know it got cut off
1:fe77ca5: 				s = s.substring(0,w-1)+"&";
1:fe77ca5: 
1:fe77ca5: 			buf.append(s);
1:fe77ca5: 		}
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 	} // DisplayRow
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Check if an object is null, and if it is, throw an exception
1:fe77ca5: 		with an informative parameter about what was null.
1:fe77ca5: 		The exception is a run-time exception that is internal to ij.
1:fe77ca5: 
1:fe77ca5: 		@param o the object to test
1:fe77ca5: 		@param what the information to include in the error if it is null
1:fe77ca5: 	 */
1:fe77ca5: 	public static void checkNotNull(Object o, String what) {
1:fe77ca5: 		if (o == null) {
1:fe77ca5: 			throw ijException.objectWasNull(what);
1:fe77ca5: 		}
1:fe77ca5: 	} // checkNotNull
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Map the string to the value if it is null.
1:fe77ca5: 
1:fe77ca5: 		@param s the string to test for null
1:fe77ca5: 		@param nullValue the value to use if s is null
1:fe77ca5: 
1:fe77ca5: 		@return if s is non-null, s; else nullValue.
1:fe77ca5: 	 */
1:fe77ca5: 	static public String mapNull(String s, String nullValue) {
1:fe77ca5: 		if (s==null) return nullValue;
1:fe77ca5: 		return s;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		If the property ij.exceptionTrace is true, display the stack
1:fe77ca5: 		trace to the print stream. Otherwise, do nothing.
1:fe77ca5: 
1:fe77ca5: 		@param out the output stream to write to
1:fe77ca5: 		@param e the exception to display
1:fe77ca5: 	 */
1:fe77ca5: 	static public void doTrace(PrintWriter out, Exception e) {
1:663dfd3: 		if (getSystemBoolean("ij.exceptionTrace")) {
1:fe77ca5: 			e.printStackTrace(out);
1:fe77ca5: 		    out.flush();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void setMaxDisplayWidth(int maxDisplayWidth) {
1:fe77ca5: 		maxWidth = maxDisplayWidth;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, String text )
1:fe77ca5: 	{
1:fe77ca5: 		indent( out, indentLevel );
1:fe77ca5: 		out.println( text );
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, StringBuffer text )
1:fe77ca5: 	{
1:fe77ca5: 		indent( out, indentLevel );
1:fe77ca5: 		out.println( text );
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indent( PrintWriter out, int indentLevel )
1:fe77ca5: 	{
1:fe77ca5: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	// ================
1:fe77ca5: 
1:fe77ca5: 	static public void ShowException(PrintStream out, Throwable e) {
1:fe77ca5: 		if (e == null) return;
1:fe77ca5: 
1:fe77ca5: 		if (e instanceof SQLException)
1:fe77ca5: 			ShowSQLException(out, (SQLException)e);
1:fe77ca5: 		else
1:fe77ca5: 			e.printStackTrace(out);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void ShowSQLException(PrintStream out, SQLException e) {
1:fe77ca5: 		String errorCode;
1:fe77ca5: 
1:663dfd3: 		if (getSystemBoolean("ij.showErrorCode")) {
1:fe77ca5: 			errorCode = " (errorCode = " + e.getErrorCode() + ")";
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			errorCode = "";
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		while (e!=null) {
1:fe77ca5: 			out.println("ERROR "+mapNull(e.getSQLState(),"(no SQLState)")+": "+
1:fe77ca5: 				 mapNull(e.getMessage(),"(no message)")+errorCode);
1:fe77ca5: 			doTrace(out, e);
1:fe77ca5: 			e=e.getNextException();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void ShowWarnings(PrintStream out, Connection theConnection) {
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET CONNECTION WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (theConnection != null) {
1:fe77ca5: 			ShowWarnings(out, theConnection.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (theConnection != null) {
1:fe77ca5: 			theConnection.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowWarnings
1:fe77ca5: 
1:fe77ca5: 	static public void ShowWarnings(PrintStream out, SQLWarning warning) {
1:fe77ca5: 		while (warning != null) {
1:fe77ca5: 			out.println("WARNING "+
1:fe77ca5: 				mapNull(warning.getSQLState(),"(no SQLState)")+": "+
1:fe77ca5: 				mapNull(warning.getMessage(),"(no message)"));
1:fe77ca5: 			warning = warning.getNextWarning();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void ShowWarnings(PrintStream out, ResultSet rs) {
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET RESULTSET WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (rs != null) {
1:fe77ca5: 			ShowWarnings(out, rs.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (rs != null) {
1:fe77ca5: 			rs.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowResultSetWarnings
1:fe77ca5: 
1:fe77ca5: 	static public void ShowWarnings(PrintStream out, Statement s)
1:fe77ca5: 	{
1:fe77ca5: 	    try {
1:fe77ca5: 		// GET STATEMENT WARNINGS
1:fe77ca5: 		SQLWarning warning = null;
1:fe77ca5: 
1:fe77ca5: 		if (s != null) {
1:fe77ca5: 			ShowWarnings(out, s.getWarnings());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (s != null) {
1:fe77ca5: 			s.clearWarnings();
1:fe77ca5: 		}
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			ShowSQLException(out, e);
1:fe77ca5: 	    }
1:fe77ca5: 	} // ShowStatementWarnings
1:fe77ca5: 
1:fe77ca5: 	static public void DisplayResults(PrintStream out, Statement stmt, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayResults( out, stmt, conn, 0, null, null);			
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static private void indent_DisplayResults
1:a9217e9: 	(PrintStream out, Statement stmt, Connection conn, int indentLevel,
1:a9217e9: 	 int[] displayColumns, int[] displayColumnWidths)
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:fe77ca5: 		checkNotNull(stmt, "Statement");
1:fe77ca5: 
1:fe77ca5: 		ResultSet rs = stmt.getResultSet();
1:fe77ca5: 		if (rs != null) {
1:a9217e9: 			indent_DisplayResults(out, rs, conn, indentLevel, displayColumns,
1:a9217e9: 								  displayColumnWidths);
1:fe77ca5: 			rs.close(); // let the result set go away
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out,stmt);
1:fe77ca5: 	} // DisplayResults
1:fe77ca5: 
1:fe77ca5: 	static void DisplayUpdateCount(PrintStream out, int count, int indentLevel ) {
1:fe77ca5: 		if (count == 1) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, "1 row inserted/updated/deleted");
1:fe77ca5: 		}
1:fe77ca5: 		else if (count >= 0) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, count+" rows inserted/updated/deleted");
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, "Statement executed.");
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void DisplayResults(PrintStream out, ResultSet rs, Connection conn)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayResults( out, rs, conn, 0, null, null);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static private void indent_DisplayResults
1:a9217e9: 	(PrintStream out, ResultSet rs, Connection conn, int indentLevel,
1:a9217e9: 	 int[] displayColumns, int[] displayColumnWidths)
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		checkNotNull(rsmd, "ResultSetMetaData");
1:16d3334: 		Vector<ResultSet> nestedResults;
1:fe77ca5:     int numberOfRowsSelected = 0;
1:fe77ca5: 
1:fe77ca5: 		// autocommit must be off or the nested cursors
1:fe77ca5: 		// are closed when the outer statement completes.
1:fe77ca5: 		if (!conn.getAutoCommit())
1:16d3334: 			nestedResults = new Vector<ResultSet>();
1:fe77ca5: 		else
1:fe77ca5: 			nestedResults = null;
1:fe77ca5: 
1:a9217e9: 		if(displayColumnWidths == null)
1:a9217e9: 			displayColumnWidths = getColumnDisplayWidths(rsmd, displayColumns, false);
1:fe77ca5: 
1:a9217e9: 		int len = indent_DisplayBanner(out,rsmd, indentLevel, displayColumns,
1:a9217e9: 									   displayColumnWidths);
1:fe77ca5: 
1:fe77ca5: 		// When displaying rows, keep going past errors
1:fe77ca5: 		// unless/until the maximum # of errors is reached.
1:fe77ca5: 		boolean doNext = true;
1:fe77ca5: 		int retry = 0;
2:fe77ca5: 		while (doNext) {
1:fe77ca5: 			try {
1:fe77ca5: 				doNext = rs.next();
1:fe77ca5: 				if (doNext) {
1:fe77ca5: 
1:7b5fc1e: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, 
1:7b5fc1e: 							   indentLevel, displayColumns, 
1:a9217e9: 							   displayColumnWidths);
1:fe77ca5: 					ShowWarnings(out, rs);
1:fe77ca5: 					numberOfRowsSelected++;
1:fe77ca5: 				}
1:fe77ca5: 			} catch (SQLException e) {
1:fe77ca5: 				// REVISIT: might want to check the exception
1:fe77ca5: 				// and for some, not bother with the retry.
1:fe77ca5: 				if (++retry > MAX_RETRIES)
1:fe77ca5: 					throw e;
1:fe77ca5: 				else
1:fe77ca5: 					ShowSQLException(out, e);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 		if (showSelectCount == true) {
1:fe77ca5: 		   if (numberOfRowsSelected == 1) {
1:fe77ca5: 			   out.println();
1:fe77ca5: 			   indentedPrintLine( out, indentLevel, "1 row selected");
1:fe77ca5: 		   } else if (numberOfRowsSelected >= 0) {
1:fe77ca5: 			   out.println();
1:fe77ca5: 		       indentedPrintLine( out, indentLevel, numberOfRowsSelected + " rows selected");
1:fe77ca5: 		   }
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5: 		nestedResults = null;
1:fe77ca5: 	}
1:fe77ca5: 
1:16d3334: 	static private void DisplayNestedResults(PrintStream out, Vector<ResultSet> nr, Connection conn, int indentLevel )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:fe77ca5: 		if (nr == null) return;
1:fe77ca5: 
1:fe77ca5: 		String s="+ ResultSet #";
1:fe77ca5: 		String b="++++++++++++++++";
1:fe77ca5: 		String oldString="0";
1:fe77ca5: 
1:fe77ca5: 		for (int i=0; i < nr.size(); i++) {
1:fe77ca5: 			System.out.println();
1:fe77ca5: 
1:fe77ca5: 			//just too clever to get the extra +s
1:fe77ca5: 			String t = Integer.toString(i);
1:fe77ca5: 			if (t.length() > oldString.length()) {
1:fe77ca5: 				oldString = t;
1:fe77ca5: 				b=b+"+";
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			System.out.println(b);
1:fe77ca5: 			System.out.println(s+i+" +");
1:fe77ca5: 			System.out.println(b);
1:16d3334: 			indent_DisplayResults(out, nr.elementAt(i), conn, 
1:a9217e9: 								  indentLevel, null, null);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static public void DisplayNextRow(PrintStream out, ResultSet rs, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null
1:a9217e9: 							   : getColumnDisplayWidths(rs.getMetaData(),null,false) );
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private void indent_DisplayNextRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel,
1:a9217e9: 											  int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:16d3334: 		Vector<ResultSet> nestedResults;
1:fe77ca5: 
1:fe77ca5: 		// autocommit must be off or the nested cursors
1:fe77ca5: 		// are closed when the outer statement completes.
1:fe77ca5: 		if (!conn.getAutoCommit())
1:16d3334: 			nestedResults = new Vector<ResultSet>();
1:fe77ca5: 		else
1:fe77ca5: 			nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 		checkNotNull(rs, "ResultSet");
1:fe77ca5: 
1:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		checkNotNull(rsmd, "ResultSetMetaData");
1:fe77ca5: 
1:fe77ca5: 		// Only print stuff out if there is a row to be had.
1:fe77ca5: 		if (rs.next()) {
1:a9217e9: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, null, null);
1:a9217e9:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1:a9217e9: 					   displayColumns, displayColumnWidths);
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out, rs);
1:fe77ca5: 
1:fe77ca5: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5: 		nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 	} // DisplayNextRow
1:fe77ca5: 
1:fe77ca5: 	static public void DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null
1:a9217e9: 								  : getColumnDisplayWidths(rs.getMetaData(),null,false) );
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private void indent_DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn, 
1:a9217e9: 												 int indentLevel, int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException {
1:fe77ca5: 
1:16d3334: 		Vector<ResultSet> nestedResults;
1:fe77ca5: 
1:fe77ca5: 		if (rs == null) {
1:fe77ca5: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
1:fe77ca5: 			return;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		// autocommit must be off or the nested cursors
1:fe77ca5: 		// are closed when the outer statement completes.
1:fe77ca5: 		if (!conn.getAutoCommit())
1:16d3334: 			nestedResults = new Vector<ResultSet>();
1:fe77ca5: 		else
1:fe77ca5: 			nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		checkNotNull(rsmd, "ResultSetMetaData");
1:fe77ca5: 
1:a9217e9: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:a9217e9:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1:a9217e9: 				   displayColumns, displayColumnWidths);
1:fe77ca5: 
1:fe77ca5: 		ShowWarnings(out, rs);
1:fe77ca5: 
1:fe77ca5: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1:fe77ca5: 		nestedResults = null;
1:fe77ca5: 
1:fe77ca5: 	} // DisplayNextRow
1:fe77ca5: 
1:fe77ca5: 	static public int DisplayBanner(PrintStream out, ResultSetMetaData rsmd )
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:a9217e9: 		return indent_DisplayBanner( out, rsmd, 0, null,
1:a9217e9: 									 getColumnDisplayWidths(rsmd,null,false) );
1:fe77ca5: 	}
1:fe77ca5: 
1:a9217e9: 	static private int indent_DisplayBanner(PrintStream out, ResultSetMetaData rsmd, int indentLevel,
1:a9217e9: 											int[] displayColumns, int[] displayColumnWidths )
1:fe77ca5: 		throws SQLException	{
1:fe77ca5: 
1:fe77ca5: 		StringBuffer buf = new StringBuffer();
1:fe77ca5: 
1:a9217e9: 		int numCols = displayColumnWidths.length;
1:fe77ca5: 		int rowLen;
1:fe77ca5: 
1:fe77ca5: 		// do some precalculation so the buffer is allocated only once
1:fe77ca5: 		// buffer is twice as long as the display length plus one for a newline
1:fe77ca5: 		rowLen = (numCols - 1); // for the column separators
1:fe77ca5: 		for (int i=1; i <= numCols; i++) {
1:a9217e9: 			rowLen += displayColumnWidths[i-1];
1:fe77ca5: 		}
1:fe77ca5: 		buf.ensureCapacity(rowLen);
1:fe77ca5: 
1:fe77ca5: 		// get column header info
1:fe77ca5: 		// truncate it to the column display width
1:fe77ca5: 		// add a bar between each item.
1:fe77ca5: 		for (int i=1; i <= numCols; i++) {
1:a9217e9: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1:fe77ca5: 
1:fe77ca5: 			if (i>1)
1:fe77ca5: 				buf.append('|');
1:fe77ca5: 
1:a9217e9: 			String s = rsmd.getColumnLabel(colnum);
1:fe77ca5: 
1:a9217e9: 			int w = displayColumnWidths[i-1];
1:7b5fc1e: 
1:fe77ca5: 			if (s.length() < w) {
2:fe77ca5: 				// build a string buffer to hold the whitespace
2:fe77ca5: 				StringBuffer blanks = new StringBuffer(s);
2:fe77ca5: 				blanks.ensureCapacity(w);
1:fe77ca5: 
1:fe77ca5: 				// try to paste on big chunks of space at a time.
2:fe77ca5: 				for (int k=blanks.length()+64; k<=w; k+=64)
2:fe77ca5: 					blanks.append(
1:fe77ca5:           "                                                                ");
2:fe77ca5: 				for (int k=blanks.length()+16; k<=w; k+=16)
2:fe77ca5: 					blanks.append("                ");
2:fe77ca5: 				for (int k=blanks.length()+4; k<=w; k+=4)
2:fe77ca5: 					blanks.append("    ");
2:fe77ca5: 				for (int k=blanks.length(); k<w; k++)
2:fe77ca5: 					blanks.append(' ');
1:fe77ca5: 
2:fe77ca5: 				buf.append(blanks);
2:fe77ca5: 				// REMIND: could do more cleverness, like keep around
2:fe77ca5: 				// past buffers to reuse...
1:fe77ca5: 			}
1:fe77ca5: 			else if (s.length() > w)  {
1:fe77ca5: 				if (w > 1) 
1:fe77ca5: 					buf.append(s.substring(0,w-1));
1:fe77ca5: 				if (w > 0) 
1:fe77ca5: 					buf.append('&');
1:fe77ca5: 			}
1:fe77ca5: 			else {
1:fe77ca5: 				buf.append(s);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		buf.setLength(Math.min(rowLen, 1024));
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 		// now print a row of '-'s
1:fe77ca5: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
1:fe77ca5: 			buf.setCharAt(i, '-');
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 		buf = null;
1:fe77ca5: 
1:fe77ca5: 		return rowLen;
1:fe77ca5: 	} // DisplayBanner
1:fe77ca5: 
1:16d3334: 	static private void DisplayRow(PrintStream out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector<ResultSet> nestedResults, Connection conn, int indentLevel,
1:a9217e9: 								   int[] displayColumns, int[] displayColumnWidths)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:fe77ca5: 		StringBuffer buf = new StringBuffer();
1:fe77ca5: 		buf.ensureCapacity(rowLen);
1:fe77ca5: 
1:a9217e9: 		int numCols = displayColumnWidths.length;
1:fe77ca5: 		int i;
1:fe77ca5: 
1:fe77ca5: 		// get column header info
1:fe77ca5: 		// truncate it to the column display width
1:fe77ca5: 		// add a bar between each item.
1:fe77ca5: 		for (i=1; i <= numCols; i++){
1:a9217e9: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1:fe77ca5: 			if (i>1)
1:fe77ca5: 				buf.append('|');
1:fe77ca5: 
1:fe77ca5: 			String s;
1:a9217e9: 			switch (rsmd.getColumnType(colnum)) {
1:fe77ca5: 			default:
1:a9217e9: 				s = rs.getString(colnum);
1:fe77ca5: 				break;
1:1a4ea31: 			case Types.JAVA_OBJECT:
1:fe77ca5: 			case Types.OTHER:
1:fe77ca5: 			{
1:a9217e9: 				Object o = rs.getObject(colnum);
1:fe77ca5: 				if (o == null) { s = "NULL"; }
1:fe77ca5: 				else if (o instanceof ResultSet && nestedResults != null)
1:fe77ca5: 				{
1:fe77ca5: 					s = "ResultSet #"+nestedResults.size();
1:16d3334: 					nestedResults.addElement( (ResultSet) o);
1:fe77ca5: 				}
1:fe77ca5: 				else
1:fe77ca5: 				{
1:fe77ca5: 					try {
1:a9217e9: 						s = rs.getString(colnum);
1:fe77ca5: 					} catch (SQLException se) {
1:fe77ca5: 						// oops, they don't support refetching the column
1:fe77ca5: 						s = o.toString();
1:fe77ca5: 					}
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 			break;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (s==null) s = "NULL";
1:fe77ca5: 
1:a9217e9: 			int w = displayColumnWidths[i-1];
1:fe77ca5: 			if (s.length() < w) {
1:fe77ca5: 				StringBuffer fullS = new StringBuffer(s);
1:fe77ca5: 				fullS.ensureCapacity(w);
1:fe77ca5: 				for (int k=s.length(); k<w; k++)
1:fe77ca5: 					fullS.append(' ');
1:fe77ca5: 				s = fullS.toString();
1:fe77ca5: 			}
1:fe77ca5: 			else if (s.length() > w)
1:fe77ca5: 				// add the & marker to know it got cut off
1:fe77ca5: 				s = s.substring(0,w-1)+"&";
1:fe77ca5: 
1:fe77ca5: 			buf.append(s);
1:7b5fc1e: 		}
1:fe77ca5: 		indentedPrintLine( out, indentLevel, buf);
1:fe77ca5: 
1:fe77ca5: 	} // DisplayRow
1:fe77ca5: 
1:fe77ca5: 	static public void doTrace(PrintStream out, Exception e) {
1:663dfd3: 		if (getSystemBoolean("ij.exceptionTrace")) {
1:fe77ca5: 			e.printStackTrace(out);
1:fe77ca5: 		    out.flush();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, String text )
1:fe77ca5: 	{
1:fe77ca5: 		indent( out, indentLevel );
1:fe77ca5: 		out.println( text );
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, StringBuffer text )
1:fe77ca5: 	{
1:fe77ca5: 		indent( out, indentLevel );
1:fe77ca5: 		out.println( text );
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	static	private	void	indent( PrintStream out, int indentLevel )
1:fe77ca5: 	{
1:fe77ca5: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
1:fe77ca5: 	}
1:fe77ca5: 	
1:fe77ca5: 	// ==========================
1:663dfd3:     
1:663dfd3:     /**
1:663dfd3:      * Get an ij boolean system property.
1:663dfd3:      *
1:663dfd3:      * @param name name of the property
1:663dfd3:      */
1:663dfd3:     private static boolean getSystemBoolean(final String name) {
1:663dfd3: 
1:16d3334:         return (AccessController
1:16d3334:                 .doPrivileged(new java.security.PrivilegedAction<Boolean>() {
1:663dfd3: 
1:16d3334:                     public Boolean run() {
1:01648d6:                         return Boolean.getBoolean(name) ?
1:01648d6:                             Boolean.TRUE : Boolean.FALSE;
1:663dfd3: 
1:663dfd3:                     }
1:663dfd3: 
1:663dfd3:                 })).booleanValue();
1:663dfd3:     }
1:fe77ca5: }
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:16d3334
/////////////////////////////////////////////////////////////////////////
1:     static public void DisplayMultipleResults(PrintWriter out, List<ResultSet> resultSets,
/////////////////////////////////////////////////////////////////////////
1:         List<ResultSet> resultSets = new ArrayList<ResultSet>();
1:         (PrintWriter out, List<ResultSet> resultSets, Connection conn, int indentLevel,
/////////////////////////////////////////////////////////////////////////
1:             rsmd = (resultSets.get(0)).getMetaData();
1:         Vector<ResultSet> nestedResults;
1:             nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1:             rs = resultSets.get(i);
/////////////////////////////////////////////////////////////////////////
1: 	static private void DisplayNestedResults(PrintWriter out, Vector<ResultSet> nr, Connection conn, int indentLevel )
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ResultSet> nestedResults;
1: 			nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ResultSet> nestedResults;
/////////////////////////////////////////////////////////////////////////
1: 			nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1: 	static private void DisplayRow(PrintWriter out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector<ResultSet> nestedResults, Connection conn, int indentLevel,
/////////////////////////////////////////////////////////////////////////
1: 					nestedResults.addElement( (ResultSet) o);
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ResultSet> nestedResults;
1: 			nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1: 	static private void DisplayNestedResults(PrintStream out, Vector<ResultSet> nr, Connection conn, int indentLevel )
/////////////////////////////////////////////////////////////////////////
1: 			indent_DisplayResults(out, nr.elementAt(i), conn, 
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ResultSet> nestedResults;
1: 			nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<ResultSet> nestedResults;
/////////////////////////////////////////////////////////////////////////
1: 			nestedResults = new Vector<ResultSet>();
/////////////////////////////////////////////////////////////////////////
1: 	static private void DisplayRow(PrintStream out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector<ResultSet> nestedResults, Connection conn, int indentLevel,
/////////////////////////////////////////////////////////////////////////
1: 					nestedResults.addElement( (ResultSet) o);
/////////////////////////////////////////////////////////////////////////
1:         return (AccessController
1:                 .doPrivileged(new java.security.PrivilegedAction<Boolean>() {
1:                     public Boolean run() {
commit:80d6162
/////////////////////////////////////////////////////////////////////////
1:     static private boolean showSelectCount = false;
/////////////////////////////////////////////////////////////////////////
1: 	// Accessors
1: 
1:     public  static  boolean getShowSelectCount() { return showSelectCount; }
1:     public  static  void    setShowSelectCount( boolean newValue ) { showSelectCount = newValue; }
1: 
1: 	//-----------------------------------------------------------------
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
1: 			case Types.JAVA_OBJECT:
/////////////////////////////////////////////////////////////////////////
1: 			case Types.JAVA_OBJECT:
commit:663dfd3
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
/////////////////////////////////////////////////////////////////////////
1: 		if (getSystemBoolean("ij.showErrorCode")) {
/////////////////////////////////////////////////////////////////////////
1: 		if (getSystemBoolean("ij.exceptionTrace")) {
/////////////////////////////////////////////////////////////////////////
1: 		if (getSystemBoolean("ij.showErrorCode")) {
/////////////////////////////////////////////////////////////////////////
1: 		if (getSystemBoolean("ij.exceptionTrace")) {
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get an ij boolean system property.
1:      *
1:      * @param name name of the property
1:      */
1:     private static boolean getSystemBoolean(final String name) {
1: 
0:         return ((Boolean) AccessController
0:                 .doPrivileged(new java.security.PrivilegedAction() {
1: 
0:                     public Object run() {
0:                         return Boolean.valueOf(Boolean.getBoolean(name));
1: 
1:                     }
1: 
1:                 })).booleanValue();
1:     }
commit:79b6c66
/////////////////////////////////////////////////////////////////////////
commit:23ddbc8
/////////////////////////////////////////////////////////////////////////
1: 				
1: 				buf.append(s);
1: 				int k = w - s.length();
1: 				for (; k >= 64; k -= 64)
1: 					buf.append(
1: 				for (; k >= 16; k -= 16)
1: 					buf.append("                ");
1: 				for (; k >= 4; k -= 4)
1: 					buf.append("    ");
1: 				for (; k > 0; k--)
1: 					buf.append(' ');
commit:9fedfda
/////////////////////////////////////////////////////////////////////////
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.tools.JDBCDisplayUtil
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
1: public class JDBCDisplayUtil {
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.tools
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.tools;
1: 
1: import java.io.PrintStream;
1: import java.io.PrintWriter;
1: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: 
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.Types;
1: 
1: import java.util.Properties;
1: import java.util.Enumeration;
1: import java.util.Vector;
1: 
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1: 
1: import org.apache.derby.impl.tools.ij.ijException;
1: 
1: /**
1: 	
1: 	This class contains utility methods for displaying JDBC objects and results.
1: 	
1: 	<p>
1: 	All of the methods are static. The output stream
1: 	to write to is always passed in, along with the
1: 	JDBC objects to display.
1: 
0: 	@author ames
1:  */
0: public class JDBCDisplayUtil { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	// used to control display
1: 	static final private int MINWIDTH = 4;
1: 	static private int maxWidth = 128;
0:     static public boolean showSelectCount = false;
1: 
1:     static {
1:         // initialize the locale support functions to default value of JVM 
1:         LocalizedResource.getInstance();
1:     }
1: 
1: 
1: 	//-----------------------------------------------------------------
0: 	// Methods for initialization resource bundle and codeset's output
1: 	
1: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the derby.ui.locale and derby.ui.codeset
0: 	 * properties if exists or using the default values from the JVM.
1: 	 */
0: 	static public boolean init() {
0: 		return (LocalizedResource.getInstance() != null);
1: 	}
1: 
1: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the derby.ui.locale properties and on the 
0:      * given codeset if exists or using the default values from the JVM.
1: 	 */
0: 	public static boolean init(String codeset) {
0: 		return init(codeset, null);
1: 	}
1: 
1: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the given codeset and locale.
0: 	 * If the parameters are null it will try to init use derby.ui.locale
0: 	 * and derby.ui.codeset properties if exists or using the default
0: 	 * values from the JVM.
1: 	 */
0: 	public static boolean init(String pCodeset, String pLocale) {
0: 		LocalizedResource.getInstance().init(pCodeset, pLocale,null);
0: 		return true;
1: 	}
1: 
1: 	//-----------------------------------------------------------------
1: 	// Methods for displaying and checking errors
1: 
1: 	/**
1: 		Print information about the exception to the given PrintWriter.
1: 		For non-SQLExceptions, does a stack trace. For SQLExceptions,
1: 		print a standard error message and walk the list, if any.
1: 
1: 		@param out the place to write to
1: 		@param e the exception to display
1: 	 */
1: 	static public void ShowException(PrintWriter out, Throwable e) {
1: 		if (e == null) return;
1: 
1: 		if (e instanceof SQLException)
1: 			ShowSQLException(out, (SQLException)e);
1: 		else
1: 			e.printStackTrace(out);
1: 	}
1: 
1: 	/**
1: 		Print information about the SQL exception to the given PrintWriter.
1: 		Walk the list of exceptions, if any.
1: 
1: 		@param out the place to write to
1: 		@param e the exception to display
1: 	 */
1: 	static public void ShowSQLException(PrintWriter out, SQLException e) {
1: 		String errorCode;
1: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
1: 			errorCode = LocalizedResource.getMessage("UT_Error0", LocalizedResource.getNumber(e.getErrorCode()));
1: 		}
1: 		else {
1: 			errorCode = "";
1: 		}
1: 
1: 		while (e!=null) {
1: 			String p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst"));
1: 			String p2 = mapNull(e.getMessage(),LocalizedResource.getMessage("UT_NoMessa"));
1: 			out.println(LocalizedResource.getMessage("UT_Error012", p1, p2,errorCode));
1: 			doTrace(out, e);
1: 			e=e.getNextException();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Print information about the SQL warnings for the connection
1: 		to the given PrintWriter.
1: 		Walks the list of exceptions, if any.
1: 
1: 		@param out the place to write to
1: 		@param theConnection the connection that may have warnings.
1: 	 */
1: 	static public void ShowWarnings(PrintWriter out, Connection theConnection) {
1: 	    try {
1: 		// GET CONNECTION WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (theConnection != null) {
1: 			ShowWarnings(out, theConnection.getWarnings());
1: 		}
1: 
1: 		if (theConnection != null) {
1: 			theConnection.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowWarnings
1: 
1: 	/**
1: 		@param out the place to write to
1: 		@param warning the SQLWarning
1: 	*/
1: 	static public void ShowWarnings(PrintWriter out, SQLWarning warning) {
1: 		while (warning != null) {
1: 			String p1 = mapNull(warning.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst_7"));
1: 			String p2 = mapNull(warning.getMessage(),LocalizedResource.getMessage("UT_NoMessa_8"));
1: 			out.println(LocalizedResource.getMessage("UT_Warni01", p1, p2));
1: 			warning = warning.getNextWarning();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Print information about the SQL warnings for the ResultSet
1: 		to the given PrintWriter.
1: 		Walk the list of exceptions, if any.
1: 	
1: 		@param out the place to write to
1: 		@param rs the ResultSet that may have warnings on it
1: 	 */
1: 	static public void ShowWarnings(PrintWriter out, ResultSet rs) {
1: 	    try {
1: 		// GET RESULTSET WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (rs != null) {
1: 			ShowWarnings(out, rs.getWarnings());
1: 		}
1: 
1: 		if (rs != null) {
1: 			rs.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowResultSetWarnings
1: 
1: 	/**
1: 		Print information about the SQL warnings for the Statement
1: 		to the given PrintWriter.
1: 		Walks the list of exceptions, if any.
1: 
1: 		@param out the place to write to
1: 		@param s the Statement that may have warnings on it
1: 	 */
1: 	static public void ShowWarnings(PrintWriter out, Statement s)
1: 	{
1: 	    try {
1: 		// GET STATEMENT WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (s != null) {
1: 			ShowWarnings(out, s.getWarnings());
1: 		}
1: 
1: 		if (s != null) {
1: 			s.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowStatementWarnings
1: 
1: 	//-----------------------------------------------------------------
1: 	// Methods for displaying and checking results
1: 
1: 	// REMIND: make this configurable...
1: 	static final private int MAX_RETRIES = 0;
1: 
1: 	/**
1: 		Pretty-print the results of a statement that has been executed.
1: 		If it is a select, gathers and prints the results.  Display
1: 		partial results up to the first error.
1: 		If it is not a SELECT, determine if rows were involved or not,
1: 		and print the appropriate message.
1: 
1: 		@param out the place to write to
1: 		@param stmt the Statement to display
1: 		@param conn the Connection against which the statement was executed
1: 
1: 		@exception SQLException on JDBC access failure
1: 	 */
1: 	static public void DisplayResults(PrintWriter out, Statement stmt, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayResults( out, stmt, conn, 0);			
1: 	}
1: 
1: 	static private void indent_DisplayResults
0: 	(PrintWriter out, Statement stmt, Connection conn, int indentLevel)
1: 		throws SQLException {
1: 
1: 		checkNotNull(stmt, "Statement");
1: 
1: 		ResultSet rs = stmt.getResultSet();
1: 		if (rs != null) {
0: 			indent_DisplayResults(out, rs, conn, indentLevel);
1: 			rs.close(); // let the result set go away
1: 		}
1: 		else {
1: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
1: 		}
1: 
1: 		ShowWarnings(out,stmt);
1: 	} // DisplayResults
1: 
1: 	/**
1: 		@param out the place to write to
1: 		@param count the update count to display
1: 		@param indentLevel number of tab stops to indent line
1: 	 */
1: 	static void DisplayUpdateCount(PrintWriter out, int count, int indentLevel ) {
1: 		if (count == 1) {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowInserUpdatDelet"));
1: 		}
1: 		else if (count >= 0) {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_0RowsInserUpdatDelet", LocalizedResource.getNumber(count)));
1: 		}
1: 		else {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_StateExecu"));
1: 		}
1: 	}
1: 
1: 	/**
1: 		@param out the place to write to
0: 		@param rs the ResultSet to display
1: 		@param conn the Connection against which the ResultSet was retrieved
1: 
1: 		@exception SQLException on JDBC access failure
1: 	 */
0: 	static public void DisplayResults(PrintWriter out, ResultSet rs, Connection conn)
1: 		throws SQLException
1: 	{
0: 		indent_DisplayResults( out, rs, conn, 0);
1: 	}
1: 
1: 	static private void indent_DisplayResults
0: 	(PrintWriter out, ResultSet rs, Connection conn, int indentLevel)
1: 		throws SQLException {
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 		Vector nestedResults;
1:     int numberOfRowsSelected = 0;
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
0: 		int len = indent_DisplayBanner(out,rsmd, indentLevel);
1: 
1: 		// When displaying rows, keep going past errors
1: 		// unless/until the maximum # of errors is reached.
1: 		boolean doNext = true;
1: 		int retry = 0;
1: 		while (doNext) {
1: 			try {
1: 				doNext = rs.next();
1: 				if (doNext) {
1: 
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, indentLevel);
1: 					ShowWarnings(out, rs);
1: 					numberOfRowsSelected++;
1: 				}
1: 			} catch (SQLException e) {
1: 				// REVISIT: might want to check the exception
1: 				// and for some, not bother with the retry.
1: 				if (++retry > MAX_RETRIES)
1: 					throw e;
1: 				else
1: 					ShowSQLException(out, e);
1: 			}
1: 		}
1: 		if (showSelectCount == true) {
1: 		   if (numberOfRowsSelected == 1) {
1: 			   out.println();
0: 			   indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowSelec"));
1: 		   } else if (numberOfRowsSelected >= 0) {
1: 			   out.println();
0: 		       indentedPrintLine( out, indentLevel, 
0: 			LocalizedResource.getMessage("UT_0RowsSelec", LocalizedResource.getNumber(numberOfRowsSelected)));
1: 		   }
1: 		}
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 	}
1: 
1: 	/**
1: 		@param out the place to write to
1: 		@param nr the vector of results
1: 		@param conn the Connection against which the ResultSet was retrieved
1: 		@param indentLevel number of tab stops to indent line
1: 
1: 		@exception SQLException thrown on access error
1: 	 */
0: 	static private void DisplayNestedResults(PrintWriter out, Vector nr, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
1: 		if (nr == null) return;
1: 
1: 		String b=LocalizedResource.getMessage("UT_JDBCDisplayUtil_16");
1: 		String oldString="0";
1: 
1: 		for (int i=0; i < nr.size(); i++) {
1: 			LocalizedResource.OutputWriter().println();
1: 
1: 			//just too clever to get the extra +s
1: 			String t = Integer.toString(i);
1: 			if (t.length() > oldString.length()) {
1: 				oldString = t;
1: 				b=b+LocalizedResource.getMessage("UT_JDBCDisplayUtil_17");
1: 			}
1: 
1: 			LocalizedResource.OutputWriter().println(b);
1: 			LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("UT_Resul0", LocalizedResource.getNumber(i)));
1: 			LocalizedResource.OutputWriter().println(b);
0: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn, indentLevel);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Fetch the next row of the result set, and if it
1: 		exists format and display a banner and the row.
1: 
1: 		@param out the place to write to
1: 		@param rs the ResultSet in use
1: 		@param conn the Connection against which the ResultSet was retrieved
1: 
1: 		@exception SQLException on JDBC access failure
1: 	 */
1: 	static public void DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayNextRow( out, rs, conn, 0 );
1: 	}
1: 
0: 	static private void indent_DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
0: 		Vector nestedResults;
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
1: 		checkNotNull(rs, "ResultSet");
1: 
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
1: 
1: 		// Only print stuff out if there is a row to be had.
1: 		if (rs.next()) {
0: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
1: 		}
1: 		else {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
1: 		}
1: 
1: 		ShowWarnings(out, rs);
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 
1: 	} // DisplayNextRow
1: 
1: 	/**
1: 		Display the current row of the result set along with
1: 		a banner. Assume the result set is on a row.
1: 
1: 		@param out the place to write to
1: 		@param rs the ResultSet in use
1: 		@param conn the Connection against which the ResultSet was retrieved
1: 
1: 		@exception SQLException on JDBC access failure
1: 	 */
1: 	static public void DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayCurrentRow( out, rs, conn, 0 );
1: 	}
1: 
0: 	static private void indent_DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
0: 		Vector nestedResults;
1: 
1: 		if (rs == null) {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
1: 			return;
1: 		}
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
1: 
0: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
1: 
1: 		ShowWarnings(out, rs);
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 
1: 	} // DisplayNextRow
1: 
1: 	/**
1: 		Print a banner containing the column labels separated with '|'s
1: 		and a line of '-'s.  Each field is as wide as the display
1: 		width reported by the metadata.
1: 
1: 		@param out the place to write to
1: 		@param rsmd the ResultSetMetaData to use
1: 
1: 		@exception SQLException on JDBC access failure
1: 	 */
1: 	static public int DisplayBanner(PrintWriter out, ResultSetMetaData rsmd )
1: 		throws SQLException
1: 	{
0: 		return indent_DisplayBanner( out, rsmd, 0 );
1: 	}
1: 
0: 	static private int indent_DisplayBanner(PrintWriter out, ResultSetMetaData rsmd, int indentLevel )
1: 		throws SQLException	{
1: 
1: 		StringBuffer buf = new StringBuffer();
1: 
0: 		int numCols = rsmd.getColumnCount();
1: 		int rowLen;
1: 
1: 		// do some precalculation so the buffer is allocated only once
1: 		// buffer is twice as long as the display length plus one for a newline
1: 		rowLen = (numCols - 1); // for the column separators
1: 		for (int i=1; i <= numCols; i++) {
0: 			rowLen += Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH, LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
1: 		}
1: 		buf.ensureCapacity(rowLen);
1: 
1: 		// get column header info
1: 		// truncate it to the column display width
1: 		// add a bar between each item.
1: 		for (int i=1; i <= numCols; i++) {
1: 
1: 			if (i>1)
1: 				buf.append('|');
1: 
0: 			String s = rsmd.getColumnLabel(i);
1: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max(((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH), LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
1: 
1: 			if (s.length() < w) {
1: 				// build a string buffer to hold the whitespace
1: 				StringBuffer blanks = new StringBuffer(s);
1: 				blanks.ensureCapacity(w);
1: 
1: 				// try to paste on big chunks of space at a time.
1: 				for (int k=blanks.length()+64; k<=w; k+=64)
1: 					blanks.append(
1:           "                                                                ");
1: 				for (int k=blanks.length()+16; k<=w; k+=16)
1: 					blanks.append("                ");
1: 				for (int k=blanks.length()+4; k<=w; k+=4)
1: 					blanks.append("    ");
1: 				for (int k=blanks.length(); k<w; k++)
1: 					blanks.append(' ');
1: 
1: 				buf.append(blanks);
1: 				// REMIND: could do more cleverness, like keep around
1: 				// past buffers to reuse...
1: 			}
1: 			else if (s.length() > w)  {
1: 				if (w > 1) 
1: 					buf.append(s.substring(0,w-1));
1: 				if (w > 0) 
1: 					buf.append('&');
1: 			}
1: 			else {
1: 				buf.append(s);
1: 			}
1: 		}
1: 
1: 		buf.setLength(Math.min(rowLen, 1024));
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 		// now print a row of '-'s
1: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
1: 			buf.setCharAt(i, '-');
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 		buf = null;
1: 
1: 		return rowLen;
1: 	} // DisplayBanner
1: 
1: 	/**
1: 		Print one row of a result set, padding each field to the
1: 		display width and separating them with '|'s
1: 
1: 		@param out the place to write to
1: 		@param rs the ResultSet to use
1: 		@param rsmd the ResultSetMetaData to use
1: 		@param rowLen
1: 		@param nestedResults
1: 		@param conn
1: 		@param indentLevel number of tab stops to indent line
1: 
1: 		@exception SQLException thrown on JDBC access failure
1: 	 */
0: 	static private void DisplayRow(PrintWriter out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel )
1: 		throws SQLException
1: 	{
1: 		StringBuffer buf = new StringBuffer();
1: 		buf.ensureCapacity(rowLen);
1: 
0: 		int numCols = rsmd.getColumnCount();
1: 		int i;
1: 
1: 		// get column header info
1: 		// truncate it to the column display width
1: 		// add a bar between each item.
1: 		for (i=1; i <= numCols; i++){
1: 			if (i>1)
1: 				buf.append('|');
1: 
1: 			String s;
0: 			switch (rsmd.getColumnType(i)) {
1: 			default:
0: 				s = LocalizedResource.getInstance().getLocalizedString(rs, rsmd, i );
1: 				break;
0: 			case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
1: 			case Types.OTHER:
1: 			{
0: 				Object o = rs.getObject(i);
1: 				if (o == null) { s = "NULL"; }
1: 				else if (o instanceof ResultSet && nestedResults != null)
1: 				{
1: 					s = LocalizedResource.getMessage("UT_Resul0_20", LocalizedResource.getNumber(nestedResults.size()));
0: 					nestedResults.addElement(o);
1: 				}
1: 				else
1: 				{
1: 					try {
0: 						s = rs.getString(i);
1: 					} catch (SQLException se) {
1: 						// oops, they don't support refetching the column
1: 						s = o.toString();
1: 					}
1: 				}
1: 			}
1: 			break;
1: 			}
1: 			if (s==null) s = "NULL";
1: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH, LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
1: 			if (s.length() < w) {
1: 				StringBuffer fullS = new StringBuffer(s);
1: 				fullS.ensureCapacity(w);
1: 				for (int k=s.length(); k<w; k++)
1: 					fullS.append(' ');
1: 				s = fullS.toString();
1: 			}
1: 			else if (s.length() > w)
1: 				// add the & marker to know it got cut off
1: 				s = s.substring(0,w-1)+"&";
1: 
1: 			buf.append(s);
1: 		}
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 	} // DisplayRow
1: 
1: 	/**
1: 		Check if an object is null, and if it is, throw an exception
1: 		with an informative parameter about what was null.
1: 		The exception is a run-time exception that is internal to ij.
1: 
1: 		@param o the object to test
1: 		@param what the information to include in the error if it is null
1: 	 */
1: 	public static void checkNotNull(Object o, String what) {
1: 		if (o == null) {
1: 			throw ijException.objectWasNull(what);
1: 		}
1: 	} // checkNotNull
1: 
1: 	/**
1: 		Map the string to the value if it is null.
1: 
1: 		@param s the string to test for null
1: 		@param nullValue the value to use if s is null
1: 
1: 		@return if s is non-null, s; else nullValue.
1: 	 */
1: 	static public String mapNull(String s, String nullValue) {
1: 		if (s==null) return nullValue;
1: 		return s;
1: 	}
1: 
1: 	/**
1: 		If the property ij.exceptionTrace is true, display the stack
1: 		trace to the print stream. Otherwise, do nothing.
1: 
1: 		@param out the output stream to write to
1: 		@param e the exception to display
1: 	 */
1: 	static public void doTrace(PrintWriter out, Exception e) {
0: 		if (Boolean.getBoolean("ij.exceptionTrace")) {
1: 			e.printStackTrace(out);
1: 		    out.flush();
1: 		}
1: 	}
1: 
1: 	static public void setMaxDisplayWidth(int maxDisplayWidth) {
1: 		maxWidth = maxDisplayWidth;
1: 	}
1: 
1: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, String text )
1: 	{
1: 		indent( out, indentLevel );
1: 		out.println( text );
1: 	}
1: 
1: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, StringBuffer text )
1: 	{
1: 		indent( out, indentLevel );
1: 		out.println( text );
1: 	}
1: 
1: 	static	private	void	indent( PrintWriter out, int indentLevel )
1: 	{
1: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
1: 	}
1: 
1: 	// ================
1: 
1: 	static public void ShowException(PrintStream out, Throwable e) {
1: 		if (e == null) return;
1: 
1: 		if (e instanceof SQLException)
1: 			ShowSQLException(out, (SQLException)e);
1: 		else
1: 			e.printStackTrace(out);
1: 	}
1: 
1: 	static public void ShowSQLException(PrintStream out, SQLException e) {
1: 		String errorCode;
1: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
1: 			errorCode = " (errorCode = " + e.getErrorCode() + ")";
1: 		}
1: 		else {
1: 			errorCode = "";
1: 		}
1: 
1: 		while (e!=null) {
1: 			out.println("ERROR "+mapNull(e.getSQLState(),"(no SQLState)")+": "+
1: 				 mapNull(e.getMessage(),"(no message)")+errorCode);
1: 			doTrace(out, e);
1: 			e=e.getNextException();
1: 		}
1: 	}
1: 
1: 	static public void ShowWarnings(PrintStream out, Connection theConnection) {
1: 	    try {
1: 		// GET CONNECTION WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (theConnection != null) {
1: 			ShowWarnings(out, theConnection.getWarnings());
1: 		}
1: 
1: 		if (theConnection != null) {
1: 			theConnection.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowWarnings
1: 
1: 	static public void ShowWarnings(PrintStream out, SQLWarning warning) {
1: 		while (warning != null) {
1: 			out.println("WARNING "+
1: 				mapNull(warning.getSQLState(),"(no SQLState)")+": "+
1: 				mapNull(warning.getMessage(),"(no message)"));
1: 			warning = warning.getNextWarning();
1: 		}
1: 	}
1: 
1: 	static public void ShowWarnings(PrintStream out, ResultSet rs) {
1: 	    try {
1: 		// GET RESULTSET WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (rs != null) {
1: 			ShowWarnings(out, rs.getWarnings());
1: 		}
1: 
1: 		if (rs != null) {
1: 			rs.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowResultSetWarnings
1: 
1: 	static public void ShowWarnings(PrintStream out, Statement s)
1: 	{
1: 	    try {
1: 		// GET STATEMENT WARNINGS
1: 		SQLWarning warning = null;
1: 
1: 		if (s != null) {
1: 			ShowWarnings(out, s.getWarnings());
1: 		}
1: 
1: 		if (s != null) {
1: 			s.clearWarnings();
1: 		}
1: 	    } catch (SQLException e) {
1: 			ShowSQLException(out, e);
1: 	    }
1: 	} // ShowStatementWarnings
1: 
1: 	static public void DisplayResults(PrintStream out, Statement stmt, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayResults( out, stmt, conn, 0);			
1: 	}
1: 
1: 	static private void indent_DisplayResults
0: 	(PrintStream out, Statement stmt, Connection conn, int indentLevel)
1: 		throws SQLException {
1: 
1: 		checkNotNull(stmt, "Statement");
1: 
1: 		ResultSet rs = stmt.getResultSet();
1: 		if (rs != null) {
0: 			indent_DisplayResults(out, rs, conn, indentLevel);
1: 			rs.close(); // let the result set go away
1: 		}
1: 		else {
1: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
1: 		}
1: 
1: 		ShowWarnings(out,stmt);
1: 	} // DisplayResults
1: 
1: 	static void DisplayUpdateCount(PrintStream out, int count, int indentLevel ) {
1: 		if (count == 1) {
1: 			indentedPrintLine( out, indentLevel, "1 row inserted/updated/deleted");
1: 		}
1: 		else if (count >= 0) {
1: 			indentedPrintLine( out, indentLevel, count+" rows inserted/updated/deleted");
1: 		}
1: 		else {
1: 			indentedPrintLine( out, indentLevel, "Statement executed.");
1: 		}
1: 	}
1: 
1: 	static public void DisplayResults(PrintStream out, ResultSet rs, Connection conn)
1: 		throws SQLException
1: 	{
0: 		indent_DisplayResults( out, rs, conn, 0);
1: 	}
1: 
1: 	static private void indent_DisplayResults
0: 	(PrintStream out, ResultSet rs, Connection conn, int indentLevel)
1: 		throws SQLException {
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 		Vector nestedResults;
1:     int numberOfRowsSelected = 0;
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
0: 		int len = indent_DisplayBanner(out,rsmd, indentLevel);
1: 
1: 		// When displaying rows, keep going past errors
1: 		// unless/until the maximum # of errors is reached.
1: 		boolean doNext = true;
1: 		int retry = 0;
1: 		while (doNext) {
1: 			try {
1: 				doNext = rs.next();
1: 				if (doNext) {
1: 
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, indentLevel);
1: 					ShowWarnings(out, rs);
1: 					numberOfRowsSelected++;
1: 				}
1: 			} catch (SQLException e) {
1: 				// REVISIT: might want to check the exception
1: 				// and for some, not bother with the retry.
1: 				if (++retry > MAX_RETRIES)
1: 					throw e;
1: 				else
1: 					ShowSQLException(out, e);
1: 			}
1: 		}
1: 		if (showSelectCount == true) {
1: 		   if (numberOfRowsSelected == 1) {
1: 			   out.println();
1: 			   indentedPrintLine( out, indentLevel, "1 row selected");
1: 		   } else if (numberOfRowsSelected >= 0) {
1: 			   out.println();
1: 		       indentedPrintLine( out, indentLevel, numberOfRowsSelected + " rows selected");
1: 		   }
1: 		}
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 	}
1: 
0: 	static private void DisplayNestedResults(PrintStream out, Vector nr, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
1: 		if (nr == null) return;
1: 
1: 		String s="+ ResultSet #";
1: 		String b="++++++++++++++++";
1: 		String oldString="0";
1: 
1: 		for (int i=0; i < nr.size(); i++) {
1: 			System.out.println();
1: 
1: 			//just too clever to get the extra +s
1: 			String t = Integer.toString(i);
1: 			if (t.length() > oldString.length()) {
1: 				oldString = t;
1: 				b=b+"+";
1: 			}
1: 
1: 			System.out.println(b);
1: 			System.out.println(s+i+" +");
1: 			System.out.println(b);
0: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn, indentLevel);
1: 		}
1: 	}
1: 
1: 	static public void DisplayNextRow(PrintStream out, ResultSet rs, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayNextRow( out, rs, conn, 0 );
1: 	}
1: 
0: 	static private void indent_DisplayNextRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
0: 		Vector nestedResults;
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
1: 		checkNotNull(rs, "ResultSet");
1: 
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
1: 
1: 		// Only print stuff out if there is a row to be had.
1: 		if (rs.next()) {
0: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
1: 		}
1: 		else {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
1: 		}
1: 
1: 		ShowWarnings(out, rs);
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 
1: 	} // DisplayNextRow
1: 
1: 	static public void DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn )
1: 		throws SQLException
1: 	{
0: 		indent_DisplayCurrentRow( out, rs, conn, 0 );
1: 	}
1: 
0: 	static private void indent_DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel )
1: 		throws SQLException {
1: 
0: 		Vector nestedResults;
1: 
1: 		if (rs == null) {
1: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
1: 			return;
1: 		}
1: 
1: 		// autocommit must be off or the nested cursors
1: 		// are closed when the outer statement completes.
1: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
1: 		else
1: 			nestedResults = null;
1: 
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		checkNotNull(rsmd, "ResultSetMetaData");
1: 
0: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
1: 
1: 		ShowWarnings(out, rs);
1: 
1: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
1: 		nestedResults = null;
1: 
1: 	} // DisplayNextRow
1: 
1: 	static public int DisplayBanner(PrintStream out, ResultSetMetaData rsmd )
1: 		throws SQLException
1: 	{
0: 		return indent_DisplayBanner( out, rsmd, 0 );
1: 	}
1: 
0: 	static private int indent_DisplayBanner(PrintStream out, ResultSetMetaData rsmd, int indentLevel )
1: 		throws SQLException	{
1: 
1: 		StringBuffer buf = new StringBuffer();
1: 
0: 		int numCols = rsmd.getColumnCount();
1: 		int rowLen;
1: 
1: 		// do some precalculation so the buffer is allocated only once
1: 		// buffer is twice as long as the display length plus one for a newline
1: 		rowLen = (numCols - 1); // for the column separators
1: 		for (int i=1; i <= numCols; i++) {
0: 			rowLen += Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH,
0: 						rsmd.getColumnDisplaySize(i)));
1: 		}
1: 		buf.ensureCapacity(rowLen);
1: 
1: 		// get column header info
1: 		// truncate it to the column display width
1: 		// add a bar between each item.
1: 		for (int i=1; i <= numCols; i++) {
1: 
1: 			if (i>1)
1: 				buf.append('|');
1: 
0: 			String s = rsmd.getColumnLabel(i);
1: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max(((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH),
0: 						rsmd.getColumnDisplaySize(i)));
1: 
1: 			if (s.length() < w) {
1: 				// build a string buffer to hold the whitespace
1: 				StringBuffer blanks = new StringBuffer(s);
1: 				blanks.ensureCapacity(w);
1: 
1: 				// try to paste on big chunks of space at a time.
1: 				for (int k=blanks.length()+64; k<=w; k+=64)
1: 					blanks.append(
1:           "                                                                ");
1: 				for (int k=blanks.length()+16; k<=w; k+=16)
1: 					blanks.append("                ");
1: 				for (int k=blanks.length()+4; k<=w; k+=4)
1: 					blanks.append("    ");
1: 				for (int k=blanks.length(); k<w; k++)
1: 					blanks.append(' ');
1: 
1: 				buf.append(blanks);
1: 				// REMIND: could do more cleverness, like keep around
1: 				// past buffers to reuse...
1: 			}
1: 			else if (s.length() > w)  {
1: 				if (w > 1) 
1: 					buf.append(s.substring(0,w-1));
1: 				if (w > 0) 
1: 					buf.append('&');
1: 			}
1: 			else {
1: 				buf.append(s);
1: 			}
1: 		}
1: 
1: 		buf.setLength(Math.min(rowLen, 1024));
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 		// now print a row of '-'s
1: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
1: 			buf.setCharAt(i, '-');
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 		buf = null;
1: 
1: 		return rowLen;
1: 	} // DisplayBanner
1: 
0: 	static private void DisplayRow(PrintStream out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel )
1: 		throws SQLException
1: 	{
1: 		StringBuffer buf = new StringBuffer();
1: 		buf.ensureCapacity(rowLen);
1: 
0: 		int numCols = rsmd.getColumnCount();
1: 		int i;
1: 
1: 		// get column header info
1: 		// truncate it to the column display width
1: 		// add a bar between each item.
1: 		for (i=1; i <= numCols; i++){
1: 			if (i>1)
1: 				buf.append('|');
1: 
1: 			String s;
0: 			switch (rsmd.getColumnType(i)) {
1: 			default:
0: 				s = rs.getString(i);
1: 				break;
0: 			case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
1: 			case Types.OTHER:
1: 			{
0: 				Object o = rs.getObject(i);
1: 				if (o == null) { s = "NULL"; }
1: 				else if (o instanceof ResultSet && nestedResults != null)
1: 				{
1: 					s = "ResultSet #"+nestedResults.size();
0: 					nestedResults.addElement(o);
1: 				}
1: 				else
1: 				{
1: 					try {
0: 						s = rs.getString(i);
1: 					} catch (SQLException se) {
1: 						// oops, they don't support refetching the column
1: 						s = o.toString();
1: 					}
1: 				}
1: 			}
1: 			break;
1: 			}
1: 
1: 			if (s==null) s = "NULL";
1: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH,
0: 						rsmd.getColumnDisplaySize(i)));
1: 			if (s.length() < w) {
1: 				StringBuffer fullS = new StringBuffer(s);
1: 				fullS.ensureCapacity(w);
1: 				for (int k=s.length(); k<w; k++)
1: 					fullS.append(' ');
1: 				s = fullS.toString();
1: 			}
1: 			else if (s.length() > w)
1: 				// add the & marker to know it got cut off
1: 				s = s.substring(0,w-1)+"&";
1: 
1: 			buf.append(s);
1: 		}
1: 		indentedPrintLine( out, indentLevel, buf);
1: 
1: 	} // DisplayRow
1: 
1: 	static public void doTrace(PrintStream out, Exception e) {
0: 		if (Boolean.getBoolean("ij.exceptionTrace")) {
1: 			e.printStackTrace(out);
1: 		    out.flush();
1: 		}
1: 	}
1: 
1: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, String text )
1: 	{
1: 		indent( out, indentLevel );
1: 		out.println( text );
1: 	}
1: 
1: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, StringBuffer text )
1: 	{
1: 		indent( out, indentLevel );
1: 		out.println( text );
1: 	}
1: 
1: 	static	private	void	indent( PrintStream out, int indentLevel )
1: 	{
1: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
1: 	}
1: 	
1: 	// ==========================
1: }
1: 
1: 
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:e5ca925
/////////////////////////////////////////////////////////////////////////
1:        @param resultSets list of <code>ResultSet</code>s to display
1:        @param conn the connection against which the <code>ResultSet</code>s
1:             were retrieved
1:        @param displayColumns column numbers to display, <code>null</code> if all
1:        @param displayColumnWidths column widths, in characters, if
1:             <code>displayColumns</code> is specified
/////////////////////////////////////////////////////////////////////////
1:         indent_DisplayResults( out, resultSets, conn, 0, displayColumns,
1:        @param rs the <code>ResultSet</code> to display
1:        @param conn the connection against which the <code>ResultSet</code>
1:             was retrieved
1:        @param displayColumns column numbers to display, <code>null</code> if all
1:        @param displayColumnWidths column widths, in characters, if
1:             <code>displayColumns</code> is specified
/////////////////////////////////////////////////////////////////////////
1:         (PrintWriter out, ResultSet rs, Connection conn, int indentLevel,
/////////////////////////////////////////////////////////////////////////
0:         (PrintWriter out, List resultSets, Connection conn, int indentLevel,
/////////////////////////////////////////////////////////////////////////
0:             rsmd = ((ResultSet)resultSets.get(0)).getMetaData();
1: 
/////////////////////////////////////////////////////////////////////////
1:                                                          displayColumns,true);
/////////////////////////////////////////////////////////////////////////
1: 
1:                         DisplayRow(out, rs, rsmd, len, nestedResults, conn,
1:                                    indentLevel, displayColumns,
/////////////////////////////////////////////////////////////////////////
1:                 indentedPrintLine(out, indentLevel,
1:                                   LocalizedResource.getMessage("UT_1RowSelec"));
1:                 indentedPrintLine(out, indentLevel,
1:                         LocalizedResource.getMessage("UT_0RowsSelec",
1:                             LocalizedResource.getNumber(numberOfRowsSelected)));
commit:7b5fc1e
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     /**
1:        @param out the place to write to
0:        @param resultSets List of ResultSet to display
0:        @param conn the Connection against which the ResultSet was retrieved
0:        @param displayColumns Column numbers to display, or null if all
0:        @param displayColumnWidths Column widths, in characters, if displayColumns is specified.
1:        @exception SQLException on JDBC access failure
0:     */
0:     static public void DisplayMultipleResults(PrintWriter out, List resultSets,
1:                                               Connection conn,
1:                                               int[] displayColumns,
1:                                               int[] displayColumnWidths)
1:         throws SQLException
1:     {
1:         indent_DisplayResults( out, resultSets, conn, 0, displayColumns, 
1:                                displayColumnWidths);
1:     }
1: 
0:     /**
1:        @param out the place to write to
0:        @param rs the ResultSet to display
0:        @param conn the Connection against which the ResultSet was retrieved
0:        @param displayColumns Column numbers to display, or null if all
0:        @param displayColumnWidths Column widths, in characters, if displayColumns is specified.
1: 
1:        @exception SQLException on JDBC access failure
0:     */
/////////////////////////////////////////////////////////////////////////
1:     static private void indent_DisplayResults
0:         (PrintWriter out, ResultSet rs, Connection conn, int indentLevel, 
1:          int[] displayColumns, int[] displayColumnWidths)
1:         throws SQLException {
0:         List resultSets = new ArrayList();
1:         resultSets.add(rs);
0:         indent_DisplayResults( out, resultSets, conn, 0, displayColumns, 
1:                                displayColumnWidths);
0:     }
1:     static private void indent_DisplayResults
0:         (PrintWriter out, List resultSets, Connection conn, int indentLevel, 
1:          int[] displayColumns, int[] displayColumnWidths)
1:         throws SQLException {
1:         ResultSetMetaData rsmd = null;
1:         //get metadata from the first ResultSet
1:         if (resultSets != null && resultSets.size() > 0)
0: 			rsmd = ((ResultSet)resultSets.get(0)).getMetaData();
1:     
0:         checkNotNull(rsmd, "ResultSetMetaData");
0:         Vector nestedResults;
0:         int numberOfRowsSelected = 0;
0:         // autocommit must be off or the nested cursors
0:         // are closed when the outer statement completes.
0:         if (!conn.getAutoCommit())
0:             nestedResults = new Vector();
0:         else
0:             nestedResults = null;
1:         if(displayColumnWidths == null)
1:             displayColumnWidths = getColumnDisplayWidths(rsmd,
0: 														 displayColumns,true);
1: 
1:         int len = indent_DisplayBanner(out,rsmd, indentLevel, displayColumns,
1:                                        displayColumnWidths);
1: 
0:         // When displaying rows, keep going past errors
0:         // unless/until the maximum # of errors is reached.
0:         int retry = 0;
1: 
1:         ResultSet rs = null;
0:         boolean doNext = true;
1:         for (int i = 0; i< resultSets.size(); i++) {
0:             rs = (ResultSet)resultSets.get(i);
1:             doNext = true;
1:             while (doNext){
0:                 try {
0:                     doNext = rs.next();
0:                     if (doNext) {
1:                 
1:                         DisplayRow(out, rs, rsmd, len, nestedResults, conn, 
1:                                    indentLevel, displayColumns, 
1:                                    displayColumnWidths);
0:                         ShowWarnings(out, rs);
0:                         numberOfRowsSelected++;
0:                     }
0:                 } catch (SQLException e) {
0:                     // REVISIT: might want to check the exception
0:                     // and for some, not bother with the retry.
0:                     if (++retry > MAX_RETRIES)
0:                         throw e;
0:                     else
0:                         ShowSQLException(out, e);
0:                 }
0:             }
0:         }
0:         if (showSelectCount == true) {
0:             if (numberOfRowsSelected == 1) {
0:                 out.println();
0:                 indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowSelec"));
0:             } else if (numberOfRowsSelected >= 0) {
0:                 out.println();
0:                 indentedPrintLine( out, indentLevel, 
0:                                    LocalizedResource.getMessage("UT_0RowsSelec", LocalizedResource.getNumber(numberOfRowsSelected)));
0:             }
0:         }
1: 
0:         DisplayNestedResults(out, nestedResults, conn, indentLevel );
0:         nestedResults = null;
0:     }
1: 
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:01648d6
/////////////////////////////////////////////////////////////////////////
1:                         return Boolean.getBoolean(name) ?
1:                             Boolean.TRUE : Boolean.FALSE;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:a9217e9
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayResults( out, stmt, conn, 0, null, null);			
1: 	(PrintWriter out, Statement stmt, Connection conn, int indentLevel,
1: 	 int[] displayColumns, int[] displayColumnWidths)
1: 			indent_DisplayResults(out, rs, conn, indentLevel, 
1: 								  displayColumns, displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
1: 	    Calculates column display widths from the default widths of the
1: 	    result set.
0: 	 */
1: 	static private int[] getColumnDisplayWidths(ResultSetMetaData rsmd, int[] dispColumns,
1: 												boolean localizedOutput)
0: 		throws SQLException {
1: 		int count = (dispColumns == null) ? rsmd.getColumnCount() : dispColumns.length;
1: 		int[] widths = new int[count];
0: 
1: 		for(int i=0; i<count; i++) {
1: 			int colnum = (dispColumns == null) ? (i + 1) : dispColumns[i];
1: 			int dispsize = localizedOutput
1: 				? LocalizedResource.getInstance().getColumnDisplaySize(rsmd, colnum)
1:                 : rsmd.getColumnDisplaySize(colnum);
1: 			widths[i] = Math.min(maxWidth,
1: 				Math.max((rsmd.isNullable(colnum) == ResultSetMetaData.columnNoNulls)?
1: 				0 : MINWIDTH, dispsize));
0: 		}
1: 		return widths;
0: 	}
0: 
0: 
0: 	/**
0: 	    @param displayColumns Column numbers to display, or null if all
0: 	    @param displayColumnWidths Column widths, in characters, if displayColumns is specified.
1: 	static public void DisplayResults(PrintWriter out, ResultSet rs, Connection conn,
1: 									  int[] displayColumns, int[] displayColumnWidths)
1: 		indent_DisplayResults( out, rs, conn, 0, displayColumns, 
1: 							   displayColumnWidths);
0: 	(PrintWriter out, ResultSet rs, Connection conn, int indentLevel, 
1: 	 int[] displayColumns, int[] displayColumnWidths)
/////////////////////////////////////////////////////////////////////////
1: 		if(displayColumnWidths == null)
0: 			displayColumnWidths = getColumnDisplayWidths(rsmd, displayColumns,true);
0: 		
1: 		int len = indent_DisplayBanner(out,rsmd, indentLevel, displayColumns,
1: 									   displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, 
0: 							   indentLevel, displayColumns, 
1: 							   displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
1: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn,
1: 								  indentLevel, null, null);
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null
1: 							   : getColumnDisplayWidths(rs.getMetaData(), null, true));
1: 	static private void indent_DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel,
1: 											  int[] displayColumns, int[] displayColumnWidths )
/////////////////////////////////////////////////////////////////////////
1: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1: 					   null, null );
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null
1: 								  : getColumnDisplayWidths(rs.getMetaData(), null, true) );
1: 	static private void indent_DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn, 
1: 												 int indentLevel, int[] displayColumns, int[] displayColumnWidths )
/////////////////////////////////////////////////////////////////////////
1: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1: 				   displayColumns, displayColumnWidths );
/////////////////////////////////////////////////////////////////////////
1: 		return indent_DisplayBanner( out, rsmd, 0, null, 
1: 									 getColumnDisplayWidths(rsmd, null, true) );
1: 	static private int indent_DisplayBanner(PrintWriter out, ResultSetMetaData rsmd, int indentLevel,
1: 											int[] displayColumns, int[] displayColumnWidths )
1: 		int numCols = displayColumnWidths.length;
1: 		for (int i=1; i <= numCols; i++)
1: 			rowLen += displayColumnWidths[i-1];
1: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1: 			String s = rsmd.getColumnLabel(colnum);
1: 			int w = displayColumnWidths[i-1];
/////////////////////////////////////////////////////////////////////////
1: 	    @param displayColumns A list of column numbers to display
1: 	    @param displayColumnWidths If displayColumns is set, the width of
1: 								columns to display, in characters.
0: 	static private void DisplayRow(PrintWriter out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel,
1: 								   int[] displayColumns, int[] displayColumnWidths )
1: 		int numCols = displayColumnWidths.length;
1: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1: 			switch (rsmd.getColumnType(colnum)) {
1: 				s = LocalizedResource.getInstance().getLocalizedString(rs, rsmd, colnum );
1: 				Object o = rs.getObject(colnum);
/////////////////////////////////////////////////////////////////////////
1: 						s = rs.getString(colnum);
/////////////////////////////////////////////////////////////////////////
1: 			int w = displayColumnWidths[i-1];
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayResults( out, stmt, conn, 0, null, null);			
1: 	(PrintStream out, Statement stmt, Connection conn, int indentLevel,
1: 	 int[] displayColumns, int[] displayColumnWidths)
1: 			indent_DisplayResults(out, rs, conn, indentLevel, displayColumns,
1: 								  displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayResults( out, rs, conn, 0, null, null);
1: 	(PrintStream out, ResultSet rs, Connection conn, int indentLevel,
1: 	 int[] displayColumns, int[] displayColumnWidths)
/////////////////////////////////////////////////////////////////////////
0: 		if(displayColumnWidths == null)
1: 			displayColumnWidths = getColumnDisplayWidths(rsmd, displayColumns, false);
0: 
0: 		int len = indent_DisplayBanner(out,rsmd, indentLevel, displayColumns,
0: 									   displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, 
0: 							   indentLevel, displayColumns, 
0: 							   displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
0: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn, 
1: 								  indentLevel, null, null);
1: 		indent_DisplayNextRow( out, rs, conn, 0, null, (rs == null) ? null
1: 							   : getColumnDisplayWidths(rs.getMetaData(),null,false) );
1: 	static private void indent_DisplayNextRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel,
1: 											  int[] displayColumns, int[] displayColumnWidths )
/////////////////////////////////////////////////////////////////////////
1: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, null, null);
1:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1: 					   displayColumns, displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
1: 		indent_DisplayCurrentRow( out, rs, conn, 0, null, (rs == null) ? null
1: 								  : getColumnDisplayWidths(rs.getMetaData(),null,false) );
1: 	static private void indent_DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn, 
1: 												 int indentLevel, int[] displayColumns, int[] displayColumnWidths )
/////////////////////////////////////////////////////////////////////////
1: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel, displayColumns, displayColumnWidths);
1:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel,
1: 				   displayColumns, displayColumnWidths);
/////////////////////////////////////////////////////////////////////////
1: 		return indent_DisplayBanner( out, rsmd, 0, null,
1: 									 getColumnDisplayWidths(rsmd,null,false) );
1: 	static private int indent_DisplayBanner(PrintStream out, ResultSetMetaData rsmd, int indentLevel,
1: 											int[] displayColumns, int[] displayColumnWidths )
1: 		int numCols = displayColumnWidths.length;
1: 			rowLen += displayColumnWidths[i-1];
/////////////////////////////////////////////////////////////////////////
1: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1: 			String s = rsmd.getColumnLabel(colnum);
1: 			int w = displayColumnWidths[i-1];
/////////////////////////////////////////////////////////////////////////
0: 	static private void DisplayRow(PrintStream out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel,
0: 								   int[] displayColumns, int[] displayColumnWidths)
1: 		int numCols = displayColumnWidths.length;
1: 			int colnum = displayColumns==null ? i : displayColumns[i-1];
1: 			switch (rsmd.getColumnType(colnum)) {
1: 				s = rs.getString(colnum);
1: 				Object o = rs.getObject(colnum);
/////////////////////////////////////////////////////////////////////////
1: 						s = rs.getString(colnum);
/////////////////////////////////////////////////////////////////////////
1: 			int w = displayColumnWidths[i-1];
commit:3dc2ce4
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.tools
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.tools;
0: 
0: import java.io.PrintStream;
0: import java.io.PrintWriter;
0: import java.io.File;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: 
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.Types;
0: 
0: import java.util.Properties;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: 
0: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
0: 
0: import org.apache.derby.impl.tools.ij.ijException;
0: 
0: /**
0: 	
0: 	This class contains utility methods for displaying JDBC objects and results.
0: 	
0: 	<p>
0: 	All of the methods are static. The output stream
0: 	to write to is always passed in, along with the
0: 	JDBC objects to display.
0: 
0: 	@author ames
0:  */
0: public class JDBCDisplayUtil { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	// used to control display
0: 	static final private int MINWIDTH = 4;
0: 	static private int maxWidth = 128;
0:     static public boolean showSelectCount = false;
0: 
0:     static {
0:         // initialize the locale support functions to default value of JVM 
0:         LocalizedResource.getInstance();
0:     }
0: 
0: 
0: 	//-----------------------------------------------------------------
0: 	// Methods for initialization resource bundle and codeset's output
0: 	
0: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the derby.ui.locale and derby.ui.codeset
0: 	 * properties if exists or using the default values from the JVM.
0: 	 */
0: 	static public boolean init() {
0: 		return (LocalizedResource.getInstance() != null);
0: 	}
0: 
0: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the derby.ui.locale properties and on the 
0:      * given codeset if exists or using the default values from the JVM.
0: 	 */
0: 	public static boolean init(String codeset) {
0: 		return init(codeset, null);
0: 	}
0: 
0: 	/**
0: 	 * init method - will init the class to support a locale and
0: 	 * codeset based on the given codeset and locale.
0: 	 * If the parameters are null it will try to init use derby.ui.locale
0: 	 * and derby.ui.codeset properties if exists or using the default
0: 	 * values from the JVM.
0: 	 */
0: 	public static boolean init(String pCodeset, String pLocale) {
0: 		LocalizedResource.getInstance().init(pCodeset, pLocale,null);
0: 		return true;
0: 	}
0: 
0: 	//-----------------------------------------------------------------
0: 	// Methods for displaying and checking errors
0: 
0: 	/**
0: 		Print information about the exception to the given PrintWriter.
0: 		For non-SQLExceptions, does a stack trace. For SQLExceptions,
0: 		print a standard error message and walk the list, if any.
0: 
0: 		@param out the place to write to
0: 		@param e the exception to display
0: 	 */
0: 	static public void ShowException(PrintWriter out, Throwable e) {
0: 		if (e == null) return;
0: 
0: 		if (e instanceof SQLException)
0: 			ShowSQLException(out, (SQLException)e);
0: 		else
0: 			e.printStackTrace(out);
0: 	}
0: 
0: 	/**
0: 		Print information about the SQL exception to the given PrintWriter.
0: 		Walk the list of exceptions, if any.
0: 
0: 		@param out the place to write to
0: 		@param e the exception to display
0: 	 */
0: 	static public void ShowSQLException(PrintWriter out, SQLException e) {
0: 		String errorCode;
0: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
0: 			errorCode = LocalizedResource.getMessage("UT_Error0", LocalizedResource.getNumber(e.getErrorCode()));
0: 		}
0: 		else {
0: 			errorCode = "";
0: 		}
0: 
0: 		while (e!=null) {
0: 			String p1 = mapNull(e.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst"));
0: 			String p2 = mapNull(e.getMessage(),LocalizedResource.getMessage("UT_NoMessa"));
0: 			out.println(LocalizedResource.getMessage("UT_Error012", p1, p2,errorCode));
0: 			doTrace(out, e);
0: 			e=e.getNextException();
0: 		}
0: 	}
0: 
0: 	/**
0: 		Print information about the SQL warnings for the connection
0: 		to the given PrintWriter.
0: 		Walks the list of exceptions, if any.
0: 
0: 		@param out the place to write to
0: 		@param theConnection the connection that may have warnings.
0: 	 */
0: 	static public void ShowWarnings(PrintWriter out, Connection theConnection) {
0: 	    try {
0: 		// GET CONNECTION WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (theConnection != null) {
0: 			ShowWarnings(out, theConnection.getWarnings());
0: 		}
0: 
0: 		if (theConnection != null) {
0: 			theConnection.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowWarnings
0: 
0: 	/**
0: 		@param out the place to write to
0: 		@param warning the SQLWarning
0: 	*/
0: 	static public void ShowWarnings(PrintWriter out, SQLWarning warning) {
0: 		while (warning != null) {
0: 			String p1 = mapNull(warning.getSQLState(),LocalizedResource.getMessage("UT_NoSqlst_7"));
0: 			String p2 = mapNull(warning.getMessage(),LocalizedResource.getMessage("UT_NoMessa_8"));
0: 			out.println(LocalizedResource.getMessage("UT_Warni01", p1, p2));
0: 			warning = warning.getNextWarning();
0: 		}
0: 	}
0: 
0: 	/**
0: 		Print information about the SQL warnings for the ResultSet
0: 		to the given PrintWriter.
0: 		Walk the list of exceptions, if any.
0: 	
0: 		@param out the place to write to
0: 		@param rs the ResultSet that may have warnings on it
0: 	 */
0: 	static public void ShowWarnings(PrintWriter out, ResultSet rs) {
0: 	    try {
0: 		// GET RESULTSET WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (rs != null) {
0: 			ShowWarnings(out, rs.getWarnings());
0: 		}
0: 
0: 		if (rs != null) {
0: 			rs.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowResultSetWarnings
0: 
0: 	/**
0: 		Print information about the SQL warnings for the Statement
0: 		to the given PrintWriter.
0: 		Walks the list of exceptions, if any.
0: 
0: 		@param out the place to write to
0: 		@param s the Statement that may have warnings on it
0: 	 */
0: 	static public void ShowWarnings(PrintWriter out, Statement s)
0: 	{
0: 	    try {
0: 		// GET STATEMENT WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (s != null) {
0: 			ShowWarnings(out, s.getWarnings());
0: 		}
0: 
0: 		if (s != null) {
0: 			s.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowStatementWarnings
0: 
0: 	//-----------------------------------------------------------------
0: 	// Methods for displaying and checking results
0: 
0: 	// REMIND: make this configurable...
0: 	static final private int MAX_RETRIES = 0;
0: 
0: 	/**
0: 		Pretty-print the results of a statement that has been executed.
0: 		If it is a select, gathers and prints the results.  Display
0: 		partial results up to the first error.
0: 		If it is not a SELECT, determine if rows were involved or not,
0: 		and print the appropriate message.
0: 
0: 		@param out the place to write to
0: 		@param stmt the Statement to display
0: 		@param conn the Connection against which the statement was executed
0: 
0: 		@exception SQLException on JDBC access failure
0: 	 */
0: 	static public void DisplayResults(PrintWriter out, Statement stmt, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayResults( out, stmt, conn, 0);			
0: 	}
0: 
0: 	static private void indent_DisplayResults
0: 	(PrintWriter out, Statement stmt, Connection conn, int indentLevel)
0: 		throws SQLException {
0: 
0: 		checkNotNull(stmt, "Statement");
0: 
0: 		ResultSet rs = stmt.getResultSet();
0: 		if (rs != null) {
0: 			indent_DisplayResults(out, rs, conn, indentLevel);
0: 			rs.close(); // let the result set go away
0: 		}
0: 		else {
0: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
0: 		}
0: 
0: 		ShowWarnings(out,stmt);
0: 	} // DisplayResults
0: 
0: 	/**
0: 		@param out the place to write to
0: 		@param count the update count to display
0: 		@param indentLevel number of tab stops to indent line
0: 	 */
0: 	static void DisplayUpdateCount(PrintWriter out, int count, int indentLevel ) {
0: 		if (count == 1) {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowInserUpdatDelet"));
0: 		}
0: 		else if (count >= 0) {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_0RowsInserUpdatDelet", LocalizedResource.getNumber(count)));
0: 		}
0: 		else {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_StateExecu"));
0: 		}
0: 	}
0: 
0: 	/**
0: 		@param out the place to write to
0: 		@param rs the ResultSet to display
0: 		@param conn the Connection against which the ResultSet was retrieved
0: 
0: 		@exception SQLException on JDBC access failure
0: 	 */
0: 	static public void DisplayResults(PrintWriter out, ResultSet rs, Connection conn)
0: 		throws SQLException
0: 	{
0: 		indent_DisplayResults( out, rs, conn, 0);
0: 	}
0: 
0: 	static private void indent_DisplayResults
0: 	(PrintWriter out, ResultSet rs, Connection conn, int indentLevel)
0: 		throws SQLException {
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 		Vector nestedResults;
0:     int numberOfRowsSelected = 0;
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		int len = indent_DisplayBanner(out,rsmd, indentLevel);
0: 
0: 		// When displaying rows, keep going past errors
0: 		// unless/until the maximum # of errors is reached.
0: 		boolean doNext = true;
0: 		int retry = 0;
0: 		while (doNext) {
0: 			try {
0: 				doNext = rs.next();
0: 				if (doNext) {
0: 
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, indentLevel);
0: 					ShowWarnings(out, rs);
0: 					numberOfRowsSelected++;
0: 				}
0: 			} catch (SQLException e) {
0: 				// REVISIT: might want to check the exception
0: 				// and for some, not bother with the retry.
0: 				if (++retry > MAX_RETRIES)
0: 					throw e;
0: 				else
0: 					ShowSQLException(out, e);
0: 			}
0: 		}
0: 		if (showSelectCount == true) {
0: 		   if (numberOfRowsSelected == 1) {
0: 			   out.println();
0: 			   indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_1RowSelec"));
0: 		   } else if (numberOfRowsSelected >= 0) {
0: 			   out.println();
0: 		       indentedPrintLine( out, indentLevel, 
0: 			LocalizedResource.getMessage("UT_0RowsSelec", LocalizedResource.getNumber(numberOfRowsSelected)));
0: 		   }
0: 		}
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 	}
0: 
0: 	/**
0: 		@param out the place to write to
0: 		@param nr the vector of results
0: 		@param conn the Connection against which the ResultSet was retrieved
0: 		@param indentLevel number of tab stops to indent line
0: 
0: 		@exception SQLException thrown on access error
0: 	 */
0: 	static private void DisplayNestedResults(PrintWriter out, Vector nr, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		if (nr == null) return;
0: 
0: 		String b=LocalizedResource.getMessage("UT_JDBCDisplayUtil_16");
0: 		String oldString="0";
0: 
0: 		for (int i=0; i < nr.size(); i++) {
0: 			LocalizedResource.OutputWriter().println();
0: 
0: 			//just too clever to get the extra +s
0: 			String t = Integer.toString(i);
0: 			if (t.length() > oldString.length()) {
0: 				oldString = t;
0: 				b=b+LocalizedResource.getMessage("UT_JDBCDisplayUtil_17");
0: 			}
0: 
0: 			LocalizedResource.OutputWriter().println(b);
0: 			LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("UT_Resul0", LocalizedResource.getNumber(i)));
0: 			LocalizedResource.OutputWriter().println(b);
0: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn, indentLevel);
0: 		}
0: 	}
0: 
0: 	/**
0: 		Fetch the next row of the result set, and if it
0: 		exists format and display a banner and the row.
0: 
0: 		@param out the place to write to
0: 		@param rs the ResultSet in use
0: 		@param conn the Connection against which the ResultSet was retrieved
0: 
0: 		@exception SQLException on JDBC access failure
0: 	 */
0: 	static public void DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayNextRow( out, rs, conn, 0 );
0: 	}
0: 
0: 	static private void indent_DisplayNextRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		Vector nestedResults;
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		checkNotNull(rs, "ResultSet");
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 
0: 		// Only print stuff out if there is a row to be had.
0: 		if (rs.next()) {
0: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
0: 		}
0: 		else {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
0: 		}
0: 
0: 		ShowWarnings(out, rs);
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 
0: 	} // DisplayNextRow
0: 
0: 	/**
0: 		Display the current row of the result set along with
0: 		a banner. Assume the result set is on a row.
0: 
0: 		@param out the place to write to
0: 		@param rs the ResultSet in use
0: 		@param conn the Connection against which the ResultSet was retrieved
0: 
0: 		@exception SQLException on JDBC access failure
0: 	 */
0: 	static public void DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayCurrentRow( out, rs, conn, 0 );
0: 	}
0: 
0: 	static private void indent_DisplayCurrentRow(PrintWriter out, ResultSet rs, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		Vector nestedResults;
0: 
0: 		if (rs == null) {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
0: 			return;
0: 		}
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 
0: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
0: 
0: 		ShowWarnings(out, rs);
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 
0: 	} // DisplayNextRow
0: 
0: 	/**
0: 		Print a banner containing the column labels separated with '|'s
0: 		and a line of '-'s.  Each field is as wide as the display
0: 		width reported by the metadata.
0: 
0: 		@param out the place to write to
0: 		@param rsmd the ResultSetMetaData to use
0: 
0: 		@exception SQLException on JDBC access failure
0: 	 */
0: 	static public int DisplayBanner(PrintWriter out, ResultSetMetaData rsmd )
0: 		throws SQLException
0: 	{
0: 		return indent_DisplayBanner( out, rsmd, 0 );
0: 	}
0: 
0: 	static private int indent_DisplayBanner(PrintWriter out, ResultSetMetaData rsmd, int indentLevel )
0: 		throws SQLException	{
0: 
0: 		StringBuffer buf = new StringBuffer();
0: 
0: 		int numCols = rsmd.getColumnCount();
0: 		int rowLen;
0: 
0: 		// do some precalculation so the buffer is allocated only once
0: 		// buffer is twice as long as the display length plus one for a newline
0: 		rowLen = (numCols - 1); // for the column separators
0: 		for (int i=1; i <= numCols; i++) {
0: 			rowLen += Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH, LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
0: 		}
0: 		buf.ensureCapacity(rowLen);
0: 
0: 		// get column header info
0: 		// truncate it to the column display width
0: 		// add a bar between each item.
0: 		for (int i=1; i <= numCols; i++) {
0: 
0: 			if (i>1)
0: 				buf.append('|');
0: 
0: 			String s = rsmd.getColumnLabel(i);
0: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max(((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH), LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
0: 
0: 			if (s.length() < w) {
0: 				// build a string buffer to hold the whitespace
0: 				StringBuffer blanks = new StringBuffer(s);
0: 				blanks.ensureCapacity(w);
0: 
0: 				// try to paste on big chunks of space at a time.
0: 				for (int k=blanks.length()+64; k<=w; k+=64)
0: 					blanks.append(
0:           "                                                                ");
0: 				for (int k=blanks.length()+16; k<=w; k+=16)
0: 					blanks.append("                ");
0: 				for (int k=blanks.length()+4; k<=w; k+=4)
0: 					blanks.append("    ");
0: 				for (int k=blanks.length(); k<w; k++)
0: 					blanks.append(' ');
0: 
0: 				buf.append(blanks);
0: 				// REMIND: could do more cleverness, like keep around
0: 				// past buffers to reuse...
0: 			}
0: 			else if (s.length() > w)  {
0: 				if (w > 1) 
0: 					buf.append(s.substring(0,w-1));
0: 				if (w > 0) 
0: 					buf.append('&');
0: 			}
0: 			else {
0: 				buf.append(s);
0: 			}
0: 		}
0: 
0: 		buf.setLength(Math.min(rowLen, 1024));
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 		// now print a row of '-'s
0: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
0: 			buf.setCharAt(i, '-');
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 		buf = null;
0: 
0: 		return rowLen;
0: 	} // DisplayBanner
0: 
0: 	/**
0: 		Print one row of a result set, padding each field to the
0: 		display width and separating them with '|'s
0: 
0: 		@param out the place to write to
0: 		@param rs the ResultSet to use
0: 		@param rsmd the ResultSetMetaData to use
0: 		@param rowLen
0: 		@param nestedResults
0: 		@param conn
0: 		@param indentLevel number of tab stops to indent line
0: 
0: 		@exception SQLException thrown on JDBC access failure
0: 	 */
0: 	static private void DisplayRow(PrintWriter out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel )
0: 		throws SQLException
0: 	{
0: 		StringBuffer buf = new StringBuffer();
0: 		buf.ensureCapacity(rowLen);
0: 
0: 		int numCols = rsmd.getColumnCount();
0: 		int i;
0: 
0: 		// get column header info
0: 		// truncate it to the column display width
0: 		// add a bar between each item.
0: 		for (i=1; i <= numCols; i++){
0: 			if (i>1)
0: 				buf.append('|');
0: 
0: 			String s;
0: 			switch (rsmd.getColumnType(i)) {
0: 			default:
0: 				s = LocalizedResource.getInstance().getLocalizedString(rs, rsmd, i );
0: 				break;
0: 			case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
0: 			case Types.OTHER:
0: 			{
0: 				Object o = rs.getObject(i);
0: 				if (o == null) { s = "NULL"; }
0: 				else if (o instanceof ResultSet && nestedResults != null)
0: 				{
0: 					s = LocalizedResource.getMessage("UT_Resul0_20", LocalizedResource.getNumber(nestedResults.size()));
0: 					nestedResults.addElement(o);
0: 				}
0: 				else
0: 				{
0: 					try {
0: 						s = rs.getString(i);
0: 					} catch (SQLException se) {
0: 						// oops, they don't support refetching the column
0: 						s = o.toString();
0: 					}
0: 				}
0: 			}
0: 			break;
0: 			}
0: 			if (s==null) s = "NULL";
0: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH, LocalizedResource.getInstance().getColumnDisplaySize(rsmd, i)));
0: 			if (s.length() < w) {
0: 				StringBuffer fullS = new StringBuffer(s);
0: 				fullS.ensureCapacity(w);
0: 				for (int k=s.length(); k<w; k++)
0: 					fullS.append(' ');
0: 				s = fullS.toString();
0: 			}
0: 			else if (s.length() > w)
0: 				// add the & marker to know it got cut off
0: 				s = s.substring(0,w-1)+"&";
0: 
0: 			buf.append(s);
0: 		}
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 	} // DisplayRow
0: 
0: 	/**
0: 		Check if an object is null, and if it is, throw an exception
0: 		with an informative parameter about what was null.
0: 		The exception is a run-time exception that is internal to ij.
0: 
0: 		@param o the object to test
0: 		@param what the information to include in the error if it is null
0: 	 */
0: 	public static void checkNotNull(Object o, String what) {
0: 		if (o == null) {
0: 			throw ijException.objectWasNull(what);
0: 		}
0: 	} // checkNotNull
0: 
0: 	/**
0: 		Map the string to the value if it is null.
0: 
0: 		@param s the string to test for null
0: 		@param nullValue the value to use if s is null
0: 
0: 		@return if s is non-null, s; else nullValue.
0: 	 */
0: 	static public String mapNull(String s, String nullValue) {
0: 		if (s==null) return nullValue;
0: 		return s;
0: 	}
0: 
0: 	/**
0: 		If the property ij.exceptionTrace is true, display the stack
0: 		trace to the print stream. Otherwise, do nothing.
0: 
0: 		@param out the output stream to write to
0: 		@param e the exception to display
0: 	 */
0: 	static public void doTrace(PrintWriter out, Exception e) {
0: 		if (Boolean.getBoolean("ij.exceptionTrace")) {
0: 			e.printStackTrace(out);
0: 		    out.flush();
0: 		}
0: 	}
0: 
0: 	static public void setMaxDisplayWidth(int maxDisplayWidth) {
0: 		maxWidth = maxDisplayWidth;
0: 	}
0: 
0: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, String text )
0: 	{
0: 		indent( out, indentLevel );
0: 		out.println( text );
0: 	}
0: 
0: 	static	private	void	indentedPrintLine( PrintWriter out, int indentLevel, StringBuffer text )
0: 	{
0: 		indent( out, indentLevel );
0: 		out.println( text );
0: 	}
0: 
0: 	static	private	void	indent( PrintWriter out, int indentLevel )
0: 	{
0: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
0: 	}
0: 
0: 	// ================
0: 
0: 	static public void ShowException(PrintStream out, Throwable e) {
0: 		if (e == null) return;
0: 
0: 		if (e instanceof SQLException)
0: 			ShowSQLException(out, (SQLException)e);
0: 		else
0: 			e.printStackTrace(out);
0: 	}
0: 
0: 	static public void ShowSQLException(PrintStream out, SQLException e) {
0: 		String errorCode;
0: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
0: 			errorCode = " (errorCode = " + e.getErrorCode() + ")";
0: 		}
0: 		else {
0: 			errorCode = "";
0: 		}
0: 
0: 		while (e!=null) {
0: 			out.println("ERROR "+mapNull(e.getSQLState(),"(no SQLState)")+": "+
0: 				 mapNull(e.getMessage(),"(no message)")+errorCode);
0: 			doTrace(out, e);
0: 			e=e.getNextException();
0: 		}
0: 	}
0: 
0: 	static public void ShowWarnings(PrintStream out, Connection theConnection) {
0: 	    try {
0: 		// GET CONNECTION WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (theConnection != null) {
0: 			ShowWarnings(out, theConnection.getWarnings());
0: 		}
0: 
0: 		if (theConnection != null) {
0: 			theConnection.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowWarnings
0: 
0: 	static public void ShowWarnings(PrintStream out, SQLWarning warning) {
0: 		while (warning != null) {
0: 			out.println("WARNING "+
0: 				mapNull(warning.getSQLState(),"(no SQLState)")+": "+
0: 				mapNull(warning.getMessage(),"(no message)"));
0: 			warning = warning.getNextWarning();
0: 		}
0: 	}
0: 
0: 	static public void ShowWarnings(PrintStream out, ResultSet rs) {
0: 	    try {
0: 		// GET RESULTSET WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (rs != null) {
0: 			ShowWarnings(out, rs.getWarnings());
0: 		}
0: 
0: 		if (rs != null) {
0: 			rs.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowResultSetWarnings
0: 
0: 	static public void ShowWarnings(PrintStream out, Statement s)
0: 	{
0: 	    try {
0: 		// GET STATEMENT WARNINGS
0: 		SQLWarning warning = null;
0: 
0: 		if (s != null) {
0: 			ShowWarnings(out, s.getWarnings());
0: 		}
0: 
0: 		if (s != null) {
0: 			s.clearWarnings();
0: 		}
0: 	    } catch (SQLException e) {
0: 			ShowSQLException(out, e);
0: 	    }
0: 	} // ShowStatementWarnings
0: 
0: 	static public void DisplayResults(PrintStream out, Statement stmt, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayResults( out, stmt, conn, 0);			
0: 	}
0: 
0: 	static private void indent_DisplayResults
0: 	(PrintStream out, Statement stmt, Connection conn, int indentLevel)
0: 		throws SQLException {
0: 
0: 		checkNotNull(stmt, "Statement");
0: 
0: 		ResultSet rs = stmt.getResultSet();
0: 		if (rs != null) {
0: 			indent_DisplayResults(out, rs, conn, indentLevel);
0: 			rs.close(); // let the result set go away
0: 		}
0: 		else {
0: 			DisplayUpdateCount(out,stmt.getUpdateCount(), indentLevel);
0: 		}
0: 
0: 		ShowWarnings(out,stmt);
0: 	} // DisplayResults
0: 
0: 	static void DisplayUpdateCount(PrintStream out, int count, int indentLevel ) {
0: 		if (count == 1) {
0: 			indentedPrintLine( out, indentLevel, "1 row inserted/updated/deleted");
0: 		}
0: 		else if (count >= 0) {
0: 			indentedPrintLine( out, indentLevel, count+" rows inserted/updated/deleted");
0: 		}
0: 		else {
0: 			indentedPrintLine( out, indentLevel, "Statement executed.");
0: 		}
0: 	}
0: 
0: 	static public void DisplayResults(PrintStream out, ResultSet rs, Connection conn)
0: 		throws SQLException
0: 	{
0: 		indent_DisplayResults( out, rs, conn, 0);
0: 	}
0: 
0: 	static private void indent_DisplayResults
0: 	(PrintStream out, ResultSet rs, Connection conn, int indentLevel)
0: 		throws SQLException {
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 		Vector nestedResults;
0:     int numberOfRowsSelected = 0;
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		int len = indent_DisplayBanner(out,rsmd, indentLevel);
0: 
0: 		// When displaying rows, keep going past errors
0: 		// unless/until the maximum # of errors is reached.
0: 		boolean doNext = true;
0: 		int retry = 0;
0: 		while (doNext) {
0: 			try {
0: 				doNext = rs.next();
0: 				if (doNext) {
0: 
0: 		    		DisplayRow(out, rs, rsmd, len, nestedResults, conn, indentLevel);
0: 					ShowWarnings(out, rs);
0: 					numberOfRowsSelected++;
0: 				}
0: 			} catch (SQLException e) {
0: 				// REVISIT: might want to check the exception
0: 				// and for some, not bother with the retry.
0: 				if (++retry > MAX_RETRIES)
0: 					throw e;
0: 				else
0: 					ShowSQLException(out, e);
0: 			}
0: 		}
0: 		if (showSelectCount == true) {
0: 		   if (numberOfRowsSelected == 1) {
0: 			   out.println();
0: 			   indentedPrintLine( out, indentLevel, "1 row selected");
0: 		   } else if (numberOfRowsSelected >= 0) {
0: 			   out.println();
0: 		       indentedPrintLine( out, indentLevel, numberOfRowsSelected + " rows selected");
0: 		   }
0: 		}
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 	}
0: 
0: 	static private void DisplayNestedResults(PrintStream out, Vector nr, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		if (nr == null) return;
0: 
0: 		String s="+ ResultSet #";
0: 		String b="++++++++++++++++";
0: 		String oldString="0";
0: 
0: 		for (int i=0; i < nr.size(); i++) {
0: 			System.out.println();
0: 
0: 			//just too clever to get the extra +s
0: 			String t = Integer.toString(i);
0: 			if (t.length() > oldString.length()) {
0: 				oldString = t;
0: 				b=b+"+";
0: 			}
0: 
0: 			System.out.println(b);
0: 			System.out.println(s+i+" +");
0: 			System.out.println(b);
0: 			indent_DisplayResults(out, (ResultSet) nr.elementAt(i), conn, indentLevel);
0: 		}
0: 	}
0: 
0: 	static public void DisplayNextRow(PrintStream out, ResultSet rs, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayNextRow( out, rs, conn, 0 );
0: 	}
0: 
0: 	static private void indent_DisplayNextRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		Vector nestedResults;
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		checkNotNull(rs, "ResultSet");
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 
0: 		// Only print stuff out if there is a row to be had.
0: 		if (rs.next()) {
0: 			int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:     		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
0: 		}
0: 		else {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow"));
0: 		}
0: 
0: 		ShowWarnings(out, rs);
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 
0: 	} // DisplayNextRow
0: 
0: 	static public void DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn )
0: 		throws SQLException
0: 	{
0: 		indent_DisplayCurrentRow( out, rs, conn, 0 );
0: 	}
0: 
0: 	static private void indent_DisplayCurrentRow(PrintStream out, ResultSet rs, Connection conn, int indentLevel )
0: 		throws SQLException {
0: 
0: 		Vector nestedResults;
0: 
0: 		if (rs == null) {
0: 			indentedPrintLine( out, indentLevel, LocalizedResource.getMessage("UT_NoCurreRow_19"));
0: 			return;
0: 		}
0: 
0: 		// autocommit must be off or the nested cursors
0: 		// are closed when the outer statement completes.
0: 		if (!conn.getAutoCommit())
0: 			nestedResults = new Vector();
0: 		else
0: 			nestedResults = null;
0: 
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		checkNotNull(rsmd, "ResultSetMetaData");
0: 
0: 		int rowLen = indent_DisplayBanner(out, rsmd, indentLevel);
0:    		DisplayRow(out, rs, rsmd, rowLen, nestedResults, conn, indentLevel );
0: 
0: 		ShowWarnings(out, rs);
0: 
0: 		DisplayNestedResults(out, nestedResults, conn, indentLevel );
0: 		nestedResults = null;
0: 
0: 	} // DisplayNextRow
0: 
0: 	static public int DisplayBanner(PrintStream out, ResultSetMetaData rsmd )
0: 		throws SQLException
0: 	{
0: 		return indent_DisplayBanner( out, rsmd, 0 );
0: 	}
0: 
0: 	static private int indent_DisplayBanner(PrintStream out, ResultSetMetaData rsmd, int indentLevel )
0: 		throws SQLException	{
0: 
0: 		StringBuffer buf = new StringBuffer();
0: 
0: 		int numCols = rsmd.getColumnCount();
0: 		int rowLen;
0: 
0: 		// do some precalculation so the buffer is allocated only once
0: 		// buffer is twice as long as the display length plus one for a newline
0: 		rowLen = (numCols - 1); // for the column separators
0: 		for (int i=1; i <= numCols; i++) {
0: 			rowLen += Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH,
0: 						rsmd.getColumnDisplaySize(i)));
0: 		}
0: 		buf.ensureCapacity(rowLen);
0: 
0: 		// get column header info
0: 		// truncate it to the column display width
0: 		// add a bar between each item.
0: 		for (int i=1; i <= numCols; i++) {
0: 
0: 			if (i>1)
0: 				buf.append('|');
0: 
0: 			String s = rsmd.getColumnLabel(i);
0: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max(((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH),
0: 						rsmd.getColumnDisplaySize(i)));
0: 
0: 			if (s.length() < w) {
0: 				// build a string buffer to hold the whitespace
0: 				StringBuffer blanks = new StringBuffer(s);
0: 				blanks.ensureCapacity(w);
0: 
0: 				// try to paste on big chunks of space at a time.
0: 				for (int k=blanks.length()+64; k<=w; k+=64)
0: 					blanks.append(
0:           "                                                                ");
0: 				for (int k=blanks.length()+16; k<=w; k+=16)
0: 					blanks.append("                ");
0: 				for (int k=blanks.length()+4; k<=w; k+=4)
0: 					blanks.append("    ");
0: 				for (int k=blanks.length(); k<w; k++)
0: 					blanks.append(' ');
0: 
0: 				buf.append(blanks);
0: 				// REMIND: could do more cleverness, like keep around
0: 				// past buffers to reuse...
0: 			}
0: 			else if (s.length() > w)  {
0: 				if (w > 1) 
0: 					buf.append(s.substring(0,w-1));
0: 				if (w > 0) 
0: 					buf.append('&');
0: 			}
0: 			else {
0: 				buf.append(s);
0: 			}
0: 		}
0: 
0: 		buf.setLength(Math.min(rowLen, 1024));
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 		// now print a row of '-'s
0: 		for (int i=0; i<Math.min(rowLen, 1024); i++)
0: 			buf.setCharAt(i, '-');
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 		buf = null;
0: 
0: 		return rowLen;
0: 	} // DisplayBanner
0: 
0: 	static private void DisplayRow(PrintStream out, ResultSet rs, ResultSetMetaData rsmd, int rowLen, Vector nestedResults, Connection conn, int indentLevel )
0: 		throws SQLException
0: 	{
0: 		StringBuffer buf = new StringBuffer();
0: 		buf.ensureCapacity(rowLen);
0: 
0: 		int numCols = rsmd.getColumnCount();
0: 		int i;
0: 
0: 		// get column header info
0: 		// truncate it to the column display width
0: 		// add a bar between each item.
0: 		for (i=1; i <= numCols; i++){
0: 			if (i>1)
0: 				buf.append('|');
0: 
0: 			String s;
0: 			switch (rsmd.getColumnType(i)) {
0: 			default:
0: 				s = rs.getString(i);
0: 				break;
0: 			case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
0: 			case Types.OTHER:
0: 			{
0: 				Object o = rs.getObject(i);
0: 				if (o == null) { s = "NULL"; }
0: 				else if (o instanceof ResultSet && nestedResults != null)
0: 				{
0: 					s = "ResultSet #"+nestedResults.size();
0: 					nestedResults.addElement(o);
0: 				}
0: 				else
0: 				{
0: 					try {
0: 						s = rs.getString(i);
0: 					} catch (SQLException se) {
0: 						// oops, they don't support refetching the column
0: 						s = o.toString();
0: 					}
0: 				}
0: 			}
0: 			break;
0: 			}
0: 
0: 			if (s==null) s = "NULL";
0: 
0: 			int w = Math.min(maxWidth,
0: 				Math.max((rsmd.isNullable(i) == 
0: 							ResultSetMetaData.columnNoNulls)?
0: 							0 : MINWIDTH,
0: 						rsmd.getColumnDisplaySize(i)));
0: 			if (s.length() < w) {
0: 				StringBuffer fullS = new StringBuffer(s);
0: 				fullS.ensureCapacity(w);
0: 				for (int k=s.length(); k<w; k++)
0: 					fullS.append(' ');
0: 				s = fullS.toString();
0: 			}
0: 			else if (s.length() > w)
0: 				// add the & marker to know it got cut off
0: 				s = s.substring(0,w-1)+"&";
0: 
0: 			buf.append(s);
0: 		}
0: 		indentedPrintLine( out, indentLevel, buf);
0: 
0: 	} // DisplayRow
0: 
0: 	static public void doTrace(PrintStream out, Exception e) {
0: 		if (Boolean.getBoolean("ij.exceptionTrace")) {
0: 			e.printStackTrace(out);
0: 		    out.flush();
0: 		}
0: 	}
0: 
0: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, String text )
0: 	{
0: 		indent( out, indentLevel );
0: 		out.println( text );
0: 	}
0: 
0: 	static	private	void	indentedPrintLine( PrintStream out, int indentLevel, StringBuffer text )
0: 	{
0: 		indent( out, indentLevel );
0: 		out.println( text );
0: 	}
0: 
0: 	static	private	void	indent( PrintStream out, int indentLevel )
0: 	{
0: 		for ( int ictr = 0; ictr < indentLevel; ictr++ ) { out.print( "  " ); }
0: 	}
0: 	
0: 	// ==========================
0: }
0: 
0: 
0: 
============================================================================