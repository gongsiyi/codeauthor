1:106ea47: /*
2:106ea47: 
1:106ea47: Derby - Class org.apache.derbyTesting.perf.clients.Runner
1:106ea47: 
1:106ea47: Licensed to the Apache Software Foundation (ASF) under one or more
1:106ea47: contributor license agreements.  See the NOTICE file distributed with
1:106ea47: this work for additional information regarding copyright ownership.
1:106ea47: The ASF licenses this file to You under the Apache License, Version 2.0
1:106ea47: (the "License"); you may not use this file except in compliance with
1:106ea47: the License.  You may obtain a copy of the License at
1:106ea47: 
1:106ea47:    http://www.apache.org/licenses/LICENSE-2.0
1:106ea47: 
1:106ea47: Unless required by applicable law or agreed to in writing, software
1:106ea47: distributed under the License is distributed on an "AS IS" BASIS,
1:106ea47: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:106ea47: See the License for the specific language governing permissions and
1:106ea47: limitations under the License.
1:106ea47: 
1:106ea47: */
1:106ea47: 
1:106ea47: package org.apache.derbyTesting.perf.clients;
1:106ea47: 
1:106ea47: import java.io.PrintStream;
1:106ea47: import java.sql.Connection;
1:106ea47: import java.sql.DriverManager;
1:106ea47: import java.sql.SQLException;
1:6f53b7f: import java.sql.Types;
1:2445ee8: import java.util.HashMap;
1:106ea47: 
1:106ea47: /**
1:106ea47:  * Class used for running a performance test from the command line. To learn
1:106ea47:  * how to run the tests, invoke this command:
1:106ea47:  * <pre>
1:106ea47:  * java org.apache.derbyTesting.perf.clients.Runner
1:106ea47:  * </pre>
1:106ea47:  */
1:106ea47: public class Runner {
1:106ea47: 
1:106ea47:     private static final String DERBY_EMBEDDED_DRIVER =
1:106ea47:             "org.apache.derby.jdbc.EmbeddedDriver";
1:106ea47: 
1:106ea47:     private static final String DEFAULT_URL = "jdbc:derby:db;create=true";
1:106ea47: 
1:106ea47:     /** The JDBC driver class to use in the test. */
1:106ea47:     private static String driver = DERBY_EMBEDDED_DRIVER;
1:106ea47:     /** The JDBC connection URL to use in the test. */
1:106ea47:     private static String url = DEFAULT_URL;
1:106ea47:     /** Username for connecting to the database. */
1:106ea47:     private static String user = "test";
1:106ea47:     /** Password for connecting to the database. */
1:106ea47:     private static String password = "test";
1:106ea47:     /**
1:106ea47:      * Flag which tells whether the data needed by this test should be
1:106ea47:      * (re)created.
1:106ea47:      */
1:106ea47:     private static boolean init = false;
1:106ea47:     /** The name of the type of load to use in the test. */
1:106ea47:     private static String load; // required argument
1:2445ee8:     /** Map containing load-specific options. */
1:9d44c9e:     private final static HashMap<String, String> loadOpts =
1:9d44c9e:             new HashMap<String, String>();
1:106ea47:     /** The name of the load generator to use in the test. */
1:106ea47:     private static String generator = "b2b";
1:106ea47:     /** The number of client threads to use in the test. */
1:106ea47:     private static int threads = 1;
1:106ea47:     /**
1:106ea47:      * The number of requests to issue to the database per second (for the
1:106ea47:      * load generators that take that as an argument).
1:106ea47:      */
1:106ea47:     private static int requestsPerSecond = 100;
1:106ea47:     /** The number of seconds to spend in the warmup phase. */
1:106ea47:     private static int warmupSec = 30;
1:106ea47:     /** The number of seconds to collect results. */
1:106ea47:     private static int steadySec = 60;
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Main method which starts the Runner application.
1:106ea47:      *
1:106ea47:      * @param args the command line arguments
1:106ea47:      */
1:106ea47:     public static void main(String[] args) throws Exception {
1:106ea47:         try {
1:106ea47:             parseArgs(args);
1:106ea47:         } catch (Exception e) {
1:106ea47:             System.err.println(e);
1:106ea47:             printUsage(System.err);
1:106ea47:             System.exit(1);
1:106ea47:         }
1:106ea47: 
1:4469400:         Class<?> clazz = Class.forName(driver);
1:4469400:         clazz.getConstructor().newInstance();
1:106ea47: 
1:106ea47:         if (init) {
1:106ea47:             DBFiller filler = getDBFiller();
1:106ea47:             Connection conn = DriverManager.getConnection(url, user, password);
1:fdd3567:             System.out.println("initializing database...");
1:106ea47:             filler.fill(conn);
1:106ea47:             conn.close();
1:106ea47:         }
1:106ea47: 
1:106ea47:         Client[] clients = new Client[threads];
1:106ea47:         for (int i = 0; i < clients.length; i++) {
1:106ea47:             Connection c = DriverManager.getConnection(url, user, password);
1:106ea47:             c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:106ea47:             clients[i] = newClient();
1:106ea47:             clients[i].init(c);
1:106ea47:         }
1:106ea47: 
1:106ea47:         LoadGenerator gen = getLoadGenerator();
1:106ea47:         gen.init(clients);
1:106ea47:         System.out.println("starting warmup...");
1:106ea47:         gen.startWarmup();
1:106ea47:         Thread.sleep(1000L * warmupSec);
1:106ea47:         System.out.println("entering steady state...");
1:106ea47:         gen.startSteadyState();
1:106ea47:         Thread.sleep(1000L * steadySec);
1:106ea47:         System.out.println("stopping threads...");
1:106ea47:         gen.stop();
1:106ea47:         gen.printReport(System.out);
1:106ea47: 
1:106ea47:         shutdownDatabase();
1:106ea47:     }
1:106ea47: 
1:2445ee8:     /**
1:106ea47:      * Parse the command line arguments and set the state variables to
1:106ea47:      * reflect the arguments.
1:106ea47:      *
1:106ea47:      * @param args the command line arguments
1:106ea47:      */
1:106ea47:     private static void parseArgs(String[] args) throws Exception {
1:106ea47:         for (int i = 0; i < args.length; i++) {
1:106ea47:             if (args[i].equals("-driver")) {
1:106ea47:                 driver = args[++i];
1:106ea47:             } else if (args[i].equals("-url")) {
1:106ea47:                 url = args[++i];
1:106ea47:             } else if (args[i].equals("-user")) {
1:106ea47:                 user = args[++i];
1:106ea47:             } else if (args[i].equals("-pass")) {
1:106ea47:                 password = args[++i];
1:106ea47:             } else if (args[i].equals("-init")) {
1:106ea47:                 init = true;
1:106ea47:             } else if (args[i].equals("-load")) {
1:106ea47:                 load = args[++i];
1:4ea38fb:             } else if (args[i].equals("-load_opts")) {
1:2445ee8:                 parseLoadOpts(args[++i]);
1:106ea47:             } else if (args[i].equals("-gen")) {
1:106ea47:                 generator = args[++i];
1:106ea47:             } else if (args[i].equals("-threads")) {
1:106ea47:                 threads = Integer.parseInt(args[++i]);
1:106ea47:             } else if (args[i].equals("-rate")) {
1:106ea47:                 requestsPerSecond = Integer.parseInt(args[++i]);
1:106ea47:             } else if (args[i].equals("-wt")) {
1:106ea47:                 warmupSec = Integer.parseInt(args[++i]);
1:106ea47:             } else if (args[i].equals("-rt")) {
1:106ea47:                 steadySec = Integer.parseInt(args[++i]);
1:106ea47:             } else {
1:106ea47:                 throw new Exception("invalid argument: " + args[i]);
1:106ea47:             }
1:106ea47:         }
1:106ea47:         if (load == null) {
1:106ea47:             throw new Exception("required parameter -load not specified");
1:106ea47:         }
1:106ea47:     }
1:106ea47: 
1:106ea47:     /**
1:2445ee8:      * Parse the load-specific options. It's a comma-separated list of options,
1:2445ee8:      * where each option is either a keyword or a (keyword, value) pair
1:2445ee8:      * separated by an equals sign (=). The parsed options will be put into the
1:2445ee8:      * map {@link #loadOpts}.
1:2445ee8:      *
1:2445ee8:      * @param optsString the comma-separated list of options
1:2445ee8:      */
1:2445ee8:     private static void parseLoadOpts(String optsString) {
1:2445ee8:         String[] opts = optsString.split(",");
1:2445ee8:         for (int i = 0; i < opts.length; i++) {
1:2445ee8:             String[] keyValue = opts[i].split("=", 2);
1:2445ee8:             if (keyValue.length == 2) {
1:2445ee8:                 loadOpts.put(keyValue[0], keyValue[1]);
1:2445ee8:             } else {
1:2445ee8:                 loadOpts.put(opts[i], null);
1:2445ee8:             }
1:2445ee8:         }
1:2445ee8:     }
1:2445ee8: 
1:2445ee8:     /**
1:2445ee8:      * Checks whether the specified option is set.
1:2445ee8:      *
1:2445ee8:      * @param option the name of the option
1:2445ee8:      * @return {@code true} if the option is set
1:2445ee8:      */
1:2445ee8:     private static boolean hasOption(String option) {
1:2445ee8:         return loadOpts.keySet().contains(option);
1:2445ee8:     }
1:2445ee8: 
1:2445ee8:     /**
1:2445ee8:      * Get the {@code int} value of the specified option.
1:2445ee8:      *
1:2445ee8:      * @param option the name of the option
1:2445ee8:      * @param defaultValue the value to return if the option is not set
1:2445ee8:      * @return the value of the option
1:2445ee8:      * @throws NumberFormatException if the value is not an {@code int}
1:2445ee8:      */
1:130cfe6:     static int getLoadOpt(String option, int defaultValue) {
1:2445ee8:         String val = (String) loadOpts.get(option);
1:2445ee8:         return val == null ? defaultValue : Integer.parseInt(val);
1:2445ee8:     }
1:2445ee8: 
1:106ea47:     /** String to print when there are errors in the command line arguments. */
1:106ea47:     private static final String USAGE =
1:106ea47: 
1:106ea47: "Valid parameters:\n" +
1:106ea47: "  -driver: JDBC driver class, default: " + DERBY_EMBEDDED_DRIVER + "\n" +
1:106ea47: "  -url: JDBC connection url, default: " +  DEFAULT_URL + "\n" +
1:106ea47: "  -user: JDBC user name, default: test\n" +
1:106ea47: "  -pass: JDBC user password, default: test\n" +
1:106ea47: "  -init: initialize database (otherwise, reuse database)\n" +
1:106ea47: "  -load: type of load, required argument, valid types:\n" +
1:106ea47: "      * sr_select - single-record (primary key) select from table with\n" +
1:4ea38fb: "                    100 000 rows. It accepts the following load-specific\n" +
1:4ea38fb: "                    options (see also -load_opts):\n" +
1:4ea38fb: "            - blob or clob: use BLOB or CLOB data instead of VARCHAR\n" +
1:4ea38fb: "            - secondary: select on a column with a secondary (non-unique)\n" +
1:4ea38fb: "              index instead of the primary key\n" +
1:4ea38fb: "            - nonIndexed: select on a non-indexed column instead of the\n" +
1:4ea38fb: "              primary key\n" +
1:106ea47: "      * sr_update - single-record (primary key) update on table with\n" +
1:4ea38fb: "                    100 000 rows. It accepts the same load-specific\n" +
1:4ea38fb: "                    options as sr_select.\n" +
1:106ea47: "      * sr_select_big - single-record (primary key) select from table with\n" +
1:106ea47: "                    100 000 000 rows\n" +
1:106ea47: "      * sr_update_big - single-record (primary key) update on table with\n" +
1:106ea47: "                    100 000 000 rows\n" +
1:106ea47: "      * sr_select_multi - single-record select from a random table\n" +
1:106ea47: "                    (32 tables with a single row each)\n" +
1:106ea47: "      * sr_update_multi - single-record update on a random table\n" +
1:106ea47: "                    (32 tables with a single row each)\n" +
1:106ea47: "      * index_join - join of two tables (using indexed columns)\n" +
1:130cfe6: "      * group_by - GROUP BY queries against TENKTUP1\n" +
1:2445ee8: "      * bank_tx - emulate simple bank transactions, similar to TPC-B. The\n" +
1:2445ee8: "                  following load-specific options are accepted:\n" +
1:2445ee8: "            - branches=NN: specifies the number of branches in the db\n" +
1:2445ee8: "                           (default: 1)\n" +
1:2445ee8: "            - tellersPerBranch=NN: specifies how many tellers each branch\n" +
1:2445ee8: "              in the database has (default: 10)\n" +
1:2445ee8: "            - accountsPerBranch=NN: specifies the number of accounts in\n" +
1:2445ee8: "              each branch (default: 100000)\n" +
1:9a05e65: "      * seq_gen - sequence generator concurrency. Accepts\n" +
1:9a05e65: "                    the following load-specific options (see also -load_opts):\n" +
1:9a05e65: "            - numberOfGenerators: number of sequences to create\n" +
1:9a05e65: "            - tablesPerGenerator: number of tables to create per sequence\n" +
1:9a05e65: "            - insertsPerTransaction: number of inserts to perform per transaction\n" +
1:9a05e65: "            - debugging: 1 means print debug chatter, 0 means do not print the chatter\n" +
1:db26d0a: "            - identityTest: 1 means do identity column testing, any other number \n" +
1:db26d0a: "                    means do sequence generator testing. If no identityTest is specified \n" +
1:db26d0a: "                    then sequence generator testing will be done by default \n" +
1:4ea38fb: "  -load_opts: comma-separated list of load-specific options\n" +
1:106ea47: "  -gen: load generator, default: b2b, valid types:\n" +
1:106ea47: "      * b2b - clients perform operations back-to-back\n" +
1:106ea47: "      * poisson - load is Poisson distributed\n" +
1:106ea47: "  -threads: number of threads performing operations, default: 1\n" +
1:106ea47: "  -rate: average number of transactions per second to inject when\n" +
1:106ea47: "         load generator is \"poisson\", default: 100\n" +
1:106ea47: "  -wt: warmup time in seconds, default: 30\n" +
1:106ea47: "  -rt: time in seconds to collect results, default: 60";
1:106ea47:     /**
1:106ea47:      * Print the usage string.
1:106ea47:      *
1:106ea47:      * @param out the stream to print the usage string to
1:106ea47:      */
1:106ea47:     private static void printUsage(PrintStream out) {
1:106ea47:         out.println(USAGE);
1:106ea47:     }
1:106ea47: 
1:106ea47:     /**
1:4ea38fb:      * Get the data type to be used for sr_select and sr_update types of load.
1:4ea38fb:      *
1:4ea38fb:      * @return one of the {@code java.sql.Types} data type constants
1:4ea38fb:      */
1:4ea38fb:     private static int getTextType() {
1:2445ee8:         boolean blob = hasOption("blob");
1:2445ee8:         boolean clob = hasOption("clob");
1:4ea38fb:         if (blob && clob) {
1:4ea38fb:             System.err.println("Cannot specify both 'blob' and 'clob'");
1:4ea38fb:             printUsage(System.err);
1:4ea38fb:             System.exit(1);
1:4ea38fb:         }
1:4ea38fb:         if (blob) {
1:4ea38fb:             return Types.BLOB;
1:4ea38fb:         }
1:4ea38fb:         if (clob) {
1:4ea38fb:             return Types.CLOB;
1:4ea38fb:         }
1:4ea38fb:         return Types.VARCHAR;
1:4ea38fb:     }
1:4ea38fb: 
1:4ea38fb:     /**
1:106ea47:      * Find the {@code DBFiller} instance for the load specified on the
1:106ea47:      * command line.
1:106ea47:      *
1:106ea47:      * @return a {@code DBFiller} instance
1:106ea47:      */
1:106ea47:     private static DBFiller getDBFiller() {
1:106ea47:         if (load.equals("sr_select") || load.equals("sr_update")) {
1:4ea38fb:             return new SingleRecordFiller(100000, 1, getTextType(),
1:2445ee8:                                           hasOption("secondary"),
1:2445ee8:                                           hasOption("nonIndexed"));
1:106ea47:         } else if (load.equals("sr_select_big") ||
1:106ea47:                        load.equals("sr_update_big")) {
1:4ea38fb:             return new SingleRecordFiller(100000000, 1);
1:106ea47:         } else if (load.equals("sr_select_multi") ||
1:106ea47:                        load.equals("sr_update_multi")) {
1:4ea38fb:             return new SingleRecordFiller(1, 32);
1:106ea47:         } else if (load.equals("index_join")) {
1:106ea47:             return new WisconsinFiller();
1:130cfe6:         } else if (load.equals("group_by")) {
1:130cfe6:             return new WisconsinFiller(getLoadOpt("numRows", 10000));
1:2445ee8:         } else if (load.equals("bank_tx")) {
1:2445ee8:             return new BankAccountFiller(
1:2445ee8:                 getLoadOpt("branches", 1),
1:2445ee8:                 getLoadOpt("tellersPerBranch", 10),
1:2445ee8:                 getLoadOpt("accountsPerBranch", 100000));
1:9a05e65:         } else if (load.equals("seq_gen")) {
1:9a05e65:             return new SequenceGeneratorConcurrency.Filler();
1:106ea47:         }
1:106ea47:         System.err.println("unknown load: " + load);
1:106ea47:         printUsage(System.err);
1:106ea47:         System.exit(1);
1:106ea47:         return null;
1:106ea47:     }
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Create a new client for the load specified on the command line.
1:106ea47:      *
1:106ea47:      * @return a {@code Client} instance
1:106ea47:      */
1:106ea47:     private static Client newClient() {
1:106ea47:         if (load.equals("sr_select")) {
1:4ea38fb:             return new SingleRecordSelectClient(100000, 1, getTextType(),
1:2445ee8:                     hasOption("secondary"), hasOption("nonIndexed"));
1:106ea47:         } else if (load.equals("sr_update")) {
1:4ea38fb:             return new SingleRecordUpdateClient(100000, 1, getTextType(),
1:2445ee8:                     hasOption("secondary"), hasOption("nonIndexed"));
1:106ea47:         } else if (load.equals("sr_select_big")) {
1:4ea38fb:             return new SingleRecordSelectClient(100000000, 1);
1:106ea47:         } else if (load.equals("sr_update_big")) {
1:106ea47:             return new SingleRecordUpdateClient(100000000, 1);
1:106ea47:         } else if (load.equals("sr_select_multi")) {
1:4ea38fb:             return new SingleRecordSelectClient(1, 32);
1:106ea47:         } else if (load.equals("sr_update_multi")) {
1:106ea47:             return new SingleRecordUpdateClient(1, 32);
1:106ea47:         } else if (load.equals("index_join")) {
1:106ea47:             return new IndexJoinClient();
1:130cfe6:         } else if (load.equals("group_by")) {
1:130cfe6:             return new GroupByClient();
1:2445ee8:         } else if (load.equals("bank_tx")) {
1:2445ee8:             return new BankTransactionClient(
1:2445ee8:                 getLoadOpt("branches", 1),
1:2445ee8:                 getLoadOpt("tellersPerBranch", 10),
1:2445ee8:                 getLoadOpt("accountsPerBranch", 100000));
1:9a05e65:         } else if (load.equals("seq_gen")) {
1:9a05e65:             return new SequenceGeneratorConcurrency.SGClient();
1:106ea47:         }
1:106ea47:         System.err.println("unknown load: " + load);
1:106ea47:         printUsage(System.err);
1:106ea47:         System.exit(1);
1:106ea47:         return null;
1:106ea47:     }
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Create a load generator for the load specified on the command line.
1:106ea47:      *
1:106ea47:      * @return a {@code LoadGenerator} instance
1:106ea47:      */
1:106ea47:     private static LoadGenerator getLoadGenerator() {
1:106ea47:         if (generator.equals("b2b")) {
1:106ea47:             return new BackToBackLoadGenerator();
1:106ea47:         } else if (generator.equals("poisson")) {
1:106ea47:             double avgWaitTime = 1000d * threads / requestsPerSecond;
1:106ea47:             return new PoissonLoadGenerator(avgWaitTime);
1:106ea47:         }
1:106ea47:         System.err.println("unknown load generator: " + generator);
1:106ea47:         printUsage(System.err);
1:106ea47:         System.exit(1);
1:106ea47:         return null;
1:106ea47:     }
1:106ea47: 
1:106ea47:     /**
1:106ea47:      * Shut down the database if it is a Derby embedded database.
1:106ea47:      */
1:106ea47:     private static void shutdownDatabase() throws SQLException {
1:106ea47:         if (driver.equals(DERBY_EMBEDDED_DRIVER)) {
1:106ea47:             try {
1:106ea47:                 DriverManager.getConnection(url + ";shutdown=true");
1:106ea47:                 System.err.println("WARNING: Shutdown of database didn't " +
1:106ea47:                                    "throw expected exception");
1:106ea47:             } catch (SQLException e) {
1:106ea47:                 if (!"08006".equals(e.getSQLState())) {
1:106ea47:                     System.err.println("WARNING: Shutdown of database threw " +
1:106ea47:                                        "unexpected exception");
1:106ea47:                     e.printStackTrace();
1:106ea47:                 }
1:106ea47:             }
1:106ea47:         }
1:106ea47:     }
1:106ea47: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Class<?> clazz = Class.forName(driver);
1:         clazz.getConstructor().newInstance();
commit:9a05e65
/////////////////////////////////////////////////////////////////////////
1: "      * seq_gen - sequence generator concurrency. Accepts\n" +
1: "                    the following load-specific options (see also -load_opts):\n" +
1: "            - numberOfGenerators: number of sequences to create\n" +
1: "            - tablesPerGenerator: number of tables to create per sequence\n" +
1: "            - insertsPerTransaction: number of inserts to perform per transaction\n" +
1: "            - debugging: 1 means print debug chatter, 0 means do not print the chatter\n" +
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("seq_gen")) {
1:             return new SequenceGeneratorConcurrency.Filler();
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("seq_gen")) {
1:             return new SequenceGeneratorConcurrency.SGClient();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
1:     private final static HashMap<String, String> loadOpts =
1:             new HashMap<String, String>();
commit:fdd3567
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             System.out.println("initializing database...");
commit:2445ee8
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     /** Map containing load-specific options. */
0:     private final static HashMap loadOpts = new HashMap();
/////////////////////////////////////////////////////////////////////////
1:                 parseLoadOpts(args[++i]);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Parse the load-specific options. It's a comma-separated list of options,
1:      * where each option is either a keyword or a (keyword, value) pair
1:      * separated by an equals sign (=). The parsed options will be put into the
1:      * map {@link #loadOpts}.
1:      *
1:      * @param optsString the comma-separated list of options
1:      */
1:     private static void parseLoadOpts(String optsString) {
1:         String[] opts = optsString.split(",");
1:         for (int i = 0; i < opts.length; i++) {
1:             String[] keyValue = opts[i].split("=", 2);
1:             if (keyValue.length == 2) {
1:                 loadOpts.put(keyValue[0], keyValue[1]);
1:             } else {
1:                 loadOpts.put(opts[i], null);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Checks whether the specified option is set.
1:      *
1:      * @param option the name of the option
1:      * @return {@code true} if the option is set
1:      */
1:     private static boolean hasOption(String option) {
1:         return loadOpts.keySet().contains(option);
1:     }
1: 
1:     /**
1:      * Get the {@code int} value of the specified option.
1:      *
1:      * @param option the name of the option
1:      * @param defaultValue the value to return if the option is not set
1:      * @return the value of the option
1:      * @throws NumberFormatException if the value is not an {@code int}
1:      */
0:     private static int getLoadOpt(String option, int defaultValue) {
1:         String val = (String) loadOpts.get(option);
1:         return val == null ? defaultValue : Integer.parseInt(val);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: "      * bank_tx - emulate simple bank transactions, similar to TPC-B. The\n" +
1: "                  following load-specific options are accepted:\n" +
1: "            - branches=NN: specifies the number of branches in the db\n" +
1: "                           (default: 1)\n" +
1: "            - tellersPerBranch=NN: specifies how many tellers each branch\n" +
1: "              in the database has (default: 10)\n" +
1: "            - accountsPerBranch=NN: specifies the number of accounts in\n" +
1: "              each branch (default: 100000)\n" +
/////////////////////////////////////////////////////////////////////////
1:         boolean blob = hasOption("blob");
1:         boolean clob = hasOption("clob");
/////////////////////////////////////////////////////////////////////////
1:                                           hasOption("secondary"),
1:                                           hasOption("nonIndexed"));
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("bank_tx")) {
1:             return new BankAccountFiller(
1:                 getLoadOpt("branches", 1),
1:                 getLoadOpt("tellersPerBranch", 10),
1:                 getLoadOpt("accountsPerBranch", 100000));
/////////////////////////////////////////////////////////////////////////
1:                     hasOption("secondary"), hasOption("nonIndexed"));
1:                     hasOption("secondary"), hasOption("nonIndexed"));
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("bank_tx")) {
1:             return new BankTransactionClient(
1:                 getLoadOpt("branches", 1),
1:                 getLoadOpt("tellersPerBranch", 10),
1:                 getLoadOpt("accountsPerBranch", 100000));
commit:4ea38fb
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
0: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:     /** Set of load-specific options. */
0:     private final static HashSet loadOpts = new HashSet();
/////////////////////////////////////////////////////////////////////////
1:             } else if (args[i].equals("-load_opts")) {
0:                 loadOpts.addAll(Arrays.asList(args[++i].split(",")));
/////////////////////////////////////////////////////////////////////////
1: "                    100 000 rows. It accepts the following load-specific\n" +
1: "                    options (see also -load_opts):\n" +
1: "            - blob or clob: use BLOB or CLOB data instead of VARCHAR\n" +
1: "            - secondary: select on a column with a secondary (non-unique)\n" +
1: "              index instead of the primary key\n" +
1: "            - nonIndexed: select on a non-indexed column instead of the\n" +
1: "              primary key\n" +
1: "                    100 000 rows. It accepts the same load-specific\n" +
1: "                    options as sr_select.\n" +
/////////////////////////////////////////////////////////////////////////
1: "  -load_opts: comma-separated list of load-specific options\n" +
/////////////////////////////////////////////////////////////////////////
1:      * Get the data type to be used for sr_select and sr_update types of load.
1:      *
1:      * @return one of the {@code java.sql.Types} data type constants
1:      */
1:     private static int getTextType() {
0:         boolean blob = loadOpts.contains("blob");
0:         boolean clob = loadOpts.contains("clob");
1:         if (blob && clob) {
1:             System.err.println("Cannot specify both 'blob' and 'clob'");
1:             printUsage(System.err);
1:             System.exit(1);
1:         }
1:         if (blob) {
1:             return Types.BLOB;
1:         }
1:         if (clob) {
1:             return Types.CLOB;
1:         }
1:         return Types.VARCHAR;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:             return new SingleRecordFiller(100000, 1, getTextType(),
0:                                           loadOpts.contains("secondary"),
0:                                           loadOpts.contains("nonIndexed"));
1:             return new SingleRecordFiller(100000000, 1);
1:             return new SingleRecordFiller(1, 32);
/////////////////////////////////////////////////////////////////////////
1:             return new SingleRecordSelectClient(100000, 1, getTextType(),
0:                     loadOpts.contains("secondary"),
0:                     loadOpts.contains("nonIndexed"));
1:             return new SingleRecordUpdateClient(100000, 1, getTextType(),
0:                     loadOpts.contains("secondary"),
0:                     loadOpts.contains("nonIndexed"));
1:             return new SingleRecordSelectClient(100000000, 1);
1:             return new SingleRecordSelectClient(1, 32);
commit:6f53b7f
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
0: "                    100 000 rows. If _blob or _clob is appended to the\n" +
0: "                    name, BLOB/CLOB is used for the data columns.\n" +
/////////////////////////////////////////////////////////////////////////
0:             return new SingleRecordFiller(100000, 1, Types.VARCHAR);
0:         } else if (load.equals("sr_select_blob")) {
0:             return new SingleRecordFiller(100000, 1, Types.BLOB);
0:         } else if (load.equals("sr_select_clob")) {
0:             return new SingleRecordFiller(100000, 1, Types.CLOB);
0:             return new SingleRecordFiller(100000000, 1, Types.VARCHAR);
0:             return new SingleRecordFiller(1, 32, Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
0:             return new SingleRecordSelectClient(100000, 1, Types.VARCHAR);
0:         } else if (load.equals("sr_select_blob")) {
0:             return new SingleRecordSelectClient(100000, 1, Types.BLOB);
0:         } else if (load.equals("sr_select_clob")) {
0:             return new SingleRecordSelectClient(100000, 1, Types.CLOB);
0:             return new SingleRecordSelectClient(100000000, 1, Types.VARCHAR);
0:             return new SingleRecordSelectClient(1, 32, Types.VARCHAR);
commit:106ea47
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.perf.clients.Runner
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.perf.clients;
1: 
1: import java.io.PrintStream;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: 
1: /**
1:  * Class used for running a performance test from the command line. To learn
1:  * how to run the tests, invoke this command:
1:  * <pre>
1:  * java org.apache.derbyTesting.perf.clients.Runner
1:  * </pre>
1:  */
1: public class Runner {
1: 
1:     private static final String DERBY_EMBEDDED_DRIVER =
1:             "org.apache.derby.jdbc.EmbeddedDriver";
1: 
1:     private static final String DEFAULT_URL = "jdbc:derby:db;create=true";
1: 
1:     /** The JDBC driver class to use in the test. */
1:     private static String driver = DERBY_EMBEDDED_DRIVER;
1:     /** The JDBC connection URL to use in the test. */
1:     private static String url = DEFAULT_URL;
1:     /** Username for connecting to the database. */
1:     private static String user = "test";
1:     /** Password for connecting to the database. */
1:     private static String password = "test";
1:     /**
1:      * Flag which tells whether the data needed by this test should be
1:      * (re)created.
1:      */
1:     private static boolean init = false;
1:     /** The name of the type of load to use in the test. */
1:     private static String load; // required argument
1:     /** The name of the load generator to use in the test. */
1:     private static String generator = "b2b";
1:     /** The number of client threads to use in the test. */
1:     private static int threads = 1;
1:     /**
1:      * The number of requests to issue to the database per second (for the
1:      * load generators that take that as an argument).
1:      */
1:     private static int requestsPerSecond = 100;
1:     /** The number of seconds to spend in the warmup phase. */
1:     private static int warmupSec = 30;
1:     /** The number of seconds to collect results. */
1:     private static int steadySec = 60;
1: 
1:     /**
1:      * Main method which starts the Runner application.
1:      *
1:      * @param args the command line arguments
1:      */
1:     public static void main(String[] args) throws Exception {
1:         try {
1:             parseArgs(args);
1:         } catch (Exception e) {
1:             System.err.println(e);
1:             printUsage(System.err);
1:             System.exit(1);
1:         }
1: 
0:         Class.forName(driver).newInstance();
1: 
1:         if (init) {
1:             DBFiller filler = getDBFiller();
1:             Connection conn = DriverManager.getConnection(url, user, password);
0:             System.out.println("initializing database...");
1:             filler.fill(conn);
1:             conn.close();
1:         }
1: 
1:         Client[] clients = new Client[threads];
1:         for (int i = 0; i < clients.length; i++) {
1:             Connection c = DriverManager.getConnection(url, user, password);
1:             c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:             clients[i] = newClient();
1:             clients[i].init(c);
1:         }
1: 
1:         LoadGenerator gen = getLoadGenerator();
1:         gen.init(clients);
1:         System.out.println("starting warmup...");
1:         gen.startWarmup();
1:         Thread.sleep(1000L * warmupSec);
1:         System.out.println("entering steady state...");
1:         gen.startSteadyState();
1:         Thread.sleep(1000L * steadySec);
1:         System.out.println("stopping threads...");
1:         gen.stop();
1:         gen.printReport(System.out);
1: 
1:         shutdownDatabase();
1:     }
1: 
1:     /**
1:      * Parse the command line arguments and set the state variables to
1:      * reflect the arguments.
1:      *
1:      * @param args the command line arguments
1:      */
1:     private static void parseArgs(String[] args) throws Exception {
1:         for (int i = 0; i < args.length; i++) {
1:             if (args[i].equals("-driver")) {
1:                 driver = args[++i];
1:             } else if (args[i].equals("-url")) {
1:                 url = args[++i];
1:             } else if (args[i].equals("-user")) {
1:                 user = args[++i];
1:             } else if (args[i].equals("-pass")) {
1:                 password = args[++i];
1:             } else if (args[i].equals("-init")) {
1:                 init = true;
1:             } else if (args[i].equals("-load")) {
1:                 load = args[++i];
1:             } else if (args[i].equals("-gen")) {
1:                 generator = args[++i];
1:             } else if (args[i].equals("-threads")) {
1:                 threads = Integer.parseInt(args[++i]);
1:             } else if (args[i].equals("-rate")) {
1:                 requestsPerSecond = Integer.parseInt(args[++i]);
1:             } else if (args[i].equals("-wt")) {
1:                 warmupSec = Integer.parseInt(args[++i]);
1:             } else if (args[i].equals("-rt")) {
1:                 steadySec = Integer.parseInt(args[++i]);
1:             } else {
1:                 throw new Exception("invalid argument: " + args[i]);
1:             }
1:         }
1:         if (load == null) {
1:             throw new Exception("required parameter -load not specified");
1:         }
1:     }
1: 
1:     /** String to print when there are errors in the command line arguments. */
1:     private static final String USAGE =
1: 
1: "Valid parameters:\n" +
1: "  -driver: JDBC driver class, default: " + DERBY_EMBEDDED_DRIVER + "\n" +
1: "  -url: JDBC connection url, default: " +  DEFAULT_URL + "\n" +
1: "  -user: JDBC user name, default: test\n" +
1: "  -pass: JDBC user password, default: test\n" +
1: "  -init: initialize database (otherwise, reuse database)\n" +
1: "  -load: type of load, required argument, valid types:\n" +
1: "      * sr_select - single-record (primary key) select from table with\n" +
0: "                    100 000 rows\n" +
1: "      * sr_update - single-record (primary key) update on table with\n" +
0: "                    100 000 rows\n" +
1: "      * sr_select_big - single-record (primary key) select from table with\n" +
1: "                    100 000 000 rows\n" +
1: "      * sr_update_big - single-record (primary key) update on table with\n" +
1: "                    100 000 000 rows\n" +
1: "      * sr_select_multi - single-record select from a random table\n" +
1: "                    (32 tables with a single row each)\n" +
1: "      * sr_update_multi - single-record update on a random table\n" +
1: "                    (32 tables with a single row each)\n" +
1: "      * index_join - join of two tables (using indexed columns)\n" +
1: "  -gen: load generator, default: b2b, valid types:\n" +
1: "      * b2b - clients perform operations back-to-back\n" +
1: "      * poisson - load is Poisson distributed\n" +
1: "  -threads: number of threads performing operations, default: 1\n" +
1: "  -rate: average number of transactions per second to inject when\n" +
1: "         load generator is \"poisson\", default: 100\n" +
1: "  -wt: warmup time in seconds, default: 30\n" +
1: "  -rt: time in seconds to collect results, default: 60";
1: 
1:     /**
1:      * Print the usage string.
1:      *
1:      * @param out the stream to print the usage string to
1:      */
1:     private static void printUsage(PrintStream out) {
1:         out.println(USAGE);
1:     }
1: 
1:     /**
1:      * Find the {@code DBFiller} instance for the load specified on the
1:      * command line.
1:      *
1:      * @return a {@code DBFiller} instance
1:      */
1:     private static DBFiller getDBFiller() {
1:         if (load.equals("sr_select") || load.equals("sr_update")) {
0:             return new SingleRecordFiller(100000, 1);
1:         } else if (load.equals("sr_select_big") ||
1:                        load.equals("sr_update_big")) {
0:             return new SingleRecordFiller(100000000, 1);
1:         } else if (load.equals("sr_select_multi") ||
1:                        load.equals("sr_update_multi")) {
0:             return new SingleRecordFiller(1, 32);
1:         } else if (load.equals("index_join")) {
1:             return new WisconsinFiller();
1:         }
1:         System.err.println("unknown load: " + load);
1:         printUsage(System.err);
1:         System.exit(1);
1:         return null;
1:     }
1: 
1:     /**
1:      * Create a new client for the load specified on the command line.
1:      *
1:      * @return a {@code Client} instance
1:      */
1:     private static Client newClient() {
1:         if (load.equals("sr_select")) {
0:             return new SingleRecordSelectClient(100000, 1);
1:         } else if (load.equals("sr_update")) {
0:             return new SingleRecordUpdateClient(100000, 1);
1:         } else if (load.equals("sr_select_big")) {
0:             return new SingleRecordSelectClient(100000000, 1);
1:         } else if (load.equals("sr_update_big")) {
1:             return new SingleRecordUpdateClient(100000000, 1);
1:         } else if (load.equals("sr_select_multi")) {
0:             return new SingleRecordSelectClient(1, 32);
1:         } else if (load.equals("sr_update_multi")) {
1:             return new SingleRecordUpdateClient(1, 32);
1:         } else if (load.equals("index_join")) {
1:             return new IndexJoinClient();
1:         }
1:         System.err.println("unknown load: " + load);
1:         printUsage(System.err);
1:         System.exit(1);
1:         return null;
1:     }
1: 
1:     /**
1:      * Create a load generator for the load specified on the command line.
1:      *
1:      * @return a {@code LoadGenerator} instance
1:      */
1:     private static LoadGenerator getLoadGenerator() {
1:         if (generator.equals("b2b")) {
1:             return new BackToBackLoadGenerator();
1:         } else if (generator.equals("poisson")) {
1:             double avgWaitTime = 1000d * threads / requestsPerSecond;
1:             return new PoissonLoadGenerator(avgWaitTime);
1:         }
1:         System.err.println("unknown load generator: " + generator);
1:         printUsage(System.err);
1:         System.exit(1);
1:         return null;
1:     }
1: 
1:     /**
1:      * Shut down the database if it is a Derby embedded database.
1:      */
1:     private static void shutdownDatabase() throws SQLException {
1:         if (driver.equals(DERBY_EMBEDDED_DRIVER)) {
1:             try {
1:                 DriverManager.getConnection(url + ";shutdown=true");
1:                 System.err.println("WARNING: Shutdown of database didn't " +
1:                                    "throw expected exception");
1:             } catch (SQLException e) {
1:                 if (!"08006".equals(e.getSQLState())) {
1:                     System.err.println("WARNING: Shutdown of database threw " +
1:                                        "unexpected exception");
1:                     e.printStackTrace();
1:                 }
1:             }
1:         }
1:     }
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:db26d0a
/////////////////////////////////////////////////////////////////////////
0:             System.out.print("initializing database for ");
0:             System.out.println((Runner.getLoadOpt( "identityTest", 0 ) == 1)?
0:             				"identity column testing...":
0:             				"sequence generator testing...");
/////////////////////////////////////////////////////////////////////////
1: "            - identityTest: 1 means do identity column testing, any other number \n" +
1: "                    means do sequence generator testing. If no identityTest is specified \n" +
1: "                    then sequence generator testing will be done by default \n" +
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:130cfe6
/////////////////////////////////////////////////////////////////////////
1:     static int getLoadOpt(String option, int defaultValue) {
/////////////////////////////////////////////////////////////////////////
1: "      * group_by - GROUP BY queries against TENKTUP1\n" +
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("group_by")) {
1:             return new WisconsinFiller(getLoadOpt("numRows", 10000));
/////////////////////////////////////////////////////////////////////////
1:         } else if (load.equals("group_by")) {
1:             return new GroupByClient();
============================================================================