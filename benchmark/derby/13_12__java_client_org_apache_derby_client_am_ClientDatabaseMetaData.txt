1:33776ff: /*
111:33776ff: 
1:69e3d06:    Derby - Class DatabaseMetaData
1:d326b7d: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:90731d5: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:d506170: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:d506170: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:69e3d06: import java.sql.Connection;
1:69e3d06: import java.sql.DatabaseMetaData;
1:69e3d06: import java.sql.ResultSet;
1:9a0cdf1: import java.sql.RowIdLifetime;
1:d506170: import java.sql.SQLException;
1:69e3d06: import java.sql.Types;
1:69e3d06: import java.util.StringTokenizer;
1:486829c: 
1:b6cdb88: import org.apache.derby.iapi.services.info.JVMInfo;
1:486829c: import org.apache.derby.shared.common.reference.SQLState;
1:486829c: 
1:33776ff: // Note:
1:33776ff: //   Tag members using the strictest visibility.
1:33776ff: // Note:
1:33776ff: //   Mark methods synchronized if and only if they update object state and are public.
1:33776ff: // Not yet done:
1:33776ff: //   Application heap data should be copied for shiraz.
1:33776ff: //   Save for future pass to avoid clutter during development.
1:33776ff: // Not yet done:
1:33776ff: //   Apply meaning-preserving program transformations for performance,
1:33776ff: //   including the replacement of slow ADTs with faster unsynchronized ADTs.
1:33776ff: //   Save for future pass to avoid clutter during development.
1:33776ff: // Not yet done:
1:33776ff: //   Assign an ErrorKey, ResourceKey, and Resource for each throw statement.
1:33776ff: //   Save for future pass to avoid maintenance during development.
1:33776ff: 
1:69e3d06: public abstract class ClientDatabaseMetaData implements DatabaseMetaData {
1:70f7692:     //----------------------------- constants  -----------------------------------
1:33776ff: 
1:70f7692:     private final static short SQL_BEST_ROWID = 1;
1:70f7692:     private final static short SQL_ROWVER = 2;
1:33776ff: 
1:70f7692:     private final static short SQL_INDEX_UNIQUE = 0;
1:70f7692:     private final static short SQL_INDEX_ALL = 1;
1:33776ff: 
1:70f7692:     //---------------------navigational members-----------------------------------
1:33776ff: 
1:0326967:     private Agent agent_;
1:69e3d06:     protected ClientConnection connection_;
1:33776ff: 
1:70f7692:     //-----------------------------state------------------------------------------
1:33776ff: 
1:70f7692:     private final static int numberOfMetaDataInfoMethods__ = 108;
1:70f7692:     private Object[] metaDataInfoCache_ = new Object[numberOfMetaDataInfoMethods__];
1:70f7692:     private boolean metaDataInfoIsCached_ = false;
1:33776ff: 
1:0326967:     ProductLevel productLevel_;
1:33776ff: 
1:178ae9d:     /** The JDBC major version supported by the server. */
1:178ae9d:     private final int serverJdbcMajorVersion;
1:178ae9d:     /** The JDBC minor version supported by the server. */
1:178ae9d:     private final int serverJdbcMinorVersion;
1:178ae9d: 
1:eff3919:     /** True if the server supports QRYCLSIMP. */
1:eff3919:     private boolean supportsQryclsimp_;
1:eff3919:     
1:eff3919:     private boolean supportsLayerBStreaming_;
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * True if the server supports session data caching
1:eff3919:      */
1:eff3919:     private boolean supportsSessionDataCaching_;
1:eff3919: 
1:eff3919:     /** True if the server supports UDTs */
1:eff3919:     private boolean supportsUDTs_;
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * True if the server supports aborting a statement whilst transferring
1:eff3919:      * EXTDTA objects. Note that there are two types of aborts, depending on
1:eff3919:      * whether an object is being transferred to the server using DDM layer B
1:eff3919:      * streaming or not.
1:eff3919:      */
1:eff3919:     private boolean supportsEXTDTAAbort_;
1:eff3919:     
1:eff3919:     /** True if the server supports nanoseconds in timestamps */
1:eff3919:     private boolean supportsTimestampNanoseconds_;
1:eff3919:     
1:eff3919:     /** True if the server supports boolean values */
1:eff3919:     private boolean supportsBooleanValues_;
1:eff3919: 
1:d326b7d:     /**
1:813aa38:      * DERBY-4805(Increase the length of the RDBNAM field in the DRDA 
1:813aa38:      *   implementation)  
1:813aa38:      * True if the server supports RDBNAM longer than 255 character
1:813aa38:      */
1:813aa38:     private boolean supportsLongRDBNAM_;
1:813aa38: 
1:813aa38:     /**
1:d326b7d:      * True if the server supports transport of boolean parameter values as
1:d326b7d:      * booleans. If false, boolean values used as parameters in prepared
1:d326b7d:      * statements will be transported as smallints to preserve backwards
1:d326b7d:      * compatibility. See DERBY-4965.
1:d326b7d:      */
1:d326b7d:     private boolean supportsBooleanParameterTransport_;
1:d326b7d: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:33776ff: 
1:69e3d06:     protected ClientDatabaseMetaData(Agent agent,
1:69e3d06:                                      ClientConnection connection,
1:69e3d06:                                      ProductLevel productLevel) {
1:70f7692:         agent_ = agent;
1:70f7692:         connection_ = connection;
1:70f7692:         productLevel_ = productLevel;
1:70f7692:         computeFeatureSet_();
1:70f7692:         if (connection.isXAConnection()) {
1:70f7692:             connection.xaHostVersion_ = productLevel_.versionLevel_;
1:70f7692:         }
1:178ae9d:         if (productLevel_.lessThan(10, 2, 0)) {
1:178ae9d:             serverJdbcMajorVersion = 3;
1:178ae9d:             serverJdbcMinorVersion = 0;
1:178ae9d:         } else {
1:b6cdb88:             // this value is only used to check that we have at least 4.0; 
1:b6cdb88:             // higher is irrelevant
1:178ae9d:             serverJdbcMajorVersion = 4;
1:178ae9d:             serverJdbcMinorVersion = 0;
1:178ae9d:         }
230:33776ff:     }
1:9d92267: 
1:70f7692:     // ---------------------------jdbc 1------------------------------------------
1:33776ff: 
1:70f7692:     //----------------------------------------------------------------------
1:70f7692:     // First, a variety of minor information about the target database.
1:33776ff: 
1:70f7692:     private final static int allProceduresAreCallable__ = 0;
1:33776ff: 
1:d506170:     public boolean allProceduresAreCallable() throws SQLException {
25:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(allProceduresAreCallable__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int allTablesAreSelectable__ = 1;
1:33776ff: 
1:d506170:     public boolean allTablesAreSelectable() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(allTablesAreSelectable__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int nullsAreSortedHigh__ = 2;
1:33776ff: 
1:d506170:     public boolean nullsAreSortedHigh() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(nullsAreSortedHigh__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int nullsAreSortedLow__ = 3;
1:33776ff: 
1:d506170:     public boolean nullsAreSortedLow() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(nullsAreSortedLow__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int nullsAreSortedAtStart__ = 4;
1:33776ff: 
1:d506170:     public boolean nullsAreSortedAtStart() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(nullsAreSortedAtStart__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int nullsAreSortedAtEnd__ = 5;
1:33776ff: 
1:d506170:     public boolean nullsAreSortedAtEnd() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(nullsAreSortedAtEnd__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int usesLocalFiles__ = 6;
1:33776ff: 
1:d506170:     public boolean usesLocalFiles() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(usesLocalFiles__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int usesLocalFilePerTable__ = 7;
1:33776ff: 
1:d506170:     public boolean usesLocalFilePerTable() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(usesLocalFilePerTable__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int storesUpperCaseIdentifiers__ = 8;
1:33776ff: 
1:d506170:     public boolean storesUpperCaseIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesUpperCaseIdentifiers__);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     private final static int storesLowerCaseIdentifiers__ = 9;
1:33776ff: 
1:d506170:     public boolean storesLowerCaseIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesLowerCaseIdentifiers__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int storesMixedCaseIdentifiers__ = 10;
1:33776ff: 
1:d506170:     public boolean storesMixedCaseIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesMixedCaseIdentifiers__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int storesUpperCaseQuotedIdentifiers__ = 11;
1:33776ff: 
1:d506170:     public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesUpperCaseQuotedIdentifiers__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int storesLowerCaseQuotedIdentifiers__ = 12;
1:33776ff: 
1:d506170:     public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesLowerCaseQuotedIdentifiers__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int storesMixedCaseQuotedIdentifiers__ = 13;
1:70f7692: 
1:d506170:     public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(storesMixedCaseQuotedIdentifiers__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getSQLKeywords__ = 14;
1:70f7692: 
1:d506170:     public String getSQLKeywords() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getSQLKeywords__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getNumericFunctions__ = 15;
1:70f7692: 
1:d506170:     public String getNumericFunctions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getNumericFunctions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getStringFunctions__ = 16;
1:70f7692: 
1:d506170:     public String getStringFunctions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getStringFunctions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getSystemFunctions__ = 17;
1:70f7692: 
1:d506170:     public String getSystemFunctions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getSystemFunctions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getTimeDateFunctions__ = 18;
1:70f7692: 
1:d506170:     public String getTimeDateFunctions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getTimeDateFunctions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getSearchStringEscape__ = 19;
1:70f7692: 
1:d506170:     public String getSearchStringEscape() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getSearchStringEscape__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getExtraNameCharacters__ = 20;
1:70f7692: 
1:d506170:     public String getExtraNameCharacters() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getExtraNameCharacters__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsAlterTableWithAddColumn__ = 21;
1:70f7692: 
1:d506170:     public boolean supportsAlterTableWithAddColumn() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsAlterTableWithAddColumn__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsAlterTableWithDropColumn__ = 22;
1:70f7692: 
1:d506170:     public boolean supportsAlterTableWithDropColumn() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsAlterTableWithDropColumn__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsConvert__ = 23;
1:70f7692: 
1:d506170:     public boolean supportsConvert() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsConvert__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsConvertType__ = 24;
1:70f7692: 
1:d506170:     public boolean supportsConvert(int fromType, int toType) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean_supportsConvert(supportsConvertType__, fromType, toType);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsDifferentTableCorrelationNames__ = 25;
1:70f7692: 
1:d506170:     public boolean supportsDifferentTableCorrelationNames() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsDifferentTableCorrelationNames__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsExpressionsInOrderBy__ = 26;
1:70f7692: 
1:d506170:     public boolean supportsExpressionsInOrderBy() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsExpressionsInOrderBy__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsOrderByUnrelated__ = 27;
1:70f7692: 
1:d506170:     public boolean supportsOrderByUnrelated() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOrderByUnrelated__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsGroupBy__ = 28;
1:70f7692: 
1:d506170:     public boolean supportsGroupBy() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsGroupBy__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsGroupByUnrelated__ = 29;
1:70f7692: 
1:d506170:     public boolean supportsGroupByUnrelated() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsGroupByUnrelated__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsGroupByBeyondSelect__ = 30;
1:70f7692: 
1:d506170:     public boolean supportsGroupByBeyondSelect() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsGroupByBeyondSelect__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsMultipleResultSets__ = 31;
1:70f7692: 
1:d506170:     public boolean supportsMultipleResultSets() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsMultipleResultSets__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsMultipleTransactions__ = 32;
1:70f7692: 
1:d506170:     public boolean supportsMultipleTransactions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsMultipleTransactions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCoreSQLGrammar__ = 33;
1:70f7692: 
1:d506170:     public boolean supportsCoreSQLGrammar() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCoreSQLGrammar__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsExtendedSQLGrammar__ = 34;
1:70f7692: 
1:d506170:     public boolean supportsExtendedSQLGrammar() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsExtendedSQLGrammar__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsANSI92IntermediateSQL__ = 35;
1:70f7692: 
1:d506170:     public boolean supportsANSI92IntermediateSQL() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsANSI92IntermediateSQL__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsANSI92FullSQL__ = 36;
1:70f7692: 
1:d506170:     public boolean supportsANSI92FullSQL() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsANSI92FullSQL__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsIntegrityEnhancementFacility__ = 37;
1:70f7692: 
1:d506170:     public boolean supportsIntegrityEnhancementFacility() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsIntegrityEnhancementFacility__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsOuterJoins__ = 38;
1:70f7692: 
1:d506170:     public boolean supportsOuterJoins() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOuterJoins__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsFullOuterJoins__ = 39;
1:70f7692: 
1:d506170:     public boolean supportsFullOuterJoins() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsFullOuterJoins__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsLimitedOuterJoins__ = 40;
1:70f7692: 
1:d506170:     public boolean supportsLimitedOuterJoins() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsLimitedOuterJoins__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getSchemaTerm__ = 41;
1:70f7692: 
1:d506170:     public String getSchemaTerm() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getSchemaTerm__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getProcedureTerm__ = 42;
1:70f7692: 
1:d506170:     public String getProcedureTerm() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getProcedureTerm__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getCatalogTerm__ = 43;
1:70f7692: 
1:d506170:     public String getCatalogTerm() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getCatalogTerm__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int isCatalogAtStart__ = 44;
1:70f7692: 
1:d506170:     public boolean isCatalogAtStart() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(isCatalogAtStart__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getCatalogSeparator__ = 45;
1:70f7692: 
1:d506170:     public String getCatalogSeparator() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoString(getCatalogSeparator__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSchemasInDataManipulation__ = 46;
1:70f7692: 
1:d506170:     public boolean supportsSchemasInDataManipulation() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSchemasInDataManipulation__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSchemasInProcedureCalls__ = 47;
1:70f7692: 
1:d506170:     public boolean supportsSchemasInProcedureCalls() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSchemasInProcedureCalls__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSchemasInTableDefinitions__ = 48;
1:70f7692: 
1:d506170:     public boolean supportsSchemasInTableDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSchemasInTableDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     private final static int supportsSchemasInIndexDefinitions__ = 49;
1:70f7692: 
1:d506170:     public boolean supportsSchemasInIndexDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSchemasInIndexDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSchemasInPrivilegeDefinitions__ = 50;
1:70f7692: 
1:d506170:     public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSchemasInPrivilegeDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCatalogsInDataManipulation__ = 51;
1:70f7692: 
1:d506170:     public boolean supportsCatalogsInDataManipulation() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCatalogsInDataManipulation__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCatalogsInProcedureCalls__ = 52;
1:70f7692: 
1:d506170:     public boolean supportsCatalogsInProcedureCalls() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCatalogsInProcedureCalls__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCatalogsInTableDefinitions__ = 53;
1:70f7692: 
1:d506170:     public boolean supportsCatalogsInTableDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCatalogsInTableDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCatalogsInIndexDefinitions__ = 54;
1:70f7692: 
1:d506170:     public boolean supportsCatalogsInIndexDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCatalogsInIndexDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsCatalogsInPrivilegeDefinitions__ = 55;
1:70f7692: 
1:d506170:     public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsCatalogsInPrivilegeDefinitions__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsPositionedDelete__ = 56;
1:70f7692: 
1:d506170:     public boolean supportsPositionedDelete() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsPositionedDelete__);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     private final static int supportsPositionedUpdate__ = 57;
1:70f7692: 
1:d506170:     public boolean supportsPositionedUpdate() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsPositionedUpdate__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSelectForUpdate__ = 58;
1:70f7692: 
1:d506170:     public boolean supportsSelectForUpdate() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSelectForUpdate__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsStoredProcedures__ = 59;
1:70f7692: 
1:d506170:     public boolean supportsStoredProcedures() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsStoredProcedures__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsSubqueriesInComparisons__ = 60;
1:70f7692: 
1:d506170:     public boolean supportsSubqueriesInComparisons() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsSubqueriesInComparisons__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsUnion__ = 61;
1:70f7692: 
1:d506170:     public boolean supportsUnion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsUnion__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsUnionAll__ = 62;
1:70f7692: 
1:d506170:     public boolean supportsUnionAll() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsUnionAll__);
1:d506170: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsOpenCursorsAcrossCommit__ = 63;
1:70f7692: 
1:d506170:     public boolean supportsOpenCursorsAcrossCommit() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOpenCursorsAcrossCommit__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsOpenCursorsAcrossRollback__ = 64;
1:70f7692: 
1:d506170:     public boolean supportsOpenCursorsAcrossRollback() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOpenCursorsAcrossRollback__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int supportsOpenStatementsAcrossCommit__ = 65;
1:70f7692: 
1:d506170:     public boolean supportsOpenStatementsAcrossCommit() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOpenStatementsAcrossCommit__);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     private final static int supportsOpenStatementsAcrossRollback__ = 66;
1:70f7692: 
1:d506170:     public boolean supportsOpenStatementsAcrossRollback() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsOpenStatementsAcrossRollback__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     //----------------------------------------------------------------------
1:70f7692:     // The following group of methods exposes various limitations
1:70f7692:     // based on the target database with the current driver.
1:70f7692:     // Unless otherwise specified, a result of zero means there is no
1:70f7692:     // limit, or the limit is not known.
1:70f7692:     private final static int getMaxBinaryLiteralLength__ = 67;
1:70f7692: 
1:d506170:     public int getMaxBinaryLiteralLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxBinaryLiteralLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxCharLiteralLength__ = 68;
1:70f7692: 
1:d506170:     public int getMaxCharLiteralLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxCharLiteralLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnNameLength__ = 69;
1:70f7692: 
1:d506170:     public int getMaxColumnNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnNameLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnsInGroupBy__ = 70;
1:70f7692: 
1:d506170:     public int getMaxColumnsInGroupBy() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnsInGroupBy__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnsInIndex__ = 71;
1:70f7692: 
1:d506170:     public int getMaxColumnsInIndex() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnsInIndex__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnsInOrderBy__ = 72;
1:70f7692: 
1:d506170:     public int getMaxColumnsInOrderBy() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnsInOrderBy__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnsInSelect__ = 73;
1:70f7692: 
1:d506170:     public int getMaxColumnsInSelect() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnsInSelect__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxColumnsInTable__ = 74;
1:70f7692: 
1:d506170:     public int getMaxColumnsInTable() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxColumnsInTable__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxConnections__ = 75;
1:70f7692: 
1:d506170:     public int getMaxConnections() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxConnections__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxCursorNameLength__ = 76;
1:70f7692: 
1:d506170:     public int getMaxCursorNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxCursorNameLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxIndexLength__ = 77;
1:70f7692: 
1:d506170:     public int getMaxIndexLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxIndexLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxSchemaNameLength__ = 78;
1:70f7692: 
1:d506170:     public int getMaxSchemaNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxSchemaNameLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxProcedureNameLength__ = 79;
1:70f7692: 
1:d506170:     public int getMaxProcedureNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxProcedureNameLength__);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private final static int getMaxCatalogNameLength__ = 80;
1:70f7692: 
1:d506170:     public int getMaxCatalogNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxCatalogNameLength__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxRowSize__ = 81;
1:33776ff: 
1:d506170:     public int getMaxRowSize() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxRowSize__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int doesMaxRowSizeIncludeBlobs__ = 82;
1:33776ff: 
1:d506170:     public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(doesMaxRowSizeIncludeBlobs__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxStatementLength__ = 83;
1:33776ff: 
1:d506170:     public int getMaxStatementLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxStatementLength__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxStatements__ = 84;
1:33776ff: 
1:d506170:     public int getMaxStatements() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxStatements__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxTableNameLength__ = 85;
1:33776ff: 
1:d506170:     public int getMaxTableNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxTableNameLength__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxTablesInSelect__ = 86;
1:33776ff: 
1:d506170:     public int getMaxTablesInSelect() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxTablesInSelect__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getMaxUserNameLength__ = 87;
1:33776ff: 
1:d506170:     public int getMaxUserNameLength() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getMaxUserNameLength__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int getDefaultTransactionIsolation__ = 88;
1:33776ff: 
1:d506170:     public int getDefaultTransactionIsolation() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt(getDefaultTransactionIsolation__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int supportsTransactions__ = 89;
1:33776ff: 
1:d506170:     public boolean supportsTransactions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsTransactions__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all supported levels
1:70f7692:     private final static int supportsTransactionIsolationLevel__ = 90;
1:33776ff: 
1:d506170:     public boolean supportsTransactionIsolationLevel(int level) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(supportsTransactionIsolationLevel__, level);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     private final static int supportsDataDefinitionAndDataManipulationTransactions__ = 91;
1:33776ff: 
1:d506170:     public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsDataDefinitionAndDataManipulationTransactions__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int supportsDataManipulationTransactionsOnly__ = 92;
1:33776ff: 
1:d506170:     public boolean supportsDataManipulationTransactionsOnly() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsDataManipulationTransactionsOnly__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int dataDefinitionCausesTransactionCommit__ = 93;
1:33776ff: 
1:d506170:     public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(dataDefinitionCausesTransactionCommit__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int dataDefinitionIgnoredInTransactions__ = 94;
1:33776ff: 
1:d506170:     public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(dataDefinitionIgnoredInTransactions__);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported resultSet types
1:70f7692:     private final static int supportsResultSetType__ = 95;
1:33776ff: 
1:d506170:     public boolean supportsResultSetType(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(supportsResultSetType__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int supportsResultSetConcurrency__ = 96;
1:33776ff: 
1:d506170:     public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoInt_SupportsResultSetConcurrency(supportsResultSetConcurrency__, type, concurrency);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int ownUpdatesAreVisible__ = 97;
1:33776ff: 
1:d506170:     public boolean ownUpdatesAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(ownUpdatesAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int ownDeletesAreVisible__ = 98;
1:33776ff: 
1:d506170:     public boolean ownDeletesAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(ownDeletesAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list all the supported result Set types
1:70f7692:     private final static int ownInsertsAreVisible__ = 99;
1:33776ff: 
1:d506170:     public boolean ownInsertsAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(ownInsertsAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int othersUpdatesAreVisible__ = 100;
1:33776ff: 
1:d506170:     public boolean othersUpdatesAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(othersUpdatesAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int othersDeletesAreVisible__ = 101;
1:33776ff: 
1:d506170:     public boolean othersDeletesAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(othersDeletesAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int othersInsertsAreVisible__ = 102;
1:33776ff: 
1:d506170:     public boolean othersInsertsAreVisible(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(othersInsertsAreVisible__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int updatesAreDetected__ = 103;
1:33776ff: 
1:d506170:     public boolean updatesAreDetected(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(updatesAreDetected__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int deletesAreDetected__ = 104;
1:33776ff: 
1:d506170:     public boolean deletesAreDetected(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(deletesAreDetected__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Stored Procedure will return a String containing a
1:70f7692:     // comma seperated list of all the supported result Set types
1:70f7692:     private final static int insertsAreDetected__ = 105;
1:33776ff: 
1:d506170:     public boolean insertsAreDetected(int type) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBooleanWithType(insertsAreDetected__, type);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private final static int supportsBatchUpdates__ = 106;
1:33776ff: 
1:d506170:     public boolean supportsBatchUpdates() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return getMetaDataInfoBoolean(supportsBatchUpdates__);
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsSavepoints() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         if (productLevel_.greaterThanOrEqualTo(5, 2, 0)) {
2:70f7692:             return true;
1:70f7692:         }
1:33776ff: 
6:70f7692:         return false;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // start tagging all abstract methods with an underscore like this !!
1:70f7692:     abstract public String getURL_() throws SqlException;
1:33776ff: 
1:d506170:     public String getURL() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedConnection();
1:d506170:             return getURL_();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getUserName() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return connection_.user_;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean isReadOnly() throws SQLException {
1:70f7692:         return false;
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getDatabaseProductName() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return productLevel_.databaseProductName_;
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getDatabaseProductVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return productLevel_.databaseProductVersion_;
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getDriverName() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return Configuration.dncDriverName;
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getDriverVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return Version.getDriverVersion();
1:70f7692:     }
1:33776ff: 
1:70f7692:     // JDBC signature also does not throw SqlException, so we don't check for closed connection.
1:70f7692:     public int getDriverMajorVersion() {
1:70f7692:         return Version.getMajorVersion();
1:70f7692:     }
1:33776ff: 
1:70f7692:     // JDBC signature also does not throw SqlException, so we don't check for closed connection.
1:70f7692:     public int getDriverMinorVersion() {
1:70f7692:         return Version.getMinorVersion();
1:70f7692:     }
1:33776ff: 
1:70f7692:     //All JDBC Drivers must return false for this method. For this reason we choose
1:70f7692:     //to return FALSE
1:d506170:     public boolean supportsMixedCaseIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return false;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getIdentifierQuoteString() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return "\"";
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsColumnAliasing() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean nullPlusNonNullIsNull() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsTableCorrelationNames() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsLikeEscapeClause() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsNonNullableColumns() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsMinimumSQLGrammar() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsANSI92EntryLevelSQL() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsSubqueriesInExists() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsSubqueriesInIns() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsSubqueriesInQuantifieds() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsCorrelatedSubqueries() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     //------------------------catalog query methods follow--------------------------------------------
1:33776ff: 
1:70f7692:     // call stored procedure SQLProcedures
1:70f7692:     // SYSIBM.SQLProcedures(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              ProcName    varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:6eb29f6:     //
1:69e3d06:     public ResultSet getProcedures(String catalog,
1:70f7692:                                             String schemaPattern,
1:d506170:                                             String procedureNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getProcedures", catalog, schemaPattern, procedureNamePattern);
1:d506170:                 }
1:d506170:                 return getProceduresX(catalog, schemaPattern, procedureNamePattern);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:69e3d06:     private ClientResultSet getProceduresX(String catalog,
1:70f7692:                                      String schemaPattern,
2:70f7692:                                      String procedureNamePattern) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs =
1:69e3d06:             prepareMetaDataQuery("SYSIBM.SQLPROCEDURES(?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schemaPattern);
1:70f7692:         cs.setStringX(3, procedureNamePattern);
1:70f7692:         cs.setStringX(4, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // call stored procedure SQLProcedureCols
1:70f7692:     // SYSIBM.SQLProcedureCols(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              ProcName    varchar(128),
1:70f7692:     //              ParamName   varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:6eb29f6:     //
1:69e3d06:     public ResultSet getProcedureColumns(String catalog,
1:70f7692:                                                   String schemaPattern,
1:70f7692:                                                   String procedureNamePattern,
1:d506170:                                                   String columnNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getProcedureColumns", catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:d506170:                 }
1:d506170:                 return getProcedureColumnsX(catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:d506170:         
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getProcedureColumnsX(String catalog,
13:33776ff:                                            String schemaPattern,
1:70f7692:                                            String procedureNamePattern,
4:70f7692:                                            String columnNamePattern) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs =
1:69e3d06:             prepareMetaDataQuery("SYSIBM.SQLPROCEDURECOLS(?,?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schemaPattern);
1:70f7692:         cs.setStringX(3, procedureNamePattern);
1:70f7692:         cs.setStringX(4, columnNamePattern);
1:70f7692:         cs.setStringX(5, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:33776ff:     }
1:33776ff: 
1:e423333:     /** 
1:e423333:      * Get the function names available in the database.  Calls stored
1:0223b95:      * procedure <code>SYSIBM.SQLFunctions(CatalogName
1:0223b95:      * varchar(128), SchemaName varchar(128), FuncName varchar(128),
1:0223b95:      * Options varchar(4000))</code> on the server. This procedure
1:0223b95:      * will in turn call
1:0223b95:      * <code>EmbedDatabaseMetaData.getFunctions(String,String,String)</code><p>
1:0223b95:      * Compatibility: Only available if both server and client version
1:dbed020:      * &lt; 10.1, and JDK version &gt;= 1.6. Older clients will not have
1:0223b95:      * this method available. Newer clients will be able to call this
1:0223b95:      * method when connected to an older server, but this will be
1:0223b95:      * trigger an exception in
1:0223b95:      * <code>checkServerJdbcVersionX()</code>. <p>Upgrade:
1:0223b95:      * <code>SYSIBM.SQLFunctions</code> is added in
1:0223b95:      * <code>DataDictionaryImpl.create_10_2_system_procedures
1:0223b95:      * (TransactionController,UUID)</code> so it will become available
1:0223b95:      * in newly created databases and after <b>hard</b> upgrade.
1:0223b95:      *
1:0223b95:      * @param catalog limit search to this catalog
1:0223b95:      * @param schemaPattern limit search to schemas matching this pattern
1:0223b95:      * @param functionNamePattern limit search to functions matching this 
1:0223b95:      * pattern
1:0223b95:      * @return a <code>ResultSet</code> listing the fucntions
1:f668d94:      * @exception SQLException if a database error occurs
1:0223b95:      * @see #getFunctionsX(String, String, String)
1:7b301ec:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,java.util.HashSet,UUID)
1:0223b95:      * @see org.apache.derby.impl.jdbc.EmbedDatabaseMetaData#getFunctions(String,String,String)
1:0223b95:      */
1:0223b95: 
1:69e3d06:     public ResultSet getFunctions(String catalog,
1:0223b95:                                            String schemaPattern,
1:0223b95:                                            String functionNamePattern) 
1:0223b95:         throws SQLException {
1:0223b95:         try {
1:0223b95:             synchronized (connection_) {
1:0223b95:                 if (agent_.loggingEnabled()) {
1:0223b95:                     agent_.logWriter_.traceEntry(this, "getFunctions", 
1:0223b95:                                                  catalog, schemaPattern, 
1:0223b95:                                                  functionNamePattern);
1:0223b95:                 }
1:0223b95:                 return getFunctionsX(catalog, schemaPattern, 
1:0223b95:                                      functionNamePattern);
1:0223b95:             }
1:0223b95:         }
1:0223b95:         catch (SqlException se) {
1:0223b95:             throw se.getSQLException();
1:0223b95:         }
1:0223b95:     }
1:0223b95: 
1:d326b7d:     /** 
1:0223b95:      * Untraced version of <code>getFunctions(String, String, String)</code>.
1:0223b95:      * @param catalog limit search to this catalog
1:0223b95:      * @param schemaPattern limit search to schemas matching this pattern
1:0223b95:      * @param functionNamePattern limit search to functions matching this 
1:0223b95:      * pattern
1:0223b95:      * @return a <code>ResultSet</code> listing the fucntions
1:e423333:      * @exception SqlException if a database error occurs
1:0223b95:      * @see #getFunctions(String, String, String)
1:0223b95:      */
1:69e3d06:     private ClientResultSet getFunctionsX(String catalog,
1:0223b95:                                     String schemaPattern,
1:0223b95:                                     String functionNamePattern) 
1:0223b95:         throws SqlException {
1:0223b95:         checkForClosedConnectionX();
1:0223b95:         checkServerJdbcVersionX("getFunctions(String,String,String)", 4, 0); 
1:0223b95: 
1:69e3d06:         ClientPreparedStatement cs =
1:0223b95:             prepareMetaDataQuery("SYSIBM.SQLFUNCTIONS(?,?,?,?)");
1:0223b95: 
1:0223b95:         cs.setStringX(1, catalog);
1:0223b95:         cs.setStringX(2, schemaPattern);
1:0223b95:         cs.setStringX(3, functionNamePattern);
1:0223b95:         cs.setStringX(4, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:0223b95:     }
1:0223b95: 
1:533d502:     /** 
1:0223b95:      * Get the function names available in the database.  Calls stored
1:e423333:      * procedure <code>SYSIBM.SQLFunctionParams(CatalogName
1:e423333:      * varchar(128), SchemaName varchar(128), FuncName varchar(128),
1:e423333:      * ParamName varchar(128), Options varchar(4000))</code> on the
1:e423333:      * server. This procedure will in turn call
1:ebdced0:      * <code>EmbedDatabaseMetaData.getFunctionColumns(String,String,
1:e423333:      * String,String)</code><p> Compatibility: Only available if both
1:dbed020:      * server and client version &gt; 10.1, and JDK version &gt;= 1.6. Older
1:e423333:      * clients will not have this method available. Newer clients will
1:e423333:      * be able to call this method when connected to an older server,
1:e423333:      * but this will be trigger an exception in
1:e423333:      * <code>checkServerJdbcVersionX()</code>. <p>Upgrade:
1:e423333:      * <code>SYSIBM.SQLFunctionParams</code> is added in
1:e423333:      * <code>DataDictionaryImpl.create_10_2_system_procedures
1:e423333:      * (TransactionController,UUID)</code> so it will become available
1:e423333:      * in newly created databases and after <b>hard</b> upgrade.
1:e423333:      *
1:e423333:      * @param catalog limit search to this catalog
1:e423333:      * @param schemaPattern limit search to schemas matching this pattern
1:e423333:      * @param functionNamePattern limit search to functions matching this 
1:e423333:      * pattern
1:e423333:      * @return a <code>ResultSet</code> listing the fucntions
1:f668d94:      * @exception SQLException if a database error occurs
1:ebdced0:      * @see #getFunctionColumnsX(String, String, String,String)
1:7b301ec:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,java.util.HashSet,UUID)
1:e423333:      * @see org.apache.derby.impl.jdbc.EmbedDatabaseMetaData#getFunctions(String,String,String)
1:e423333:      */
1:69e3d06:     public ResultSet
1:ebdced0:         getFunctionColumns(String catalog,
1:e423333:                               String schemaPattern,
1:e423333:                               String functionNamePattern,
1:e423333:                               String parameterNamePattern) 
1:e423333:         throws SQLException {
1:e423333:         try
1:e423333:         {
1:e423333:             synchronized (connection_) {
1:e423333:                 if (agent_.loggingEnabled()) {
1:e423333:                     agent_.logWriter_.
1:e423333:                         traceEntry(this, 
1:ebdced0:                                    "getFunctionColumns", 
1:e423333:                                    catalog, schemaPattern, 
1:e423333:                                    functionNamePattern, parameterNamePattern);
1:e423333:                 }
1:ebdced0:                 return getFunctionColumnsX(catalog, schemaPattern, 
1:e423333:                                               functionNamePattern, 
1:e423333:                                               parameterNamePattern);
1:e423333:             }
1:e423333:         }
1:e423333:         catch ( SqlException se )
1:e423333:         {
1:e423333:             throw se.getSQLException();
1:e423333:         }
1:e423333:     }
1:e423333: 
1:e423333:     /** 
1:ebdced0:      * Untraced version of <code>getFunctionColumns(String, String,
1:e423333:      * String, String)</code>.
1:e423333:      * @param catalog limit search to this catalog
1:e423333:      * @param schemaPattern limit search to schemas matching this pattern
1:e423333:      * @param functionNamePattern limit search to functions matching this 
1:e423333:      * pattern
1:e423333:      * @param parameterNamePattern limit search to parameters mathing
1:e423333:      * this pattern
1:e423333:      * @return a <code>ResultSet</code> listing the fucntions
1:406bef9:      * @exception SqlException if a database error occurs
1:ebdced0:      * @see #getFunctionColumns(String, String, String, String)
1:e423333:      */
1:69e3d06:     private ClientResultSet getFunctionColumnsX(String catalog,
1:e423333:                                              String schemaPattern,
1:e423333:                                              String functionNamePattern,
1:e423333:                                              String parameterNamePattern) 
1:e423333:         throws SqlException {
1:e423333:         checkForClosedConnectionX();
1:ebdced0:         checkServerJdbcVersionX("getFunctionColumns"+
1:e423333:                                 "(String,String,String,String)", 4, 0);
1:e423333:  
1:69e3d06:         ClientPreparedStatement cs =
1:e423333:             prepareMetaDataQuery("SYSIBM.SQLFUNCTIONPARAMS(?,?,?,?,?)");
1:e423333: 
1:e423333:         cs.setStringX(1, catalog);
1:e423333:         cs.setStringX(2, schemaPattern);
1:e423333:         cs.setStringX(3, functionNamePattern);
1:e423333:         cs.setStringX(4, parameterNamePattern);
1:e423333:         cs.setStringX(5, getOptions());
1:e423333:         return executeCatalogQuery(cs);
1:e423333:     }
1:0223b95: 
1:70f7692:     // call stored procedure SQLTables
1:70f7692:     // SYSIBM.SQLTables(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              TaleType    varchar(4000),
1:70f7692:     //              Options     varchar(4000))
2:70f7692:     //
1:69e3d06:     public ResultSet getTables(String catalog,
1:33776ff:                                         String schemaPattern,
4:33776ff:                                         String tableNamePattern,
1:d506170:                                         String types[]) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getTables", catalog, schemaPattern, tableNamePattern, types);
1:d506170:                 }
1:d506170:                 return getTablesX(catalog, schemaPattern, tableNamePattern, types);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getTablesX(String catalog,
1:70f7692:                                  String schemaPattern,
1:70f7692:                                  String tableNamePattern,
2:70f7692:                                  String types[]) throws SqlException {
1:d506170:         try {
1:f658f85:             checkForClosedConnection();
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:d506170:         }
1:33776ff: 
1:69e3d06:         ClientPreparedStatement cs =
1:69e3d06:             prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1:33776ff: 
1:70f7692:         if (catalog == null) {
1:69e3d06:             cs.setNullX(1, Types.VARCHAR);
4:70f7692:         } else {
1:70f7692:             cs.setStringX(1, catalog);
1:70f7692:         }
1:33776ff: 
1:70f7692:         if (schemaPattern == null) {
1:69e3d06:             cs.setNullX(2, Types.VARCHAR);
1:70f7692:         } else {
1:70f7692:             cs.setStringX(2, schemaPattern);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (tableNamePattern == null) {
1:69e3d06:             cs.setNullX(3, Types.VARCHAR);
1:70f7692:         } else {
1:70f7692:             cs.setStringX(3, tableNamePattern);
1:70f7692:         }
1:70f7692: 
1:4a4b0a8:         String tableTypes = "";
1:70f7692:         int i = 0;
1:70f7692:         if (types == null) {
1:69e3d06:             cs.setNullX(4, Types.VARCHAR);
1:70f7692:         } else if (types.length == 1 && (types[0].trim()).equals("%")) {
1:70f7692:             cs.setStringX(4, types[0]);
1:70f7692:         } else {
1:70f7692:             while (i < types.length) {
1:70f7692:                 if (i > 0) {
1:70f7692:                     tableTypes = tableTypes.concat(",");
1:70f7692:                 }
1:70f7692:                 tableTypes = tableTypes.concat("'" + types[i] + "'");
1:70f7692:                 i++;
1:70f7692:             }
1:70f7692:             cs.setStringX(4, tableTypes);
1:70f7692:         }
1:70f7692:         cs.setStringX(5, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // call stored procedure SQLTables
1:70f7692:     // SYSIBM.SQLTables(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              TaleType    varchar(4000),
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getSchemas() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getSchemas");
1:d506170:                 }
1:d506170:                 return getSchemasX();
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:d506170: 
1:69e3d06:     private ClientResultSet getSchemasX() throws SqlException {
1:d506170:         try {
1:d506170:             checkForClosedConnection();
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:70f7692:         }
1:70f7692:         
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLTABLES('', '', '', '', 'GETSCHEMAS=1')");
1:69e3d06:         return (ClientResultSet) cs.executeQueryX();
1:33776ff:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // DERBY does not have the notion of a catalog, so we return a result set with no rows.
1:69e3d06:     public ResultSet getCatalogs() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getCatalogs");
1:d506170:                 }
1:d506170:                 return getCatalogsX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getCatalogsX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLTABLES('', '', '', '', 'GETCATALOGS=1')");
1:69e3d06:         return (ClientResultSet) cs.executeQueryX();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // call stored procedure SQLTables
1:70f7692:     // SYSIBM.SQLTables(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              TableType   varchar(4000),
1:70f7692:     //              Options     varchar(4000))
1:69e3d06:     public ResultSet getTableTypes() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getTableTypes");
1:d506170:                 }
1:d506170:                 return getTableTypesX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getTableTypesX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs = null;
1:70f7692:         cs = prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, "");
1:70f7692:         cs.setStringX(2, "");
1:70f7692:         cs.setStringX(3, "");
1:70f7692:         cs.setStringX(4, "%");
1:70f7692:         int cursorHold;
1:1e8a20f:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             cursorHold = 1;
1:70f7692:         } else {
1:70f7692:             cursorHold = 0;
1:70f7692:         }
1:70f7692:         cs.setStringX(5, "DATATYPE='JDBC';GETTABLETYPES=1; CURSORHOLD=" + cursorHold);
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // call stored procedure SQLColumns
1:70f7692:     // SYSIBM.SQLColumns(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              ColumnName  varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getColumns(String catalog,
1:33776ff:                                          String schemaPattern,
1:70f7692:                                          String tableNamePattern,
1:d506170:                                          String columnNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:d506170:                 }
1:d506170:                 checkForClosedConnection();
1:d506170:                 return getColumnsX(catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getColumnsX(String catalog,
1:70f7692:                                   String schemaPattern,
1:70f7692:                                   String tableNamePattern,
1:70f7692:                                   String columnNamePattern) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLCOLUMNS(?,?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schemaPattern);
1:70f7692:         cs.setStringX(3, tableNamePattern);
1:70f7692:         cs.setStringX(4, columnNamePattern); //Always null  for JDBC
1:70f7692:         cs.setStringX(5, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     // call stored procedure SQLColumnPrivileges
1:70f7692:     // SYSIBM.SQLColPrivileges(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              ColumnName  varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getColumnPrivileges(String catalog,
10:33776ff:                                                   String schema,
5:33776ff:                                                   String table,
1:d506170:                                                   String columnNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getColumnPrivileges", catalog, schema, table, columnNamePattern);
1:d506170:                 }
1:d506170:                 return getColumnPrivilegesX(catalog, schema, table, columnNamePattern);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getColumnPrivilegesX(String catalog,
1:33776ff:                                            String schema,
1:33776ff:                                            String table,
1:70f7692:                                            String columnNamePattern) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692:         // check input params, table and columnNamePattern cannot be null
1:70f7692:         if (table == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:486829c: 
1:70f7692:         }
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLCOLPRIVILEGES(?,?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schema);
1:70f7692:         cs.setStringX(3, table);
1:70f7692:         cs.setStringX(4, columnNamePattern);
1:70f7692:         cs.setStringX(5, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // call stored procedure SQLTablePrivileges
1:70f7692:     // SYSIBM.SQLTablePrivileges(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getTablePrivileges(String catalog,
1:70f7692:                                                  String schemaPattern,
1:d506170:                                                  String tableNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getTablePrivileges", catalog, schemaPattern, tableNamePattern);
1:d506170:                 }
1:d506170:                 return getTablePrivilegesX(catalog, schemaPattern, tableNamePattern);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getTablePrivilegesX(String catalog,
1:70f7692:                                           String schemaPattern,
3:70f7692:                                           String tableNamePattern) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLTABLEPRIVILEGES(?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schemaPattern);
1:70f7692:         cs.setStringX(3, tableNamePattern);
1:70f7692:         cs.setStringX(4, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:33776ff:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     // call stored procedure
1:70f7692:     // SYSIBM.SQLSPECIALCOLUMNS ( IN COLTYPE SMALLINT,
1:70f7692:     //                            IN CATALOG_NAME VARCHAR(128),
1:70f7692:     //                            IN SCHEMA_NAME  VARCHAR(128),
1:70f7692:     //                            IN TABLE_NAME   VARCHAR(128),
1:70f7692:     //                            IN SCOPE        SMALLINT,
1:70f7692:     //                            IN NULLABLE     SMALLINT,
1:70f7692:     //                            IN OPTIONS      VARCHAR(4000) )
1:70f7692:     //
1:69e3d06:     public ResultSet getBestRowIdentifier(String catalog,
1:70f7692:                                                    String schema,
1:70f7692:                                                    String table,
1:70f7692:                                                    int scope,
1:d506170:                                                    boolean nullable) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBestRowIdentifier", catalog, schema, table, scope, nullable);
1:d506170:                 }
1:d506170:                 return getBestRowIdentifierX(catalog, schema, table, scope, nullable);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getBestRowIdentifierX(String catalog,
1:33776ff:                                             String schema,
1:70f7692:                                             String table,
1:70f7692:                                             int scope,
2:70f7692:                                             boolean nullable) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:70f7692:         // check input params
1:70f7692:         //
1:70f7692:         // validate input table, which can not be null
1:70f7692:         if (table == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:486829c: 
1:70f7692:         }
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1:486829c: 
1:70f7692:         cs.setIntX(1, SQL_BEST_ROWID);
1:70f7692:         cs.setStringX(2, catalog);
1:70f7692:         cs.setStringX(3, schema);
1:70f7692:         cs.setStringX(4, table);
1:70f7692:         cs.setIntX(5, scope);
1:70f7692:         if (nullable) {
1:70f7692:             cs.setShortX(6, (short) 1);
1:70f7692:         } else {
1:70f7692:             cs.setShortX(6, (short) 0);
1:70f7692:         }
1:70f7692:         cs.setStringX(7, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:69e3d06:     public ResultSet getVersionColumns(String catalog,
1:70f7692:                                                 String schema,
1:d506170:                                                 String table) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getVersionColumns", catalog, schema, table);
1:d506170:                 }
1:d506170:                 return getVersionColumnsX(catalog, schema, table);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getVersionColumnsX(String catalog,
1:70f7692:                                          String schema,
5:70f7692:                                          String table) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:70f7692:         // validate input table, which can not be null
1:70f7692:         if (table == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:33776ff: 
1:70f7692:         }
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setIntX(1, SQL_ROWVER);
1:70f7692:         cs.setStringX(2, catalog);
1:70f7692:         cs.setStringX(3, schema);
1:70f7692:         cs.setStringX(4, table);
1:70f7692:         cs.setIntX(5, 0);
1:70f7692:         cs.setShortX(6, (short) 0);
1:70f7692:         cs.setStringX(7, getOptions());
1:70f7692: 
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // call stored procedure SQLPrimaryKeys
1:70f7692:     // SYSIBM.SQLPrimaryKeys(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getPrimaryKeys(String catalog,
1:33776ff:                                              String schema,
1:d506170:                                              String table) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getPrimaryKeys", catalog, schema, table);
1:d506170:                 }
1:d506170:                 return getPrimaryKeysX(catalog, schema, table);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getPrimaryKeysX(String catalog,
1:33776ff:                                       String schema,
1:70f7692:                                       String table) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:70f7692:         // validate the input table name
1:70f7692:         if (table == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:486829c: 
1:70f7692:         }
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLPRIMARYKEYS(?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schema);
1:70f7692:         cs.setStringX(3, table);
1:70f7692:         cs.setStringX(4, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:33776ff:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     // call storlastGetPrimaryKeysResultSet_ed procedure SQLForeignKeys
1:70f7692:     // SYSIBM.SQLForeignKeys(
1:70f7692:     //              PKCatalogName varchar(128),
1:70f7692:     //              PKSchemaName  varchar(128),
1:70f7692:     //              PKTableName   varchar(128),
1:70f7692:     //              FKCatalogName varchar(128),
1:70f7692:     //              FKSchemaName  varchar(128),
1:70f7692:     //              FKTableName   varchar(128),
1:70f7692:     //              Options       varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getImportedKeys(String catalog,
1:70f7692:                                               String schema,
1:d506170:                                               String table) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getImportedKeys", catalog, schema, table);
1:d506170:                 }
1:d506170:                 return getImportedKeysX(catalog, schema, table);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     private ClientResultSet getImportedKeysX(String catalog,
1:70f7692:                                        String schema,
1:70f7692:                                        String table) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:920fea5:         // validate the table name       
1:920fea5:         if (table == null) {
1:920fea5:             throw new SqlException(agent_.logWriter_,
1:920fea5:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:920fea5:         }
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setStringX(1, "");
1:70f7692:         cs.setStringX(2, null);
1:70f7692:         cs.setStringX(3, "");
1:70f7692:         cs.setStringX(4, catalog);
1:70f7692:         cs.setStringX(5, schema);
1:70f7692:         cs.setStringX(6, table);
1:70f7692:         // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
1:70f7692:         // As a workaround in getCrossReference(), we'll just "select * where 0=1" when primaryTable==""
1:1e8a20f:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             cs.setStringX(7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=1");
1:70f7692:         } else {
1:70f7692:             cs.setStringX(7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=0");
1:920fea5:         }
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // call stored procedure SQLForeignKeys
1:70f7692:     // SYSIBM.SQLForeignKeys(
1:70f7692:     //              PKCatalogName varchar(128),
1:70f7692:     //              PKSchemaName  varchar(128),
1:70f7692:     //              PKTableName   varchar(128),
1:70f7692:     //              FKCatalogName varchar(128),
1:70f7692:     //              FKSchemaName  varchar(128),
1:70f7692:     //              FKTableName   varchar(128),
1:70f7692:     //              Options       varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getExportedKeys(String catalog,
1:70f7692:                                               String schema,
1:d506170:                                               String table) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getExportedKeys", catalog, schema, table);
1:d506170:                 }
1:d506170:                 return getExportedKeysX(catalog, schema, table);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getExportedKeysX(String catalog,
1:70f7692:                                        String schema,
1:70f7692:                                        String table) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:920fea5:         // validate the table name
1:920fea5:         if (table == null) {
1:920fea5:             throw new SqlException(agent_.logWriter_,
1:920fea5:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:33776ff:         }        
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1:33776ff: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schema);
1:70f7692:         cs.setStringX(3, table);
1:70f7692:         cs.setStringX(4, "");
1:70f7692:         cs.setStringX(5, null);
1:70f7692:         cs.setStringX(6, "");
1:70f7692:         // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
1:70f7692:         // As a workaround in getCrossReference(), we'll just "select * where 0=1" when foreignTable==""
1:1e8a20f:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             cs.setStringX(7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=1");
1:70f7692:         } else {
1:70f7692:             cs.setStringX(7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=0");
1:70f7692:         }
1:765e2c4:         return executeCatalogQuery(cs);
1:33776ff:     }
1:33776ff: 
1:70f7692:     // call stored procedure SQLForeignKeys
1:70f7692:     // SYSIBM.SQLForeignKeys(
1:70f7692:     //              PKCatalogName varchar(128),
1:70f7692:     //              PKSchemaName  varchar(128),
1:70f7692:     //              PKTableName   varchar(128),
1:70f7692:     //              FKCatalogName varchar(128),
1:70f7692:     //              FKSchemaName  varchar(128),
1:70f7692:     //              FKTableName   varchar(128),
1:70f7692:     //              Options       varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getCrossReference(String primaryCatalog,
1:70f7692:                                                 String primarySchema,
1:70f7692:                                                 String primaryTable,
1:70f7692:                                                 String foreignCatalog,
1:70f7692:                                                 String foreignSchema,
1:d506170:                                                 String foreignTable) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getCrossReference", primaryCatalog, primarySchema, primaryTable, foreignCatalog, foreignSchema, foreignTable);
1:d506170:                 }
1:d506170:                 return getCrossReferenceX(primaryCatalog, primarySchema, primaryTable,
1:d506170:                         foreignCatalog, foreignSchema, foreignTable);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:33776ff: 
1:69e3d06:     private ClientResultSet getCrossReferenceX(String primaryCatalog,
1:70f7692:                                          String primarySchema,
1:70f7692:                                          String primaryTable,
1:70f7692:                                          String foreignCatalog,
1:70f7692:                                          String foreignSchema,
2:70f7692:                                          String foreignTable) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:70f7692:         // check input params, primaryTable and foreignTable cannot be null
1:70f7692:         if (primaryTable == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.PRIMARY_TABLE_NAME_IS_NULL)); 
1:486829c: 
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (foreignTable == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.FOREIGN_TABLE_NAME_IS_NULL)); 
1:486829c: 
1:70f7692:         }
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, primaryCatalog);
1:70f7692:         cs.setStringX(2, primarySchema);
1:70f7692:         cs.setStringX(3, primaryTable);
1:70f7692:         cs.setStringX(4, foreignCatalog);
1:70f7692:         cs.setStringX(5, foreignSchema);
1:70f7692:         cs.setStringX(6, foreignTable);
1:70f7692:         cs.setStringX(7, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:33776ff:     }
1:33776ff: 
1:70f7692:     // call stored procedure SQLGetTypeInfo
1:70f7692:     // SYSIBM.SQLGetTypeInfo (IN DATATYPE SMALLINT,
1:70f7692:     //                        IN Options VARCHAR(4000))
1:70f7692:     //
1:70f7692:     //
1:69e3d06:     public ResultSet getTypeInfo() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getTypeInfo");
1:d506170:                 }
1:d506170:                 return getTypeInfoX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:33776ff:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getTypeInfoX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:33776ff: 
1:70f7692:         // check if the last call's resultset is closed or not.
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLGETTYPEINFO(?,?)");
1:70f7692: 
1:70f7692:         cs.setShortX(1, (short) 0);
1:70f7692:         cs.setStringX(2, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // call stored procedure SQLStatistics
1:70f7692:     // SYSIBM.SQLStatistics(
1:70f7692:     //              CatalogName varchar(128),
1:70f7692:     //              SchemaName  varchar(128),
1:70f7692:     //              TableName   varchar(128),
1:70f7692:     //              Unique      Smallint,
1:70f7692:     //              Reserved    Smallint,
1:70f7692:     //              Options     varchar(4000))
1:70f7692:     //
1:69e3d06:     public ResultSet getIndexInfo(String catalog,
1:70f7692:                                            String schema,
1:70f7692:                                            String table,
1:70f7692:                                            boolean unique,
1:d506170:                                            boolean approximate) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getIndexInfo", catalog, schema, table, unique, approximate);
1:d506170:                 }
1:d506170:                 return getIndexInfoX(catalog, schema, table, unique, approximate);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getIndexInfoX(String catalog,
1:70f7692:                                     String schema,
1:70f7692:                                     String table,
1:70f7692:                                     boolean unique,
2:70f7692:                                     boolean approximate) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:70f7692:         // validate the input table name
1:70f7692:         if (table == null) {
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:70f7692:         }
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLSTATISTICS(?,?,?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schema);
1:70f7692:         cs.setStringX(3, table);
1:70f7692: 
1:70f7692:         if (unique) {
1:70f7692:             cs.setShortX(4, SQL_INDEX_UNIQUE);
1:70f7692:         } else {
1:70f7692:             cs.setShortX(4, SQL_INDEX_ALL);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (approximate) {
1:70f7692:             cs.setShortX(5, (short) 1);
1:70f7692:         } else {
1:70f7692:             cs.setShortX(5, (short) 0);
1:70f7692:         }
1:70f7692: 
1:70f7692:         cs.setStringX(6, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     //--------------------------JDBC 2.0-----------------------------
1:70f7692: 
1:69e3d06:     public ResultSet getUDTs(String catalog,
1:70f7692:                                       String schemaPattern,
1:70f7692:                                       String typeNamePattern,
1:d506170:                                       int[] types) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getUDTs", catalog, schemaPattern, typeNamePattern, types);
1:d506170:                 }
1:d506170:                 return getUDTsX(catalog, schemaPattern, typeNamePattern, types);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getUDTsX(String catalog,
1:70f7692:                                String schemaPattern,
1:70f7692:                                String typeNamePattern,
2:70f7692:                                int[] types) throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692: 
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:69e3d06:             "SYSIBM.SQLUDTS(?,?,?,?,?)");
1:70f7692: 
1:70f7692:         cs.setStringX(1, catalog);
1:70f7692:         cs.setStringX(2, schemaPattern);
1:70f7692:         cs.setStringX(3, typeNamePattern);
1:70f7692:         int i = 0;
1:4a4b0a8:         String udtTypes = "";
1:70f7692:         while (types != null && i < types.length) {
1:70f7692:             if (i > 0) {
1:70f7692:                 udtTypes = udtTypes.concat(",");
1:70f7692:             }
1:70f7692:             udtTypes = udtTypes.concat(String.valueOf(types[i]));
1:70f7692:             i++;
1:70f7692:         }
1:70f7692:         cs.setStringX(4, udtTypes);
1:70f7692:         cs.setStringX(5, getOptions());
1:765e2c4:         return executeCatalogQuery(cs);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // helper method for the catalog queries only
1:70f7692:     private String getOptions() {
1:70f7692:         int cursorHold;
1:1e8a20f:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:70f7692:             cursorHold = 1;
1:70f7692:         } else {
1:70f7692:             cursorHold = 0;
1:70f7692:         }
1:70f7692:         return "DATATYPE='JDBC';DYNAMIC=0;REPORTPUBLICPRIVILEGES=1;CURSORHOLD=" + cursorHold;
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Derby uses a PreparedStatement argument rather than a callable statement
1:69e3d06:     private ClientResultSet executeCatalogQuery(ClientPreparedStatement cs)
1:d506170:         throws SqlException {
1:70f7692:         try {
1:70f7692:             return cs.executeQueryX();
1:70f7692:         } catch (SqlException e) {
1:70f7692:             if (e.getErrorCode() == -440) {
1:70f7692:                 SqlException newException = new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.STORED_PROC_NOT_INSTALLED));
1:70f7692:                 newException.setNextException(e);
1:70f7692:                 throw newException;
1:70f7692:             } else if (e.getErrorCode() == -444) {
1:70f7692:                 SqlException newException = new SqlException(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId(SQLState.STORED_PROC_LOAD_MODULE_NOT_FOUND));
1:70f7692:                 newException.setNextException(e);
1:70f7692:                 throw newException;
1:70f7692:             } else {
1:70f7692:                 throw e;
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Connection getConnection() throws SQLException {
1:d506170:         checkForClosedConnection();
1:70f7692:         return connection_;
1:70f7692:     }
1:33776ff: 
1:33776ff:     // ------------------- JDBC 3.0 -------------------------
1:70f7692: 
1:d506170:     public boolean supportsNamedParameters() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:f658f85:         return false;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsMultipleOpenResults() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:33776ff: 
1:d506170:     public boolean supportsGetGeneratedKeys() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return false;
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public ResultSet getSuperTypes(String catalog,
1:70f7692:                                             String schemaPattern,
1:d506170:                                             String typeNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getSuperTypes", catalog, schemaPattern, typeNamePattern);
1:d506170:                 }
1:d506170:                 return getSuperTypesX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getSuperTypesX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:70f7692:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
1:70f7692:                 "VARCHAR('', 128) AS TYPE_NAME," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_CAT," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_SCHEM," +
1:70f7692:                 "VARCHAR('', 128) AS SUPERTYPE_NAME " +
1:70f7692:                 "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR ";
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             connection_.prepareDynamicCatalogQuery(sql);
1:765e2c4:         return ps.executeQueryX();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public ResultSet getSuperTables(String catalog,
1:70f7692:                                              String schemaPattern,
1:d506170:                                              String tableNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getSuperTables", catalog, schemaPattern, tableNamePattern);
1:d506170:                 }
1:d506170:                 return getSuperTablesX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getSuperTablesX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:69e3d06:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TABLE_CAT," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM," +
1:70f7692:                 "VARCHAR('', 128) AS TABLE_NAME," +
1:70f7692:                 "VARCHAR('', 128) AS SUPERTABLE_NAME FROM SYSIBM.SYSDUMMY1 " +
1:70f7692:                 "WHERE 1=0 WITH UR";
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             connection_.prepareDynamicCatalogQuery(sql);
1:765e2c4:         return ps.executeQueryX();
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:69e3d06:     public ResultSet getAttributes(String catalog,
1:70f7692:                                             String schemaPattern,
1:70f7692:                                             String typeNamePattern,
1:d506170:                                             String attributeNamePattern) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getAttributes", catalog, schemaPattern, typeNamePattern, attributeNamePattern);
1:d506170:                 }
1:d506170:                 return getAttributesX();
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientResultSet getAttributesX() throws SqlException {
1:d506170:         checkForClosedConnectionX();
1:69e3d06:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
1:70f7692:                 "VARCHAR('', 128) AS TYPE_NAME," +
1:70f7692:                 "VARCHAR('',128) AS ATTR_NAME," +
1:9f5e1d4:                 "0 AS DATA_TYPE," +
1:70f7692:                 "VARCHAR('',129) AS ATTR_TYPE_NAME," +
1:70f7692:                 "0 AS ATTR_SIZE," +
1:70f7692:                 "0 AS DECIMAL_DIGITS," +
1:70f7692:                 "0 AS NUM_PREC_RADIX," +
1:70f7692:                 "2 AS NULLABLE," +
1:70f7692:                 "CAST(NULL AS VARCHAR(254)) AS REMARKS," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS ATTR_DEF," +
1:70f7692:                 "0 AS SQL_DATA_TYPE," +
1:70f7692:                 "0 AS SQL_DATETIME_SUB," +
1:70f7692:                 "0 AS CHAR_OCTET_LENGTH," +
1:70f7692:                 "0 AS ORDINAL_POSITION," +
1:70f7692:                 "VARCHAR('',128) AS IS_NULLABLE," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_CATALOG," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_SCHEMA," +
1:70f7692:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_TABLE," +
1:70f7692:                 "CAST(NULL AS SMALLINT) AS SOURCE_DATA_TYPE " +
1:70f7692:                 "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR";
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             connection_.prepareDynamicCatalogQuery(sql);
1:765e2c4:         return ps.executeQueryX();
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean supportsResultSetHoldability(int holdability) throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return true;
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getResultSetHoldability() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:69e3d06:         return ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getDatabaseMajorVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return productLevel_.versionLevel_;
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getDatabaseMinorVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return productLevel_.releaseLevel_;
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getJDBCMajorVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:9a0cdf1:         return 4;
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getJDBCMinorVersion() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:b6cdb88:         return JVMInfo.jdbcMinorVersion();
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getSQLStateType() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return sqlStateSQL99;
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean locatorsUpdateCopy() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:c99cc56:         return true;
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean supportsStatementPooling() throws SQLException {
1:70f7692:         checkForClosedConnection();
1:70f7692:         return false;
1:70f7692:     }
1:70f7692: 
1:eff3919:     //-----------------------------helper methods---------------------------------
1:70f7692: 
1:eff3919:     // Set flags describing the level of support for this connection.
1:eff3919:     // Flags will be set based on manager level and/or specific product identifiers.
1:eff3919:     // Support for a specific server version can be set as follows. For example
1:eff3919:     // if (productLevel_.greaterThanOrEqualTo(11,1,0))
1:eff3919:     //  supportsTheBestThingEver = true
1:eff3919:     //
1:eff3919:     // WARNING WARNING WARNING !!!!
1:eff3919:     //
1:eff3919:     // If you define an instance variable of NetDatabaseMetaData that
1:eff3919:     // you want computeFeatureSet_() to compute, DO NOT assign an
1:eff3919:     // initial value to the variable in the
1:eff3919:     // declaration. NetDatabaseMetaData's constructor will invoke
1:eff3919:     // DatabaseMetaData's constructor, which then invokes
1:eff3919:     // computeFeatureSet_(). Initialization of instance variables in
1:eff3919:     // NetDatabaseMetaData will happen *after* the invocation of
1:eff3919:     // computeFeatureSet_() and will therefore overwrite the computed
1:eff3919:     // values. So, LEAVE INSTANCE VARIABLES UNINITIALIZED!
1:eff3919:     //
1:eff3919:     // END OF WARNING
1:0326967:     private void computeFeatureSet_() {
1:eff3919: 
1:eff3919:         // Support for QRYCLSIMP was added in 10.2.0
1:eff3919:         if (productLevel_.greaterThanOrEqualTo(10, 2, 0)) {
1:eff3919:             supportsQryclsimp_ = true;
1:eff3919:         } else {
1:eff3919:             supportsQryclsimp_ = false;
1:eff3919:         }
1:eff3919:         
1:eff3919:         supportsLayerBStreaming_ = 
1:eff3919:             productLevel_.greaterThanOrEqualTo(10, 3, 0);
1:eff3919: 
1:eff3919:         supportsSessionDataCaching_ =
1:eff3919:                 productLevel_.greaterThanOrEqualTo(10, 4, 0);
1:eff3919: 
1:eff3919:         supportsUDTs_ =
1:eff3919:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1:eff3919: 
1:eff3919:         supportsTimestampNanoseconds_ =
1:eff3919:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1:eff3919: 
1:eff3919:         supportsEXTDTAAbort_ =
1:eff3919:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1:eff3919: 
1:eff3919:         supportsBooleanValues_ =
1:eff3919:                 productLevel_.greaterThanOrEqualTo(10, 7, 0);
1:eff3919: 
1:d326b7d:         supportsBooleanParameterTransport_ =
1:d326b7d:                 productLevel_.greaterThanOrEqualTo(10, 8, 0);
1:813aa38: 
1:813aa38:         supportsLongRDBNAM_ =
1:813aa38:                 productLevel_.greaterThanOrEqualTo(10, 11, 0);
1:eff3919:     }
1:70f7692: 
1:eff3919:     /**
1:eff3919:      * Check whether the server has full support for the QRYCLSIMP
1:eff3919:      * parameter in OPNQRY.
1:eff3919:      *
1:eff3919:      * @return true if QRYCLSIMP is fully supported
1:eff3919:      */
1:eff3919:     final public boolean serverSupportsQryclsimp() {
1:eff3919:         return supportsQryclsimp_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     final public boolean serverSupportsLayerBStreaming() {
1:eff3919:         return supportsLayerBStreaming_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * Check if server supports session data caching
1:eff3919:      * @return true if the server supports this
1:eff3919:      */
1:eff3919:     final public boolean serverSupportsSessionDataCaching() {
1:eff3919:         return supportsSessionDataCaching_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * Check if server supports UDTs
1:eff3919:      * @return true if the server supports this
1:eff3919:      */
1:eff3919:     final public boolean serverSupportsUDTs() {
2:eff3919:         return supportsUDTs_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * Check if server supports nanoseconds in timestamps
1:eff3919:      * @return true if the server supports this
1:eff3919:      */
1:eff3919:     final public boolean serverSupportsTimestampNanoseconds() {
1:eff3919:         return supportsTimestampNanoseconds_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * Check if server supports product specific EXTDTA abort protocol.
1:eff3919:      * @return {@code true} if the server supports this.
1:eff3919:      */
1:eff3919:     final public boolean serverSupportsEXTDTAAbort() {
1:eff3919:         return supportsEXTDTAAbort_;
1:eff3919:     }
1:eff3919: 
1:eff3919:     /**
1:eff3919:      * Check if server supports boolean values
1:eff3919:      * @return true if the server supports this
1:eff3919:      */
1:b565f41:     private boolean serverSupportsBooleanValues() {
1:d4ebb49:         return supportsBooleanValues_;
1:eff3919:     }
1:33776ff: 
1:9a0cdf1:     /**
1:d326b7d:      * Check if the server accepts receiving booleans as parameter values.
1:d326b7d:      * @return true if the server supports this
1:d326b7d:      */
1:d326b7d:     final public boolean serverSupportsBooleanParameterTransport() {
1:d326b7d:         return supportsBooleanParameterTransport_;
1:d326b7d:     }
1:d326b7d: 
1:813aa38:     final public boolean serverSupportLongRDBNAM() {
1:813aa38:         return supportsLongRDBNAM_;
1:813aa38:     }
1:813aa38: 
1:70f7692:     //------------helper methods for meta data info call methods------------------
1:70f7692: 
1:70f7692: 
1:d506170:     private boolean getMetaDataInfoBoolean(int infoCallIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:eff3919:             if ( !metaDataInfoIsCached_) { metaDataInfoCall(); }
1:eff3919: 
1:eff3919:             if ( serverSupportsBooleanValues() )
1:eff3919:             {
1:eff3919:                 return ((Boolean) metaDataInfoCache_[infoCallIndex]).booleanValue();
1:eff3919:             }
1:eff3919:             else
1:eff3919:             {
1:eff3919:                 return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1:eff3919:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:90731d5: 
1:6eb29f6:     private int getMetaDataInfoInt(int infoCallIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:93cfc7f:             if (metaDataInfoIsCached_) {
1:d506170:                 return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:93cfc7f:             }
1:93cfc7f:             metaDataInfoCall();
2:70f7692:             return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:             
1:70f7692:     }
1:70f7692: 
1:d506170:     private String getMetaDataInfoString(int infoCallIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (metaDataInfoIsCached_) {
1:d506170:                 return (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             }
1:d506170:             metaDataInfoCall();
2:70f7692:             return (String) metaDataInfoCache_[infoCallIndex];
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:9d92267:     private boolean getMetaDataInfoBooleanWithType(int infoCallIndex, int type) 
1:9d92267:         throws SQLException {
1:9d92267: 
1:9d92267:         boolean clientValue =
1:9d92267:             getMetaDataInfoBooleanWithTypeClient(infoCallIndex, type);
1:9d92267:         
1:9d92267:         // DERBY-1252. In Derby <= 10.x, clients (incl JCC) do not have
1:9d92267:         // logic to negotiate down these values with the server, so
1:9d92267:         // for features introduced with 10.x, x >= 2 (e.g. SUR
1:9d92267:         // DERBY-775, in 10.2), the server will return 10.0 values for
1:9d92267:         // any version 10.x so as not to break existing apps running
1:9d92267:         // an older 10 client (e.g. 10.1 client for DERBY-775).
1:9d92267:         // Reciprocally, this means clients at 10.x, where x => 2,
1:9d92267:         // must disregard the server's (too conservative) answers for
1:9d92267:         // these features, see logic in
1:9d92267:         // getMetaDataInfoBooleanWithTypeClient.
1:9d92267:         //
1:9d92267:         // For Derby >= 11, the down-negotiation code below which is
1:9d92267:         // presently commented out should be activated, and the values
1:9d92267:         // returned from the server should once more reflect reality.
1:9d92267: 
1:9d92267:         // Commented out till we hit Derby 11:
1:9d92267:         //
1:9d92267:         //     boolean serverValue = 
1:9d92267:         //         getMetaDataInfoBooleanWithTypeServer(infoCallIndex, type);
1:9d92267:         //
1:9d92267:         //     return clientValue && serverValue;
1:9d92267: 
1:9d92267:         return clientValue;
1:9d92267:     }
1:9d92267: 
1:9d92267: 
1:9d92267:     // Client's view of boolean metadata.  
1:9d92267:     // 
1:9d92267:     // For values which depend on (added) functionality in *both* the
1:9d92267:     // client and the server, the client should have its own view of
1:9d92267:     // all such values here.  For other values, it can defer to the
1:9d92267:     // server. This is a prerequisite for negotiating down in a mixed
1:9d92267:     // client/Server context. Note that metadata negotiation should
1:9d92267:     // mirror the similar negotiation for use of the feature itself,
1:9d92267:     // for example, for scrollable updatable result sets of type
1:9d92267:     // insensitive, the server will downgrade to read-only if it is
1:9d92267:     // older than 10.2.
1:9d92267:     //
1:9d92267:     // See also comments in getMetaDataInfoBooleanWithType and
1:9d92267:     // engine/org/apache/derby/impl/sql/catalog/metadata_net.properties.
1:9d92267:     // 
1:9d92267:     private boolean getMetaDataInfoBooleanWithTypeClient(int infoCallIndex,
1:9d92267:                                                          int type) 
1:9d92267:         throws SQLException {
1:9d92267: 
1:9d92267:         switch (infoCallIndex) {
1:9d92267:         case updatesAreDetected__:
1:9d92267:         case deletesAreDetected__:
1:9d92267:         case ownUpdatesAreVisible__:
1:9d92267:         case ownDeletesAreVisible__:
1:9d92267:             
1:9d92267:             if (productLevel_.greaterThanOrEqualTo(10,2,0) && 
1:9d92267:                 type == ResultSet.TYPE_SCROLL_INSENSITIVE) {
1:9d92267:                 return true;
1:9d92267:             } else {
1:9d92267:                 return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:9d92267:                                                             type);
1:9d92267:             }
1:9d92267:         case insertsAreDetected__:
1:9d92267:         case ownInsertsAreVisible__:
1:9d92267:             if (productLevel_.greaterThanOrEqualTo(10,2,0) &&
1:9d92267:                 type == ResultSet.TYPE_SCROLL_INSENSITIVE) {
1:9d92267:                 return false;
1:9d92267:             } else {
1:9d92267:                 return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:9d92267:                                                             type);
1:9d92267:             }
1:9d92267:         default:
1:9d92267:             return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:9d92267:                                                         type);
1:9d92267:         }
1:9d92267:     }
1:9d92267: 
1:9d92267: 
1:9d92267:     private boolean getMetaDataInfoBooleanWithTypeServer(int infoCallIndex, 
1:9d92267:                                                      int type) 
1:9d92267:         throws SQLException {
1:9d92267: 
1:70f7692:         // Stored Procedure will return a String containing a
1:70f7692:         // comma seperated list of all the supported result Set types
1:70f7692:         // not throwing any exception right now even if the the type is wrong as per the spec
1:d506170:         try
1:d506170:         {
1:d506170:             String returnedFromSP = null;
1:d506170:             if (metaDataInfoIsCached_) {
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             } else {
1:d506170:                 metaDataInfoCall();
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:70f7692:             }
1:69e3d06:             StringTokenizer st = new StringTokenizer(returnedFromSP, ",");
1:d506170:             while (st.hasMoreTokens()) {
1:5da491e:                 if ((Integer.parseInt(st.nextToken())) == type) {
1:d506170:                     return true;
1:d506170:                 }
1:d506170:             }
1:d506170:             return false;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:d506170:     private boolean getMetaDataInfoInt_SupportsResultSetConcurrency(int infoCallIndex, int type, int concurrency) throws SQLException {
1:98f5fd9:         // The stored procured will return a String containing a list
1:98f5fd9:         // of lists: For each result set type in the outer list, an
1:98f5fd9:         // inner list gives the allowed concurrencies for that type:
1:98f5fd9:     // The encoding syntax is reproduced here from the server file
1:98f5fd9:     // 'metadata_net.properties (please keep in synch!):  
1:98f5fd9:     //
1:98f5fd9:         // String syntax:  
1:98f5fd9:     // <type> { "," <concurrency>}* { ";" <type> { "," <concurrency>}* }}*
1:98f5fd9:     //
1:98f5fd9:     // <type> ::= <the integer value for that type from interface java.sql.Resultset
1:98f5fd9:     //             i.e. TYPE_FORWARD_ONLY is 1003>
1:98f5fd9:     // <concurrency> ::= <the integer value for that concurrency
1:98f5fd9:     //                    from interface java.sql.Resultset, i.e.
1:98f5fd9:     //                    CONCUR_UPDATABLE is 1008>
1:d506170:         try
1:d506170:         {
1:d506170:             String returnedFromSP = null;
1:d506170:             if (metaDataInfoIsCached_) {
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             } else {
1:d506170:                 metaDataInfoCall();
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             }
1:69e3d06:             StringTokenizer st = new StringTokenizer(returnedFromSP, ";");
2:d506170:             while (st.hasMoreTokens()) {
1:69e3d06:                 StringTokenizer stForConc =
1:69e3d06:             new StringTokenizer(st.nextToken(), ",");
1:5da491e:                 if ((Integer.parseInt(stForConc.nextToken())) == type) {
1:98f5fd9:                     while (stForConc.hasMoreTokens()) {
1:5da491e:                         if ((Integer.parseInt(stForConc.nextToken())) == concurrency) {
1:d506170:                             return true;
1:d506170:                         }
1:d506170:                     }
1:d506170:                     return false;
1:70f7692:                 }
1:70f7692:             }
1:d506170:             return false;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }            
1:70f7692:     }
1:33776ff: 
1:d506170:     private boolean getMetaDataInfoBoolean_supportsConvert(int infoCallIndex, int fromType, int toType) throws SQLException {
1:70f7692:         // The Stored procedure will return a String contain a list of all the valid conversions it support
1:70f7692:         // For eg. If the database conversion from char(1) to date(91), time(92) and
1:70f7692:         // Decimal(3) to char(1) ,double(8)
1:70f7692:         // then StoredProcedure string will return "1,91,92;3,1,8"
1:70f7692:         // see how fromTypes are seperated by ";"
1:d506170:         try
1:d506170:         {
1:d506170:             String returnedFromSP = null;
2:d506170:             if (metaDataInfoIsCached_) {
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             } else {
2:d506170:                 metaDataInfoCall();
1:d506170:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:d506170:             }
1:69e3d06:             StringTokenizer st = new StringTokenizer(returnedFromSP, ";");
1:d506170:             while (st.hasMoreTokens()) {
1:69e3d06:                 StringTokenizer stForType =
1:69e3d06:                     new StringTokenizer(st.nextToken(), ",");
1:69e3d06: 
1:5da491e:                 if ((Integer.parseInt(stForType.nextToken())) == fromType) {
1:d506170:                     while (st.hasMoreTokens()) {
1:5da491e:                         if ((Integer.parseInt(st.nextToken())) == toType) {
1:d506170:                             return true;
1:d506170:                         }
1:d506170:                     }
1:d506170:                     return false;
1:d506170:                 }
1:d506170:             }
1:d506170:             return false;
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // We synchronize at this level so that we don't have to synchronize all
1:70f7692:     // the meta data info methods.  If we just return hardwired answers we don't
1:70f7692:     // need to synchronize at the higher level.
1:70f7692:     private void metaDataInfoCall() throws SqlException {
22:70f7692:         synchronized (connection_) {
1:69e3d06:             ClientResultSet rs;
1:70f7692: 
1:70f7692:             // These remote calls return a result set containing a single row.
1:70f7692:             // Each column in the row corresponds to a particular get meta data info
1:70f7692:             // method.
1:69e3d06:             ClientPreparedStatement ps = prepareMetaDataQuery(
1:69e3d06:                 "SYSIBM.MetaData()");
1:69e3d06:             rs = (ClientResultSet) ps.executeQueryX();
1:70f7692:             rs.nextX();
1:d506170:             int ColumnCount;
1:d506170:             try {
1:d506170:                 ColumnCount = ((ColumnMetaData) rs.getMetaDataX()).getColumnCount();
1:d506170:             } catch ( SQLException se ) {
1:d506170:                 throw new SqlException(se);
1:d506170:             }
1:70f7692:             for (int infoCallIndex = 0;
1:70f7692:                  (infoCallIndex < ColumnCount && infoCallIndex < metaDataInfoCache_.length);
1:70f7692:                  infoCallIndex++) {
1:70f7692:                 metaDataInfoCache_[infoCallIndex] = rs.getObjectX(infoCallIndex + 1);
1:70f7692:             }
1:70f7692:             metaDataInfoIsCached_ = true;
1:70f7692:             rs.closeX();
1:70f7692:         }
1:33776ff:     }
1:70f7692: 
1:f658f85:     // ------------------- JDBC 4.0 -------------------------
1:f658f85: 
1:0223b95:     /**
1:f658f85:      * Retrieves whether this database supports invoking user-defined
1:f658f85:      * or vendor functions using the stored procedure escape syntax.
2:f658f85:      *
1:f658f85:      * @return <code>true</code>, since Derby supports the escape syntax
2:f658f85:      * @exception SQLException if a database access error occurs
1:f658f85:      */
1:f658f85:     public final boolean supportsStoredFunctionsUsingCallSyntax()
1:f658f85:         throws SQLException
1:f658f85:     {
1:f658f85:         checkForClosedConnection();
1:f658f85:         return true;
1:f658f85:     }
1:f658f85: 
1:0223b95:     /**
1:f658f85:      * Retrieves whether an <code>SQLException</code> will cause all
1:f658f85:      * open <code>ResultSet</code>s to be closed when auto-commit is
1:f658f85:      * <code>true</code>.
1:f658f85:      *
1:f658f85:      * @return <code>false</code>, since Derby does not close all open
1:f658f85:      * result sets when an error occurs
1:f658f85:      * @exception SQLException if a database access error occurs
1:f658f85:      */
1:f658f85:     public final boolean autoCommitFailureClosesAllResultSets()
1:f658f85:         throws SQLException
1:f658f85:     {
1:f658f85:         checkForClosedConnection();
1:f658f85:         return false;
1:f658f85:     }
1:f658f85: 
1:f658f85:     /**
1:533d502:      * Get the schema names available in this database. The results
1:533d502:      * are ordered by schema name.
1:533d502:      *
1:533d502:      * <p>The schema columns are:
1:533d502:      *  <ol>
1:533d502:      *  <li><strong>TABLE_SCHEM</strong> String =&gt; schema name</li>
1:533d502:      *  <li><strong>TABLE_CATALOG</strong> String =&gt; catalog name
1:533d502:      *  (may be <code>null</code>)</li>
1:533d502:      *  </ol>
1:533d502:      *
1:533d502:      * @param catalog catalog name used to narrow down the search; ""
1:533d502:      * means no catalog, <code>null</code> means any catalog
1:533d502:      * @param schemaPattern schema name used to narrow down the
1:533d502:      * search, <code>null</code> means schema name should not be used
1:533d502:      * to narrow down search
1:533d502:      * @return a <code>ResultSet</code> object in which each row is a
1:533d502:      * schema description
1:533d502:      * @exception SQLException if a database error occurs
1:533d502:      */
1:533d502:     public ResultSet getSchemas(String catalog, String schemaPattern)
1:533d502:         throws SQLException
1:533d502:     {
1:533d502:         try {
1:533d502:             synchronized (connection_) {
1:533d502:                 if (agent_.loggingEnabled()) {
1:533d502:                     agent_.logWriter_.traceEntry(this, "getSchemas");
1:533d502:                 }
1:533d502:                 return getSchemasX(catalog, schemaPattern);
1:533d502:             }
1:533d502:         } catch (SqlException se) {
1:533d502:             throw se.getSQLException();
1:533d502:         }
1:533d502:     }
1:533d502: 
1:533d502:     /**
1:533d502:      * Untraced version of <code>getSchemas(String, String)</code>.
1:533d502:      *
1:533d502:      * @param catalog catalog name
1:533d502:      * @param schemaPattern pattern for schema name
1:533d502:      * @return a <code>ResultSet</code> value
1:f2e6696:      * @exception SqlException if a database error occurs
1:533d502:      * @see #getSchemas(String, String)
1:533d502:      */
1:69e3d06:     private ClientResultSet getSchemasX(String catalog, String schemaPattern)
1:533d502:         throws SqlException
1:533d502:     {
1:533d502:         checkForClosedConnectionX();
1:533d502: 
1:533d502:         // If the server has not implemented support for JDBC 4.0,
1:533d502:         // SYSIBM.SQLTABLES does not recognize the GETSCHEMAS=2
1:533d502:         // option, and it will call getTables() instead of
1:533d502:         // getSchemas(). Therefore, check server version and throw an
1:533d502:         // exception if the server does not support JDBC 4.0.
1:533d502:         checkServerJdbcVersionX("getSchemas(String, String)", 4, 0);
1:533d502: 
1:533d502:         String call = "SYSIBM.SQLTABLES(?, ?, '', '', 'GETSCHEMAS=2')";
1:69e3d06:         ClientPreparedStatement cs = prepareMetaDataQuery(call);
1:533d502:         if (catalog == null) {
1:69e3d06:             cs.setNullX(1, Types.VARCHAR);
1:533d502:         } else {
1:533d502:             cs.setStringX(1, catalog);
1:533d502:         }
1:533d502:         if (schemaPattern == null) {
1:69e3d06:             cs.setNullX(2, Types.VARCHAR);
1:533d502:         } else {
1:533d502:             cs.setStringX(2, schemaPattern);
1:533d502:         }
1:533d502:         return cs.executeQueryX();
1:533d502:     }
1:533d502: 
1:533d502:     /**
1:533d502:      * Returns a list of the client info properties supported by the
1:533d502:      * driver. The result set contains the following columns:
1:533d502:      *
1:533d502:      * <p>
1:533d502:      * <ol>
1:533d502:      *  <li>NAME String=&gt; The name of the client info property.</li>
1:533d502:      *  <li>MAX_LEN int=&gt; The maximum length of the value for the
1:533d502:      *      property.</li>
1:533d502:      *  <li>DEFAULT_VALUE String=&gt; The default value of the property.</li>
1:533d502:      *  <li>DESCRIPTION String=&gt; A description of the property.</li>
1:533d502:      * </ol>
1:533d502:      *
1:533d502:      * <p>The <code>ResultSet</code> is sorted by the NAME column.
1:533d502:      *
1:533d502:      * @return A <code>ResultSet</code> object; each row is a
1:533d502:      * supported client info property
1:533d502:      * @exception SQLException if an error occurs
1:533d502:      */
1:533d502:     public ResultSet getClientInfoProperties() throws SQLException {
1:533d502:         try {
1:533d502:             synchronized (connection_) {
1:533d502:                 if (agent_.loggingEnabled()) {
1:533d502:                     agent_.logWriter_.traceEntry(this,
1:533d502:                                                  "getClientInfoProperties");
1:533d502:                 }
1:533d502:                 return getClientInfoPropertiesX();
1:533d502:             }
1:533d502:         } catch (SqlException se) {
1:533d502:             throw se.getSQLException();
1:533d502:         }
1:533d502:     }
1:533d502: 
1:533d502:     /**
1:533d502:      * Untraced version of <code>getClientInfoProperties()</code>.
1:533d502:      * Returns an empty <code>ResultSet</code> with the correct column
1:533d502:      * names.
1:533d502:      *
1:533d502:      * @return a <code>ResultSet</code> value
2:533d502:      * @exception SqlException if a database error occurs
1:533d502:      * @see #getClientInfoProperties
1:533d502:      */
1:69e3d06:     private ClientResultSet getClientInfoPropertiesX() throws SqlException {
1:533d502:         checkForClosedConnectionX();
1:533d502:         final String sql =
1:533d502:             "SELECT CAST(NULL AS VARCHAR(128)) AS NAME, " +
1:533d502:             "CAST(NULL AS INT) AS MAX_LEN, " +
1:533d502:             "CAST(NULL AS VARCHAR(128)) AS DEFAULT_VALUE, " +
1:533d502:             "CAST(NULL AS VARCHAR(128)) AS DESCRIPTION " +
1:533d502:             "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR";
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             connection_.prepareDynamicCatalogQuery(sql);
1:533d502:         return ps.executeQueryX();
1:533d502:     }
1:533d502: 
1:f658f85:     /**
1:9a0cdf1:      * Indicates whether or not this data source supports the SQL
1:9a0cdf1:      * <code>ROWID</code> type. Since Derby does not support the
1:9a0cdf1:      * <code>ROWID</code> type, return <code>ROWID_UNSUPPORTED</code>.
1:9a0cdf1:      *
1:9a0cdf1:      * @return <code>ROWID_UNSUPPORTED</code>
1:9a0cdf1:      * @exception SQLException if a database access error occurs
1:9a0cdf1:      */
1:9a0cdf1:     public RowIdLifetime getRowIdLifetime() throws SQLException {
1:9a0cdf1:         checkForClosedConnection();
1:9a0cdf1:         return RowIdLifetime.ROWID_UNSUPPORTED;
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * Returns false unless <code>interfaces</code> is implemented
1:9a0cdf1:      *
1:9a0cdf1:      * @param  interfaces             a Class defining an interface.
1:9a0cdf1:      * @return true                   if this implements the interface or
1:9a0cdf1:      *                                directly or indirectly wraps an object
1:9a0cdf1:      *                                that does.
1:9a0cdf1:      * @throws java.sql.SQLException  if an error occurs while determining
1:9a0cdf1:      *                                whether this is a wrapper for an object
1:9a0cdf1:      *                                with the given interface.
1:9a0cdf1:      */
1:9a0cdf1:     public boolean isWrapperFor(Class<?> interfaces) throws SQLException {
1:9a0cdf1:         return interfaces.isInstance(this);
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     /**
1:9a0cdf1:      * Returns <code>this</code> if this class implements the interface
1:9a0cdf1:      *
1:9a0cdf1:      * @param  interfaces a Class defining an interface
1:9a0cdf1:      * @return an object that implements the interface
1:9a0cdf1:      * @throws SQLException if no object if found that implements the
1:9a0cdf1:      * interface
1:9a0cdf1:      */
1:9a0cdf1:     public <T> T unwrap(Class<T> interfaces)
1:9a0cdf1:                                    throws SQLException {
1:9a0cdf1:         try {
1:9a0cdf1:             return interfaces.cast(this);
1:9a0cdf1:         } catch (ClassCastException cce) {
1:9a0cdf1:             throw new SqlException(null,
1:9a0cdf1:                 new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:9a0cdf1:                 interfaces).getSQLException();
1:9a0cdf1:         }
1:9a0cdf1:     }
1:9a0cdf1: 
1:81ee700:     // ------------------- JDBC 4.1 -------------------------
1:81ee700: 
1:81ee700:     /** See DatabaseMetaData javadoc */
1:81ee700:     public  boolean generatedKeyAlwaysReturned() { return true; }
1:81ee700: 
1:69e3d06:     public ResultSet getPseudoColumns
1:81ee700:         ( String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern )
1:81ee700:         throws SQLException
1:81ee700:     {
1:81ee700:         try
1:81ee700:         {
1:81ee700:             synchronized (connection_) {
1:81ee700:                 if (agent_.loggingEnabled()) {
1:81ee700:                     agent_.logWriter_.traceEntry
1:81ee700:                         ( this, "getPseudoColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern );
1:81ee700:                 }
1:81ee700:                 return getPseudoColumnsX();
1:81ee700:             }
1:81ee700:         }
1:81ee700:         catch ( SqlException se )
1:81ee700:         {
1:81ee700:             throw se.getSQLException();
1:81ee700:         }
1:81ee700:     }
1:81ee700: 
1:69e3d06:     private ClientResultSet getPseudoColumnsX() throws SqlException
1:81ee700:     {
1:81ee700:         checkForClosedConnectionX();
1:81ee700:         String sql =
1:81ee700:             "SELECT \n" +
1:81ee700:             "        CAST(NULL AS VARCHAR(128)) AS TABLE_CAT, \n" +
1:81ee700:             "        CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM, \n" +
1:81ee700:             "        VARCHAR('', 128) AS TABLE_NAME, \n" +
1:81ee700:             "        VARCHAR('',128) AS COLUMN_NAME, \n" +
1:81ee700:             "        CAST(1 AS INT) AS DATA_TYPE, \n" +
1:81ee700:             "        CAST(1 AS INT) AS COLUMN_SIZE, \n" +
1:81ee700:             "        CAST(NULL AS INT) AS DECIMAL_DIGITS, \n" +
1:81ee700:             "        CAST(NULL AS INT) AS NUM_PREC_RADIX, \n" +
1:81ee700:             "        VARCHAR('',128) AS COLUMN_USAGE, \n" +
1:81ee700:             "        CAST(NULL AS VARCHAR(32672)) AS REMARKS, \n" +
1:81ee700:             "        CAST(NULL AS INT) AS CHAR_OCTET_LENGTH, \n" +
1:81ee700:             "        VARCHAR('NO',128) AS IS_NULLABLE \n" +
1:81ee700:             "    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR"
1:81ee700:             ;
1:69e3d06:         ClientPreparedStatement ps =
1:69e3d06:             connection_.prepareDynamicCatalogQuery(sql);
1:81ee700:         return ps.executeQueryX();
1:81ee700:     }
1:81ee700: 
1:0be2189:     // ------------------- JDBC 4.2 -------------------------
1:0be2189: 
1:ce930bc:     /** See DatabaseMetaData javadoc */
1:ce930bc:     public  long getMaxLogicalLobSize() { return 0L; }
1:0be2189: 
1:0be2189:     /** Derby does not support the Types.REF_CURSOR type. */
1:0be2189:     public boolean supportsRefCursors() { return false; }
1:0be2189: 
1:0be2189: 
1:70f7692:     //----------------------------helper methods----------------------------------
1:70f7692: 
1:70f7692: 
1:69e3d06:     private ClientPreparedStatement prepareMetaDataQuery(String cmd)
1:69e3d06:             throws SqlException {
1:69e3d06:         ClientPreparedStatement ps;
1:70f7692: 
1:69e3d06:         ps = (ClientPreparedStatement)
1:70f7692:                 connection_.prepareStatementX("CALL " + cmd,
1:69e3d06:                         ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                         ResultSet.CONCUR_READ_ONLY,
1:fdfc981:                         connection_.holdability(),
1:69e3d06:                         ClientStatement.NO_GENERATED_KEYS,
1:b52081a:                         null, null);
1:70f7692:         return ps;
1:f658f85:     }
1:70f7692: 
1:f658f85:     /** 
1:d506170:      * A "public" version of checkForClosedConnection() that throws
1:d506170:      * SQLException instead of SqlException.  In particular this is used
1:d506170:      * by all the DatabaseMetadata methods
1:f658f85:      */
1:f658f85:     protected void checkForClosedConnection() throws SQLException
1:d506170:     {
1:d506170:         try {
1:d506170:             checkForClosedConnectionX();
1:d506170:         } catch ( SqlException se ) {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170:     
1:d506170:     private void checkForClosedConnectionX() throws SqlException {
1:70f7692:         if (connection_.isClosedX()) {
1:70f7692:             agent_.checkForDeferredExceptions();
1:486829c:             throw new SqlException(agent_.logWriter_,
1:e65b4db:                 new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)); 
1:178ae9d: 
1:70f7692:         } else {
1:70f7692:             agent_.checkForDeferredExceptions();
1:70f7692:         }
1:70f7692:     }
1:486829c: 
1:178ae9d:     /**
1:178ae9d:      * Checks whether the server supports a JDBC version. If the
1:178ae9d:      * server does not support the JDBC version, an exception is
1:178ae9d:      * thrown.
1:178ae9d:      *
1:178ae9d:      * @param method name of the method for which support is needed on
1:178ae9d:      * the server (used in exception message)
1:178ae9d:      * @param major minimum JDBC major version
1:178ae9d:      * @param minor minimum JDBC minor version if major version matches
1:178ae9d:      * @exception SqlException if the server does not support the
1:178ae9d:      * specified JDBC version
1:178ae9d:      */
1:0326967:     private void checkServerJdbcVersionX(String method, int major, int minor)
1:178ae9d:         throws SqlException
1:178ae9d:     {
1:178ae9d:         if (serverJdbcMajorVersion < major ||
1:178ae9d:             (serverJdbcMajorVersion == major &&
1:178ae9d:              serverJdbcMinorVersion < minor)) {
1:5d2e2bd:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.JDBC_METHOD_NOT_SUPPORTED_BY_SERVER), method);
1:178ae9d:         }
1:178ae9d:     }
1:70f7692: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * &lt; 10.1, and JDK version &gt;= 1.6. Older clients will not have
/////////////////////////////////////////////////////////////////////////
1:      * server and client version &gt; 10.1, and JDK version &gt;= 1.6. Older
commit:ce930bc
/////////////////////////////////////////////////////////////////////////
1:     /** See DatabaseMetaData javadoc */
1:     public  long getMaxLogicalLobSize() { return 0L; }
commit:40b723c
/////////////////////////////////////////////////////////////////////////
0:     public  long getMaxLogicalLobSize() { return ((long) Integer.MAX_VALUE) * 2; }
commit:0be2189
/////////////////////////////////////////////////////////////////////////
1:     // ------------------- JDBC 4.2 -------------------------
1: 
0:     /** See DatabaseMetaData javadoc and Limits.DB2_LOB_MAXWIDTH */
0:     public  long getMaxLogicalLOBSize() { return ((long) Integer.MAX_VALUE) * 2; }
1: 
1:     /** Derby does not support the Types.REF_CURSOR type. */
1:     public boolean supportsRefCursors() { return false; }
1: 
1: 
commit:81ee700
/////////////////////////////////////////////////////////////////////////
1:     // ------------------- JDBC 4.1 -------------------------
1: 
1:     /** See DatabaseMetaData javadoc */
1:     public  boolean generatedKeyAlwaysReturned() { return true; }
1: 
0:     public java.sql.ResultSet getPseudoColumns
1:         ( String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern )
1:         throws SQLException
1:     {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry
1:                         ( this, "getPseudoColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern );
1:                 }
1:                 return getPseudoColumnsX();
1:             }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
0:     private ResultSet getPseudoColumnsX() throws SqlException
1:     {
1:         checkForClosedConnectionX();
1:         String sql =
1:             "SELECT \n" +
1:             "        CAST(NULL AS VARCHAR(128)) AS TABLE_CAT, \n" +
1:             "        CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM, \n" +
1:             "        VARCHAR('', 128) AS TABLE_NAME, \n" +
1:             "        VARCHAR('',128) AS COLUMN_NAME, \n" +
1:             "        CAST(1 AS INT) AS DATA_TYPE, \n" +
1:             "        CAST(1 AS INT) AS COLUMN_SIZE, \n" +
1:             "        CAST(NULL AS INT) AS DECIMAL_DIGITS, \n" +
1:             "        CAST(NULL AS INT) AS NUM_PREC_RADIX, \n" +
1:             "        VARCHAR('',128) AS COLUMN_USAGE, \n" +
1:             "        CAST(NULL AS VARCHAR(32672)) AS REMARKS, \n" +
1:             "        CAST(NULL AS INT) AS CHAR_OCTET_LENGTH, \n" +
1:             "        VARCHAR('NO',128) AS IS_NULLABLE \n" +
1:             "    FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR"
1:             ;
0:         PreparedStatement ps = connection_.prepareDynamicCatalogQuery(sql);
1:         return ps.executeQueryX();
1:     }
1: 
commit:eff3919
/////////////////////////////////////////////////////////////////////////
1:     /** True if the server supports QRYCLSIMP. */
1:     private boolean supportsQryclsimp_;
1:     
1:     private boolean supportsLayerBStreaming_;
1: 
1:     /**
1:      * True if the server supports session data caching
1:      */
1:     private boolean supportsSessionDataCaching_;
1: 
1:     /** True if the server supports UDTs */
1:     private boolean supportsUDTs_;
1: 
1:     /**
1:      * True if the server supports aborting a statement whilst transferring
1:      * EXTDTA objects. Note that there are two types of aborts, depending on
1:      * whether an object is being transferred to the server using DDM layer B
1:      * streaming or not.
1:      */
1:     private boolean supportsEXTDTAAbort_;
1:     
1:     /** True if the server supports nanoseconds in timestamps */
1:     private boolean supportsTimestampNanoseconds_;
1:     
1:     /** True if the server supports boolean values */
1:     private boolean supportsBooleanValues_;
1: 
/////////////////////////////////////////////////////////////////////////
1:     //-----------------------------helper methods---------------------------------
1:     // Set flags describing the level of support for this connection.
1:     // Flags will be set based on manager level and/or specific product identifiers.
1:     // Support for a specific server version can be set as follows. For example
1:     // if (productLevel_.greaterThanOrEqualTo(11,1,0))
1:     //  supportsTheBestThingEver = true
1:     //
1:     // WARNING WARNING WARNING !!!!
1:     //
1:     // If you define an instance variable of NetDatabaseMetaData that
1:     // you want computeFeatureSet_() to compute, DO NOT assign an
1:     // initial value to the variable in the
1:     // declaration. NetDatabaseMetaData's constructor will invoke
1:     // DatabaseMetaData's constructor, which then invokes
1:     // computeFeatureSet_(). Initialization of instance variables in
1:     // NetDatabaseMetaData will happen *after* the invocation of
1:     // computeFeatureSet_() and will therefore overwrite the computed
1:     // values. So, LEAVE INSTANCE VARIABLES UNINITIALIZED!
1:     //
1:     // END OF WARNING
0:     protected void computeFeatureSet_() {
1: 
1:         // Support for QRYCLSIMP was added in 10.2.0
1:         if (productLevel_.greaterThanOrEqualTo(10, 2, 0)) {
1:             supportsQryclsimp_ = true;
1:         } else {
1:             supportsQryclsimp_ = false;
1:         }
1:         
1:         supportsLayerBStreaming_ = 
1:             productLevel_.greaterThanOrEqualTo(10, 3, 0);
1: 
1:         supportsSessionDataCaching_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 4, 0);
1: 
1:         supportsUDTs_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1: 
1:         supportsTimestampNanoseconds_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1: 
1:         supportsEXTDTAAbort_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 6, 0);
1: 
1:         supportsBooleanValues_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 7, 0);
1:     }
1: 
1:     /**
1:      * Check whether the server has full support for the QRYCLSIMP
1:      * parameter in OPNQRY.
1:      *
1:      * @return true if QRYCLSIMP is fully supported
1:      */
1:     final public boolean serverSupportsQryclsimp() {
1:         return supportsQryclsimp_;
1:     }
1: 
1:     final public boolean serverSupportsLayerBStreaming() {
1:         return supportsLayerBStreaming_;
1:     }
1: 
1:     /**
1:      * Check if server supports session data caching
1:      * @return true if the server supports this
1:      */
1:     final public boolean serverSupportsSessionDataCaching() {
1:         return supportsSessionDataCaching_;
1:     }
1: 
1:     /**
1:      * Check if server supports UDTs
1:      * @return true if the server supports this
1:      */
1:     final public boolean serverSupportsUDTs() {
1:         return supportsUDTs_;
1:     }
1: 
1:     /**
1:      * Check if server supports nanoseconds in timestamps
1:      * @return true if the server supports this
1:      */
1:     final public boolean serverSupportsTimestampNanoseconds() {
1:         return supportsTimestampNanoseconds_;
1:     }
1: 
1:     /**
1:      * Check if server supports product specific EXTDTA abort protocol.
1:      * @return {@code true} if the server supports this.
1:      */
1:     final public boolean serverSupportsEXTDTAAbort() {
1:         return supportsEXTDTAAbort_;
1:     }
1: 
1:     /**
1:      * Check if server supports boolean values
1:      * @return true if the server supports this
1:      */
0:     final public boolean serverSupportsBooleanValues() {
1:         return supportsUDTs_;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 			if ( !metaDataInfoIsCached_) { metaDataInfoCall(); }
1: 
1:             if ( serverSupportsBooleanValues() )
1:             {
1:                 return ((Boolean) metaDataInfoCache_[infoCallIndex]).booleanValue();
1:             }
1:             else
1:             {
1:                 return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1:             }
commit:7b301ec
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,java.util.HashSet,UUID)
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,java.util.HashSet,UUID)
commit:ebdced0
/////////////////////////////////////////////////////////////////////////
1:      * <code>EmbedDatabaseMetaData.getFunctionColumns(String,String,
/////////////////////////////////////////////////////////////////////////
1:      * @see #getFunctionColumnsX(String, String, String,String)
1:         getFunctionColumns(String catalog,
/////////////////////////////////////////////////////////////////////////
1:                                    "getFunctionColumns", 
1:                 return getFunctionColumnsX(catalog, schemaPattern, 
/////////////////////////////////////////////////////////////////////////
1:      * Untraced version of <code>getFunctionColumns(String, String,
/////////////////////////////////////////////////////////////////////////
1:      * @see #getFunctionColumns(String, String, String, String)
0:     private ResultSet getFunctionColumnsX(String catalog,
1:         checkServerJdbcVersionX("getFunctionColumns"+
commit:9d92267
/////////////////////////////////////////////////////////////////////////
1: 
1:     private boolean getMetaDataInfoBooleanWithType(int infoCallIndex, int type) 
1:         throws SQLException {
1: 
1:         boolean clientValue =
1:             getMetaDataInfoBooleanWithTypeClient(infoCallIndex, type);
1:         
1:         // DERBY-1252. In Derby <= 10.x, clients (incl JCC) do not have
1:         // logic to negotiate down these values with the server, so
1:         // for features introduced with 10.x, x >= 2 (e.g. SUR
1:         // DERBY-775, in 10.2), the server will return 10.0 values for
1:         // any version 10.x so as not to break existing apps running
1:         // an older 10 client (e.g. 10.1 client for DERBY-775).
1:         // Reciprocally, this means clients at 10.x, where x => 2,
1:         // must disregard the server's (too conservative) answers for
1:         // these features, see logic in
1:         // getMetaDataInfoBooleanWithTypeClient.
1:         //
1:         // For Derby >= 11, the down-negotiation code below which is
1:         // presently commented out should be activated, and the values
1:         // returned from the server should once more reflect reality.
1: 
1:         // Commented out till we hit Derby 11:
1:         //
1:         //     boolean serverValue = 
1:         //         getMetaDataInfoBooleanWithTypeServer(infoCallIndex, type);
1:         //
1:         //     return clientValue && serverValue;
1: 
1:         return clientValue;
1:     }
1: 
1: 
1:     // Client's view of boolean metadata.  
1:     // 
1:     // For values which depend on (added) functionality in *both* the
1:     // client and the server, the client should have its own view of
1:     // all such values here.  For other values, it can defer to the
1:     // server. This is a prerequisite for negotiating down in a mixed
1:     // client/Server context. Note that metadata negotiation should
1:     // mirror the similar negotiation for use of the feature itself,
1:     // for example, for scrollable updatable result sets of type
1:     // insensitive, the server will downgrade to read-only if it is
1:     // older than 10.2.
1:     //
1:     // See also comments in getMetaDataInfoBooleanWithType and
1:     // engine/org/apache/derby/impl/sql/catalog/metadata_net.properties.
1:     // 
1:     private boolean getMetaDataInfoBooleanWithTypeClient(int infoCallIndex,
1:                                                          int type) 
1:         throws SQLException {
1: 
1:         switch (infoCallIndex) {
1:         case updatesAreDetected__:
1:         case deletesAreDetected__:
1:         case ownUpdatesAreVisible__:
1:         case ownDeletesAreVisible__:
1:             
1:             if (productLevel_.greaterThanOrEqualTo(10,2,0) && 
1:                 type == ResultSet.TYPE_SCROLL_INSENSITIVE) {
1:                 return true;
1:             } else {
1:                 return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:                                                             type);
1:             }
1:         case insertsAreDetected__:
1:         case ownInsertsAreVisible__:
1:             if (productLevel_.greaterThanOrEqualTo(10,2,0) &&
1:                 type == ResultSet.TYPE_SCROLL_INSENSITIVE) {
1:                 return false;
1:             } else {
1:                 return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:                                                             type);
1:             }
1:         default:
1:             return getMetaDataInfoBooleanWithTypeServer(infoCallIndex, 
1:                                                         type);
1:         }
1:     }
1: 
1: 
1:     private boolean getMetaDataInfoBooleanWithTypeServer(int infoCallIndex, 
1:                                                      int type) 
1:         throws SQLException {
1: 
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
1: 			if (metaDataInfoIsCached_) {
0: 				return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1: 			}
1: 			metaDataInfoCall();
0: 			return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
commit:406bef9
/////////////////////////////////////////////////////////////////////////
1:      * @exception SqlException if a database error occurs
commit:e423333
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** 
1:      * Get the function names available in the database.  Calls stored
1:      * procedure <code>SYSIBM.SQLFunctionParams(CatalogName
1:      * varchar(128), SchemaName varchar(128), FuncName varchar(128),
1:      * ParamName varchar(128), Options varchar(4000))</code> on the
1:      * server. This procedure will in turn call
0:      * <code>EmbedDatabaseMetaData.getFunctionParameters(String,String,
1:      * String,String)</code><p> Compatibility: Only available if both
0:      * server and client version > 10.1, and JDK version >= 1.6. Older
1:      * clients will not have this method available. Newer clients will
1:      * be able to call this method when connected to an older server,
1:      * but this will be trigger an exception in
1:      * <code>checkServerJdbcVersionX()</code>. <p>Upgrade:
1:      * <code>SYSIBM.SQLFunctionParams</code> is added in
1:      * <code>DataDictionaryImpl.create_10_2_system_procedures
1:      * (TransactionController,UUID)</code> so it will become available
1:      * in newly created databases and after <b>hard</b> upgrade.
1:      *
1:      * @param catalog limit search to this catalog
1:      * @param schemaPattern limit search to schemas matching this pattern
1:      * @param functionNamePattern limit search to functions matching this 
1:      * pattern
1:      * @return a <code>ResultSet</code> listing the fucntions
1:      * @exception SqlException if a database error occurs
0:      * @see #getFunctionParametersX(String, String, String,String)
0:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,UUID)
1:      * @see org.apache.derby.impl.jdbc.EmbedDatabaseMetaData#getFunctions(String,String,String)
1:      */
0:     public java.sql.ResultSet 
0:         getFunctionParameters(String catalog,
1:                               String schemaPattern,
1:                               String functionNamePattern,
1:                               String parameterNamePattern) 
1:         throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.
1:                         traceEntry(this, 
0:                                    "getFunctionParameters", 
1:                                    catalog, schemaPattern, 
1:                                    functionNamePattern, parameterNamePattern);
1:                 }
0:                 return getFunctionParametersX(catalog, schemaPattern, 
1:                                               functionNamePattern, 
1:                                               parameterNamePattern);
1:             }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /** 
0:      * Untraced version of <code>getFunctionParameters(String, String,
1:      * String, String)</code>.
1:      * @param catalog limit search to this catalog
1:      * @param schemaPattern limit search to schemas matching this pattern
1:      * @param functionNamePattern limit search to functions matching this 
1:      * pattern
1:      * @param parameterNamePattern limit search to parameters mathing
1:      * this pattern
1:      * @return a <code>ResultSet</code> listing the fucntions
0:      * @excption SqlException if a database error occurs
0:      * @see #getFunctionParameters(String, String, String, String)
1:      */
0:     private ResultSet getFunctionParametersX(String catalog,
1:                                              String schemaPattern,
1:                                              String functionNamePattern,
1:                                              String parameterNamePattern) 
1:         throws SqlException {
1:         checkForClosedConnectionX();
0:         checkServerJdbcVersionX("getFunctionParameters"+
1:                                 "(String,String,String,String)", 4, 0);
1:  
0:         PreparedStatement cs = 
1:             prepareMetaDataQuery("SYSIBM.SQLFUNCTIONPARAMS(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, functionNamePattern);
1:         cs.setStringX(4, parameterNamePattern);
1:         cs.setStringX(5, getOptions());
1:         return executeCatalogQuery(cs);
1:     }
commit:f2e6696
/////////////////////////////////////////////////////////////////////////
1:      * @exception SqlException if a database error occurs
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:813aa38
/////////////////////////////////////////////////////////////////////////
1:      * DERBY-4805(Increase the length of the RDBNAM field in the DRDA 
1:      *   implementation)  
1:      * True if the server supports RDBNAM longer than 255 character
1:      */
1:     private boolean supportsLongRDBNAM_;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:         supportsLongRDBNAM_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 11, 0);
/////////////////////////////////////////////////////////////////////////
1:     final public boolean serverSupportLongRDBNAM() {
1:         return supportsLongRDBNAM_;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException if a database error occurs
/////////////////////////////////////////////////////////////////////////
1:      * @exception SQLException if a database error occurs
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.RowIdLifetime;
/////////////////////////////////////////////////////////////////////////
1:         return 4;
0:         return 1;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Indicates whether or not this data source supports the SQL
1:      * <code>ROWID</code> type. Since Derby does not support the
1:      * <code>ROWID</code> type, return <code>ROWID_UNSUPPORTED</code>.
1:      *
1:      * @return <code>ROWID_UNSUPPORTED</code>
1:      * @exception SQLException if a database access error occurs
1:      */
1:     public RowIdLifetime getRowIdLifetime() throws SQLException {
1:         checkForClosedConnection();
1:         return RowIdLifetime.ROWID_UNSUPPORTED;
1:     }
1: 
1:     /**
1:      * Returns false unless <code>interfaces</code> is implemented
1:      *
1:      * @param  interfaces             a Class defining an interface.
1:      * @return true                   if this implements the interface or
1:      *                                directly or indirectly wraps an object
1:      *                                that does.
1:      * @throws java.sql.SQLException  if an error occurs while determining
1:      *                                whether this is a wrapper for an object
1:      *                                with the given interface.
1:      */
1:     public boolean isWrapperFor(Class<?> interfaces) throws SQLException {
1:         return interfaces.isInstance(this);
1:     }
1: 
1:     /**
1:      * Returns <code>this</code> if this class implements the interface
1:      *
1:      * @param  interfaces a Class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object if found that implements the
1:      * interface
1:      */
1:     public <T> T unwrap(Class<T> interfaces)
1:                                    throws SQLException {
1:         try {
1:             return interfaces.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw new SqlException(null,
1:                 new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:                 interfaces).getSQLException();
1:         }
1:     }
1: 
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:         String tableTypes = "";
/////////////////////////////////////////////////////////////////////////
1:         String udtTypes = "";
commit:5da491e
/////////////////////////////////////////////////////////////////////////
1:                 if ((Integer.parseInt(st.nextToken())) == type) {
/////////////////////////////////////////////////////////////////////////
1:                 if ((Integer.parseInt(stForConc.nextToken())) == type) {
1:                         if ((Integer.parseInt(stForConc.nextToken())) == concurrency) {
/////////////////////////////////////////////////////////////////////////
1:                 if ((Integer.parseInt(stForType.nextToken())) == fromType) {
1:                         if ((Integer.parseInt(st.nextToken())) == toType) {
commit:d326b7d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * True if the server supports transport of boolean parameter values as
1:      * booleans. If false, boolean values used as parameters in prepared
1:      * statements will be transported as smallints to preserve backwards
1:      * compatibility. See DERBY-4965.
1:      */
1:     private boolean supportsBooleanParameterTransport_;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         supportsBooleanParameterTransport_ =
1:                 productLevel_.greaterThanOrEqualTo(10, 8, 0);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if the server accepts receiving booleans as parameter values.
1:      * @return true if the server supports this
1:      */
1:     final public boolean serverSupportsBooleanParameterTransport() {
1:         return supportsBooleanParameterTransport_;
1:     }
1: 
commit:d4ebb49
/////////////////////////////////////////////////////////////////////////
1:         return supportsBooleanValues_;
commit:7e4dcd9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getSchemas(String catalog, String schemaPattern)
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getClientInfoProperties() throws SQLException {
commit:c99cc56
/////////////////////////////////////////////////////////////////////////
1:         return true;
commit:9f5e1d4
/////////////////////////////////////////////////////////////////////////
1:                 "0 AS DATA_TYPE," +
commit:533d502
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the schema names available in this database. The results
1:      * are ordered by schema name.
1:      *
1:      * <p>The schema columns are:
1:      *  <ol>
1:      *  <li><strong>TABLE_SCHEM</strong> String =&gt; schema name</li>
1:      *  <li><strong>TABLE_CATALOG</strong> String =&gt; catalog name
1:      *  (may be <code>null</code>)</li>
1:      *  </ol>
1:      *
1:      * @param catalog catalog name used to narrow down the search; ""
1:      * means no catalog, <code>null</code> means any catalog
1:      * @param schemaPattern schema name used to narrow down the
1:      * search, <code>null</code> means schema name should not be used
1:      * to narrow down search
1:      * @return a <code>ResultSet</code> object in which each row is a
1:      * schema description
1:      * @exception SQLException if a database error occurs
1:      */
1:     public ResultSet getSchemas(String catalog, String schemaPattern)
1:         throws SQLException
1:     {
1:         try {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getSchemas");
1:                 }
1:                 return getSchemasX(catalog, schemaPattern);
1:             }
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /**
1:      * Untraced version of <code>getSchemas(String, String)</code>.
1:      *
1:      * @param catalog catalog name
1:      * @param schemaPattern pattern for schema name
1:      * @return a <code>ResultSet</code> value
1:      * @exception SqlException if a database error occurs
1:      * @see #getSchemas(String, String)
1:      */
0:     private ResultSet getSchemasX(String catalog, String schemaPattern)
1:         throws SqlException
1:     {
1:         checkForClosedConnectionX();
1: 
1:         // If the server has not implemented support for JDBC 4.0,
1:         // SYSIBM.SQLTABLES does not recognize the GETSCHEMAS=2
1:         // option, and it will call getTables() instead of
1:         // getSchemas(). Therefore, check server version and throw an
1:         // exception if the server does not support JDBC 4.0.
1:         checkServerJdbcVersionX("getSchemas(String, String)", 4, 0);
1: 
1:         String call = "SYSIBM.SQLTABLES(?, ?, '', '', 'GETSCHEMAS=2')";
0:         PreparedStatement cs = prepareMetaDataQuery(call);
1:         if (catalog == null) {
0:             cs.setNullX(1, java.sql.Types.VARCHAR);
1:         } else {
1:             cs.setStringX(1, catalog);
1:         }
1:         if (schemaPattern == null) {
0:             cs.setNullX(2, java.sql.Types.VARCHAR);
1:         } else {
1:             cs.setStringX(2, schemaPattern);
1:         }
1:         return cs.executeQueryX();
1:     }
1: 
1:     /**
1:      * Returns a list of the client info properties supported by the
1:      * driver. The result set contains the following columns:
1:      *
1:      * <p>
1:      * <ol>
1:      *  <li>NAME String=&gt; The name of the client info property.</li>
1:      *  <li>MAX_LEN int=&gt; The maximum length of the value for the
1:      *      property.</li>
1:      *  <li>DEFAULT_VALUE String=&gt; The default value of the property.</li>
1:      *  <li>DESCRIPTION String=&gt; A description of the property.</li>
1:      * </ol>
1:      *
1:      * <p>The <code>ResultSet</code> is sorted by the NAME column.
1:      *
1:      * @return A <code>ResultSet</code> object; each row is a
1:      * supported client info property
1:      * @exception SQLException if an error occurs
1:      */
1:     public ResultSet getClientInfoProperties() throws SQLException {
1:         try {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this,
1:                                                  "getClientInfoProperties");
1:                 }
1:                 return getClientInfoPropertiesX();
1:             }
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /**
1:      * Untraced version of <code>getClientInfoProperties()</code>.
1:      * Returns an empty <code>ResultSet</code> with the correct column
1:      * names.
1:      *
1:      * @return a <code>ResultSet</code> value
1:      * @exception SqlException if a database error occurs
1:      * @see #getClientInfoProperties
1:      */
0:     private ResultSet getClientInfoPropertiesX() throws SqlException {
1:         checkForClosedConnectionX();
1:         final String sql =
1:             "SELECT CAST(NULL AS VARCHAR(128)) AS NAME, " +
1:             "CAST(NULL AS INT) AS MAX_LEN, " +
1:             "CAST(NULL AS VARCHAR(128)) AS DEFAULT_VALUE, " +
1:             "CAST(NULL AS VARCHAR(128)) AS DESCRIPTION " +
1:             "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR";
0:         PreparedStatement ps = connection_.prepareDynamicCatalogQuery(sql);
1:         return ps.executeQueryX();
1:     }
1: 
commit:765e2c4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return executeCatalogQuery(cs);
/////////////////////////////////////////////////////////////////////////
1:         return ps.executeQueryX();
/////////////////////////////////////////////////////////////////////////
1:         return ps.executeQueryX();
/////////////////////////////////////////////////////////////////////////
1:         return ps.executeQueryX();
commit:0223b95
/////////////////////////////////////////////////////////////////////////
1:     /** 
1:      * Get the function names available in the database.  Calls stored
1:      * procedure <code>SYSIBM.SQLFunctions(CatalogName
1:      * varchar(128), SchemaName varchar(128), FuncName varchar(128),
1:      * Options varchar(4000))</code> on the server. This procedure
1:      * will in turn call
1:      * <code>EmbedDatabaseMetaData.getFunctions(String,String,String)</code><p>
1:      * Compatibility: Only available if both server and client version
0:      * > 10.1, and JDK version >= 1.6. Older clients will not have
1:      * this method available. Newer clients will be able to call this
1:      * method when connected to an older server, but this will be
1:      * trigger an exception in
1:      * <code>checkServerJdbcVersionX()</code>. <p>Upgrade:
1:      * <code>SYSIBM.SQLFunctions</code> is added in
1:      * <code>DataDictionaryImpl.create_10_2_system_procedures
1:      * (TransactionController,UUID)</code> so it will become available
1:      * in newly created databases and after <b>hard</b> upgrade.
1:      *
1:      * @param catalog limit search to this catalog
1:      * @param schemaPattern limit search to schemas matching this pattern
1:      * @param functionNamePattern limit search to functions matching this 
1:      * pattern
1:      * @return a <code>ResultSet</code> listing the fucntions
0:      * @exception SqlException if a database error occurs
1:      * @see #getFunctionsX(String, String, String)
0:      * @see org.apache.derby.impl.sql.catalog.DataDictionaryImpl#create_10_2_system_procedures(TransactionController,UUID)
1:      * @see org.apache.derby.impl.jdbc.EmbedDatabaseMetaData#getFunctions(String,String,String)
1:      */
1: 
0:     public java.sql.ResultSet getFunctions(String catalog,
1:                                            String schemaPattern,
1:                                            String functionNamePattern) 
1:         throws SQLException {
1:         try {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getFunctions", 
1:                                                  catalog, schemaPattern, 
1:                                                  functionNamePattern);
1:                 }
1:                 return getFunctionsX(catalog, schemaPattern, 
1:                                      functionNamePattern);
1:             }
1:         }
1:         catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     /** 
1:      * Untraced version of <code>getFunctions(String, String, String)</code>.
1:      * @param catalog limit search to this catalog
1:      * @param schemaPattern limit search to schemas matching this pattern
1:      * @param functionNamePattern limit search to functions matching this 
1:      * pattern
1:      * @return a <code>ResultSet</code> listing the fucntions
0:      * @excption SqlException if a database error occurs
1:      * @see #getFunctions(String, String, String)
1:      */
0:     private ResultSet getFunctionsX(String catalog,
1:                                     String schemaPattern,
1:                                     String functionNamePattern) 
1:         throws SqlException {
1:         checkForClosedConnectionX();
1:         checkServerJdbcVersionX("getFunctions(String,String,String)", 4, 0); 
1: 
0:         PreparedStatement cs = 
1:             prepareMetaDataQuery("SYSIBM.SQLFUNCTIONS(?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, functionNamePattern);
1:         cs.setStringX(4, getOptions());
0:         lastGetProceduresResultSet_ = executeCatalogQuery(cs);
0:         return lastGetProceduresResultSet_;
1:     }
1: 
1: 
commit:178ae9d
/////////////////////////////////////////////////////////////////////////
1:     /** The JDBC major version supported by the server. */
1:     private final int serverJdbcMajorVersion;
1:     /** The JDBC minor version supported by the server. */
1:     private final int serverJdbcMinorVersion;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (productLevel_.lessThan(10, 2, 0)) {
1:             serverJdbcMajorVersion = 3;
1:             serverJdbcMinorVersion = 0;
1:         } else {
1:             serverJdbcMajorVersion = 4;
1:             serverJdbcMinorVersion = 0;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Checks whether the server supports a JDBC version. If the
1:      * server does not support the JDBC version, an exception is
1:      * thrown.
1:      *
1:      * @param method name of the method for which support is needed on
1:      * the server (used in exception message)
1:      * @param major minimum JDBC major version
1:      * @param minor minimum JDBC minor version if major version matches
1:      * @exception SqlException if the server does not support the
1:      * specified JDBC version
1:      */
0:     protected void checkServerJdbcVersionX(String method, int major, int minor)
1:         throws SqlException
1:     {
1:         if (serverJdbcMajorVersion < major ||
1:             (serverJdbcMajorVersion == major &&
1:              serverJdbcMinorVersion < minor)) {
0:             MessageId mid =
0:                 new MessageId(SQLState.JDBC_METHOD_NOT_SUPPORTED_BY_SERVER);
0:             throw new SqlException(agent_.logWriter_, mid, method);
1:         }
1:     }
commit:f658f85
/////////////////////////////////////////////////////////////////////////
1:     // ------------------- JDBC 4.0 -------------------------
1: 
1:     /**
1:      * Retrieves whether this database supports invoking user-defined
1:      * or vendor functions using the stored procedure escape syntax.
1:      *
1:      * @return <code>true</code>, since Derby supports the escape syntax
1:      * @exception SQLException if a database access error occurs
1:      */
1:     public final boolean supportsStoredFunctionsUsingCallSyntax()
1:         throws SQLException
1:     {
1:         checkForClosedConnection();
1:         return true;
1:     }
1: 
1:     /**
1:      * Retrieves whether an <code>SQLException</code> will cause all
1:      * open <code>ResultSet</code>s to be closed when auto-commit is
1:      * <code>true</code>.
1:      *
1:      * @return <code>false</code>, since Derby does not close all open
1:      * result sets when an error occurs
1:      * @exception SQLException if a database access error occurs
1:      */
1:     public final boolean autoCommitFailureClosesAllResultSets()
1:         throws SQLException
1:     {
1:         checkForClosedConnection();
1:         return false;
1:     }
1: 
1:     /**
0:      * Retrieves whether this JDBC driver provides its own
0:      * <code>QueryObjectGenerator</code>.
1:      *
0:      * @return <code>false</code>, since Derby does not provide its
0:      * own generator
1:      * @exception SQLException if a database access error occurs
1:      */
0:     public final boolean providesQueryObjectGenerator() throws SQLException {
1:         checkForClosedConnection();
1:         return false;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     protected void checkForClosedConnection() throws SQLException
commit:98f5fd9
/////////////////////////////////////////////////////////////////////////
1:         // The stored procured will return a String containing a list
1:         // of lists: For each result set type in the outer list, an
1:         // inner list gives the allowed concurrencies for that type:
1: 	// The encoding syntax is reproduced here from the server file
1: 	// 'metadata_net.properties (please keep in synch!):  
1: 	//
1:         // String syntax:  
1: 	// <type> { "," <concurrency>}* { ";" <type> { "," <concurrency>}* }}*
1: 	//
1: 	// <type> ::= <the integer value for that type from interface java.sql.Resultset
1: 	//             i.e. TYPE_FORWARD_ONLY is 1003>
1: 	// <concurrency> ::= <the integer value for that concurrency
1: 	//                    from interface java.sql.Resultset, i.e.
1: 	//                    CONCUR_UPDATABLE is 1008>
/////////////////////////////////////////////////////////////////////////
0:                 java.util.StringTokenizer stForConc = 
0: 		    new java.util.StringTokenizer(st.nextToken(), ",");
0:                 if ((new Integer(stForConc.nextToken())).intValue() == type) {
1:                     while (stForConc.hasMoreTokens()) {
0:                         if ((new Integer(stForConc.nextToken())).intValue() == concurrency) {
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b6cdb88
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
1:             // this value is only used to check that we have at least 4.0; 
1:             // higher is irrelevant
/////////////////////////////////////////////////////////////////////////
1:         return JVMInfo.jdbcMinorVersion();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     private boolean serverSupportsBooleanValues() {
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private Agent agent_;
/////////////////////////////////////////////////////////////////////////
1:     ProductLevel productLevel_;
/////////////////////////////////////////////////////////////////////////
1:     private void computeFeatureSet_() {
/////////////////////////////////////////////////////////////////////////
1:     private void checkServerJdbcVersionX(String method, int major, int minor)
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class DatabaseMetaData
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.ResultSet;
1: import java.sql.Types;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1: public abstract class ClientDatabaseMetaData implements DatabaseMetaData {
/////////////////////////////////////////////////////////////////////////
1:     protected ClientConnection connection_;
/////////////////////////////////////////////////////////////////////////
1:     protected ClientDatabaseMetaData(Agent agent,
1:                                      ClientConnection connection,
1:                                      ProductLevel productLevel) {
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getProcedures(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getProceduresX(String catalog,
1:         ClientPreparedStatement cs =
1:             prepareMetaDataQuery("SYSIBM.SQLPROCEDURES(?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getProcedureColumns(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getProcedureColumnsX(String catalog,
1:         ClientPreparedStatement cs =
1:             prepareMetaDataQuery("SYSIBM.SQLPROCEDURECOLS(?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getFunctions(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getFunctionsX(String catalog,
1:         ClientPreparedStatement cs =
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getFunctionColumnsX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs =
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getTables(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getTablesX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs =
1:             prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1:             cs.setNullX(1, Types.VARCHAR);
1:             cs.setNullX(2, Types.VARCHAR);
1:             cs.setNullX(3, Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
1:             cs.setNullX(4, Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getSchemas() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getSchemasX() throws SqlException {
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLTABLES('', '', '', '', 'GETSCHEMAS=1')");
1:         return (ClientResultSet) cs.executeQueryX();
1:     public ResultSet getCatalogs() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getCatalogsX() throws SqlException {
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLTABLES('', '', '', '', 'GETCATALOGS=1')");
1:         return (ClientResultSet) cs.executeQueryX();
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getTableTypes() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getTableTypesX() throws SqlException {
1:         ClientPreparedStatement cs = null;
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getColumns(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getColumnsX(String catalog,
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLCOLUMNS(?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getColumnPrivileges(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getColumnPrivilegesX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLCOLPRIVILEGES(?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getTablePrivileges(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getTablePrivilegesX(String catalog,
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLTABLEPRIVILEGES(?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getBestRowIdentifier(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getBestRowIdentifierX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getVersionColumns(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getVersionColumnsX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getPrimaryKeys(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getPrimaryKeysX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLPRIMARYKEYS(?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getImportedKeys(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getImportedKeysX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getExportedKeys(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getExportedKeysX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getCrossReference(String primaryCatalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getCrossReferenceX(String primaryCatalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getTypeInfo() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getTypeInfoX() throws SqlException {
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLGETTYPEINFO(?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getIndexInfo(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getIndexInfoX(String catalog,
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLSTATISTICS(?,?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getUDTs(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getUDTsX(String catalog,
1:         ClientPreparedStatement cs = prepareMetaDataQuery(
1:             "SYSIBM.SQLUDTS(?,?,?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet executeCatalogQuery(ClientPreparedStatement cs)
/////////////////////////////////////////////////////////////////////////
1:     public Connection getConnection() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getSuperTypes(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getSuperTypesX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement ps =
1:             connection_.prepareDynamicCatalogQuery(sql);
1:     public ResultSet getSuperTables(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getSuperTablesX() throws SqlException {
1:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TABLE_CAT," +
1:         ClientPreparedStatement ps =
1:             connection_.prepareDynamicCatalogQuery(sql);
1:     public ResultSet getAttributes(String catalog,
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getAttributesX() throws SqlException {
1:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement ps =
1:             connection_.prepareDynamicCatalogQuery(sql);
/////////////////////////////////////////////////////////////////////////
1:         return ResultSet.HOLD_CURSORS_OVER_COMMIT;
/////////////////////////////////////////////////////////////////////////
1:             StringTokenizer st = new StringTokenizer(returnedFromSP, ",");
/////////////////////////////////////////////////////////////////////////
1:             StringTokenizer st = new StringTokenizer(returnedFromSP, ";");
1:                 StringTokenizer stForConc =
1:             new StringTokenizer(st.nextToken(), ",");
/////////////////////////////////////////////////////////////////////////
1:             StringTokenizer st = new StringTokenizer(returnedFromSP, ";");
1:                 StringTokenizer stForType =
1:                     new StringTokenizer(st.nextToken(), ",");
1: 
/////////////////////////////////////////////////////////////////////////
1:             ClientResultSet rs;
1:             ClientPreparedStatement ps = prepareMetaDataQuery(
1:                 "SYSIBM.MetaData()");
1:             rs = (ClientResultSet) ps.executeQueryX();
/////////////////////////////////////////////////////////////////////////
0:     public ResultSet getSchemas(String catalog, String schemaPattern)
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getSchemasX(String catalog, String schemaPattern)
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement cs = prepareMetaDataQuery(call);
1:             cs.setNullX(1, Types.VARCHAR);
1:             cs.setNullX(2, Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
0:     public ResultSet getClientInfoProperties() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getClientInfoPropertiesX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement ps =
1:             connection_.prepareDynamicCatalogQuery(sql);
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet getPseudoColumns
/////////////////////////////////////////////////////////////////////////
1:     private ClientResultSet getPseudoColumnsX() throws SqlException
/////////////////////////////////////////////////////////////////////////
1:         ClientPreparedStatement ps =
1:             connection_.prepareDynamicCatalogQuery(sql);
/////////////////////////////////////////////////////////////////////////
1:     private ClientPreparedStatement prepareMetaDataQuery(String cmd)
1:             throws SqlException {
1:         ClientPreparedStatement ps;
1:         ps = (ClientPreparedStatement)
1:                         ResultSet.TYPE_FORWARD_ONLY,
1:                         ResultSet.CONCUR_READ_ONLY,
1:                         ClientStatement.NO_GENERATED_KEYS,
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
0:         ps = (PreparedStatement)
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
0:             if ( !metaDataInfoIsCached_) { metaDataInfoCall(); }
/////////////////////////////////////////////////////////////////////////
1:     private int getMetaDataInfoInt(int infoCallIndex) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     // The encoding syntax is reproduced here from the server file
0:     // 'metadata_net.properties (please keep in synch!):  
1:     //
0:     // <type> { "," <concurrency>}* { ";" <type> { "," <concurrency>}* }}*
1:     //
0:     // <type> ::= <the integer value for that type from interface java.sql.Resultset
0:     //             i.e. TYPE_FORWARD_ONLY is 1003>
0:     // <concurrency> ::= <the integer value for that concurrency
0:     //                    from interface java.sql.Resultset, i.e.
0:     //                    CONCUR_UPDATABLE is 1008>
/////////////////////////////////////////////////////////////////////////
0:             new java.util.StringTokenizer(st.nextToken(), ",");
commit:b52081a
/////////////////////////////////////////////////////////////////////////
1:                         null, null);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a49056f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:         if (connection_.holdability() == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
commit:fdfc981
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.holdability() == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.holdability() == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.holdability() == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.holdability() == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
1:                         connection_.holdability(),
commit:f86608b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC30Translation;
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.resultSetHoldability_ == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.resultSetHoldability_ == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.resultSetHoldability_ == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
/////////////////////////////////////////////////////////////////////////
0:         if (connection_.resultSetHoldability_ == JDBC30Translation.HOLD_CURSORS_OVER_COMMIT) {
commit:90731d5
/////////////////////////////////////////////////////////////////////////
0:         if ( !metaDataInfoIsCached_) { metaDataInfoCall(); }
1: 
0:         // account for fact that after 10.2 booleans are really booleans, not ints.
0:         Object	metadataScrap = metaDataInfoCache_[infoCallIndex];
1: 
0:         if ( metadataScrap instanceof Boolean ) { return ((Boolean) metadataScrap).booleanValue(); }
0:         else { return ((Integer) metadataScrap).intValue() != 0; }
0: 	private int getMetaDataInfoInt(int infoCallIndex) throws SqlException {
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:920fea5
/////////////////////////////////////////////////////////////////////////
1:         // validate the table name       
1:         if (table == null) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:         }
/////////////////////////////////////////////////////////////////////////
1:         // validate the table name
1:         if (table == null) {
1:             throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1:         }        
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.PRIMARY_TABLE_NAME_IS_NULL)); 
1:                 new ClientMessageId(SQLState.FOREIGN_TABLE_NAME_IS_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.STORED_PROC_NOT_INSTALLED));
1:                     new ClientMessageId(SQLState.STORED_PROC_LOAD_MODULE_NOT_FOUND));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.NO_CURRENT_CONNECTION)); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.JDBC_METHOD_NOT_SUPPORTED_BY_SERVER), method);
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.STORED_PROC_NOT_INSTALLED));
0:                     new MessageId(SQLState.STORED_PROC_LOAD_MODULE_NOT_FOUND));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.JDBC_METHOD_NOT_SUPPORTED_BY_SERVER), method);
commit:486829c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientDataSource;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.PRIMARY_TABLE_NAME_IS_NULL)); 
1: 
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.FOREIGN_TABLE_NAME_IS_NULL)); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.TABLE_NAME_CANNOT_BE_NULL)); 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                 new MessageId(SQLState.NO_CURRENT_CONNECTION)); 
1: 
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean allProceduresAreCallable() throws SQLException {
1:     public boolean allTablesAreSelectable() throws SQLException {
1:     public boolean nullsAreSortedHigh() throws SQLException {
1:     public boolean nullsAreSortedLow() throws SQLException {
1:     public boolean nullsAreSortedAtStart() throws SQLException {
1:     public boolean nullsAreSortedAtEnd() throws SQLException {
1:     public boolean usesLocalFiles() throws SQLException {
1:     public boolean usesLocalFilePerTable() throws SQLException {
1:     public boolean storesUpperCaseIdentifiers() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean storesLowerCaseIdentifiers() throws SQLException {
1:     public boolean storesMixedCaseIdentifiers() throws SQLException {
1:     public boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
1:     public boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
1:     public boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
1:     public String getSQLKeywords() throws SQLException {
1:     public String getNumericFunctions() throws SQLException {
1:     public String getStringFunctions() throws SQLException {
1:     public String getSystemFunctions() throws SQLException {
1:     public String getTimeDateFunctions() throws SQLException {
1:     public String getSearchStringEscape() throws SQLException {
1:     public String getExtraNameCharacters() throws SQLException {
1:     public boolean supportsAlterTableWithAddColumn() throws SQLException {
1:     public boolean supportsAlterTableWithDropColumn() throws SQLException {
1:     public boolean supportsConvert() throws SQLException {
1:     public boolean supportsConvert(int fromType, int toType) throws SQLException {
1:     public boolean supportsDifferentTableCorrelationNames() throws SQLException {
1:     public boolean supportsExpressionsInOrderBy() throws SQLException {
1:     public boolean supportsOrderByUnrelated() throws SQLException {
1:     public boolean supportsGroupBy() throws SQLException {
1:     public boolean supportsGroupByUnrelated() throws SQLException {
1:     public boolean supportsGroupByBeyondSelect() throws SQLException {
1:     public boolean supportsMultipleResultSets() throws SQLException {
1:     public boolean supportsMultipleTransactions() throws SQLException {
1:     public boolean supportsCoreSQLGrammar() throws SQLException {
1:     public boolean supportsExtendedSQLGrammar() throws SQLException {
1:     public boolean supportsANSI92IntermediateSQL() throws SQLException {
1:     public boolean supportsANSI92FullSQL() throws SQLException {
1:     public boolean supportsIntegrityEnhancementFacility() throws SQLException {
1:     public boolean supportsOuterJoins() throws SQLException {
1:     public boolean supportsFullOuterJoins() throws SQLException {
1:     public boolean supportsLimitedOuterJoins() throws SQLException {
1:     public String getSchemaTerm() throws SQLException {
1:     public String getProcedureTerm() throws SQLException {
1:     public String getCatalogTerm() throws SQLException {
1:     public boolean isCatalogAtStart() throws SQLException {
1:     public String getCatalogSeparator() throws SQLException {
1:     public boolean supportsSchemasInDataManipulation() throws SQLException {
1:     public boolean supportsSchemasInProcedureCalls() throws SQLException {
1:     public boolean supportsSchemasInTableDefinitions() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsSchemasInIndexDefinitions() throws SQLException {
1:     public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
1:     public boolean supportsCatalogsInDataManipulation() throws SQLException {
1:     public boolean supportsCatalogsInProcedureCalls() throws SQLException {
1:     public boolean supportsCatalogsInTableDefinitions() throws SQLException {
1:     public boolean supportsCatalogsInIndexDefinitions() throws SQLException {
1:     public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
1:     public boolean supportsPositionedDelete() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsPositionedUpdate() throws SQLException {
1:     public boolean supportsSelectForUpdate() throws SQLException {
1:     public boolean supportsStoredProcedures() throws SQLException {
1:     public boolean supportsSubqueriesInComparisons() throws SQLException {
1:     public boolean supportsUnion() throws SQLException {
1:     public boolean supportsUnionAll() throws SQLException {
1: 
1:     public boolean supportsOpenCursorsAcrossCommit() throws SQLException {
1:     public boolean supportsOpenCursorsAcrossRollback() throws SQLException {
1:     public boolean supportsOpenStatementsAcrossCommit() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsOpenStatementsAcrossRollback() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public int getMaxBinaryLiteralLength() throws SQLException {
1:     public int getMaxCharLiteralLength() throws SQLException {
1:     public int getMaxColumnNameLength() throws SQLException {
1:     public int getMaxColumnsInGroupBy() throws SQLException {
1:     public int getMaxColumnsInIndex() throws SQLException {
1:     public int getMaxColumnsInOrderBy() throws SQLException {
1:     public int getMaxColumnsInSelect() throws SQLException {
1:     public int getMaxColumnsInTable() throws SQLException {
1:     public int getMaxConnections() throws SQLException {
1:     public int getMaxCursorNameLength() throws SQLException {
1:     public int getMaxIndexLength() throws SQLException {
1:     public int getMaxSchemaNameLength() throws SQLException {
1:     public int getMaxProcedureNameLength() throws SQLException {
1:     public int getMaxCatalogNameLength() throws SQLException {
1:     public int getMaxRowSize() throws SQLException {
1:     public boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
1:     public int getMaxStatementLength() throws SQLException {
1:     public int getMaxStatements() throws SQLException {
1:     public int getMaxTableNameLength() throws SQLException {
1:     public int getMaxTablesInSelect() throws SQLException {
1:     public int getMaxUserNameLength() throws SQLException {
1:     public int getDefaultTransactionIsolation() throws SQLException {
1:     public boolean supportsTransactions() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsTransactionIsolationLevel(int level) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {
1:     public boolean supportsDataManipulationTransactionsOnly() throws SQLException {
1:     public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
1:     public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsResultSetType(int type) throws SQLException {
1:     public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean ownUpdatesAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean ownDeletesAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean ownInsertsAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean othersUpdatesAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean othersDeletesAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean othersInsertsAreVisible(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean updatesAreDetected(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean deletesAreDetected(int type) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean insertsAreDetected(int type) throws SQLException {
1:     public boolean supportsBatchUpdates() throws SQLException {
1:     public boolean supportsSavepoints() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public String getURL() throws SQLException {
1:         try
1:         {
1:             checkForClosedConnection();
1:             return getURL_();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     public String getUserName() throws SQLException {
1:     public boolean isReadOnly() throws SQLException {
1:     public String getDatabaseProductName() throws SQLException {
1:     public String getDatabaseProductVersion() throws SQLException {
1:     public String getDriverName() throws SQLException {
1:     public String getDriverVersion() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsMixedCaseIdentifiers() throws SQLException {
1:     public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
1:     public String getIdentifierQuoteString() throws SQLException {
1:     public boolean supportsColumnAliasing() throws SQLException {
1:     public boolean nullPlusNonNullIsNull() throws SQLException {
1:     public boolean supportsTableCorrelationNames() throws SQLException {
1:     public boolean supportsLikeEscapeClause() throws SQLException {
1:     public boolean supportsNonNullableColumns() throws SQLException {
1:     public boolean supportsMinimumSQLGrammar() throws SQLException {
1:     public boolean supportsANSI92EntryLevelSQL() throws SQLException {
1:     public boolean supportsSubqueriesInExists() throws SQLException {
1:     public boolean supportsSubqueriesInIns() throws SQLException {
1:     public boolean supportsSubqueriesInQuantifieds() throws SQLException {
1:     public boolean supportsCorrelatedSubqueries() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                                             String procedureNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getProcedures", catalog, schemaPattern, procedureNamePattern);
1:                 }
1:                 return getProceduresX(catalog, schemaPattern, procedureNamePattern);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                   String columnNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getProcedureColumns", catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:                 }
1:                 return getProcedureColumnsX(catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:         
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                         String types[]) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getTables", catalog, schemaPattern, tableNamePattern, types);
1:                 }
1:                 return getTablesX(catalog, schemaPattern, tableNamePattern, types);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             checkForClosedConnection();
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getSchemas() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getSchemas");
1:                 }
1:                 return getSchemasX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         try {
1:             checkForClosedConnection();
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getCatalogs() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getCatalogs");
1:                 }
1:                 return getCatalogsX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getTableTypes() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getTableTypes");
1:                 }
1:                 return getTableTypesX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                          String columnNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:                 }
1:                 checkForClosedConnection();
1:                 return getColumnsX(catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                   String columnNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getColumnPrivileges", catalog, schema, table, columnNamePattern);
1:                 }
1:                 return getColumnPrivilegesX(catalog, schema, table, columnNamePattern);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                  String tableNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getTablePrivileges", catalog, schemaPattern, tableNamePattern);
1:                 }
1:                 return getTablePrivilegesX(catalog, schemaPattern, tableNamePattern);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                    boolean nullable) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBestRowIdentifier", catalog, schema, table, scope, nullable);
1:                 }
1:                 return getBestRowIdentifierX(catalog, schema, table, scope, nullable);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                 String table) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getVersionColumns", catalog, schema, table);
1:                 }
1:                 return getVersionColumnsX(catalog, schema, table);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                              String table) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getPrimaryKeys", catalog, schema, table);
1:                 }
1:                 return getPrimaryKeysX(catalog, schema, table);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                               String table) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getImportedKeys", catalog, schema, table);
1:                 }
1:                 return getImportedKeysX(catalog, schema, table);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                               String table) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getExportedKeys", catalog, schema, table);
1:                 }
1:                 return getExportedKeysX(catalog, schema, table);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                                 String foreignTable) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getCrossReference", primaryCatalog, primarySchema, primaryTable, foreignCatalog, foreignSchema, foreignTable);
1:                 }
1:                 return getCrossReferenceX(primaryCatalog, primarySchema, primaryTable,
1:                         foreignCatalog, foreignSchema, foreignTable);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet getTypeInfo() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getTypeInfo");
1:                 }
1:                 return getTypeInfoX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                            boolean approximate) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getIndexInfo", catalog, schema, table, unique, approximate);
1:                 }
1:                 return getIndexInfoX(catalog, schema, table, unique, approximate);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                       int[] types) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getUDTs", catalog, schemaPattern, typeNamePattern, types);
1:                 }
1:                 return getUDTsX(catalog, schemaPattern, typeNamePattern, types);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
0:     private ResultSet executeCatalogQuery(PreparedStatement cs) 
1:         throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.Connection getConnection() throws SQLException {
1:     public boolean supportsNamedParameters() throws SQLException {
1:     public boolean supportsMultipleOpenResults() throws SQLException {
1:     public boolean supportsGetGeneratedKeys() throws SQLException {
1:                                             String typeNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getSuperTypes", catalog, schemaPattern, typeNamePattern);
1:                 }
1:                 return getSuperTypesX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                              String tableNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getSuperTables", catalog, schemaPattern, tableNamePattern);
1:                 }
1:                 return getSuperTablesX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:                                             String attributeNamePattern) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getAttributes", catalog, schemaPattern, typeNamePattern, attributeNamePattern);
1:                 }
1:                 return getAttributesX();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         checkForClosedConnectionX();
/////////////////////////////////////////////////////////////////////////
1:     public boolean supportsResultSetHoldability(int holdability) throws SQLException {
1:     public int getResultSetHoldability() throws SQLException {
1:     public int getDatabaseMajorVersion() throws SQLException {
1:     public int getDatabaseMinorVersion() throws SQLException {
1:     public int getJDBCMajorVersion() throws SQLException {
1:     public int getJDBCMinorVersion() throws SQLException {
1:     public int getSQLStateType() throws SQLException {
1:     public boolean locatorsUpdateCopy() throws SQLException {
1:     public boolean supportsStatementPooling() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     private boolean getMetaDataInfoBoolean(int infoCallIndex) throws SQLException {
1:         try
1:         {
0:             if ( !metaDataInfoIsCached_) { metaDataInfoCall(); }
0:             // account for fact that after 10.2 booleans are really booleans, not ints.
0:             Object	metadataScrap = metaDataInfoCache_[infoCallIndex];
0:             if ( metadataScrap instanceof Boolean ) { return ((Boolean) metadataScrap).booleanValue(); }
0:             else { return ((Integer) metadataScrap).intValue() != 0; }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0: 	private int getMetaDataInfoInt(int infoCallIndex) throws SQLException {
1:         try
1:         {
1:             if (metaDataInfoIsCached_) {
1:                 return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:             }
1:             metaDataInfoCall();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:             
1:     private String getMetaDataInfoString(int infoCallIndex) throws SQLException {
1:         try
1:         {
1:             if (metaDataInfoIsCached_) {
1:                 return (String) metaDataInfoCache_[infoCallIndex];
1:             }
1:             metaDataInfoCall();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
0:     private boolean getMetaDataInfoBooleanWithType(int infoCallIndex, int type) throws SQLException {
1:         try
1:         {
1:             String returnedFromSP = null;
1:             if (metaDataInfoIsCached_) {
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:             } else {
1:                 metaDataInfoCall();
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:             java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ",");
1:             while (st.hasMoreTokens()) {
0:                 if ((new Integer(st.nextToken())).intValue() == type) {
1:                     return true;
1:                 }
1:             }
1:             return false;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
1:     private boolean getMetaDataInfoInt_SupportsResultSetConcurrency(int infoCallIndex, int type, int concurrency) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         try
1:         {
1:             String returnedFromSP = null;
1:             if (metaDataInfoIsCached_) {
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:             } else {
1:                 metaDataInfoCall();
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:             java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ";");
1:             while (st.hasMoreTokens()) {
0:                 java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(), ",");
0:                 if ((new Integer(stForType.nextToken())).intValue() == concurrency) {
1:                     while (st.hasMoreTokens()) {
0:                         if ((new Integer(st.nextToken())).intValue() == type) {
1:                             return true;
1:                         }
1:                     }
1:                     return false;
1:                 }
1:             }
1:             return false;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }            
1:     private boolean getMetaDataInfoBoolean_supportsConvert(int infoCallIndex, int fromType, int toType) throws SQLException {
1:         try
1:         {
1:             String returnedFromSP = null;
1:             if (metaDataInfoIsCached_) {
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:             } else {
1:                 metaDataInfoCall();
1:                 returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:             java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ";");
1:             while (st.hasMoreTokens()) {
0:                 java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(), ",");
0:                 if ((new Integer(stForType.nextToken())).intValue() == fromType) {
1:                     while (st.hasMoreTokens()) {
0:                         if ((new Integer(st.nextToken())).intValue() == toType) {
1:                             return true;
1:                         }
1:                     }
1:                     return false;
1:                 }
1:             }
1:             return false;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:             int ColumnCount;
1:             try {
1:                 ColumnCount = ((ColumnMetaData) rs.getMetaDataX()).getColumnCount();
1:             } catch ( SQLException se ) {
1:                 throw new SqlException(se);
1:             }
/////////////////////////////////////////////////////////////////////////
0:     /** 
1:      * A "public" version of checkForClosedConnection() that throws
1:      * SQLException instead of SqlException.  In particular this is used
1:      * by all the DatabaseMetadata methods
1:      */
0:     private void checkForClosedConnection() throws SQLException
1:     {
1:         try {
1:             checkForClosedConnectionX();
1:         } catch ( SqlException se ) {
1:             throw se.getSQLException();
1:         }
1:     }
1:     
1:     private void checkForClosedConnectionX() throws SqlException {
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public abstract class DatabaseMetaData implements java.sql.DatabaseMetaData {
1:     //----------------------------- constants  -----------------------------------
1:     private final static short SQL_BEST_ROWID = 1;
1:     private final static short SQL_ROWVER = 2;
1:     private final static short SQL_INDEX_UNIQUE = 0;
1:     private final static short SQL_INDEX_ALL = 1;
1:     //---------------------navigational members-----------------------------------
0:     protected Agent agent_;
0:     protected Connection connection_;
1:     //-----------------------------state------------------------------------------
1:     private final static int numberOfMetaDataInfoMethods__ = 108;
1:     private Object[] metaDataInfoCache_ = new Object[numberOfMetaDataInfoMethods__];
1:     private boolean metaDataInfoIsCached_ = false;
0:     public ProductLevel productLevel_;
0:     private ResultSet lastGetColumnPrivilegesResultSet_ = null;
0:     private ResultSet lastGetColumnsResultSet_ = null;
0:     private ResultSet lastGetForeignKeysResultSet_ = null;
0:     private ResultSet lastGetPrimaryKeysResultSet_ = null;
0:     private ResultSet lastGetProcedureColumnsResultSet_ = null;
0:     private ResultSet lastGetProceduresResultSet_ = null;
0:     private ResultSet lastGetSpecialColumnsResultSet_ = null;
0:     private ResultSet lastGetStatisticsResultSet_ = null;
0:     private ResultSet lastGetTablePrivilegesResultSet_ = null;
0:     private ResultSet lastGetTablesResultSet_ = null;
0:     private ResultSet lastGetUDTsResultSet_ = null;
0:     private ResultSet lastGetTypeInfoResultSet_ = null;
0:     private ResultSet lastGetAttrResultSet_ = null;
0:     private ResultSet lastGetSuperTypesResultSet_ = null;
0:     private ResultSet lastGetSuperTablesResultSet_ = null;
0:     public boolean useServerXAState_ = true;
1:     //---------------------constructors/finalizer---------------------------------
0:     protected DatabaseMetaData(Agent agent, Connection connection, ProductLevel productLevel) {
1:         agent_ = agent;
1:         connection_ = connection;
1:         productLevel_ = productLevel;
1:         computeFeatureSet_();
1:         if (connection.isXAConnection()) {
1:             connection.xaHostVersion_ = productLevel_.versionLevel_;
1:         }
1:     // ---------------------------jdbc 1------------------------------------------
1:     //----------------------------------------------------------------------
1:     // First, a variety of minor information about the target database.
1:     private final static int allProceduresAreCallable__ = 0;
0:     public boolean allProceduresAreCallable() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(allProceduresAreCallable__);
1:     }
1:     private final static int allTablesAreSelectable__ = 1;
0:     public boolean allTablesAreSelectable() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(allTablesAreSelectable__);
1:     }
1:     private final static int nullsAreSortedHigh__ = 2;
0:     public boolean nullsAreSortedHigh() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(nullsAreSortedHigh__);
1:     }
1:     private final static int nullsAreSortedLow__ = 3;
0:     public boolean nullsAreSortedLow() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(nullsAreSortedLow__);
1:     }
1:     private final static int nullsAreSortedAtStart__ = 4;
0:     public boolean nullsAreSortedAtStart() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(nullsAreSortedAtStart__);
1:     }
1:     private final static int nullsAreSortedAtEnd__ = 5;
0:     public boolean nullsAreSortedAtEnd() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(nullsAreSortedAtEnd__);
1:     }
1:     private final static int usesLocalFiles__ = 6;
0:     public boolean usesLocalFiles() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(usesLocalFiles__);
1:     }
1:     private final static int usesLocalFilePerTable__ = 7;
0:     public boolean usesLocalFilePerTable() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(usesLocalFilePerTable__);
1:     }
1:     private final static int storesUpperCaseIdentifiers__ = 8;
0:     public boolean storesUpperCaseIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesUpperCaseIdentifiers__);
1:     }
1:     private final static int storesLowerCaseIdentifiers__ = 9;
0:     public boolean storesLowerCaseIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesLowerCaseIdentifiers__);
1:     }
1:     private final static int storesMixedCaseIdentifiers__ = 10;
0:     public boolean storesMixedCaseIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesMixedCaseIdentifiers__);
1:     }
1:     private final static int storesUpperCaseQuotedIdentifiers__ = 11;
0:     public boolean storesUpperCaseQuotedIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesUpperCaseQuotedIdentifiers__);
1:     }
1:     private final static int storesLowerCaseQuotedIdentifiers__ = 12;
0:     public boolean storesLowerCaseQuotedIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesLowerCaseQuotedIdentifiers__);
1:     }
1: 
1:     private final static int storesMixedCaseQuotedIdentifiers__ = 13;
1: 
0:     public boolean storesMixedCaseQuotedIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(storesMixedCaseQuotedIdentifiers__);
1:     }
1: 
1:     private final static int getSQLKeywords__ = 14;
1: 
0:     public String getSQLKeywords() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getSQLKeywords__);
1:     }
1: 
1:     private final static int getNumericFunctions__ = 15;
1: 
0:     public String getNumericFunctions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getNumericFunctions__);
1:     }
1: 
1:     private final static int getStringFunctions__ = 16;
1: 
0:     public String getStringFunctions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getStringFunctions__);
1:     }
1: 
1:     private final static int getSystemFunctions__ = 17;
1: 
0:     public String getSystemFunctions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getSystemFunctions__);
1:     }
1: 
1:     private final static int getTimeDateFunctions__ = 18;
1: 
0:     public String getTimeDateFunctions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getTimeDateFunctions__);
1:     }
1: 
1:     private final static int getSearchStringEscape__ = 19;
1: 
0:     public String getSearchStringEscape() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getSearchStringEscape__);
1:     }
1: 
1:     private final static int getExtraNameCharacters__ = 20;
1: 
0:     public String getExtraNameCharacters() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getExtraNameCharacters__);
1:     }
1: 
1:     private final static int supportsAlterTableWithAddColumn__ = 21;
1: 
0:     public boolean supportsAlterTableWithAddColumn() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsAlterTableWithAddColumn__);
1:     }
1: 
1:     private final static int supportsAlterTableWithDropColumn__ = 22;
1: 
0:     public boolean supportsAlterTableWithDropColumn() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsAlterTableWithDropColumn__);
1:     }
1: 
1:     private final static int supportsConvert__ = 23;
1: 
0:     public boolean supportsConvert() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsConvert__);
1:     }
1: 
1:     private final static int supportsConvertType__ = 24;
1: 
0:     public boolean supportsConvert(int fromType, int toType) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean_supportsConvert(supportsConvertType__, fromType, toType);
1:     }
1: 
1:     private final static int supportsDifferentTableCorrelationNames__ = 25;
1: 
0:     public boolean supportsDifferentTableCorrelationNames() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsDifferentTableCorrelationNames__);
1:     }
1: 
1:     private final static int supportsExpressionsInOrderBy__ = 26;
1: 
0:     public boolean supportsExpressionsInOrderBy() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsExpressionsInOrderBy__);
1:     }
1: 
1:     private final static int supportsOrderByUnrelated__ = 27;
1: 
0:     public boolean supportsOrderByUnrelated() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOrderByUnrelated__);
1:     }
1: 
1:     private final static int supportsGroupBy__ = 28;
1: 
0:     public boolean supportsGroupBy() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsGroupBy__);
1:     }
1: 
1:     private final static int supportsGroupByUnrelated__ = 29;
1: 
0:     public boolean supportsGroupByUnrelated() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsGroupByUnrelated__);
1:     }
1: 
1:     private final static int supportsGroupByBeyondSelect__ = 30;
1: 
0:     public boolean supportsGroupByBeyondSelect() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsGroupByBeyondSelect__);
1:     }
1: 
1:     private final static int supportsMultipleResultSets__ = 31;
1: 
0:     public boolean supportsMultipleResultSets() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsMultipleResultSets__);
1:     }
1: 
1:     private final static int supportsMultipleTransactions__ = 32;
1: 
0:     public boolean supportsMultipleTransactions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsMultipleTransactions__);
1:     }
1: 
1:     private final static int supportsCoreSQLGrammar__ = 33;
1: 
0:     public boolean supportsCoreSQLGrammar() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCoreSQLGrammar__);
1:     }
1: 
1:     private final static int supportsExtendedSQLGrammar__ = 34;
1: 
0:     public boolean supportsExtendedSQLGrammar() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsExtendedSQLGrammar__);
1:     }
1: 
1:     private final static int supportsANSI92IntermediateSQL__ = 35;
1: 
0:     public boolean supportsANSI92IntermediateSQL() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsANSI92IntermediateSQL__);
1:     }
1: 
1:     private final static int supportsANSI92FullSQL__ = 36;
1: 
0:     public boolean supportsANSI92FullSQL() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsANSI92FullSQL__);
1:     }
1: 
1:     private final static int supportsIntegrityEnhancementFacility__ = 37;
1: 
0:     public boolean supportsIntegrityEnhancementFacility() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsIntegrityEnhancementFacility__);
1:     }
1: 
1:     private final static int supportsOuterJoins__ = 38;
1: 
0:     public boolean supportsOuterJoins() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOuterJoins__);
1:     }
1: 
1:     private final static int supportsFullOuterJoins__ = 39;
1: 
0:     public boolean supportsFullOuterJoins() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsFullOuterJoins__);
1:     }
1: 
1:     private final static int supportsLimitedOuterJoins__ = 40;
1: 
0:     public boolean supportsLimitedOuterJoins() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsLimitedOuterJoins__);
1:     }
1: 
1:     private final static int getSchemaTerm__ = 41;
1: 
0:     public String getSchemaTerm() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getSchemaTerm__);
1:     }
1: 
1:     private final static int getProcedureTerm__ = 42;
1: 
0:     public String getProcedureTerm() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getProcedureTerm__);
1:     }
1: 
1:     private final static int getCatalogTerm__ = 43;
1: 
0:     public String getCatalogTerm() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getCatalogTerm__);
1:     }
1: 
1:     private final static int isCatalogAtStart__ = 44;
1: 
0:     public boolean isCatalogAtStart() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(isCatalogAtStart__);
1:     }
1: 
1:     private final static int getCatalogSeparator__ = 45;
1: 
0:     public String getCatalogSeparator() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoString(getCatalogSeparator__);
1:     }
1: 
1:     private final static int supportsSchemasInDataManipulation__ = 46;
1: 
0:     public boolean supportsSchemasInDataManipulation() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSchemasInDataManipulation__);
1:     }
1: 
1:     private final static int supportsSchemasInProcedureCalls__ = 47;
1: 
0:     public boolean supportsSchemasInProcedureCalls() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSchemasInProcedureCalls__);
1:     }
1: 
1:     private final static int supportsSchemasInTableDefinitions__ = 48;
1: 
0:     public boolean supportsSchemasInTableDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSchemasInTableDefinitions__);
1:     }
1: 
1: 
1:     private final static int supportsSchemasInIndexDefinitions__ = 49;
1: 
0:     public boolean supportsSchemasInIndexDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSchemasInIndexDefinitions__);
1:     }
1: 
1:     private final static int supportsSchemasInPrivilegeDefinitions__ = 50;
1: 
0:     public boolean supportsSchemasInPrivilegeDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSchemasInPrivilegeDefinitions__);
1:     }
1: 
1:     private final static int supportsCatalogsInDataManipulation__ = 51;
1: 
0:     public boolean supportsCatalogsInDataManipulation() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCatalogsInDataManipulation__);
1:     }
1: 
1:     private final static int supportsCatalogsInProcedureCalls__ = 52;
1: 
0:     public boolean supportsCatalogsInProcedureCalls() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCatalogsInProcedureCalls__);
1:     }
1: 
1:     private final static int supportsCatalogsInTableDefinitions__ = 53;
1: 
0:     public boolean supportsCatalogsInTableDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCatalogsInTableDefinitions__);
1:     }
1: 
1:     private final static int supportsCatalogsInIndexDefinitions__ = 54;
1: 
0:     public boolean supportsCatalogsInIndexDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCatalogsInIndexDefinitions__);
1:     }
1: 
1:     private final static int supportsCatalogsInPrivilegeDefinitions__ = 55;
1: 
0:     public boolean supportsCatalogsInPrivilegeDefinitions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsCatalogsInPrivilegeDefinitions__);
1:     }
1: 
1:     private final static int supportsPositionedDelete__ = 56;
1: 
0:     public boolean supportsPositionedDelete() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsPositionedDelete__);
1:     }
1: 
1: 
1:     private final static int supportsPositionedUpdate__ = 57;
1: 
0:     public boolean supportsPositionedUpdate() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsPositionedUpdate__);
1:     }
1: 
1:     private final static int supportsSelectForUpdate__ = 58;
1: 
0:     public boolean supportsSelectForUpdate() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSelectForUpdate__);
1:     }
1: 
1:     private final static int supportsStoredProcedures__ = 59;
1: 
0:     public boolean supportsStoredProcedures() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsStoredProcedures__);
1:     }
1: 
1:     private final static int supportsSubqueriesInComparisons__ = 60;
1: 
0:     public boolean supportsSubqueriesInComparisons() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsSubqueriesInComparisons__);
1:     }
1: 
1:     private final static int supportsUnion__ = 61;
1: 
0:     public boolean supportsUnion() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsUnion__);
1:     }
1: 
1:     private final static int supportsUnionAll__ = 62;
1: 
0:     public boolean supportsUnionAll() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsUnionAll__);
1:     }
1: 
1:     private final static int supportsOpenCursorsAcrossCommit__ = 63;
1: 
0:     public boolean supportsOpenCursorsAcrossCommit() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOpenCursorsAcrossCommit__);
1:     }
1: 
1:     private final static int supportsOpenCursorsAcrossRollback__ = 64;
1: 
0:     public boolean supportsOpenCursorsAcrossRollback() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOpenCursorsAcrossRollback__);
1:     }
1: 
1:     private final static int supportsOpenStatementsAcrossCommit__ = 65;
1: 
0:     public boolean supportsOpenStatementsAcrossCommit() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOpenStatementsAcrossCommit__);
1:     }
1: 
1: 
1:     private final static int supportsOpenStatementsAcrossRollback__ = 66;
1: 
0:     public boolean supportsOpenStatementsAcrossRollback() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsOpenStatementsAcrossRollback__);
1:     }
1: 
1:     //----------------------------------------------------------------------
1:     // The following group of methods exposes various limitations
1:     // based on the target database with the current driver.
1:     // Unless otherwise specified, a result of zero means there is no
1:     // limit, or the limit is not known.
1:     private final static int getMaxBinaryLiteralLength__ = 67;
1: 
0:     public int getMaxBinaryLiteralLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxBinaryLiteralLength__);
1:     }
1: 
1:     private final static int getMaxCharLiteralLength__ = 68;
1: 
0:     public int getMaxCharLiteralLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxCharLiteralLength__);
1:     }
1: 
1:     private final static int getMaxColumnNameLength__ = 69;
1: 
0:     public int getMaxColumnNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnNameLength__);
1:     }
1: 
1:     private final static int getMaxColumnsInGroupBy__ = 70;
1: 
0:     public int getMaxColumnsInGroupBy() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnsInGroupBy__);
1:     }
1: 
1:     private final static int getMaxColumnsInIndex__ = 71;
1: 
0:     public int getMaxColumnsInIndex() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnsInIndex__);
1:     }
1: 
1:     private final static int getMaxColumnsInOrderBy__ = 72;
1: 
0:     public int getMaxColumnsInOrderBy() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnsInOrderBy__);
1:     }
1: 
1:     private final static int getMaxColumnsInSelect__ = 73;
1: 
0:     public int getMaxColumnsInSelect() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnsInSelect__);
1:     }
1: 
1:     private final static int getMaxColumnsInTable__ = 74;
1: 
0:     public int getMaxColumnsInTable() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxColumnsInTable__);
1:     }
1: 
1:     private final static int getMaxConnections__ = 75;
1: 
0:     public int getMaxConnections() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxConnections__);
1:     }
1: 
1:     private final static int getMaxCursorNameLength__ = 76;
1: 
0:     public int getMaxCursorNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxCursorNameLength__);
1:     }
1: 
1:     private final static int getMaxIndexLength__ = 77;
1: 
0:     public int getMaxIndexLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxIndexLength__);
1:     }
1: 
1:     private final static int getMaxSchemaNameLength__ = 78;
1: 
0:     public int getMaxSchemaNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxSchemaNameLength__);
1:     }
1: 
1:     private final static int getMaxProcedureNameLength__ = 79;
1: 
0:     public int getMaxProcedureNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxProcedureNameLength__);
1:     }
1: 
1:     private final static int getMaxCatalogNameLength__ = 80;
1: 
0:     public int getMaxCatalogNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxCatalogNameLength__);
1:     }
1:     private final static int getMaxRowSize__ = 81;
0:     public int getMaxRowSize() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxRowSize__);
1:     }
1:     private final static int doesMaxRowSizeIncludeBlobs__ = 82;
0:     public boolean doesMaxRowSizeIncludeBlobs() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(doesMaxRowSizeIncludeBlobs__);
1:     }
1:     private final static int getMaxStatementLength__ = 83;
0:     public int getMaxStatementLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxStatementLength__);
1:     }
1:     private final static int getMaxStatements__ = 84;
0:     public int getMaxStatements() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxStatements__);
1:     }
1:     private final static int getMaxTableNameLength__ = 85;
0:     public int getMaxTableNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxTableNameLength__);
1:     }
1:     private final static int getMaxTablesInSelect__ = 86;
0:     public int getMaxTablesInSelect() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxTablesInSelect__);
1:     }
1:     private final static int getMaxUserNameLength__ = 87;
0:     public int getMaxUserNameLength() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getMaxUserNameLength__);
1:     }
1:     private final static int getDefaultTransactionIsolation__ = 88;
0:     public int getDefaultTransactionIsolation() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt(getDefaultTransactionIsolation__);
1:     }
1:     private final static int supportsTransactions__ = 89;
0:     public boolean supportsTransactions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsTransactions__);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all supported levels
1:     private final static int supportsTransactionIsolationLevel__ = 90;
0:     public boolean supportsTransactionIsolationLevel(int level) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(supportsTransactionIsolationLevel__, level);
1:     }
1:     private final static int supportsDataDefinitionAndDataManipulationTransactions__ = 91;
0:     public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsDataDefinitionAndDataManipulationTransactions__);
1:     }
1:     private final static int supportsDataManipulationTransactionsOnly__ = 92;
0:     public boolean supportsDataManipulationTransactionsOnly() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsDataManipulationTransactionsOnly__);
1:     }
1:     private final static int dataDefinitionCausesTransactionCommit__ = 93;
0:     public boolean dataDefinitionCausesTransactionCommit() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(dataDefinitionCausesTransactionCommit__);
1:     }
1:     private final static int dataDefinitionIgnoredInTransactions__ = 94;
0:     public boolean dataDefinitionIgnoredInTransactions() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(dataDefinitionIgnoredInTransactions__);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported resultSet types
1:     private final static int supportsResultSetType__ = 95;
0:     public boolean supportsResultSetType(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(supportsResultSetType__, type);
1:     }
1:     private final static int supportsResultSetConcurrency__ = 96;
0:     public boolean supportsResultSetConcurrency(int type, int concurrency) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoInt_SupportsResultSetConcurrency(supportsResultSetConcurrency__, type, concurrency);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int ownUpdatesAreVisible__ = 97;
0:     public boolean ownUpdatesAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(ownUpdatesAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int ownDeletesAreVisible__ = 98;
0:     public boolean ownDeletesAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(ownDeletesAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list all the supported result Set types
1:     private final static int ownInsertsAreVisible__ = 99;
0:     public boolean ownInsertsAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(ownInsertsAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int othersUpdatesAreVisible__ = 100;
0:     public boolean othersUpdatesAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(othersUpdatesAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int othersDeletesAreVisible__ = 101;
0:     public boolean othersDeletesAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(othersDeletesAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int othersInsertsAreVisible__ = 102;
0:     public boolean othersInsertsAreVisible(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(othersInsertsAreVisible__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int updatesAreDetected__ = 103;
0:     public boolean updatesAreDetected(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(updatesAreDetected__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int deletesAreDetected__ = 104;
0:     public boolean deletesAreDetected(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(deletesAreDetected__, type);
1:     }
1:     // Stored Procedure will return a String containing a
1:     // comma seperated list of all the supported result Set types
1:     private final static int insertsAreDetected__ = 105;
0:     public boolean insertsAreDetected(int type) throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBooleanWithType(insertsAreDetected__, type);
1:     }
1:     private final static int supportsBatchUpdates__ = 106;
0:     public boolean supportsBatchUpdates() throws SqlException {
1:         checkForClosedConnection();
1:         return getMetaDataInfoBoolean(supportsBatchUpdates__);
1:     }
0:     public boolean supportsSavepoints() throws SqlException {
1:         checkForClosedConnection();
1:         if (productLevel_.greaterThanOrEqualTo(5, 2, 0)) {
1:             return true;
1:         }
1:         return false;
1:     }
1:     // start tagging all abstract methods with an underscore like this !!
1:     abstract public String getURL_() throws SqlException;
0:     public String getURL() throws SqlException {
1:         checkForClosedConnection();
0:         return getURL_();
1:     }
0:     public String getUserName() throws SqlException {
1:         checkForClosedConnection();
1:         return connection_.user_;
1:     }
0:     public boolean isReadOnly() throws SqlException {
1:         return false;
1:     }
0:     public String getDatabaseProductName() throws SqlException {
1:         checkForClosedConnection();
1:         return productLevel_.databaseProductName_;
1:     }
0:     public String getDatabaseProductVersion() throws SqlException {
1:         checkForClosedConnection();
1:         return productLevel_.databaseProductVersion_;
1:     }
0:     public String getDriverName() throws SqlException {
1:         checkForClosedConnection();
1:         return Configuration.dncDriverName;
1:     }
0:     public String getDriverVersion() throws SqlException {
1:         checkForClosedConnection();
1:         return Version.getDriverVersion();
1:     }
1:     // JDBC signature also does not throw SqlException, so we don't check for closed connection.
1:     public int getDriverMajorVersion() {
1:         return Version.getMajorVersion();
1:     }
1:     // JDBC signature also does not throw SqlException, so we don't check for closed connection.
1:     public int getDriverMinorVersion() {
1:         return Version.getMinorVersion();
1:     }
1:     //All JDBC Drivers must return false for this method. For this reason we choose
1:     //to return FALSE
0:     public boolean supportsMixedCaseIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:         return false;
1:     }
0:     public boolean supportsMixedCaseQuotedIdentifiers() throws SqlException {
1:         checkForClosedConnection();
1:     }
0:     public String getIdentifierQuoteString() throws SqlException {
1:         checkForClosedConnection();
1:         return "\"";
1:     }
0:     public boolean supportsColumnAliasing() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean nullPlusNonNullIsNull() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsTableCorrelationNames() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsLikeEscapeClause() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsNonNullableColumns() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsMinimumSQLGrammar() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsANSI92EntryLevelSQL() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsSubqueriesInExists() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsSubqueriesInIns() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsSubqueriesInQuantifieds() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
0:     public boolean supportsCorrelatedSubqueries() throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
1:     //------------------------catalog query methods follow--------------------------------------------
1:     // call stored procedure SQLProcedures
1:     // SYSIBM.SQLProcedures(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              ProcName    varchar(128),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getProcedures(String catalog,
1:                                             String schemaPattern,
1:                                             String procedureNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getProcedures", catalog, schemaPattern, procedureNamePattern);
1:             }
0:             return getProceduresX(catalog, schemaPattern, procedureNamePattern);
1:         }
1:     }
1: 
1: 
0:     private ResultSet getProceduresX(String catalog,
1:                                      String schemaPattern,
1:                                      String procedureNamePattern) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPROCEDURES(?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, procedureNamePattern);
1:         cs.setStringX(4, getOptions());
0:         lastGetProceduresResultSet_ = executeCatalogQuery(cs);
0:         return lastGetProceduresResultSet_;
1:     }
1: 
1: 
1:     // call stored procedure SQLProcedureCols
1:     // SYSIBM.SQLProcedureCols(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              ProcName    varchar(128),
1:     //              ParamName   varchar(128),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getProcedureColumns(String catalog,
1:                                                   String schemaPattern,
1:                                                   String procedureNamePattern,
1:                                                   String columnNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getProcedureColumns", catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:             }
0:             return getProcedureColumnsX(catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:         }
1:     }
1: 
0:     private ResultSet getProcedureColumnsX(String catalog,
1:                                            String procedureNamePattern,
1:                                            String columnNamePattern) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPROCEDURECOLS(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, procedureNamePattern);
1:         cs.setStringX(4, columnNamePattern);
1:         cs.setStringX(5, getOptions());
0:         lastGetProcedureColumnsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetProcedureColumnsResultSet_;
1:     // call stored procedure SQLTables
1:     // SYSIBM.SQLTables(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              TaleType    varchar(4000),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getTables(String catalog,
1:                                         String types[]) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTables", catalog, schemaPattern, tableNamePattern, types);
1:             }
0:             return getTablesX(catalog, schemaPattern, tableNamePattern, types);
1:         }
0:     private ResultSet getTablesX(String catalog,
1:                                  String schemaPattern,
1:                                  String tableNamePattern,
1:                                  String types[]) throws SqlException {
1:         checkForClosedConnection();
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1:         if (catalog == null) {
0:             cs.setNullX(1, java.sql.Types.VARCHAR);
1:         } else {
1:             cs.setStringX(1, catalog);
1:         }
1:         if (schemaPattern == null) {
0:             cs.setNullX(2, java.sql.Types.VARCHAR);
1:         } else {
1:             cs.setStringX(2, schemaPattern);
1:         }
1: 
1:         if (tableNamePattern == null) {
0:             cs.setNullX(3, java.sql.Types.VARCHAR);
1:         } else {
1:             cs.setStringX(3, tableNamePattern);
1:         }
1: 
0:         String tableTypes = new String();
1:         int i = 0;
1:         if (types == null) {
0:             cs.setNullX(4, java.sql.Types.VARCHAR);
1:         } else if (types.length == 1 && (types[0].trim()).equals("%")) {
1:             cs.setStringX(4, types[0]);
1:         } else {
1:             while (i < types.length) {
1:                 if (i > 0) {
1:                     tableTypes = tableTypes.concat(",");
1:                 }
1:                 tableTypes = tableTypes.concat("'" + types[i] + "'");
1:                 i++;
1:             }
1:             cs.setStringX(4, tableTypes);
1:         }
1:         cs.setStringX(5, getOptions());
0:         lastGetTablesResultSet_ = executeCatalogQuery(cs);
0:         return lastGetTablesResultSet_;
1:     // call stored procedure SQLTables
1:     // SYSIBM.SQLTables(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              TaleType    varchar(4000),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getSchemas() throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getSchemas");
1:             }
0:             return getSchemasX();
1:         }
1:     }
1: 
0:     private ResultSet getSchemasX() throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLTABLES('', '', '', '', 'GETSCHEMAS=1')");
0:         return (ResultSet) cs.executeQueryX();
1:     }
1: 
1: 
1:     // DERBY does not have the notion of a catalog, so we return a result set with no rows.
0:     public java.sql.ResultSet getCatalogs() throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getCatalogs");
1:             }
0:             return getCatalogsX();
1:         }
1:     }
1: 
0:     private ResultSet getCatalogsX() throws SqlException {
1:         checkForClosedConnection();
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLTABLES('', '', '', '', 'GETCATALOGS=1')");
0:         return (ResultSet) cs.executeQueryX();
1:     }
1: 
1:     // call stored procedure SQLTables
1:     // SYSIBM.SQLTables(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              TableType   varchar(4000),
1:     //              Options     varchar(4000))
0:     public java.sql.ResultSet getTableTypes() throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTableTypes");
1:             }
0:             return getTableTypesX();
1:         }
1:     }
1: 
0:     private ResultSet getTableTypesX() throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
0:         PreparedStatement cs = null;
1:         cs = prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, "");
1:         cs.setStringX(2, "");
1:         cs.setStringX(3, "");
1:         cs.setStringX(4, "%");
1:         int cursorHold;
0:         if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             cursorHold = 1;
1:         } else {
1:             cursorHold = 0;
1:         }
1:         cs.setStringX(5, "DATATYPE='JDBC';GETTABLETYPES=1; CURSORHOLD=" + cursorHold);
0:         lastGetTablesResultSet_ = executeCatalogQuery(cs);
0:         return lastGetTablesResultSet_;
1:     }
1: 
1: 
1:     // call stored procedure SQLColumns
1:     // SYSIBM.SQLColumns(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              ColumnName  varchar(128),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getColumns(String catalog,
1:                                          String tableNamePattern,
1:                                          String columnNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:             }
1:             checkForClosedConnection();
0:             return getColumnsX(catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:         }
1:     }
0:     private ResultSet getColumnsX(String catalog,
1:                                   String schemaPattern,
1:                                   String tableNamePattern,
1:                                   String columnNamePattern) throws SqlException {
1:         checkForClosedConnection();
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLCOLUMNS(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, tableNamePattern);
1:         cs.setStringX(4, columnNamePattern); //Always null  for JDBC
1:         cs.setStringX(5, getOptions());
0:         lastGetColumnsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetColumnsResultSet_;
1:     }
1:     // call stored procedure SQLColumnPrivileges
1:     // SYSIBM.SQLColPrivileges(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              ColumnName  varchar(128),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getColumnPrivileges(String catalog,
1:                                                   String columnNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getColumnPrivileges", catalog, schema, table, columnNamePattern);
1:             }
0:             return getColumnPrivilegesX(catalog, schema, table, columnNamePattern);
1:         }
0:     private ResultSet getColumnPrivilegesX(String catalog,
1:                                            String columnNamePattern) throws SqlException {
1:         checkForClosedConnection();
1:         // check input params, table and columnNamePattern cannot be null
1:         if (table == null) {
0:             throw new SqlException(agent_.logWriter_, "getColumnPrivileges(): null not allowed for table name");
1:         }
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLCOLPRIVILEGES(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schema);
1:         cs.setStringX(3, table);
1:         cs.setStringX(4, columnNamePattern);
1:         cs.setStringX(5, getOptions());
0:         lastGetColumnPrivilegesResultSet_ = executeCatalogQuery(cs);
0:         return lastGetColumnPrivilegesResultSet_;
1:     }
1: 
1: 
1:     // call stored procedure SQLTablePrivileges
1:     // SYSIBM.SQLTablePrivileges(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              Options     varchar(4000))
0:     public java.sql.ResultSet getTablePrivileges(String catalog,
1:                                                  String schemaPattern,
1:                                                  String tableNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTablePrivileges", catalog, schemaPattern, tableNamePattern);
1:             }
0:             return getTablePrivilegesX(catalog, schemaPattern, tableNamePattern);
1:         }
0:     private ResultSet getTablePrivilegesX(String catalog,
1:                                           String schemaPattern,
1:                                           String tableNamePattern) throws SqlException {
1:         checkForClosedConnection();
0:         ;
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLTABLEPRIVILEGES(?,?,?,?)");
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, tableNamePattern);
1:         cs.setStringX(4, getOptions());
0:         lastGetTablePrivilegesResultSet_ = executeCatalogQuery(cs);
0:         return lastGetTablePrivilegesResultSet_;
1:     // call stored procedure
1:     // SYSIBM.SQLSPECIALCOLUMNS ( IN COLTYPE SMALLINT,
1:     //                            IN CATALOG_NAME VARCHAR(128),
1:     //                            IN SCHEMA_NAME  VARCHAR(128),
1:     //                            IN TABLE_NAME   VARCHAR(128),
1:     //                            IN SCOPE        SMALLINT,
1:     //                            IN NULLABLE     SMALLINT,
1:     //                            IN OPTIONS      VARCHAR(4000) )
1:     //
0:     public java.sql.ResultSet getBestRowIdentifier(String catalog,
1:                                                    String schema,
1:                                                    String table,
1:                                                    int scope,
1:                                                    boolean nullable) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBestRowIdentifier", catalog, schema, table, scope, nullable);
1:             }
0:             return getBestRowIdentifierX(catalog, schema, table, scope, nullable);
1:         }
0:     private ResultSet getBestRowIdentifierX(String catalog,
1:                                             String table,
1:                                             int scope,
1:                                             boolean nullable) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
1:         // check input params
1:         //
1:         // validate input table, which can not be null
1:         if (table == null) {
0:             throw new SqlException(agent_.logWriter_, "getBestRowIdentifier(): null not allowed for table name");
1:         }
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1: 
1:         cs.setIntX(1, SQL_BEST_ROWID);
1:         cs.setStringX(2, catalog);
1:         cs.setStringX(3, schema);
1:         cs.setStringX(4, table);
1:         cs.setIntX(5, scope);
1:         if (nullable) {
1:             cs.setShortX(6, (short) 1);
1:         } else {
1:             cs.setShortX(6, (short) 0);
1:         }
1:         cs.setStringX(7, getOptions());
0:         lastGetSpecialColumnsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetSpecialColumnsResultSet_;
0:     public java.sql.ResultSet getVersionColumns(String catalog,
1:                                                 String schema,
1:                                                 String table) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getVersionColumns", catalog, schema, table);
1:             }
0:             return getVersionColumnsX(catalog, schema, table);
1:         }
0:     private ResultSet getVersionColumnsX(String catalog,
1:                                          String schema,
1:                                          String table) throws SqlException {
1:         checkForClosedConnection();
1:         // validate input table, which can not be null
1:         if (table == null) {
0:             throw new SqlException(agent_.logWriter_, "getBestRowIdentifier(): null not allowed for table name");
1:         }
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1:         cs.setIntX(1, SQL_ROWVER);
1:         cs.setStringX(2, catalog);
1:         cs.setStringX(3, schema);
1:         cs.setStringX(4, table);
1:         cs.setIntX(5, 0);
1:         cs.setShortX(6, (short) 0);
1:         cs.setStringX(7, getOptions());
1: 
0:         lastGetSpecialColumnsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetSpecialColumnsResultSet_;
1:     }
1: 
1:     // call stored procedure SQLPrimaryKeys
1:     // SYSIBM.SQLPrimaryKeys(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getPrimaryKeys(String catalog,
1:                                              String table) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getPrimaryKeys", catalog, schema, table);
1:             }
0:             return getPrimaryKeysX(catalog, schema, table);
1:         }
0:     private ResultSet getPrimaryKeysX(String catalog,
1:                                       String table) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1:         // validate the input table name
1:         if (table == null) {
0:             throw new SqlException(agent_.logWriter_, "getIndexInfo(): null not allowed for table name");
1:         }
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPRIMARYKEYS(?,?,?,?)");
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schema);
1:         cs.setStringX(3, table);
1:         cs.setStringX(4, getOptions());
0:         lastGetPrimaryKeysResultSet_ = executeCatalogQuery(cs);
0:         return lastGetPrimaryKeysResultSet_;
1: 
1:     // call storlastGetPrimaryKeysResultSet_ed procedure SQLForeignKeys
1:     // SYSIBM.SQLForeignKeys(
1:     //              PKCatalogName varchar(128),
1:     //              PKSchemaName  varchar(128),
1:     //              PKTableName   varchar(128),
1:     //              FKCatalogName varchar(128),
1:     //              FKSchemaName  varchar(128),
1:     //              FKTableName   varchar(128),
1:     //              Options       varchar(4000))
1:     //
0:     public java.sql.ResultSet getImportedKeys(String catalog,
1:                                               String schema,
1:                                               String table) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getImportedKeys", catalog, schema, table);
1:             }
0:             return getImportedKeysX(catalog, schema, table);
1:         }
0:     private ResultSet getImportedKeysX(String catalog,
1:                                        String schema,
1:                                        String table) throws SqlException {
1:         checkForClosedConnection();
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1:         cs.setStringX(1, "");
1:         cs.setStringX(2, null);
1:         cs.setStringX(3, "");
1:         cs.setStringX(4, catalog);
1:         cs.setStringX(5, schema);
1:         cs.setStringX(6, table);
1:         // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
1:         // As a workaround in getCrossReference(), we'll just "select * where 0=1" when primaryTable==""
0:         if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             cs.setStringX(7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=1");
1:         } else {
1:             cs.setStringX(7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=0");
1:         }
0:         lastGetForeignKeysResultSet_ = executeCatalogQuery(cs);
0:         return lastGetForeignKeysResultSet_;
1:     // call stored procedure SQLForeignKeys
1:     // SYSIBM.SQLForeignKeys(
1:     //              PKCatalogName varchar(128),
1:     //              PKSchemaName  varchar(128),
1:     //              PKTableName   varchar(128),
1:     //              FKCatalogName varchar(128),
1:     //              FKSchemaName  varchar(128),
1:     //              FKTableName   varchar(128),
1:     //              Options       varchar(4000))
1:     //
0:     public java.sql.ResultSet getExportedKeys(String catalog,
1:                                               String schema,
1:                                               String table) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getExportedKeys", catalog, schema, table);
1:             }
0:             return getExportedKeysX(catalog, schema, table);
1:         }
0:     private ResultSet getExportedKeysX(String catalog,
1:                                        String schema,
1:                                        String table) throws SqlException {
1:         checkForClosedConnection();
0:         ;
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schema);
1:         cs.setStringX(3, table);
1:         cs.setStringX(4, "");
1:         cs.setStringX(5, null);
1:         cs.setStringX(6, "");
1:         // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
1:         // As a workaround in getCrossReference(), we'll just "select * where 0=1" when foreignTable==""
0:         if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             cs.setStringX(7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=1");
1:         } else {
1:             cs.setStringX(7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=0");
1:         }
0:         lastGetForeignKeysResultSet_ = executeCatalogQuery(cs);
0:         return lastGetForeignKeysResultSet_;
1:     // call stored procedure SQLForeignKeys
1:     // SYSIBM.SQLForeignKeys(
1:     //              PKCatalogName varchar(128),
1:     //              PKSchemaName  varchar(128),
1:     //              PKTableName   varchar(128),
1:     //              FKCatalogName varchar(128),
1:     //              FKSchemaName  varchar(128),
1:     //              FKTableName   varchar(128),
1:     //              Options       varchar(4000))
1:     //
0:     public java.sql.ResultSet getCrossReference(String primaryCatalog,
1:                                                 String primarySchema,
1:                                                 String primaryTable,
1:                                                 String foreignCatalog,
1:                                                 String foreignSchema,
1:                                                 String foreignTable) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getCrossReference", primaryCatalog, primarySchema, primaryTable, foreignCatalog, foreignSchema, foreignTable);
1:             }
0:             return getCrossReferenceX(primaryCatalog, primarySchema, primaryTable,
0:                     foreignCatalog, foreignSchema, foreignTable);
1:         }
0:     private ResultSet getCrossReferenceX(String primaryCatalog,
1:                                          String primarySchema,
1:                                          String primaryTable,
1:                                          String foreignCatalog,
1:                                          String foreignSchema,
1:                                          String foreignTable) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1:         // check input params, primaryTable and foreignTable cannot be null
1:         if (primaryTable == null) {
0:             throw new SqlException(agent_.logWriter_, "getCrossReference(): null not allowed for primary table name");
1:         }
1: 
1:         if (foreignTable == null) {
0:             throw new SqlException(agent_.logWriter_, "getCrossReference(): null not allowed for foreign table name");
1:         }
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1: 
1:         cs.setStringX(1, primaryCatalog);
1:         cs.setStringX(2, primarySchema);
1:         cs.setStringX(3, primaryTable);
1:         cs.setStringX(4, foreignCatalog);
1:         cs.setStringX(5, foreignSchema);
1:         cs.setStringX(6, foreignTable);
1:         cs.setStringX(7, getOptions());
0:         lastGetForeignKeysResultSet_ = executeCatalogQuery(cs);
0:         return lastGetForeignKeysResultSet_;
1:     // call stored procedure SQLGetTypeInfo
1:     // SYSIBM.SQLGetTypeInfo (IN DATATYPE SMALLINT,
1:     //                        IN Options VARCHAR(4000))
1:     //
1:     //
0:     public java.sql.ResultSet getTypeInfo() throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTypeInfo");
1:             }
0:             return getTypeInfoX();
1:         }
0:     private ResultSet getTypeInfoX() throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
1:         // check if the last call's resultset is closed or not.
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLGETTYPEINFO(?,?)");
1: 
1:         cs.setShortX(1, (short) 0);
1:         cs.setStringX(2, getOptions());
0:         lastGetTypeInfoResultSet_ = executeCatalogQuery(cs);
0:         return lastGetTypeInfoResultSet_;
1:     }
1: 
1: 
1:     // call stored procedure SQLStatistics
1:     // SYSIBM.SQLStatistics(
1:     //              CatalogName varchar(128),
1:     //              SchemaName  varchar(128),
1:     //              TableName   varchar(128),
1:     //              Unique      Smallint,
1:     //              Reserved    Smallint,
1:     //              Options     varchar(4000))
1:     //
0:     public java.sql.ResultSet getIndexInfo(String catalog,
1:                                            String schema,
1:                                            String table,
1:                                            boolean unique,
1:                                            boolean approximate) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getIndexInfo", catalog, schema, table, unique, approximate);
1:             }
0:             return getIndexInfoX(catalog, schema, table, unique, approximate);
1:         }
1:     }
1: 
0:     private ResultSet getIndexInfoX(String catalog,
1:                                     String schema,
1:                                     String table,
1:                                     boolean unique,
1:                                     boolean approximate) throws SqlException {
1:         checkForClosedConnection();
1: 
1:         // validate the input table name
1:         if (table == null) {
0:             throw new SqlException(agent_.logWriter_, "getIndexInfo(): null not allowed for table name");
1:         }
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSTATISTICS(?,?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schema);
1:         cs.setStringX(3, table);
1: 
1:         if (unique) {
1:             cs.setShortX(4, SQL_INDEX_UNIQUE);
1:         } else {
1:             cs.setShortX(4, SQL_INDEX_ALL);
1:         }
1: 
1:         if (approximate) {
1:             cs.setShortX(5, (short) 1);
1:         } else {
1:             cs.setShortX(5, (short) 0);
1:         }
1: 
1:         cs.setStringX(6, getOptions());
0:         lastGetStatisticsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetStatisticsResultSet_;
1:     }
1: 
1: 
1:     //--------------------------JDBC 2.0-----------------------------
1: 
0:     public java.sql.ResultSet getUDTs(String catalog,
1:                                       String schemaPattern,
1:                                       String typeNamePattern,
1:                                       int[] types) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getUDTs", catalog, schemaPattern, typeNamePattern, types);
1:             }
0:             return getUDTsX(catalog, schemaPattern, typeNamePattern, types);
1:         }
1:     }
1: 
0:     private ResultSet getUDTsX(String catalog,
1:                                String schemaPattern,
1:                                String typeNamePattern,
1:                                int[] types) throws SqlException {
1:         checkForClosedConnection();
0:         ;
1: 
0:         PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLUDTS(?,?,?,?,?)");
1: 
1:         cs.setStringX(1, catalog);
1:         cs.setStringX(2, schemaPattern);
1:         cs.setStringX(3, typeNamePattern);
1:         int i = 0;
0:         String udtTypes = new String();
1:         while (types != null && i < types.length) {
1:             if (i > 0) {
1:                 udtTypes = udtTypes.concat(",");
1:             }
1:             udtTypes = udtTypes.concat(String.valueOf(types[i]));
1:             i++;
1:         }
1:         cs.setStringX(4, udtTypes);
1:         cs.setStringX(5, getOptions());
0:         lastGetUDTsResultSet_ = executeCatalogQuery(cs);
0:         return lastGetUDTsResultSet_;
1:     }
1: 
1: 
1:     // helper method for the catalog queries only
1:     private String getOptions() {
1:         int cursorHold;
0:         if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT) {
1:             cursorHold = 1;
1:         } else {
1:             cursorHold = 0;
1:         }
1:         return "DATATYPE='JDBC';DYNAMIC=0;REPORTPUBLICPRIVILEGES=1;CURSORHOLD=" + cursorHold;
1: 
1:     }
1: 
1:     // Derby uses a PreparedStatement argument rather than a callable statement
0:     private ResultSet executeCatalogQuery(PreparedStatement cs) throws SqlException {
1:         try {
1:             return cs.executeQueryX();
1:         } catch (SqlException e) {
1:             if (e.getErrorCode() == -440) {
1:                 SqlException newException = new SqlException(agent_.logWriter_,
0:                         "The required stored procedure is not installed on the server.");
1:                 newException.setNextException(e);
1:                 throw newException;
1:             } else if (e.getErrorCode() == -444) {
1:                 SqlException newException = new SqlException(agent_.logWriter_,
0:                         "The load module name for the stored procedure on the server is not found. ");
1:                 newException.setNextException(e);
1:                 throw newException;
1:             } else {
1:                 throw e;
1:             }
1:         }
1:     }
1: 
0:     public java.sql.Connection getConnection() throws SqlException {
1:         checkForClosedConnection();
1:         return connection_;
1:     }
0:     public boolean supportsNamedParameters() throws SqlException {
1:         checkForClosedConnection();
1:         return false;
0:     public boolean supportsMultipleOpenResults() throws SqlException {
1:         checkForClosedConnection();
0:     public boolean supportsGetGeneratedKeys() throws SqlException {
1:         checkForClosedConnection();
1:         return false;
1: 
0:     public java.sql.ResultSet getSuperTypes(String catalog,
1:                                             String schemaPattern,
0:                                             String typeNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getSuperTypes", catalog, schemaPattern, typeNamePattern);
1:             }
0:             return getSuperTypesX();
1:         }
1:     }
1: 
0:     private ResultSet getSuperTypesX() throws SqlException {
1:         checkForClosedConnection();
1:         String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
1:                 "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
1:                 "VARCHAR('', 128) AS TYPE_NAME," +
1:                 "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_CAT," +
1:                 "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_SCHEM," +
1:                 "VARCHAR('', 128) AS SUPERTYPE_NAME " +
1:                 "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR ";
0:         PreparedStatement ps = connection_.prepareDynamicCatalogQuery(sql);
0:         lastGetSuperTypesResultSet_ = ps.executeQueryX();
0:         return lastGetSuperTypesResultSet_;
1:     }
1: 
0:     public java.sql.ResultSet getSuperTables(String catalog,
1:                                              String schemaPattern,
1:                                              String tableNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getSuperTables", catalog, schemaPattern, tableNamePattern);
1:             }
0:             return getSuperTablesX();
1:         }
1:     }
1: 
0:     private ResultSet getSuperTablesX() throws SqlException {
1:         checkForClosedConnection();
0:         java.lang.String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TABLE_CAT," +
1:                 "CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM," +
1:                 "VARCHAR('', 128) AS TABLE_NAME," +
1:                 "VARCHAR('', 128) AS SUPERTABLE_NAME FROM SYSIBM.SYSDUMMY1 " +
1:                 "WHERE 1=0 WITH UR";
0:         PreparedStatement ps = connection_.prepareDynamicCatalogQuery(sql);
0:         lastGetSuperTablesResultSet_ = ps.executeQueryX();
0:         return lastGetSuperTablesResultSet_;
1:     }
1: 
1: 
0:     public java.sql.ResultSet getAttributes(String catalog,
1:                                             String schemaPattern,
1:                                             String typeNamePattern,
0:                                             String attributeNamePattern) throws SqlException {
1:         synchronized (connection_) {
0:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getAttributes", catalog, schemaPattern, typeNamePattern, attributeNamePattern);
1:             }
0:             return getAttributesX();
1:         }
1:     }
1: 
0:     private ResultSet getAttributesX() throws SqlException {
1:         checkForClosedConnection();
0:         java.lang.String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
1:                 "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
1:                 "VARCHAR('', 128) AS TYPE_NAME," +
1:                 "VARCHAR('',128) AS ATTR_NAME," +
0:                 "SMALLINT(0) AS DATA_TYPE," +
1:                 "VARCHAR('',129) AS ATTR_TYPE_NAME," +
1:                 "0 AS ATTR_SIZE," +
1:                 "0 AS DECIMAL_DIGITS," +
1:                 "0 AS NUM_PREC_RADIX," +
1:                 "2 AS NULLABLE," +
1:                 "CAST(NULL AS VARCHAR(254)) AS REMARKS," +
1:                 "CAST(NULL AS VARCHAR(128)) AS ATTR_DEF," +
1:                 "0 AS SQL_DATA_TYPE," +
1:                 "0 AS SQL_DATETIME_SUB," +
1:                 "0 AS CHAR_OCTET_LENGTH," +
1:                 "0 AS ORDINAL_POSITION," +
1:                 "VARCHAR('',128) AS IS_NULLABLE," +
1:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_CATALOG," +
1:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_SCHEMA," +
1:                 "CAST(NULL AS VARCHAR(128)) AS SCOPE_TABLE," +
1:                 "CAST(NULL AS SMALLINT) AS SOURCE_DATA_TYPE " +
1:                 "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR";
0:         PreparedStatement ps = connection_.prepareDynamicCatalogQuery(sql);
0:         lastGetAttrResultSet_ = ps.executeQueryX();
0:         return lastGetAttrResultSet_;
1:     }
1: 
0:     public boolean supportsResultSetHoldability(int holdability) throws SqlException {
1:         checkForClosedConnection();
1:         return true;
1:     }
1: 
0:     public int getResultSetHoldability() throws SqlException {
1:         checkForClosedConnection();
0:         return java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:     }
1: 
0:     public int getDatabaseMajorVersion() throws SqlException {
1:         checkForClosedConnection();
1:         return productLevel_.versionLevel_;
1:     }
1: 
0:     public int getDatabaseMinorVersion() throws SqlException {
1:         checkForClosedConnection();
1:         return productLevel_.releaseLevel_;
1:     }
1: 
0:     public int getJDBCMajorVersion() throws SqlException {
1:         checkForClosedConnection();
0:         return 3;
1:     }
1: 
0:     public int getJDBCMinorVersion() throws SqlException {
1:         checkForClosedConnection();
0:         return 0;
1:     }
1: 
0:     public int getSQLStateType() throws SqlException {
1:         checkForClosedConnection();
1:         return sqlStateSQL99;
1:     }
1: 
0:     public boolean locatorsUpdateCopy() throws SqlException {
1:         checkForClosedConnection();
1:         return false;
1:     }
1: 
0:     public boolean supportsStatementPooling() throws SqlException {
1:         checkForClosedConnection();
1:         return false;
1:     }
1: 
0:     //--------------------Abstract material layer call-down methods-----------------
1: 
0:     // Compute feature set based on release
0:     abstract protected void computeFeatureSet_();
1: 
1:     //------------helper methods for meta data info call methods------------------
1: 
1: 
0:     private boolean getMetaDataInfoBoolean(int infoCallIndex) throws SqlException {
0:         if (metaDataInfoIsCached_) {
0:             return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1:         }
0:         metaDataInfoCall();
0:         return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1:     }
1: 
0:     private int getMetaDataInfoInt(int infoCallIndex) throws SqlException {
0:         if (metaDataInfoIsCached_) {
1:             return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:         }
0:         metaDataInfoCall();
1:         return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:     }
1: 
0:     private String getMetaDataInfoString(int infoCallIndex) throws SqlException {
0:         if (metaDataInfoIsCached_) {
1:             return (String) metaDataInfoCache_[infoCallIndex];
1:         }
0:         metaDataInfoCall();
1:         return (String) metaDataInfoCache_[infoCallIndex];
1:     }
1: 
0:     private boolean getMetaDataInfoBooleanWithType(int infoCallIndex, int type) throws SqlException {
1:         // Stored Procedure will return a String containing a
1:         // comma seperated list of all the supported result Set types
1:         // not throwing any exception right now even if the the type is wrong as per the spec
0:         String returnedFromSP = null;
0:         if (metaDataInfoIsCached_) {
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         } else {
0:             metaDataInfoCall();
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         }
0:         java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ",");
0:             if ((new Integer(st.nextToken())).intValue() == type) {
1:                 return true;
1:             }
1: 
0:     private boolean getMetaDataInfoInt_SupportsResultSetConcurrency(int infoCallIndex, int type, int concurrency) throws SqlException {
0:         // The stored procured will return a String containg a list of concurrency and list of resultSet types which support
0:         // a perticular concurrency
0:         // For eg. if the database supports concurrency CONCUR_READ_ONLY(1007) in ResultSet type TYPE_FORWARD_ONLY(1003),
0:         // TYPE_SCROLL_INSENSITIVE(1004), TYPE_SCROLL_SENSITIVE(1005) and
0:         // supports concurrency CONCUR_UPDATBLE(1008) in resultSet TYPE_SCROLL_SENSITIVE(1005)
0:         // then stored procedure will return a string "1007,1003,1004,1005;1008,1005"
0:         // see how concurrency and supported result set types are seperated by ";"
0:         String returnedFromSP = null;
0:         if (metaDataInfoIsCached_) {
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         } else {
0:             metaDataInfoCall();
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         }
0:         java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ";");
0:             java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(), ",");
0:             if ((new Integer(stForType.nextToken())).intValue() == concurrency) {
0:                 while (st.hasMoreTokens()) {
0:                     if ((new Integer(st.nextToken())).intValue() == type) {
1:                         return true;
1:                     }
1:                 }
1:                 return false;
1:             }
0:     private boolean getMetaDataInfoBoolean_supportsConvert(int infoCallIndex, int fromType, int toType) throws SqlException {
1:         // The Stored procedure will return a String contain a list of all the valid conversions it support
1:         // For eg. If the database conversion from char(1) to date(91), time(92) and
1:         // Decimal(3) to char(1) ,double(8)
1:         // then StoredProcedure string will return "1,91,92;3,1,8"
1:         // see how fromTypes are seperated by ";"
0:         String returnedFromSP = null;
0:         if (metaDataInfoIsCached_) {
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         } else {
0:             metaDataInfoCall();
0:             returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:         }
0:         java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP, ";");
0:         while (st.hasMoreTokens()) {
0:             java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(), ",");
0:             if ((new Integer(stForType.nextToken())).intValue() == fromType) {
0:                 while (st.hasMoreTokens()) {
0:                     if ((new Integer(st.nextToken())).intValue() == toType) {
1:                         return true;
1:                     }
1:                 }
1:                 return false;
1:             }
1:         }
1:         return false;
1:     // We synchronize at this level so that we don't have to synchronize all
1:     // the meta data info methods.  If we just return hardwired answers we don't
1:     // need to synchronize at the higher level.
1:     private void metaDataInfoCall() throws SqlException {
1:         synchronized (connection_) {
0:             ResultSet rs;
1:             // These remote calls return a result set containing a single row.
1:             // Each column in the row corresponds to a particular get meta data info
1:             // method.
0:             PreparedStatement ps = prepareMetaDataQuery("SYSIBM.MetaData()");
0:             rs = (ResultSet) ps.executeQueryX();
1:             rs.nextX();
0:             int ColumnCount = ((ColumnMetaData) rs.getMetaDataX()).getColumnCount();
1:             for (int infoCallIndex = 0;
1:                  (infoCallIndex < ColumnCount && infoCallIndex < metaDataInfoCache_.length);
1:                  infoCallIndex++) {
1:                 metaDataInfoCache_[infoCallIndex] = rs.getObjectX(infoCallIndex + 1);
1:             }
1:             metaDataInfoIsCached_ = true;
1:             rs.closeX();
1:         }
1: 
1: 
1:     //----------------------------helper methods----------------------------------
1: 
1: 
0:     private PreparedStatement prepareMetaDataQuery(String cmd) throws SqlException {
0:         PreparedStatement ps;
1: 
0:         ps = (org.apache.derby.client.am.PreparedStatement)
1:                 connection_.prepareStatementX("CALL " + cmd,
0:                         java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                         java.sql.ResultSet.CONCUR_READ_ONLY,
0:                         connection_.resultSetHoldability_,
0:                         java.sql.Statement.NO_GENERATED_KEYS,
0:                         null);
1:         return ps;
1: 
0:     private void checkForClosedConnection() throws SqlException {
1:         if (connection_.isClosedX()) {
1:             agent_.checkForDeferredExceptions();
0:             throw new SqlException(agent_.logWriter_, "DatabaseMetaData method called after connection was closed");
1:         } else {
1:             agent_.checkForDeferredExceptions();
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derby.client.am.DatabaseMetaData
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: 
1: package org.apache.derby.client.am;
1: 
0: import org.apache.derby.jdbc.ClientDataSource;
1: 
1: // Note:
1: //   Tag members using the strictest visibility.
1: // Note:
1: //   Mark methods synchronized if and only if they update object state and are public.
1: // Not yet done:
1: //   Application heap data should be copied for shiraz.
1: //   Save for future pass to avoid clutter during development.
1: // Not yet done:
1: //   Apply meaning-preserving program transformations for performance,
1: //   including the replacement of slow ADTs with faster unsynchronized ADTs.
1: //   Save for future pass to avoid clutter during development.
1: // Not yet done:
1: //   Assign an ErrorKey, ResourceKey, and Resource for each throw statement.
1: //   Save for future pass to avoid maintenance during development.
1: 
0: public abstract class DatabaseMetaData implements java.sql.DatabaseMetaData
0: {
0:   //----------------------------- constants  -----------------------------------
1: 
0:   private final static short SQL_BEST_ROWID = 1;
0:   private final static short SQL_ROWVER = 2;
1: 
0:   private final static short SQL_INDEX_UNIQUE = 0;
0:   private final static short SQL_INDEX_ALL = 1;
1: 
0:   //---------------------navigational members-----------------------------------
1: 
0:   protected Agent agent_;
0:   protected Connection connection_;
1: 
0:   //-----------------------------state------------------------------------------
1: 
0:   private final static int numberOfMetaDataInfoMethods__ = 108;
0:   private Object[] metaDataInfoCache_ = new Object[numberOfMetaDataInfoMethods__];
0:   private boolean metaDataInfoIsCached_ = false;
1: 
0:   public ProductLevel productLevel_;
1: 
0:   private ResultSet lastGetColumnPrivilegesResultSet_ = null;
0:   private ResultSet lastGetColumnsResultSet_ = null;
0:   private ResultSet lastGetForeignKeysResultSet_ = null;
0:   private ResultSet lastGetPrimaryKeysResultSet_ = null;
0:   private ResultSet lastGetProcedureColumnsResultSet_ = null;
0:   private ResultSet lastGetProceduresResultSet_ = null;
0:   private ResultSet lastGetSpecialColumnsResultSet_ = null;
0:   private ResultSet lastGetStatisticsResultSet_ = null;
0:   private ResultSet lastGetTablePrivilegesResultSet_ = null;
0:   private ResultSet lastGetTablesResultSet_ = null;
0:   private ResultSet lastGetUDTsResultSet_ = null;
0:   private ResultSet lastGetTypeInfoResultSet_ = null;
0:   private ResultSet lastGetAttrResultSet_ = null;
0:   private ResultSet lastGetSuperTypesResultSet_ = null;
0:   private ResultSet lastGetSuperTablesResultSet_ = null;
1: 
0:   public boolean useServerXAState_ = true;
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   protected DatabaseMetaData (Agent agent, Connection connection, ProductLevel productLevel)
0:   {
0:     agent_ = agent;
0:     connection_ = connection;
0:     productLevel_ = productLevel;
0:     computeFeatureSet_();
0:     if( connection.isXAConnection() )
0:     {
0:       connection.xaHostVersion_ = productLevel_.versionLevel_;
1:     }
1:   }
1: 
0:   // ---------------------------jdbc 1------------------------------------------
1: 
0:   //----------------------------------------------------------------------
0:   // First, a variety of minor information about the target database.
1: 
0:   private final static int allProceduresAreCallable__ = 0;
0:   public boolean allProceduresAreCallable () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (allProceduresAreCallable__);
1:   }
1: 
0:   private final static int allTablesAreSelectable__ = 1;
0:   public boolean allTablesAreSelectable () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (allTablesAreSelectable__);
1:   }
1: 
0:   private final static int nullsAreSortedHigh__ = 2;
0:   public boolean nullsAreSortedHigh () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (nullsAreSortedHigh__);
1:   }
1: 
0:   private final static int nullsAreSortedLow__ = 3;
0:   public boolean nullsAreSortedLow () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (nullsAreSortedLow__);
1:   }
1: 
0:   private final static int nullsAreSortedAtStart__ = 4;
0:   public boolean nullsAreSortedAtStart () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (nullsAreSortedAtStart__);
1:   }
1: 
0:   private final static int nullsAreSortedAtEnd__ = 5;
0:   public boolean nullsAreSortedAtEnd () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (nullsAreSortedAtEnd__);
1:   }
1: 
0:   private final static int usesLocalFiles__ = 6;
0:   public boolean usesLocalFiles () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (usesLocalFiles__);
1:   }
1: 
0:   private final static int usesLocalFilePerTable__ = 7;
0:   public boolean usesLocalFilePerTable () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (usesLocalFilePerTable__);
1:   }
1: 
0:   private final static int storesUpperCaseIdentifiers__ = 8;
0:   public boolean storesUpperCaseIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesUpperCaseIdentifiers__);
1:   }
1: 
1: 
0:   private final static int storesLowerCaseIdentifiers__ = 9;
0:   public boolean storesLowerCaseIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesLowerCaseIdentifiers__);
1:   }
1: 
0:   private final static int storesMixedCaseIdentifiers__ = 10;
0:   public boolean storesMixedCaseIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesMixedCaseIdentifiers__);
1:   }
1: 
0:   private final static int storesUpperCaseQuotedIdentifiers__ = 11;
0:   public boolean storesUpperCaseQuotedIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesUpperCaseQuotedIdentifiers__);
1:   }
1: 
0:   private final static int storesLowerCaseQuotedIdentifiers__ = 12;
0:   public boolean storesLowerCaseQuotedIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesLowerCaseQuotedIdentifiers__);
1:   }
1: 
0:   private final static int storesMixedCaseQuotedIdentifiers__ = 13;
0:   public boolean storesMixedCaseQuotedIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (storesMixedCaseQuotedIdentifiers__);
1:   }
1: 
0:   private final static int getSQLKeywords__ = 14;
0:   public String getSQLKeywords () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getSQLKeywords__);
1:   }
1: 
0:   private final static int getNumericFunctions__ = 15;
0:   public String getNumericFunctions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getNumericFunctions__);
1:   }
1: 
0:   private final static int getStringFunctions__ = 16;
0:   public String getStringFunctions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getStringFunctions__);
1:   }
1: 
0:   private final static int getSystemFunctions__ = 17;
0:   public String getSystemFunctions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getSystemFunctions__);
1:   }
1: 
0:   private final static int getTimeDateFunctions__ = 18;
0:   public String getTimeDateFunctions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getTimeDateFunctions__);
1:   }
1: 
0:   private final static int getSearchStringEscape__ = 19;
0:   public String getSearchStringEscape () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getSearchStringEscape__);
1:   }
0:   private final static int getExtraNameCharacters__ = 20;
0:   public String getExtraNameCharacters () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getExtraNameCharacters__);
1:   }
1: 
0:   private final static int supportsAlterTableWithAddColumn__ = 21;
0:   public boolean supportsAlterTableWithAddColumn () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (supportsAlterTableWithAddColumn__);
1:   }
1: 
0:   private final static int supportsAlterTableWithDropColumn__ = 22;
0:   public boolean supportsAlterTableWithDropColumn () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsAlterTableWithDropColumn__);
1:   }
1: 
0:   private final static int supportsConvert__ = 23;
0:   public boolean supportsConvert () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsConvert__);
1:   }
1: 
0:   private final static int supportsConvertType__ = 24;
0:   public boolean supportsConvert (int fromType, int toType) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean_supportsConvert (supportsConvertType__, fromType, toType);
1:   }
1: 
0:   private final static int supportsDifferentTableCorrelationNames__ = 25;
0:   public boolean supportsDifferentTableCorrelationNames () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (supportsDifferentTableCorrelationNames__);
1:   }
1: 
0:   private final static int supportsExpressionsInOrderBy__ = 26;
0:   public boolean supportsExpressionsInOrderBy () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsExpressionsInOrderBy__);
1:   }
1: 
0:   private final static int supportsOrderByUnrelated__ = 27;
0:   public boolean supportsOrderByUnrelated () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOrderByUnrelated__);
1:   }
1: 
0:   private final static int supportsGroupBy__ = 28;
0:   public boolean supportsGroupBy () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsGroupBy__);
1:   }
1: 
0:   private final static int supportsGroupByUnrelated__ = 29;
0:   public boolean supportsGroupByUnrelated () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsGroupByUnrelated__);
1:   }
1: 
0:   private final static int supportsGroupByBeyondSelect__ = 30;
0:   public boolean supportsGroupByBeyondSelect () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsGroupByBeyondSelect__);
1:   }
1: 
0:   private final static int supportsMultipleResultSets__ = 31;
0:   public boolean supportsMultipleResultSets () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsMultipleResultSets__);
1:   }
1: 
0:   private final static int supportsMultipleTransactions__ = 32;
0:   public boolean supportsMultipleTransactions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsMultipleTransactions__);
1:   }
1: 
0:   private final static int supportsCoreSQLGrammar__ = 33;
0:   public boolean supportsCoreSQLGrammar () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCoreSQLGrammar__);
1:   }
1: 
0:   private final static int supportsExtendedSQLGrammar__ = 34;
0:   public boolean supportsExtendedSQLGrammar () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsExtendedSQLGrammar__);
1:   }
1: 
0:   private final static int supportsANSI92IntermediateSQL__ = 35;
0:   public boolean supportsANSI92IntermediateSQL () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsANSI92IntermediateSQL__);
1:   }
1: 
0:   private final static int supportsANSI92FullSQL__ = 36;
0:   public boolean supportsANSI92FullSQL () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsANSI92FullSQL__);
1:   }
1: 
0:   private final static int supportsIntegrityEnhancementFacility__ = 37;
0:   public boolean supportsIntegrityEnhancementFacility () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsIntegrityEnhancementFacility__);
1:   }
1: 
0:   private final static int supportsOuterJoins__ = 38;
0:   public boolean supportsOuterJoins () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOuterJoins__);
1:   }
1: 
0:   private final static int supportsFullOuterJoins__ = 39;
0:   public boolean supportsFullOuterJoins () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsFullOuterJoins__);
1:   }
1: 
0:   private final static int supportsLimitedOuterJoins__ = 40;
0:   public boolean supportsLimitedOuterJoins () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsLimitedOuterJoins__);
1:   }
1: 
0:   private final static int getSchemaTerm__ = 41;
0:   public String getSchemaTerm () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getSchemaTerm__);
1:   }
1: 
0:   private final static int getProcedureTerm__ = 42;
0:   public String getProcedureTerm () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getProcedureTerm__);
1:   }
1: 
0:   private final static int getCatalogTerm__ = 43;
0:   public String getCatalogTerm () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getCatalogTerm__);
1:   }
1: 
0:   private final static int isCatalogAtStart__ = 44;
0:   public boolean isCatalogAtStart () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (isCatalogAtStart__);
1:   }
1: 
0:   private final static int getCatalogSeparator__ = 45;
0:   public String getCatalogSeparator () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoString (getCatalogSeparator__);
1:   }
1: 
0:   private final static int supportsSchemasInDataManipulation__ = 46;
0:   public boolean supportsSchemasInDataManipulation () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSchemasInDataManipulation__);
1:   }
1: 
0:   private final static int supportsSchemasInProcedureCalls__ = 47;
0:   public boolean supportsSchemasInProcedureCalls () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSchemasInProcedureCalls__);
1:   }
1: 
0:   private final static int supportsSchemasInTableDefinitions__ = 48;
0:   public boolean supportsSchemasInTableDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSchemasInTableDefinitions__);
1:   }
1: 
1: 
0:   private final static int supportsSchemasInIndexDefinitions__ = 49;
0:   public boolean supportsSchemasInIndexDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSchemasInIndexDefinitions__);
1:   }
1: 
0:   private final static int supportsSchemasInPrivilegeDefinitions__ = 50;
0:   public boolean supportsSchemasInPrivilegeDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSchemasInPrivilegeDefinitions__);
1:   }
1: 
0:   private final static int supportsCatalogsInDataManipulation__ = 51;
0:   public boolean supportsCatalogsInDataManipulation () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCatalogsInDataManipulation__);
1:   }
1: 
0:   private final static int supportsCatalogsInProcedureCalls__ = 52;
0:   public boolean supportsCatalogsInProcedureCalls () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCatalogsInProcedureCalls__);
1:   }
1: 
0:   private final static int supportsCatalogsInTableDefinitions__ = 53;
0:   public boolean supportsCatalogsInTableDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCatalogsInTableDefinitions__);
1:   }
1: 
0:   private final static int supportsCatalogsInIndexDefinitions__ = 54;
0:   public boolean supportsCatalogsInIndexDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCatalogsInIndexDefinitions__);
1:   }
1: 
0:   private final static int supportsCatalogsInPrivilegeDefinitions__ = 55;
0:   public boolean supportsCatalogsInPrivilegeDefinitions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsCatalogsInPrivilegeDefinitions__);
1:   }
1: 
0:   private final static int supportsPositionedDelete__ = 56;
0:   public boolean supportsPositionedDelete () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsPositionedDelete__);
1:   }
1: 
1: 
0:   private final static int supportsPositionedUpdate__ = 57;
0:   public boolean supportsPositionedUpdate () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsPositionedUpdate__);
1:   }
1: 
0:   private final static int supportsSelectForUpdate__ = 58;
0:   public boolean supportsSelectForUpdate () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSelectForUpdate__);
1:   }
1: 
0:   private final static int supportsStoredProcedures__ = 59;
0:   public boolean supportsStoredProcedures () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsStoredProcedures__);
1:   }
1: 
0:   private final static int supportsSubqueriesInComparisons__ = 60;
0:   public boolean supportsSubqueriesInComparisons () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsSubqueriesInComparisons__);
1:   }
1: 
0:   private final static int supportsUnion__ = 61;
0:   public boolean supportsUnion () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsUnion__);
1:   }
1: 
0:   private final static int supportsUnionAll__ = 62;
0:   public boolean supportsUnionAll () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsUnionAll__);
1:   }
1: 
0:   private final static int supportsOpenCursorsAcrossCommit__ = 63;
0:   public boolean supportsOpenCursorsAcrossCommit () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOpenCursorsAcrossCommit__);
1:   }
1: 
0:   private final static int supportsOpenCursorsAcrossRollback__ = 64;
0:   public boolean supportsOpenCursorsAcrossRollback () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOpenCursorsAcrossRollback__);
1:   }
1: 
0:   private final static int supportsOpenStatementsAcrossCommit__ = 65;
0:   public boolean supportsOpenStatementsAcrossCommit () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOpenStatementsAcrossCommit__);
1:   }
1: 
1: 
0:   private final static int supportsOpenStatementsAcrossRollback__ = 66;
0:   public boolean supportsOpenStatementsAcrossRollback () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsOpenStatementsAcrossRollback__);
1:   }
0:   //----------------------------------------------------------------------
0:   // The following group of methods exposes various limitations
0:   // based on the target database with the current driver.
0:   // Unless otherwise specified, a result of zero means there is no
0:   // limit, or the limit is not known.
0:   private final static int getMaxBinaryLiteralLength__ = 67;
0:   public int getMaxBinaryLiteralLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt (getMaxBinaryLiteralLength__);
1:   }
1: 
0:   private final static int getMaxCharLiteralLength__ = 68;
0:   public int getMaxCharLiteralLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxCharLiteralLength__);
1:   }
0:   private final static int getMaxColumnNameLength__ = 69;
1: 
0:   public int getMaxColumnNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnNameLength__);
1:   }
1: 
0:   private final static int getMaxColumnsInGroupBy__ = 70;
0:   public int getMaxColumnsInGroupBy () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnsInGroupBy__);
1:   }
0:   private final static int getMaxColumnsInIndex__ = 71;
0:   public int getMaxColumnsInIndex () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnsInIndex__);
1:   }
0:   private final static int getMaxColumnsInOrderBy__ = 72;
0:   public int getMaxColumnsInOrderBy () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnsInOrderBy__);
1:   }
0:   private final static int getMaxColumnsInSelect__ = 73;
0:   public int getMaxColumnsInSelect () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnsInSelect__);
1:   }
0:   private final static int getMaxColumnsInTable__ = 74;
0:   public int getMaxColumnsInTable () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxColumnsInTable__);
1:   }
1: 
0:   private final static int getMaxConnections__ = 75;
0:   public int getMaxConnections () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxConnections__);
1:   }
0:   private final static int getMaxCursorNameLength__ = 76;
0:   public int getMaxCursorNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxCursorNameLength__);
1:   }
0:   private final static int getMaxIndexLength__ = 77;
0:   public int getMaxIndexLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxIndexLength__);
1:   }
0:   private final static int getMaxSchemaNameLength__ = 78;
0:   public int getMaxSchemaNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxSchemaNameLength__);
1:   }
0:   private final static int getMaxProcedureNameLength__ = 79;
0:   public int getMaxProcedureNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxProcedureNameLength__);
1:   }
0:   private final static int getMaxCatalogNameLength__ = 80;
0:   public int getMaxCatalogNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxCatalogNameLength__);
1:   }
1: 
0:   private final static int getMaxRowSize__ = 81;
0:   public int getMaxRowSize () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxRowSize__);
1:   }
0:   private final static int doesMaxRowSizeIncludeBlobs__ = 82;
0:   public boolean doesMaxRowSizeIncludeBlobs () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(doesMaxRowSizeIncludeBlobs__);
1:   }
0:   private final static int getMaxStatementLength__ = 83;
0:   public int getMaxStatementLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxStatementLength__);
1:   }
0:   private final static int getMaxStatements__ = 84;
0:   public int getMaxStatements () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxStatements__);
1:   }
0:   private final static int getMaxTableNameLength__ = 85;
0:   public int getMaxTableNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxTableNameLength__);
1:   }
0:   private final static int getMaxTablesInSelect__ = 86;
0:   public int getMaxTablesInSelect () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxTablesInSelect__);
1:   }
0:   private final static int getMaxUserNameLength__ = 87;
0:   public int getMaxUserNameLength () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getMaxUserNameLength__);
1:   }
1: 
0:   private final static int getDefaultTransactionIsolation__ = 88;
0:   public int getDefaultTransactionIsolation () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt(getDefaultTransactionIsolation__);
1:   }
1: 
0:   private final static int supportsTransactions__ = 89;
0:   public boolean supportsTransactions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsTransactions__);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all supported levels
0:   private final static int supportsTransactionIsolationLevel__ = 90;
0:   public boolean supportsTransactionIsolationLevel (int level) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (supportsTransactionIsolationLevel__, level);
1:   }
1: 
1: 
0:   private final static int supportsDataDefinitionAndDataManipulationTransactions__ = 91;
0:   public boolean supportsDataDefinitionAndDataManipulationTransactions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsDataDefinitionAndDataManipulationTransactions__);
1:   }
1: 
0:   private final static int supportsDataManipulationTransactionsOnly__ = 92;
0:   public boolean supportsDataManipulationTransactionsOnly () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(supportsDataManipulationTransactionsOnly__);
1:   }
0:   private final static int dataDefinitionCausesTransactionCommit__ = 93;
0:   public boolean dataDefinitionCausesTransactionCommit () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(dataDefinitionCausesTransactionCommit__);
1:   }
1: 
0:   private final static int dataDefinitionIgnoredInTransactions__ = 94;
0:   public boolean dataDefinitionIgnoredInTransactions () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean(dataDefinitionIgnoredInTransactions__);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported resultSet types
0:   private final static int supportsResultSetType__ = 95;
0:   public boolean supportsResultSetType (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (supportsResultSetType__, type);
1:   }
1: 
0:   private final static int supportsResultSetConcurrency__ = 96;
0:   public boolean supportsResultSetConcurrency  (int type, int concurrency) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoInt_SupportsResultSetConcurrency (supportsResultSetConcurrency__, type, concurrency);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int ownUpdatesAreVisible__ = 97;
0:   public boolean ownUpdatesAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (ownUpdatesAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int ownDeletesAreVisible__ = 98;
0:   public boolean ownDeletesAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (ownDeletesAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list all the supported result Set types
0:   private final static int ownInsertsAreVisible__ = 99;
0:   public boolean ownInsertsAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (ownInsertsAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int othersUpdatesAreVisible__ = 100;
0:   public boolean othersUpdatesAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (othersUpdatesAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int othersDeletesAreVisible__ = 101;
0:   public boolean othersDeletesAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (othersDeletesAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int othersInsertsAreVisible__ = 102;
0:   public boolean othersInsertsAreVisible (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (othersInsertsAreVisible__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int updatesAreDetected__ = 103;
0:   public boolean updatesAreDetected (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (updatesAreDetected__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int deletesAreDetected__ = 104;
0:   public boolean deletesAreDetected (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (deletesAreDetected__, type);
1:   }
1: 
0:   // Stored Procedure will return a String containing a
0:   // comma seperated list of all the supported result Set types
0:   private final static int insertsAreDetected__ = 105;
0:   public boolean insertsAreDetected (int type) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBooleanWithType (insertsAreDetected__, type);
1:   }
1: 
0:   private final static int supportsBatchUpdates__ = 106;
0:   public boolean supportsBatchUpdates () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getMetaDataInfoBoolean (supportsBatchUpdates__);
1:   }
1: 
0:   public boolean supportsSavepoints () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     if (productLevel_.greaterThanOrEqualTo(5,2,0))
0:         return true;
1: 
0:     return false;
1:   }
1: 
0:   // start tagging all abstract methods with an underscore like this !!
0:   abstract public String getURL_ () throws SqlException;
0:   public String getURL () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return getURL_();
1:   }
1: 
0:   public String getUserName () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return connection_.user_;
1:   }
1: 
0:   public boolean isReadOnly () throws SqlException
0:   {
0:     return false;
1:   }
1: 
0:   public String getDatabaseProductName () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return productLevel_.databaseProductName_;
1:   }
1: 
0:   public String getDatabaseProductVersion () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return productLevel_.databaseProductVersion_;
1: 
1:   }
1: 
0:   public String getDriverName () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return Configuration.dncDriverName;
1:   }
1: 
0:   public String getDriverVersion () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return Version.getDriverVersion();
1:   }
1: 
0:   // JDBC signature also does not throw SqlException, so we don't check for closed connection.
0:   public int getDriverMajorVersion ()
0:   {
0:     return Version.getMajorVersion();
1:   }
1: 
0:   // JDBC signature also does not throw SqlException, so we don't check for closed connection.
0:   public int getDriverMinorVersion ()
0:   {
0:     return Version.getMinorVersion();
1:   }
1: 
0:   //All JDBC Drivers must return false for this method. For this reason we choose
0:   //to return FALSE
0:   public boolean supportsMixedCaseIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return false;
1:   }
1: 
0:   public boolean supportsMixedCaseQuotedIdentifiers () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public String getIdentifierQuoteString () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return "\"";
1:   }
1: 
0:   public boolean supportsColumnAliasing () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean nullPlusNonNullIsNull () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsTableCorrelationNames () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsLikeEscapeClause () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsNonNullableColumns () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsMinimumSQLGrammar () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsANSI92EntryLevelSQL () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsSubqueriesInExists () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsSubqueriesInIns () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsSubqueriesInQuantifieds () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsCorrelatedSubqueries () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
1: 
0:   //------------------------catalog query methods follow--------------------------------------------
1: 
0:   // call stored procedure SQLProcedures
0:   // SYSIBM.SQLProcedures(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              ProcName    varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getProcedures (String catalog,
1:                                            String schemaPattern,
0:                                            String procedureNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getProcedures", catalog, schemaPattern, procedureNamePattern);
0:       return getProceduresX (catalog, schemaPattern, procedureNamePattern);
1:     }
1:   }
1: 
1: 
0:   private ResultSet getProceduresX (String catalog,
1:                                     String schemaPattern,
0:                                     String procedureNamePattern) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPROCEDURES(?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schemaPattern);
0:     cs.setStringX (3, procedureNamePattern);
0:     cs.setStringX (4, getOptions());
0:     lastGetProceduresResultSet_ = executeCatalogQuery (cs);
0:     return lastGetProceduresResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLProcedureCols
0:   // SYSIBM.SQLProcedureCols(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              ProcName    varchar(128),
0:   //              ParamName   varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getProcedureColumns (String catalog,
1:                                                  String schemaPattern,
0:                                                  String procedureNamePattern,
0:                                                  String columnNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getProcedureColumns", catalog, schemaPattern, procedureNamePattern, columnNamePattern);
0:       return getProcedureColumnsX (catalog, schemaPattern, procedureNamePattern, columnNamePattern);
1:     }
1:   }
1: 
0:   private ResultSet getProcedureColumnsX (String catalog,
1:                                           String schemaPattern,
0:                                           String procedureNamePattern,
0:                                           String columnNamePattern) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPROCEDURECOLS(?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schemaPattern);
0:     cs.setStringX (3, procedureNamePattern);
0:     cs.setStringX (4, columnNamePattern);
0:     cs.setStringX (5, getOptions());
0:     lastGetProcedureColumnsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetProcedureColumnsResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLTables
0:   // SYSIBM.SQLTables(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              TaleType    varchar(4000),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getTables (String catalog,
1:                                        String schemaPattern,
1:                                        String tableNamePattern,
0:                                        String types[]) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTables", catalog, schemaPattern, tableNamePattern, types);
0:       return getTablesX (catalog, schemaPattern, tableNamePattern, types);
1:     }
1:   }
1: 
0:   private ResultSet getTablesX (String catalog,
1:                                 String schemaPattern,
1:                                 String tableNamePattern,
0:                                 String types[]) throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     PreparedStatement cs = prepareMetaDataQuery ("SYSIBM.SQLTABLES(?,?,?,?,?)");
1: 
0:     if (catalog == null) cs.setNullX (1, java.sql.Types.VARCHAR);
0:     else cs.setStringX (1, catalog);
1: 
0:     if (schemaPattern == null) cs.setNullX (2, java.sql.Types.VARCHAR);
0:     else cs.setStringX (2, schemaPattern);
1: 
0:     if (tableNamePattern == null) cs.setNullX (3, java.sql.Types.VARCHAR);
0:     else cs.setStringX (3, tableNamePattern);
1: 
0:     String tableTypes = new String();
0:     int i=0;
0:     if (types == null)
0:       cs.setNullX (4,java.sql.Types.VARCHAR);
0:     else if (types.length == 1 && (types[0].trim()).equals("%"))
0:       cs.setStringX (4, types[0]);
0:     else {
0:       while (i < types.length) {
0:         if (i>0) tableTypes = tableTypes.concat (",");
0:           tableTypes = tableTypes.concat ("'" + types[i] + "'");
0:         i++;
1:       }
0:       cs.setStringX (4, tableTypes );
1:     }
0:     cs.setStringX (5, getOptions());
0:     lastGetTablesResultSet_ = executeCatalogQuery (cs);
0:     return lastGetTablesResultSet_;
1:   }
1: 
0:   // call stored procedure SQLTables
0:   // SYSIBM.SQLTables(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              TaleType    varchar(4000),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getSchemas () throws SqlException
0:   {
0:     synchronized (connection_) {
0:        if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getSchemas");
0:        return getSchemasX();
1:     }
1:   }
1: 
0:   private ResultSet getSchemasX () throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery ("SYSIBM.SQLTABLES('', '', '', '', 'GETSCHEMAS=1')");
0:     return (ResultSet) cs.executeQueryX();
1:   }
1: 
1: 
0:   // DERBY does not have the notion of a catalog, so we return a result set with no rows.
0:   public java.sql.ResultSet getCatalogs () throws SqlException
0:   {
0:     synchronized (connection_) {
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getCatalogs");
0:         return getCatalogsX();
1:     }
1:   }
1: 
0:   private ResultSet getCatalogsX () throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     PreparedStatement cs = prepareMetaDataQuery ("SYSIBM.SQLTABLES('', '', '', '', 'GETCATALOGS=1')");
0:     return (ResultSet) cs.executeQueryX();
1:   }
1: 
0:   // call stored procedure SQLTables
0:   // SYSIBM.SQLTables(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              TableType   varchar(4000),
0:   //              Options     varchar(4000))
0:   public java.sql.ResultSet getTableTypes () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTableTypes");
0:       return getTableTypesX();
1:     }
1:   }
1: 
0:   private ResultSet getTableTypesX () throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = null;
0:     cs = prepareMetaDataQuery("SYSIBM.SQLTABLES(?,?,?,?,?)");
1: 
0:     cs.setStringX (1, "");
0:     cs.setStringX (2, "");
0:     cs.setStringX (3, "");
0:     cs.setStringX (4, "%");
0:     int cursorHold;
0:     if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:        cursorHold = 1;
0:     else
0:        cursorHold = 0;
0:     cs.setStringX (5, "DATATYPE='JDBC';GETTABLETYPES=1; CURSORHOLD="+cursorHold);
0:     lastGetTablesResultSet_ = executeCatalogQuery (cs);
0:     return lastGetTablesResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLColumns
0:   // SYSIBM.SQLColumns(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              ColumnName  varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getColumns (String catalog,
1:                                         String schemaPattern,
1:                                         String tableNamePattern,
0:                                         String columnNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getColumns", catalog, schemaPattern, tableNamePattern, columnNamePattern);
0:       checkForClosedConnection();
0:       return getColumnsX (catalog, schemaPattern, tableNamePattern, columnNamePattern);
1:     }
1:   }
1: 
0:   private ResultSet getColumnsX (String catalog,
1:                                           String schemaPattern,
1:                                           String tableNamePattern,
0:                                           String columnNamePattern) throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLCOLUMNS(?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schemaPattern);
0:     cs.setStringX (3, tableNamePattern);
0:     cs.setStringX (4, columnNamePattern); //Always null  for JDBC
0:     cs.setStringX (5, getOptions());
0:     lastGetColumnsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetColumnsResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLColumnPrivileges
0:   // SYSIBM.SQLColPrivileges(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              ColumnName  varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getColumnPrivileges (String catalog,
1:                                                  String schema,
1:                                                  String table,
0:                                                  String columnNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getColumnPrivileges", catalog, schema, table, columnNamePattern);
0:       return getColumnPrivilegesX (catalog, schema, table, columnNamePattern);
1:     }
1:   }
1: 
0:   private ResultSet getColumnPrivilegesX (String catalog,
1:                                           String schema,
1:                                           String table,
0:                                           String columnNamePattern) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     // check input params, table and columnNamePattern cannot be null
0:     if ( table == null ) {
0:       throw new SqlException (agent_.logWriter_,  "getColumnPrivileges(): null not allowed for table name" );
1:     }
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLCOLPRIVILEGES(?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schema);
0:     cs.setStringX (3, table);
0:     cs.setStringX (4, columnNamePattern);
0:     cs.setStringX (5, getOptions());
0:     lastGetColumnPrivilegesResultSet_ = executeCatalogQuery (cs);
0:     return lastGetColumnPrivilegesResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLTablePrivileges
0:   // SYSIBM.SQLTablePrivileges(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getTablePrivileges (String catalog,
1:                                                 String schemaPattern,
0:                                                 String tableNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTablePrivileges", catalog, schemaPattern, tableNamePattern);
0:       return getTablePrivilegesX (catalog, schemaPattern, tableNamePattern);
1:     }
1:   }
1: 
0:   private ResultSet getTablePrivilegesX (String catalog,
1:                                          String schemaPattern,
0:                                          String tableNamePattern) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLTABLEPRIVILEGES(?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schemaPattern);
0:     cs.setStringX (3, tableNamePattern);
0:     cs.setStringX (4, getOptions());
0:     lastGetTablePrivilegesResultSet_ = executeCatalogQuery (cs);
0:     return lastGetTablePrivilegesResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure
0:   // SYSIBM.SQLSPECIALCOLUMNS ( IN COLTYPE SMALLINT,
0:   //                            IN CATALOG_NAME VARCHAR(128),
0:   //                            IN SCHEMA_NAME  VARCHAR(128),
0:   //                            IN TABLE_NAME   VARCHAR(128),
0:   //                            IN SCOPE        SMALLINT,
0:   //                            IN NULLABLE     SMALLINT,
0:   //                            IN OPTIONS      VARCHAR(4000) )
0:   //
0:   public java.sql.ResultSet getBestRowIdentifier (String catalog,
1:                                                   String schema,
1:                                                   String table,
0:                                                   int scope,
0:                                                   boolean nullable) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBestRowIdentifier", catalog, schema, table, scope, nullable);
0:       return getBestRowIdentifierX (catalog, schema, table, scope, nullable);
1:     }
1:   }
1: 
0:   private ResultSet getBestRowIdentifierX (String catalog,
1:                                            String schema,
1:                                            String table,
0:                                            int scope,
0:                                            boolean nullable) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     // check input params
0:     //
0:     // validate input table, which can not be null
0:     if (table == null) {
0:       throw new SqlException (agent_.logWriter_,  "getBestRowIdentifier(): null not allowed for table name" );
1:     }
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1: 
0:     cs.setIntX (1, SQL_BEST_ROWID);
0:     cs.setStringX (2, catalog);
0:     cs.setStringX (3, schema);
0:     cs.setStringX (4, table);
0:     cs.setIntX (5, scope);
0:     if (nullable)
0:       cs.setShortX (6, (short) 1);
0:     else
0:       cs.setShortX (6, (short) 0);
0:     cs.setStringX (7, getOptions());
0:     lastGetSpecialColumnsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetSpecialColumnsResultSet_;
1:   }
1: 
1: 
0:   public java.sql.ResultSet getVersionColumns (String catalog,
1:                                                String schema,
0:                                                String table) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getVersionColumns", catalog, schema, table);
0:       return getVersionColumnsX (catalog, schema, table);
1:     }
1:   }
1: 
0:   private ResultSet getVersionColumnsX (String catalog,
1:                                         String schema,
0:                                         String table) throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     // validate input table, which can not be null
0:     if (table == null) {
0:       throw new SqlException (agent_.logWriter_,  "getBestRowIdentifier(): null not allowed for table name" );
1:     }
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSPECIALCOLUMNS(?,?,?,?,?,?,?)");
1: 
0:     cs.setIntX (1, SQL_ROWVER);
0:     cs.setStringX (2, catalog);
0:     cs.setStringX (3, schema);
0:     cs.setStringX (4, table);
0:     cs.setIntX (5, 0);
0:     cs.setShortX (6, (short) 0);
0:     cs.setStringX (7, getOptions());
1: 
0:     lastGetSpecialColumnsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetSpecialColumnsResultSet_;
1:   }
1: 
0:   // call stored procedure SQLPrimaryKeys
0:   // SYSIBM.SQLPrimaryKeys(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getPrimaryKeys (String catalog,
1:                                             String schema,
0:                                             String table) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getPrimaryKeys", catalog, schema, table);
0:       return getPrimaryKeysX (catalog, schema, table);
1:     }
1:   }
1: 
0:   private ResultSet getPrimaryKeysX (String catalog,
1:                                      String schema,
0:                                      String table) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     // validate the input table name
0:     if ( table == null ) {
0:       throw new SqlException (agent_.logWriter_,  "getIndexInfo(): null not allowed for table name" );
1:     }
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLPRIMARYKEYS(?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schema);
0:     cs.setStringX (3, table);
0:     cs.setStringX (4, getOptions());
0:     lastGetPrimaryKeysResultSet_ = executeCatalogQuery (cs);
0:     return lastGetPrimaryKeysResultSet_;
1:   }
1: 
1: 
0:   // call storlastGetPrimaryKeysResultSet_ed procedure SQLForeignKeys
0:   // SYSIBM.SQLForeignKeys(
0:   //              PKCatalogName varchar(128),
0:   //              PKSchemaName  varchar(128),
0:   //              PKTableName   varchar(128),
0:   //              FKCatalogName varchar(128),
0:   //              FKSchemaName  varchar(128),
0:   //              FKTableName   varchar(128),
0:   //              Options       varchar(4000))
0:   //
0:   public java.sql.ResultSet getImportedKeys (String catalog,
1:                                              String schema,
0:                                              String table) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getImportedKeys", catalog, schema, table);
0:       return getImportedKeysX (catalog, schema, table);
1:     }
1:   }
1: 
0:   private ResultSet getImportedKeysX (String catalog,
1:                                       String schema,
0:                                       String table) throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1: 
0:     cs.setStringX (1, "");
0:     cs.setStringX (2, null);
0:     cs.setStringX (3, "");
0:     cs.setStringX (4, catalog);
0:     cs.setStringX (5, schema);
0:     cs.setStringX (6, table);
0:     // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
0:     // As a workaround in getCrossReference(), we'll just "select * where 0=1" when primaryTable==""
0:     if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:       cs.setStringX (7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=1" );
0:     else
0:       cs.setStringX (7, "DATATYPE='JDBC';IMPORTEDKEY=1; CURSORHOLD=0" );
0:     lastGetForeignKeysResultSet_ = executeCatalogQuery (cs);
0:     return lastGetForeignKeysResultSet_;
1:   }
1: 
0:   // call stored procedure SQLForeignKeys
0:   // SYSIBM.SQLForeignKeys(
0:   //              PKCatalogName varchar(128),
0:   //              PKSchemaName  varchar(128),
0:   //              PKTableName   varchar(128),
0:   //              FKCatalogName varchar(128),
0:   //              FKSchemaName  varchar(128),
0:   //              FKTableName   varchar(128),
0:   //              Options       varchar(4000))
0:   //
0:   public java.sql.ResultSet getExportedKeys (String catalog,
1:                                              String schema,
0:                                              String table) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getExportedKeys", catalog, schema, table);
0:       return getExportedKeysX (catalog, schema, table);
1:     }
1:   }
1: 
0:   private ResultSet getExportedKeysX (String catalog,
1:                                       String schema,
0:                                       String table) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schema);
0:     cs.setStringX (3, table);
0:     cs.setStringX (4, "");
0:     cs.setStringX (5, null);
0:     cs.setStringX (6, "");
0:     // We're passing the keyword EXPORTEDKEY, but this support may not be in the GA version of SPs.
0:     // As a workaround in getCrossReference(), we'll just "select * where 0=1" when foreignTable==""
0:     if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:       cs.setStringX (7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=1" );
0:     else
0:       cs.setStringX (7, "DATATYPE='JDBC';EXPORTEDKEY=1; CURSORHOLD=0" );
0:     lastGetForeignKeysResultSet_ = executeCatalogQuery (cs);
0:     return lastGetForeignKeysResultSet_;
1:   }
1: 
0:   // call stored procedure SQLForeignKeys
0:   // SYSIBM.SQLForeignKeys(
0:   //              PKCatalogName varchar(128),
0:   //              PKSchemaName  varchar(128),
0:   //              PKTableName   varchar(128),
0:   //              FKCatalogName varchar(128),
0:   //              FKSchemaName  varchar(128),
0:   //              FKTableName   varchar(128),
0:   //              Options       varchar(4000))
0:   //
0:   public java.sql.ResultSet getCrossReference (String primaryCatalog,
0:                                                String primarySchema,
0:                                                String primaryTable,
0:                                                String foreignCatalog,
0:                                                String foreignSchema,
0:                                                String foreignTable) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getCrossReference", primaryCatalog, primarySchema, primaryTable, foreignCatalog, foreignSchema, foreignTable);
0:       return getCrossReferenceX (primaryCatalog, primarySchema, primaryTable,
0:                                    foreignCatalog, foreignSchema, foreignTable);
1:     }
1:   }
1: 
1: 
0:   private ResultSet getCrossReferenceX (String primaryCatalog,
0:                                         String primarySchema,
0:                                         String primaryTable,
0:                                         String foreignCatalog,
0:                                         String foreignSchema,
0:                                         String foreignTable) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     // check input params, primaryTable and foreignTable cannot be null
0:     if ( primaryTable == null ) {
0:       throw new SqlException (agent_.logWriter_,  "getCrossReference(): null not allowed for primary table name" );
1:     }
1: 
0:     if ( foreignTable == null ) {
0:       throw new SqlException (agent_.logWriter_,  "getCrossReference(): null not allowed for foreign table name" );
1:     }
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLFOREIGNKEYS(?,?,?,?,?,?,?)");
1: 
0:     cs.setStringX (1, primaryCatalog);
0:     cs.setStringX (2, primarySchema);
0:     cs.setStringX (3, primaryTable);
0:     cs.setStringX (4, foreignCatalog);
0:     cs.setStringX (5, foreignSchema);
0:     cs.setStringX (6, foreignTable);
0:     cs.setStringX (7, getOptions());
0:     lastGetForeignKeysResultSet_ = executeCatalogQuery (cs);
0:     return lastGetForeignKeysResultSet_;
1:   }
1: 
0:   // call stored procedure SQLGetTypeInfo
0:   // SYSIBM.SQLGetTypeInfo (IN DATATYPE SMALLINT,
0:   //                        IN Options VARCHAR(4000))
0:   //
0:   //
0:   public java.sql.ResultSet getTypeInfo () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTypeInfo");
0:       return getTypeInfoX();
1:     }
1:   }
1: 
0:   private ResultSet getTypeInfoX () throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     // check if the last call's resultset is closed or not.
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLGETTYPEINFO(?,?)");
1: 
0:     cs.setShortX (1, (short)0);
0:     cs.setStringX (2, getOptions());
0:     lastGetTypeInfoResultSet_ = executeCatalogQuery (cs);
0:     return lastGetTypeInfoResultSet_;
1:   }
1: 
1: 
0:   // call stored procedure SQLStatistics
0:   // SYSIBM.SQLStatistics(
0:   //              CatalogName varchar(128),
0:   //              SchemaName  varchar(128),
0:   //              TableName   varchar(128),
0:   //              Unique      Smallint,
0:   //              Reserved    Smallint,
0:   //              Options     varchar(4000))
0:   //
0:   public java.sql.ResultSet getIndexInfo (String catalog,
1:                                           String schema,
1:                                           String table,
0:                                           boolean unique,
0:                                           boolean approximate) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getIndexInfo", catalog, schema, table, unique, approximate);
0:       return getIndexInfoX (catalog, schema, table, unique, approximate);
1:     }
1:   }
1: 
0:   private ResultSet getIndexInfoX (String catalog,
1:                                    String schema,
1:                                    String table,
0:                                    boolean unique,
0:                                    boolean approximate) throws SqlException
0:   {
0:     checkForClosedConnection();
1: 
0:     // validate the input table name
0:     if ( table == null ) {
0:       throw new SqlException (agent_.logWriter_,  "getIndexInfo(): null not allowed for table name" );
1:     }
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLSTATISTICS(?,?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schema);
0:     cs.setStringX (3, table);
1: 
0:     if (unique) cs.setShortX (4, SQL_INDEX_UNIQUE);
0:     else cs.setShortX (4, SQL_INDEX_ALL);
1: 
0:     if (approximate) cs.setShortX (5,(short) 1);
0:     else cs.setShortX (5, (short)0);
1: 
0:     cs.setStringX (6, getOptions());
0:     lastGetStatisticsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetStatisticsResultSet_;
1:   }
1: 
1: 
0:   //--------------------------JDBC 2.0-----------------------------
1: 
0:   public java.sql.ResultSet getUDTs (String catalog,
1:                                      String schemaPattern,
0:                                      String typeNamePattern,
0:                                      int[] types) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getUDTs", catalog, schemaPattern, typeNamePattern, types);
0:       return getUDTsX (catalog, schemaPattern, typeNamePattern, types);
1:     }
1:   }
1: 
0:   private ResultSet getUDTsX (String catalog,
1:                               String schemaPattern,
0:                               String typeNamePattern,
0:                               int[] types) throws SqlException
0:   {
0:     checkForClosedConnection();;
1: 
0:     PreparedStatement cs = prepareMetaDataQuery("SYSIBM.SQLUDTS(?,?,?,?,?)");
1: 
0:     cs.setStringX (1, catalog);
0:     cs.setStringX (2, schemaPattern);
0:     cs.setStringX (3, typeNamePattern);
0:     int i = 0;
0:     String udtTypes = new String();
0:     while (types != null && i < types.length) {
0:       if (i>0) udtTypes = udtTypes.concat (",");
0:       udtTypes = udtTypes.concat (String.valueOf (types[i]));
0:       i++;
1:     }
0:     cs.setStringX (4, udtTypes);
0:     cs.setStringX (5, getOptions());
0:     lastGetUDTsResultSet_ = executeCatalogQuery (cs);
0:     return lastGetUDTsResultSet_;
1:   }
1: 
1: 
0:   // helper method for the catalog queries only
0:   private String getOptions ()
0:   {
0:     int cursorHold;
0:     if (connection_.resultSetHoldability_ == ClientDataSource.HOLD_CURSORS_OVER_COMMIT)
0:        cursorHold = 1;
0:     else
0:        cursorHold = 0;
0:       return "DATATYPE='JDBC';DYNAMIC=0;REPORTPUBLICPRIVILEGES=1;CURSORHOLD=" + cursorHold;
1: 
1:   }
1: 
0:   // Derby uses a PreparedStatement argument rather than a callable statement
0:   private ResultSet executeCatalogQuery (PreparedStatement cs) throws SqlException
0:   {
0:     try {
0:       return cs.executeQueryX();
1:     }
0:     catch (SqlException e) {
0:       if (e.getErrorCode() == -440 ) {
0:         SqlException newException = new SqlException (agent_.logWriter_,
0:         "The required stored procedure is not installed on the server.");
0:         newException.setNextException (e);
0:         throw newException;
1:       }
0:       else if (e.getErrorCode() == -444 ) {
0:         SqlException newException = new SqlException (agent_.logWriter_,
0:         "The load module name for the stored procedure on the server is not found. ");
0:         newException.setNextException (e);
0:         throw newException;
1:       }
0:       else
0:         throw e;
1:     }
1:   }
1: 
0:   public java.sql.Connection getConnection () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return connection_;
1:   }
1: 
1:     // ------------------- JDBC 3.0 -------------------------
1: 
0:   public boolean supportsNamedParameters() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return false;
1:   }
1: 
0:   public boolean supportsMultipleOpenResults() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public boolean supportsGetGeneratedKeys() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return false;
1:   }
1: 
0:   public java.sql.ResultSet getSuperTypes (String catalog,
1:                                            String schemaPattern,
0:                                            String typeNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getSuperTypes", catalog, schemaPattern, typeNamePattern);
0:       return getSuperTypesX ();
1:     }
1:   }
1: 
0:   private ResultSet getSuperTypesX () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
0:                  "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
0:                  "VARCHAR('', 128) AS TYPE_NAME," +
0:                  "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_CAT," +
0:                  "CAST(NULL AS VARCHAR(128)) AS SUPERTYPE_SCHEM," +
0:                  "VARCHAR('', 128) AS SUPERTYPE_NAME "+
0:                  "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR " ;
0:     PreparedStatement ps = connection_.prepareDynamicCatalogQuery (sql);
0:     lastGetSuperTypesResultSet_ = ps.executeQueryX();
0:     return lastGetSuperTypesResultSet_;
1:   }
1: 
0:   public java.sql.ResultSet getSuperTables (String catalog,
1:                                             String schemaPattern,
0:                                             String tableNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getSuperTables", catalog, schemaPattern, tableNamePattern);
0:       return getSuperTablesX ();
1:     }
1:   }
1: 
0:   private ResultSet getSuperTablesX () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     java.lang.String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TABLE_CAT," +
0:                            "CAST(NULL AS VARCHAR(128)) AS TABLE_SCHEM," +
0:                            "VARCHAR('', 128) AS TABLE_NAME," +
0:                            "VARCHAR('', 128) AS SUPERTABLE_NAME FROM SYSIBM.SYSDUMMY1 "+
0:                            "WHERE 1=0 WITH UR";
0:     PreparedStatement ps = connection_.prepareDynamicCatalogQuery (sql);
0:     lastGetSuperTablesResultSet_ = ps.executeQueryX();
0:     return lastGetSuperTablesResultSet_;
1:   }
1: 
1: 
0:   public java.sql.ResultSet getAttributes (String catalog,
1:                                            String schemaPattern,
0:                                            String typeNamePattern,
0:                                            String attributeNamePattern) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getAttributes", catalog, schemaPattern, typeNamePattern, attributeNamePattern);
0:       return getAttributesX ();
1:     }
1:   }
1: 
0:   private ResultSet getAttributesX () throws SqlException
0:   {
0:     checkForClosedConnection();
0:     java.lang.String sql = "SELECT CAST(NULL AS VARCHAR(128)) AS TYPE_CAT," +
0:                            "CAST(NULL AS VARCHAR(128)) AS TYPE_SCHEM," +
0:                            "VARCHAR('', 128) AS TYPE_NAME," +
0:                            "VARCHAR('',128) AS ATTR_NAME," +
0:                            "SMALLINT(0) AS DATA_TYPE," +
0:                            "VARCHAR('',129) AS ATTR_TYPE_NAME,"+
0:                            "0 AS ATTR_SIZE," +
0:                            "0 AS DECIMAL_DIGITS," +
0:                            "0 AS NUM_PREC_RADIX,"+
0:                            "2 AS NULLABLE," +
0:                            "CAST(NULL AS VARCHAR(254)) AS REMARKS,"+
0:                            "CAST(NULL AS VARCHAR(128)) AS ATTR_DEF,"+
0:                            "0 AS SQL_DATA_TYPE," +
0:                            "0 AS SQL_DATETIME_SUB," +
0:                            "0 AS CHAR_OCTET_LENGTH," +
0:                            "0 AS ORDINAL_POSITION," +
0:                            "VARCHAR('',128) AS IS_NULLABLE,"+
0:                            "CAST(NULL AS VARCHAR(128)) AS SCOPE_CATALOG," +
0:                            "CAST(NULL AS VARCHAR(128)) AS SCOPE_SCHEMA,"+
0:                            "CAST(NULL AS VARCHAR(128)) AS SCOPE_TABLE," +
0:                            "CAST(NULL AS SMALLINT) AS SOURCE_DATA_TYPE " +
0:                            "FROM SYSIBM.SYSDUMMY1 WHERE 1=0 WITH UR" ;
0:     PreparedStatement ps = connection_.prepareDynamicCatalogQuery (sql);
0:     lastGetAttrResultSet_ = ps.executeQueryX();
0:     return lastGetAttrResultSet_;
1:   }
1: 
0:   public boolean supportsResultSetHoldability (int holdability) throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return true;
1:   }
1: 
0:   public int getResultSetHoldability() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:   }
1: 
0:   public int getDatabaseMajorVersion() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return productLevel_.versionLevel_;
1:   }
1: 
0:   public int getDatabaseMinorVersion() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return productLevel_.releaseLevel_;
1:   }
1: 
0:   public int getJDBCMajorVersion() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return 3;
1:   }
1: 
0:   public int getJDBCMinorVersion() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return 0;
1:   }
1: 
0:   public int getSQLStateType() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return sqlStateSQL99;
1:   }
1: 
0:   public boolean locatorsUpdateCopy() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return false;
1:   }
1: 
0:   public boolean supportsStatementPooling() throws SqlException
0:   {
0:     checkForClosedConnection();
0:     return false;
1:   }
1: 
0:   //--------------------Abstract material layer call-down methods-----------------
1: 
0:   // Compute feature set based on release
0:   abstract protected void computeFeatureSet_ ();
1: 
0:   //------------helper methods for meta data info call methods------------------
1: 
1: 
0:   private boolean getMetaDataInfoBoolean (int infoCallIndex) throws SqlException
0:   {
0:     if (metaDataInfoIsCached_) return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
0:     metaDataInfoCall ();
0:     return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue() != 0;
1:   }
1: 
0:   private int getMetaDataInfoInt (int infoCallIndex) throws SqlException
0:   {
0:     if (metaDataInfoIsCached_) return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
0:     metaDataInfoCall ();
0:     return ((Integer) metaDataInfoCache_[infoCallIndex]).intValue();
1:   }
1: 
0:   private String getMetaDataInfoString (int infoCallIndex) throws SqlException
0:   {
0:     if (metaDataInfoIsCached_) return (String) metaDataInfoCache_[infoCallIndex];
0:     metaDataInfoCall ();
0:     return (String) metaDataInfoCache_[infoCallIndex];
1:   }
0:   private boolean getMetaDataInfoBooleanWithType (int infoCallIndex, int type)throws SqlException
0:   {
0:     // Stored Procedure will return a String containing a
0:     // comma seperated list of all the supported result Set types
0:     // not throwing any exception right now even if the the type is wrong as per the spec
0:     String returnedFromSP = null;
0:     if (metaDataInfoIsCached_)
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:     else {
0:       metaDataInfoCall ();
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:     }
0:     java.util.StringTokenizer st = new java.util.StringTokenizer (returnedFromSP, ",");
0:     while (st.hasMoreTokens()) {
0:       if ((new Integer( st.nextToken())).intValue() == type )
0:         return true;
1:     }
0:     return false;
1:   }
1: 
0:   private boolean getMetaDataInfoInt_SupportsResultSetConcurrency (int infoCallIndex, int type, int concurrency) throws SqlException
0:   {
0:     // The stored procured will return a String containg a list of concurrency and list of resultSet types which support
0:     // a perticular concurrency
0:     // For eg. if the database supports concurrency CONCUR_READ_ONLY(1007) in ResultSet type TYPE_FORWARD_ONLY(1003),
0:     // TYPE_SCROLL_INSENSITIVE(1004), TYPE_SCROLL_SENSITIVE(1005) and
0:     // supports concurrency CONCUR_UPDATBLE(1008) in resultSet TYPE_SCROLL_SENSITIVE(1005)
0:     // then stored procedure will return a string "1007,1003,1004,1005;1008,1005"
0:     // see how concurrency and supported result set types are seperated by ";"
0:     String returnedFromSP = null;
0:     if (metaDataInfoIsCached_)
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:     else {
0:       metaDataInfoCall ();
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:     }
0:     java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP,";");
0:     while (st.hasMoreTokens()) {
0:       java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(),",");
0:       if ((new Integer( stForType.nextToken())).intValue() == concurrency ) {
0:         while (st.hasMoreTokens()) {
0:           if ((new Integer( st.nextToken())).intValue() == type ) return true;
1:         }
0:         return false;
1:       }
1:     }
0:     return false;
1:   }
0:   private boolean getMetaDataInfoBoolean_supportsConvert (int infoCallIndex, int fromType, int toType) throws SqlException
0:   {
0:     // The Stored procedure will return a String contain a list of all the valid conversions it support
0:     // For eg. If the database conversion from char(1) to date(91), time(92) and
0:     // Decimal(3) to char(1) ,double(8)
0:     // then StoredProcedure string will return "1,91,92;3,1,8"
0:     // see how fromTypes are seperated by ";"
0:     String returnedFromSP = null;
0:     if (metaDataInfoIsCached_)
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
0:     else {
0:       metaDataInfoCall ();
0:       returnedFromSP = (String) metaDataInfoCache_[infoCallIndex];
1:     }
0:     java.util.StringTokenizer st = new java.util.StringTokenizer(returnedFromSP,";");
0:     while (st.hasMoreTokens()) {
0:       java.util.StringTokenizer stForType = new java.util.StringTokenizer(st.nextToken(),",");
0:       if ((new Integer( stForType.nextToken())).intValue() == fromType ) {
0:         while (st.hasMoreTokens()) {
0:           if ((new Integer( st.nextToken())).intValue() == toType ) return true;
1:         }
0:         return false;
1:       }
1:     }
0:     return false;
1:   }
1: 
0:   // We synchronize at this level so that we don't have to synchronize all
0:   // the meta data info methods.  If we just return hardwired answers we don't
0:   // need to synchronize at the higher level.
0:   private void metaDataInfoCall () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       ResultSet rs;
1: 
0:       // These remote calls return a result set containing a single row.
0:       // Each column in the row corresponds to a particular get meta data info
0:       // method.
0:       PreparedStatement ps = prepareMetaDataQuery("SYSIBM.MetaData()");
0:       rs = (ResultSet) ps.executeQueryX();
0:       rs.nextX();
0:       int ColumnCount = ((ColumnMetaData) rs.getMetaDataX()).getColumnCount();
0:       for (int infoCallIndex = 0;
0:         (infoCallIndex < ColumnCount && infoCallIndex < metaDataInfoCache_.length);
0:         infoCallIndex++) {
0:         metaDataInfoCache_[infoCallIndex] = rs.getObjectX(infoCallIndex + 1);
1:       }
0:       metaDataInfoIsCached_ = true;
0:       rs.closeX();
1:     }
1:   }
1: 
1: 
0:   //----------------------------helper methods----------------------------------
1: 
1: 
0:   private PreparedStatement prepareMetaDataQuery (String cmd)  throws SqlException
0:   {
0:     PreparedStatement ps;
1: 
0:     ps = (org.apache.derby.client.am.PreparedStatement)
0:   	connection_.prepareStatementX ( "CALL " + cmd,
0:                                        java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                                        java.sql.ResultSet.CONCUR_READ_ONLY,
0:                                        connection_.resultSetHoldability_,
0:                                        java.sql.Statement.NO_GENERATED_KEYS,
0:                                        null );
0:     return ps;
1:   }
1: 
0:   private void checkForClosedConnection () throws SqlException
0:   {
0:     if (connection_.isClosedX()) {
0:       agent_.checkForDeferredExceptions();
0:       throw new SqlException (agent_.logWriter_, "DatabaseMetaData method called after connection was closed");
1:     }
0:     else {
0:       agent_.checkForDeferredExceptions();
1:     }
1:   }
1: }
============================================================================