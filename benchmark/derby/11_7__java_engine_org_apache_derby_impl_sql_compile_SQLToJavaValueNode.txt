1:fe77ca5: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.SQLToJavaValueNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
19:fe77ca5: 
4:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
1:fe77ca5: 
1:fe77ca5: import java.lang.reflect.Modifier;
1:f33fbaf: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.JSQLType;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:fe77ca5: 
5:fe77ca5: /**
1:fe77ca5:  * This node type converts a value in the SQL domain to a value in the Java
1:fe77ca5:  * domain.
1:fe77ca5:  */
1:fe77ca5: 
1:3bb140c: class SQLToJavaValueNode extends JavaValueNode
7:fe77ca5: {
1:fe77ca5: 	ValueNode	value;
1:fe77ca5: 
1:7d3ddb1:     /**
1:7d3ddb1:      * If set then this SQL value is being passed into a SQL function
1:7d3ddb1:      * declared RETURNS NULL ON NULL input. In this case this node
1:7d3ddb1:      * performs NULL checking logic in addition simple translation
1:7d3ddb1:      * from the SQL domain to the Java domain. Thus if this
1:7d3ddb1:      * is set then this node can not be removed when it
1:7d3ddb1:      * is paired with a JavaToSQLValueNode.
1:7d3ddb1:      * This field is set at generate time of the
1:7d3ddb1:      * enclosing StaticMethodCallNode.
1:7d3ddb1:      */
1:fe77ca5: 	LocalField	returnsNullOnNullState;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Constructor for a SQLToJavaValueNode
5:fe77ca5: 	 *
1:fe77ca5: 	 * @param value		A ValueNode representing a SQL value to convert to
1:fe77ca5: 	 *					the Java domain.
1:3bb140c:      * @param cm        The context manager
1:fe77ca5: 	 */
1:3bb140c:     SQLToJavaValueNode(ValueNode value, ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.value = value;
1:3bb140c:     }
1:fe77ca5: 
1:3bb140c:     /**
1:fe77ca5: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:fe77ca5: 	 * how tree printing is supposed to work.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param depth		The depth of this node in the tree
1:22917ef: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			int	parm;
1:fe77ca5: 
1:fe77ca5: 			super.printSubNodes(depth);
1:fe77ca5: 			if (value != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "value: ");
1:fe77ca5: 				value.treePrint(depth + 1);
8:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:22917ef: 	/**
1:fe77ca5: 	  *	Returns the name of the java class type that this node coerces to.
1:fe77ca5: 	  *
1:fe77ca5: 	  *	@return	name of java class type
1:fe77ca5: 	  *
1:fe77ca5: 	  */
1:3bb140c:     @Override
1:9f2ed7d:     String getJavaTypeName()
1:3bb140c:             throws StandardException
1:7d3ddb1: 	{
1:fe77ca5: 		JSQLType	myType = getJSQLType();
1:fe77ca5: 
1:fe77ca5: 		if ( myType == null ) { return ""; }
1:fe77ca5: 		else { return	mapToTypeID( myType ).getCorrespondingJavaTypeName(); }
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  *	Returns the name of the java primitive type that this node coerces to.
1:fe77ca5: 	  *
1:fe77ca5: 	  *	@return	name of java primitive type
1:fe77ca5: 	  *
1:fe77ca5: 	  * @exception StandardException		Thrown on error
1:fe77ca5: 	  */
1:3bb140c:     @Override
1:9f2ed7d:     String getPrimitiveTypeName()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		JSQLType	myType = getJSQLType();
1:fe77ca5: 
1:fe77ca5: 		if ( myType == null )
1:fe77ca5: 		{
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			return
1:fe77ca5: 				getTypeCompiler(mapToTypeID( myType )).
1:fe77ca5: 										getCorrespondingPrimitiveTypeName();
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
1:fe77ca5: 	  *	a Java primitive, or a Java class.
1:fe77ca5: 	  *
1:fe77ca5: 	  *	Overrides method in JavaValueNode.
1:fe77ca5: 	  *
1:fe77ca5: 	  *	@return	the corresponding JSQLType
1:fe77ca5: 	  *
1:fe77ca5: 	  */
1:3bb140c:     @Override
1:9f2ed7d:     JSQLType getJSQLType() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		if ( jsqlType == null )
1:fe77ca5: 		{
1:d5bc20f: 			if ( value.requiresTypeFromContext()) 
1:fe77ca5: 			{
1:d5bc20f:   				ParameterNode pn;
1:d5bc20f: 	  			if (value instanceof UnaryOperatorNode) 
1:d5bc20f: 	  				pn = ((UnaryOperatorNode)value).getParameterOperand();
1:fe77ca5: 	  			else
1:d5bc20f: 	  				pn = (ParameterNode) (value);
1:d5bc20f: 				jsqlType = pn.getJSQLType();
1:fe77ca5: 				
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				DataTypeDescriptor dtd = value.getTypeServices();
1:fe77ca5: 				if (dtd != null)
1:fe77ca5: 					jsqlType = new JSQLType( dtd );
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return jsqlType;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind this expression.  This means binding the sub-expressions,
1:fe77ca5: 	 * as well as figuring out what the return type is for this expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromList		The FROM list for the query this
1:09c2697:      *                      expression is in, for binding columns.
1:09c2697:      * @param subqueryList  The subquery list being built as we find
1:09c2697:      *                      SubqueryNodes
1:09c2697:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return this	
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:09c2697:     JavaValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/* Bind the expression under us */
1:fe77ca5: 		value = value.bindExpression(fromList, subqueryList,
1:09c2697:                               aggregates);
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:3bb140c:     @Override
1:9f2ed7d:     DataTypeDescriptor getDataType() throws StandardException
1:22917ef:     {
1:22917ef:         return value.getTypeServices();
1:22917ef:     }
1:22917ef: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Remap all ColumnReferences in this tree to be clones of the
1:fe77ca5: 	 * underlying expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return JavaValueNode			The remapped expression tree.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException			Thrown on error
1:fe77ca5: 	 */
1:9f2ed7d:     JavaValueNode remapColumnReferencesToExpressions()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		value = value.remapColumnReferencesToExpressions();
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Categorize this predicate.  Initially, this means
1:fe77ca5: 	 * building a bit map of the referenced tables for each predicate.
1:fe77ca5: 	 * If the source of this ColumnReference (at the next underlying level) 
1:fe77ca5: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:fe77ca5: 	 * will not be pushed down.
1:fe77ca5: 	 *
1:fe77ca5: 	 * For example, in:
1:fe77ca5: 	 *		select * from (select 1 from s) a (x) where x = 1
1:fe77ca5: 	 * we will not push down x = 1.
1:fe77ca5: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:fe77ca5: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:fe77ca5: 	 * that tree into the pushed predicate, and that tree could contain
1:fe77ca5: 	 * subqueries and method calls.
1:fe77ca5: 	 * RESOLVE - revisit this issue once we have views.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:fe77ca5: 	 * @param simplePredsOnly	Whether or not to consider method
1:fe77ca5: 	 *							calls, field references and conditional nodes
1:fe77ca5: 	 *							when building bit map
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:fe77ca5: 	 *						or a VirtualColumnNode.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException			Thrown on error
1:fe77ca5: 	 */
1:9f2ed7d:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return value.categorize(referencedTabs, simplePredsOnly);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Preprocess an expression tree.  We do a number of transformations
1:fe77ca5: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:fe77ca5: 	 * subquery flattening.
1:fe77ca5: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param	numTables			Number of tables in the DML Statement
1:fe77ca5: 	 * @param	outerFromList		FromList from outer query block
1:fe77ca5: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:fe77ca5: 	 * @param	outerPredicateList	PredicateList from outer query block
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:9f2ed7d:     void preprocess(int numTables,
1:fe77ca5: 							FromList outerFromList,
1:fe77ca5: 							SubqueryList outerSubqueryList,
1:fe77ca5: 							PredicateList outerPredicateList) 
1:fe77ca5: 							throws StandardException
1:fe77ca5: 	{
1:f3e70a1:         value = value.preprocess(numTables,
1:fe77ca5: 						 outerFromList, outerSubqueryList,
1:fe77ca5: 						 outerPredicateList);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return the variant type for the underlying expression.
1:fe77ca5: 	 * The variant type can be:
1:fe77ca5: 	 *		VARIANT				- variant within a scan
1:fe77ca5: 	 *							  (method calls and non-static field access)
1:fe77ca5: 	 *		SCAN_INVARIANT		- invariant within a scan
1:fe77ca5: 	 *							  (column references from outer tables)
1:fe77ca5: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:fe77ca5: 	 *							  (constant expressions)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The variant type for the underlying expression.
1:fe77ca5: 	 * @exception StandardException	thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     int getOrderableVariantType() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return value.getOrderableVariantType();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	///////////////////////////////////////////////////////////////////////
1:fe77ca5: 	//
1:fe77ca5: 	//	CODE GENERATION METHODS
1:fe77ca5: 	//
1:fe77ca5: 	///////////////////////////////////////////////////////////////////////
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Generate code to get the Java value out of a SQL value.
1:fe77ca5: 	 *
1:fe77ca5: 	 * Every SQL type has a corresponding Java type.  The getObject() method
1:fe77ca5: 	 * on the SQL type gets the right Java type.
1:fe77ca5: 	 *
1:fe77ca5: 	 * The generated code will be:
1:fe77ca5: 	 *
1:fe77ca5: 	 * (<Java type name>) ((DataValueDescriptor)
1:fe77ca5: 	 *								<generated value>.getObject())
1:fe77ca5: 	 *
1:fe77ca5: 	 * where <Java type name> comes from the getCorrespondingJavaTypeName()
1:fe77ca5: 	 * method of the value's TypeId.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param acb	The ExpressionClassBuilder for the class being built
2:fe77ca5: 	 * @param mb	The method the expression will go into
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:9f2ed7d:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:fe77ca5: 									throws StandardException
1:fe77ca5: 	{       
1:fe77ca5: 		/* Compile the expression under us */
1:fe77ca5: 		generateSQLValue( acb, mb );
1:fe77ca5: 
1:fe77ca5: 		/* now cast the SQLValue to a Java value */
1:fe77ca5: 		generateJavaValue( acb, mb);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Generate the SQLvalue that this node wraps.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:fe77ca5: 	 * @param mb	The method the expression will go into
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:7d3ddb1: 	private void generateSQLValue(ExpressionClassBuilder acb,
2:fe77ca5: 											MethodBuilder mb)
1:fe77ca5: 									throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		value.generateExpression(acb, mb);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Generate code to cast the SQLValue to a Java value.
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:6b50965: 	 * @param mbex	The method the expression will go into
1:fe77ca5: 	 *
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 
1:7d3ddb1: 	private void generateJavaValue
2:fe77ca5: 	(
1:fe77ca5: 		ExpressionClassBuilder	acb,
1:fe77ca5: 		MethodBuilder mbex
2:fe77ca5:     )
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/* If this is a conversion to a primitive type, then call the
1:fe77ca5: 		 * appropriate method for getting the primitive value and
1:fe77ca5: 		 * cast it to the primitive type. 
1:fe77ca5: 		 * NOTE: We first call Activation.nullToPrimitiveTest(),
1:fe77ca5: 		 * which will throw a StandardException if the value is null
1:fe77ca5: 		 */
1:fe77ca5: 		if ( isPrimitiveType() || mustCastToPrimitive() )
1:fe77ca5: 		{
1:fe77ca5: 			String		primitiveTN = value.getTypeCompiler().getCorrespondingPrimitiveTypeName();
1:fe77ca5: 
1:fe77ca5: 			/* Put the code to check if the object is null and to
1:fe77ca5: 			 * get the primitive value in a method call.  This is
1:fe77ca5: 			 * necessary because we are generating an expression here and
1:fe77ca5: 			 * cannot have multiple statements.
1:fe77ca5: 			 * The method call will take SQLValue as a parameter.
1:fe77ca5: 			 */
1:fe77ca5: 			String[] pd = new String[1];
1:fe77ca5: 			pd[0] = getSQLValueInterfaceName(); // parameter "param1"
1:fe77ca5: 
1:fe77ca5: 			MethodBuilder	mb = acb.newGeneratedFun(primitiveTN, Modifier.PRIVATE, pd);
1:fe77ca5: 
1:fe77ca5: 			mb.getParameter(0);
1:fe77ca5: 
1:fe77ca5: 			if (returnsNullOnNullState != null)
1:92268ac: 			{
1:fe77ca5: 				generateReturnsNullOnNullCheck(mb);
1:92268ac: 			}
1:92268ac: 			else
1:92268ac: 			{
1:fe77ca5: 				mb.dup();
1:fe77ca5: 				mb.upCast(ClassName.DataValueDescriptor);
1:fe77ca5: 				mb.push(primitiveTN); 
1:fe77ca5: 				mb.callMethod(VMOpcode.INVOKESTATIC, ClassName.BaseActivation, "nullToPrimitiveTest", "void", 2);
1:fe77ca5: 			}
1:92268ac: 
1:fe77ca5: 			// stack is dvd
1:fe77ca5: 
1:fe77ca5: 			/* Generate the code to get the primitive value */
1:fe77ca5: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1:fe77ca5: 								value.getTypeCompiler().getPrimitiveMethodName(), primitiveTN, 0);
1:fe77ca5: 
1:fe77ca5: 			mb.methodReturn();
1:fe77ca5: 			mb.complete();
1:fe77ca5: 
1:fe77ca5: 			/* Generate the call to the new method, with the parameter */
1:fe77ca5: 
1:fe77ca5: 			mbex.pushThis();
1:fe77ca5: 			mbex.swap(); // caller pushed out parameter
1:fe77ca5: 			mbex.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, mb.getName(), primitiveTN, 1);
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			if (returnsNullOnNullState != null)
1:fe77ca5: 				generateReturnsNullOnNullCheck(mbex);
1:fe77ca5: 
1:9495437: 			/* Call getObject() to get the right type of Java value */
1:9495437: 			mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "getObject",
1:9495437: 										"java.lang.Object", 0);
1:fe77ca5: 
1:9495437: 			mbex.cast(value.getTypeId().getCorrespondingJavaTypeName());
1:9495437: 		}
1:92268ac: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Generate the code for the returns Null on Null input check..
1:fe77ca5: 		Stack must contain the DataDescriptorValue.
1:fe77ca5: 	*/
1:fe77ca5: 
1:fe77ca5: 	private void generateReturnsNullOnNullCheck(MethodBuilder mb)
1:fe77ca5: 	{
1:fe77ca5: 		mb.dup();
1:fe77ca5: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Storable,
1:fe77ca5: 								"isNull", "boolean", 0);
1:fe77ca5: 
1:fe77ca5: 		mb.conditionalIf();
1:fe77ca5: 		  mb.push(true);
1:fe77ca5: 		mb.startElseCode();
1:fe77ca5: 		  mb.getField(returnsNullOnNullState);
1:fe77ca5: 		mb.completeConditional();
1:fe77ca5: 		
1:afa871e: 		mb.setField(returnsNullOnNullState);
1:92268ac: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  *	Get the type name of the SQLValue we generate.
1:fe77ca5: 	  *
1:fe77ca5: 	  *	@return	name of interface corresponding to SQLValue
1:fe77ca5: 	  *
1:fe77ca5: 	  *
1:fe77ca5: 	  * @exception StandardException		Thrown on error
1:fe77ca5: 	  */
1:ef158f2: 	private	String	getSQLValueInterfaceName()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return value.getTypeCompiler().interfaceName();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	///////////////////////////////////////////////////////////////////////
1:fe77ca5: 	//
1:fe77ca5: 	//	OTHER VALUE NODE METHODS
1:fe77ca5: 	//
1:fe77ca5: 	///////////////////////////////////////////////////////////////////////
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the SQL ValueNode that is being converted to a JavaValueNode
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The underlying SQL ValueNode
1:fe77ca5: 	 */
1:fe77ca5: 	ValueNode getSQLValueNode()
1:fe77ca5: 	{
1:fe77ca5: 		return value;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see ValueNode#getConstantValueAsObject 
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	Object getConstantValueAsObject()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return value.getConstantValueAsObject();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:fe77ca5: 	 * 
1:fe77ca5: 	 * @param v the visitor
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:fe77ca5: 
1:aebfb28: 		if (value != null)
1:fe77ca5: 		{
1:fe77ca5: 			value = (ValueNode)value.accept(v);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f3e70a1
/////////////////////////////////////////////////////////////////////////
1:         value = value.preprocess(numTables,
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     String getJavaTypeName()
/////////////////////////////////////////////////////////////////////////
1:     String getPrimitiveTypeName()
/////////////////////////////////////////////////////////////////////////
1:     JSQLType getJSQLType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getDataType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     JavaValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     int getOrderableVariantType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      *                      expression is in, for binding columns.
1:      * @param subqueryList  The subquery list being built as we find
1:      *                      SubqueryNodes
1:      * @param aggregates    The aggregate list being built as we find AggregateNodes
1:     JavaValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
1:                               aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (value != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.JSQLType;
1: import org.apache.derby.iapi.util.JBitSet;
1: class SQLToJavaValueNode extends JavaValueNode
/////////////////////////////////////////////////////////////////////////
1:      * @param cm        The context manager
1:     SQLToJavaValueNode(ValueNode value, ContextManager cm) {
1:         super(cm);
0:         setNodeType(C_NodeTypes.SQL_TO_JAVA_VALUE_NODE);
1:         this.value = value;
1:     }
1:     /**
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:9495437
/////////////////////////////////////////////////////////////////////////
1: 			/* Call getObject() to get the right type of Java value */
1: 			mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "getObject",
1: 										"java.lang.Object", 0);
1: 			mbex.cast(value.getTypeId().getCorrespondingJavaTypeName());
1: 		}
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:             if ( value.getTypeId().isPasswordTypeId() )
1:             {
0:                 // if we are setting a password, make sure we zero out the value
0:                 // that was passed in so that it can't be memory-sniffed
1:                 
0:                 mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.StringDataValue, "getRawDataAndZeroIt",
0:                                 "char[]", 0);
1:             }
1:             else
1:             {
0:                 /* Call getObject() to get the right type of Java value */
0:                 mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "getObject",
0:                                 "java.lang.Object", 0);
0:                 mbex.cast(value.getTypeId().getCorrespondingJavaTypeName());
1:             }
1:         }
commit:22917ef
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Override behavior in superclass.
1:      */
0:     public DataTypeDescriptor getDataType() throws StandardException
1:     {
1:         return value.getTypeServices();
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: 	private	String	getSQLValueInterfaceName()
commit:7d3ddb1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * If set then this SQL value is being passed into a SQL function
1:      * declared RETURNS NULL ON NULL input. In this case this node
1:      * performs NULL checking logic in addition simple translation
1:      * from the SQL domain to the Java domain. Thus if this
1:      * is set then this node can not be removed when it
1:      * is paired with a JavaToSQLValueNode.
1:      * This field is set at generate time of the
1:      * enclosing StaticMethodCallNode.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	{       
/////////////////////////////////////////////////////////////////////////
1: 	private void generateSQLValue(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1: 	private void generateJavaValue
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		mb.setField(returnsNullOnNullState);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.SQLToJavaValueNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.JSQLType;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: 
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
1: import java.lang.reflect.Modifier;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * This node type converts a value in the SQL domain to a value in the Java
1:  * domain.
1:  */
1: 
0: public class SQLToJavaValueNode extends JavaValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	ValueNode	value;
1: 
1: 	LocalField	returnsNullOnNullState;
1: 
1: 	/**
1: 	 * Constructor for a SQLToJavaValueNode
1: 	 *
1: 	 * @param value		A ValueNode representing a SQL value to convert to
1: 	 *					the Java domain.
1: 	 */
1: 
0: 	public void init(Object value)
1: 	{
0: 		this.value = (ValueNode) value;
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			int	parm;
1: 
1: 			super.printSubNodes(depth);
1: 			if (value != null)
1: 			{
1: 				printLabel(depth, "value: ");
1: 				value.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  *	Returns the name of the java class type that this node coerces to.
1: 	  *
1: 	  *	@return	name of java class type
1: 	  *
1: 	  */
0: 	public String getJavaTypeName()
1: 	{
1: 		JSQLType	myType = getJSQLType();
1: 
1: 		if ( myType == null ) { return ""; }
1: 		else { return	mapToTypeID( myType ).getCorrespondingJavaTypeName(); }
1: 	}
1: 
1: 	/**
1: 	  *	Returns the name of the java primitive type that this node coerces to.
1: 	  *
1: 	  *	@return	name of java primitive type
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
0: 	public String getPrimitiveTypeName()
1: 		throws StandardException
1: 	{
1: 		JSQLType	myType = getJSQLType();
1: 
1: 		if ( myType == null )
1: 		{
1: 			return "";
1: 		}
1: 		else
1: 		{
1: 			return
1: 				getTypeCompiler(mapToTypeID( myType )).
1: 										getCorrespondingPrimitiveTypeName();
1: 		}
1: 	}
1: 
1: 	/**
1: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
1: 	  *	a Java primitive, or a Java class.
1: 	  *
1: 	  *	Overrides method in JavaValueNode.
1: 	  *
1: 	  *	@return	the corresponding JSQLType
1: 	  *
1: 	  */
0: 	public	JSQLType	getJSQLType
1: 	(
1:     )
1: 	{
1: 		if ( jsqlType == null )
1: 		{
0: 			if ( value.isParameterNode() ) 
1: 			{
0: 				jsqlType = ((ParameterNode) value).getJSQLType();
1: 			}
1: 			else
1: 			{
1: 				DataTypeDescriptor dtd = value.getTypeServices();
1: 				if (dtd != null)
1: 					jsqlType = new JSQLType( dtd );
1: 			}
1: 		}
1: 
1: 		return jsqlType;
1: 	}
1: 
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		value.setClause(clause);
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find
0: 	 *							SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return this	
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
1: 		/* Bind the expression under us */
1: 		value = value.bindExpression(fromList, subqueryList,
0: 							  aggregateVector);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return JavaValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		value = value.remapColumnReferencesToExpressions();
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		return value.categorize(referencedTabs, simplePredsOnly);
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
0: 	 * @return	Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void preprocess(int numTables,
1: 							FromList outerFromList,
1: 							SubqueryList outerSubqueryList,
1: 							PredicateList outerPredicateList) 
1: 							throws StandardException
1: 	{
0: 		value.preprocess(numTables,
1: 						 outerFromList, outerSubqueryList,
1: 						 outerPredicateList);
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException	thrown on error
1: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		return value.getOrderableVariantType();
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CODE GENERATION METHODS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * Generate code to get the Java value out of a SQL value.
1: 	 *
1: 	 * Every SQL type has a corresponding Java type.  The getObject() method
1: 	 * on the SQL type gets the right Java type.
1: 	 *
1: 	 * The generated code will be:
1: 	 *
1: 	 * (<Java type name>) ((DataValueDescriptor)
1: 	 *								<generated value>.getObject())
1: 	 *
1: 	 * where <Java type name> comes from the getCorrespondingJavaTypeName()
1: 	 * method of the value's TypeId.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		/* Compile the expression under us */
1: 		generateSQLValue( acb, mb );
1: 
1: 		/* now cast the SQLValue to a Java value */
1: 		generateJavaValue( acb, mb);
1: 	}
1: 
1: 	/**
1: 	 * Generate the SQLvalue that this node wraps.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateSQLValue(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		value.generateExpression(acb, mb);
1: 	}
1: 
1: 	/**
1: 	 * Generate code to cast the SQLValue to a Java value.
1: 	 *
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
0: 	 * @param SQLValue	An Expression holding the SQLValue.
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateJavaValue
1: 	(
1: 		ExpressionClassBuilder	acb,
1: 		MethodBuilder mbex
1:     )
1: 		throws StandardException
1: 	{
1: 		/* If this is a conversion to a primitive type, then call the
1: 		 * appropriate method for getting the primitive value and
1: 		 * cast it to the primitive type. 
1: 		 * NOTE: We first call Activation.nullToPrimitiveTest(),
1: 		 * which will throw a StandardException if the value is null
1: 		 */
1: 		if ( isPrimitiveType() || mustCastToPrimitive() )
1: 		{
1: 			String		primitiveTN = value.getTypeCompiler().getCorrespondingPrimitiveTypeName();
1: 
1: 			/* Put the code to check if the object is null and to
1: 			 * get the primitive value in a method call.  This is
1: 			 * necessary because we are generating an expression here and
1: 			 * cannot have multiple statements.
1: 			 * The method call will take SQLValue as a parameter.
1: 			 */
1: 			String[] pd = new String[1];
1: 			pd[0] = getSQLValueInterfaceName(); // parameter "param1"
1: 
1: 			MethodBuilder	mb = acb.newGeneratedFun(primitiveTN, Modifier.PRIVATE, pd);
1: 
1: 			mb.getParameter(0);
1: 
1: 			if (returnsNullOnNullState != null)
1: 			{
1: 				generateReturnsNullOnNullCheck(mb);
1: 			}
1: 			else
1: 			{
1: 				mb.dup();
1: 				mb.upCast(ClassName.DataValueDescriptor);
1: 				mb.push(primitiveTN); 
1: 				mb.callMethod(VMOpcode.INVOKESTATIC, ClassName.BaseActivation, "nullToPrimitiveTest", "void", 2);
1: 			}
1: 
1: 			// stack is dvd
1: 
1: 			/* Generate the code to get the primitive value */
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
1: 								value.getTypeCompiler().getPrimitiveMethodName(), primitiveTN, 0);
1: 
1: 			mb.methodReturn();
1: 			mb.complete();
1: 
1: 			/* Generate the call to the new method, with the parameter */
1: 
1: 			mbex.pushThis();
1: 			mbex.swap(); // caller pushed out parameter
1: 			mbex.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, mb.getName(), primitiveTN, 1);
1: 		}
1: 		else
1: 		{
1: 			if (returnsNullOnNullState != null)
1: 				generateReturnsNullOnNullCheck(mbex);
1: 
0: 			/* Call getObject() to get the right type of Java value */
0: 			mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "getObject",
0: 										"java.lang.Object", 0);
1: 
0: 			mbex.cast(value.getTypeId().getCorrespondingJavaTypeName());
1: 		}
1: 	}
1: 
1: 	/**
1: 		Generate the code for the returns Null on Null input check..
1: 		Stack must contain the DataDescriptorValue.
1: 	*/
1: 
1: 	private void generateReturnsNullOnNullCheck(MethodBuilder mb)
1: 	{
1: 		mb.dup();
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Storable,
1: 								"isNull", "boolean", 0);
1: 
1: 		mb.conditionalIf();
1: 		  mb.push(true);
1: 		mb.startElseCode();
1: 		  mb.getField(returnsNullOnNullState);
1: 		mb.completeConditional();
1: 		
0: 		mb.putField(returnsNullOnNullState);
0: 		mb.endStatement();
1: 	}
1: 
1: 
1: 	/**
1: 	  *	Get the type name of the SQLValue we generate.
1: 	  *
1: 	  *	@return	name of interface corresponding to SQLValue
1: 	  *
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
0: 	public	String	getSQLValueInterfaceName()
1: 		throws StandardException
1: 	{
1: 		return value.getTypeCompiler().interfaceName();
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	OTHER VALUE NODE METHODS
1: 	//
1: 	///////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
1: 	 * Get the SQL ValueNode that is being converted to a JavaValueNode
1: 	 *
1: 	 * @return	The underlying SQL ValueNode
1: 	 */
1: 	ValueNode getSQLValueNode()
1: 	{
1: 		return value;
1: 	}
1: 
1: 	/** @see ValueNode#getConstantValueAsObject 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Object getConstantValueAsObject()
1: 		throws StandardException
1: 	{
1: 		return value.getConstantValueAsObject();
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 	
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
0: 		if (value != null && !v.stopTraversal())
1: 		{
1: 			value = (ValueNode)value.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 				
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param mbex	The method the expression will go into
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public	JSQLType	getJSQLType	() throws StandardException
1: 			if ( value.requiresTypeFromContext()) 
1:   				ParameterNode pn;
1: 	  			if (value instanceof UnaryOperatorNode) 
1: 	  				pn = ((UnaryOperatorNode)value).getParameterOperand();
0: 	  			else
1: 	  				pn = (ParameterNode) (value);
1: 				jsqlType = pn.getJSQLType();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.JSQLType;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * This node type converts a value in the SQL domain to a value in the Java
0:  * domain.
0:  */
0: 
0: public class SQLToJavaValueNode extends JavaValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	ValueNode	value;
0: 
0: 	LocalField	returnsNullOnNullState;
0: 
0: 	/**
0: 	 * Constructor for a SQLToJavaValueNode
0: 	 *
0: 	 * @param value		A ValueNode representing a SQL value to convert to
0: 	 *					the Java domain.
0: 	 */
0: 
0: 	public void init(Object value)
0: 	{
0: 		this.value = (ValueNode) value;
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			int	parm;
0: 
0: 			super.printSubNodes(depth);
0: 			if (value != null)
0: 			{
0: 				printLabel(depth, "value: ");
0: 				value.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	Returns the name of the java class type that this node coerces to.
0: 	  *
0: 	  *	@return	name of java class type
0: 	  *
0: 	  */
0: 	public String getJavaTypeName()
0: 	{
0: 		JSQLType	myType = getJSQLType();
0: 
0: 		if ( myType == null ) { return ""; }
0: 		else { return	mapToTypeID( myType ).getCorrespondingJavaTypeName(); }
0: 	}
0: 
0: 	/**
0: 	  *	Returns the name of the java primitive type that this node coerces to.
0: 	  *
0: 	  *	@return	name of java primitive type
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public String getPrimitiveTypeName()
0: 		throws StandardException
0: 	{
0: 		JSQLType	myType = getJSQLType();
0: 
0: 		if ( myType == null )
0: 		{
0: 			return "";
0: 		}
0: 		else
0: 		{
0: 			return
0: 				getTypeCompiler(mapToTypeID( myType )).
0: 										getCorrespondingPrimitiveTypeName();
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	Get the JSQLType that corresponds to this node. Could be a SQLTYPE,
0: 	  *	a Java primitive, or a Java class.
0: 	  *
0: 	  *	Overrides method in JavaValueNode.
0: 	  *
0: 	  *	@return	the corresponding JSQLType
0: 	  *
0: 	  */
0: 	public	JSQLType	getJSQLType
0: 	(
0:     )
0: 	{
0: 		if ( jsqlType == null )
0: 		{
0: 			if ( value.isParameterNode() ) 
0: 			{
0: 				jsqlType = ((ParameterNode) value).getJSQLType();
0: 			}
0: 			else
0: 			{
0: 				DataTypeDescriptor dtd = value.getTypeServices();
0: 				if (dtd != null)
0: 					jsqlType = new JSQLType( dtd );
0: 			}
0: 		}
0: 
0: 		return jsqlType;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		value.setClause(clause);
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find
0: 	 *							SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return this	
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public JavaValueNode bindExpression(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		/* Bind the expression under us */
0: 		value = value.bindExpression(fromList, subqueryList,
0: 							  aggregateVector);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return JavaValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		value = value.remapColumnReferencesToExpressions();
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		return value.categorize(referencedTabs, simplePredsOnly);
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return	Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void preprocess(int numTables,
0: 							FromList outerFromList,
0: 							SubqueryList outerSubqueryList,
0: 							PredicateList outerPredicateList) 
0: 							throws StandardException
0: 	{
0: 		value.preprocess(numTables,
0: 						 outerFromList, outerSubqueryList,
0: 						 outerPredicateList);
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		return value.getOrderableVariantType();
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CODE GENERATION METHODS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	/**
0: 	 * Generate code to get the Java value out of a SQL value.
0: 	 *
0: 	 * Every SQL type has a corresponding Java type.  The getObject() method
0: 	 * on the SQL type gets the right Java type.
0: 	 *
0: 	 * The generated code will be:
0: 	 *
0: 	 * (<Java type name>) ((DataValueDescriptor)
0: 	 *								<generated value>.getObject())
0: 	 *
0: 	 * where <Java type name> comes from the getCorrespondingJavaTypeName()
0: 	 * method of the value's TypeId.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		/* Compile the expression under us */
0: 		generateSQLValue( acb, mb );
0: 
0: 		/* now cast the SQLValue to a Java value */
0: 		generateJavaValue( acb, mb);
0: 	}
0: 
0: 	/**
0: 	 * Generate the SQLvalue that this node wraps.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateSQLValue(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		value.generateExpression(acb, mb);
0: 	}
0: 
0: 	/**
0: 	 * Generate code to cast the SQLValue to a Java value.
0: 	 *
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 * @param SQLValue	An Expression holding the SQLValue.
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateJavaValue
0: 	(
0: 		ExpressionClassBuilder	acb,
0: 		MethodBuilder mbex
0:     )
0: 		throws StandardException
0: 	{
0: 		/* If this is a conversion to a primitive type, then call the
0: 		 * appropriate method for getting the primitive value and
0: 		 * cast it to the primitive type. 
0: 		 * NOTE: We first call Activation.nullToPrimitiveTest(),
0: 		 * which will throw a StandardException if the value is null
0: 		 */
0: 		if ( isPrimitiveType() || mustCastToPrimitive() )
0: 		{
0: 			String		primitiveTN = value.getTypeCompiler().getCorrespondingPrimitiveTypeName();
0: 
0: 			/* Put the code to check if the object is null and to
0: 			 * get the primitive value in a method call.  This is
0: 			 * necessary because we are generating an expression here and
0: 			 * cannot have multiple statements.
0: 			 * The method call will take SQLValue as a parameter.
0: 			 */
0: 			String[] pd = new String[1];
0: 			pd[0] = getSQLValueInterfaceName(); // parameter "param1"
0: 
0: 			MethodBuilder	mb = acb.newGeneratedFun(primitiveTN, Modifier.PRIVATE, pd);
0: 
0: 			mb.getParameter(0);
0: 
0: 			if (returnsNullOnNullState != null)
0: 			{
0: 				generateReturnsNullOnNullCheck(mb);
0: 			}
0: 			else
0: 			{
0: 				mb.dup();
0: 				mb.upCast(ClassName.DataValueDescriptor);
0: 				mb.push(primitiveTN); 
0: 				mb.callMethod(VMOpcode.INVOKESTATIC, ClassName.BaseActivation, "nullToPrimitiveTest", "void", 2);
0: 			}
0: 
0: 			// stack is dvd
0: 
0: 			/* Generate the code to get the primitive value */
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor,
0: 								value.getTypeCompiler().getPrimitiveMethodName(), primitiveTN, 0);
0: 
0: 			mb.methodReturn();
0: 			mb.complete();
0: 
0: 			/* Generate the call to the new method, with the parameter */
0: 
0: 			mbex.pushThis();
0: 			mbex.swap(); // caller pushed out parameter
0: 			mbex.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, mb.getName(), primitiveTN, 1);
0: 		}
0: 		else
0: 		{
0: 			if (returnsNullOnNullState != null)
0: 				generateReturnsNullOnNullCheck(mbex);
0: 
0: 			/* Call getObject() to get the right type of Java value */
0: 			mbex.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.DataValueDescriptor, "getObject",
0: 										"java.lang.Object", 0);
0: 
0: 			mbex.cast(value.getTypeId().getCorrespondingJavaTypeName());
0: 		}
0: 	}
0: 
0: 	/**
0: 		Generate the code for the returns Null on Null input check..
0: 		Stack must contain the DataDescriptorValue.
0: 	*/
0: 
0: 	private void generateReturnsNullOnNullCheck(MethodBuilder mb)
0: 	{
0: 		mb.dup();
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.Storable,
0: 								"isNull", "boolean", 0);
0: 
0: 		mb.conditionalIf();
0: 		  mb.push(true);
0: 		mb.startElseCode();
0: 		  mb.getField(returnsNullOnNullState);
0: 		mb.completeConditional();
0: 		
0: 		mb.putField(returnsNullOnNullState);
0: 		mb.endStatement();
0: 	}
0: 
0: 
0: 	/**
0: 	  *	Get the type name of the SQLValue we generate.
0: 	  *
0: 	  *	@return	name of interface corresponding to SQLValue
0: 	  *
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public	String	getSQLValueInterfaceName()
0: 		throws StandardException
0: 	{
0: 		return value.getTypeCompiler().interfaceName();
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	OTHER VALUE NODE METHODS
0: 	//
0: 	///////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	/**
0: 	 * Get the SQL ValueNode that is being converted to a JavaValueNode
0: 	 *
0: 	 * @return	The underlying SQL ValueNode
0: 	 */
0: 	ValueNode getSQLValueNode()
0: 	{
0: 		return value;
0: 	}
0: 
0: 	/** @see ValueNode#getConstantValueAsObject 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Object getConstantValueAsObject()
0: 		throws StandardException
0: 	{
0: 		return value.getConstantValueAsObject();
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 	
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		if (value != null && !v.stopTraversal())
0: 		{
0: 			value = (ValueNode)value.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================