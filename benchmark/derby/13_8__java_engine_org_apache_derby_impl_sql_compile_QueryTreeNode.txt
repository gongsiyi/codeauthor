2:eac0369: /*
80:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.QueryTreeNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
30:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:4fb136d: 
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:4fb136d: import java.sql.Types;
1:070d37e: import java.util.ArrayList;
1:070d37e: import java.util.List;
1:c9a1206: import java.util.Map;
1:0cefeda: import java.util.SortedSet;
1:4fb136d: import org.apache.derby.catalog.AliasInfo;
1:b4af7da: import org.apache.derby.catalog.TypeDescriptor;
1:b4af7da: import org.apache.derby.catalog.types.RowMultiSetImpl;
1:3bb140c: import org.apache.derby.catalog.types.SynonymAliasInfo;
1:d039ced: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1:4fb136d: import org.apache.derby.iapi.error.StandardException;
1:4fb136d: import org.apache.derby.iapi.reference.ClassName;
1:4fb136d: import org.apache.derby.iapi.reference.SQLState;
1:4fb136d: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:4fb136d: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:4fb136d: import org.apache.derby.iapi.services.context.ContextManager;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:a0dbbd7: import org.apache.derby.iapi.services.context.ContextService;
1:95a483d: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassFactory;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:4fb136d: import org.apache.derby.iapi.sql.StatementType;
1:a56ecfa: import org.apache.derby.iapi.sql.StatementUtil;
1:eac0369: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:9881ca4: import org.apache.derby.iapi.sql.compile.OptTrace;
1:eac0369: import org.apache.derby.iapi.sql.compile.Parser;
1:4fb136d: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:eac0369: import org.apache.derby.iapi.sql.compile.Visitable;
1:eac0369: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:4fb136d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:4fb136d: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:4fb136d: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:4fb136d: import org.apache.derby.iapi.types.DataValueDescriptor;
1:4fb136d: import org.apache.derby.iapi.types.TypeId;
1:4fb136d: import org.apache.derby.impl.sql.execute.GenericConstantActionFactory;
1:4fb136d: import org.apache.derby.impl.sql.execute.GenericExecutionFactory;
1:eac0369: 
28:eac0369: /**
1:eac0369:  * QueryTreeNode is the root class for all query tree nodes. All
1:eac0369:  * query tree nodes inherit from QueryTreeNode except for those that extend
1:eac0369:  * QueryTreeNodeVector.
46:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: public abstract class QueryTreeNode implements Visitable
56:eac0369: {
1:3bb140c:     static final int AUTOINCREMENT_START_INDEX = 0;
1:3bb140c:     static final int AUTOINCREMENT_INC_INDEX   = 1;
1:3bb140c:     static final int AUTOINCREMENT_IS_AUTOINCREMENT_INDEX   = 2;
1:6a5edfc: 	//Parser uses this static field to make a note if the autoincrement column 
1:6a5edfc: 	//is participating in create or alter table.
1:3bb140c:     static final int AUTOINCREMENT_CREATE_MODIFY  = 3;
1:d055adb:     static final int AUTOINCREMENT_CYCLE  = 4;
1:eac0369: 
1:7f1493a: 	private int		beginOffset = -1;		// offset into SQL input of the substring
1:eac0369: 	                                // which this query node encodes.
1:7f1493a: 	private int		endOffset = -1;
1:eac0369: 
1:eac0369: 	private ContextManager cm;
1:eac0369: 	private LanguageConnectionContext lcc;
1:eac0369: 	private GenericConstantActionFactory	constantActionFactory;
1:eac0369: 
1:070d37e:     private ArrayList<String>   visitableTags;
1:070d37e: 
1:eac0369: 	/**
1:2d2e717: 	 * In Derby SQL Standard Authorization, views, triggers and constraints 
1:2d2e717: 	 * execute with definer's privileges. Taking a specific eg of views
1:2d2e717: 	 * user1
1:2d2e717: 	 * create table t1 (c11 int);
1:2d2e717: 	 * create view v1 as select * from user1.t1;
1:2d2e717: 	 * grant select on v1 to user2;
1:2d2e717: 	 * user2
1:2d2e717: 	 * select * from user1.v1;
1:2d2e717: 	 * Running with definer's privileges mean that since user2 has select
1:2d2e717: 	 * privileges on view v1 owned by user1, then that is sufficient for user2
1:2d2e717: 	 * to do a select from view v1. View v1 underneath might access some
1:2d2e717: 	 * objects that user2 doesn't have privileges on, but that is not a problem
1:2d2e717: 	 * since views execute with definer's privileges. In order to implement this
1:2d2e717: 	 * behavior, when doing a select from view v1, we only want to check for
1:2d2e717: 	 * select privilege on view v1. While processing the underlying query for
1:2d2e717: 	 * view v1, we want to stop collecting the privilege requirements for the
1:2d2e717: 	 * query underneath. Following flag, isPrivilegeCollectionRequired is used
1:2d2e717: 	 * for this purpose. The flag will be true when we are the top level of view
1:2d2e717: 	 * and then it is turned off while we process the query underlying the view
1:2d2e717: 	 * v1.             
1:2d2e717: 	 */
1:e3720ab:     private boolean isPrivilegeCollectionRequired = true;
1:2d2e717: 
1:3bb140c:     QueryTreeNode(ContextManager cm) {
1:3bb140c:         this.cm = cm;
1:eac0369: 
1:3bb140c:         if (SanityManager.DEBUG)
1:3bb140c:        {
1:3bb140c:            SanityManager.ASSERT(cm != null,
1:3bb140c:                "cm not expected to be null");
1:98c7520:        }
1:3bb140c:     }
1:d6c2047: 
1:0cefeda:     /**
1:eac0369: 	 * Get the current ContextManager.
1:d6c2047: 	 *
1:eac0369: 	 * @return The current ContextManager.
1:eac0369: 	 */
1:3bb140c:     final ContextManager getContextManager()
1:d6c2047: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (cm == null)
1:eac0369: 				SanityManager.THROWASSERT("Null context manager in QueryTreeNode of type :" + this.getClass());
1:3bb140c: 		}
1:eac0369: 		return cm;
57:eac0369: 	}
1:3bb140c: 
1:3bb140c: 	/**
1:eac0369: 	  *	Gets the NodeFactory for this database.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the node factory for this database.
1:eac0369: 	  *
1:eac0369: 	  */
1:3bb140c:     public  final OptimizerFactory getOptimizerFactory()
1:eac0369: 	{
1:eac0369: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
1:3bb140c:                                                         getOptimizerFactory();
1:eac0369: 	}
1:108305b: 
1:9881ca4:     /** Convenience method for finding the optimizer tracer */
1:9881ca4:     public  OptTrace    getOptimizerTracer()    { return getLanguageConnectionContext().getOptimizerTracer(); }
1:9881ca4: 
1:9881ca4:     /** Convenience method for checking whether optimizer tracing is on */
1:9881ca4:     public  boolean optimizerTracingIsOn() { return getLanguageConnectionContext().optimizerTracingIsOn(); }
1:9881ca4:     
1:108305b: 	/**
1:eac0369: 	  *	Gets the constant action factory for this database.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the constant action factory.
1:eac0369: 	  */
1:eac0369: 	public	final GenericConstantActionFactory	getGenericConstantActionFactory()
1:eac0369: 	{
1:eac0369: 		if ( constantActionFactory == null )
1:eac0369: 		{
1:eac0369: 			GenericExecutionFactory	execFactory = (GenericExecutionFactory) getExecutionFactory();
1:eac0369: 			constantActionFactory = execFactory.getConstantActionFactory();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return constantActionFactory;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public	final	ExecutionFactory	getExecutionFactory()
1:eac0369: 	{
1:eac0369: 		ExecutionFactory	ef = getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory();
1:eac0369: 
1:eac0369: 		return ef;
1:eac0369: 	}
1:eac0369: 
1:2d2e717: 	/**
1:eac0369: 		Get the ClassFactory to use with this database.
1:eac0369: 	*/
1:eac0369: 	protected final ClassFactory getClassFactory() {
1:eac0369: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
1:eac0369: 			getClassFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets the LanguageConnectionContext for this connection.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the lcc for this connection
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	protected final LanguageConnectionContext	getLanguageConnectionContext()
1:eac0369: 	{
1:eac0369: 		if (lcc == null)
1:eac0369: 		{
1:eac0369: 			lcc = (LanguageConnectionContext) getContextManager().
1:eac0369: 							getContext(LanguageConnectionContext.CONTEXT_ID);
1:eac0369: 		}
1:eac0369: 		return lcc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the beginning offset of the SQL substring which this
1:eac0369: 	 * query node represents.
1:eac0369: 	 *
1:7f1493a: 	 * @return	The beginning offset of the SQL substring. -1 means unknown.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369:     public	int	getBeginOffset() { return beginOffset; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the beginning offset of the SQL substring which this
1:eac0369: 	 * query node represents.
1:eac0369: 	 *
1:6b50965: 	 * @param	beginOffset	The beginning offset of the SQL substring.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369:     public	void	setBeginOffset( int beginOffset )
1:eac0369: 	{
1:eac0369: 		this.beginOffset = beginOffset;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the ending offset of the SQL substring which this
1:eac0369: 	 * query node represents.
1:eac0369: 	 *
1:7f1493a: 	 * @return	The ending offset of the SQL substring. -1 means unknown.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	int	getEndOffset()  { return endOffset; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the ending offset of the SQL substring which this
1:eac0369: 	 * query node represents.
1:eac0369: 	 *
1:6b50965: 	 * @param	endOffset	The ending offset of the SQL substring.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public	void	setEndOffset( int endOffset )
1:eac0369: 	{
1:eac0369: 		this.endOffset = endOffset;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return header information for debug printing of this query
1:eac0369: 	 * tree node.
1:eac0369: 	 *
1:eac0369: 	 * @return	Header information for debug printing of this query
1:eac0369: 	 *		tree node.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	protected String	nodeHeader()
1:eac0369: 	{
16:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "\n" + this.getClass().getName() + '@' +
1:eac0369: 					Integer.toHexString(hashCode()) + "\n";
1:eac0369: 		}
1:2455f1a: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Format a node that has been converted to a String for printing
1:eac0369: 	 * as part of a tree.  This method indents the String to the given
1:eac0369: 	 * depth by inserting tabs at the beginning of the string, and also
1:eac0369: 	 * after every newline.
1:eac0369: 	 *
1:eac0369: 	 * @param nodeString	The node formatted as a String
1:eac0369: 	 * @param depth		The depth to indent the given node
1:eac0369: 	 *
1:eac0369: 	 * @return	The node String reformatted with tab indentation
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     static String formatNodeString(String nodeString, int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:3bb140c:             StringBuilder   nodeStringBuilder = new StringBuilder(nodeString);
1:eac0369: 			int		pos;
1:eac0369: 			char		c;
1:eac0369: 			char[]		indent = new char[depth];
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Form an array of tab characters for indentation.
1:eac0369: 			*/
1:eac0369: 			while (depth > 0)
1:eac0369: 			{
1:eac0369: 				indent[depth - 1] = '\t';
1:eac0369: 				depth--;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Indent the beginning of the string */
1:3bb140c:             nodeStringBuilder.insert(0, indent);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Look for newline characters, except for the last character.
1:eac0369: 			** We don't want to indent after the last newline.
1:eac0369: 			*/
1:3bb140c:             for (pos = 0; pos < nodeStringBuilder.length() - 1; pos++)
1:eac0369: 			{
1:3bb140c:                 c = nodeStringBuilder.charAt(pos);
1:eac0369: 				if (c == '\n')
1:eac0369: 				{
1:eac0369: 					/* Indent again after each newline */
1:3bb140c:                     nodeStringBuilder.insert(pos + 1, indent);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:3bb140c:             return nodeStringBuilder.toString();
1:eac0369: 		}
5:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print this tree for debugging purposes.  This recurses through
1:eac0369: 	 * all the sub-nodes and prints them indented by their depth in
1:eac0369: 	 * the tree.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void treePrint()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			debugPrint(nodeHeader());
1:c9a1206: 			String thisStr = formatNodeString(this.toString(), 0);
1:c9a1206: 
1:c9a1206: 			if (containsInfo(thisStr) &&
1:c9a1206: 					!SanityManager.DEBUG_ON("DumpBrief")) {
1:c9a1206: 				debugPrint(thisStr);
1:c9a1206: 			}
1:c9a1206: 
1:eac0369: 			printSubNodes(0);
1:eac0369: 			debugFlush();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2060c4a: 	 * Print call stack for debug purposes
1:2060c4a: 	 */
1:2060c4a: 
1:3bb140c:     void stackPrint()
1:2060c4a: 	{
1:2060c4a: 		if (SanityManager.DEBUG)
1:2060c4a: 		{
1:2060c4a: 			debugPrint("Stacktrace:\n");
1:2060c4a: 			Exception e = new Exception("dummy");
1:2060c4a:             StackTraceElement[] st= e.getStackTrace();
1:2060c4a:             for (int i=0; i<st.length; i++) {
1:2060c4a:                 debugPrint(st[i] + "\n");
1:2060c4a:             }
1:2060c4a: 
1:2060c4a: 			debugFlush();
1:2060c4a: 		}
1:2060c4a: 	}
1:2060c4a: 
1:2060c4a: 	/**
1:eac0369: 	 * Print this tree for debugging purposes.  This recurses through
1:eac0369: 	 * all the sub-nodes and prints them indented by their depth in
1:eac0369: 	 * the tree, starting with the given indentation.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree, thus,
1:eac0369: 	 *			the amount to indent it when printing it.
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void treePrint(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:71c8e86: 			Map<Object,Object> printed =
1:c9a1206: 				getLanguageConnectionContext().getPrintedObjectsMap();
1:c9a1206: 
1:c9a1206: 			if (printed.containsKey(this)) {
1:c9a1206: 				debugPrint(formatNodeString(nodeHeader(), depth));
1:c9a1206: 				debugPrint(formatNodeString("***truncated***\n", depth));
1:c9a1206: 			} else {
1:c9a1206: 				printed.put(this, null);
1:c9a1206: 				debugPrint(formatNodeString(nodeHeader(), depth));
1:c9a1206: 				String thisStr = formatNodeString(this.toString(), depth);
1:c9a1206: 
1:c9a1206: 				if (containsInfo(thisStr) &&
1:c9a1206: 						!SanityManager.DEBUG_ON("DumpBrief")) {
1:c9a1206: 					debugPrint(thisStr);
1:c9a1206: 				}
1:c9a1206: 
1:2060c4a: 				if (thisStr.charAt(thisStr.length()-1) != '\n') {
1:2060c4a: 					debugPrint("\n");
1:2060c4a: 				}
1:2060c4a: 
1:c9a1206: 				printSubNodes(depth);
1:c9a1206: 			}
1:c9a1206: 
1:eac0369: 		}
1:eac0369: 	}
1:c9a1206: 
1:eac0369: 
1:c9a1206: 	private static boolean containsInfo(String str) {
1:c9a1206: 		for (int i = 0; i < str.length(); i++) {
1:c9a1206: 			if (str.charAt(i) != '\t' && str.charAt(i) != '\n') {
1:c9a1206: 				return true;
1:c9a1206: 			}
1:c9a1206: 		}
1:c9a1206: 		return false;
1:c9a1206: 	}
1:c9a1206: 
1:eac0369: 	/**
1:eac0369: 	 * Print a String for debugging
1:eac0369: 	 *
1:eac0369: 	 * @param outputString	The String to print
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     static void debugPrint(String outputString)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.GET_DEBUG_STREAM().print(outputString);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Flush the debug stream out
1:eac0369: 	 */
1:eac0369: 	protected static void debugFlush()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.GET_DEBUG_STREAM().flush();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print the sub-nodes of this node.
1:eac0369: 	 *
1:eac0369: 	 * Each sub-class of QueryTreeNode is expected to provide its own
1:eac0369: 	 * printSubNodes() method.  In each case, it calls super.printSubNodes(),
1:eac0369: 	 * passing along its depth, to get the sub-nodes of the super-class.
1:eac0369: 	 * Then it prints its own sub-nodes by calling treePrint() on each
1:eac0369: 	 * of its members that is a type of QueryTreeNode.  In each case where
1:eac0369: 	 * it calls treePrint(), it should pass "depth + 1" to indicate that
1:eac0369: 	 * the sub-node should be indented one more level when printing.
1:eac0369: 	 * Also, it should call printLabel() to print the name of each sub-node
1:eac0369: 	 * before calling treePrint() on the sub-node, so that the reader of
1:eac0369: 	 * the printed tree can tell what the sub-node is.
1:eac0369: 	 *
1:eac0369: 	 * This printSubNodes() exists in here merely to act as a backstop.
1:eac0369: 	 * In other words, the calls to printSubNodes() move up the type
1:eac0369: 	 * hierarchy, and in this node the calls stop.
1:eac0369: 	 *
1:eac0369: 	 * I would have liked to put the call to super.printSubNodes() in
1:eac0369: 	 * this super-class, but Java resolves "super" statically, so it
1:eac0369: 	 * wouldn't get to the right super-class.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth to indent the sub-nodes
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Format this node as a string
1:eac0369: 	 *
1:eac0369: 	 * Each sub-class of QueryTreeNode should implement its own toString()
1:eac0369: 	 * method.  In each case, toString() should format the class members
1:eac0369: 	 * that are not sub-types of QueryTreeNode (printSubNodes() takes care
1:eac0369: 	 * of following the references to sub-nodes, and toString() takes care
1:eac0369: 	 * of all members that are not sub-nodes).  Newlines should be used
1:eac0369: 	 * liberally - one good way to do this is to have a newline at the
1:eac0369: 	 * end of each formatted member.  It's also a good idea to put the
1:eac0369: 	 * name of each member in front of the formatted value.  For example,
1:eac0369: 	 * the code might look like:
1:eac0369: 	 *
1:eac0369: 	 * "memberName: " + memberName + "\n" + ...
1:eac0369: 	 *
1:c9a1206: 	 * Vector members containing subclasses of QueryTreeNode should subclass
1:c9a1206: 	 * QueryTreeNodeVector. Such subclasses form a special case: These classes
1:c9a1206: 	 * should not implement printSubNodes, since there is generic handling in
1:c9a1206: 	 * QueryTreeNodeVector.  They should only implement toString if they
1:c9a1206: 	 * contain additional members.
1:c9a1206: 	 *
1:eac0369: 	 * @return	This node formatted as a String
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print the given label at the given indentation depth.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of indentation to use when printing
1:eac0369: 	 *			the label
1:eac0369: 	 * @param label		The String to print
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void printLabel(int depth, String label)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			debugPrint(formatNodeString(label, depth));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
18:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean referencesSessionSchema()
3:eac0369: 		throws StandardException
1:daffaee: 	{
3:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Checks if the passed schema descriptor is for SESSION schema
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the passed schema descriptor is for SESSION schema
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	final boolean isSessionSchema(SchemaDescriptor sd)
1:eac0369: 	{
1:eac0369: 		return isSessionSchema(sd.getSchemaName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Checks if the passed schema name is for SESSION schema
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the passed schema name is for SESSION schema
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     static boolean isSessionSchema(String schemaName)
1:eac0369: 	{
1:eac0369: 		return SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME.equals(schemaName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:7bfb37a:      * Triggers, constraints and views get executed with their definers'
1:7bfb37a:      * privileges and they can exist in the system only if their definers
1:7bfb37a:      * still have all the privileges to create them. Based on this, any
1:2d2e717: 	 * time a trigger/view/constraint is executing, we do not need to waste
1:2d2e717: 	 * time in checking if the definer still has the right set of privileges.
1:7bfb37a:      * At compile time, we will make sure that we do not collect the privilege
1:2d2e717: 	 * requirement for objects accessed with definer privileges by calling the
1:2d2e717: 	 * following method. 
1:2d2e717: 	 */
1:7bfb37a: 	final void disablePrivilegeCollection()
1:2d2e717: 	{
1:2d2e717: 		isPrivilegeCollectionRequired = false;
1:2d2e717: 	}
1:2d2e717: 
1:2d2e717: 	/**
1:2d2e717: 	 * Return true from this method means that we need to collect privilege
1:2d2e717: 	 * requirement for this node. For following cases, this method will
1:2d2e717: 	 * return true.
1:2d2e717: 	 * 1)execute view - collect privilege to access view but do not collect
1:2d2e717: 	 * privilege requirements for objects accessed by actual view uqery
1:2d2e717: 	 * 2)execute select - collect privilege requirements for objects accessed
1:2d2e717: 	 * by select statement
1:2d2e717: 	 * 3)create view -  collect privileges for select statement : the select
1:2d2e717: 	 * statement for create view falls under 2) category above.
1:2d2e717: 	 * 
1:2d2e717: 	 * @return true if need to collect privilege requirement for this node
1:2d2e717: 	 */
1:3bb140c:     boolean isPrivilegeCollectionRequired()
1:070d37e:         throws StandardException
1:2d2e717: 	{
1:070d37e:         return
1:070d37e:             isPrivilegeCollectionRequired &&
1:070d37e:             getCompilerContext().passesPrivilegeFilters( this );
1:2d2e717: 	}
1:2d2e717: 
1:2d2e717: 	/**
1:eac0369: 	 * Do the code generation for this node.  This is a place-holder
1:eac0369: 	 * method - it should be over-ridden in the sub-classes.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method for the generated code to go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
2:eac0369: 		throw StandardException.newException(SQLState.LANG_UNABLE_TO_GENERATE,
2:eac0369: 			this.nodeHeader());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Parameter info is stored in the compiler context.
1:eac0369: 	 * Hide this from the callers.
1:eac0369: 	 *
1:eac0369: 	 *
2:eac0369: 	 * @return	null
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor[] getParameterTypes()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:b49cc55:         return ((CompilerContextImpl) getCompilerContext()).getParameterTypes();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This creates a class that will do the work that's constant
1:eac0369: 	 * across all Executions of a PreparedStatement. It's up to
1:eac0369: 	 * our subclasses to override this method if they need to compile
1:eac0369: 	 * constant actions into PreparedStatements.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 		return	null;
1:eac0369: 	}
1:8a93440: 
1:eac0369: 	/**
1:eac0369: 	 * Get the DataDictionary
1:eac0369: 	 *
1:eac0369: 	 * @return The DataDictionary
1:eac0369: 	 *
1:eac0369: 	 */
1:3bb140c:     final public DataDictionary getDataDictionary()
1:eac0369: 	{
1:eac0369: 		return getLanguageConnectionContext().getDataDictionary();
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     final DependencyManager getDependencyManager()
1:eac0369: 	{
1:eac0369: 		return getDataDictionary().getDependencyManager();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the CompilerContext
1:eac0369: 	 *
1:eac0369: 	 * @return The CompilerContext
1:eac0369: 	 */
1:eac0369: 	protected final CompilerContext getCompilerContext()
1:eac0369: 	{
1:eac0369: 		return (CompilerContext) getContextManager().
1:eac0369: 										getContext(CompilerContext.CONTEXT_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeCompiler associated with the given TypeId
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The TypeId to get a TypeCompiler for
1:eac0369: 	 *
1:eac0369: 	 * @return	The corresponding TypeCompiler
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	protected final TypeCompiler getTypeCompiler(TypeId typeId)
1:eac0369: 	{
1:eac0369: 		return
1:eac0369: 		  getCompilerContext().getTypeCompilerFactory().getTypeCompiler(typeId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept a visitor, and call {@code v.visit()} on child nodes as
1:dd2f5a8: 	 * necessary. Sub-classes should not override this method, but instead
1:dd2f5a8: 	 * override the {@link #acceptChildren(Visitor)} method.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:dd2f5a8: 	public final Visitable accept(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		final boolean childrenFirst = v.visitChildrenFirst(this);
1:dd2f5a8: 		final boolean skipChildren = v.skipChildren(this);
1:dd2f5a8: 
1:dd2f5a8: 		if (childrenFirst && !skipChildren && !v.stopTraversal()) {
1:dd2f5a8: 			acceptChildren(v);
1:dd2f5a8: 		}
1:dd2f5a8: 
1:dd2f5a8: 		final Visitable ret = v.stopTraversal() ? this : v.visit(this);
1:dd2f5a8: 
1:dd2f5a8: 		if (!childrenFirst && !skipChildren && !v.stopTraversal()) {
1:dd2f5a8: 			acceptChildren(v);
1:dd2f5a8: 		}
1:dd2f5a8: 
1:dd2f5a8: 		return ret;
1:dd2f5a8: 	}
1:dd2f5a8: 
1:dd2f5a8: 	/**
1:dd2f5a8: 	 * Accept a visitor on all child nodes. All sub-classes that add fields
1:dd2f5a8: 	 * that should be visited, should override this method and call
1:dd2f5a8: 	 * {@code accept(v)} on all visitable fields, as well as
1:dd2f5a8: 	 * {@code super.acceptChildren(v)} to make sure all visitable fields
1:dd2f5a8: 	 * defined by the super-class are accepted too.
1:dd2f5a8: 	 *
1:dd2f5a8: 	 * @param v the visitor
1:dd2f5a8: 	 * @throws StandardException on errors raised by the visitor
1:dd2f5a8: 	 */
1:dd2f5a8: 	void acceptChildren(Visitor v) throws StandardException {
1:dd2f5a8: 		// no children
1:eac0369: 	}
1:eac0369: 
1:070d37e:     public  void    addTag( String tag )
1:070d37e:     {
1:070d37e:         if ( visitableTags == null ) { visitableTags = new ArrayList<String>(); }
1:070d37e:         visitableTags.add( tag );
1:070d37e:     }
1:070d37e: 
1:070d37e:     public  boolean taggedWith( String tag )
1:070d37e:     {
1:070d37e:         if ( visitableTags == null ) { return false; }
1:070d37e:         else { return visitableTags.contains( tag ); }
1:070d37e:     }
1:070d37e: 
1:070d37e:     /** Copy the tags from another QueryTreeNode */
1:070d37e:     protected   void    copyTagsFrom( QueryTreeNode that )
1:070d37e:     {
1:070d37e:         if ( that.visitableTags == null ) { return; }
1:070d37e:         else
1:070d37e:         {
1:070d37e:             for ( String tag : that.visitableTags ) { addTag( tag ); }
1:070d37e:         }
1:070d37e:     }
1:070d37e:     
1:eac0369: 	/**
1:eac0369: 	 * Get the int value of a Property
1:eac0369: 	 *
1:eac0369: 	 * @param value		Property value as a String
1:eac0369: 	 * @param key		Key value of property
1:eac0369: 	 *
1:eac0369: 	 * @return	The int value of the property
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	protected int getIntProperty(String value, String key)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int intVal = -1;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			intVal = Integer.parseInt(value);
1:eac0369: 		}
1:eac0369: 		catch (NumberFormatException nfe)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
1:eac0369: 					value, key);
1:eac0369: 		}
1:eac0369: 		return intVal;
1:eac0369: 	}
1:be0b54f: 	
1:eac0369: 	/**
1:af1c18c:      * Get the long value of a Property
1:af1c18c:      *
1:af1c18c:      * @param value     Property value as a String
1:af1c18c:      * @param key       Key value of property
1:af1c18c:      *
1:af1c18c:      * @return  The long value of the property
1:af1c18c:      *
1:af1c18c:      * @exception StandardException     Thrown on failure
1:af1c18c:      */
1:af1c18c:     protected long getLongProperty(String value, String key)
1:af1c18c:         throws StandardException
1:af1c18c:     {
1:af1c18c:         long longVal = -1;
1:af1c18c:         try
1:af1c18c:         {
1:af1c18c:             longVal = Long.parseLong(value);
1:af1c18c:         }
1:af1c18c:         catch (NumberFormatException nfe)
1:af1c18c:         {
1:af1c18c:             throw StandardException.newException(
1:af1c18c:                 SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE,
1:af1c18c:                 value,
1:af1c18c:                 key);
1:af1c18c:         }
1:af1c18c:         return longVal;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c:     /**
1:be0b54f: 	** Parse the a SQL statement from the body
1:be0b54f: 	* of another SQL statement. Pushes and pops a
1:be0b54f: 	* separate CompilerContext to perform the compilation.
1:be0b54f: 	*/
1:be0b54f: 	StatementNode parseStatement(String sql, boolean internalSQL) throws StandardException
1:eac0369: 	{
1:d9878ca:         return (StatementNode)
1:d9878ca:                 parseStatementOrSearchCondition(sql, internalSQL, true);
1:d9878ca:     }
1:d9878ca: 
1:d9878ca:     /**
1:d9878ca:      * Parse an SQL fragment that represents a {@code <search condition>}.
1:d9878ca:      *
1:d9878ca:      * @param sql a fragment of an SQL statement
1:d9878ca:      * @param internalSQL {@code true} if the SQL fragment is allowed to
1:d9878ca:      *   contain internal syntax, {@code false} otherwise
1:d9878ca:      * @return a {@code ValueNode} representing the parse tree of the
1:d9878ca:      *   SQL fragment
1:d9878ca:      * @throws StandardException if an error happens while parsing
1:d9878ca:      */
1:d9878ca:     ValueNode parseSearchCondition(String sql, boolean internalSQL)
1:d9878ca:         throws StandardException
1:d9878ca:     {
1:d9878ca:         return (ValueNode)
1:d9878ca:                 parseStatementOrSearchCondition(sql, internalSQL, false);
1:d9878ca:     }
1:d9878ca: 
1:d9878ca:     /**
1:d9878ca:      * Parse a full SQL statement or a fragment representing a {@code <search
1:d9878ca:      * condition>}. This is a worker method that contains common logic for
1:d9878ca:      * {@link #parseStatement} and {@link #parseSearchCondition}.
1:d9878ca:      *
1:d9878ca:      * @param sql the SQL statement or fragment to parse
1:d9878ca:      * @param internalSQL {@code true} if it is allowed to contain internal
1:d9878ca:      *   syntax, {@code false} otherwise
1:d9878ca:      * @param isStatement {@code true} if {@code sql} is a full SQL statement,
1:d9878ca:      *   {@code false} if it is a fragment
1:d9878ca:      * @return a parse tree
1:d9878ca:      * @throws StandardException if an error happens while parsing
1:d9878ca:      */
1:d9878ca:     private Visitable parseStatementOrSearchCondition(
1:d9878ca:             String sql, boolean internalSQL, boolean isStatement)
1:d9878ca:         throws StandardException
1:d9878ca:     {
1:be0b54f: 		/*
1:be0b54f: 		** Get a new compiler context, so the parsing of the text
1:be0b54f: 		** doesn't mess up anything in the current context 
1:be0b54f: 		*/
1:be0b54f: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1:be0b54f: 		CompilerContext newCC = lcc.pushCompilerContext();
1:be0b54f: 		if (internalSQL)
1:be0b54f: 		    newCC.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1:eac0369: 
1:be0b54f: 		try
1:be0b54f: 		{
1:be0b54f: 			Parser p = newCC.getParser();
1:d9878ca:             return isStatement
1:d9878ca:                     ? p.parseStatement(sql)
1:d9878ca:                     : p.parseSearchCondition(sql);
1:108305b: 		}
1:eac0369: 
1:be0b54f: 		finally
1:be0b54f: 		{
1:be0b54f: 			lcc.popCompilerContext(newCC);
1:be0b54f: 		}
1:be0b54f: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the type of statement, something from
1:eac0369: 	 * StatementType.
1:eac0369: 	 *
1:eac0369: 	 * @return the type of statement
1:eac0369: 	 */
1:eac0369: 	protected int getStatementType()
1:eac0369: 	{
1:eac0369: 		return StatementType.UNKNOWN;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d1fbe3c: 	 * Get a ConstantNode to represent a typed null value. 
1:eac0369: 	 *
1:d1fbe3c: 	 * @param type Type of the null node.
1:eac0369: 	 *
1:eac0369: 	 * @return	A ConstantNode with the specified type, and a value of null
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:8fe3166:     ConstantNode getNullNode(DataTypeDescriptor type)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         switch (type.getTypeId().getJDBCTypeId())
1:3bb140c:         {
1:3bb140c:           case Types.VARCHAR: {
1:3bb140c:               CharConstantNode ccn = new CharConstantNode(
1:2706d1f:                       CharConstantNode.K_VARCHAR,
1:3bb140c:                       type.getTypeId(),
1:3bb140c:                       cm);
1:3bb140c:               ccn.setType(type.getNullabilityType(true));
1:3bb140c:               return ccn;
1:3bb140c:           }
1:3bb140c:           case Types.CHAR: {
1:3bb140c:               CharConstantNode ccn = new CharConstantNode(type.getTypeId(), cm);
1:3bb140c:               ccn.setType(type.getNullabilityType(true));
1:3bb140c:               return ccn;
1:3bb140c:           }
1:3bb140c:           case Types.TINYINT:
1:3bb140c:           case Types.SMALLINT:
1:3bb140c:           case Types.INTEGER:
1:3bb140c:           case Types.BIGINT:
1:3bb140c:           case Types.REAL:
1:3bb140c:           case Types.DOUBLE:
1:3bb140c:           case Types.DECIMAL: {
1:3bb140c:               NumericConstantNode nvn =
1:3bb140c:                       new NumericConstantNode(type.getTypeId(), cm);
1:3bb140c:               nvn.setType(type.getNullabilityType(true)); // SUPERFLUOUS? FIXME
1:3bb140c:               return nvn;
1:3bb140c:           }
1:3bb140c:           case Types.NUMERIC: {
1:3bb140c:               // Map this to DECIMAL
1:3bb140c:               NumericConstantNode ncn = new NumericConstantNode(
1:3bb140c:                       TypeId.getBuiltInTypeId(Types.DECIMAL), cm);
1:3bb140c:               ncn.setType(type.getNullabilityType(true)); // SUPERFLUOUS? FIXME
1:3bb140c:               return ncn;
1:3bb140c:           }
1:eac0369: 		  case Types.DATE:
1:eac0369: 		  case Types.TIME:
1:3bb140c:           case Types.TIMESTAMP: {
1:3bb140c:               UserTypeConstantNode
1:3bb140c:                       utcn = new UserTypeConstantNode(type.getTypeId(), cm);
1:3bb140c:               utcn.setType(type.getNullabilityType(true));
1:3bb140c:               return utcn;
1:3bb140c:           }
1:3bb140c:           case Types.BINARY: {
1:3bb140c:               BitConstantNode bcn =
1:3bb140c:                       new BitConstantNode(type.getTypeId(), cm);
1:3bb140c:               bcn.setType(type.getNullabilityType(true));
1:3bb140c:               return bcn;
1:3bb140c:           }
1:3bb140c:           case Types.VARBINARY: {
1:3bb140c:               VarbitConstantNode vcn =
1:3bb140c:                       new VarbitConstantNode(type.getTypeId(), cm);
1:3bb140c:               vcn.setType(type.getNullabilityType(true));
1:3bb140c:               return vcn;
1:3bb140c:           }
1:3bb140c:           case Types.LONGVARCHAR: {
1:3bb140c:               CharConstantNode ccn = new CharConstantNode(
1:2706d1f:                   CharConstantNode.K_LONGVARCHAR, type.getTypeId(), cm);
1:3bb140c:               ccn.setType(type.getNullabilityType(true));
1:3bb140c:               return ccn;
1:3bb140c:           }
1:3bb140c:           case Types.CLOB: {
1:3bb140c:               CharConstantNode ccn = new CharConstantNode(
1:2706d1f:                   CharConstantNode.K_CLOB, type.getTypeId(), cm);
1:3bb140c:               ccn.setType(type.getNullabilityType(true));
1:3bb140c:               return ccn;
1:3bb140c:           }
1:3bb140c:           case Types.LONGVARBINARY: {
1:3bb140c:               VarbitConstantNode vcn =
1:3bb140c:                       new VarbitConstantNode(type.getTypeId(), cm);
1:3bb140c:               vcn.setType(type.getNullabilityType(true));
1:3bb140c:               return vcn;
1:3bb140c:           }
1:3bb140c:           case Types.BLOB: {
1:3bb140c:               VarbitConstantNode vcn =
1:3bb140c:                   new VarbitConstantNode(type.getTypeId(), cm);
1:3bb140c:               vcn.setType(type.getNullabilityType(true));
1:3bb140c:               return vcn;
1:3bb140c:           }
1:eac0369: 
1:3bb140c:         case Types.SQLXML: {
1:3bb140c:               XMLConstantNode xcn =
1:3bb140c:                   new XMLConstantNode(type.getTypeId(), cm);
1:3bb140c:              xcn.setType(type.getNullabilityType(true));
1:3bb140c:               return xcn;
1:3bb140c:           }
1:3bb140c:           case Types.BOOLEAN: {
1:3bb140c:               BooleanConstantNode bCn =
1:3bb140c:                       new BooleanConstantNode(type.getTypeId(), cm);
1:3bb140c:               bCn.setType(type.getNullabilityType(true));
1:3bb140c:               return bCn;
1:3bb140c:           }
1:eac0369: 		  default:
1:3bb140c:            if (type.getTypeId().userType()) {
1:3bb140c:                 UserTypeConstantNode utcn =
1:3bb140c:                         new UserTypeConstantNode(type.getTypeId(), cm);
1:3bb140c:                 utcn.setType(type.getNullabilityType(true));
1:3bb140c:                 return utcn;
1:3bb140c:            } else {
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.THROWASSERT( "Unknown type " + 
1:d1fbe3c:                         type.getTypeId().getSQLTypeName() + " in getNullNode");
4:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Translate a Default node into a default value, given a type descriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param typeDescriptor	A description of the required data type.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     DataValueDescriptor convertDefaultNode(DataTypeDescriptor typeDescriptor)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Override in cases where node type
1:eac0369: 		** can be converted to default value.
1:eac0369: 		*/
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public	TableName	makeTableName
3:eac0369: 	(
1:eac0369: 		String	schemaName,
1:eac0369: 		String	flatName
2:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:95a483d:         return makeTableName
1:3bb140c:             ( getContextManager(), schemaName, flatName );
1:95a483d: 	}
1:95a483d: 
1:95a483d: 	public	static  TableName	makeTableName
1:95a483d: 	(
1:95a483d:         ContextManager contextManager,
1:95a483d: 		String	schemaName,
1:95a483d: 		String	flatName
1:95a483d: 	)
1:95a483d: 		throws StandardException
1:95a483d: 	{
1:3bb140c:         return new TableName(schemaName, flatName, contextManager);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean isAtomic() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("isAtomic should not be called for this  class: " + getClass().getName());
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the descriptor for the named table within the given schema.
1:eac0369: 	 * If the schema parameter is NULL, it looks for the table in the
1:eac0369: 	 * current (default) schema. Table descriptors include object ids,
1:eac0369: 	 * object types (table, view, etc.)
1:eac0369: 	 * If the schema is SESSION, then before looking into the data dictionary
1:eac0369: 	 * for persistent tables, it first looks into LCC for temporary tables.
1:eac0369: 	 * If no temporary table tableName found for the SESSION schema, then it goes and
1:eac0369: 	 * looks through the data dictionary for persistent table
1:eac0369: 	 * We added getTableDescriptor here so that we can look for non data dictionary
1:eac0369: 	 * tables(ie temp tables) here. Any calls to getTableDescriptor in data dictionary
1:eac0369: 	 * should be only for persistent tables
1:eac0369: 	 *
1:eac0369: 	 * @param tableName	The name of the table to get the descriptor for
1:eac0369: 	 * @param schema	The descriptor for the schema the table lives in.
1:eac0369: 	 *			If null, use the current (default) schema.
1:eac0369: 	 *
1:eac0369: 	 * @return	The descriptor for the table, null if table does not
1:eac0369: 	 *		exist.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	protected final TableDescriptor getTableDescriptor(String tableName,
1:eac0369: 					SchemaDescriptor schema)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		TableDescriptor retval;
1:eac0369: 
1:eac0369: 		//Following if means we are dealing with SESSION schema.
1:eac0369: 		if (isSessionSchema(schema))
1:eac0369: 		{
1:eac0369: 			//First we need to look in the list of temporary tables to see if this table is a temporary table.
1:eac0369: 			retval = getLanguageConnectionContext().getTableDescriptorForDeclaredGlobalTempTable(tableName);
1:eac0369: 			if (retval != null)
1:eac0369: 				return retval; //this is a temporary table
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//Following if means we are dealing with SESSION schema and we are dealing with in-memory schema (ie there is no physical SESSION schema)
1:eac0369: 		//If following if is true, it means SESSION.table is not a declared table & it can't be physical SESSION.table
1:eac0369: 		//because there is no physical SESSION schema
1:eac0369: 		if (schema.getUUID() == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		//it is not a temporary table, so go through the data dictionary to find the physical persistent table
1:0978789: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableName, schema,
1:0978789:                 this.getLanguageConnectionContext().getTransactionCompile());
1:582425f: 		if (td == null || td.isSynonymDescriptor())
1:eac0369: 			return null;
1:d039ced: 
1:582425f: 		return td;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the descriptor for the named schema. If the schemaName
1:20d5490: 	 * parameter is NULL, it gets the descriptor for the current
1:20d5490: 	 * compilation schema.
1:20d5490:      * 
1:20d5490:      * QueryTreeNodes must obtain schemas using this method or the two argument
1:20d5490:      * version of it. This is to ensure that the correct default compliation schema
1:20d5490:      * is returned and to allow determination of if the statement being compiled
1:20d5490:      * depends on the current schema. 
1:20d5490:      * 
1:20d5490:      * Schema descriptors include authorization ids and schema ids.
1:eac0369: 	 * SQL92 allows a schema to specify a default character set - we will
1:eac0369: 	 * not support this.  Will check default schema for a match
1:eac0369: 	 * before scanning a system table.
1:eac0369: 	 * 
1:eac0369: 	 * @param schemaName	The name of the schema we're interested in.
1:eac0369: 	 *			If the name is NULL, get the descriptor for the
1:20d5490: 	 *			current compilation schema.
1:eac0369: 	 *
1:eac0369: 	 * @return	The descriptor for the schema.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//return getSchemaDescriptor(schemaName, schemaName != null);
1:eac0369: 		return getSchemaDescriptor(schemaName, true);
1:eac0369: 	}
1:20d5490:     
1:20d5490:     /**
1:20d5490:      * Get the descriptor for the named schema. If the schemaName
1:20d5490:      * parameter is NULL, it gets the descriptor for the current
1:20d5490:      * compilation schema.
1:20d5490:      * 
1:20d5490:      * QueryTreeNodes must obtain schemas using this method or the single argument
1:20d5490:      * version of it. This is to ensure that the correct default compliation schema
1:20d5490:      * is returned and to allow determination of if the statement being compiled
1:20d5490:      * depends on the current schema. 
1:20d5490:      * 
1:20d5490:      * @param schemaName The name of the schema we're interested in.
1:20d5490:      * If the name is NULL, get the descriptor for the current compilation schema.
1:20d5490:      * @param raiseError True to raise an error if the schema does not exist,
1:20d5490:      * false to return null if the schema does not exist.
1:20d5490:      * @return Valid SchemaDescriptor or null if raiseError is false and the
1:20d5490:      * schema does not exist. 
1:20d5490:      * @throws StandardException Schema does not exist and raiseError is true.
1:20d5490:      */
1:eac0369: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName, boolean raiseError)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:a56ecfa:         return StatementUtil.getSchemaDescriptor
1:a56ecfa:             (
1:a56ecfa:              schemaName,
1:a56ecfa:              raiseError,
1:a56ecfa:              getDataDictionary(),
1:a56ecfa:              getLanguageConnectionContext(),
1:a56ecfa:              getCompilerContext()
1:a56ecfa:              );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:582425f: 	 * Resolve table/view reference to a synonym. May have to follow a synonym chain.
1:eac0369: 	 *
1:582425f: 	 * @param	tabName to match for a synonym
1:eac0369: 	 *
1:582425f: 	 * @return	Synonym TableName if a match is found, NULL otherwise.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     TableName resolveTableToSynonym(TableName tabName) throws StandardException
1:eac0369: 	{
1:582425f: 		DataDictionary dd = getDataDictionary();
1:582425f: 		String nextSynonymTable = tabName.getTableName();
1:582425f: 		String nextSynonymSchema = tabName.getSchemaName();
1:582425f: 		boolean found = false;
1:eac0369: 		CompilerContext cc = getCompilerContext();
1:eac0369: 
1:582425f: 		// Circular synonym references should have been detected at the DDL time, so
1:582425f: 		// the following loop shouldn't loop forever.
1:582425f: 		for (;;)
1:eac0369: 		{
1:582425f: 			SchemaDescriptor nextSD = getSchemaDescriptor(nextSynonymSchema, false);
1:582425f: 			if (nextSD == null || nextSD.getUUID() == null)
16:eac0369: 				break;
1:5a0cfa2: 	
1:582425f: 			AliasDescriptor nextAD = dd.getAliasDescriptor(nextSD.getUUID().toString(),
1:582425f: 						 nextSynonymTable, AliasInfo.ALIAS_NAME_SPACE_SYNONYM_AS_CHAR);
1:582425f: 			if (nextAD == null)
1:d1fbe3c: 				break;
1:d1fbe3c: 
1:81ad58c: 			/* Query is dependent on the AliasDescriptor */
1:81ad58c: 			cc.createDependency(nextAD);
1:d1fbe3c: 
1:582425f: 			found = true;
1:582425f: 			SynonymAliasInfo info = ((SynonymAliasInfo)nextAD.getAliasInfo());
1:582425f: 			nextSynonymTable = info.getSynonymTable();
1:582425f: 			nextSynonymSchema = info.getSynonymSchema();
1:eac0369: 		}
1:d1fbe3c: 
1:582425f: 		if (!found)
1:eac0369: 			return null;
1:eac0369: 
1:3bb140c:         TableName tableName = new TableName(
1:3bb140c:                 nextSynonymSchema,
1:3bb140c:                 nextSynonymTable,
1:3bb140c:                 getContextManager());
1:3bb140c: 
1:582425f: 		return tableName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2e1b5e8: 	 * Verify that a java class exists, is accessible (public)
1:2e1b5e8:      * and not a class representing a primitive type.
1:eac0369: 	 * @param javaClassName	The name of the java class to resolve.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:2e1b5e8: 	void verifyClassExist(String javaClassName)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1:eac0369: 
1:eac0369: 		Throwable reason = null;
1:eac0369: 		boolean foundMatch = false;
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			foundMatch = classInspector.accessible(javaClassName);
1:eac0369: 
1:eac0369: 		} catch (ClassNotFoundException cnfe) {
1:eac0369: 
1:eac0369: 			reason = cnfe;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!foundMatch)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST2, reason, javaClassName);
1:eac0369: 
1:eac0369: 		if (ClassInspector.primitiveType(javaClassName))
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST3, javaClassName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * set the Information gathered from the parent table that is 
1:28f9484:      * required to perform a referential action on dependent table.
1:eac0369: 	 */
1:28f9484:     void setRefActionInfo(long fkIndexConglomId,
1:eac0369: 								 int[]fkColArray, 
1:eac0369: 								 String parentResultSetId,
1:eac0369: 								 boolean dependentScan)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"setRefActionInfo() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add an authorization check into the passed in method.
1:eac0369: 	*/
1:eac0369: 	void generateAuthorizeCheck(ActivationClassBuilder acb,
1:eac0369: 								MethodBuilder mb,
1:eac0369: 								int sqlOperation) {
1:eac0369: 		// add code to authorize statement execution.
1:eac0369: 		acb.pushThisAsActivation(mb);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getLanguageConnectionContext",
1:eac0369: 											 ClassName.LanguageConnectionContext, 0);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getAuthorizer",
1:eac0369: 											 ClassName.Authorizer, 0);
1:eac0369: 
1:c45f5b1: 		acb.pushThisAsActivation(mb);
1:eac0369: 		mb.push(sqlOperation);
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "authorize",
1:c45f5b1: 											 "void", 2);
1:eac0369: 	}
1:eac0369: 	
1:95a483d: 	/**
1:95a483d: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
1:95a483d: 	  * unstable results AND if we're in a context where unstable results are
1:95a483d: 	  * forbidden.
1:95a483d: 	  *
1:95a483d: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1:95a483d: 	  *
1:95a483d: 	  *	@param	fragmentType	Type of fragment as a String, for inclusion in error messages.
1:95a483d: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
1:95a483d: 	  *
1:95a483d: 	  * @exception StandardException		Thrown on error
1:95a483d: 	  */
1:95a483d: 	public	void	checkReliability( String fragmentType, int fragmentBitMask )
1:95a483d: 		throws StandardException
1:95a483d: 	{
1:95a483d: 		// if we're in a context that forbids unreliable fragments, raise an error
1:95a483d: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1:95a483d: 		{
1:5a0cfa2:             throwReliabilityException( fragmentType, fragmentBitMask );
1:95a483d: 		}
1:95a483d: 	}
1:95a483d: 
1:95a483d: 	/**
1:95a483d: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
1:95a483d: 	  * unstable results AND if we're in a context where unstable results are
1:95a483d: 	  * forbidden.
1:95a483d: 	  *
1:95a483d: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1:95a483d: 	  *
1:95a483d: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
1:95a483d: 	  *	@param	fragmentType	Type of fragment as a String, to be fetch for the error message.
1:95a483d: 	  *
1:95a483d: 	  * @exception StandardException		Thrown on error
1:95a483d: 	  */
1:95a483d: 	public	void	checkReliability( int fragmentBitMask, String fragmentType )
1:95a483d: 		throws StandardException
1:95a483d: 	{
1:95a483d: 		// if we're in a context that forbids unreliable fragments, raise an error
1:95a483d: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1:95a483d: 		{
1:95a483d:             String fragmentTypeTxt = MessageService.getTextMessage( fragmentType );
1:5a0cfa2:             throwReliabilityException( fragmentTypeTxt, fragmentBitMask );
1:95a483d: 		}
1:95a483d: 	}
1:95a483d: 
1:95a483d:     /**
1:d039ced:      * Bind a UDT. This involves looking it up in the DataDictionary and filling
1:d039ced:      * in its class name.
1:53c606b:      *
1:53c606b:      * @param originalDTD A datatype: might be an unbound UDT and might not be
1:53c606b:      *
1:53c606b:      * @return The bound UDT if originalDTD was an unbound UDT; otherwise returns originalDTD.
1:d039ced:      */
1:d039ced:     public DataTypeDescriptor bindUserType( DataTypeDescriptor originalDTD ) throws StandardException
1:d039ced:     {
1:b4af7da:         // if the type is a table type, then we need to bind its user-typed columns
1:b4af7da:         if ( originalDTD.getCatalogType().isRowMultiSet() ) { return bindRowMultiSet( originalDTD ); }
1:b4af7da:         
1:d039ced:         // nothing to do if this is not a user defined type
1:d039ced:         if ( !originalDTD.getTypeId().userType() ) { return originalDTD; }
1:d039ced: 
1:d039ced:         UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) originalDTD.getTypeId().getBaseTypeId();
1:d039ced: 
1:d039ced:         // also nothing to do if the type has already been resolved
1:d039ced:         if ( userTypeID.isBound() ) { return originalDTD; }
1:d039ced: 
1:d039ced:         // ok, we have an unbound UDT. lookup this type in the data dictionary
1:d039ced: 
1:d039ced:         DataDictionary dd = getDataDictionary();
1:d039ced:         SchemaDescriptor typeSchema = getSchemaDescriptor( userTypeID.getSchemaName() );
1:d039ced:         char  udtNameSpace = AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR;
1:d039ced:         String unqualifiedTypeName = userTypeID.getUnqualifiedName();
1:d039ced:         AliasDescriptor ad = dd.getAliasDescriptor( typeSchema.getUUID().toString(), unqualifiedTypeName, udtNameSpace );
1:d039ced: 
1:d039ced: 		if (ad == null)
1:d039ced: 		{
1:56a7b39: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, AliasDescriptor.getAliasType(udtNameSpace),  unqualifiedTypeName);
1:d039ced: 		}
1:d039ced: 
1:98c7520:         createTypeDependency( ad );
1:98c7520: 
1:d039ced:         DataTypeDescriptor result = new DataTypeDescriptor
1:d039ced:             (
1:d039ced:              TypeId.getUserDefinedTypeId( typeSchema.getSchemaName(), unqualifiedTypeName, ad.getJavaClassName() ),
1:d039ced:              originalDTD.isNullable()
1:d039ced:              );
1:d039ced: 
1:d039ced:         return result;
1:d039ced:     }
1:d039ced: 
1:0acf797:     /** Bind user defined types as necessary */
1:0acf797:     public  TypeDescriptor  bindUserCatalogType( TypeDescriptor td )
1:0acf797:         throws StandardException
1:0acf797:     {
1:0acf797:         // if this is a user defined type, resolve the Java class name
1:0acf797:         if ( !td.isUserDefinedType() ) { return td; }
1:0acf797:         else
1:0acf797:         {
1:0acf797:             DataTypeDescriptor dtd = DataTypeDescriptor.getType( td );
1:0acf797: 
1:0acf797:             dtd = bindUserType( dtd );
1:0acf797:             return dtd.getCatalogType();
1:0acf797:         }
1:0acf797:     }
1:0acf797: 
1:070d37e:     /** Get the AliasDescriptor of a UDT */
1:070d37e:     public  AliasDescriptor getUDTDesc( DataTypeDescriptor dtd )
1:070d37e:         throws StandardException
1:070d37e:     {
1:070d37e:         UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) dtd.getTypeId().getBaseTypeId();
1:070d37e: 
1:070d37e:         DataDictionary dd = getDataDictionary();
1:070d37e:         SchemaDescriptor typeSchema = getSchemaDescriptor( userTypeID.getSchemaName() );
1:070d37e:         char  udtNameSpace = AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR;
1:070d37e:         String unqualifiedTypeName = userTypeID.getUnqualifiedName();
1:070d37e:         AliasDescriptor ad = dd.getAliasDescriptor( typeSchema.getUUID().toString(), unqualifiedTypeName, udtNameSpace );
1:070d37e: 
1:070d37e:         return ad;
1:070d37e:     }
1:070d37e: 
1:d039ced:     /**
1:daffaee:      * Add USAGE privilege for all UDTs mentioned in the indicated ValueNodes.
1:daffaee:      */
1:daffaee:     void    addUDTUsagePriv( List<ValueNode> valueNodes )
1:daffaee:         throws StandardException
1:daffaee:     {
1:daffaee:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:daffaee:         
1:9a9d658:         for ( ValueNode val : valueNodes ) { addUDTUsagePriv( val ); }
1:9a9d658:     }
1:9a9d658: 
1:9a9d658:     /**
1:9a9d658:      * Add USAGE privilege for a single UDT.
1:9a9d658:      */
1:9a9d658:     void    addUDTUsagePriv( ValueNode val )
1:9a9d658:         throws StandardException
1:9a9d658:     {
1:9a9d658:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:9a9d658:         
1:9a9d658:         DataTypeDescriptor  dtd = val.getTypeServices();
1:9a9d658:         if ( (dtd != null) && dtd.getTypeId().userType() )
1:daffaee:         {
1:9a9d658:             AliasDescriptor ad = getUDTDesc( dtd );
1:9a9d658:             getCompilerContext().addRequiredUsagePriv( ad );
1:daffaee:         }
1:daffaee:     }
1:daffaee: 
1:daffaee:     /**
1:b4af7da:      * Bind the UDTs in a table type.
1:b4af7da:      *
1:b4af7da:      * @param originalDTD A datatype: might be an unbound UDT and might not be
1:b4af7da:      *
1:b4af7da:      * @return The bound table type if originalDTD was an unbound table type; otherwise returns originalDTD.
1:b4af7da:      */
1:b4af7da:     public DataTypeDescriptor bindRowMultiSet( DataTypeDescriptor originalDTD ) throws StandardException
1:b4af7da:     {
1:b4af7da:         if ( !originalDTD.getCatalogType().isRowMultiSet() ) { return originalDTD; }
1:b4af7da: 
1:b4af7da:         RowMultiSetImpl originalMultiSet = (RowMultiSetImpl) originalDTD.getTypeId().getBaseTypeId();
1:b4af7da:         TypeDescriptor[] columnTypes = originalMultiSet.getTypes();
1:b4af7da:         int columnCount = columnTypes.length;
1:b4af7da: 
1:b4af7da:         for ( int i = 0; i < columnCount; i++ )
1:b4af7da:         {
1:0acf797:             columnTypes[ i ] = bindUserCatalogType( columnTypes[ i ] );
1:daffaee:         }
1:57465ef:         originalMultiSet.setTypes( columnTypes );
1:b4af7da: 
1:b4af7da:         return originalDTD;
1:b4af7da:     }
1:b4af7da:         
1:b4af7da:     
1:b4af7da:     /**
1:98c7520:      * Declare a dependency on a type and check that you have privilege to use
1:98c7520:      * it. This is only used if the type is an ANSI UDT.
1:eac0369:      *
1:d6c2047:      * @param dtd Type which may have a dependency declared on it.
1:d6c2047:      */
1:d6c2047:     public void createTypeDependency( DataTypeDescriptor dtd ) throws StandardException
1:b4af7da:     {
1:d6c2047:         AliasDescriptor ad = getDataDictionary().getAliasDescriptorForUDT( null, dtd );
1:b4af7da: 
1:98c7520:         if ( ad != null ) { createTypeDependency( ad ); }
1:b4af7da:     }
1:98c7520:     /**
1:98c7520:      * Declare a dependency on an ANSI UDT, identified by its AliasDescriptor,
1:98c7520:      * and check that you have privilege to use it.
1:98c7520:      */
1:98c7520:     private void createTypeDependency( AliasDescriptor ad ) throws StandardException
1:98c7520:     {
1:98c7520:         getCompilerContext().createDependency( ad );
1:b4af7da: 
1:b93f9db:         if ( isPrivilegeCollectionRequired() && !getCompilerContext().skippingTypePrivileges() )
1:d6c2047:         {
1:daffaee:             getCompilerContext().addRequiredUsagePriv( ad );
1:b4af7da:         }
1:d6c2047:     }
1:b4af7da:     
1:d6c2047:     /**
1:95a483d:      * Common code for the 2 checkReliability functions.  Always throws StandardException.
1:95a483d:      *
1:95a483d:      * @param fragmentType Type of fragment as a string, for inclusion in error messages.
1:15b837e:      * @param fragmentBitMask Describes the kinds of expressions we ar suspicious of
1:95a483d:      * @exception StandardException        Throws an error, always.
1:95a483d:      */
1:5a0cfa2:     private void throwReliabilityException( String fragmentType, int fragmentBitMask ) throws StandardException
1:95a483d:     {
1:2455f1a:         final int reliability = getCompilerContext().getReliability();
1:95a483d:         String sqlState;
1:95a483d: 		/* Error string somewhat dependent on operation due to different
1:95a483d: 		 * nodes being allowed for different operations.
1:95a483d: 		 */
1:2455f1a:         if (reliability == CompilerContext.DEFAULT_RESTRICTION)
1:95a483d: 		{
1:95a483d:             sqlState = SQLState.LANG_INVALID_DEFAULT_DEFINITION;
1:d6c2047: 		}
1:2455f1a:         else if (reliability == CompilerContext.GENERATION_CLAUSE_RESTRICTION)
1:95a483d: 		{
1:5a0cfa2:             switch ( fragmentBitMask )
1:5a0cfa2:             {
1:5a0cfa2:             case CompilerContext.SQL_IN_ROUTINES_ILLEGAL:
1:5a0cfa2:                 sqlState = SQLState.LANG_ROUTINE_CANT_PERMIT_SQL;
1:5a0cfa2:                 break;
1:b4af7da: 
1:5a0cfa2:             default:
1:5a0cfa2:                 sqlState = SQLState.LANG_NON_DETERMINISTIC_GENERATION_CLAUSE;
1:5a0cfa2:                 break;
1:5a0cfa2:             }
1:95a483d: 		}
1:508a010:         else if (
1:2455f1a:                  (reliability & fragmentBitMask & CompilerContext.SQL_IN_ROUTINES_ILLEGAL)
1:508a010:                  != 0
1:508a010:                  )
1:508a010:         {
1:508a010:             sqlState = SQLState.LANG_ROUTINE_CANT_PERMIT_SQL;
1:508a010:         }
1:2455f1a:         else if (reliability == CompilerContext.CHECK_CONSTRAINT)
1:95a483d:         {
1:2455f1a:             sqlState = SQLState.LANG_UNRELIABLE_CHECK_CONSTRAINT;
1:95a483d:         }
1:95a483d:         else
1:2455f1a: 		{
1:95a483d:             sqlState = SQLState.LANG_UNRELIABLE_QUERY_FRAGMENT;
1:95a483d: 		}
1:95a483d: 		throw StandardException.newException(sqlState, fragmentType);
1:95a483d:     }
1:98c7520: 
1:e671fc7:     /**
1:e671fc7:      * OR in more reliability bits and return the old reliability value.
1:e671fc7:      */
1:e671fc7:     public int orReliability( int newBits )
1:e671fc7:     {
1:e671fc7:         CompilerContext cc = getCompilerContext();
1:e671fc7:         
1:e671fc7:         int previousReliability = cc.getReliability();
1:e671fc7: 
1:e671fc7:         cc.setReliability( previousReliability | newBits );
1:e671fc7: 
1:e671fc7:         return previousReliability;
1:e671fc7:     }
1:e671fc7: 
1:d6c2047: 
1:eac0369:     /**
1:108305b:      * Bind the parameters of OFFSET n ROWS and FETCH FIRST n ROWS ONLY, if
1:108305b:      * any.
1:108305b:      *
1:108305b:      * @param offset the OFFSET parameter, if any
1:108305b:      * @param fetchFirst the FETCH parameter, if any
1:108305b:      *
1:108305b:      * @exception StandardException         Thrown on error
1:108305b:      */
1:108305b:     public static void bindOffsetFetch(ValueNode offset,
1:108305b:                                        ValueNode fetchFirst)
1:108305b:             throws StandardException {
1:95a483d: 
1:108305b:         if (offset instanceof ConstantNode) {
1:108305b:             DataValueDescriptor dvd = ((ConstantNode)offset).getValue();
1:108305b:             long val = dvd.getLong();
1:108305b: 
1:108305b:             if (val < 0) {
1:108305b:                 throw StandardException.newException(
1:108305b:                     SQLState.LANG_INVALID_ROW_COUNT_OFFSET,
1:108305b:                     Long.toString(val) );
1:2455f1a:             }
1:108305b:         } else if (offset instanceof ParameterNode) {
1:108305b:             offset.
1:108305b:                 setType(new DataTypeDescriptor(
1:108305b:                             TypeId.getBuiltInTypeId(Types.BIGINT),
1:108305b:                             false /* ignored tho; ends up nullable,
1:108305b:                                      so we test for NULL at execute time */));
1:108305b:         }
1:108305b: 
1:108305b: 
1:108305b:         if (fetchFirst instanceof ConstantNode) {
1:108305b:             DataValueDescriptor dvd = ((ConstantNode)fetchFirst).getValue();
1:108305b:             long val = dvd.getLong();
1:108305b: 
1:108305b:             if (val < 1) {
1:108305b:                 throw StandardException.newException(
1:108305b:                     SQLState.LANG_INVALID_ROW_COUNT_FIRST,
1:108305b:                     Long.toString(val) );
1:108305b:             }
1:108305b:         } else if (fetchFirst instanceof ParameterNode) {
1:108305b:             fetchFirst.
1:108305b:                 setType(new DataTypeDescriptor(
1:108305b:                             TypeId.getBuiltInTypeId(Types.BIGINT),
1:108305b:                             false /* ignored tho; ends up nullable,
1:108305b:                                      so we test for NULL at execute time*/));
1:108305b:         }
1:108305b:     }
1:108305b: 
1:eac0369:     /**
1:0cefeda:      * Get all child nodes of a specific type, and return them in the order
1:0cefeda:      * in which they appear in the SQL text.
1:0cefeda:      *
1:0cefeda:      * @param <N> the type of node to look for
1:0cefeda:      * @param type the type of node to look for
1:0cefeda:      * @return all nodes of the specified type
1:0cefeda:      * @throws StandardException if an error occurs
1:0cefeda:      */
1:0cefeda:     public <N extends QueryTreeNode>
1:0cefeda:         SortedSet<N> getOffsetOrderedNodes(Class<N> type)
1:0cefeda:                 throws StandardException {
1:0cefeda:         OffsetOrderVisitor<N> visitor = new OffsetOrderVisitor<N>(
1:0cefeda:                 type, getBeginOffset(), getEndOffset() + 1);
1:0cefeda:         accept(visitor);
1:0cefeda:         return visitor.getNodes();
1:0cefeda:     }
1:0cefeda: 
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be package protected so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContext( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContext( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:d055adb
/////////////////////////////////////////////////////////////////////////
1:     static final int AUTOINCREMENT_CYCLE  = 4;
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
1: import org.apache.derby.iapi.services.context.ContextService;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged lookup of a Context. Must be package protected so that user code
1:      * can't call this entry point.
1:      */
1:     static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
commit:9a9d658
/////////////////////////////////////////////////////////////////////////
1:         for ( ValueNode val : valueNodes ) { addUDTUsagePriv( val ); }
1:     }
1: 
1:     /**
1:      * Add USAGE privilege for a single UDT.
1:      */
1:     void    addUDTUsagePriv( ValueNode val )
1:         throws StandardException
1:     {
1:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:         
1:         DataTypeDescriptor  dtd = val.getTypeServices();
1:         if ( (dtd != null) && dtd.getTypeId().userType() )
1:             AliasDescriptor ad = getUDTDesc( dtd );
1:             getCompilerContext().addRequiredUsagePriv( ad );
commit:b93f9db
/////////////////////////////////////////////////////////////////////////
1:         if ( isPrivilegeCollectionRequired() && !getCompilerContext().skippingTypePrivileges() )
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1:      * Add USAGE privilege for all UDTs mentioned in the indicated ValueNodes.
1:      */
1:     void    addUDTUsagePriv( List<ValueNode> valueNodes )
1:         throws StandardException
1:     {
1:         if ( !isPrivilegeCollectionRequired() ) { return; }
1:         
0:         for ( ValueNode val : valueNodes )
1:         {
0:             DataTypeDescriptor  dtd = val.getTypeServices();
0:             if ( (dtd != null) && dtd.getTypeId().userType() )
1:             {
0:                 AliasDescriptor ad = getUDTDesc( dtd );
1:                 getCompilerContext().addRequiredUsagePriv( ad );
1:             }
1:         }
1:     }
1: 
1:     /**
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<String>   visitableTags;
1: 
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
1:         return
1:             isPrivilegeCollectionRequired &&
1:             getCompilerContext().passesPrivilegeFilters( this );
/////////////////////////////////////////////////////////////////////////
1:     public  void    addTag( String tag )
1:     {
1:         if ( visitableTags == null ) { visitableTags = new ArrayList<String>(); }
1:         visitableTags.add( tag );
1:     }
1: 
1:     public  boolean taggedWith( String tag )
1:     {
1:         if ( visitableTags == null ) { return false; }
1:         else { return visitableTags.contains( tag ); }
1:     }
1: 
1:     /** Copy the tags from another QueryTreeNode */
1:     protected   void    copyTagsFrom( QueryTreeNode that )
1:     {
1:         if ( that.visitableTags == null ) { return; }
1:         else
1:         {
1:             for ( String tag : that.visitableTags ) { addTag( tag ); }
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /** Get the AliasDescriptor of a UDT */
1:     public  AliasDescriptor getUDTDesc( DataTypeDescriptor dtd )
1:         throws StandardException
1:     {
1:         UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) dtd.getTypeId().getBaseTypeId();
1: 
1:         DataDictionary dd = getDataDictionary();
1:         SchemaDescriptor typeSchema = getSchemaDescriptor( userTypeID.getSchemaName() );
1:         char  udtNameSpace = AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR;
1:         String unqualifiedTypeName = userTypeID.getUnqualifiedName();
1:         AliasDescriptor ad = dd.getAliasDescriptor( typeSchema.getUUID().toString(), unqualifiedTypeName, udtNameSpace );
1: 
1:         return ad;
1:     }
1: 
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:         else if (
0:                  (getCompilerContext().getReliability() & fragmentBitMask & CompilerContext.SQL_IN_ROUTINES_ILLEGAL)
1:                  != 0
1:                  )
1:         {
1:             sqlState = SQLState.LANG_ROUTINE_CANT_PERMIT_SQL;
1:         }
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.OptTrace;
/////////////////////////////////////////////////////////////////////////
1:     /** Convenience method for finding the optimizer tracer */
1:     public  OptTrace    getOptimizerTracer()    { return getLanguageConnectionContext().getOptimizerTracer(); }
1: 
1:     /** Convenience method for checking whether optimizer tracing is on */
1:     public  boolean optimizerTracingIsOn() { return getLanguageConnectionContext().optimizerTracingIsOn(); }
1:     
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.StatementUtil;
/////////////////////////////////////////////////////////////////////////
1:         return StatementUtil.getSchemaDescriptor
1:             (
1:              schemaName,
1:              raiseError,
1:              getDataDictionary(),
1:              getLanguageConnectionContext(),
1:              getCompilerContext()
1:              );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 			Map<Object,Object> printed =
commit:57465ef
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         originalMultiSet.setTypes( columnTypes );
commit:0acf797
/////////////////////////////////////////////////////////////////////////
1:     /** Bind user defined types as necessary */
1:     public  TypeDescriptor  bindUserCatalogType( TypeDescriptor td )
1:         throws StandardException
1:     {
1:         // if this is a user defined type, resolve the Java class name
1:         if ( !td.isUserDefinedType() ) { return td; }
1:         else
1:         {
1:             DataTypeDescriptor dtd = DataTypeDescriptor.getType( td );
1: 
1:             dtd = bindUserType( dtd );
1:             return dtd.getCatalogType();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             columnTypes[ i ] = bindUserCatalogType( columnTypes[ i ] );
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * OR in more reliability bits and return the old reliability value.
1:      */
1:     public int orReliability( int newBits )
1:     {
1:         CompilerContext cc = getCompilerContext();
1:         
1:         int previousReliability = cc.getReliability();
1: 
1:         cc.setReliability( previousReliability | newBits );
1: 
1:         return previousReliability;
1:     }
1: 
commit:b4af7da
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RowMultiSetImpl;
/////////////////////////////////////////////////////////////////////////
1:         // if the type is a table type, then we need to bind its user-typed columns
1:         if ( originalDTD.getCatalogType().isRowMultiSet() ) { return bindRowMultiSet( originalDTD ); }
1:         
/////////////////////////////////////////////////////////////////////////
1:      * Bind the UDTs in a table type.
1:      *
1:      * @param originalDTD A datatype: might be an unbound UDT and might not be
1:      *
1:      * @return The bound table type if originalDTD was an unbound table type; otherwise returns originalDTD.
1:      */
1:     public DataTypeDescriptor bindRowMultiSet( DataTypeDescriptor originalDTD ) throws StandardException
1:     {
1:         if ( !originalDTD.getCatalogType().isRowMultiSet() ) { return originalDTD; }
1: 
1:         RowMultiSetImpl originalMultiSet = (RowMultiSetImpl) originalDTD.getTypeId().getBaseTypeId();
0:         String[] columnNames = originalMultiSet.getColumnNames();
1:         TypeDescriptor[] columnTypes = originalMultiSet.getTypes();
1:         int columnCount = columnTypes.length;
1: 
1:         for ( int i = 0; i < columnCount; i++ )
1:         {
0:             TypeDescriptor columnType = columnTypes[ i ];
1: 
0:             if ( columnType.isUserDefinedType() )
1:             {
0:                 DataTypeDescriptor newColumnDTD = DataTypeDescriptor.getType( columnType );
1: 
0:                 newColumnDTD = bindUserType( newColumnDTD );
1: 
0:                 TypeDescriptor newColumnType = newColumnDTD.getCatalogType();
1: 
0:                 // poke the bound type back into the multi set descriptor
0:                 columnTypes[ i ] = newColumnType;
1:             }
1:         }
1: 
1:         return originalDTD;
1:     }
1:         
1:     
1:     /**
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1:         createTypeDependency( ad );
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Declare a dependency on a type and check that you have privilege to use
1:      * it. This is only used if the type is an ANSI UDT.
/////////////////////////////////////////////////////////////////////////
1:         if ( ad != null ) { createTypeDependency( ad ); }
1:     }
1:     /**
1:      * Declare a dependency on an ANSI UDT, identified by its AliasDescriptor,
1:      * and check that you have privilege to use it.
1:      */
1:     private void createTypeDependency( AliasDescriptor ad ) throws StandardException
1:     {
1:         getCompilerContext().createDependency( ad );
1: 
0:         if ( isPrivilegeCollectionRequired() )
0:             getCompilerContext().addRequiredUsagePriv( ad );
commit:d6c2047
/////////////////////////////////////////////////////////////////////////
0:      * Declare a dependency on a type. This is only used if the type is an ANSI UDT.
1:      *
1:      * @param dtd Type which may have a dependency declared on it.
1:      */
1:     public void createTypeDependency( DataTypeDescriptor dtd ) throws StandardException
1:     {
1:         AliasDescriptor ad = getDataDictionary().getAliasDescriptorForUDT( null, dtd );
1: 
0:         if ( ad != null )
1:         {
0:             getCompilerContext().createDependency( ad );
1:         }
1:     }
1:     
1:     /**
commit:53c606b
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param originalDTD A datatype: might be an unbound UDT and might not be
1:      *
1:      * @return The bound UDT if originalDTD was an unbound UDT; otherwise returns originalDTD.
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Bind a UDT. This involves looking it up in the DataDictionary and filling
1:      * in its class name.
1:      */
1:     public DataTypeDescriptor bindUserType( DataTypeDescriptor originalDTD ) throws StandardException
1:     {
1:         // nothing to do if this is not a user defined type
1:         if ( !originalDTD.getTypeId().userType() ) { return originalDTD; }
1: 
1:         UserDefinedTypeIdImpl userTypeID = (UserDefinedTypeIdImpl) originalDTD.getTypeId().getBaseTypeId();
1: 
1:         // also nothing to do if the type has already been resolved
1:         if ( userTypeID.isBound() ) { return originalDTD; }
1: 
1:         // ok, we have an unbound UDT. lookup this type in the data dictionary
1: 
1:         DataDictionary dd = getDataDictionary();
1:         SchemaDescriptor typeSchema = getSchemaDescriptor( userTypeID.getSchemaName() );
1:         char  udtNameSpace = AliasInfo.ALIAS_NAME_SPACE_UDT_AS_CHAR;
1:         String unqualifiedTypeName = userTypeID.getUnqualifiedName();
1:         AliasDescriptor ad = dd.getAliasDescriptor( typeSchema.getUUID().toString(), unqualifiedTypeName, udtNameSpace );
1: 
1: 		if (ad == null)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, ad.getAliasType(udtNameSpace),  unqualifiedTypeName);
1: 		}
1: 
1:         DataTypeDescriptor result = new DataTypeDescriptor
1:             (
1:              TypeId.getUserDefinedTypeId( typeSchema.getSchemaName(), unqualifiedTypeName, ad.getJavaClassName() ),
1:              originalDTD.isNullable()
1:              );
1: 
1:         return result;
1:     }
1: 
1:     /**
commit:15b837e
/////////////////////////////////////////////////////////////////////////
1:      * @param fragmentBitMask Describes the kinds of expressions we ar suspicious of
commit:5a0cfa2
/////////////////////////////////////////////////////////////////////////
1:             throwReliabilityException( fragmentType, fragmentBitMask );
/////////////////////////////////////////////////////////////////////////
1:             throwReliabilityException( fragmentTypeTxt, fragmentBitMask );
/////////////////////////////////////////////////////////////////////////
1:     private void throwReliabilityException( String fragmentType, int fragmentBitMask ) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             switch ( fragmentBitMask )
1:             {
1:             case CompilerContext.SQL_IN_ROUTINES_ILLEGAL:
1:                 sqlState = SQLState.LANG_ROUTINE_CANT_PERMIT_SQL;
1:                 break;
1: 
1:             default:
1:                 sqlState = SQLState.LANG_NON_DETERMINISTIC_GENERATION_CLAUSE;
1:                 break;
1:             }
commit:95a483d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.i18n.MessageService;
/////////////////////////////////////////////////////////////////////////
1:         return makeTableName
0:             ( getNodeFactory(), getContextManager(), schemaName, flatName );
1: 	}
1: 
1: 	public	static  TableName	makeTableName
1: 	(
0:         NodeFactory nodeFactory,
1:         ContextManager contextManager,
1: 		String	schemaName,
1: 		String	flatName
1: 	)
1: 		throws StandardException
1: 	{
0: 		return (TableName) nodeFactory.getNode
0: 				contextManager
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
1: 	  * unstable results AND if we're in a context where unstable results are
1: 	  * forbidden.
1: 	  *
1: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1: 	  *
1: 	  *	@param	fragmentType	Type of fragment as a String, for inclusion in error messages.
1: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	public	void	checkReliability( String fragmentType, int fragmentBitMask )
1: 		throws StandardException
1: 	{
1: 		// if we're in a context that forbids unreliable fragments, raise an error
1: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1: 		{
0:             throwReliabilityException( fragmentType );
1: 		}
1: 	}
1: 
1: 	/**
1: 	  * Bind time logic. Raises an error if this ValueNode, once compiled, returns
1: 	  * unstable results AND if we're in a context where unstable results are
1: 	  * forbidden.
1: 	  *
1: 	  * Called by children who may NOT appear in the WHERE subclauses of ADD TABLE clauses.
1: 	  *
1: 	  *	@param	fragmentBitMask	Type of fragment as a bitmask of possible fragment types
1: 	  *	@param	fragmentType	Type of fragment as a String, to be fetch for the error message.
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	public	void	checkReliability( int fragmentBitMask, String fragmentType )
1: 		throws StandardException
1: 	{
1: 		// if we're in a context that forbids unreliable fragments, raise an error
1: 		if ( ( getCompilerContext().getReliability() & fragmentBitMask ) != 0 )
1: 		{
1:             String fragmentTypeTxt = MessageService.getTextMessage( fragmentType );
0:             throwReliabilityException( fragmentTypeTxt );
1: 		}
1: 	}
1: 
1:     /**
1:      * Common code for the 2 checkReliability functions.  Always throws StandardException.
1:      *
1:      * @param fragmentType Type of fragment as a string, for inclusion in error messages.
1:      * @exception StandardException        Throws an error, always.
1:      */
0:     private void throwReliabilityException( String fragmentType ) throws StandardException
1:     {
1:         String sqlState;
1: 		/* Error string somewhat dependent on operation due to different
1: 		 * nodes being allowed for different operations.
1: 		 */
0: 		if (getCompilerContext().getReliability() == CompilerContext.DEFAULT_RESTRICTION)
1: 		{
1:             sqlState = SQLState.LANG_INVALID_DEFAULT_DEFINITION;
1: 		}
0: 		else if (getCompilerContext().getReliability() == CompilerContext.GENERATION_CLAUSE_RESTRICTION)
1: 		{
0:             sqlState = SQLState.LANG_NON_DETERMINISTIC_GENERATION_CLAUSE;
1: 		}
1: 		else
1: 		{
1:             sqlState = SQLState.LANG_UNRELIABLE_QUERY_FRAGMENT;
1: 		}
1: 		throw StandardException.newException(sqlState, fragmentType);
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2455f1a
/////////////////////////////////////////////////////////////////////////
1:         final int reliability = getCompilerContext().getReliability();
1:         if (reliability == CompilerContext.DEFAULT_RESTRICTION)
1:         else if (reliability == CompilerContext.GENERATION_CLAUSE_RESTRICTION)
/////////////////////////////////////////////////////////////////////////
1:                  (reliability & fragmentBitMask & CompilerContext.SQL_IN_ROUTINES_ILLEGAL)
1:         else if (reliability == CompilerContext.CHECK_CONSTRAINT)
1:         {
1:             sqlState = SQLState.LANG_UNRELIABLE_CHECK_CONSTRAINT;
1:         }
1:         else
commit:0cefeda
/////////////////////////////////////////////////////////////////////////
1: import java.util.SortedSet;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get all child nodes of a specific type, and return them in the order
1:      * in which they appear in the SQL text.
1:      *
1:      * @param <N> the type of node to look for
1:      * @param type the type of node to look for
1:      * @return all nodes of the specified type
1:      * @throws StandardException if an error occurs
1:      */
1:     public <N extends QueryTreeNode>
1:         SortedSet<N> getOffsetOrderedNodes(Class<N> type)
1:                 throws StandardException {
1:         OffsetOrderVisitor<N> visitor = new OffsetOrderVisitor<N>(
1:                 type, getBeginOffset(), getEndOffset() + 1);
1:         accept(visitor);
1:         return visitor.getNodes();
1:     }
1: 
commit:e3720ab
/////////////////////////////////////////////////////////////////////////
1:     private boolean isPrivilegeCollectionRequired = true;
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:         return (StatementNode)
1:                 parseStatementOrSearchCondition(sql, internalSQL, true);
1:     }
1: 
1:     /**
1:      * Parse an SQL fragment that represents a {@code <search condition>}.
1:      *
1:      * @param sql a fragment of an SQL statement
1:      * @param internalSQL {@code true} if the SQL fragment is allowed to
1:      *   contain internal syntax, {@code false} otherwise
1:      * @return a {@code ValueNode} representing the parse tree of the
1:      *   SQL fragment
1:      * @throws StandardException if an error happens while parsing
1:      */
1:     ValueNode parseSearchCondition(String sql, boolean internalSQL)
1:         throws StandardException
1:     {
1:         return (ValueNode)
1:                 parseStatementOrSearchCondition(sql, internalSQL, false);
1:     }
1: 
1:     /**
1:      * Parse a full SQL statement or a fragment representing a {@code <search
1:      * condition>}. This is a worker method that contains common logic for
1:      * {@link #parseStatement} and {@link #parseSearchCondition}.
1:      *
1:      * @param sql the SQL statement or fragment to parse
1:      * @param internalSQL {@code true} if it is allowed to contain internal
1:      *   syntax, {@code false} otherwise
1:      * @param isStatement {@code true} if {@code sql} is a full SQL statement,
1:      *   {@code false} if it is a fragment
1:      * @return a parse tree
1:      * @throws StandardException if an error happens while parsing
1:      */
1:     private Visitable parseStatementOrSearchCondition(
1:             String sql, boolean internalSQL, boolean isStatement)
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
1:             return isStatement
1:                     ? p.parseStatement(sql)
1:                     : p.parseSearchCondition(sql);
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:           case Types.SQLXML:
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     ConstantNode getNullNode(DataTypeDescriptor type)
commit:b49cc55
/////////////////////////////////////////////////////////////////////////
1:         return ((CompilerContextImpl) getCompilerContext()).getParameterTypes();
commit:dda453e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:28f9484
/////////////////////////////////////////////////////////////////////////
1:      * required to perform a referential action on dependent table.
1:     void setRefActionInfo(long fkIndexConglomId,
commit:e6a9998
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Node;
/////////////////////////////////////////////////////////////////////////
0: public abstract class QueryTreeNode implements Node, Visitable
commit:70a4f2d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			return (StatementNode) p.parseStatement(sql);
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept a visitor, and call {@code v.visit()} on child nodes as
1: 	 * necessary. Sub-classes should not override this method, but instead
1: 	 * override the {@link #acceptChildren(Visitor)} method.
1: 	public final Visitable accept(Visitor v)
1: 		final boolean childrenFirst = v.visitChildrenFirst(this);
1: 		final boolean skipChildren = v.skipChildren(this);
1: 
1: 		if (childrenFirst && !skipChildren && !v.stopTraversal()) {
1: 			acceptChildren(v);
1: 		}
1: 
1: 		final Visitable ret = v.stopTraversal() ? this : v.visit(this);
1: 
1: 		if (!childrenFirst && !skipChildren && !v.stopTraversal()) {
1: 			acceptChildren(v);
1: 		}
1: 
1: 		return ret;
1: 	}
1: 
1: 	/**
1: 	 * Accept a visitor on all child nodes. All sub-classes that add fields
1: 	 * that should be visited, should override this method and call
1: 	 * {@code accept(v)} on all visitable fields, as well as
1: 	 * {@code super.acceptChildren(v)} to make sure all visitable fields
1: 	 * defined by the super-class are accepted too.
1: 	 *
1: 	 * @param v the visitor
1: 	 * @throws StandardException on errors raised by the visitor
1: 	 */
1: 	void acceptChildren(Visitor v) throws StandardException {
1: 		// no children
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:      * Get the long value of a Property
1:      *
1:      * @param value     Property value as a String
1:      * @param key       Key value of property
1:      *
1:      * @return  The long value of the property
1:      *
1:      * @exception StandardException     Thrown on failure
1:      */
1:     protected long getLongProperty(String value, String key)
1:         throws StandardException
1:     {
1:         long longVal = -1;
1:         try
1:         {
1:             longVal = Long.parseLong(value);
1:         }
1:         catch (NumberFormatException nfe)
1:         {
1:             throw StandardException.newException(
1:                 SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE,
1:                 value,
1:                 key);
1:         }
1:         return longVal;
1:     }
1: 
1:     /**
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                       CharConstantNode.K_VARCHAR,
/////////////////////////////////////////////////////////////////////////
1:                   CharConstantNode.K_LONGVARCHAR, type.getTypeId(), cm);
1:                   CharConstantNode.K_CLOB, type.getTypeId(), cm);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.SynonymAliasInfo;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
/////////////////////////////////////////////////////////////////////////
1: public abstract class QueryTreeNode implements Visitable
1:     static final int AUTOINCREMENT_START_INDEX = 0;
1:     static final int AUTOINCREMENT_INC_INDEX   = 1;
1:     static final int AUTOINCREMENT_IS_AUTOINCREMENT_INDEX   = 2;
1:     static final int AUTOINCREMENT_CREATE_MODIFY  = 3;
/////////////////////////////////////////////////////////////////////////
1:     QueryTreeNode(ContextManager cm) {
1:         this.cm = cm;
1:         if (SanityManager.DEBUG)
1:        {
1:            SanityManager.ASSERT(cm != null,
1:                "cm not expected to be null");
1:        }
1:     }
1: 
1:     /**
1:     final ContextManager getContextManager()
/////////////////////////////////////////////////////////////////////////
1:     public  final OptimizerFactory getOptimizerFactory()
1:                                                         getOptimizerFactory();
/////////////////////////////////////////////////////////////////////////
1:     static String formatNodeString(String nodeString, int depth)
1:             StringBuilder   nodeStringBuilder = new StringBuilder(nodeString);
/////////////////////////////////////////////////////////////////////////
1:             nodeStringBuilder.insert(0, indent);
1:             for (pos = 0; pos < nodeStringBuilder.length() - 1; pos++)
1:                 c = nodeStringBuilder.charAt(pos);
1:                     nodeStringBuilder.insert(pos + 1, indent);
1:             return nodeStringBuilder.toString();
/////////////////////////////////////////////////////////////////////////
1:     void stackPrint()
/////////////////////////////////////////////////////////////////////////
1:     void treePrint(int depth)
/////////////////////////////////////////////////////////////////////////
1:     static void debugPrint(String outputString)
/////////////////////////////////////////////////////////////////////////
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void printLabel(int depth, String label)
/////////////////////////////////////////////////////////////////////////
1:     static boolean isSessionSchema(String schemaName)
/////////////////////////////////////////////////////////////////////////
1:     boolean isPrivilegeCollectionRequired()
/////////////////////////////////////////////////////////////////////////
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
0:     void setNodeType(int nodeType)
/////////////////////////////////////////////////////////////////////////
1:     final public DataDictionary getDataDictionary()
1:     final DependencyManager getDependencyManager()
/////////////////////////////////////////////////////////////////////////
1:         switch (type.getTypeId().getJDBCTypeId())
1:         {
1:           case Types.VARCHAR: {
1:               CharConstantNode ccn = new CharConstantNode(
0:                       C_NodeTypes.VARCHAR_CONSTANT_NODE,
1:                       type.getTypeId(),
1:                       cm);
1:               ccn.setType(type.getNullabilityType(true));
1:               return ccn;
1:           }
1:           case Types.CHAR: {
1:               CharConstantNode ccn = new CharConstantNode(type.getTypeId(), cm);
1:               ccn.setType(type.getNullabilityType(true));
1:               return ccn;
1:           }
1:           case Types.TINYINT:
1:           case Types.SMALLINT:
1:           case Types.INTEGER:
1:           case Types.BIGINT:
1:           case Types.REAL:
1:           case Types.DOUBLE:
1:           case Types.DECIMAL: {
1:               NumericConstantNode nvn =
1:                       new NumericConstantNode(type.getTypeId(), cm);
1:               nvn.setType(type.getNullabilityType(true)); // SUPERFLUOUS? FIXME
1:               return nvn;
1:           }
1:           case Types.NUMERIC: {
1:               // Map this to DECIMAL
1:               NumericConstantNode ncn = new NumericConstantNode(
1:                       TypeId.getBuiltInTypeId(Types.DECIMAL), cm);
1:               ncn.setType(type.getNullabilityType(true)); // SUPERFLUOUS? FIXME
1:               return ncn;
1:           }
1:           case Types.TIMESTAMP: {
1:               UserTypeConstantNode
1:                       utcn = new UserTypeConstantNode(type.getTypeId(), cm);
1:               utcn.setType(type.getNullabilityType(true));
1:               return utcn;
1:           }
1:           case Types.BINARY: {
1:               BitConstantNode bcn =
1:                       new BitConstantNode(type.getTypeId(), cm);
1:               bcn.setType(type.getNullabilityType(true));
1:               return bcn;
1:           }
1:           case Types.VARBINARY: {
1:               VarbitConstantNode vcn =
1:                       new VarbitConstantNode(type.getTypeId(), cm);
1:               vcn.setType(type.getNullabilityType(true));
1:               return vcn;
1:           }
1:           case Types.LONGVARCHAR: {
1:               CharConstantNode ccn = new CharConstantNode(
0:                   C_NodeTypes.LONGVARCHAR_CONSTANT_NODE, type.getTypeId(), cm);
1:               ccn.setType(type.getNullabilityType(true));
1:               return ccn;
1:           }
1:           case Types.CLOB: {
1:               CharConstantNode ccn = new CharConstantNode(
0:                   C_NodeTypes.CLOB_CONSTANT_NODE, type.getTypeId(), cm);
1:               ccn.setType(type.getNullabilityType(true));
1:               return ccn;
1:           }
1:           case Types.LONGVARBINARY: {
1:               VarbitConstantNode vcn =
1:                       new VarbitConstantNode(type.getTypeId(), cm);
1:               vcn.setType(type.getNullabilityType(true));
1:               return vcn;
1:           }
1:           case Types.BLOB: {
1:               VarbitConstantNode vcn =
1:                   new VarbitConstantNode(type.getTypeId(), cm);
1:               vcn.setType(type.getNullabilityType(true));
1:               return vcn;
1:           }
1:         case Types.SQLXML: {
1:               XMLConstantNode xcn =
1:                   new XMLConstantNode(type.getTypeId(), cm);
1:              xcn.setType(type.getNullabilityType(true));
1:               return xcn;
1:           }
1:           case Types.BOOLEAN: {
1:               BooleanConstantNode bCn =
1:                       new BooleanConstantNode(type.getTypeId(), cm);
1:               bCn.setType(type.getNullabilityType(true));
1:               return bCn;
1:           }
1:            if (type.getTypeId().userType()) {
1:                 UserTypeConstantNode utcn =
1:                         new UserTypeConstantNode(type.getTypeId(), cm);
1:                 utcn.setType(type.getNullabilityType(true));
1:                 return utcn;
1:            } else {
/////////////////////////////////////////////////////////////////////////
1:     DataValueDescriptor convertDefaultNode(DataTypeDescriptor typeDescriptor)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             ( getContextManager(), schemaName, flatName );
1:         return new TableName(schemaName, flatName, contextManager);
/////////////////////////////////////////////////////////////////////////
1:     TableName resolveTableToSynonym(TableName tabName) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         TableName tableName = new TableName(
1:                 nextSynonymSchema,
1:                 nextSynonymTable,
1:                 getContextManager());
1: 
commit:7bfb37a
/////////////////////////////////////////////////////////////////////////
1:      * Triggers, constraints and views get executed with their definers'
1:      * privileges and they can exist in the system only if their definers
1:      * still have all the privileges to create them. Based on this, any
1:      * At compile time, we will make sure that we do not collect the privilege
1: 	final void disablePrivilegeCollection()
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Bind the parameters of OFFSET n ROWS and FETCH FIRST n ROWS ONLY, if
1:      * any.
1:      *
1:      * @param offset the OFFSET parameter, if any
1:      * @param fetchFirst the FETCH parameter, if any
1:      *
1:      * @exception StandardException         Thrown on error
1:      */
1:     public static void bindOffsetFetch(ValueNode offset,
1:                                        ValueNode fetchFirst)
1:             throws StandardException {
1: 
1:         if (offset instanceof ConstantNode) {
1:             DataValueDescriptor dvd = ((ConstantNode)offset).getValue();
1:             long val = dvd.getLong();
1: 
1:             if (val < 0) {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_ROW_COUNT_OFFSET,
1:                     Long.toString(val) );
1:             }
1:         } else if (offset instanceof ParameterNode) {
1:             offset.
1:                 setType(new DataTypeDescriptor(
1:                             TypeId.getBuiltInTypeId(Types.BIGINT),
1:                             false /* ignored tho; ends up nullable,
1:                                      so we test for NULL at execute time */));
1:         }
1: 
1: 
1:         if (fetchFirst instanceof ConstantNode) {
1:             DataValueDescriptor dvd = ((ConstantNode)fetchFirst).getValue();
1:             long val = dvd.getLong();
1: 
1:             if (val < 1) {
1:                 throw StandardException.newException(
1:                     SQLState.LANG_INVALID_ROW_COUNT_FIRST,
1:                     Long.toString(val) );
1:             }
1:         } else if (fetchFirst instanceof ParameterNode) {
1:             fetchFirst.
1:                 setType(new DataTypeDescriptor(
1:                             TypeId.getBuiltInTypeId(Types.BIGINT),
1:                             false /* ignored tho; ends up nullable,
1:                                      so we test for NULL at execute time*/));
1:         }
1:     }
1: 
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	 * Print call stack for debug purposes
1: 	 */
1: 
0: 	public void stackPrint()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			debugPrint("Stacktrace:\n");
1: 			Exception e = new Exception("dummy");
1:             StackTraceElement[] st= e.getStackTrace();
1:             for (int i=0; i<st.length; i++) {
1:                 debugPrint(st[i] + "\n");
1:             }
1: 
1: 			debugFlush();
1: 		}
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 				if (thisStr.charAt(thisStr.length()-1) != '\n') {
1: 					debugPrint("\n");
1: 				}
1: 
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: 			String thisStr = formatNodeString(this.toString(), 0);
1: 
1: 			if (containsInfo(thisStr) &&
1: 					!SanityManager.DEBUG_ON("DumpBrief")) {
1: 				debugPrint(thisStr);
1: 			}
1: 
/////////////////////////////////////////////////////////////////////////
0: 			Map printed =
1: 				getLanguageConnectionContext().getPrintedObjectsMap();
1: 
1: 			if (printed.containsKey(this)) {
1: 				debugPrint(formatNodeString(nodeHeader(), depth));
1: 				debugPrint(formatNodeString("***truncated***\n", depth));
1: 			} else {
1: 				printed.put(this, null);
1: 				debugPrint(formatNodeString(nodeHeader(), depth));
1: 				String thisStr = formatNodeString(this.toString(), depth);
1: 
1: 				if (containsInfo(thisStr) &&
1: 						!SanityManager.DEBUG_ON("DumpBrief")) {
1: 					debugPrint(thisStr);
1: 				}
1: 
1: 				printSubNodes(depth);
1: 			}
1: 
1: 
1: 	private static boolean containsInfo(String str) {
1: 		for (int i = 0; i < str.length(); i++) {
1: 			if (str.charAt(i) != '\t' && str.charAt(i) != '\n') {
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Vector members containing subclasses of QueryTreeNode should subclass
1: 	 * QueryTreeNodeVector. Such subclasses form a special case: These classes
1: 	 * should not implement printSubNodes, since there is generic handling in
1: 	 * QueryTreeNodeVector.  They should only implement toString if they
1: 	 * contain additional members.
1: 	 *
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND, AliasDescriptor.getAliasType(udtNameSpace),  unqualifiedTypeName);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:174db5a
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0: 		  case JDBC40Translation.SQLXML:
commit:0978789
/////////////////////////////////////////////////////////////////////////
1: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableName, schema,
1:                 this.getLanguageConnectionContext().getTransactionCompile());
commit:d1fbe3c
/////////////////////////////////////////////////////////////////////////
1: 	 * Get a ConstantNode to represent a typed null value. 
1: 	 * @param type Type of the null node.
0: 	public  ConstantNode getNullNode(DataTypeDescriptor type)
0:         int constantNodeType;
0: 		switch (type.getTypeId().getJDBCTypeId())
0:               constantNodeType = C_NodeTypes.VARCHAR_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.CHAR_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.TINYINT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.SMALLINT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.INT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.LONGINT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.FLOAT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.DOUBLE_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.DECIMAL_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.USERTYPE_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.BIT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.VARBIT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.LONGVARCHAR_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.CLOB_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.LONGVARBIT_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.BLOB_CONSTANT_NODE;
0:               constantNodeType = C_NodeTypes.XML_CONSTANT_NODE;
1:             
0:           case Types.BOOLEAN:
0:               constantNodeType = C_NodeTypes.BOOLEAN_CONSTANT_NODE;
1:               break;
0: 			if (type.getTypeId().userType())
0:                 constantNodeType = C_NodeTypes.USERTYPE_CONSTANT_NODE;
1:                         type.getTypeId().getSQLTypeName() + " in getNullNode");
1:         
0:         ConstantNode constantNode = (ConstantNode) getNodeFactory().getNode(
0:                 constantNodeType,
0:                 type.getTypeId(),
0:                 cm);
0:         constantNode.setType(type.getNullabilityType(true));
1: 
0: 		return constantNode;
commit:20d5490
/////////////////////////////////////////////////////////////////////////
1: 	 * parameter is NULL, it gets the descriptor for the current
1: 	 * compilation schema.
1:      * 
1:      * QueryTreeNodes must obtain schemas using this method or the two argument
1:      * version of it. This is to ensure that the correct default compliation schema
1:      * is returned and to allow determination of if the statement being compiled
1:      * depends on the current schema. 
1:      * 
1:      * Schema descriptors include authorization ids and schema ids.
1: 	 *			current compilation schema.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get the descriptor for the named schema. If the schemaName
1:      * parameter is NULL, it gets the descriptor for the current
1:      * compilation schema.
1:      * 
1:      * QueryTreeNodes must obtain schemas using this method or the single argument
1:      * version of it. This is to ensure that the correct default compliation schema
1:      * is returned and to allow determination of if the statement being compiled
1:      * depends on the current schema. 
1:      * 
1:      * @param schemaName The name of the schema we're interested in.
1:      * If the name is NULL, get the descriptor for the current compilation schema.
1:      * @param raiseError True to raise an error if the schema does not exist,
1:      * false to return null if the schema does not exist.
1:      * @return Valid SchemaDescriptor or null if raiseError is false and the
1:      * schema does not exist. 
1:      * @throws StandardException Schema does not exist and raiseError is true.
1:      */
commit:2e1b5e8
/////////////////////////////////////////////////////////////////////////
1: 	 * Verify that a java class exists, is accessible (public)
1:      * and not a class representing a primitive type.
1: 	void verifyClassExist(String javaClassName)
/////////////////////////////////////////////////////////////////////////
commit:4fb136d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: 
1: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.types.SynonymAliasInfo;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.impl.sql.execute.GenericConstantActionFactory;
1: import org.apache.derby.impl.sql.execute.GenericExecutionFactory;
commit:354d5e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:8a93440
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:be0b54f
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	** Parse the a SQL statement from the body
1: 	* of another SQL statement. Pushes and pops a
1: 	* separate CompilerContext to perform the compilation.
1: 	*/
1: 	StatementNode parseStatement(String sql, boolean internalSQL) throws StandardException
1: 		/*
1: 		** Get a new compiler context, so the parsing of the text
1: 		** doesn't mess up anything in the current context 
1: 		*/
1: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 		CompilerContext newCC = lcc.pushCompilerContext();
1: 		if (internalSQL)
1: 		    newCC.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1: 		try
1: 		{
1: 			Parser p = newCC.getParser();
0: 			return p.parseStatement(sql);
1: 		}
1: 		finally
1: 		{
1: 			lcc.popCompilerContext(newCC);
1: 		}
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 	 * In Derby SQL Standard Authorization, views, triggers and constraints 
1: 	 * execute with definer's privileges. Taking a specific eg of views
1: 	 * user1
1: 	 * create table t1 (c11 int);
1: 	 * create view v1 as select * from user1.t1;
1: 	 * grant select on v1 to user2;
1: 	 * user2
1: 	 * select * from user1.v1;
1: 	 * Running with definer's privileges mean that since user2 has select
1: 	 * privileges on view v1 owned by user1, then that is sufficient for user2
1: 	 * to do a select from view v1. View v1 underneath might access some
1: 	 * objects that user2 doesn't have privileges on, but that is not a problem
1: 	 * since views execute with definer's privileges. In order to implement this
1: 	 * behavior, when doing a select from view v1, we only want to check for
1: 	 * select privilege on view v1. While processing the underlying query for
1: 	 * view v1, we want to stop collecting the privilege requirements for the
1: 	 * query underneath. Following flag, isPrivilegeCollectionRequired is used
1: 	 * for this purpose. The flag will be true when we are the top level of view
1: 	 * and then it is turned off while we process the query underlying the view
1: 	 * v1.             
1: 	 */
0: 	boolean isPrivilegeCollectionRequired = true;
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 	 * Triggers, constraints and views get executed with their definer's
0: 	 * privileges and they can exist in the system only if their definers'
0: 	 * still have all the privileges to creeate them. Based on this, any
1: 	 * time a trigger/view/constraint is executing, we do not need to waste
1: 	 * time in checking if the definer still has the right set of privileges.
0: 	 * At compile time, we wil make sure that we do not collect the privilege
1: 	 * requirement for objects accessed with definer privileges by calling the
1: 	 * following method. 
1: 	 */
0: 	public void disablePrivilegeCollection()
1: 	{
1: 		isPrivilegeCollectionRequired = false;
1: 	}
1: 
1: 	/**
1: 	 * Return true from this method means that we need to collect privilege
1: 	 * requirement for this node. For following cases, this method will
1: 	 * return true.
1: 	 * 1)execute view - collect privilege to access view but do not collect
1: 	 * privilege requirements for objects accessed by actual view uqery
1: 	 * 2)execute select - collect privilege requirements for objects accessed
1: 	 * by select statement
1: 	 * 3)create view -  collect privileges for select statement : the select
1: 	 * statement for create view falls under 2) category above.
1: 	 * 
1: 	 * @return true if need to collect privilege requirement for this node
1: 	 */
0: 	public boolean isPrivilegeCollectionRequired()
1: 	{
0: 		return(isPrivilegeCollectionRequired);
1: 	}
1: 
1: 	/**
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0: 			else if (typeId.userType())
commit:7f1493a
/////////////////////////////////////////////////////////////////////////
1: 	private int		beginOffset = -1;		// offset into SQL input of the substring
1: 	private int		endOffset = -1;
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	The beginning offset of the SQL substring. -1 means unknown.
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	The ending offset of the SQL substring. -1 means unknown.
commit:2542f1d
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.QueryTreeNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.execute.GenericConstantActionFactory;
0: import org.apache.derby.impl.sql.execute.GenericExecutionFactory;
0: import org.apache.derby.iapi.util.ByteArray;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: import org.apache.derby.iapi.sql.compile.Parser;
1: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.catalog.AliasInfo;
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
1: /**
1:  * QueryTreeNode is the root class for all query tree nodes. All
1:  * query tree nodes inherit from QueryTreeNode except for those that extend
1:  * QueryTreeNodeVector.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class QueryTreeNode implements Visitable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public static final int AUTOINCREMENT_START_INDEX = 0;
0: 	public static final int AUTOINCREMENT_INC_INDEX   = 1;
0: 	public static final int AUTOINCREMENT_IS_AUTOINCREMENT_INDEX   = 2;
1: 
0: 	int				beginOffset;		// offset into SQL input of the substring
1: 	                                // which this query node encodes.
0: 	int				endOffset;
1: 
0: 	private int nodeType;
1: 	private ContextManager cm;
1: 	private LanguageConnectionContext lcc;
1: 	private GenericConstantActionFactory	constantActionFactory;
1: 
1: 	/**
0: 	 * Set the ContextManager for this node.
1: 	 * 
0: 	 * @param cm	The ContextManager.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setContextManager(ContextManager cm)
1: 	{
0: 		this.cm = cm;
1: 		
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(cm != null,
0: 				"cm not expected to be null");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the current ContextManager.
1: 	 *
1: 	 * @return The current ContextManager.
1: 	 */
0: 	public final ContextManager getContextManager()
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			if (cm == null)
1: 				SanityManager.THROWASSERT("Null context manager in QueryTreeNode of type :" + this.getClass());
1: 		}
1: 		return cm;
1: 	}
1: 
1: 	/**
1: 	  *	Gets the NodeFactory for this database.
1: 	  *
1: 	  *	@return	the node factory for this database.
1: 	  *
1: 	  */
0: 	public	final NodeFactory	getNodeFactory() 
1: 	{
1: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
0: 			                                            getNodeFactory();
1: 	}
1: 
1: 
1: 	/**
1: 	  *	Gets the constant action factory for this database.
1: 	  *
1: 	  *	@return	the constant action factory.
1: 	  */
1: 	public	final GenericConstantActionFactory	getGenericConstantActionFactory()
1: 	{
1: 		if ( constantActionFactory == null )
1: 		{
1: 			GenericExecutionFactory	execFactory = (GenericExecutionFactory) getExecutionFactory();
1: 			constantActionFactory = execFactory.getConstantActionFactory();
1: 		}
1: 
1: 		return constantActionFactory;
1: 	}
1: 
1: 	public	final	ExecutionFactory	getExecutionFactory()
1: 	{
1: 		ExecutionFactory	ef = getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory();
1: 
1: 		return ef;
1: 	}
1: 
1: 	/**
1: 		Get the ClassFactory to use with this database.
1: 	*/
1: 	protected final ClassFactory getClassFactory() {
1: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
1: 			getClassFactory();
1: 	}
1: 
1: 	/**
1: 	  *	Gets the LanguageConnectionContext for this connection.
1: 	  *
1: 	  *	@return	the lcc for this connection
1: 	  *
1: 	  */
1: 	protected final LanguageConnectionContext	getLanguageConnectionContext()
1: 	{
1: 		if (lcc == null)
1: 		{
1: 			lcc = (LanguageConnectionContext) getContextManager().
1: 							getContext(LanguageConnectionContext.CONTEXT_ID);
1: 		}
1: 		return lcc;
1: 	}
1: 
1: 	/**
0: 	 * Get the name of the SPS that is used
0: 	 * to execute this statement.  Only relevant
0: 	 * for an ExecSPSNode -- otherwise, returns null.
1: 	 *
0: 	 * @return the name of the underlying sps
1: 	 */
0: 	public String getSPSName()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Gets the beginning offset of the SQL substring which this
1: 	 * query node represents.
1: 	 *
0: 	 * @return	The beginning offset of the SQL substring.
1: 	 *
1: 	 */
1:     public	int	getBeginOffset() { return beginOffset; }
1: 
1: 	/**
1: 	 * Sets the beginning offset of the SQL substring which this
1: 	 * query node represents.
1: 	 *
0: 	 * @param	The beginning offset of the SQL substring.
1: 	 *
1: 	 */
1:     public	void	setBeginOffset( int beginOffset )
1: 	{
1: 		this.beginOffset = beginOffset;
1: 	}
1: 
1: 	/**
1: 	 * Gets the ending offset of the SQL substring which this
1: 	 * query node represents.
1: 	 *
0: 	 * @return	The ending offset of the SQL substring.
1: 	 *
1: 	 */
1: 	public	int	getEndOffset()  { return endOffset; }
1: 
1: 	/**
1: 	 * Sets the ending offset of the SQL substring which this
1: 	 * query node represents.
1: 	 *
0: 	 * @param	The ending offset of the SQL substring.
1: 	 *
1: 	 */
1: 	public	void	setEndOffset( int endOffset )
1: 	{
1: 		this.endOffset = endOffset;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return header information for debug printing of this query
1: 	 * tree node.
1: 	 *
1: 	 * @return	Header information for debug printing of this query
1: 	 *		tree node.
1: 	 */
1: 
1: 	protected String	nodeHeader()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "\n" + this.getClass().getName() + '@' +
1: 					Integer.toHexString(hashCode()) + "\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Format a node that has been converted to a String for printing
1: 	 * as part of a tree.  This method indents the String to the given
1: 	 * depth by inserting tabs at the beginning of the string, and also
1: 	 * after every newline.
1: 	 *
1: 	 * @param nodeString	The node formatted as a String
1: 	 * @param depth		The depth to indent the given node
1: 	 *
1: 	 * @return	The node String reformatted with tab indentation
1: 	 */
1: 
0: 	public static String formatNodeString(String nodeString, int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			StringBuffer	nodeStringBuffer = new StringBuffer(nodeString);
1: 			int		pos;
1: 			char		c;
1: 			char[]		indent = new char[depth];
1: 
1: 			/*
1: 			** Form an array of tab characters for indentation.
1: 			*/
1: 			while (depth > 0)
1: 			{
1: 				indent[depth - 1] = '\t';
1: 				depth--;
1: 			}
1: 
1: 			/* Indent the beginning of the string */
0: 			nodeStringBuffer.insert(0, indent);
1: 
1: 			/*
1: 			** Look for newline characters, except for the last character.
1: 			** We don't want to indent after the last newline.
1: 			*/
0: 			for (pos = 0; pos < nodeStringBuffer.length() - 1; pos++)
1: 			{
0: 				c = nodeStringBuffer.charAt(pos);
1: 				if (c == '\n')
1: 				{
1: 					/* Indent again after each newline */
0: 					nodeStringBuffer.insert(pos + 1, indent);
1: 				}
1: 			}
1: 
0: 			return nodeStringBuffer.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Print this tree for debugging purposes.  This recurses through
1: 	 * all the sub-nodes and prints them indented by their depth in
1: 	 * the tree.
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
1: 	public void treePrint()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			debugPrint(nodeHeader());
0: 			debugPrint(formatNodeString(this.toString(), 0));
1: 			printSubNodes(0);
1: 			debugFlush();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Print this tree for debugging purposes.  This recurses through
1: 	 * all the sub-nodes and prints them indented by their depth in
1: 	 * the tree, starting with the given indentation.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree, thus,
1: 	 *			the amount to indent it when printing it.
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void treePrint(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			debugPrint(formatNodeString(nodeHeader(), depth));
0: 			debugPrint(formatNodeString(this.toString(), depth));
0: 			printSubNodes(depth);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Print a String for debugging
1: 	 *
1: 	 * @param outputString	The String to print
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public static void debugPrint(String outputString)
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.GET_DEBUG_STREAM().print(outputString);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Flush the debug stream out
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 	protected static void debugFlush()
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.GET_DEBUG_STREAM().flush();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Print the sub-nodes of this node.
1: 	 *
1: 	 * Each sub-class of QueryTreeNode is expected to provide its own
1: 	 * printSubNodes() method.  In each case, it calls super.printSubNodes(),
1: 	 * passing along its depth, to get the sub-nodes of the super-class.
1: 	 * Then it prints its own sub-nodes by calling treePrint() on each
1: 	 * of its members that is a type of QueryTreeNode.  In each case where
1: 	 * it calls treePrint(), it should pass "depth + 1" to indicate that
1: 	 * the sub-node should be indented one more level when printing.
1: 	 * Also, it should call printLabel() to print the name of each sub-node
1: 	 * before calling treePrint() on the sub-node, so that the reader of
1: 	 * the printed tree can tell what the sub-node is.
1: 	 *
1: 	 * This printSubNodes() exists in here merely to act as a backstop.
1: 	 * In other words, the calls to printSubNodes() move up the type
1: 	 * hierarchy, and in this node the calls stop.
1: 	 *
1: 	 * I would have liked to put the call to super.printSubNodes() in
1: 	 * this super-class, but Java resolves "super" statically, so it
1: 	 * wouldn't get to the right super-class.
1: 	 *
1: 	 * @param depth		The depth to indent the sub-nodes
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Format this node as a string
1: 	 *
1: 	 * Each sub-class of QueryTreeNode should implement its own toString()
1: 	 * method.  In each case, toString() should format the class members
1: 	 * that are not sub-types of QueryTreeNode (printSubNodes() takes care
1: 	 * of following the references to sub-nodes, and toString() takes care
1: 	 * of all members that are not sub-nodes).  Newlines should be used
1: 	 * liberally - one good way to do this is to have a newline at the
1: 	 * end of each formatted member.  It's also a good idea to put the
1: 	 * name of each member in front of the formatted value.  For example,
1: 	 * the code might look like:
1: 	 *
1: 	 * "memberName: " + memberName + "\n" + ...
1: 	 *
1: 	 * @return	This node formatted as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		return "";
1: 	}
1: 
1: 	/**
1: 	 * Print the given label at the given indentation depth.
1: 	 *
1: 	 * @param depth		The depth of indentation to use when printing
1: 	 *			the label
1: 	 * @param label		The String to print
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printLabel(int depth, String label)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			debugPrint(formatNodeString(label, depth));
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Perform the binding operation on a query tree.  Binding consists of
0: 	 * permissions checking, view resolution, datatype resolution, and
0: 	 * creation of a dependency list (for determining whether a tree or
0: 	 * plan is still up to date).
1: 	 *
0: 	 * This bind() method does nothing.  Each node type that can appear
0: 	 * at the top of a tree can override this method with its own bind()
0: 	 * method that does "something".
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Checks if the passed schema descriptor is for SESSION schema
1: 	 *
1: 	 * @return	true if the passed schema descriptor is for SESSION schema
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	final boolean isSessionSchema(SchemaDescriptor sd)
1: 	{
1: 		return isSessionSchema(sd.getSchemaName());
1: 	}
1: 
1: 	/**
1: 	 * Checks if the passed schema name is for SESSION schema
1: 	 *
1: 	 * @return	true if the passed schema name is for SESSION schema
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	final boolean isSessionSchema(String schemaName)
1: 	{
1: 		return SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME.equals(schemaName);
1: 	}
1: 
1: 	/**
0: 	 * Get the optimizer's estimate of the number of rows returned or affected
0: 	 * for an optimized QueryTree.
1: 	 *
0: 	 * For non-optimizable statements (for example, CREATE TABLE),
0: 	 * return 0. For optimizable statements, this method will be
0: 	 * over-ridden in the statement's root node (DMLStatementNode
0: 	 * in all cases we know about so far).
1: 	 *
0: 	 * @return	0L
1: 	 */
1: 
0: 	public long	getRowEstimate()
1: 	{
0: 		return	0L;
1: 	}
1: 
1: 	/**
0: 	 * Generates an optimized QueryTree from a bound QueryTree.  Actually,
0: 	 * it annotates the tree in place rather than generating a new tree,
0: 	 * but this interface allows the root node of the optmized QueryTree
0: 	 * to be different from the root node of the bound QueryTree.
1: 	 *
0: 	 * For non-optimizable statements (for example, CREATE TABLE),
0: 	 * return the bound tree without doing anything.  For optimizable
0: 	 * statements, this method will be over-ridden in the statement's
0: 	 * root node (DMLStatementNode in all cases we know about so far).
1: 	 *
0: 	 * Throws an exception if the tree is not bound, or if the binding
0: 	 * is out of date.
1: 	 *
0: 	 * @return	An optimized QueryTree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public QueryTreeNode optimize() throws StandardException
1: 	{
0: 		return this;
1: 	}
1: 
1: 	/**
0: 	 * this implementation of generate() is
0: 	 * a place-holder until all of the nodes that need to,
0: 	 * implement it. Only the root, statement nodes
0: 	 * implement this flavor of generate; the other nodes
0: 	 * will implement the version that returns Generators
0: 	 * and takes an activation class builder as an
0: 	 * argument.
1: 	 *
0: 	 * @param	ignored - ignored (he he)
1: 	 *
0: 	 * @return	A GeneratedClass for this statement
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public GeneratedClass generate(ByteArray ignored) throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.LANG_UNABLE_TO_GENERATE,
1: 			this.nodeHeader());
1: 	}
1: 
1: 	/**
1: 	 * Do the code generation for this node.  This is a place-holder
1: 	 * method - it should be over-ridden in the sub-classes.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The method for the generated code to go into
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	protected void generate(
0: 								ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.LANG_UNABLE_TO_GENERATE,
1: 			this.nodeHeader());
1: 	}
1: 
1: 	/**
0: 	 * Only DML statements have result descriptions - for all others
0: 	 * return null.  This method is overridden in DMLStatementNode.
1: 	 *
1: 	 * @return	null
1: 	 *
0: 	 * @exception StandardException never actually thrown here,
0: 	 *	but thrown by subclasses
1: 	 */
0: 	public ResultDescription makeResultDescription() 
1: 		throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Parameter info is stored in the compiler context.
1: 	 * Hide this from the callers.
1: 	 *
1: 	 *
1: 	 * @return	null
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public DataTypeDescriptor[] getParameterTypes()
1: 		throws StandardException
1: 	{
0: 		return getCompilerContext().getParameterTypes();
1: 	}
1: 
1: 	/**
1: 	 * This creates a class that will do the work that's constant
1: 	 * across all Executions of a PreparedStatement. It's up to
1: 	 * our subclasses to override this method if they need to compile
1: 	 * constant actions into PreparedStatements.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 		return	null;
1: 	}
1: 
1: 	/**
0: 	 * Returns whether or not this Statement requires a set/clear savepoint
0: 	 * around its execution.  The following statement "types" do not require them:
0: 	 *		Cursor	- unnecessary and won't work in a read only environment
0: 	 *		Xact	- savepoint will get blown away underneath us during commit/rollback
0: 	 * <p>
0: 	 * ONLY CALLABLE AFTER GENERATION
1: 	 *
0: 	 * @return boolean	Whether or not this Statement requires a set/clear savepoint
1: 	 */
0: 	public boolean needsSavepoint()
1: 	{
0: 		return true;
1: 	}
1: 
1: 	/**
0: 	 * Returns the name of statement in EXECUTE STATEMENT command.
0: 	 * Returns null for all other commands.  
0: 	 * @return String null unless overridden for Execute Statement command
1: 	 */
0: 	public String executeStatementName()
1: 	{
1: 		return null;
1: 	}
1: 
1:   /**
0:    * Returns name of schema in EXECUTE STATEMENT command.
0:    * Returns null for all other commands.
0:    * @return String schema for EXECUTE STATEMENT null for all others
1:    */
0: 	public String executeSchemaName()
1: 	{
1: 		return null;
1: 	}
1: 
1:     /**
0: 	 * Set the node type for this node.
1: 	 *
0: 	 * @param nodeType The node type.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setNodeType(int nodeType)
1: 	{
0: 		this.nodeType = nodeType;
1: 	}
1: 
0: 	protected int getNodeType()
1: 	{
0: 		return nodeType;
1: 	}
1: 
1: 	/**
0: 	 * For final nodes, return whether or not
0: 	 * the node represents the specified nodeType.
1: 	 *
0: 	 * @param nodeType	The nodeType of interest.
1: 	 *
0: 	 * @return Whether or not
0: 	 * the node represents the specified nodeType.
1: 	 */
0: 	protected boolean isInstanceOf(int nodeType)
1: 	{
0: 		return (this.nodeType == nodeType);
1: 	}
1: 
1: 	/**
1: 	 * Get the DataDictionary
1: 	 *
1: 	 * @return The DataDictionary
1: 	 *
1: 	 */
0: 	public final DataDictionary getDataDictionary()
1: 	{
1: 		return getLanguageConnectionContext().getDataDictionary();
1: 	}
1: 
0: 	public final DependencyManager getDependencyManager()
1: 	{
1: 		return getDataDictionary().getDependencyManager();
1: 	}
1: 
1: 	/**
1: 	 * Get the CompilerContext
1: 	 *
1: 	 * @return The CompilerContext
1: 	 */
1: 	protected final CompilerContext getCompilerContext()
1: 	{
1: 		return (CompilerContext) getContextManager().
1: 										getContext(CompilerContext.CONTEXT_ID);
1: 	}
1: 
1: 	/**
1: 	 * Get the TypeCompiler associated with the given TypeId
1: 	 *
1: 	 * @param typeId	The TypeId to get a TypeCompiler for
1: 	 *
1: 	 * @return	The corresponding TypeCompiler
1: 	 *
1: 	 */
1: 	protected final TypeCompiler getTypeCompiler(TypeId typeId)
1: 	{
1: 		return
1: 		  getCompilerContext().getTypeCompilerFactory().getTypeCompiler(typeId);
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		return v.visit(this);
1: 	}
1: 
1: 	/**
1: 	 * Get the int value of a Property
1: 	 *
1: 	 * @param value		Property value as a String
1: 	 * @param key		Key value of property
1: 	 *
1: 	 * @return	The int value of the property
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	protected int getIntProperty(String value, String key)
1: 		throws StandardException
1: 	{
1: 		int intVal = -1;
1: 		try
1: 		{
1: 			intVal = Integer.parseInt(value);
1: 		}
1: 		catch (NumberFormatException nfe)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
1: 					value, key);
1: 		}
1: 		return intVal;
1: 	}
1: 
1: 	/**
0: 	 * Parse some query text and return a parse tree.
1: 	 *
0: 	 * @param compilerContext	The CompilerContext to use
0: 	 * @param createViewText	Query text to parse.
0: 	 * @param paramDefaults		array of parameter defaults used to
0: 	 *							initialize parameter nodes, and ultimately
0: 	 *							for the optimization of statements with
0: 	 *							parameters.
0: 	 * @param lcc				Current LanguageConnectionContext
1: 	 *
0: 	 * @return	ResultSetNode	The parse tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public static QueryTreeNode
0: 	parseQueryText
1: 	(
0: 		CompilerContext		compilerContext,
0: 		String				queryText,
0: 		Object[]			paramDefaults,
0: 		LanguageConnectionContext lcc
1:     )
1: 		 throws StandardException
1: 	{
0: 		LanguageConnectionFactory	lcf;
0: 		Parser						p;
0: 		QueryTreeNode			    qtn;
1: 
0: 		p = compilerContext.getParser();
1: 		
0: 		/* Get a Statement to pass to the parser */
0: 		lcf = lcc.getLanguageConnectionFactory();
1: 
0: 		/* Finally, we can call the parser */
0: 		qtn = (QueryTreeNode)p.parseStatement(queryText, paramDefaults);
0: 		return	qtn;
1: 	}
1: 
1: 	/**
1: 	 * Return the type of statement, something from
1: 	 * StatementType.
1: 	 *
1: 	 * @return the type of statement
1: 	 */
1: 	protected int getStatementType()
1: 	{
1: 		return StatementType.UNKNOWN;
1: 	}
1: 
0: 	public boolean foundString(String[] list, String search)
1: 	{
0: 		if (list == null)
1: 		{
1: 			return false;
1: 		}
1: 
0: 		for (int i = 0; i < list.length; i++)
1: 		{
0: 			if (list[i].equals(search))
1: 			{	
0: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Get a ConstantNode to represent a typed null value
1: 	 *
0: 	 * @param typeId	The TypeId of the datatype of the null value
0: 	 * @param cm		The ContextManager
1: 	 *
1: 	 * @return	A ConstantNode with the specified type, and a value of null
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public  ConstantNode getNullNode(TypeId typeId,
0: 			ContextManager cm)
1: 		throws StandardException
1: 	{
0: 		QueryTreeNode constantNode = null;
0: 		NodeFactory nf = getNodeFactory();
1: 
0: 		switch (typeId.getJDBCTypeId())
1: 		{
0: 		  case Types.VARCHAR:
0: 			constantNode =  nf.getNode(
0: 										C_NodeTypes.VARCHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.CHAR:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.TINYINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.SMALLINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.INTEGER:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.INT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.BIGINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.REAL:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.DOUBLE:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.NUMERIC:
0: 		  case Types.DECIMAL:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.DECIMAL_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
1: 		  case Types.DATE:
1: 		  case Types.TIME:
0: 		  case Types.TIMESTAMP:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.BINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.BIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.VARBINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.VARBIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.LONGVARCHAR:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGVARCHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.CLOB:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.CLOB_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.LONGVARBINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGVARBIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
0: 		  case Types.BLOB:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.BLOB_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			break;
1: 
1: 		  default:
0: 			if (typeId.getSQLTypeName().equals("BOOLEAN"))
1: 			{
0: 				constantNode = nf.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			}
0: 			else if ( ! typeId.builtIn())
1: 			{
0: 				constantNode = nf.getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT( "Unknown type " + 
0: 						typeId.getSQLTypeName() + " in getNullNode");
1: 				return null;
1: 			}
1: 		}
1: 
0: 		return (ConstantNode) constantNode;
1: 	}
1: 
1: 	/**
1: 	 * Translate a Default node into a default value, given a type descriptor.
1: 	 *
1: 	 * @param typeDescriptor	A description of the required data type.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public DataValueDescriptor convertDefaultNode(DataTypeDescriptor typeDescriptor)
1: 							throws StandardException
1: 	{
1: 		/*
1: 		** Override in cases where node type
1: 		** can be converted to default value.
1: 		*/
1: 		return null;
1: 	}
1: 
0: 	/* Initializable methods */
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Single-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Two-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Three-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Four-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Five-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Six-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Seven-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Eight-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Nine-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Ten-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Eleven-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Twelve-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12,
0: 						Object arg13) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Thirteen-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Initialize a query tree node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12,
0: 						Object arg13,
0: 						Object arg14) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("Fourteen-argument init() not implemented for " + getClass().getName());
1: 		}
1: 	}
1: 
1: 	public	TableName	makeTableName
1: 	(
1: 		String	schemaName,
1: 		String	flatName
1: 	)
1: 		throws StandardException
1: 	{
0: 		return (TableName) getNodeFactory().getNode
1: 			(
0: 				C_NodeTypes.TABLE_NAME,
0: 				schemaName,
0: 				flatName,
0: 				getContextManager()
0: 			);
1: 	}
1: 
1: 	public boolean isAtomic() throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("isAtomic should not be called for this  class: " + getClass().getName());
1: 		}
1: 		
1: 		return false;
1: 	}
1: 	
0: 	public Object getCursorInfo() throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Get the descriptor for the named table within the given schema.
1: 	 * If the schema parameter is NULL, it looks for the table in the
1: 	 * current (default) schema. Table descriptors include object ids,
1: 	 * object types (table, view, etc.)
1: 	 * If the schema is SESSION, then before looking into the data dictionary
1: 	 * for persistent tables, it first looks into LCC for temporary tables.
1: 	 * If no temporary table tableName found for the SESSION schema, then it goes and
1: 	 * looks through the data dictionary for persistent table
1: 	 * We added getTableDescriptor here so that we can look for non data dictionary
1: 	 * tables(ie temp tables) here. Any calls to getTableDescriptor in data dictionary
1: 	 * should be only for persistent tables
1: 	 *
1: 	 * @param tableName	The name of the table to get the descriptor for
1: 	 * @param schema	The descriptor for the schema the table lives in.
1: 	 *			If null, use the current (default) schema.
1: 	 *
1: 	 * @return	The descriptor for the table, null if table does not
1: 	 *		exist.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	protected final TableDescriptor getTableDescriptor(String tableName,
1: 					SchemaDescriptor schema)
1: 						throws StandardException
1: 	{
1: 		TableDescriptor retval;
1: 
1: 		//Following if means we are dealing with SESSION schema.
1: 		if (isSessionSchema(schema))
1: 		{
1: 			//First we need to look in the list of temporary tables to see if this table is a temporary table.
1: 			retval = getLanguageConnectionContext().getTableDescriptorForDeclaredGlobalTempTable(tableName);
1: 			if (retval != null)
1: 				return retval; //this is a temporary table
1: 		}
1: 
1: 		//Following if means we are dealing with SESSION schema and we are dealing with in-memory schema (ie there is no physical SESSION schema)
1: 		//If following if is true, it means SESSION.table is not a declared table & it can't be physical SESSION.table
1: 		//because there is no physical SESSION schema
1: 		if (schema.getUUID() == null)
1: 			return null;
1: 
1: 		//it is not a temporary table, so go through the data dictionary to find the physical persistent table
0: 		return getDataDictionary().getTableDescriptor(tableName, schema);
1: 	}
1: 
1: 	/**
1: 	 * Get the descriptor for the named schema. If the schemaName
0: 	 * parameter is NULL, it gets the descriptor for the current (default)
0: 	 * schema. Schema descriptors include authorization ids and schema ids.
1: 	 * SQL92 allows a schema to specify a default character set - we will
1: 	 * not support this.  Will check default schema for a match
1: 	 * before scanning a system table.
1: 	 * 
1: 	 * @param schemaName	The name of the schema we're interested in.
1: 	 *			If the name is NULL, get the descriptor for the
0: 	 *			current schema.
1: 	 *
1: 	 * @return	The descriptor for the schema.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName)
1: 		throws StandardException
1: 	{
1: 		//return getSchemaDescriptor(schemaName, schemaName != null);
1: 		return getSchemaDescriptor(schemaName, true);
1: 	}
1: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName, boolean raiseError)
1: 		throws StandardException
1: 	{
1: 		/*
0: 		** Check for a compilation context.  Sometimes
0: 		** there is a special compilation context in
0: 	 	** place to recompile something that may have
0: 		** been compiled against a different schema than
0: 		** the current schema (e.g views):
0: 	 	**
0: 	 	** 	CREATE SCHEMA x
0: 	 	** 	CREATE TABLE t
0: 		** 	CREATE VIEW vt as SEELCT * FROM t
0: 		** 	SET SCHEMA app
0: 		** 	SELECT * FROM X.vt 
0: 		**
0: 		** In the above view vt must be compiled against
0: 		** the X schema.
1: 		*/
1: 
1: 
0: 		SchemaDescriptor sd = null;
0: 		boolean isCurrent = false;
0: 		boolean isCompilation = false;
0: 		if (schemaName == null) {
1: 
1: 			CompilerContext cc = getCompilerContext();
0: 			sd = cc.getCompilationSchema();
1: 
0: 			if (sd == null) {
0: 				// Set the compilation schema to be the default,
0: 				// notes that this query has schema dependencies.
0: 				sd = getLanguageConnectionContext().getDefaultSchema();
1: 
0: 				isCurrent = true;
1: 
0: 				cc.setCompilationSchema(sd);
1: 			}
1: 			else
1: 			{
0: 				isCompilation = true;
1: 			}
0: 			schemaName = sd.getSchemaName();
1: 		}
1: 
0: 		DataDictionary dataDictionary = getDataDictionary();
0: 		SchemaDescriptor sdCatalog = dataDictionary.getSchemaDescriptor(schemaName,
0: 			getLanguageConnectionContext().getTransactionCompile(), raiseError);
1: 
0: 		if (isCurrent || isCompilation) {
0: 			if (sdCatalog != null)
1: 			{
0: 				// different UUID for default (current) schema than in catalog,
0: 				// so reset default schema.
0: 				if (!sdCatalog.getUUID().equals(sd.getUUID()))
1: 				{
0: 					if (isCurrent)
0: 						getLanguageConnectionContext().setDefaultSchema(sdCatalog);
0: 					getCompilerContext().setCompilationSchema(sdCatalog);
1: 				}
1: 			}
1: 			else
1: 			{
0: 				// this schema does not exist, so ensure its UUID is null.
0: 				sd.setUUID(null);
0: 				sdCatalog = sd;
1: 			}
1: 		}
0: 		return sdCatalog;
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * @param javaClassName	The name of the java class to resolve.
1: 	 *
0: 	 * @param convertCase	whether to convert the case before resolving class alias.
1: 	 *
0: 	 * @return	Resolved class name or class alias name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	String verifyClassExist(String javaClassName, boolean convertCase)
1: 		throws StandardException
1: 	{
0: 		/* Verify that the class exists */
1: 
1: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
0: 		/* We first try to resolve the javaClassName as a class.  If that
0: 		 * fails then we try to resolve it as a class alias.
1: 		 */
1: 
1: 		Throwable reason = null;
1: 		boolean foundMatch = false;
1: 		try {
1: 
1: 			foundMatch = classInspector.accessible(javaClassName);
1: 
1: 		} catch (ClassNotFoundException cnfe) {
1: 
1: 			reason = cnfe;
0: 		} catch (LinkageError le) {
0: 			reason = le;
1: 		}
1: 
1: 		if (!foundMatch)
1: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST2, reason, javaClassName);
1: 
1: 		if (ClassInspector.primitiveType(javaClassName))
1: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST3, javaClassName);
1: 
0: 		return javaClassName;
1: 	}
1: 
1: 	/**
1: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
1: 								 int[]fkColArray, 
1: 								 String parentResultSetId,
1: 								 boolean dependentScan)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"setRefActionInfo() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 	}
1: 
1: 	/**
1: 		Add an authorization check into the passed in method.
1: 	*/
1: 	void generateAuthorizeCheck(ActivationClassBuilder acb,
1: 								MethodBuilder mb,
1: 								int sqlOperation) {
1: 		// add code to authorize statement execution.
1: 		acb.pushThisAsActivation(mb);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getLanguageConnectionContext",
1: 											 ClassName.LanguageConnectionContext, 0);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getAuthorizer",
1: 											 ClassName.Authorizer, 0);
1: 
1: 		mb.push(sqlOperation);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "authorize",
0: 											 "void", 1);
1: 	}
1: 	
1: 
1: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:68f9f47
/////////////////////////////////////////////////////////////////////////
0: 	 * Get a ConstantNode to represent a typed null value. Then set it's 
0: 	 * collation type and derivation
0: 	 * @param collationType The collation type of the ConstantNode
0: 	 * @param collationDerivation The Collation Derivation of the ConstantNode
0: 			ContextManager cm, int collationType, int collationDerivation)
/////////////////////////////////////////////////////////////////////////
0: 		ConstantNode cn = (ConstantNode) constantNode;
0: 		cn.getTypeServices().setCollationType(collationType);
0: 		cn.getTypeServices().setCollationDerivation(collationDerivation);
0: 		return cn;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:4d04c7b
/////////////////////////////////////////////////////////////////////////
0: 			//if we are dealing with a SESSION schema and it is not physically
0: 			//created yet, then it's uuid is going to be null. DERBY-1706
0: 			//Without the getUUID null check below, following will give NPE
0: 			//set schema session; -- session schema has not been created yet
0: 			//create table t1(c11 int);
0: 			if (sdCatalog != null && sdCatalog.getUUID() != null)
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	beginOffset	The beginning offset of the SQL substring.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	endOffset	The ending offset of the SQL substring.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param queryText	Query text to parse.
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: 		acb.pushThisAsActivation(mb);
1: 											 "void", 2);
commit:6a5edfc
/////////////////////////////////////////////////////////////////////////
1: 	//Parser uses this static field to make a note if the autoincrement column 
1: 	//is participating in create or alter table.
0: 	public static final int AUTOINCREMENT_CREATE_MODIFY  = 3;
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
/////////////////////////////////////////////////////////////////////////
0: 		  case StoredFormatIds.XML_TYPE_ID:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.XML_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
commit:81ad58c
/////////////////////////////////////////////////////////////////////////
0: 		CompilerContext cc = getCompilerContext();
/////////////////////////////////////////////////////////////////////////
1: 			/* Query is dependent on the AliasDescriptor */
1: 			cc.createDependency(nextAD);
0: 
commit:582425f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.SynonymAliasInfo;
/////////////////////////////////////////////////////////////////////////
0: 		TableDescriptor td = getDataDictionary().getTableDescriptor(tableName, schema);
1: 		if (td == null || td.isSynonymDescriptor())
0: 			return null;
1: 		return td;
/////////////////////////////////////////////////////////////////////////
1: 	 * Resolve table/view reference to a synonym. May have to follow a synonym chain.
0: 	 *
1: 	 * @param	tabName to match for a synonym
0: 	 *
1: 	 * @return	Synonym TableName if a match is found, NULL otherwise.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public TableName resolveTableToSynonym(TableName tabName) throws StandardException
0: 	{
1: 		DataDictionary dd = getDataDictionary();
1: 		String nextSynonymTable = tabName.getTableName();
1: 		String nextSynonymSchema = tabName.getSchemaName();
1: 		boolean found = false;
0: 
1: 		// Circular synonym references should have been detected at the DDL time, so
1: 		// the following loop shouldn't loop forever.
1: 		for (;;)
0: 		{
1: 			SchemaDescriptor nextSD = getSchemaDescriptor(nextSynonymSchema, false);
1: 			if (nextSD == null || nextSD.getUUID() == null)
0: 				break;
0: 	
1: 			AliasDescriptor nextAD = dd.getAliasDescriptor(nextSD.getUUID().toString(),
1: 						 nextSynonymTable, AliasInfo.ALIAS_NAME_SPACE_SYNONYM_AS_CHAR);
1: 			if (nextAD == null)
0: 				break;
0: 
1: 			found = true;
1: 			SynonymAliasInfo info = ((SynonymAliasInfo)nextAD.getAliasInfo());
1: 			nextSynonymTable = info.getSynonymTable();
1: 			nextSynonymSchema = info.getSynonymSchema();
0: 		}
0: 
1: 		if (!found)
0: 			return null;
0: 
0: 		TableName tableName = new TableName();
0: 		tableName.init(nextSynonymSchema, nextSynonymTable);
1: 		return tableName;
0: 	}
0: 
0: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.execute.GenericConstantActionFactory;
0: import org.apache.derby.impl.sql.execute.GenericExecutionFactory;
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.catalog.AliasInfo;
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: /**
0:  * QueryTreeNode is the root class for all query tree nodes. All
0:  * query tree nodes inherit from QueryTreeNode except for those that extend
0:  * QueryTreeNodeVector.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class QueryTreeNode implements Visitable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public static final int AUTOINCREMENT_START_INDEX = 0;
0: 	public static final int AUTOINCREMENT_INC_INDEX   = 1;
0: 	public static final int AUTOINCREMENT_IS_AUTOINCREMENT_INDEX   = 2;
0: 
0: 	int				beginOffset;		// offset into SQL input of the substring
0: 	                                // which this query node encodes.
0: 	int				endOffset;
0: 
0: 	private int nodeType;
0: 	private ContextManager cm;
0: 	private LanguageConnectionContext lcc;
0: 	private GenericConstantActionFactory	constantActionFactory;
0: 
0: 	/**
0: 	 * Set the ContextManager for this node.
0: 	 * 
0: 	 * @param cm	The ContextManager.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setContextManager(ContextManager cm)
0: 	{
0: 		this.cm = cm;
0: 		
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(cm != null,
0: 				"cm not expected to be null");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the current ContextManager.
0: 	 *
0: 	 * @return The current ContextManager.
0: 	 */
0: 	public final ContextManager getContextManager()
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			if (cm == null)
0: 				SanityManager.THROWASSERT("Null context manager in QueryTreeNode of type :" + this.getClass());
0: 		}
0: 		return cm;
0: 	}
0: 
0: 	/**
0: 	  *	Gets the NodeFactory for this database.
0: 	  *
0: 	  *	@return	the node factory for this database.
0: 	  *
0: 	  */
0: 	public	final NodeFactory	getNodeFactory() 
0: 	{
0: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
0: 			                                            getNodeFactory();
0: 	}
0: 
0: 
0: 	/**
0: 	  *	Gets the constant action factory for this database.
0: 	  *
0: 	  *	@return	the constant action factory.
0: 	  */
0: 	public	final GenericConstantActionFactory	getGenericConstantActionFactory()
0: 	{
0: 		if ( constantActionFactory == null )
0: 		{
0: 			GenericExecutionFactory	execFactory = (GenericExecutionFactory) getExecutionFactory();
0: 			constantActionFactory = execFactory.getConstantActionFactory();
0: 		}
0: 
0: 		return constantActionFactory;
0: 	}
0: 
0: 	public	final	ExecutionFactory	getExecutionFactory()
0: 	{
0: 		ExecutionFactory	ef = getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory();
0: 
0: 		return ef;
0: 	}
0: 
0: 	/**
0: 		Get the ClassFactory to use with this database.
0: 	*/
0: 	protected final ClassFactory getClassFactory() {
0: 		return getLanguageConnectionContext().getLanguageConnectionFactory().
0: 			getClassFactory();
0: 	}
0: 
0: 	/**
0: 	  *	Gets the LanguageConnectionContext for this connection.
0: 	  *
0: 	  *	@return	the lcc for this connection
0: 	  *
0: 	  */
0: 	protected final LanguageConnectionContext	getLanguageConnectionContext()
0: 	{
0: 		if (lcc == null)
0: 		{
0: 			lcc = (LanguageConnectionContext) getContextManager().
0: 							getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		}
0: 		return lcc;
0: 	}
0: 
0: 	/**
0: 	 * Get the name of the SPS that is used
0: 	 * to execute this statement.  Only relevant
0: 	 * for an ExecSPSNode -- otherwise, returns null.
0: 	 *
0: 	 * @return the name of the underlying sps
0: 	 */
0: 	public String getSPSName()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Gets the beginning offset of the SQL substring which this
0: 	 * query node represents.
0: 	 *
0: 	 * @return	The beginning offset of the SQL substring.
0: 	 *
0: 	 */
0:     public	int	getBeginOffset() { return beginOffset; }
0: 
0: 	/**
0: 	 * Sets the beginning offset of the SQL substring which this
0: 	 * query node represents.
0: 	 *
0: 	 * @param	The beginning offset of the SQL substring.
0: 	 *
0: 	 */
0:     public	void	setBeginOffset( int beginOffset )
0: 	{
0: 		this.beginOffset = beginOffset;
0: 	}
0: 
0: 	/**
0: 	 * Gets the ending offset of the SQL substring which this
0: 	 * query node represents.
0: 	 *
0: 	 * @return	The ending offset of the SQL substring.
0: 	 *
0: 	 */
0: 	public	int	getEndOffset()  { return endOffset; }
0: 
0: 	/**
0: 	 * Sets the ending offset of the SQL substring which this
0: 	 * query node represents.
0: 	 *
0: 	 * @param	The ending offset of the SQL substring.
0: 	 *
0: 	 */
0: 	public	void	setEndOffset( int endOffset )
0: 	{
0: 		this.endOffset = endOffset;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return header information for debug printing of this query
0: 	 * tree node.
0: 	 *
0: 	 * @return	Header information for debug printing of this query
0: 	 *		tree node.
0: 	 */
0: 
0: 	protected String	nodeHeader()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "\n" + this.getClass().getName() + '@' +
0: 					Integer.toHexString(hashCode()) + "\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Format a node that has been converted to a String for printing
0: 	 * as part of a tree.  This method indents the String to the given
0: 	 * depth by inserting tabs at the beginning of the string, and also
0: 	 * after every newline.
0: 	 *
0: 	 * @param nodeString	The node formatted as a String
0: 	 * @param depth		The depth to indent the given node
0: 	 *
0: 	 * @return	The node String reformatted with tab indentation
0: 	 */
0: 
0: 	public static String formatNodeString(String nodeString, int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			StringBuffer	nodeStringBuffer = new StringBuffer(nodeString);
0: 			int		pos;
0: 			char		c;
0: 			char[]		indent = new char[depth];
0: 
0: 			/*
0: 			** Form an array of tab characters for indentation.
0: 			*/
0: 			while (depth > 0)
0: 			{
0: 				indent[depth - 1] = '\t';
0: 				depth--;
0: 			}
0: 
0: 			/* Indent the beginning of the string */
0: 			nodeStringBuffer.insert(0, indent);
0: 
0: 			/*
0: 			** Look for newline characters, except for the last character.
0: 			** We don't want to indent after the last newline.
0: 			*/
0: 			for (pos = 0; pos < nodeStringBuffer.length() - 1; pos++)
0: 			{
0: 				c = nodeStringBuffer.charAt(pos);
0: 				if (c == '\n')
0: 				{
0: 					/* Indent again after each newline */
0: 					nodeStringBuffer.insert(pos + 1, indent);
0: 				}
0: 			}
0: 
0: 			return nodeStringBuffer.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print this tree for debugging purposes.  This recurses through
0: 	 * all the sub-nodes and prints them indented by their depth in
0: 	 * the tree.
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void treePrint()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			debugPrint(nodeHeader());
0: 			debugPrint(formatNodeString(this.toString(), 0));
0: 			printSubNodes(0);
0: 			debugFlush();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print this tree for debugging purposes.  This recurses through
0: 	 * all the sub-nodes and prints them indented by their depth in
0: 	 * the tree, starting with the given indentation.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree, thus,
0: 	 *			the amount to indent it when printing it.
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void treePrint(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			debugPrint(formatNodeString(nodeHeader(), depth));
0: 			debugPrint(formatNodeString(this.toString(), depth));
0: 			printSubNodes(depth);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print a String for debugging
0: 	 *
0: 	 * @param outputString	The String to print
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public static void debugPrint(String outputString)
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.GET_DEBUG_STREAM().print(outputString);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Flush the debug stream out
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 	protected static void debugFlush()
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.GET_DEBUG_STREAM().flush();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print the sub-nodes of this node.
0: 	 *
0: 	 * Each sub-class of QueryTreeNode is expected to provide its own
0: 	 * printSubNodes() method.  In each case, it calls super.printSubNodes(),
0: 	 * passing along its depth, to get the sub-nodes of the super-class.
0: 	 * Then it prints its own sub-nodes by calling treePrint() on each
0: 	 * of its members that is a type of QueryTreeNode.  In each case where
0: 	 * it calls treePrint(), it should pass "depth + 1" to indicate that
0: 	 * the sub-node should be indented one more level when printing.
0: 	 * Also, it should call printLabel() to print the name of each sub-node
0: 	 * before calling treePrint() on the sub-node, so that the reader of
0: 	 * the printed tree can tell what the sub-node is.
0: 	 *
0: 	 * This printSubNodes() exists in here merely to act as a backstop.
0: 	 * In other words, the calls to printSubNodes() move up the type
0: 	 * hierarchy, and in this node the calls stop.
0: 	 *
0: 	 * I would have liked to put the call to super.printSubNodes() in
0: 	 * this super-class, but Java resolves "super" statically, so it
0: 	 * wouldn't get to the right super-class.
0: 	 *
0: 	 * @param depth		The depth to indent the sub-nodes
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Format this node as a string
0: 	 *
0: 	 * Each sub-class of QueryTreeNode should implement its own toString()
0: 	 * method.  In each case, toString() should format the class members
0: 	 * that are not sub-types of QueryTreeNode (printSubNodes() takes care
0: 	 * of following the references to sub-nodes, and toString() takes care
0: 	 * of all members that are not sub-nodes).  Newlines should be used
0: 	 * liberally - one good way to do this is to have a newline at the
0: 	 * end of each formatted member.  It's also a good idea to put the
0: 	 * name of each member in front of the formatted value.  For example,
0: 	 * the code might look like:
0: 	 *
0: 	 * "memberName: " + memberName + "\n" + ...
0: 	 *
0: 	 * @return	This node formatted as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		return "";
0: 	}
0: 
0: 	/**
0: 	 * Print the given label at the given indentation depth.
0: 	 *
0: 	 * @param depth		The depth of indentation to use when printing
0: 	 *			the label
0: 	 * @param label		The String to print
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printLabel(int depth, String label)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			debugPrint(formatNodeString(label, depth));
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Perform the binding operation on a query tree.  Binding consists of
0: 	 * permissions checking, view resolution, datatype resolution, and
0: 	 * creation of a dependency list (for determining whether a tree or
0: 	 * plan is still up to date).
0: 	 *
0: 	 * This bind() method does nothing.  Each node type that can appear
0: 	 * at the top of a tree can override this method with its own bind()
0: 	 * method that does "something".
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Checks if the passed schema descriptor is for SESSION schema
0: 	 *
0: 	 * @return	true if the passed schema descriptor is for SESSION schema
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	final boolean isSessionSchema(SchemaDescriptor sd)
0: 	{
0: 		return isSessionSchema(sd.getSchemaName());
0: 	}
0: 
0: 	/**
0: 	 * Checks if the passed schema name is for SESSION schema
0: 	 *
0: 	 * @return	true if the passed schema name is for SESSION schema
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	final boolean isSessionSchema(String schemaName)
0: 	{
0: 		return SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME.equals(schemaName);
0: 	}
0: 
0: 	/**
0: 	 * Get the optimizer's estimate of the number of rows returned or affected
0: 	 * for an optimized QueryTree.
0: 	 *
0: 	 * For non-optimizable statements (for example, CREATE TABLE),
0: 	 * return 0. For optimizable statements, this method will be
0: 	 * over-ridden in the statement's root node (DMLStatementNode
0: 	 * in all cases we know about so far).
0: 	 *
0: 	 * @return	0L
0: 	 */
0: 
0: 	public long	getRowEstimate()
0: 	{
0: 		return	0L;
0: 	}
0: 
0: 	/**
0: 	 * Generates an optimized QueryTree from a bound QueryTree.  Actually,
0: 	 * it annotates the tree in place rather than generating a new tree,
0: 	 * but this interface allows the root node of the optmized QueryTree
0: 	 * to be different from the root node of the bound QueryTree.
0: 	 *
0: 	 * For non-optimizable statements (for example, CREATE TABLE),
0: 	 * return the bound tree without doing anything.  For optimizable
0: 	 * statements, this method will be over-ridden in the statement's
0: 	 * root node (DMLStatementNode in all cases we know about so far).
0: 	 *
0: 	 * Throws an exception if the tree is not bound, or if the binding
0: 	 * is out of date.
0: 	 *
0: 	 * @return	An optimized QueryTree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public QueryTreeNode optimize() throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * this implementation of generate() is
0: 	 * a place-holder until all of the nodes that need to,
0: 	 * implement it. Only the root, statement nodes
0: 	 * implement this flavor of generate; the other nodes
0: 	 * will implement the version that returns Generators
0: 	 * and takes an activation class builder as an
0: 	 * argument.
0: 	 *
0: 	 * @param	ignored - ignored (he he)
0: 	 *
0: 	 * @return	A GeneratedClass for this statement
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public GeneratedClass generate(ByteArray ignored) throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.LANG_UNABLE_TO_GENERATE,
0: 			this.nodeHeader());
0: 	}
0: 
0: 	/**
0: 	 * Do the code generation for this node.  This is a place-holder
0: 	 * method - it should be over-ridden in the sub-classes.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The method for the generated code to go into
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	protected void generate(
0: 								ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.LANG_UNABLE_TO_GENERATE,
0: 			this.nodeHeader());
0: 	}
0: 
0: 	/**
0: 	 * Only DML statements have result descriptions - for all others
0: 	 * return null.  This method is overridden in DMLStatementNode.
0: 	 *
0: 	 * @return	null
0: 	 *
0: 	 * @exception StandardException never actually thrown here,
0: 	 *	but thrown by subclasses
0: 	 */
0: 	public ResultDescription makeResultDescription() 
0: 		throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Parameter info is stored in the compiler context.
0: 	 * Hide this from the callers.
0: 	 *
0: 	 *
0: 	 * @return	null
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public DataTypeDescriptor[] getParameterTypes()
0: 		throws StandardException
0: 	{
0: 		return getCompilerContext().getParameterTypes();
0: 	}
0: 
0: 	/**
0: 	 * This creates a class that will do the work that's constant
0: 	 * across all Executions of a PreparedStatement. It's up to
0: 	 * our subclasses to override this method if they need to compile
0: 	 * constant actions into PreparedStatements.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		return	null;
0: 	}
0: 
0: 	/**
0: 	 * Returns whether or not this Statement requires a set/clear savepoint
0: 	 * around its execution.  The following statement "types" do not require them:
0: 	 *		Cursor	- unnecessary and won't work in a read only environment
0: 	 *		Xact	- savepoint will get blown away underneath us during commit/rollback
0: 	 * <p>
0: 	 * ONLY CALLABLE AFTER GENERATION
0: 	 *
0: 	 * @return boolean	Whether or not this Statement requires a set/clear savepoint
0: 	 */
0: 	public boolean needsSavepoint()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Returns the name of statement in EXECUTE STATEMENT command.
0: 	 * Returns null for all other commands.  
0: 	 * @return String null unless overridden for Execute Statement command
0: 	 */
0: 	public String executeStatementName()
0: 	{
0: 		return null;
0: 	}
0: 
0:   /**
0:    * Returns name of schema in EXECUTE STATEMENT command.
0:    * Returns null for all other commands.
0:    * @return String schema for EXECUTE STATEMENT null for all others
0:    */
0: 	public String executeSchemaName()
0: 	{
0: 		return null;
0: 	}
0: 
0:     /**
0: 	 * Set the node type for this node.
0: 	 *
0: 	 * @param nodeType The node type.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setNodeType(int nodeType)
0: 	{
0: 		this.nodeType = nodeType;
0: 	}
0: 
0: 	protected int getNodeType()
0: 	{
0: 		return nodeType;
0: 	}
0: 
0: 	/**
0: 	 * For final nodes, return whether or not
0: 	 * the node represents the specified nodeType.
0: 	 *
0: 	 * @param nodeType	The nodeType of interest.
0: 	 *
0: 	 * @return Whether or not
0: 	 * the node represents the specified nodeType.
0: 	 */
0: 	protected boolean isInstanceOf(int nodeType)
0: 	{
0: 		return (this.nodeType == nodeType);
0: 	}
0: 
0: 	/**
0: 	 * Get the DataDictionary
0: 	 *
0: 	 * @return The DataDictionary
0: 	 *
0: 	 */
0: 	public final DataDictionary getDataDictionary()
0: 	{
0: 		return getLanguageConnectionContext().getDataDictionary();
0: 	}
0: 
0: 	public final DependencyManager getDependencyManager()
0: 	{
0: 		return getDataDictionary().getDependencyManager();
0: 	}
0: 
0: 	/**
0: 	 * Get the CompilerContext
0: 	 *
0: 	 * @return The CompilerContext
0: 	 */
0: 	protected final CompilerContext getCompilerContext()
0: 	{
0: 		return (CompilerContext) getContextManager().
0: 										getContext(CompilerContext.CONTEXT_ID);
0: 	}
0: 
0: 	/**
0: 	 * Get the TypeCompiler associated with the given TypeId
0: 	 *
0: 	 * @param typeId	The TypeId to get a TypeCompiler for
0: 	 *
0: 	 * @return	The corresponding TypeCompiler
0: 	 *
0: 	 */
0: 	protected final TypeCompiler getTypeCompiler(TypeId typeId)
0: 	{
0: 		return
0: 		  getCompilerContext().getTypeCompilerFactory().getTypeCompiler(typeId);
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		return v.visit(this);
0: 	}
0: 
0: 	/**
0: 	 * Get the int value of a Property
0: 	 *
0: 	 * @param value		Property value as a String
0: 	 * @param key		Key value of property
0: 	 *
0: 	 * @return	The int value of the property
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	protected int getIntProperty(String value, String key)
0: 		throws StandardException
0: 	{
0: 		int intVal = -1;
0: 		try
0: 		{
0: 			intVal = Integer.parseInt(value);
0: 		}
0: 		catch (NumberFormatException nfe)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_NUMBER_FORMAT_FOR_OVERRIDE, 
0: 					value, key);
0: 		}
0: 		return intVal;
0: 	}
0: 
0: 	/**
0: 	 * Parse some query text and return a parse tree.
0: 	 *
0: 	 * @param compilerContext	The CompilerContext to use
0: 	 * @param createViewText	Query text to parse.
0: 	 * @param paramDefaults		array of parameter defaults used to
0: 	 *							initialize parameter nodes, and ultimately
0: 	 *							for the optimization of statements with
0: 	 *							parameters.
0: 	 * @param lcc				Current LanguageConnectionContext
0: 	 *
0: 	 * @return	ResultSetNode	The parse tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public static QueryTreeNode
0: 	parseQueryText
0: 	(
0: 		CompilerContext		compilerContext,
0: 		String				queryText,
0: 		Object[]			paramDefaults,
0: 		LanguageConnectionContext lcc
0:     )
0: 		 throws StandardException
0: 	{
0: 		LanguageConnectionFactory	lcf;
0: 		Parser						p;
0: 		QueryTreeNode			    qtn;
0: 
0: 		p = compilerContext.getParser();
0: 		
0: 		/* Get a Statement to pass to the parser */
0: 		lcf = lcc.getLanguageConnectionFactory();
0: 
0: 		/* Finally, we can call the parser */
0: 		qtn = (QueryTreeNode)p.parseStatement(queryText, paramDefaults);
0: 		return	qtn;
0: 	}
0: 
0: 	/**
0: 	 * Return the type of statement, something from
0: 	 * StatementType.
0: 	 *
0: 	 * @return the type of statement
0: 	 */
0: 	protected int getStatementType()
0: 	{
0: 		return StatementType.UNKNOWN;
0: 	}
0: 
0: 	public boolean foundString(String[] list, String search)
0: 	{
0: 		if (list == null)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		for (int i = 0; i < list.length; i++)
0: 		{
0: 			if (list[i].equals(search))
0: 			{	
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Get a ConstantNode to represent a typed null value
0: 	 *
0: 	 * @param typeId	The TypeId of the datatype of the null value
0: 	 * @param cm		The ContextManager
0: 	 *
0: 	 * @return	A ConstantNode with the specified type, and a value of null
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public  ConstantNode getNullNode(TypeId typeId,
0: 			ContextManager cm)
0: 		throws StandardException
0: 	{
0: 		QueryTreeNode constantNode = null;
0: 		NodeFactory nf = getNodeFactory();
0: 
0: 		switch (typeId.getJDBCTypeId())
0: 		{
0: 		  case Types.VARCHAR:
0: 			constantNode =  nf.getNode(
0: 										C_NodeTypes.VARCHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.CHAR:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.CHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.TINYINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.TINYINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.SMALLINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.SMALLINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.INTEGER:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.INT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.BIGINT:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGINT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.REAL:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.FLOAT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.DOUBLE:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.DOUBLE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.NUMERIC:
0: 		  case Types.DECIMAL:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.DECIMAL_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.DATE:
0: 		  case Types.TIME:
0: 		  case Types.TIMESTAMP:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.BINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.BIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.VARBINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.VARBIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.LONGVARCHAR:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGVARCHAR_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.CLOB:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.CLOB_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.LONGVARBINARY:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.LONGVARBIT_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  case Types.BLOB:
0: 			constantNode = nf.getNode(
0: 										C_NodeTypes.BLOB_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			break;
0: 
0: 		  default:
0: 			if (typeId.getSQLTypeName().equals("BOOLEAN"))
0: 			{
0: 				constantNode = nf.getNode(
0: 										C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			}
0: 			else if ( ! typeId.builtIn())
0: 			{
0: 				constantNode = nf.getNode(
0: 										C_NodeTypes.USERTYPE_CONSTANT_NODE,
0: 										typeId,
0: 										cm);
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT( "Unknown type " + 
0: 						typeId.getSQLTypeName() + " in getNullNode");
0: 				return null;
0: 			}
0: 		}
0: 
0: 		return (ConstantNode) constantNode;
0: 	}
0: 
0: 	/**
0: 	 * Translate a Default node into a default value, given a type descriptor.
0: 	 *
0: 	 * @param typeDescriptor	A description of the required data type.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor convertDefaultNode(DataTypeDescriptor typeDescriptor)
0: 							throws StandardException
0: 	{
0: 		/*
0: 		** Override in cases where node type
0: 		** can be converted to default value.
0: 		*/
0: 		return null;
0: 	}
0: 
0: 	/* Initializable methods */
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Single-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Two-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Three-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Four-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Five-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Six-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Seven-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Eight-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Nine-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Ten-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Eleven-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Twelve-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12,
0: 						Object arg13) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Thirteen-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Initialize a query tree node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object arg1,
0: 						Object arg2,
0: 						Object arg3,
0: 						Object arg4,
0: 						Object arg5,
0: 						Object arg6,
0: 						Object arg7,
0: 						Object arg8,
0: 						Object arg9,
0: 						Object arg10,
0: 						Object arg11,
0: 						Object arg12,
0: 						Object arg13,
0: 						Object arg14) throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("Fourteen-argument init() not implemented for " + getClass().getName());
0: 		}
0: 	}
0: 
0: 	public	TableName	makeTableName
0: 	(
0: 		String	schemaName,
0: 		String	flatName
0: 	)
0: 		throws StandardException
0: 	{
0: 		return (TableName) getNodeFactory().getNode
0: 			(
0: 				C_NodeTypes.TABLE_NAME,
0: 				schemaName,
0: 				flatName,
0: 				getContextManager()
0: 			);
0: 	}
0: 
0: 	public boolean isAtomic() throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("isAtomic should not be called for this  class: " + getClass().getName());
0: 		}
0: 		
0: 		return false;
0: 	}
0: 	
0: 	public Object getCursorInfo() throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get the descriptor for the named table within the given schema.
0: 	 * If the schema parameter is NULL, it looks for the table in the
0: 	 * current (default) schema. Table descriptors include object ids,
0: 	 * object types (table, view, etc.)
0: 	 * If the schema is SESSION, then before looking into the data dictionary
0: 	 * for persistent tables, it first looks into LCC for temporary tables.
0: 	 * If no temporary table tableName found for the SESSION schema, then it goes and
0: 	 * looks through the data dictionary for persistent table
0: 	 * We added getTableDescriptor here so that we can look for non data dictionary
0: 	 * tables(ie temp tables) here. Any calls to getTableDescriptor in data dictionary
0: 	 * should be only for persistent tables
0: 	 *
0: 	 * @param tableName	The name of the table to get the descriptor for
0: 	 * @param schema	The descriptor for the schema the table lives in.
0: 	 *			If null, use the current (default) schema.
0: 	 *
0: 	 * @return	The descriptor for the table, null if table does not
0: 	 *		exist.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	protected final TableDescriptor getTableDescriptor(String tableName,
0: 					SchemaDescriptor schema)
0: 						throws StandardException
0: 	{
0: 		TableDescriptor retval;
0: 
0: 		//Following if means we are dealing with SESSION schema.
0: 		if (isSessionSchema(schema))
0: 		{
0: 			//First we need to look in the list of temporary tables to see if this table is a temporary table.
0: 			retval = getLanguageConnectionContext().getTableDescriptorForDeclaredGlobalTempTable(tableName);
0: 			if (retval != null)
0: 				return retval; //this is a temporary table
0: 		}
0: 
0: 		//Following if means we are dealing with SESSION schema and we are dealing with in-memory schema (ie there is no physical SESSION schema)
0: 		//If following if is true, it means SESSION.table is not a declared table & it can't be physical SESSION.table
0: 		//because there is no physical SESSION schema
0: 		if (schema.getUUID() == null)
0: 			return null;
0: 
0: 		//it is not a temporary table, so go through the data dictionary to find the physical persistent table
0: 		return getDataDictionary().getTableDescriptor(tableName, schema);
0: 	}
0: 
0: 	/**
0: 	 * Get the descriptor for the named schema. If the schemaName
0: 	 * parameter is NULL, it gets the descriptor for the current (default)
0: 	 * schema. Schema descriptors include authorization ids and schema ids.
0: 	 * SQL92 allows a schema to specify a default character set - we will
0: 	 * not support this.  Will check default schema for a match
0: 	 * before scanning a system table.
0: 	 * 
0: 	 * @param schemaName	The name of the schema we're interested in.
0: 	 *			If the name is NULL, get the descriptor for the
0: 	 *			current schema.
0: 	 *
0: 	 * @return	The descriptor for the schema.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName)
0: 		throws StandardException
0: 	{
0: 		//return getSchemaDescriptor(schemaName, schemaName != null);
0: 		return getSchemaDescriptor(schemaName, true);
0: 	}
0: 	final SchemaDescriptor	getSchemaDescriptor(String schemaName, boolean raiseError)
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** Check for a compilation context.  Sometimes
0: 		** there is a special compilation context in
0: 	 	** place to recompile something that may have
0: 		** been compiled against a different schema than
0: 		** the current schema (e.g views):
0: 	 	**
0: 	 	** 	CREATE SCHEMA x
0: 	 	** 	CREATE TABLE t
0: 		** 	CREATE VIEW vt as SEELCT * FROM t
0: 		** 	SET SCHEMA app
0: 		** 	SELECT * FROM X.vt 
0: 		**
0: 		** In the above view vt must be compiled against
0: 		** the X schema.
0: 		*/
0: 
0: 
0: 		SchemaDescriptor sd = null;
0: 		boolean isCurrent = false;
0: 		boolean isCompilation = false;
0: 		if (schemaName == null) {
0: 
0: 			CompilerContext cc = getCompilerContext();
0: 			sd = cc.getCompilationSchema();
0: 
0: 			if (sd == null) {
0: 				// Set the compilation schema to be the default,
0: 				// notes that this query has schema dependencies.
0: 				sd = getLanguageConnectionContext().getDefaultSchema();
0: 
0: 				isCurrent = true;
0: 
0: 				cc.setCompilationSchema(sd);
0: 			}
0: 			else
0: 			{
0: 				isCompilation = true;
0: 			}
0: 			schemaName = sd.getSchemaName();
0: 		}
0: 
0: 		DataDictionary dataDictionary = getDataDictionary();
0: 		SchemaDescriptor sdCatalog = dataDictionary.getSchemaDescriptor(schemaName,
0: 			getLanguageConnectionContext().getTransactionCompile(), raiseError);
0: 
0: 		if (isCurrent || isCompilation) {
0: 			if (sdCatalog != null)
0: 			{
0: 				// different UUID for default (current) schema than in catalog,
0: 				// so reset default schema.
0: 				if (!sdCatalog.getUUID().equals(sd.getUUID()))
0: 				{
0: 					if (isCurrent)
0: 						getLanguageConnectionContext().setDefaultSchema(sdCatalog);
0: 					getCompilerContext().setCompilationSchema(sdCatalog);
0: 				}
0: 			}
0: 			else
0: 			{
0: 				// this schema does not exist, so ensure its UUID is null.
0: 				sd.setUUID(null);
0: 				sdCatalog = sd;
0: 			}
0: 		}
0: 		return sdCatalog;
0: 	}
0: 
0: 	/**
0: 	 * 
0: 	 * @param javaClassName	The name of the java class to resolve.
0: 	 *
0: 	 * @param convertCase	whether to convert the case before resolving class alias.
0: 	 *
0: 	 * @return	Resolved class name or class alias name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	String verifyClassExist(String javaClassName, boolean convertCase)
0: 		throws StandardException
0: 	{
0: 		/* Verify that the class exists */
0: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 
0: 		/* We first try to resolve the javaClassName as a class.  If that
0: 		 * fails then we try to resolve it as a class alias.
0: 		 */
0: 
0: 		Throwable reason = null;
0: 		boolean foundMatch = false;
0: 		try {
0: 
0: 			foundMatch = classInspector.accessible(javaClassName);
0: 
0: 		} catch (ClassNotFoundException cnfe) {
0: 
0: 			reason = cnfe;
0: 		} catch (LinkageError le) {
0: 			reason = le;
0: 		}
0: 
0: 		if (!foundMatch)
0: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST2, reason, javaClassName);
0: 
0: 		if (ClassInspector.primitiveType(javaClassName))
0: 			throw StandardException.newException(SQLState.LANG_TYPE_DOESNT_EXIST3, javaClassName);
0: 
0: 		return javaClassName;
0: 	}
0: 
0: 	/**
0: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
0: 								 int[]fkColArray, 
0: 								 String parentResultSetId,
0: 								 boolean dependentScan)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"setRefActionInfo() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 	}
0: 
0: 	/**
0: 		Add an authorization check into the passed in method.
0: 	*/
0: 	void generateAuthorizeCheck(ActivationClassBuilder acb,
0: 								MethodBuilder mb,
0: 								int sqlOperation) {
0: 		// add code to authorize statement execution.
0: 		acb.pushThisAsActivation(mb);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getLanguageConnectionContext",
0: 											 ClassName.LanguageConnectionContext, 0);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getAuthorizer",
0: 											 ClassName.Authorizer, 0);
0: 
0: 		mb.push(sqlOperation);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "authorize",
0: 											 "void", 1);
0: 	}
0: 	
0: 
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================