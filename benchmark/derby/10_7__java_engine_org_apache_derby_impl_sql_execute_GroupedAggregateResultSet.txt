8:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.GroupedAggregateResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
34:eac0369: 
1:0a6a846:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:b5105f3: import java.util.ArrayList;
1:b5105f3: import java.util.List;
1:b31849d: import java.util.Properties;
1:b5105f3: import java.util.HashSet;
1:89e145b: import java.util.Set;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:b31849d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:b5105f3: import org.apache.derby.iapi.sql.execute.ExecAggregator;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:b31849d: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:b31849d: import org.apache.derby.iapi.store.access.ScanController;
1:b31849d: import org.apache.derby.iapi.store.access.SortController;
1:b31849d: import org.apache.derby.iapi.store.access.SortObserver;
1:b31849d: import org.apache.derby.iapi.store.access.TransactionController;
1:b31849d: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b31849d: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This ResultSet evaluates grouped, non distinct aggregates.
1:eac0369:  * It will scan the entire source result set and calculate
1:eac0369:  * the grouped aggregates when scanning the source during the 
1:eac0369:  * first call to next().
1:eac0369:  *
1:b5105f3:  * The implementation is capable of computing multiple levels of grouping
1:b5105f3:  * in a single result set (this is requested using GROUP BY ROLLUP).
1:b5105f3:  *
1:b5105f3:  * This implementation has 3 variations, which it chooses according to
1:b5105f3:  * the following rules:
1:b5105f3:  * - If the data are guaranteed to arrive already in sorted order, we make
1:b5105f3:  *   a single pass over the data, computing the aggregates in-line as the
1:b5105f3:  *   data are read.
1:b5105f3:  * - If the statement requests either multiple ROLLUP levels, or a DISTINCT
1:b5105f3:  *   grouping, then the data are first sorted, then we make a single
1:b5105f3:  *   pass over the data as above.
1:b5105f3:  * - Otherwise, the data are sorted, and a SortObserver is used to compute
1:b5105f3:  *   the aggregations inside the sort, and the results are read back directly
1:b5105f3:  *   from the sorter.
1:b5105f3:  *
1:b5105f3:  * Note that, as of the introduction of the ROLLUP support, we no longer
1:b5105f3:  * ALWAYS compute the aggregates using a SortObserver, which is an
1:b5105f3:  * arrangement by which the sorter calls back into the aggregates during
1:b5105f3:  * the sort process each time it consolidates two rows with the same
1:b5105f3:  * sort key. Using aggregate sort observers is an efficient technique, but
1:b5105f3:  * it was complex to extend it to the ROLLUP case, so to simplify the code
1:b5105f3:  * we just have one path for both already-sorted and un-sorted data sources
1:b5105f3:  * in the ROLLUP case.
1:b5105f3:  *
12:eac0369:  */
1:f77f36d: class GroupedAggregateResultSet extends GenericAggregateResultSet
1:eac0369: 	implements CursorResultSet {
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public int rowsInput;
1:eac0369: 	public int rowsReturned;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:eac0369: 	private ColumnOrdering[] order;
1:eac0369: 	public	boolean	hasDistinctAggregate;	// true if distinct aggregate
1:eac0369: 	public	boolean isInSortedOrder;				// true if source results in sorted order
1:e3320c9: 	private	int numDistinctAggs = 0;
1:eac0369: 	private int maxRowSize;
1:eac0369: 
1:eac0369: 	// set in open and not modified thereafter
1:eac0369:     private ScanController scanController;
1:eac0369: 
1:eac0369: 	// Cache ExecIndexRow
1:eac0369: 	private ExecIndexRow sourceExecIndexRow;
1:eac0369: 
1:eac0369: 	private ExecIndexRow sortResultRow;
1:eac0369: 
1:b5105f3: 	// - resultRows: This is the current accumulating grouped result that
1:b5105f3: 	//   we are computing, at each level of aggregation. If we are not
1:b5105f3: 	//   doing a ROLLUP, then there is only one entry in resultRows, and
1:b5105f3: 	//   it contains the currently-accumulating aggregated result. If we
1:b5105f3: 	//   are doing a ROLLUP, then there are N+1 entries in resultRows,
1:b5105f3: 	//   as follows (imagine we're doing ROLLUP(a,b,c,d):
1:b5105f3: 	//   [0]: GROUP BY ()
1:b5105f3: 	//   [1]: GROUP BY (A)
1:b5105f3: 	//   [2]: GROUP BY (A,B)
1:b5105f3: 	//   [3]: GROUP BY (A,B,C)
1:b5105f3: 	//   [4]: GROUP BY (A,B,C,D)
1:b5105f3: 	// - finishedResults: this list is used only when a ROLLUP is computing
1:b5105f3: 	//   multiple levels of aggregation at once, and the results for
1:b5105f3: 	//   several groupings have been completed, but not yet returned to
1:b5105f3: 	//   our caller.
1:b5105f3: 	// - distinctValues: used only if DISTINCT aggregates are present,
1:b5105f3: 	//   this is a HashSet for each aggregate for each level of grouping,
1:b5105f3: 	//   and the HashSet instances contain the values this aggregate
1:b5105f3: 	//   has seen during this group instance, to eliminate duplicates.
1:b5105f3: 	//
1:b5105f3: 	private boolean resultsComplete;
1:71c8e86: 	private List<ExecRow> finishedResults;
1:b5105f3: 	private ExecIndexRow[]			resultRows;
1:031e59c:     private List<List<Set<DataValueDescriptor>>> distinctValues;
1:eac0369: 
1:b5105f3: 	private boolean rollup;
1:b5105f3: 	private boolean usingAggregateObserver = false;
1:b5105f3: 
1:eac0369: 	private long genericSortId;
1:eac0369: 	private TransactionController tc;
1:eac0369: 
1:eac0369: 	// RTS
1:eac0369: 	public Properties sortProperties = new Properties();
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param	s			input result set
1:eac0369: 	 * @param	isInSortedOrder	true if the source results are in sorted order
1:eac0369: 	 * @param	aggregateItem	indicates the number of the
1:eac0369: 	 *		SavedObject off of the PreparedStatement that holds the
1:eac0369: 	 *		AggregatorInfoList used by this routine.  
1:eac0369: 	 * @param	orderingItem	indicates the number of the
1:eac0369: 	 *		SavedObject off of the PreparedStatement that holds the
1:eac0369: 	 *		ColumOrdering array used by this routine
1:eac0369: 	 * @param	a				activation
1:d868eed: 	 * @param	ra				saved object that builds an empty output row
1:eac0369: 	 * @param	maxRowSize		approx row size, passed to sorter
1:eac0369: 	 * @param	resultSetNumber	The resultSetNumber for this result set
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:f77f36d:     GroupedAggregateResultSet(NoPutResultSet s,
1:eac0369: 					boolean isInSortedOrder,
1:eac0369: 					int	aggregateItem,
1:eac0369: 					int	orderingItem,
1:eac0369: 					Activation a,
1:d868eed: 					int ra,
1:eac0369: 					int maxRowSize,
1:eac0369: 					int resultSetNumber,
1:eac0369: 				    double optimizerEstimatedRowCount,
1:b5105f3: 					double optimizerEstimatedCost,
1:b5105f3: 					boolean isRollup) throws StandardException 
19:eac0369: 	{
1:f77f36d: 		super(s, aggregateItem, a, ra, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 		this.isInSortedOrder = isInSortedOrder;
1:b5105f3: 		rollup = isRollup;
1:71c8e86: 		finishedResults = new ArrayList<ExecRow>();
1:473d692:         order = ((FormatableArrayHolder)
1:473d692:                     (a.getPreparedStatement().getSavedObject(orderingItem)))
1:473d692:                         .getArray(ColumnOrdering[].class);
1:89e145b: 
1:eac0369: 		if (SanityManager.DEBUG)
1:0a6a846: 		{
1:eac0369: 			SanityManager.DEBUG("AggregateTrace","execution time: "+ 
1:eac0369: 					a.getPreparedStatement().getSavedObject(aggregateItem));
1:0a6a846: 		}
1:b5105f3: 		hasDistinctAggregate = aggInfoList.hasDistinct();
1:b5105f3: 		// If there is no ROLLUP, and no DISTINCT, and the data are
1:b5105f3: 		// not in sorted order, then we can use AggregateSortObserver
1:b5105f3: 		// to compute the aggregation in the sorter:
1:b5105f3: 		usingAggregateObserver =
1:b5105f3: 			!isInSortedOrder &&
1:b5105f3: 			!rollup &&
1:b5105f3: 			!hasDistinctAggregate;
1:eac0369: 
1:7008b63: 		recordConstructorTime();
19:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Open the scan.  Load the sorter and prepare to get
1:eac0369: 	 * rows from it.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:0a6a846:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:0a6a846: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		// REVISIT: through the direct DB API, this needs to be an
1:eac0369: 		// error, not an ASSERT; users can open twice. Only through JDBC
1:eac0369: 		// is access to open controlled and ensured valid.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "GroupedAggregateResultSet already open");
1:eac0369: 
1:d868eed:         sortResultRow = (ExecIndexRow) getRowTemplate().getClone();
1:d868eed:         sourceExecIndexRow = (ExecIndexRow) getRowTemplate().getClone();
1:eac0369: 
1:eac0369:         source.openCore();
1:eac0369: 
1:0a6a846: 		try {
1:b5105f3: 		/* If this is an in-order group by then we do not need the sorter.
1:b5105f3: 		 * (We can do the aggregation ourselves.)
1:b5105f3: 		 * We save a clone of the first row so that subsequent next()s
1:b5105f3: 		 * do not overwrite the saved row.
1:b5105f3: 		 */
1:b5105f3: 		if (!isInSortedOrder)
1:b5105f3: 			scanController = loadSorter();
1:b5105f3: 
1:b5105f3: 		ExecIndexRow currSortedRow = getNextRowFromRS();
1:b5105f3: 		resultsComplete = (currSortedRow == null);
1:b5105f3: 		if (usingAggregateObserver)
1:b5105f3: 		{
1:b5105f3: 			if (currSortedRow != null)
1:b5105f3: 				finishedResults.add(
1:b5105f3: 					finishAggregation(currSortedRow).getClone());
1:b5105f3: 		}
1:b5105f3: 		else if (!resultsComplete)
1:b5105f3: 		{
1:b5105f3: 			if (rollup)
1:e3320c9: 				resultRows = new ExecIndexRow[numGCols()+1];
1:0a6a846: 			else
1:b5105f3: 				resultRows = new ExecIndexRow[1];
1:b5105f3: 			if (aggInfoList.hasDistinct())
1:89e145b:             {
1:031e59c:                 distinctValues = new ArrayList<List<Set<DataValueDescriptor>>>(
1:031e59c:                         resultRows.length);
1:89e145b:             }
1:b5105f3: 			for (int r = 0; r < resultRows.length; r++)
1:b5105f3: 			{
1:b5105f3: 				resultRows[r] =
1:b5105f3: 					(ExecIndexRow) currSortedRow.getClone();
1:b5105f3: 				initializeVectorAggregation(resultRows[r]);
1:b5105f3: 				if (aggInfoList.hasDistinct())
1:89e145b:                 {
1:031e59c:                     distinctValues.add(new ArrayList<Set<DataValueDescriptor>>(
1:031e59c:                             aggregates.length));
1:89e145b:                     initializeDistinctMaps(r, true);
1:89e145b:                 }
1:b5105f3: 			}
1:0a6a846: 		}
1:0a6a846: 		} catch (StandardException e) {
1:0a6a846: 			// DERBY-4330 Result set tree must be atomically open or
1:0a6a846: 			// closed for reuse to work (after DERBY-827).
1:0a6a846: 
1:0a6a846: 			isOpen = true; // to make close do its thing:
1:0a6a846: 			try { close(); } catch (StandardException ee) {}
1:0a6a846: 			throw e;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Load up the sorter.  Feed it every row from the
1:b5105f3: 	 * source scan.  When done, close
1:eac0369: 	 * the source scan and open the sort.  Return the sort
1:eac0369: 	 * scan controller.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 *
1:eac0369: 	 * @return	the sort controller
1:eac0369:  	 */
1:eac0369: 	private ScanController loadSorter()
1:b5105f3: 		throws StandardException
1:b5105f3: 	{
1:eac0369: 		SortController 			sorter;
1:eac0369: 		ExecRow 				inputRow;
1:eac0369: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
1:d868eed:         ExecIndexRow            sortTemplateRow = getRowTemplate();
1:71c8e86: 
1:eac0369: 		tc = getTransactionController();
1:71c8e86: 
1:b5105f3: 		SortObserver observer;
1:b5105f3: 		if (usingAggregateObserver)
1:b5105f3: 			observer = new AggregateSortObserver(true, aggregates,
1:b5105f3: 				aggregates, sortTemplateRow);
1:b5105f3: 		else
1:b5105f3: 			observer = new BasicSortObserver(true, false,
1:b5105f3: 				sortTemplateRow, true);
1:eac0369: 
1:b5105f3: 		genericSortId = tc.createSort((Properties)null, 
1:b5105f3: 				sortTemplateRow.getRowArray(),
1:b5105f3: 				order,
1:b5105f3: 				observer,
1:b5105f3: 				false,
1:b5105f3: 				inputRowCountEstimate, // est rows
1:b5105f3: 				maxRowSize			// est rowsize 
1:b5105f3: 		);
1:b5105f3: 		sorter = tc.openSort(genericSortId);
1:eac0369: 	
1:eac0369: 		/* The sorter is responsible for doing the cloning */
1:eac0369: 		while ((inputRow = getNextRowFromRS()) != null) 
1:71c8e86: 		{
1:eac0369: 			sorter.insert(inputRow.getRowArray());
1:b5105f3: 		}
2:eac0369: 		source.close();
1:8417890: 		sorter.completedInserts();
1:b5105f3: 		sortProperties = sorter.getSortInfo().
1:b5105f3: 			getAllSortInfo(sortProperties);
1:b5105f3: 		if (aggInfoList.hasDistinct())
1:b5105f3: 		{
1:b5105f3: 			/*
1:b5105f3: 			** If there was a distinct aggregate, then that column
1:b5105f3: 			** was automatically included as the last column in
1:b5105f3: 			** the sort ordering. But we don't want it to be part
1:b5105f3: 			** of the ordering anymore, because we aren't grouping
1:b5105f3: 			** by that column, we just sorted it so that distinct
1:b5105f3: 			** aggregation would see the values in order.
1:b5105f3: 			*/
1:b5105f3: 			// Although it seems like N aggs could have been
1:b5105f3: 			// added at the end, in fact only one has been
1:b5105f3: 			// FIXME -- need to get GroupByNode to handle this
1:b5105f3: 			// correctly, but that requires understanding
1:b5105f3: 			// scalar distinct aggregates.
1:b5105f3: 			numDistinctAggs = 1;
1:b5105f3: 		}
1:b5105f3: 		return tc.openSortScan(genericSortId,
1:b5105f3: 			activation.getResultSetHoldability());
1:b5105f3: 	}
1:eac0369: 
1:e3320c9: 	/**
1:e3320c9: 	 * Return the number of grouping columns.
1:e3320c9: 	 *
1:e3320c9: 	 * Since some additional sort columns may have been included
1:e3320c9: 	 * in the sort for DISTINCT aggregates, this function is
1:e3320c9: 	 * used to ignore those columns when computing the grouped
1:e3320c9: 	 * results.
1:e3320c9: 	 */
1:e3320c9: 	private int numGCols() { return order.length - numDistinctAggs; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the next row.  
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException 
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		if (!isOpen)
1:eac0369: 		{
2:eac0369: 			return null;
1:71c8e86: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:b5105f3: 		if (finishedResults.size() > 0)
1:b5105f3: 			return makeCurrent(finishedResults.remove(0));
1:b5105f3: 		else if (resultsComplete)
1:b5105f3: 			return null;
1:b5105f3: 
1:b5105f3: 		ExecIndexRow nextRow = getNextRowFromRS();
1:b5105f3: 		// No rows, no work to do
1:b5105f3: 		if (nextRow == null)
1:b5105f3: 			return finalizeResults();
1:b5105f3: 
1:b5105f3: 		// If the aggregation was performed using the SortObserver, the
1:b5105f3: 		// result row from the sorter is complete and ready to return:
1:b5105f3: 		if (usingAggregateObserver)
1:b5105f3: 			return finishAggregation(nextRow);
1:b5105f3: 
1:b5105f3: 		/* Drain and merge rows until we find new distinct values for the grouping columns. */
1:b5105f3: 		while (nextRow != null)
1:eac0369: 		{
1:b5105f3: 			/* We found a new set of values for the grouping columns.  
1:b5105f3: 			 * Update the current row and return this group. 
1:b5105f3: 			 *
1:b5105f3: 			 * Note that in the case of GROUP BY ROLLUP,
1:b5105f3: 			 * there may be more than one level of grouped
1:b5105f3: 			 * aggregates which is now complete. We can
1:b5105f3: 			 * only return 1, and the other completed
1:b5105f3: 			 * groups are held in finishedResults until
1:b5105f3: 			 * our caller calls getNextRowCore() again to
1:b5105f3: 			 * get the next level of results.
1:b5105f3: 			 */
1:b5105f3: 			ExecIndexRow currSortedRow =
1:b5105f3: 				    resultRows[resultRows.length-1];
1:801cf0d:                         ExecRow origRow = nextRow.getClone();
1:b5105f3:                         initializeVectorAggregation(nextRow);
1:b5105f3: 			int distinguisherCol = 
1:b5105f3: 				    sameGroupingValues(currSortedRow, nextRow);
1:eac0369: 
1:b5105f3: 			for (int r = 0; r < resultRows.length; r++)
1:eac0369: 			{
1:b5105f3: 				boolean sameGroup = (rollup ?
1:b5105f3: 				    r <= distinguisherCol :
1:e3320c9: 				    distinguisherCol == numGCols());
1:b5105f3: 				if (sameGroup)
1:eac0369: 				{
1:b5105f3: 					/* Same group - initialize the new
1:b5105f3: 					   row and then merge the aggregates */
1:b5105f3: 					//initializeVectorAggregation(nextRow);
1:b5105f3: 					mergeVectorAggregates(nextRow, resultRows[r], r);
1:eac0369: 				}
1:b5105f3: 				else
1:eac0369: 				{
1:b5105f3: 					setRollupColumnsToNull(resultRows[r],r);
1:b5105f3: 					finishedResults.add(finishAggregation(resultRows[r]));
1:b5105f3: 					/* Save a clone of the new row so
1:b5105f3: 					   that it doesn't get overwritten */
1:b5105f3: 					resultRows[r] = (ExecIndexRow)
1:b5105f3: 						    origRow.getClone();
1:b5105f3: 					initializeVectorAggregation(resultRows[r]);
1:b5105f3: 					initializeDistinctMaps(r, false);
1:eac0369: 				}
1:eac0369: 			}
1:b5105f3: 			if (finishedResults.size() > 0)
1:eac0369: 			{
1:b5105f3: 				nextTime += getElapsedMillis(beginTime);
2:eac0369: 				rowsReturned++;
1:b5105f3:                                 return makeCurrent(finishedResults.remove(0));
1:eac0369: 			}
1:eac0369: 
1:b5105f3: 			// Get the next row
1:b5105f3: 			nextRow = getNextRowFromRS();
1:b5105f3: 		}
1:b5105f3: 
1:b5105f3: 		return finalizeResults();
1:eac0369: 	}
1:b5105f3: 	// Return the passed row, after ensuring that we call setCurrentRow
1:b5105f3: 	private ExecRow makeCurrent(Object row)
1:b5105f3: 		throws StandardException
1:b5105f3: 	{
1:b5105f3: 		ExecRow resultRow = (ExecRow)row;
1:b5105f3: 		setCurrentRow(resultRow);
1:b5105f3: 		return resultRow;
1:b5105f3: 	}
1:b5105f3: 	private ExecRow finalizeResults()
1:b5105f3: 		throws StandardException
1:b5105f3: 	{
1:b5105f3: 		// We've drained the source, so no more rows to return
1:b5105f3: 		resultsComplete = true;
1:b5105f3: 		if (! usingAggregateObserver )
1:b5105f3: 		{
1:b5105f3: 			for (int r = 0; r < resultRows.length; r++)
1:b5105f3: 			{
1:b5105f3: 				setRollupColumnsToNull(resultRows[r],r);
1:b5105f3: 				finishedResults.add(finishAggregation(resultRows[r]));
1:b5105f3: 			}
1:b5105f3: 		}
1:b5105f3: 		nextTime += getElapsedMillis(beginTime);
1:b5105f3: 		if (finishedResults.size() > 0)
1:b5105f3: 			return makeCurrent(finishedResults.remove(0));
1:b5105f3: 		else
1:b5105f3: 			return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the new row has the same values for the 
1:eac0369: 	 * grouping columns as the current row.  (This allows us to process in-order
1:eac0369: 	 * group bys without a sorter.)
1:eac0369: 	 *
1:eac0369: 	 * @param currRow	The current row.
1:eac0369: 	 * @param newRow	The new row.
1:eac0369: 	 *
1:b5105f3: 	 * @return	The order index number which first distinguished
1:b5105f3: 	 *			these rows, or order.length if the rows match.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:b5105f3: 	private int sameGroupingValues(ExecRow currRow, ExecRow newRow)
1:71c8e86: 		throws StandardException
1:eac0369: 	{
1:e3320c9: 		for (int index = 0; index < numGCols(); index++)
1:eac0369: 		{
1:eac0369: 			DataValueDescriptor currOrderable = currRow.getColumn(order[index].getColumnId() + 1);
1:eac0369: 			DataValueDescriptor newOrderable = newRow.getColumn(order[index].getColumnId() + 1);
1:eac0369: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1:eac0369: 			{
1:b5105f3: 				return index;
1:eac0369: 			}
1:eac0369: 		}
1:e3320c9: 		return numGCols();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:801cf0d:     @Override
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 		    clearCurrentRow();
1:eac0369: 
1:eac0369: 			sortResultRow = null;
1:eac0369: 			sourceExecIndexRow = null;
1:eac0369: 			closeSource();
1:eac0369: 
1:b5105f3: 			if (!isInSortedOrder)
1:eac0369: 			{
1:eac0369: 				tc.dropSort(genericSortId);
1:eac0369: 			}
1:eac0369: 			super.close();
1:eac0369: 		}
4:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 
1:eac0369: 		isOpen = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + 
1:eac0369: 						closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row location from
1:eac0369: 	 * the last fetch done. If the cursor is closed,
1:eac0369: 	 * a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure to get row location
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (! isOpen) return null;
1:eac0369: 
1:eac0369: 		// REVISIT: could we reuse the same rowlocation object
1:eac0369: 		// across several calls?
1:eac0369: 		RowLocation rl;
1:eac0369: 		rl = scanController.newRowLocationTemplate();
1:eac0369: 		scanController.fetchLocation(rl);
1:eac0369: 		return rl;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This result set has its row from the last fetch done. 
1:eac0369: 	 * If the cursor is closed, a null is returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned;
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
1:eac0369: 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// SCAN ABSTRACTION UTILITIES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Get the next output row for processing
1:eac0369: 	 */
1:eac0369: 	private ExecIndexRow getNextRowFromRS()
4:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return (scanController == null) ?
1:eac0369: 			getRowFromResultSet() :
1:eac0369: 			getRowFromSorter();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a row from the input result set.  
1:eac0369: 	 */	
1:eac0369: 	private ExecIndexRow getRowFromResultSet()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow					sourceRow;
1:eac0369: 		ExecIndexRow			inputRow = null;	
1:eac0369: 
1:eac0369: 		if ((sourceRow = source.getNextRowCore()) != null)
1:eac0369: 		{
2:eac0369: 			rowsInput++;
1:eac0369: 			sourceExecIndexRow.execRowToExecIndexRow(sourceRow);
1:eac0369: 			inputRow = sourceExecIndexRow;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return inputRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:b5105f3: 	// We are performing a ROLLUP aggregation and
1:b5105f3: 	// we need to set the N rolled-up columns in this
1:b5105f3: 	// row to NULL.
1:b5105f3: 	private void setRollupColumnsToNull(ExecRow row, int resultNum)
1:b5105f3: 		throws StandardException
1:b5105f3: 	{
1:b5105f3: 		int numRolledUpCols = resultRows.length - resultNum - 1;
1:b5105f3: 		for (int i = 0; i < numRolledUpCols; i++)
1:b5105f3: 		{
1:e3320c9: 			int rolledUpColIdx = numGCols() - 1 - i;
1:b5105f3: 			DataValueDescriptor rolledUpColumn =
1:b5105f3: 				row.getColumn(order[rolledUpColIdx].getColumnId() + 1);
1:b5105f3: 			rolledUpColumn.setToNull();
1:b5105f3: 		}
1:b5105f3: 	}
1:b5105f3: 
1:eac0369: 	/**
1:eac0369: 	 * Get a row from the sorter.  Side effects:
1:eac0369: 	 * sets currentRow.
1:eac0369: 	 */
1:eac0369: 	private ExecIndexRow getRowFromSorter()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecIndexRow			inputRow = null;	
1:eac0369: 		
1:eac0369: 		if (scanController.next())
1:eac0369: 		{
1:eac0369: 			// REMIND: HACKALERT we are assuming that result will
1:eac0369: 			// point to what sortResult is manipulating when
1:eac0369: 			// we complete the fetch.
1:eac0369: 			currentRow = sortResultRow;
1:eac0369: 
1:eac0369: 			inputRow = getExecutionFactory().getIndexableRow(currentRow);
1:eac0369: 
1:eac0369: 			scanController.fetch(inputRow.getRowArray());
1:b5105f3: 
1:eac0369: 		}
1:eac0369: 		return inputRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Close the source of whatever we have been scanning.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	closeSource() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (scanController == null)
1:eac0369: 		{
1:0a6a846: 			/*
1:eac0369: 			** NOTE: do not null out source, we
1:eac0369: 			** may be opened again, in which case
1:eac0369: 			** we will open source again.
1:eac0369: 			*/
1:eac0369: 			source.close();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			scanController.close();
1:eac0369: 			scanController = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// AGGREGATION UTILITIES
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Run the aggregator initialization method for
1:eac0369: 	 * each aggregator in the row.  Accumulate the
1:eac0369: 	 * input column.  WARNING: initializiation performs
1:eac0369: 	 * accumulation -- no need to accumulate a row
1:eac0369: 	 * that has been passed to initialization.
1:eac0369: 	 *
1:eac0369: 	 * @param	row	the row to initialize
1:eac0369: 	 *
1:94f158a: 	 * @exception	standard Derby exception
1:eac0369: 	 */
1:eac0369: 	private void initializeVectorAggregation(ExecRow row)
1:eac0369: 		throws StandardException
1:b5105f3: 	{
1:eac0369: 		int size = aggregates.length;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(row != null, 
1:eac0369: 					"Null row passed to initializeVectorAggregation");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = 0; i < size; i++)
1:eac0369: 		{
1:eac0369: 			GenericAggregator currAggregate = aggregates[i];
1:eac0369: 
1:eac0369: 			// initialize the aggregator
1:eac0369: 			currAggregate.initialize(row);
1:eac0369: 
1:eac0369: 			// get the first value, accumulate it into itself
1:eac0369: 			currAggregate.accumulate(row, row);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Run the aggregator merge method for
1:eac0369: 	 * each aggregator in the row.  
1:eac0369: 	 *
1:eac0369: 	 * @param	newRow	the row to merge
1:eac0369: 	 * @param	currRow the row to merge into
1:eac0369: 	 *
1:94f158a: 	 * @exception	standard Derby exception
1:eac0369: 	 */
1:b5105f3: 	private void mergeVectorAggregates(ExecRow newRow, ExecRow currRow,
1:b5105f3: 		int level)
1:b5105f3: 		throws StandardException
1:b5105f3: 	{
1:b5105f3: 		for (int i = 0; i < aggregates.length; i++)
1:b5105f3: 		{
1:eac0369: 			GenericAggregator currAggregate = aggregates[i];
1:801cf0d:             AggregatorInfo aInfo = aggInfoList.elementAt(i);
1:b5105f3: 			if (aInfo.isDistinct())
1:b5105f3: 			{
1:031e59c:                 if (SanityManager.DEBUG) {
1:031e59c:                     // Distinct aggregates currently always use the sorter.
1:031e59c:                     // Assert that it is so.
1:031e59c:                     SanityManager.ASSERT(!isInSortedOrder);
1:031e59c:                     SanityManager.ASSERT(scanController != null);
1:031e59c: 
1:031e59c:                     // If we ever start reading directly from the source
1:031e59c:                     // result set, we should call source.needsToClone() to
1:031e59c:                     // check if we need to clone the value before adding it
1:031e59c:                     // to the set of distinct values. Don't clone it for now.
1:031e59c:                 }
1:031e59c: 
1:b5105f3: 				DataValueDescriptor newValue = currAggregate.getInputColumnValue(newRow);
1:b5105f3: 				// A NULL value is always distinct, so we only
1:b5105f3: 				// have to check for duplicate values for
1:b5105f3: 				// non-NULL values.
1:031e59c:                 if (!newValue.isNull()
1:031e59c:                         && !distinctValues.get(level).get(i).add(newValue))
1:b5105f3: 				{
1:89e145b:                     // The value was already in the set, and we only look
1:89e145b:                     // for distinct values. Skip this value.
1:89e145b:                     continue;
1:b5105f3: 				}
1:b5105f3: 			}
1:eac0369: 
1:eac0369: 			// merge the aggregator
1:eac0369: 			currAggregate.merge(newRow, currRow);
1:b5105f3: 		}
1:b5105f3: 	}
1:b5105f3: 
1:b5105f3: 	private void initializeDistinctMaps(int r, boolean allocate)
1:b5105f3: 	    throws StandardException
1:b5105f3: 	{
1:b5105f3: 		for (int a = 0; a < aggregates.length; a++)
1:b5105f3: 		{
1:801cf0d:             AggregatorInfo aInfo = aggInfoList.elementAt(a);
1:eac0369: 
1:89e145b:             if (allocate) {
1:89e145b:                 // Allocate an empty set if the aggregate is distinct.
1:89e145b:                 // Otherwise, insert null so that the list is of the right
1:89e145b:                 // size and the indexes match those in aggregates[].
1:89e145b:                 distinctValues.get(r).add(aInfo.isDistinct() ?
1:031e59c:                         new HashSet<DataValueDescriptor>() : null);
1:89e145b:             }
1:89e145b: 
2:b5105f3: 			if (aInfo.isDistinct())
1:b5105f3: 			{
1:031e59c:                 Set<DataValueDescriptor> set = distinctValues.get(r).get(a);
1:89e145b:                 set.clear();
1:b5105f3: 				DataValueDescriptor newValue =
1:b5105f3: 					aggregates[a].getInputColumnValue(resultRows[r]);
1:031e59c:                 set.add(newValue);
1:b5105f3: 			}
1:b5105f3: 		}
1:b5105f3: 	}
1:eac0369: 
1:b5105f3: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:031e59c
/////////////////////////////////////////////////////////////////////////
1:     private List<List<Set<DataValueDescriptor>>> distinctValues;
/////////////////////////////////////////////////////////////////////////
1:                 distinctValues = new ArrayList<List<Set<DataValueDescriptor>>>(
1:                         resultRows.length);
/////////////////////////////////////////////////////////////////////////
1:                     distinctValues.add(new ArrayList<Set<DataValueDescriptor>>(
1:                             aggregates.length));
/////////////////////////////////////////////////////////////////////////
1:                 if (SanityManager.DEBUG) {
1:                     // Distinct aggregates currently always use the sorter.
1:                     // Assert that it is so.
1:                     SanityManager.ASSERT(!isInSortedOrder);
1:                     SanityManager.ASSERT(scanController != null);
1: 
1:                     // If we ever start reading directly from the source
1:                     // result set, we should call source.needsToClone() to
1:                     // check if we need to clone the value before adding it
1:                     // to the set of distinct values. Don't clone it for now.
1:                 }
1: 
1:                 if (!newValue.isNull()
1:                         && !distinctValues.get(level).get(i).add(newValue))
/////////////////////////////////////////////////////////////////////////
1:                         new HashSet<DataValueDescriptor>() : null);
1:                 Set<DataValueDescriptor> set = distinctValues.get(r).get(a);
1:                 set.add(newValue);
commit:473d692
/////////////////////////////////////////////////////////////////////////
1:         order = ((FormatableArrayHolder)
1:                     (a.getPreparedStatement().getSavedObject(orderingItem)))
1:                         .getArray(ColumnOrdering[].class);
commit:89e145b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0:     private List<List<Set<String>>> distinctValues;
/////////////////////////////////////////////////////////////////////////
1:             {
0:                 distinctValues =
0:                         new ArrayList<List<Set<String>>>(resultRows.length);
1:             }
1:                 {
0:                     distinctValues.add(
0:                             new ArrayList<Set<String>>(aggregates.length));
1:                     initializeDistinctMaps(r, true);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:                 String str = newValue.getString();
0:                 if (str != null && !distinctValues.get(level).get(i).add(str))
1:                     // The value was already in the set, and we only look
1:                     // for distinct values. Skip this value.
1:                     continue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (allocate) {
1:                 // Allocate an empty set if the aggregate is distinct.
1:                 // Otherwise, insert null so that the list is of the right
1:                 // size and the indexes match those in aggregates[].
1:                 distinctValues.get(r).add(aInfo.isDistinct() ?
0:                         new HashSet<String>() : null);
1:             }
1: 
0:                 Set<String> set = distinctValues.get(r).get(a);
1:                 set.clear();
0:                 set.add(newValue.getString());
commit:d868eed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param	ra				saved object that builds an empty output row
/////////////////////////////////////////////////////////////////////////
1: 					int ra,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         sortResultRow = (ExecIndexRow) getRowTemplate().getClone();
1:         sourceExecIndexRow = (ExecIndexRow) getRowTemplate().getClone();
/////////////////////////////////////////////////////////////////////////
1:         ExecIndexRow            sortTemplateRow = getRowTemplate();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
commit:e3320c9
/////////////////////////////////////////////////////////////////////////
1: 	private	int numDistinctAggs = 0;
/////////////////////////////////////////////////////////////////////////
1: 				resultRows = new ExecIndexRow[numGCols()+1];
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Return the number of grouping columns.
1: 	 *
1: 	 * Since some additional sort columns may have been included
1: 	 * in the sort for DISTINCT aggregates, this function is
1: 	 * used to ignore those columns when computing the grouped
1: 	 * results.
1: 	 */
1: 	private int numGCols() { return order.length - numDistinctAggs; }
/////////////////////////////////////////////////////////////////////////
1: 				    distinguisherCol == numGCols());
/////////////////////////////////////////////////////////////////////////
1: 		for (int index = 0; index < numGCols(); index++)
/////////////////////////////////////////////////////////////////////////
1: 		return numGCols();
/////////////////////////////////////////////////////////////////////////
1: 			int rolledUpColIdx = numGCols() - 1 - i;
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecAggregator;
/////////////////////////////////////////////////////////////////////////
1:  * The implementation is capable of computing multiple levels of grouping
1:  * in a single result set (this is requested using GROUP BY ROLLUP).
1:  *
1:  * This implementation has 3 variations, which it chooses according to
1:  * the following rules:
1:  * - If the data are guaranteed to arrive already in sorted order, we make
1:  *   a single pass over the data, computing the aggregates in-line as the
1:  *   data are read.
1:  * - If the statement requests either multiple ROLLUP levels, or a DISTINCT
1:  *   grouping, then the data are first sorted, then we make a single
1:  *   pass over the data as above.
1:  * - Otherwise, the data are sorted, and a SortObserver is used to compute
1:  *   the aggregations inside the sort, and the results are read back directly
1:  *   from the sorter.
1:  *
1:  * Note that, as of the introduction of the ROLLUP support, we no longer
1:  * ALWAYS compute the aggregates using a SortObserver, which is an
1:  * arrangement by which the sorter calls back into the aggregates during
1:  * the sort process each time it consolidates two rows with the same
1:  * sort key. Using aggregate sort observers is an efficient technique, but
1:  * it was complex to extend it to the ROLLUP case, so to simplify the code
1:  * we just have one path for both already-sorted and un-sorted data sources
1:  * in the ROLLUP case.
1:  *
/////////////////////////////////////////////////////////////////////////
1: 	// - resultRows: This is the current accumulating grouped result that
1: 	//   we are computing, at each level of aggregation. If we are not
1: 	//   doing a ROLLUP, then there is only one entry in resultRows, and
1: 	//   it contains the currently-accumulating aggregated result. If we
1: 	//   are doing a ROLLUP, then there are N+1 entries in resultRows,
1: 	//   as follows (imagine we're doing ROLLUP(a,b,c,d):
1: 	//   [0]: GROUP BY ()
1: 	//   [1]: GROUP BY (A)
1: 	//   [2]: GROUP BY (A,B)
1: 	//   [3]: GROUP BY (A,B,C)
1: 	//   [4]: GROUP BY (A,B,C,D)
1: 	// - finishedResults: this list is used only when a ROLLUP is computing
1: 	//   multiple levels of aggregation at once, and the results for
1: 	//   several groupings have been completed, but not yet returned to
1: 	//   our caller.
1: 	// - distinctValues: used only if DISTINCT aggregates are present,
1: 	//   this is a HashSet for each aggregate for each level of grouping,
1: 	//   and the HashSet instances contain the values this aggregate
1: 	//   has seen during this group instance, to eliminate duplicates.
1: 	//
1: 	private boolean resultsComplete;
0: 	private List finishedResults;
1: 	private ExecIndexRow[]			resultRows;
0: 	private HashSet [][]			distinctValues;
1: 	private boolean rollup;
1: 	private boolean usingAggregateObserver = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 					double optimizerEstimatedCost,
1: 					boolean isRollup) throws StandardException 
1: 		rollup = isRollup;
0: 		finishedResults = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1: 		hasDistinctAggregate = aggInfoList.hasDistinct();
1: 		// If there is no ROLLUP, and no DISTINCT, and the data are
1: 		// not in sorted order, then we can use AggregateSortObserver
1: 		// to compute the aggregation in the sorter:
1: 		usingAggregateObserver =
1: 			!isInSortedOrder &&
1: 			!rollup &&
1: 			!hasDistinctAggregate;
/////////////////////////////////////////////////////////////////////////
1: 		/* If this is an in-order group by then we do not need the sorter.
1: 		 * (We can do the aggregation ourselves.)
1: 		 * We save a clone of the first row so that subsequent next()s
1: 		 * do not overwrite the saved row.
1: 		 */
1: 		if (!isInSortedOrder)
1: 			scanController = loadSorter();
1: 
1: 		ExecIndexRow currSortedRow = getNextRowFromRS();
1: 		resultsComplete = (currSortedRow == null);
1: 		if (usingAggregateObserver)
1: 		{
1: 			if (currSortedRow != null)
1: 				finishedResults.add(
1: 					finishAggregation(currSortedRow).getClone());
1: 		}
1: 		else if (!resultsComplete)
1: 		{
1: 			if (rollup)
0: 				resultRows = new ExecIndexRow[order.length+1];
1: 				resultRows = new ExecIndexRow[1];
1: 			if (aggInfoList.hasDistinct())
0: 			    distinctValues = new HashSet[resultRows.length][aggregates.length];
1: 			for (int r = 0; r < resultRows.length; r++)
1: 				resultRows[r] =
1: 					(ExecIndexRow) currSortedRow.getClone();
1: 				initializeVectorAggregation(resultRows[r]);
1: 				if (aggInfoList.hasDistinct())
0: 					distinctValues[r] = new HashSet[aggregates.length];
0: 				initializeDistinctMaps(r, true);
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 	 * source scan.  When done, close
/////////////////////////////////////////////////////////////////////////
1: 		SortObserver observer;
1: 		if (usingAggregateObserver)
1: 			observer = new AggregateSortObserver(true, aggregates,
1: 				aggregates, sortTemplateRow);
1: 		else
1: 			observer = new BasicSortObserver(true, false,
1: 				sortTemplateRow, true);
1: 		genericSortId = tc.createSort((Properties)null, 
1: 				sortTemplateRow.getRowArray(),
1: 				order,
1: 				observer,
1: 				false,
1: 				inputRowCountEstimate, // est rows
1: 				maxRowSize			// est rowsize 
1: 		);
1: 		sorter = tc.openSort(genericSortId);
/////////////////////////////////////////////////////////////////////////
1: 		sortProperties = sorter.getSortInfo().
1: 			getAllSortInfo(sortProperties);
1: 		if (aggInfoList.hasDistinct())
1: 		{
1: 			/*
1: 			** If there was a distinct aggregate, then that column
1: 			** was automatically included as the last column in
1: 			** the sort ordering. But we don't want it to be part
1: 			** of the ordering anymore, because we aren't grouping
1: 			** by that column, we just sorted it so that distinct
1: 			** aggregation would see the values in order.
1: 			*/
0: 			int numDistinctAggs = 0;
1: 			for (int i = 0; i < aggregates.length; i++)
1: 			{
0: 				AggregatorInfo aInfo = (AggregatorInfo)
0: 					aggInfoList.elementAt(i);
1: 				if (aInfo.isDistinct())
0: 					numDistinctAggs++;
1: 			}
1: 			// Although it seems like N aggs could have been
1: 			// added at the end, in fact only one has been
1: 			// FIXME -- need to get GroupByNode to handle this
1: 			// correctly, but that requires understanding
1: 			// scalar distinct aggregates.
1: 			numDistinctAggs = 1;
0: 			if (order.length > numDistinctAggs)
1: 			{
0: 				ColumnOrdering[] newOrder = new ColumnOrdering[
0: 					order.length - numDistinctAggs];
0: 				System.arraycopy(order, 0, newOrder, 0,
0: 					order.length-numDistinctAggs);
0: 				order = newOrder;
1: 			}
1: 		}
1: 		return tc.openSortScan(genericSortId,
1: 			activation.getResultSetHoldability());
/////////////////////////////////////////////////////////////////////////
1: 		if (finishedResults.size() > 0)
1: 			return makeCurrent(finishedResults.remove(0));
1: 		else if (resultsComplete)
1: 			return null;
1: 
1: 		ExecIndexRow nextRow = getNextRowFromRS();
1: 		// No rows, no work to do
1: 		if (nextRow == null)
1: 			return finalizeResults();
1: 
1: 		// If the aggregation was performed using the SortObserver, the
1: 		// result row from the sorter is complete and ready to return:
1: 		if (usingAggregateObserver)
1: 			return finishAggregation(nextRow);
1: 
1: 		/* Drain and merge rows until we find new distinct values for the grouping columns. */
1: 		while (nextRow != null)
1: 			/* We found a new set of values for the grouping columns.  
1: 			 * Update the current row and return this group. 
1: 			 *
1: 			 * Note that in the case of GROUP BY ROLLUP,
1: 			 * there may be more than one level of grouped
1: 			 * aggregates which is now complete. We can
1: 			 * only return 1, and the other completed
1: 			 * groups are held in finishedResults until
1: 			 * our caller calls getNextRowCore() again to
1: 			 * get the next level of results.
1: 			 */
1: 			ExecIndexRow currSortedRow =
1: 				    resultRows[resultRows.length-1];
0:                         ExecRow origRow = (ExecRow)nextRow.getClone();;
1:                         initializeVectorAggregation(nextRow);
1: 			int distinguisherCol = 
1: 				    sameGroupingValues(currSortedRow, nextRow);
1: 			for (int r = 0; r < resultRows.length; r++)
1: 				boolean sameGroup = (rollup ?
1: 				    r <= distinguisherCol :
0: 				    distinguisherCol == order.length);
1: 				if (sameGroup)
1: 					/* Same group - initialize the new
1: 					   row and then merge the aggregates */
1: 					//initializeVectorAggregation(nextRow);
1: 					mergeVectorAggregates(nextRow, resultRows[r], r);
1: 					setRollupColumnsToNull(resultRows[r],r);
1: 					finishedResults.add(finishAggregation(resultRows[r]));
1: 					/* Save a clone of the new row so
1: 					   that it doesn't get overwritten */
1: 					resultRows[r] = (ExecIndexRow)
1: 						    origRow.getClone();
1: 					initializeVectorAggregation(resultRows[r]);
1: 					initializeDistinctMaps(r, false);
1: 			if (finishedResults.size() > 0)
1: 				nextTime += getElapsedMillis(beginTime);
1:                                 return makeCurrent(finishedResults.remove(0));
1: 			// Get the next row
1: 			nextRow = getNextRowFromRS();
1: 
1: 		return finalizeResults();
1: 	}
1: 	// Return the passed row, after ensuring that we call setCurrentRow
1: 	private ExecRow makeCurrent(Object row)
1: 		throws StandardException
1: 	{
1: 		ExecRow resultRow = (ExecRow)row;
1: 		setCurrentRow(resultRow);
1: 		return resultRow;
1: 	}
1: 	private ExecRow finalizeResults()
1: 		throws StandardException
1: 	{
1: 		// We've drained the source, so no more rows to return
1: 		resultsComplete = true;
1: 		if (! usingAggregateObserver )
1: 		{
1: 			for (int r = 0; r < resultRows.length; r++)
1: 			{
1: 				setRollupColumnsToNull(resultRows[r],r);
1: 				finishedResults.add(finishAggregation(resultRows[r]));
1: 			}
1: 		}
1: 		nextTime += getElapsedMillis(beginTime);
1: 		if (finishedResults.size() > 0)
1: 			return makeCurrent(finishedResults.remove(0));
1: 		else
1: 			return null;
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	The order index number which first distinguished
1: 	 *			these rows, or order.length if the rows match.
1: 	private int sameGroupingValues(ExecRow currRow, ExecRow newRow)
/////////////////////////////////////////////////////////////////////////
1: 				return index;
0: 		return order.length;
/////////////////////////////////////////////////////////////////////////
1: 			if (!isInSortedOrder)
/////////////////////////////////////////////////////////////////////////
1: 	// We are performing a ROLLUP aggregation and
1: 	// we need to set the N rolled-up columns in this
1: 	// row to NULL.
1: 	private void setRollupColumnsToNull(ExecRow row, int resultNum)
1: 		throws StandardException
1: 	{
1: 		int numRolledUpCols = resultRows.length - resultNum - 1;
1: 		for (int i = 0; i < numRolledUpCols; i++)
1: 		{
0: 			int rolledUpColIdx = order.length - 1 - i;
1: 			DataValueDescriptor rolledUpColumn =
1: 				row.getColumn(order[rolledUpColIdx].getColumnId() + 1);
1: 			rolledUpColumn.setToNull();
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 	private void mergeVectorAggregates(ExecRow newRow, ExecRow currRow,
1: 		int level)
0: 			AggregatorInfo aInfo = (AggregatorInfo)
0: 					aggInfoList.elementAt(i);
1: 			if (aInfo.isDistinct())
1: 			{
1: 				DataValueDescriptor newValue = currAggregate.getInputColumnValue(newRow);
1: 				// A NULL value is always distinct, so we only
1: 				// have to check for duplicate values for
1: 				// non-NULL values.
0: 				if (newValue.getString() != null)
1: 				{
0: 					if (distinctValues[level][i].contains(
0: 						    newValue.getString()))
0: 						continue;
0: 					distinctValues[level][i].add(
0: 						newValue.getString());
1: 				}
1: 			}
1: 	private void initializeDistinctMaps(int r, boolean allocate)
1: 	    throws StandardException
1: 	{
1: 		for (int a = 0; a < aggregates.length; a++)
1: 		{
0: 			AggregatorInfo aInfo = (AggregatorInfo)
0: 						aggInfoList.elementAt(a);
1: 			if (aInfo.isDistinct())
1: 			{
0: 				if (allocate)
0: 					distinctValues[r][a] = new HashSet();
1: 				else
0: 					distinctValues[r][a].clear();
1: 				DataValueDescriptor newValue =
1: 					aggregates[a].getInputColumnValue(resultRows[r]);
0: 				distinctValues[r][a].add(newValue.getString());
1: 			}
1: 		}
1: 	}
1: 
0:         private void dumpAllRows(int cR)
1:             throws StandardException
1:         {
0:             System.out.println("dumpAllRows("+cR+"/"+resultRows.length+"):");
0:             for (int r = 0; r < resultRows.length; r++)
0:                 System.out.println(dumpRow(resultRows[r]));
1:         }
0: 	private String dumpRow(ExecRow r)
1: 		throws StandardException
1: 	{
0:             if (r == null)
0:                 return "<NULL ROW>";
0: 	    StringBuffer buf = new StringBuffer();
0: 	    int nCols = r.nColumns();
0: 	    for (int d = 0; d < nCols; d++)
1: 	    {
0: 		if (d > 0) buf.append(",");
0:                 DataValueDescriptor o = r.getColumn(d+1);
0:                 buf.append(o.getString());
0:                 if (o instanceof ExecAggregator)
0:                     buf.append("[").
0:                         append(((ExecAggregator)o).getResult().getString()).
0:                         append("]");
1: 	    }
0: 	    return buf.toString();
1: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:                         ExecRow origRow = nextRow.getClone();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             AggregatorInfo aInfo = aggInfoList.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1:             AggregatorInfo aInfo = aggInfoList.elementAt(a);
/////////////////////////////////////////////////////////////////////////
0:         StringBuilder buf = new StringBuilder();
commit:0a6a846
/////////////////////////////////////////////////////////////////////////
1: 		try {
0: 			/* If this is an in-order group by then we do not need the sorter.
0: 			 * (We can do the aggregation ourselves.)
0: 			 * We save a clone of the first row so that subsequent next()s
0: 			 * do not overwrite the saved row.
1: 			 */
0: 			if (isInSortedOrder)
0: 				currSortedRow = getNextRowFromRS();
0: 				if (currSortedRow != null)
1: 				{
0: 					currSortedRow = (ExecIndexRow) currSortedRow.getClone();
0: 					initializeVectorAggregation(currSortedRow);
1: 				}
1: 			else
1: 			{
1: 				/*
0: 				** Load up the sorter
1: 				*/
0: 				scanController = loadSorter();
1: 			}
1: 		} catch (StandardException e) {
1: 			// DERBY-4330 Result set tree must be atomically open or
1: 			// closed for reuse to work (after DERBY-827).
1: 
1: 			isOpen = true; // to make close do its thing:
1: 			try { close(); } catch (StandardException ee) {}
1: 			throw e;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private List<ExecRow> finishedResults;
/////////////////////////////////////////////////////////////////////////
1: 		finishedResults = new ArrayList<ExecRow>();
/////////////////////////////////////////////////////////////////////////
0:                     addDistinctValue( level, i, newValue );
/////////////////////////////////////////////////////////////////////////
0:     /** Helper routine to do casting to shut up the compiler */
0:     @SuppressWarnings("unchecked")
0:     private void    addDistinctValue( int level, int aggregateNumber, DataValueDescriptor newValue )
1: 		throws StandardException
1:     {
0:         HashSet<String> set = (HashSet<String>) distinctValues[ level ][ aggregateNumber ];
1: 
0:         set.add( newValue.getString() );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 					distinctValues[r][a] = new HashSet<String>();
0:                 addDistinctValue( r, a, newValue );
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.SortController;
1: import org.apache.derby.iapi.store.access.SortObserver;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
commit:8417890
/////////////////////////////////////////////////////////////////////////
1: 			sorter.completedInserts();
/////////////////////////////////////////////////////////////////////////
0: 		sorter.completedInserts();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class GroupedAggregateResultSet extends GenericAggregateResultSet
/////////////////////////////////////////////////////////////////////////
1:     GroupedAggregateResultSet(NoPutResultSet s,
/////////////////////////////////////////////////////////////////////////
0: 				    double optimizerEstimatedCost) throws StandardException 
1: 		super(s, aggregateItem, a, ra, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.GroupedAggregateResultSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.SortController;
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: 
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Enumeration;
1: 
1: /**
1:  * This ResultSet evaluates grouped, non distinct aggregates.
1:  * It will scan the entire source result set and calculate
1:  * the grouped aggregates when scanning the source during the 
1:  * first call to next().
1:  *
0:  * @author jerry (broken out from SortResultSet)
1:  */
0: public class GroupedAggregateResultSet extends GenericAggregateResultSet
1: 	implements CursorResultSet {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	/* Run time statistics variables */
1: 	public int rowsInput;
1: 	public int rowsReturned;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
1: 	private ColumnOrdering[] order;
0: 	private ExecIndexRow sortTemplateRow;
1: 	public	boolean	hasDistinctAggregate;	// true if distinct aggregate
1: 	public	boolean isInSortedOrder;				// true if source results in sorted order
1: 	private int maxRowSize;
1: 
1: 	// set in open and not modified thereafter
1:     private ScanController scanController;
1: 
1: 	// Cache ExecIndexRow
1: 	private ExecIndexRow sourceExecIndexRow;
1: 
1: 	private ExecIndexRow sortResultRow;
1: 
0: 	// In order group bys
0: 	private ExecIndexRow currSortedRow;
0: 	private boolean nextCalled;
1: 
0: 	// used to track and close sorts
0: 	private long distinctAggSortId;
0: 	private boolean dropDistinctAggSort;
1: 	private long genericSortId;
0: 	private boolean dropGenericSort;
1: 	private TransactionController tc;
1: 
1: 	// RTS
1: 	public Properties sortProperties = new Properties();
1: 
1:     /**
1: 	 * Constructor
1: 	 *
1: 	 * @param	s			input result set
1: 	 * @param	isInSortedOrder	true if the source results are in sorted order
1: 	 * @param	aggregateItem	indicates the number of the
1: 	 *		SavedObject off of the PreparedStatement that holds the
1: 	 *		AggregatorInfoList used by this routine.  
1: 	 * @param	orderingItem	indicates the number of the
1: 	 *		SavedObject off of the PreparedStatement that holds the
1: 	 *		ColumOrdering array used by this routine
1: 	 * @param	a				activation
0: 	 * @param	ra				generated method to build an empty
0: 	 *	 	output row 
1: 	 * @param	maxRowSize		approx row size, passed to sorter
1: 	 * @param	resultSetNumber	The resultSetNumber for this result set
1: 	 *
1: 	 * @exception StandardException Thrown on error
1: 	 */
0:     public GroupedAggregateResultSet(NoPutResultSet s,
1: 					boolean isInSortedOrder,
1: 					int	aggregateItem,
1: 					int	orderingItem,
1: 					Activation a,
0: 					GeneratedMethod ra,
1: 					int maxRowSize,
1: 					int resultSetNumber,
1: 				    double optimizerEstimatedRowCount,
0: 				    double optimizerEstimatedCost,
0: 					GeneratedMethod c) throws StandardException 
1: 	{
0: 		super(s, aggregateItem, a, ra, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost, c);
1: 		this.isInSortedOrder = isInSortedOrder;
0: 		sortTemplateRow = getExecutionFactory().getIndexableRow((ExecRow) rowAllocator.invoke(activation));
0: 		order = (ColumnOrdering[])
0: 					((FormatableArrayHolder)
0: 						(a.getPreparedStatement().getSavedObject(orderingItem)))
0: 					.getArray(ColumnOrdering.class);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.DEBUG("AggregateTrace","execution time: "+ 
1: 					a.getPreparedStatement().getSavedObject(aggregateItem));
1: 		}
1: 
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Open the scan.  Load the sorter and prepare to get
1: 	 * rows from it.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		// REVISIT: through the direct DB API, this needs to be an
1: 		// error, not an ASSERT; users can open twice. Only through JDBC
1: 		// is access to open controlled and ensured valid.
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "GroupedAggregateResultSet already open");
1: 
0: 		sortResultRow = getExecutionFactory().getIndexableRow(sortTemplateRow.getClone());
0: 		sourceExecIndexRow = getExecutionFactory().getIndexableRow(sortTemplateRow.getClone());
1: 
1:         source.openCore();
1: 
0: 		/* If this is an in-order group by then we do not need the sorter.
0: 		 * (We can do the aggregation ourselves.)
0: 		 * We save a clone of the first row so that subsequent next()s
0: 		 * do not overwrite the saved row.
1: 		 */
0: 		if (isInSortedOrder)
1: 		{
0: 			currSortedRow = getNextRowFromRS();
0: 			if (currSortedRow != null)
1: 			{
0: 				currSortedRow = (ExecIndexRow) currSortedRow.getClone();
0: 				initializeVectorAggregation(currSortedRow);
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/*
0: 			** Load up the sorter
1: 			*/
0: 			scanController = loadSorter();
1: 		}
1: 
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Load up the sorter.  Feed it every row from the
0: 	 * source scan.  If we have a vector aggregate, initialize
0: 	 * the aggregator for each source row.  When done, close
1: 	 * the source scan and open the sort.  Return the sort
1: 	 * scan controller.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 *
1: 	 * @return	the sort controller
1:  	 */
1: 	private ScanController loadSorter()
1: 		throws StandardException
1: 	{
1: 		SortController 			sorter;
0: 		long 					sortId;
0: 		ExecRow 				sourceRow;
1: 		ExecRow 				inputRow;
1: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
0: 		boolean					inOrder = isInSortedOrder;
1: 
1: 		tc = getTransactionController();
1: 
0: 		ColumnOrdering[] currentOrdering = order;
1: 
1: 		/*
0: 		** Do we have any distinct aggregates?  If so, we'll need
0: 		** a separate sort.  We use all of the sorting columns and
0: 		** drop the aggregation on the distinct column.  Then
0: 		** we'll feed this into the sorter again w/o the distinct
0: 		** column in the ordering list.
1: 		*/
0: 		if (aggInfoList.hasDistinct())
1: 		{
0: 			hasDistinctAggregate = true;
1: 			
0: 			GenericAggregator[] aggsNoDistinct = getSortAggregators(aggInfoList, true,
0: 						activation.getLanguageConnectionContext(), source);
0: 			SortObserver sortObserver = new AggregateSortObserver(true, aggsNoDistinct, aggregates,
0: 																  sortTemplateRow);
1: 
0: 			sortId = tc.createSort((Properties)null, 
0: 					sortTemplateRow.getRowArray(),
0: 					order,
0: 					sortObserver,
0: 					false,			// not in order
0: 					inputRowCountEstimate,				// est rows, -1 means no idea	
0: 					maxRowSize		// est rowsize
0: 					);
0: 			sorter = tc.openSort(sortId);
0: 			distinctAggSortId = sortId;
0: 			dropDistinctAggSort = true;
1: 				
0: 			while ((sourceRow = source.getNextRowCore())!=null) 
1: 			{
0: 				sorter.insert(sourceRow.getRowArray());
1: 				rowsInput++;
1: 			}
1: 
1: 			/*
0: 			** End the sort and open up the result set
1: 			*/
1: 			source.close();
0: 			sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 			sorter.close();
1: 
0: 			scanController = 
0:                 tc.openSortScan(sortId, activation.getResultSetHoldability());
1: 			
1: 			/*
0: 			** Aggs are initialized and input rows
0: 			** are in order.  All we have to do is
0: 			** another sort to remove (merge) the 
0: 			** duplicates in the distinct column
1: 			*/	
0: 			inOrder = true;
0: 			inputRowCountEstimate = rowsInput;
1: 	
1: 			/*
0: 			** Drop the last column from the ordering.  The
0: 			** last column is the distinct column.  Don't
0: 			** pay any attention to the fact that the ordering
0: 			** object's name happens to correspond to a techo
0: 			** band from the 80's.
0: 			**
0: 			** If there aren't any ordering columns other
0: 			** than the distinct (i.e. for scalar distincts)
0: 			** just skip the 2nd sort altogether -- we'll
0: 			** do the aggregate merge ourselves rather than
0: 			** force a 2nd sort.
1: 			*/
0: 			if (order.length == 1)
1: 			{
0: 				return scanController;
1: 			}
1: 
0: 			ColumnOrdering[] newOrder = new ColumnOrdering[order.length - 1];
0: 			System.arraycopy(order, 0, newOrder, 0, order.length - 1);
0: 			currentOrdering = newOrder;
1: 		}
1: 
0: 		SortObserver sortObserver = new AggregateSortObserver(true, aggregates, aggregates,
0: 															  sortTemplateRow);
1: 
0: 		sortId = tc.createSort((Properties)null, 
0: 						sortTemplateRow.getRowArray(),
0: 						currentOrdering,
0: 						sortObserver,
0: 						inOrder,
0: 						inputRowCountEstimate, // est rows
0: 					 	maxRowSize			// est rowsize 
0: 						);
0: 		sorter = tc.openSort(sortId);
0: 		genericSortId = sortId;
0: 		dropGenericSort = true;
1: 	
1: 		/* The sorter is responsible for doing the cloning */
1: 		while ((inputRow = getNextRowFromRS()) != null) 
1: 		{
1: 			sorter.insert(inputRow.getRowArray());
1: 		}
1: 		source.close();
0: 		sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 		sorter.close();
1: 
0: 		return tc.openSortScan(sortId, activation.getResultSetHoldability());
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return the next row.  
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException 
1: 	{
1: 		if (!isOpen)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
0: 		// In order group by
0: 		if (isInSortedOrder)
1: 		{
0: 			// No rows, no work to do
0: 			if (currSortedRow == null)
1: 			{
0: 				nextTime += getElapsedMillis(beginTime);
1: 				return null;
1: 			}
1: 
0: 		    ExecIndexRow nextRow = getNextRowFromRS();
1: 
0: 			/* Drain and merge rows until we find new distinct values for the grouping columns. */
0: 			while (nextRow != null)
1: 			{
0: 				/* We found a new set of values for the grouping columns.  
0: 				 * Update the current row and return this group. 
1: 				 */
0: 				if (! sameGroupingValues(currSortedRow, nextRow))
1: 				{
0: 					ExecIndexRow result = currSortedRow;
1: 
0: 					/* Save a clone of the new row so that it doesn't get overwritten */
0: 					currSortedRow = (ExecIndexRow) nextRow.getClone();
0: 					initializeVectorAggregation(currSortedRow);
1: 
0: 					nextTime += getElapsedMillis(beginTime);
1: 					rowsReturned++;
0: 					return finishAggregation(result);
1: 				}
1: 				else
1: 				{
0: 					/* Same group - initialize the new row and then merge the aggregates */
0: 					initializeVectorAggregation(nextRow);
0: 					mergeVectorAggregates(nextRow, currSortedRow);
1: 				}
1: 
0: 				// Get the next row
0: 				nextRow = getNextRowFromRS();
1: 			}
1: 
0: 			// We've drained the source, so no more rows to return
0: 			ExecIndexRow result = currSortedRow;
0: 			currSortedRow = null;
0: 			nextTime += getElapsedMillis(beginTime);
0: 			return finishAggregation(result);
1: 		}
1: 		else
1: 		{
0: 		    ExecIndexRow sortResult = null;
1: 
0: 	        if ((sortResult = getNextRowFromRS()) != null)
1: 			{
0: 				setCurrentRow(sortResult);
1: 			}
1: 
1: 			/*
0: 			** Only finish the aggregation
0: 			** if we have a return row.  We don't generate
0: 			** a row on a vector aggregate unless there was
0: 			** a group.
1: 			*/
0: 			if (sortResult != null)
1: 			{
0: 				sortResult = finishAggregation(sortResult);
0: 				currentRow = sortResult;
1: 			}
1: 
0: 			if (sortResult != null)
1: 			{
1: 				rowsReturned++;
1: 			}
1: 
0: 			nextTime += getElapsedMillis(beginTime);
0: 		    return sortResult;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the new row has the same values for the 
1: 	 * grouping columns as the current row.  (This allows us to process in-order
1: 	 * group bys without a sorter.)
1: 	 *
1: 	 * @param currRow	The current row.
1: 	 * @param newRow	The new row.
1: 	 *
0: 	 * @return	Whether or not to filter out the new row has the same values for the 
0: 	 *			grouping columns as the current row.
1: 	 *
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
0: 	private boolean sameGroupingValues(ExecRow currRow, ExecRow newRow)
1: 		throws StandardException
1: 	{
0: 		for (int index = 0; index < order.length; index++)
1: 		{
1: 			DataValueDescriptor currOrderable = currRow.getColumn(order[index].getColumnId() + 1);
1: 			DataValueDescriptor newOrderable = newRow.getColumn(order[index].getColumnId() + 1);
1: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
1: 			{
0: 				return false;
1: 			}
1: 		}
0: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if ( isOpen )
1: 	    {
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
1: 
0: 			currentRow = null;
1: 			sortResultRow = null;
1: 			sourceExecIndexRow = null;
1: 			closeSource();
1: 
0: 			if (dropDistinctAggSort)
1: 			{
0: 				tc.dropSort(distinctAggSortId);
0: 				dropDistinctAggSort = false;
1: 			}
1: 
0: 			if (dropGenericSort)
1: 			{
1: 				tc.dropSort(genericSortId);
0: 				dropGenericSort = false;
1: 			}
1: 			super.close();
1: 		}
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 
1: 		isOpen = false;
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + 
1: 						closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * This result set has its row location from
1: 	 * the last fetch done. If the cursor is closed,
1: 	 * a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure to get row location
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException
1: 	{
1: 		if (! isOpen) return null;
1: 
1: 		// REVISIT: could we reuse the same rowlocation object
1: 		// across several calls?
1: 		RowLocation rl;
1: 		rl = scanController.newRowLocationTemplate();
1: 		scanController.fetchLocation(rl);
1: 		return rl;
1: 	}
1: 
1: 	/**
1: 	 * This result set has its row from the last fetch done. 
1: 	 * If the cursor is closed, a null is returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned;
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
1: 
1: 		return currentRow;
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// SCAN ABSTRACTION UTILITIES
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the next output row for processing
1: 	 */
1: 	private ExecIndexRow getNextRowFromRS()
1: 		throws StandardException
1: 	{
1: 		return (scanController == null) ?
1: 			getRowFromResultSet() :
1: 			getRowFromSorter();
1: 	}
1: 
1: 	/**
1: 	 * Get a row from the input result set.  
1: 	 */	
1: 	private ExecIndexRow getRowFromResultSet()
1: 		throws StandardException
1: 	{
1: 		ExecRow					sourceRow;
1: 		ExecIndexRow			inputRow = null;	
1: 
1: 		if ((sourceRow = source.getNextRowCore()) != null)
1: 		{
1: 			rowsInput++;
1: 			sourceExecIndexRow.execRowToExecIndexRow(sourceRow);
1: 			inputRow = sourceExecIndexRow;
1: 		}
1: 
1: 		return inputRow;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get a row from the sorter.  Side effects:
1: 	 * sets currentRow.
1: 	 */
1: 	private ExecIndexRow getRowFromSorter()
1: 		throws StandardException
1: 	{
1: 		ExecIndexRow			inputRow = null;	
1: 		
1: 		if (scanController.next())
1: 		{
1: 			// REMIND: HACKALERT we are assuming that result will
1: 			// point to what sortResult is manipulating when
1: 			// we complete the fetch.
1: 			currentRow = sortResultRow;
1: 
1: 			inputRow = getExecutionFactory().getIndexableRow(currentRow);
1: 
1: 			scanController.fetch(inputRow.getRowArray());
1: 		}
1: 		return inputRow;
1: 	}
1: 
1: 	/**
1: 	 * Close the source of whatever we have been scanning.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	closeSource() throws StandardException
1: 	{
1: 		if (scanController == null)
1: 		{
1: 			/*
1: 			** NOTE: do not null out source, we
1: 			** may be opened again, in which case
1: 			** we will open source again.
1: 			*/
1: 			source.close();
1: 		}
1: 		else
1: 		{
1: 			scanController.close();
1: 			scanController = null;
1: 		}
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// AGGREGATION UTILITIES
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Run the aggregator initialization method for
1: 	 * each aggregator in the row.  Accumulate the
1: 	 * input column.  WARNING: initializiation performs
1: 	 * accumulation -- no need to accumulate a row
1: 	 * that has been passed to initialization.
1: 	 *
1: 	 * @param	row	the row to initialize
1: 	 *
0: 	 * @exception	standard cloudscape exception
1: 	 */
1: 	private void initializeVectorAggregation(ExecRow row)
1: 		throws StandardException
1: 	{
1: 		int size = aggregates.length;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(row != null, 
1: 					"Null row passed to initializeVectorAggregation");
1: 		}
1: 
1: 		for (int i = 0; i < size; i++)
1: 		{
1: 			GenericAggregator currAggregate = aggregates[i];
1: 
1: 			// initialize the aggregator
1: 			currAggregate.initialize(row);
1: 
1: 			// get the first value, accumulate it into itself
1: 			currAggregate.accumulate(row, row);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Run the aggregator merge method for
1: 	 * each aggregator in the row.  
1: 	 *
1: 	 * @param	newRow	the row to merge
1: 	 * @param	currRow the row to merge into
1: 	 *
0: 	 * @exception	standard cloudscape exception
1: 	 */
0: 	private void mergeVectorAggregates(ExecRow newRow, ExecRow currRow)
1: 		throws StandardException
1: 	{
0: 		for (int i = 0; i < aggregates.length; i++)
1: 		{
1: 			GenericAggregator currAggregate = aggregates[i];
1: 
1: 			// merge the aggregator
1: 			currAggregate.merge(newRow, currRow);
1: 		}
1: 	}
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception	standard Derby exception
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception	standard Derby exception
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.SortController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Enumeration;
0: 
0: /**
0:  * This ResultSet evaluates grouped, non distinct aggregates.
0:  * It will scan the entire source result set and calculate
0:  * the grouped aggregates when scanning the source during the 
0:  * first call to next().
0:  *
0:  * @author jerry (broken out from SortResultSet)
0:  */
0: public class GroupedAggregateResultSet extends GenericAggregateResultSet
0: 	implements CursorResultSet {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	/* Run time statistics variables */
0: 	public int rowsInput;
0: 	public int rowsReturned;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0: 	private ColumnOrdering[] order;
0: 	private ExecIndexRow sortTemplateRow;
0: 	public	boolean	hasDistinctAggregate;	// true if distinct aggregate
0: 	public	boolean isInSortedOrder;				// true if source results in sorted order
0: 	private int maxRowSize;
0: 
0: 	// set in open and not modified thereafter
0:     private ScanController scanController;
0: 
0: 	// Cache ExecIndexRow
0: 	private ExecIndexRow sourceExecIndexRow;
0: 
0: 	private ExecIndexRow sortResultRow;
0: 
0: 	// In order group bys
0: 	private ExecIndexRow currSortedRow;
0: 	private boolean nextCalled;
0: 
0: 	// used to track and close sorts
0: 	private long distinctAggSortId;
0: 	private boolean dropDistinctAggSort;
0: 	private long genericSortId;
0: 	private boolean dropGenericSort;
0: 	private TransactionController tc;
0: 
0: 	// RTS
0: 	public Properties sortProperties = new Properties();
0: 
0:     /**
0: 	 * Constructor
0: 	 *
0: 	 * @param	s			input result set
0: 	 * @param	isInSortedOrder	true if the source results are in sorted order
0: 	 * @param	aggregateItem	indicates the number of the
0: 	 *		SavedObject off of the PreparedStatement that holds the
0: 	 *		AggregatorInfoList used by this routine.  
0: 	 * @param	orderingItem	indicates the number of the
0: 	 *		SavedObject off of the PreparedStatement that holds the
0: 	 *		ColumOrdering array used by this routine
0: 	 * @param	a				activation
0: 	 * @param	ra				generated method to build an empty
0: 	 *	 	output row 
0: 	 * @param	maxRowSize		approx row size, passed to sorter
0: 	 * @param	resultSetNumber	The resultSetNumber for this result set
0: 	 *
0: 	 * @exception StandardException Thrown on error
0: 	 */
0:     public GroupedAggregateResultSet(NoPutResultSet s,
0: 					boolean isInSortedOrder,
0: 					int	aggregateItem,
0: 					int	orderingItem,
0: 					Activation a,
0: 					GeneratedMethod ra,
0: 					int maxRowSize,
0: 					int resultSetNumber,
0: 				    double optimizerEstimatedRowCount,
0: 				    double optimizerEstimatedCost,
0: 					GeneratedMethod c) throws StandardException 
0: 	{
0: 		super(s, aggregateItem, a, ra, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost, c);
0: 		this.isInSortedOrder = isInSortedOrder;
0: 		sortTemplateRow = getExecutionFactory().getIndexableRow((ExecRow) rowAllocator.invoke(activation));
0: 		order = (ColumnOrdering[])
0: 					((FormatableArrayHolder)
0: 						(a.getPreparedStatement().getSavedObject(orderingItem)))
0: 					.getArray(ColumnOrdering.class);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.DEBUG("AggregateTrace","execution time: "+ 
0: 					a.getPreparedStatement().getSavedObject(aggregateItem));
0: 		}
0: 
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Open the scan.  Load the sorter and prepare to get
0: 	 * rows from it.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		// REVISIT: through the direct DB API, this needs to be an
0: 		// error, not an ASSERT; users can open twice. Only through JDBC
0: 		// is access to open controlled and ensured valid.
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "GroupedAggregateResultSet already open");
0: 
0: 		sortResultRow = getExecutionFactory().getIndexableRow(sortTemplateRow.getClone());
0: 		sourceExecIndexRow = getExecutionFactory().getIndexableRow(sortTemplateRow.getClone());
0: 
0:         source.openCore();
0: 
0: 		/* If this is an in-order group by then we do not need the sorter.
0: 		 * (We can do the aggregation ourselves.)
0: 		 * We save a clone of the first row so that subsequent next()s
0: 		 * do not overwrite the saved row.
0: 		 */
0: 		if (isInSortedOrder)
0: 		{
0: 			currSortedRow = getNextRowFromRS();
0: 			if (currSortedRow != null)
0: 			{
0: 				currSortedRow = (ExecIndexRow) currSortedRow.getClone();
0: 				initializeVectorAggregation(currSortedRow);
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Load up the sorter
0: 			*/
0: 			scanController = loadSorter();
0: 		}
0: 
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Load up the sorter.  Feed it every row from the
0: 	 * source scan.  If we have a vector aggregate, initialize
0: 	 * the aggregator for each source row.  When done, close
0: 	 * the source scan and open the sort.  Return the sort
0: 	 * scan controller.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 *
0: 	 * @return	the sort controller
0:  	 */
0: 	private ScanController loadSorter()
0: 		throws StandardException
0: 	{
0: 		SortController 			sorter;
0: 		long 					sortId;
0: 		ExecRow 				sourceRow;
0: 		ExecRow 				inputRow;
0: 		int						inputRowCountEstimate = (int) optimizerEstimatedRowCount;
0: 		boolean					inOrder = isInSortedOrder;
0: 
0: 		tc = getTransactionController();
0: 
0: 		ColumnOrdering[] currentOrdering = order;
0: 
0: 		/*
0: 		** Do we have any distinct aggregates?  If so, we'll need
0: 		** a separate sort.  We use all of the sorting columns and
0: 		** drop the aggregation on the distinct column.  Then
0: 		** we'll feed this into the sorter again w/o the distinct
0: 		** column in the ordering list.
0: 		*/
0: 		if (aggInfoList.hasDistinct())
0: 		{
0: 			hasDistinctAggregate = true;
0: 			
0: 			GenericAggregator[] aggsNoDistinct = getSortAggregators(aggInfoList, true,
0: 						activation.getLanguageConnectionContext(), source);
0: 			SortObserver sortObserver = new AggregateSortObserver(true, aggsNoDistinct, aggregates,
0: 																  sortTemplateRow);
0: 
0: 			sortId = tc.createSort((Properties)null, 
0: 					sortTemplateRow.getRowArray(),
0: 					order,
0: 					sortObserver,
0: 					false,			// not in order
0: 					inputRowCountEstimate,				// est rows, -1 means no idea	
0: 					maxRowSize		// est rowsize
0: 					);
0: 			sorter = tc.openSort(sortId);
0: 			distinctAggSortId = sortId;
0: 			dropDistinctAggSort = true;
0: 				
0: 			while ((sourceRow = source.getNextRowCore())!=null) 
0: 			{
0: 				sorter.insert(sourceRow.getRowArray());
0: 				rowsInput++;
0: 			}
0: 
0: 			/*
0: 			** End the sort and open up the result set
0: 			*/
0: 			source.close();
0: 			sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 			sorter.close();
0: 
0: 			scanController = 
0:                 tc.openSortScan(sortId, activation.getResultSetHoldability());
0: 			
0: 			/*
0: 			** Aggs are initialized and input rows
0: 			** are in order.  All we have to do is
0: 			** another sort to remove (merge) the 
0: 			** duplicates in the distinct column
0: 			*/	
0: 			inOrder = true;
0: 			inputRowCountEstimate = rowsInput;
0: 	
0: 			/*
0: 			** Drop the last column from the ordering.  The
0: 			** last column is the distinct column.  Don't
0: 			** pay any attention to the fact that the ordering
0: 			** object's name happens to correspond to a techo
0: 			** band from the 80's.
0: 			**
0: 			** If there aren't any ordering columns other
0: 			** than the distinct (i.e. for scalar distincts)
0: 			** just skip the 2nd sort altogether -- we'll
0: 			** do the aggregate merge ourselves rather than
0: 			** force a 2nd sort.
0: 			*/
0: 			if (order.length == 1)
0: 			{
0: 				return scanController;
0: 			}
0: 
0: 			ColumnOrdering[] newOrder = new ColumnOrdering[order.length - 1];
0: 			System.arraycopy(order, 0, newOrder, 0, order.length - 1);
0: 			currentOrdering = newOrder;
0: 		}
0: 
0: 		SortObserver sortObserver = new AggregateSortObserver(true, aggregates, aggregates,
0: 															  sortTemplateRow);
0: 
0: 		sortId = tc.createSort((Properties)null, 
0: 						sortTemplateRow.getRowArray(),
0: 						currentOrdering,
0: 						sortObserver,
0: 						inOrder,
0: 						inputRowCountEstimate, // est rows
0: 					 	maxRowSize			// est rowsize 
0: 						);
0: 		sorter = tc.openSort(sortId);
0: 		genericSortId = sortId;
0: 		dropGenericSort = true;
0: 	
0: 		/* The sorter is responsible for doing the cloning */
0: 		while ((inputRow = getNextRowFromRS()) != null) 
0: 		{
0: 			sorter.insert(inputRow.getRowArray());
0: 		}
0: 		source.close();
0: 		sortProperties = sorter.getSortInfo().getAllSortInfo(sortProperties);
0: 		sorter.close();
0: 
0: 		return tc.openSortScan(sortId, activation.getResultSetHoldability());
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return the next row.  
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException 
0: 	{
0: 		if (!isOpen)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		// In order group by
0: 		if (isInSortedOrder)
0: 		{
0: 			// No rows, no work to do
0: 			if (currSortedRow == null)
0: 			{
0: 				nextTime += getElapsedMillis(beginTime);
0: 				return null;
0: 			}
0: 
0: 		    ExecIndexRow nextRow = getNextRowFromRS();
0: 
0: 			/* Drain and merge rows until we find new distinct values for the grouping columns. */
0: 			while (nextRow != null)
0: 			{
0: 				/* We found a new set of values for the grouping columns.  
0: 				 * Update the current row and return this group. 
0: 				 */
0: 				if (! sameGroupingValues(currSortedRow, nextRow))
0: 				{
0: 					ExecIndexRow result = currSortedRow;
0: 
0: 					/* Save a clone of the new row so that it doesn't get overwritten */
0: 					currSortedRow = (ExecIndexRow) nextRow.getClone();
0: 					initializeVectorAggregation(currSortedRow);
0: 
0: 					nextTime += getElapsedMillis(beginTime);
0: 					rowsReturned++;
0: 					return finishAggregation(result);
0: 				}
0: 				else
0: 				{
0: 					/* Same group - initialize the new row and then merge the aggregates */
0: 					initializeVectorAggregation(nextRow);
0: 					mergeVectorAggregates(nextRow, currSortedRow);
0: 				}
0: 
0: 				// Get the next row
0: 				nextRow = getNextRowFromRS();
0: 			}
0: 
0: 			// We've drained the source, so no more rows to return
0: 			ExecIndexRow result = currSortedRow;
0: 			currSortedRow = null;
0: 			nextTime += getElapsedMillis(beginTime);
0: 			return finishAggregation(result);
0: 		}
0: 		else
0: 		{
0: 		    ExecIndexRow sortResult = null;
0: 
0: 	        if ((sortResult = getNextRowFromRS()) != null)
0: 			{
0: 				setCurrentRow(sortResult);
0: 			}
0: 
0: 			/*
0: 			** Only finish the aggregation
0: 			** if we have a return row.  We don't generate
0: 			** a row on a vector aggregate unless there was
0: 			** a group.
0: 			*/
0: 			if (sortResult != null)
0: 			{
0: 				sortResult = finishAggregation(sortResult);
0: 				currentRow = sortResult;
0: 			}
0: 
0: 			if (sortResult != null)
0: 			{
0: 				rowsReturned++;
0: 			}
0: 
0: 			nextTime += getElapsedMillis(beginTime);
0: 		    return sortResult;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the new row has the same values for the 
0: 	 * grouping columns as the current row.  (This allows us to process in-order
0: 	 * group bys without a sorter.)
0: 	 *
0: 	 * @param currRow	The current row.
0: 	 * @param newRow	The new row.
0: 	 *
0: 	 * @return	Whether or not to filter out the new row has the same values for the 
0: 	 *			grouping columns as the current row.
0: 	 *
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	private boolean sameGroupingValues(ExecRow currRow, ExecRow newRow)
0: 		throws StandardException
0: 	{
0: 		for (int index = 0; index < order.length; index++)
0: 		{
0: 			DataValueDescriptor currOrderable = currRow.getColumn(order[index].getColumnId() + 1);
0: 			DataValueDescriptor newOrderable = newRow.getColumn(order[index].getColumnId() + 1);
0: 			if (! (currOrderable.compare(DataValueDescriptor.ORDER_OP_EQUALS, newOrderable, true, true)))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if ( isOpen )
0: 	    {
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 		    clearCurrentRow();
0: 			if (closeCleanup != null) {
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 
0: 			currentRow = null;
0: 			sortResultRow = null;
0: 			sourceExecIndexRow = null;
0: 			closeSource();
0: 
0: 			if (dropDistinctAggSort)
0: 			{
0: 				tc.dropSort(distinctAggSortId);
0: 				dropDistinctAggSort = false;
0: 			}
0: 
0: 			if (dropGenericSort)
0: 			{
0: 				tc.dropSort(genericSortId);
0: 				dropGenericSort = false;
0: 			}
0: 			super.close();
0: 		}
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of SortResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 
0: 		isOpen = false;
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + 
0: 						closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - originalSource.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * This result set has its row location from
0: 	 * the last fetch done. If the cursor is closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure to get row location
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException
0: 	{
0: 		if (! isOpen) return null;
0: 
0: 		// REVISIT: could we reuse the same rowlocation object
0: 		// across several calls?
0: 		RowLocation rl;
0: 		rl = scanController.newRowLocationTemplate();
0: 		scanController.fetchLocation(rl);
0: 		return rl;
0: 	}
0: 
0: 	/**
0: 	 * This result set has its row from the last fetch done. 
0: 	 * If the cursor is closed, a null is returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned;
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isOpen, "SortResultSet expected to be open");
0: 
0: 		return currentRow;
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// SCAN ABSTRACTION UTILITIES
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Get the next output row for processing
0: 	 */
0: 	private ExecIndexRow getNextRowFromRS()
0: 		throws StandardException
0: 	{
0: 		return (scanController == null) ?
0: 			getRowFromResultSet() :
0: 			getRowFromSorter();
0: 	}
0: 
0: 	/**
0: 	 * Get a row from the input result set.  
0: 	 */	
0: 	private ExecIndexRow getRowFromResultSet()
0: 		throws StandardException
0: 	{
0: 		ExecRow					sourceRow;
0: 		ExecIndexRow			inputRow = null;	
0: 
0: 		if ((sourceRow = source.getNextRowCore()) != null)
0: 		{
0: 			rowsInput++;
0: 			sourceExecIndexRow.execRowToExecIndexRow(sourceRow);
0: 			inputRow = sourceExecIndexRow;
0: 		}
0: 
0: 		return inputRow;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get a row from the sorter.  Side effects:
0: 	 * sets currentRow.
0: 	 */
0: 	private ExecIndexRow getRowFromSorter()
0: 		throws StandardException
0: 	{
0: 		ExecIndexRow			inputRow = null;	
0: 		
0: 		if (scanController.next())
0: 		{
0: 			// REMIND: HACKALERT we are assuming that result will
0: 			// point to what sortResult is manipulating when
0: 			// we complete the fetch.
0: 			currentRow = sortResultRow;
0: 
0: 			inputRow = getExecutionFactory().getIndexableRow(currentRow);
0: 
0: 			scanController.fetch(inputRow.getRowArray());
0: 		}
0: 		return inputRow;
0: 	}
0: 
0: 	/**
0: 	 * Close the source of whatever we have been scanning.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	closeSource() throws StandardException
0: 	{
0: 		if (scanController == null)
0: 		{
0: 			/*
0: 			** NOTE: do not null out source, we
0: 			** may be opened again, in which case
0: 			** we will open source again.
0: 			*/
0: 			source.close();
0: 		}
0: 		else
0: 		{
0: 			scanController.close();
0: 			scanController = null;
0: 		}
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// AGGREGATION UTILITIES
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Run the aggregator initialization method for
0: 	 * each aggregator in the row.  Accumulate the
0: 	 * input column.  WARNING: initializiation performs
0: 	 * accumulation -- no need to accumulate a row
0: 	 * that has been passed to initialization.
0: 	 *
0: 	 * @param	row	the row to initialize
0: 	 *
0: 	 * @exception	standard cloudscape exception
0: 	 */
0: 	private void initializeVectorAggregation(ExecRow row)
0: 		throws StandardException
0: 	{
0: 		int size = aggregates.length;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(row != null, 
0: 					"Null row passed to initializeVectorAggregation");
0: 		}
0: 
0: 		for (int i = 0; i < size; i++)
0: 		{
0: 			GenericAggregator currAggregate = aggregates[i];
0: 
0: 			// initialize the aggregator
0: 			currAggregate.initialize(row);
0: 
0: 			// get the first value, accumulate it into itself
0: 			currAggregate.accumulate(row, row);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Run the aggregator merge method for
0: 	 * each aggregator in the row.  
0: 	 *
0: 	 * @param	newRow	the row to merge
0: 	 * @param	currRow the row to merge into
0: 	 *
0: 	 * @exception	standard cloudscape exception
0: 	 */
0: 	private void mergeVectorAggregates(ExecRow newRow, ExecRow currRow)
0: 		throws StandardException
0: 	{
0: 		for (int i = 0; i < aggregates.length; i++)
0: 		{
0: 			GenericAggregator currAggregate = aggregates[i];
0: 
0: 			// merge the aggregator
0: 			currAggregate.merge(newRow, currRow);
0: 		}
0: 	}
0: 
0: }
============================================================================