3:eac0369: /*
1:0eb98f1: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.ResultColumn
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
12:eac0369:  */
50:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:f33fbaf: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:ed82406: import org.apache.derby.iapi.reference.SQLState;
1:ed82406: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:ed82406: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:ed82406: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:ed82406: import org.apache.derby.iapi.sql.compile.Visitor;
1:ed82406: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:ed82406: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:ed82406: import org.apache.derby.iapi.store.access.Qualifier;
1:ed82406: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:ed82406: import org.apache.derby.iapi.types.DataValueDescriptor;
1:ed82406: import org.apache.derby.iapi.types.DataValueFactory;
1:ed82406: import org.apache.derby.iapi.types.StringDataValue;
1:ed82406: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:3bb140c: /**
1:eac0369:  * A ResultColumn represents a result column in a SELECT, INSERT, or UPDATE
1:eac0369:  * statement.  In a SELECT statement, the result column just represents an
1:eac0369:  * expression in a row being returned to the client.  For INSERT and UPDATE
1:eac0369:  * statements, the result column represents an column in a stored table.
1:eac0369:  * So, a ResultColumn has to be bound differently depending on the type of
1:eac0369:  * statement it appears in.
1:2e105f0:  * <P>
1:ba1b7ec:  * The type of the ResultColumn can differ from its underlying expression,
1:ba1b7ec:  * for example in certain joins the ResultColumn can be nullable even if
1:2e105f0:  * its underlying column is not. In an INSERT or UPDATE the ResultColumn
1:2e105f0:  * will represent the type of the column in the table, the type of
1:0eb98f1:  * the underlying expression will be the type of the source of the
1:2e105f0:  * value to be insert or updated. The method columnTypeAndLengthMatch()
1:2e105f0:  * can be used to detect when normalization is required between
1:0eb98f1:  * the expression and the type of ResultColumn. This class does
1:2e105f0:  * not implement any type normalization (conversion), this is
1:2e105f0:  * typically handled by a NormalizeResultSetNode.
1:0eb98f1:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class ResultColumn extends ValueNode
1:3bb140c:                 implements ResultColumnDescriptor, Comparable<ResultColumn>
32:eac0369: {
1:b0456a0: 	/* _underlyingName and _derivedColumnName should point to the same string, unless there is a
1:b0456a0: 	 * derived column list, in which case _underlyingName will point to the underlying name
1:b0456a0: 	 * and _derivedColumnName will point to the name from the derived column list.
1:eac0369: 	 */
1:b0456a0: 	private String			_underlyingName; // name from the actual data source
1:b0456a0: 	private String			_derivedColumnName;
1:b0456a0: 	private String			_unqualifiedTableName;
1:b0456a0: 	private String			_unqualifiedSourceTableName;
1:b57ee34: 	//Used by metadata api ResultSetMetaData.getSchemaName to get a column's table's schema.
1:b0456a0: 	private String			_sourceSchemaName;
1:b0456a0: 	private ValueNode		_expression;
1:b0456a0: 	private ColumnDescriptor	_columnDescriptor;
1:b0456a0: 	private boolean			_isGenerated;
1:b0456a0: 	private boolean			_isGeneratedForUnmatchedColumnInInsert;
1:b0456a0: 	private boolean			_isGroupingColumn;
1:b0456a0: 	private boolean			_isReferenced;
1:b0456a0: 	private boolean			_isRedundant;
1:b0456a0: 	private boolean			_isNameGenerated;
1:b0456a0: 	private boolean			_updated;
1:b0456a0: 	private boolean			_updatableByCursor;
1:eac0369: 	private boolean defaultColumn;
1:97a8b1c:     private boolean wasDefault;
1:0eb98f1:     //Following 2 fields have been added for DERBY-4631. 
1:0eb98f1:     //rightOuterJoinUsingClause will be set to true for following 2 cases
1:0eb98f1:     //1)if this column represents the join column which is part of the 
1:0eb98f1:     //  SELECT list of a RIGHT OUTER JOIN with USING/NATURAL. eg
1:0eb98f1:     //     select c from t1 right join t2 using (c)
1:0eb98f1:     //  This case is talking about column c as in "select c"
1:0eb98f1:     //2)if this column represents the join column from the right table 
1:0eb98f1:     //  for predicates generated for the USING/NATURAL of RIGHT OUTER JOIN
1:0eb98f1:     //  eg
1:0eb98f1:     //     select c from t1 right join t2 using (c)
1:0eb98f1:     //  For "using(c)", a join predicate will be created as follows
1:0eb98f1:     //    t1.c=t2.c
1:0eb98f1:     //  This case is talking about column t2.c of the join predicate.
1:0eb98f1:     private boolean rightOuterJoinUsingClause;
1:0eb98f1:     //Following will be non-null for the case 1) above. It will show the
1:0eb98f1:     // association of this result column to the join resultset created
1:0eb98f1:     // for the RIGHT OUTER JOIN with USING/NATURAL. This information along
1:0eb98f1:     // with rightOuterJoinUsingClause will be used during the code generation
1:0eb98f1:     // time.
1:0eb98f1:     private JoinNode joinResultSet = null;
1:eac0369: 
1:eac0369: 	// tells us if this ResultColumn is a placeholder for a generated
1:eac0369: 	// autoincrement value for an insert statement.
1:3c6be53: 	private boolean			_autoincrementGenerated;
1:eac0369: 
1:eac0369: 	// tells us if this ResultColumn represents an autoincrement column in a
1:eac0369: 	// base table.
1:3c6be53: 	private boolean 		_autoincrement;
1:eac0369: 
1:eac0369: 	/* ResultSetNumber for the ResultSet (at generate() time) that we belong to */
1:eac0369: 	private int		resultSetNumber = -1;
1:3c6be53: 	private ColumnReference _reference; // used to verify quals at bind time, if given.
1:eac0369: 
1:eac0369: 	/* virtualColumnId is the ResultColumn's position (1-based) within the ResultSet */
1:eac0369: 	private int		virtualColumnId;
1:eac0369: 
1:3bb140c:     ResultColumn(ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:     }
1:9f654e5: 
1:b9e22cc:     /**
1:feecfdd:      * @param underlyingName The name of the column, if any.
1:3bb140c:      * @param expression The expression this result column represents
1:3bb140c:      * @param cm context manager
1:3bb140c:      */
1:3bb140c:     ResultColumn(
1:b0456a0:             String underlyingName,
1:3bb140c:             ValueNode expression,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         setTypeExpressionAndDefault(expression);
1:b0456a0:         _underlyingName = underlyingName;
1:b0456a0:         _derivedColumnName = _underlyingName;
1:3bb140c:     }
1:69a192a: 
1:3bb140c:     /**
1:3bb140c:      * @param cr A column reference node
1:3bb140c:      * @param expression The expression this result column represents
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     ResultColumn(
1:3bb140c:             ColumnReference cr,
1:3bb140c:             ValueNode expression,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         setTypeExpressionAndDefault(expression);
1:b0456a0:         _underlyingName = cr.getColumnName();
1:b0456a0:         _derivedColumnName = cr.getColumnName();
1:3bb140c: 
1:3bb140c:         // When we bind, we'll want to make sure the reference has the right
1:3bb140c:         // table name.
1:3c6be53:         _reference = cr;
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     /**
1:3bb140c:      * @param cd The column descriptor
1:3bb140c:      * @param expression The expression this result column represents
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     ResultColumn(
1:3bb140c:             ColumnDescriptor cd,
1:3bb140c:             ValueNode expression,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         setTypeExpressionAndDefault(expression);
1:b0456a0:         _underlyingName = cd.getColumnName();
1:b0456a0:         _derivedColumnName = _underlyingName;
1:3bb140c:         setType(cd.getType());
1:b0456a0:         _columnDescriptor = cd;
1:3c6be53:         _autoincrement = cd.isAutoincrement();
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     /**
1:3bb140c:      * @param dtd The type of the column
1:3bb140c:      * @param expression The expression this result column represents
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     ResultColumn(
1:3bb140c:             DataTypeDescriptor dtd,
1:3bb140c:             ValueNode expression,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         setTypeExpressionAndDefault(expression);
1:3bb140c:         setType(dtd);
1:3bb140c: 
1:b0456a0:         if (_expression instanceof ColumnReference) {
1:3c6be53:             _reference = (ColumnReference)expression;
1:3bb140c:         }
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     private void setTypeExpressionAndDefault(ValueNode expression) {
1:3bb140c:         setExpression(expression);
1:3bb140c: 
1:3bb140c:         if (expression != null &&
1:2706d1f:                 expression instanceof DefaultNode) {
1:3bb140c:             // This result column represents a <default> keyword in an insert or
1:3bb140c:             // update statement
1:3bb140c:             defaultColumn = true;
1:3bb140c:         }
1:3bb140c:     }
1:3bb140c: 
1:3bb140c:     /**
1:0eb98f1: 	 * Returns TRUE if the ResultColumn is join column for a RIGHT OUTER 
1:0eb98f1: 	 *  JOIN with USING/NATURAL. More comments at the top of this class
1:0eb98f1: 	 *  where rightOuterJoinUsingClause is defined.
1:0eb98f1: 	 */
1:3bb140c:     boolean isRightOuterJoinUsingClause()
1:0eb98f1: 	{
1:0eb98f1: 		return rightOuterJoinUsingClause;
1:0eb98f1: 	}
1:01217c2: 
1:69a192a: 	/**
1:0eb98f1: 	 * Will be set to TRUE if this ResultColumn is join column for a 
1:0eb98f1: 	 *  RIGHT OUTER JOIN with USING/NATURAL. More comments at the top of 
1:0eb98f1: 	 *  this class where rightOuterJoinUsingClause is defined. 2 eg cases
1:0eb98f1: 	 * 1)select c from t1 right join t2 using (c)
1:0eb98f1: 	 *   This case is talking about column c as in "select c"
1:0eb98f1: 	 * 2)select c from t1 right join t2 using (c)
1:0eb98f1: 	 *   For "using(c)", a join predicate will be created as follows
1:0eb98f1: 	 *     t1.c=t2.c
1:0eb98f1: 	 *   This case is talking about column t2.c of the join predicate.
1:0eb98f1: 	 *   
1:0eb98f1: 	 * This method gets called for Case 1) during the bind phase of
1:0eb98f1: 	 *  ResultColumn(ResultColumn.bindExpression).
1:0eb98f1: 	 *   
1:0eb98f1: 	 * This method gets called for Case 2) during the bind phase of
1:0eb98f1: 	 *  JoinNode while we are going through the list of join columns
1:0eb98f1: 	 *  for a NATURAL JOIN or user supplied list of join columns for
1:0eb98f1: 	 *  USING clause(JoinNode.getMatchingColumn).
1:0eb98f1: 	 *  
2:0eb98f1: 	 * @param value True/False
1:0eb98f1: 	 */
1:3bb140c:     void setRightOuterJoinUsingClause(boolean value)
1:0eb98f1: 	{
1:0eb98f1: 		rightOuterJoinUsingClause = value;
1:0eb98f1: 	}
1:0eb98f1: 
1:0eb98f1: 	/**
1:0eb98f1: 	 * Returns a non-null value if the ResultColumn represents the join
1:0eb98f1: 	 * column which is part of the SELECT list of a RIGHT OUTER JOIN with
1:0eb98f1: 	 * USING/NATURAL. eg
1:0eb98f1: 	 *      select c from t1 right join t2 using (c)
1:0eb98f1: 	 * The join column we are talking about is column c as in "select c"
1:0eb98f1: 	 * The return value of following method will show the association of this 
1:0eb98f1: 	 * result column to the join resultset created for the RIGHT OUTER JOIN 
1:0eb98f1: 	 * with USING/NATURAL. This information along with 
1:0eb98f1: 	 * rightOuterJoinUsingClause will be used during the code generation 
1:0eb98f1: 	 * time.
1:0eb98f1: 	 */
1:3bb140c:     JoinNode getJoinResultSet() {
1:0eb98f1: 		return joinResultSet;
1:0eb98f1: 	}
1:0eb98f1: 
1:0eb98f1: 	/**
1:0eb98f1: 	 * This method gets called during the bind phase of a ResultColumn if it
1:0eb98f1: 	 *  is determined that the ResultColumn represents the join column which
1:0eb98f1: 	 *  is part of the SELECT list of a RIGHT OUTER JOIN with 
1:0eb98f1: 	 *  USING/NATURAL. eg
1:0eb98f1: 	 *      select c from t1 right join t2 using (c)
1:0eb98f1: 	 *   This case is talking about column c as in "select c"
1:0eb98f1: 	 * @param resultSet - The ResultColumn belongs to this JoinNode
1:0eb98f1: 	 */
1:3bb140c:     void setJoinResultset(JoinNode resultSet)
1:0eb98f1: 	{
1:0eb98f1: 		joinResultSet = resultSet;
1:0eb98f1: 	}
1:0eb98f1: 	
1:0eb98f1: 	/**
1:eac0369: 	 * Returns TRUE if the ResultColumn is standing in for a DEFAULT keyword in
1:eac0369: 	 * an insert/update statement.
1:2d2e717: 	 */
1:3bb140c:     boolean isDefaultColumn()
1:01217c2: 	{
1:eac0369: 		return defaultColumn;
1:01217c2: 	}
1:2d2e717: 
1:3bb140c:     void setDefaultColumn(boolean value)
1:01217c2: 	{
1:eac0369: 		defaultColumn = value;
1:2d2e717: 	}
1:c83a399: 
1:0eb98f1: 	/**
1:97a8b1c: 	 * Returns TRUE if the ResultColumn used to stand in for a DEFAULT keyword in
1:97a8b1c: 	 * an insert/update statement.
1:97a8b1c: 	 */
1:3bb140c:     boolean wasDefaultColumn()
1:97a8b1c: 	{
1:97a8b1c: 		return wasDefault;
1:97a8b1c: 	}
1:97a8b1c: 
1:3bb140c:     void setWasDefaultColumn(boolean value)
1:97a8b1c: 	{
1:97a8b1c: 		wasDefault = value;
1:97a8b1c: 	}
1:97a8b1c: 
1:97a8b1c: 	/**
1:497ffc7: 	 * Return TRUE if this result column matches the provided column name.
1:497ffc7: 	 *
1:497ffc7: 	 * This function is used by ORDER BY column resolution. For the
1:497ffc7: 	 * ORDER BY clause, Derby will prefer to match on the column's
1:b0456a0: 	 * alias (_derivedColumnName), but will also successfully match on the
1:497ffc7: 	 * underlying column name. Thus the following statements are
1:497ffc7: 	 * treated equally:
1:497ffc7: 	 *  select name from person order by name;
1:497ffc7: 	 *  select name as person_name from person order by name;
1:497ffc7: 	 *  select name as person_name from person order by person_name;
1:497ffc7: 	 * See DERBY-2351 for more discussion.
1:497ffc7: 	 */
1:497ffc7: 	boolean columnNameMatches(String columnName)
1:497ffc7: 	{
1:b0456a0: 		return columnName.equals(_derivedColumnName) ||
1:b0456a0: 			columnName.equals( _underlyingName ) ||
1:497ffc7: 			columnName.equals(getSourceColumnName());
1:497ffc7: 	}
1:0eb98f1: 	
1:497ffc7: 	/**
1:0eb98f1: 	 * Get non-null column name. This method is called during the bind phase
1:0eb98f1: 	 *  to see if we are dealing with ResultColumn in the SELECT list that 
1:0eb98f1: 	 *  belongs to a RIGHT OUTER JOIN(NATURAL OR USING)'s join column.
1:0eb98f1: 	 * 					
1:0eb98f1: 	 * For a query like following, we want to use column name x and not the
1:0eb98f1: 	 *  alias x1 when looking in the JoinNode for join column
1:0eb98f1: 	 *   SELECT x x1
1:0eb98f1: 	 *   	 FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;
1:0eb98f1: 	 * For a query like following, getSourceColumnName() will return null
1:0eb98f1: 	 *  because we are dealing with a function for the column. For this
1:0eb98f1: 	 *  case, "name" will return the alias name cx
1:0eb98f1: 	 *   SELECT coalesce(derby4631_t2.x, derby4631_t1.x) cx
1:0eb98f1: 	 *   	 FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;	
1:0eb98f1: 	 * For a query like following, getSourceColumnName() and name will 
1:0eb98f1: 	 *  return null and hence need to use the generated name
1:0eb98f1: 	 *   SELECT ''dummy="'|| TRIM(CHAR(x))|| '"'
1:0eb98f1: 	 *        FROM (derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1);
1:0eb98f1: 	 */
1:0eb98f1: 	String getUnderlyingOrAliasName() 
1:0eb98f1: 	{
1:0eb98f1: 		if (getSourceColumnName() != null)
1:b0456a0:         {
1:0eb98f1: 			return getSourceColumnName();
1:b0456a0:         }
1:b0456a0: 		else if ( _underlyingName != null )
1:b0456a0:         {
1:b0456a0: 			return _underlyingName;
1:b0456a0:         }
1:0eb98f1: 		else
1:b0456a0:         {
1:b0456a0: 			return _derivedColumnName;
1:b0456a0:         }
1:0eb98f1: 	}
1:0eb98f1: 	
1:0eb98f1:  	/**
1:b9e22cc: 	 * Returns true if this column is updatable.
1:b9e22cc: 	 *
1:b9e22cc: 	 * This method is used for determining if updateRow and insertRow
1:b9e22cc: 	 * are allowed for this cursor (DERBY-1773). Since the updateRow
1:b9e22cc: 	 * and insertRow implementations dynamically build SQL statements
1:b9e22cc: 	 * on the fly, the critical issue here is whether we have a
1:b9e22cc: 	 * column that has been aliased, because if it has been
1:b9e22cc: 	 * aliased, the dynamic SQL generation logic won't be able to
1:b9e22cc: 	 * compute the proper true base column name when it needs to.
1:b9e22cc: 	 *
1:b9e22cc: 	 * @return true if this result column is updatable.
1:b9e22cc: 	 */
1:b9e22cc: 	boolean isUpdatable()
1:b9e22cc: 	{
1:b9e22cc: 		return _derivedColumnName == null ||
1:b9e22cc: 			_underlyingName.equals(_derivedColumnName);
1:b9e22cc: 	}
1:b9e22cc: 
1:c723732: 	/**
1:497ffc7: 	 * Returns the underlying source column name, if this ResultColumn
1:497ffc7: 	 * is a simple direct reference to a table column, or NULL otherwise.
1:497ffc7: 	 */
1:497ffc7: 	String getSourceColumnName()
1:497ffc7: 	{
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:b0456a0: 			return ((ColumnReference)_expression).getColumnName();
1:497ffc7: 		return null;
1:497ffc7: 	}
1:497ffc7: 	/**
1:eac0369: 	 * The following methods implement the ResultColumnDescriptor
1:eac0369: 	 * interface.  See the Language Module Interface for details.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public String getName()
1:2d2e717: 	{
1:b0456a0: 		return _derivedColumnName;
27:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     String getSchemaName() throws StandardException
1:eac0369: 	{
1:b0456a0: 		if ((_columnDescriptor!=null) &&
1:b0456a0: 			(_columnDescriptor.getTableDescriptor() != null))
1:b0456a0: 			return _columnDescriptor.getTableDescriptor().getSchemaName();
1:b57ee34: 		else
1:eac0369: 		{
1:b0456a0: 			if (_expression != null)
1:eac0369: 			// REMIND: could look in reference, if set.
1:b0456a0: 				return _expression.getSchemaName();
3:eac0369: 			else
1:eac0369: 				return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:3bb140c:     String getTableName()
1:eac0369: 	{
1:b0456a0: 		if (_unqualifiedTableName != null)
1:eac0369: 		{
1:b0456a0: 			return _unqualifiedTableName;
1:eac0369: 		}
1:b0456a0: 		if ((_columnDescriptor!=null) &&
1:b0456a0: 			(_columnDescriptor.getTableDescriptor() != null))
1:eac0369: 		{
1:b0456a0: 			return _columnDescriptor.getTableDescriptor().getName();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:b0456a0: 			return _expression.getTableName();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:2e105f0: 	/**
1:eac0369: 	 * @see ResultColumnDescriptor#getSourceTableName
1:eac0369: 	 */
1:eac0369: 	public String getSourceTableName()
1:eac0369: 	{
1:b0456a0: 		return _unqualifiedSourceTableName;
1:eac0369: 	}
1:eac0369: 
1:2d2e717: 	/**
1:b57ee34: 	 * @see ResultColumnDescriptor#getSourceSchemaName
1:b57ee34: 	 */
1:b57ee34: 	public String getSourceSchemaName()
1:b57ee34: 	{
1:b0456a0: 		return _sourceSchemaName;
1:b57ee34: 	}
1:b57ee34: 
1:b57ee34: 	/**
1:eac0369: 	 * Clear the table name for the underlying ColumnReference.
1:444aa52: 	 * See UpdateNode.scrubResultColumns() for full explaination.
1:eac0369: 	 */
1:3bb140c:     void clearTableName()
1:eac0369: 	{
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:eac0369: 		{
1:b0456a0: 			((ColumnReference) _expression).setQualifiedTableName( (TableName) null );
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public DataTypeDescriptor getType()
1:eac0369: 	{
1:ed82406: 		return getTypeServices();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getColumnPosition()
1:eac0369: 	{
1:b0456a0: 		if (_columnDescriptor!=null)
1:b0456a0: 			return _columnDescriptor.getPosition();
1:eac0369: 		else
1:eac0369: 			return virtualColumnId;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
11:eac0369: 	/**
1:eac0369: 	 * Set the expression in this ResultColumn.  This is useful in those
1:eac0369: 	 * cases where you don't know the expression in advance, like for
1:eac0369: 	 * INSERT statements with column lists, where the column list and
1:eac0369: 	 * SELECT or VALUES clause are parsed separately, and then have to
1:eac0369: 	 * be hooked up.
1:c723732: 	 *
1:eac0369: 	 * @param expression	The expression to be set in this ResultColumn
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setExpression(ValueNode expression)
1:eac0369: 	{
1:b0456a0: 		_expression = expression;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the expression in this ResultColumn.  
1:ba1b7ec: 	 *
1:eac0369: 	 * @return ValueNode	this.expression
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     ValueNode getExpression()
1:eac0369: 	{
1:b0456a0: 		return _expression;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the expression to a null node of the
1:eac0369: 	 * correct type.
39:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void setExpressionToNullNode()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:c533cd2: 		setExpression( getNullNode(getTypeServices()) );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the name in this ResultColumn.  This is useful when you don't
1:eac0369: 	 * know the name at the time you create the ResultColumn, for example,
1:eac0369: 	 * in an insert-select statement, where you want the names of the
1:eac0369: 	 * result columns to match the table being inserted into, not the
1:eac0369: 	 * table they came from.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The name to set in this ResultColumn
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setName(String name)
1:eac0369: 	{
1:b0456a0: 		if ( _underlyingName == null )
1:eac0369: 		{
1:b0456a0: 			_underlyingName = name;
1:eac0369: 		}
1:eac0369: 		else {
3:eac0369: 			if (SanityManager.DEBUG)
1:3c6be53: 			SanityManager.ASSERT(_reference == null || 
1:3c6be53: 				name.equals(_reference.getColumnName()), 
1:eac0369: 				"don't change name from reference name");
1:eac0369: 		}
1:eac0369: 
1:b0456a0: 		_derivedColumnName = name;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the name for this ResultColumn generated?
1:eac0369: 	 */
1:3bb140c:     boolean isNameGenerated()
1:eac0369: 	{
1:b0456a0: 		return _isNameGenerated;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set that this result column name is generated.
1:eac0369: 	 */
1:3bb140c:     void setNameGenerated(boolean value)
1:eac0369: 	{
1:b0456a0: 		_isNameGenerated = value;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the resultSetNumber for this ResultColumn.  This is the 
1:eac0369: 	 * resultSetNumber for the ResultSet that we belong to.  This
1:eac0369: 	 * is useful for generate() and necessary since we do not have a
1:eac0369: 	 * back pointer to the RSN.
1:eac0369: 	 *
1:eac0369: 	 * @param resultSetNumber	The resultSetNumber.
1:eac0369: 	 */
1:3bb140c:     void setResultSetNumber(int resultSetNumber)
1:eac0369: 	{
1:eac0369: 		this.resultSetNumber = resultSetNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the resultSetNumber for this ResultColumn.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The resultSetNumber.
1:eac0369: 	 */
1:eac0369: 	public int getResultSetNumber()
1:eac0369: 	{
1:eac0369: 		return resultSetNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Adjust the virtualColumnId for this ResultColumn	by the specified amount
1:eac0369: 	 * 
1:eac0369: 	 * @param adjust	The adjustment for the virtualColumnId
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void adjustVirtualColumnId(int adjust)
1:eac0369: 	{
1:eac0369: 		virtualColumnId += adjust;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Set the virtualColumnId for this ResultColumn
1:eac0369: 	 * 
1:eac0369: 	 * @param id	The virtualColumnId for this ResultColumn
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void setVirtualColumnId(int id)
1:eac0369: 	{
1:eac0369: 		virtualColumnId = id;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the virtualColumnId for this ResultColumn
1:eac0369: 	 *
1:eac0369: 	 * @return virtualColumnId for this ResultColumn
1:eac0369: 	 */
1:3bb140c:     int getVirtualColumnId()
1:eac0369: 	{
1:eac0369: 		return virtualColumnId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2bb13ac: 	 * Adjust this virtualColumnId to account for the removal of a column
1:2bb13ac: 	 *
1:2bb13ac: 	 * This routine is called when bind processing finds and removes
1:2bb13ac: 	 * duplicate columns in the result list which were pulled up due to their
1:2bb13ac: 	 * presence in the ORDER BY clause, but were later found to be duplicate.
1:2bb13ac: 	 * 
1:2bb13ac: 	 * If this column is a virtual column, and if this column's virtual
1:2bb13ac: 	 * column id is greater than the column id which is being removed, then
1:2bb13ac: 	 * we must logically shift this column to the left by decrementing its
1:2bb13ac: 	 * virtual column id.
1:2bb13ac: 	 *
1:2bb13ac: 	 * @param removedColumnId   id of the column being removed.
1:2bb13ac: 	 */
1:3bb140c:     void collapseVirtualColumnIdGap(int removedColumnId)
1:2bb13ac: 	{
1:b0456a0: 		if (_columnDescriptor == null && virtualColumnId > removedColumnId)
1:2bb13ac: 			virtualColumnId--;
1:2bb13ac: 	}
1:2bb13ac: 
1:2bb13ac: 	/**
1:eac0369: 	 * Generate a unique (across the entire statement) column name for unnamed
1:eac0369: 	 * ResultColumns
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void guaranteeColumnName() throws StandardException
1:eac0369: 	{
1:b0456a0: 		if (_derivedColumnName == null)
1:eac0369: 		{
1:eac0369: 			/* Unions may also need generated names, if both sides name don't match */
1:b0456a0: 			_derivedColumnName ="SQLCol" + getCompilerContext().getNextColumnNumber();
1:b0456a0: 			_isNameGenerated = true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:b0456a0: 			return "derivedColumnName: " + _derivedColumnName + "\n" +
1:b0456a0: 				"underlyingName: " + _underlyingName + "\n" +
1:b0456a0: 				"tableName: " + _unqualifiedTableName + "\n" +
1:97a8b1c: 				"isDefaultColumn: " + defaultColumn + "\n" +
1:97a8b1c: 				"wasDefaultColumn: " + wasDefault + "\n" +
1:b0456a0: 				"isNameGenerated: " + _isNameGenerated + "\n" +
1:b0456a0: 				"sourceTableName: " + _unqualifiedSourceTableName + "\n" +
1:ed82406: 				"type: " + getTypeServices() + "\n" +
1:b0456a0: 				"columnDescriptor: " + _columnDescriptor + "\n" +
1:b0456a0: 				"isGenerated: " + _isGenerated + "\n" +
1:b0456a0: 				"isGeneratedForUnmatchedColumnInInsert: " + _isGeneratedForUnmatchedColumnInInsert + "\n" +
1:b0456a0: 				"isGroupingColumn: " + _isGroupingColumn + "\n" +
1:b0456a0: 				"isReferenced: " + _isReferenced + "\n" +
1:b0456a0: 				"isRedundant: " + _isRedundant + "\n" +
1:0eb98f1: 				"rightOuterJoinUsingClause: " + rightOuterJoinUsingClause + "\n" +
1:0eb98f1: 				"joinResultSet: " + joinResultSet + "\n" +
1:eac0369: 				"virtualColumnId: " + virtualColumnId + "\n" +
1:eac0369: 				"resultSetNumber: " + resultSetNumber + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:b0456a0: 			if (_expression != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "expression: ");
1:b0456a0: 				_expression.treePrint(depth + 1);
1:eac0369: 			}
1:3c6be53: 			if (_reference != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "reference: ");
1:3c6be53: 				_reference.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions.
1:eac0369: 	 * In this case, we figure out what the result type of this result
1:eac0369: 	 * column is when we call one of the bindResultColumn*() methods.
1:eac0369: 	 * The reason is that there are different ways of binding the
1:eac0369: 	 * result columns depending on the statement type, and this is
1:eac0369: 	 * a standard interface that does not take the statement type as
1:eac0369: 	 * a parameter.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:e1f49ca:     ResultColumn bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Set the type of a parameter to the type of the result column.
1:eac0369: 		** Don't do it if this result column doesn't have a type yet.
1:eac0369: 		** This can happen if the parameter is part of a table constructor.
1:eac0369: 		*/
1:b0456a0: 		if (_expression.requiresTypeFromContext())
1:eac0369: 		{
1:eac0369: 			if (getTypeServices() != null)
1:eac0369: 			{
1:b0456a0: 				_expression.setType(getTypeServices());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:0eb98f1: 		//DERBY-4631
1:0eb98f1: 		//Following code is for a join column(which obviously will not be 
1:0eb98f1: 		// qualified with a table name because join columns are not
1:0eb98f1: 		// associated with left or right table) of RIGHT OUTER JOIN  
1:0eb98f1: 		// with USING/NATURAL join. For such columns, 
1:0eb98f1: 		// isJoinColumnForRightOuterJoin() call will set 
1:0eb98f1: 		// rightOuterJoinUsingClause to true and associate the  
1:0eb98f1: 		// JoinResultSet with it. eg
1:0eb98f1: 		//      select c from t1 right join t2 using (c)
1:0eb98f1: 		// Here, we are talking about column c as in "select c"
1:b0456a0: 		if (_expression.getTableName() == null) {
1:0eb98f1: 			fromList.isJoinColumnForRightOuterJoin(this);
1:0eb98f1: 		}
1:0eb98f1: 
1:b0456a0: 		setExpression( _expression.bindExpression(fromList, subqueryList,
1:09c2697:                                                  aggregates) );
1:eac0369: 
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:eac0369: 		{
1:3c6be53: 			_autoincrement = ((ColumnReference)_expression).getSource().isAutoincrement();
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 
1:eac0369: 		
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this result column by ordinal position and set the VirtualColumnId.  
1:eac0369: 	 * This is useful for INSERT statements like "insert into t values (1, 2, 3)", 
1:eac0369: 	 * where the user did not specify a column list.
1:eac0369: 	 * If a columnDescriptor is not found for a given position, then
1:eac0369: 	 * the user has specified more values than the # of columns in
1:eac0369: 	 * the table and an exception is thrown.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
1:eac0369: 	 * construct the ResultColumnList in the usual way.
1:eac0369: 	 *
1:eac0369: 	 * @param tableDescriptor	The descriptor for the table being
1:eac0369: 	 *				inserted into
1:eac0369: 	 * @param columnId		The ordinal position of the column
1:eac0369: 	 *						in the table, starting at 1.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void bindResultColumnByPosition(TableDescriptor tableDescriptor,
1:eac0369: 					int columnId)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:3bb140c:         ColumnDescriptor    colDesc;
1:eac0369: 
1:3bb140c:         colDesc = tableDescriptor.getColumnDescriptor(columnId);
1:eac0369: 
1:3bb140c:         if (colDesc == null)
1:eac0369: 		{
1:eac0369: 			String		errorString;
1:eac0369: 			String		schemaName;
1:eac0369: 
1:eac0369: 			errorString = "";
1:eac0369: 			schemaName = tableDescriptor.getSchemaName();
1:eac0369: 			if (schemaName != null)
1:eac0369: 				errorString += schemaName + ".";
1:eac0369: 			errorString += tableDescriptor.getName();
1:eac0369: 
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_RESULT_COLUMNS, errorString);
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         setColumnDescriptor(tableDescriptor, colDesc);
1:eac0369: 		setVirtualColumnId(columnId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this result column by its name and set the VirtualColumnId.  
1:eac0369: 	 * This is useful for update statements, and for INSERT statements 
1:eac0369: 	 * like "insert into t (a, b, c) values (1, 2, 3)" where the user 
1:eac0369: 	 * specified a column list.
1:eac0369: 	 * An exception is thrown when a columnDescriptor cannot be found for a
1:eac0369: 	 * given name.  (There is no column with that name.)
1:eac0369: 	 *
1:eac0369: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
1:eac0369: 	 * construct the ResultColumnList in the usual way.
1:eac0369: 	 *
1:eac0369: 	 * @param tableDescriptor	The descriptor for the table being
1:eac0369: 	 *				updated or inserted into
1:eac0369: 	 * @param columnId		The ordinal position of the column
1:eac0369: 	 *						in the table, starting at 1. (Used to
1:eac0369: 	 *						set the VirtualColumnId.)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void bindResultColumnByName(TableDescriptor tableDescriptor,
1:eac0369: 					int columnId)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:3bb140c:         ColumnDescriptor    colDesc;
1:eac0369: 
1:b0456a0:         colDesc = tableDescriptor.getColumnDescriptor(_derivedColumnName);
1:eac0369: 
1:3bb140c:         if (colDesc == null)
1:eac0369: 		{
1:eac0369: 			String		errorString;
1:eac0369: 			String		schemaName;
1:eac0369: 
1:eac0369: 			errorString = "";
1:eac0369: 			schemaName = tableDescriptor.getSchemaName();
1:eac0369: 			if (schemaName != null)
1:eac0369: 				errorString += schemaName + ".";
1:eac0369: 			errorString += tableDescriptor.getName();
1:eac0369: 
1:b0456a0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, _derivedColumnName, errorString);
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         setColumnDescriptor(tableDescriptor, colDesc);
1:eac0369: 		setVirtualColumnId(columnId);
1:2d2e717: 		if (isPrivilegeCollectionRequired())
1:3bb140c:             getCompilerContext().addRequiredColumnPriv( colDesc);
1:eac0369: 	}
1:c533cd2: 
1:eac0369: 	/**
1:eac0369: 	 * Change an untyped null to a typed null.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void typeUntypedNullExpression( ResultColumn bindingRC)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369:         TypeId typeId = bindingRC.getTypeId();
1:eac0369: 		/* This is where we catch null in a VALUES clause outside
1:eac0369: 		 * of INSERT VALUES()
1:eac0369: 		 */
1:eac0369: 		if (typeId == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NULL_IN_VALUES_CLAUSE);
1:eac0369: 		}
1:eac0369: 
1:b0456a0:         if( _expression instanceof UntypedNullConstantNode)
1:68f9f47:         	//since we don't know the type of such a constant node, we just
1:68f9f47:         	//use the default values for collation type and derivation.
1:68f9f47:         	//eg insert into table1 values(1,null)
1:68f9f47:         	//When this method is executed for the sql above, we don't know
1:68f9f47:         	//the type of the null at this point.
1:c533cd2:             setExpression( getNullNode(bindingRC.getTypeServices()) );
1:b0456a0:         else if( ( _expression instanceof ColumnReference) && _expression.getTypeServices() == null)
1:eac0369:         {
1:eac0369:             // The expression must be a reference to a null column in a values table.
1:b0456a0:             _expression.setType( bindingRC.getType());
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the column descriptor for this result column.  It also gets
1:eac0369: 	 * the data type services from the column descriptor and stores it in
1:eac0369: 	 * this result column: this is redundant, but we have to store the result
1:eac0369: 	 * type here for SELECT statements, and it is more orthogonal if the type
1:eac0369: 	 * can be found here regardless of what type of statement it is.
1:eac0369: 	 *
1:eac0369: 	 * @param tableDescriptor	The TableDescriptor for the table
1:eac0369: 	 *				being updated or inserted into.
1:eac0369: 	 *				This parameter is used only for
1:eac0369: 	 *				error reporting.
1:eac0369: 	 * @param columnDescriptor	The ColumnDescriptor to set in
1:eac0369: 	 *				this ResultColumn.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException tableNameMismatch
1:eac0369: 	 */
1:eac0369: 	void setColumnDescriptor(TableDescriptor tableDescriptor,
1:eac0369: 				ColumnDescriptor columnDescriptor) throws StandardException
1:eac0369: 	{
1:b0456a0: 		if ( columnDescriptor != null ) { setType(columnDescriptor.getType()); }
1:b0456a0: 		_columnDescriptor = columnDescriptor;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			If the node was created using a reference, the table name
1:eac0369: 			of the reference must agree with that of the tabledescriptor.
1:eac0369: 		 */
1:2f8e6fb: 		if (
1:2f8e6fb:             _reference != null &&
1:2f8e6fb:             _reference.getTableName() != null &&
1:2f8e6fb:             (_reference.getMergeTableID() == ColumnReference.MERGE_UNKNOWN)
1:2f8e6fb:             ) 
1:eac0369: 		{
1:b0456a0: 			if ( (tableDescriptor != null) && ! tableDescriptor.getName().equals(
1:3c6be53: 					_reference.getTableName()) ) 
1:eac0369: 			{
1:eac0369: 				/* REMIND: need to have schema name comparison someday as well...
1:eac0369: 				** left out for now, lots of null checking needed...
1:eac0369: 				** || ! tableDescriptor.getSchemaName().equals(
1:b0456a0: 				**	reference.getQualifiedTableName().getSchemaName())) {
1:eac0369: 				*/
1:eac0369: 				String realName = tableDescriptor.getName();
1:3c6be53: 				String refName = _reference.getTableName();
1:eac0369: 
1:eac0369: 				throw StandardException.newException(SQLState.LANG_TABLE_NAME_MISMATCH, 
1:eac0369: 					realName, refName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the result column to the expression that lives under it.
1:eac0369: 	 * All this does is copy the datatype information to this node.
1:eac0369: 	 * This is useful for SELECT statements, where the result type
1:eac0369: 	 * of each column is the type of the column's expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void bindResultColumnToExpression()
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** This gets the same DataTypeServices object as
1:eac0369: 		** is used in the expression.  It is probably not
1:eac0369: 		** necessary to clone the object here.
1:eac0369: 		*/
1:b0456a0: 		setType(_expression.getTypeServices());
1:eac0369: 
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:eac0369: 		{
1:b0456a0: 			ColumnReference cr = (ColumnReference) _expression;
1:b0456a0: 			_unqualifiedTableName = cr.getTableName();
1:b0456a0: 			_unqualifiedSourceTableName = cr.getSourceTableName();
1:b0456a0: 			_sourceSchemaName = cr.getSourceSchemaName();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:69a192a: 	 * Set the column source's table name
1:69a192a: 	 * @param t The source table name
1:69a192a: 	 */
1:3bb140c:     void setSourceTableName(String t) {
1:b0456a0: 		_unqualifiedSourceTableName = t;
1:69a192a: 	}
1:69a192a: 
1:69a192a: 	/**
1:69a192a: 	 * Set the column source's schema name
1:69a192a: 	 * @param s The source schema name
1:69a192a: 	 */
1:3bb140c:     void setSourceSchemaName(String s) {
1:b0456a0: 		_sourceSchemaName = s;
1:69a192a: 	}
1:69a192a: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @return		The modified expression
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:e1f49ca:     ResultColumn preprocess(int numTables,
1:eac0369: 								FromList outerFromList,
1:eac0369: 								SubqueryList outerSubqueryList,
1:eac0369: 								PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:b0456a0: 		if (_expression == null)
1:eac0369: 			return this;
1:b0456a0: 		setExpression( _expression.preprocess(numTables, outerFromList,
1:eac0369: 										   outerSubqueryList,
1:c533cd2:                                            outerPredicateList) );
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This verifies that the expression is storable into the result column.
1:eac0369: 		It checks versus the given ResultColumn.
1:eac0369: 
1:eac0369: 		This method should not be called until the result column and
1:eac0369: 		expression both have a valid type, i.e. after they are bound
1:eac0369: 		appropriately. Its use is for statements like insert, that need to
1:eac0369: 		verify if a given value can be stored into a column.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if types not suitable.
1:eac0369: 	 */
1:3bb140c:     void checkStorableExpression(ResultColumn toStore)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:ed82406:         checkStorableExpression((ValueNode) toStore);
1:eac0369: 	}
1:ed82406:     
1:ed82406:     private void checkStorableExpression(ValueNode source)
1:ed82406:         throws StandardException
1:ed82406:     {
1:ed82406:         TypeId toStoreTypeId = source.getTypeId();
1:ed82406:         
1:ed82406:         if (!getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
1:ed82406:         {
1:ed82406:            throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
1:ed82406:                     getTypeId().getSQLTypeName(),
1:ed82406:                     toStoreTypeId.getSQLTypeName() );
1:ed82406:         }   
1:ed82406:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This verifies that the expression is storable into the result column.
1:eac0369: 		It checks versus the expression under this ResultColumn.
1:eac0369: 
1:eac0369: 		This method should not be called until the result column and
1:eac0369: 		expression both have a valid type, i.e. after they are bound
1:eac0369: 		appropriately. Its use is for statements like update, that need to
1:eac0369: 		verify if a given value can be stored into a column.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if types not suitable.
1:eac0369: 	 */
1:3bb140c:     void checkStorableExpression()
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:ed82406:         checkStorableExpression(getExpression());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for a result column.  This consists of doing the code
1:eac0369: 	 * generation for the underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @param ecb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:2b467cf:     void generateExpression(ExpressionClassBuilder ecb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:b0456a0:         _expression.generateExpression(ecb, mb);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation to return a Null of the appropriate type
1:eac0369: 	 * for the result column.  
1:eac0369: 	   Requires the getCOlumnExpress value pushed onto the stack
1:eac0369: 	 *
1:eac0369: 	 * @param acb		The ActivationClassBuilder for the class we're generating
1:eac0369: 	 * @param eb		The ExpressionBlock that the generate code is to go into
1:eac0369: 	 * @param getColumnExpression "fieldx.getColumn(y)"
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: /*PUSHCOMPILE
1:3bb140c:     void generateNulls(ExpressionClassBuilder acb,
1:eac0369: 									MethodBuilder mb,
1:eac0369: 									Expression getColumnExpress) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		acb.pushDataValueFactory(mb);
1:eac0369: 		getTypeCompiler().generateNull(mb, acb.getBaseClassName());
1:eac0369: 
1:eac0369: 		
1:eac0369: 		mb.cast(ClassName.DataValueDescriptor);
1:eac0369: 
1:eac0369: 
1:eac0369: 		return eb.newCastExpression(
1:eac0369: 					ClassName.DataValueDescriptor, 
1:eac0369: 					getTypeCompiler().
1:eac0369: 						generateNull(
1:eac0369: 									eb,
1:eac0369: 									acb.getBaseClassName(),
1:eac0369: 									acb.getDataValueFactory(eb),
1:eac0369: 									getColumnExpress));
1:eac0369: 	}
1:eac0369: */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	** Check whether the column length and type of this result column
1:eac0369: 	** match the expression under the columns.  This is useful for
1:eac0369: 	** INSERT and UPDATE statements.  For SELECT statements this method
1:eac0369: 	** should always return true.  There is no need to call this for a
1:eac0369: 	** DELETE statement.
1:eac0369: 	**
1:eac0369: 	** @return	true means the column matches its expressions,
1:eac0369: 	**			false means it doesn't match.
1:eac0369: 	*/
1:eac0369: 	boolean columnTypeAndLengthMatch()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** We can never make any assumptions about
1:eac0369: 		** parameters.  So don't even bother in this
1:eac0369: 		** case.
1:eac0369: 		*/
1:ed82406: 		if (getExpression().requiresTypeFromContext())
1:eac0369: 		{
7:eac0369: 			return false;
1:eac0369: 		}
1:c533cd2: 
1:9f654e5: 		// Are we inserting/updating an XML column?  If so, we always
1:9f654e5: 		// return false so that normalization will occur.  We have to
1:9f654e5: 		// do this because there are different "kinds" of XML values
1:9f654e5: 		// and we need to make sure they match--but we don't know
1:9f654e5: 		// the "kind" until execution time.  See the "normalize"
1:9f654e5: 		// method in org.apache.derby.iapi.types.XML for more.
1:ed82406: 		if (getTypeId().isXMLTypeId())
1:9f654e5: 			return false;
1:9f654e5:         
1:ed82406:         
1:ed82406:         DataTypeDescriptor  expressionType = getExpression().getTypeServices();
1:ed82406:         
1:ed82406:         if (!getTypeServices().isExactTypeAndLengthMatch(expressionType))
1:ed82406:             return false;
1:ed82406: 
1:eac0369: 		/* Is the source nullable and the target non-nullable? */
1:ed82406: 		if ((! getTypeServices().isNullable()) && expressionType.isNullable())
1:c723732: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:ed82406: 
1:c723732: 		return true;
1:c723732: 	}
1:c723732: 
1:eac0369: 	boolean columnTypeAndLengthMatch(ResultColumn otherColumn)
1:eac0369: 		throws StandardException
1:c723732: 	{
1:eac0369: 		ValueNode otherExpression = otherColumn.getExpression();
1:c723732: 
1:ed82406:         DataTypeDescriptor resultColumnType = getTypeServices();
1:ed82406:         DataTypeDescriptor otherResultColumnType = otherColumn.getTypeServices();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(resultColumnType != null,
1:eac0369: 					"Type is null for column " + this);
1:eac0369: 			SanityManager.ASSERT(otherResultColumnType != null,
1:eac0369: 					"Type is null for column " + otherColumn);
1:c723732: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** We can never make any assumptions about
1:eac0369: 		** parameters.  So don't even bother in this
1:eac0369: 		** case.
1:c723732: 		*/
1:d5bc20f: 		if ((otherExpression != null) && (otherExpression.requiresTypeFromContext()) ||
1:b0456a0: 			(_expression.requiresTypeFromContext()))
1:eac0369: 		{
1:c723732: 			return false;
1:c723732: 		}
1:eac0369: 
1:9f654e5: 		// Are we inserting/updating an XML column?  If so, we always
1:9f654e5: 		// return false so that normalization will occur.  We have to
1:9f654e5: 		// do this because there are different "kinds" of XML values
1:9f654e5: 		// and we need to make sure they match--but we don't know
1:9f654e5: 		// the "kind" until execution time.  See the "normalize"
1:9f654e5: 		// method in org.apache.derby.iapi.types.XML for more.
1:9f654e5: 		if (resultColumnType.getTypeId().isXMLTypeId())
1:9f654e5: 			return false;
1:9f654e5: 
2:eac0369: 		/* Are they the same type? */
1:eac0369: 		if ( ! resultColumnType.getTypeId().equals(
1:eac0369: 			otherResultColumnType.getTypeId()
3:eac0369: 				)
1:eac0369: 			)
1:eac0369: 		{
1:eac0369: 			/* If the source is a constant of a different type then
1:eac0369: 			 * we try to convert that constant to a constant of our
1:eac0369: 			 * type. (The initial implementation only does the conversion
1:eac0369: 			 * to string types because the most common problem is a char
1:eac0369: 			 * constant with a varchar column.)  
1:eac0369: 			 * NOTE: We do not attempt any conversion here if the source
1:eac0369: 			 * is a string type and the target is not or vice versa in 
1:eac0369: 			 * order to avoid problems with implicit varchar conversions.
1:eac0369: 			 * Anyway, we will check if the "converted" constant has the
1:eac0369: 			 * same type as the original constant.  If not, then the conversion
1:eac0369: 			 * happened.  In that case, we will reuse the ConstantNode, for simplicity,
1:eac0369: 			 * and reset the type to match the desired type.
1:c723732: 			 */
1:eac0369: 			if (otherExpression instanceof ConstantNode)
1:eac0369: 			{
1:eac0369: 				ConstantNode constant = (ConstantNode)otherColumn.getExpression();
1:eac0369: 				DataValueDescriptor oldValue = constant.getValue();
1:eac0369: 
1:eac0369: 				DataValueDescriptor newValue = convertConstant(
1:eac0369: 					resultColumnType.getTypeId(),
1:45f198b: 					resultColumnType.getMaximumWidth(), 
1:45f198b: 					oldValue);
1:eac0369: 
1:eac0369: 				if ((oldValue != newValue) &&
1:eac0369: 					(oldValue instanceof StringDataValue ==
1:eac0369: 					 newValue instanceof StringDataValue))
1:eac0369: 				{
1:eac0369: 					constant.setValue(newValue);
1:eac0369: 					constant.setType(getTypeServices());
1:eac0369: 					otherColumn.bindResultColumnToExpression();
2:eac0369: 					otherResultColumnType = otherColumn.getType();
1:c723732: 				}
1:45f198b: 				//If we are dealing with StringDataValue, then make sure we 
1:45f198b: 				//have correct collation type and derivaiton set and the value
1:45f198b: 				//represented by collation is either SQLxxx or CollatorSQLxxx
1:45f198b: 				//depending on the collation type.
1:45f198b: 				if (newValue instanceof StringDataValue)
1:45f198b: 				{
1:b25481f:                     constant.setCollationInfo(resultColumnType);
1:b25481f:                     
1:45f198b: 					DataValueFactory dvf = getDataValueFactory();
1:45f198b: 					newValue = ((StringDataValue)newValue).getValue(dvf.getCharacterCollator(
1:45f198b: 							constant.getTypeServices().getCollationType()));
1:45f198b: 					constant.setValue(newValue);
1:45f198b: 				}
1:eac0369: 			}
1:eac0369: 			if ( ! resultColumnType.getTypeId().equals(
1:eac0369: 				otherResultColumnType.getTypeId()
1:eac0369: 					)
1:eac0369: 				)
1:eac0369: 			{
1:c723732: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		/* Are they the same precision? */
1:eac0369: 		if (resultColumnType.getPrecision() !=
1:eac0369: 										otherResultColumnType.getPrecision())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		/* Are they the same scale? */
1:eac0369: 		if (resultColumnType.getScale() != otherResultColumnType.getScale())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		/* Are they the same width? */
1:eac0369: 		if (resultColumnType.getMaximumWidth() !=
1:eac0369: 										otherResultColumnType.getMaximumWidth())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Is the source nullable and the target non-nullable? 
1:eac0369: 		 * The source is nullable if it is nullable or if the target is generated
1:eac0369: 		 * for an unmatched column in an insert with a column list.
1:eac0369: 		 * This additional check is needed because when we generate any additional
1:eac0369: 		 * source RCs for an insert with a column list the generated RCs for any 
1:eac0369: 		 * non-specified columns get the type info from the column.  Thus, 
1:eac0369: 		 * for t1(non_nullable, nullable)
1:eac0369: 		 *	insert into t2 (nullable) values 1;
1:eac0369: 		 * RCType.isNullable() returns false for the generated source RC for 
1:eac0369: 		 * non_nullable.  In this case, we want to see it as
1:eac0369: 		 */
1:eac0369: 		if ((! resultColumnType.isNullable()) &&
1:eac0369: 					(otherResultColumnType.isNullable() || 
1:eac0369: 					 otherColumn.isGeneratedForUnmatchedColumnInInsert()))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:c723732: 		return true;
1:eac0369: 	}
1:eac0369: 
1:c533cd2: 	/**
1:eac0369: 	 * Is this a generated column?
1:c723732: 	 *
1:eac0369: 	 * @return Boolean - whether or not this column is a generated column.
1:eac0369: 	 */
1:3bb140c:     boolean isGenerated()
1:eac0369: 	{
1:b0456a0: 		return (_isGenerated == true);
1:eac0369: 	}
1:eac0369: 
1:c723732: 	/**
1:eac0369: 	 * Is this columm generated for an unmatched column in an insert?
1:eac0369: 	 *
1:eac0369: 	 * @return Boolean - whether or not this columm was generated for an unmatched column in an insert.
1:eac0369: 	 */
1:3bb140c:     boolean isGeneratedForUnmatchedColumnInInsert()
1:eac0369: 	{
1:b0456a0: 		return (_isGeneratedForUnmatchedColumnInInsert == true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this a columm as a generated column
1:eac0369: 	 */
1:3bb140c:     void markGenerated()
1:eac0369: 	{
1:b0456a0: 		_isGenerated = true;
1:eac0369: 		/* A generated column is a referenced column */
1:b0456a0: 		_isReferenced = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this a columm as generated for an unmatched column in an insert
1:eac0369: 	 */
1:3bb140c:     void markGeneratedForUnmatchedColumnInInsert()
1:eac0369: 	{
1:b0456a0: 		_isGeneratedForUnmatchedColumnInInsert = true;
1:eac0369: 		/* A generated column is a referenced column */
1:b0456a0: 		_isReferenced = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a referenced column?
1:eac0369: 	 *
1:eac0369: 	 * @return Boolean - whether or not this column is a referenced column.
1:eac0369: 	 */
1:3bb140c:     boolean isReferenced()
1:eac0369: 	{
1:b0456a0: 		return _isReferenced;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this column as a referenced column.
1:eac0369: 	 */
1:3bb140c:     void setReferenced()
1:eac0369: 	{
1:b0456a0: 		_isReferenced = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Mark this column as a referenced column if it is already marked as referenced or if any result column in
1:eac0369:      * its chain of virtual columns is marked as referenced.
1:eac0369:      */
1:eac0369:     void pullVirtualIsReferenced()
1:eac0369:     {
1:eac0369:         if( isReferenced())
2:eac0369:             return;
1:eac0369:         
1:b0456a0:         for( ValueNode expr = _expression; expr != null && (expr instanceof VirtualColumnNode);)
1:eac0369:         {
1:eac0369:             VirtualColumnNode vcn = (VirtualColumnNode) expr;
1:eac0369:             ResultColumn src = vcn.getSourceColumn();
1:eac0369:             if( src.isReferenced())
1:eac0369:             {
1:eac0369:                 setReferenced();
1:eac0369:                 return;
1:eac0369:             }
1:eac0369:             expr = src.getExpression();
1:eac0369:         }
1:eac0369:     } // end of pullVirtualIsReferenced
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this column as an unreferenced column.
1:eac0369: 	 */
1:3bb140c:     void setUnreferenced()
1:eac0369: 	{
1:b0456a0: 		_isReferenced = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:  	 * Mark this RC and all RCs in the underlying
1:eac0369: 	 * RC/VCN chain as referenced.
1:eac0369: 	 */
1:eac0369: 	void markAllRCsInChainReferenced()
1:eac0369: 	{
1:eac0369: 		setReferenced();
1:eac0369: 
1:b0456a0: 		ValueNode vn = _expression;
1:eac0369: 
1:eac0369: 		while (vn instanceof VirtualColumnNode)
1:eac0369: 		{
1:eac0369: 			VirtualColumnNode vcn = (VirtualColumnNode) vn;
1:eac0369: 			ResultColumn rc = vcn.getSourceColumn();
1:eac0369: 			rc.setReferenced();
1:eac0369: 			vn = rc.getExpression();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this a redundant ResultColumn?
1:eac0369: 	 *
1:eac0369: 	 * @return Boolean - whether or not this RC is redundant.
1:eac0369: 	 */
1:3bb140c:     boolean isRedundant()
1:eac0369: 	{
1:b0456a0: 		return _isRedundant;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this ResultColumn as redundant.
1:eac0369: 	 */
1:3bb140c:     void setRedundant()
1:eac0369: 	{
1:b0456a0: 		_isRedundant = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this ResultColumn as a grouping column in the SELECT list
1:eac0369: 	 */
1:3bb140c:     void markAsGroupingColumn()
1:eac0369: 	{
1:b0456a0: 		_isGroupingColumn = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d5bc20f: 	 * Look for and reject ?/-?/+? parameter under this ResultColumn.  This is
1:eac0369: 	 * called for SELECT statements.
1:eac0369: 	 *
1:d5bc20f: 	 * @exception StandardException		Thrown if a ?/-?/+? parameter was found
1:eac0369: 	 *									directly under this ResultColumn.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void rejectParameter() throws StandardException
1:eac0369: 	{
1:b0456a0: 		if ((_expression != null) && (_expression.isParameterNode()))
1:eac0369: 			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** The following methods implement the Comparable interface.
1:eac0369: 	*/
1:3bb140c:     public int compareTo(ResultColumn other)
1:eac0369: 	{
1:3bb140c:         ResultColumn otherResultColumn = other;
1:eac0369: 
1:eac0369: 		return this.getColumnPosition() - otherResultColumn.getColumnPosition();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Mark this column as being updated by an update statement.
1:eac0369: 	 */
1:eac0369: 	void markUpdated()
1:eac0369: 	{
1:b0456a0: 		_updated = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this column as being updatable, so we can make sure it is in the
1:eac0369: 	 * "for update" list of a positioned update.
1:eac0369: 	 */
1:eac0369: 	void markUpdatableByCursor()
1:eac0369: 	{
1:b0456a0: 		_updatableByCursor = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this column is being updated.
1:eac0369: 	 *
1:eac0369: 	 * @return	true means this column is being updated.
1:eac0369: 	 */
1:eac0369: 	boolean updated()
1:eac0369: 	{
1:b0456a0: 		return _updated;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b57ee34: 	 * Tell whether this column is updatable by a positioned update.
1:eac0369: 	 *
1:eac0369: 	 * @return	true means this column is updatable
1:eac0369: 	 */
1:3bb140c:     @Override
1:b57ee34: 	public boolean updatableByCursor()
1:eac0369: 	{
1:b0456a0: 		return _updatableByCursor;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Make a copy of this ResultColumn in a new ResultColumn
1:eac0369: 	 *
1:eac0369: 	 * @return	A new ResultColumn with the same contents as this one
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	ResultColumn cloneMe() throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumn	newResultColumn;
1:eac0369: 		ValueNode		cloneExpr;
1:eac0369: 
1:eac0369: 		/* If expression is a ColumnReference, then we want to 
1:eac0369: 		 * have the RC's clone have a clone of the ColumnReference
1:eac0369: 		 * for it's expression.  This is for the special case of
1:eac0369: 		 * cloning the SELECT list for the HAVING clause in the parser.
1:eac0369: 		 * The SELECT generated for the HAVING needs its own copy
1:eac0369: 		 * of the ColumnReferences.
1:eac0369: 		 */
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:eac0369: 		{
1:b0456a0: 			cloneExpr = ((ColumnReference) _expression).getClone();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:b0456a0: 			cloneExpr = _expression;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* If a columnDescriptor exists, then we must propagate it */
1:b0456a0: 		if (_columnDescriptor != null)
1:eac0369: 		{
1:3bb140c:             newResultColumn = new ResultColumn(
1:b0456a0:                     _columnDescriptor, _expression, getContextManager());
1:eac0369: 			newResultColumn.setExpression(cloneExpr);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:3bb140c:             newResultColumn = new ResultColumn(
1:3bb140c:                     getName(), cloneExpr, getContextManager());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Set the VirtualColumnId and name in the new node */
1:eac0369: 		newResultColumn.setVirtualColumnId(getVirtualColumnId());
1:eac0369: 
1:eac0369: 		/* Set the type and name information in the new node */
1:eac0369: 		newResultColumn.setName(getName());
1:eac0369: 		newResultColumn.setType(getTypeServices());
1:eac0369: 		newResultColumn.setNameGenerated(isNameGenerated());
1:eac0369: 
1:69a192a: 		// For OFFSET/FETCH we need the also clone table name to avoid failing
1:69a192a: 		// check #2 in EmbedResultSet#checksBeforeUpdateXXX. Clone schema for
1:69a192a: 		// good measure...
1:69a192a: 		newResultColumn.setSourceTableName(getSourceTableName());
1:69a192a: 		newResultColumn.setSourceSchemaName(getSourceSchemaName());
1:69a192a: 
1:eac0369: 		/* Set the "is generated for unmatched column in insert" status in the new node
1:eac0369: 		This if for bug 4194*/
1:eac0369: 		if (isGeneratedForUnmatchedColumnInInsert())
1:eac0369: 			newResultColumn.markGeneratedForUnmatchedColumnInInsert();
1:eac0369: 
1:eac0369: 		/* Set the "is referenced" status in the new node */
1:eac0369: 		if (isReferenced())
1:eac0369: 			newResultColumn.setReferenced();
1:eac0369: 
1:eac0369: 		/* Set the "updated" status in the new node */
1:eac0369: 		if (updated())
1:eac0369: 			newResultColumn.markUpdated();
1:eac0369: 
1:eac0369: 		/* Setthe "updatable by cursor" status in the new node */
1:eac0369: 		if (updatableByCursor())
1:eac0369: 			newResultColumn.markUpdatableByCursor();
1:eac0369: 
1:eac0369: 		if (isAutoincrementGenerated())
1:eac0369: 			newResultColumn.setAutoincrementGenerated();
1:eac0369: 
1:eac0369:   		if (isAutoincrement())
1:eac0369:   			newResultColumn.setAutoincrement();
1:01217c2:   		if (isGroupingColumn()) 
1:01217c2:   			newResultColumn.markAsGroupingColumn();
1:d5ef906:   		
1:0eb98f1:   		if (isRightOuterJoinUsingClause()) {
1:0eb98f1:   			newResultColumn.setRightOuterJoinUsingClause(true);
1:0eb98f1:   		}
1:0eb98f1: 
1:0eb98f1:   		if (getJoinResultSet() != null) {
1:0eb98f1:   	  		newResultColumn.setJoinResultset(getJoinResultSet());
1:0eb98f1:   		}
1:0eb98f1:   		
1:d5ef906:   		if (isGenerated()) {
1:d5ef906:   			newResultColumn.markGenerated();
1:d5ef906:   		}
1:c533cd2: 
1:070d37e:         newResultColumn.copyTagsFrom( this );
1:070d37e: 
1:01217c2:   		return newResultColumn;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the maximum size of the column
1:eac0369: 	 *
1:eac0369: 	 * @return the max size
1:eac0369: 	 */
1:3bb140c:     int getMaximumColumnSize()
1:eac0369: 	{
1:ed82406: 		return getTypeServices().getTypeId()
1:ed82406: 			.getApproximateLengthInBytes(getTypeServices());
1:eac0369: 	}
1:ed82406:     
1:3bb140c:     @Override
1:ed82406:     public DataTypeDescriptor getTypeServices()
1:ed82406:     {
1:ed82406:         DataTypeDescriptor type = super.getTypeServices();
1:ed82406:         if (type != null)
1:ed82406:             return type;
1:ed82406:         
1:ed82406:         if (getExpression() != null)
1:ed82406:             return getExpression().getTypeServices();
1:ed82406:         
1:ed82406:         return null;
1:ed82406:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (method calls and non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *		CONSTANT				- constant
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** If the expression is VARIANT, then
1:eac0369: 		** return VARIANT.  Otherwise, we return
1:eac0369: 		** CONSTANT. For result columns that are 
1:eac0369: 		** generating autoincrement values, the result
1:28ce266: 		** is variant.
1:eac0369: 		*/
1:28ce266:         int expType;
1:28ce266:         if (isAutoincrementGenerated()) {
1:28ce266:             expType = Qualifier.VARIANT;
1:b0456a0:         } else if (_expression != null) {
1:b0456a0:             expType = _expression.getOrderableVariantType();
1:28ce266:         } else {
1:28ce266:             expType = Qualifier.CONSTANT;
1:eac0369:         }
1:eac0369: 
1:eac0369: 		switch (expType)
1:eac0369: 		{
1:eac0369: 			case Qualifier.VARIANT: 
1:eac0369: 					return Qualifier.VARIANT;
1:eac0369: 
1:eac0369: 			case Qualifier.SCAN_INVARIANT: 
1:eac0369: 			case Qualifier.QUERY_INVARIANT: 
1:eac0369: 					return Qualifier.SCAN_INVARIANT;
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 					return Qualifier.CONSTANT;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 	
1:b0456a0: 		if (_expression != null)
1:eac0369: 		{
1:b0456a0: 			setExpression( (ValueNode)_expression.accept(v) );
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that this RC is orderable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void verifyOrderable() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		 * Do not check to see if we can map user types
1:eac0369: 		 * to built-in types.  The ability to do so does
1:eac0369: 		 * not mean that ordering will work.  In fact,
1:eac0369: 		 * as of version 2.0, ordering does not work on
1:eac0369: 		 * user types.
1:eac0369: 		 */
1:eac0369: 		if (!getTypeId().orderable(getClassFactory()))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1:eac0369: 						getTypeId().getSQLTypeName());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  If this ResultColumn is bound to a column in a table
1:eac0369: 	  get the column descriptor for the column in the table.
1:eac0369: 	  Otherwise return null.
1:eac0369: 	  */
1:b0456a0: 	ColumnDescriptor getTableColumnDescriptor() {return _columnDescriptor;}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns true if this result column is a placeholder for a generated
1:eac0369: 	 * autoincrement value.
1:eac0369: 	 */
1:3bb140c:     boolean isAutoincrementGenerated()
1:eac0369: 	{
1:3c6be53: 		return _autoincrementGenerated;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     void setAutoincrementGenerated()
1:eac0369: 	{
1:3c6be53: 		_autoincrementGenerated = true;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     void resetAutoincrementGenerated()
1:eac0369: 	{
1:3c6be53: 		_autoincrementGenerated = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:   	public boolean isAutoincrement()
1:eac0369:   	{
1:3c6be53: 		return _autoincrement;
1:eac0369:   	}
1:eac0369: 
1:3bb140c:     void setAutoincrement()
1:eac0369:   	{
1:3c6be53:   		_autoincrement = true;
1:eac0369:   	}
1:eac0369:         
1:b0456a0:     public boolean isGroupingColumn()
1:b0456a0:     {
1:b0456a0:         return _isGroupingColumn;
1:b0456a0:     }
1:01217c2:         
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     @SuppressWarnings("fallthrough")
1:45f198b: 	private DataValueDescriptor convertConstant(TypeId toTypeId, int maxWidth,
1:45f198b: 			DataValueDescriptor constantValue)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int formatId = toTypeId.getTypeFormatId();
1:eac0369: 		DataValueFactory dvf = getDataValueFactory();
4:eac0369: 		switch (formatId)
1:eac0369: 		{
1:eac0369: 			default:
1:eac0369: 			case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369: 				return constantValue;
1:eac0369: 
4:eac0369: 			case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369: 				String sourceValue = constantValue.getString();
1:eac0369: 				int sourceWidth = sourceValue.length();
1:eac0369: 				int posn;
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If the input is already the right length, no normalization is
1:eac0369: 				** necessary - just return the source.
1:eac0369: 				** 
1:eac0369: 				*/
1:eac0369: 
1:eac0369: 				if (sourceWidth <= maxWidth)
1:eac0369: 				{
1:111785f: 					if(formatId == StoredFormatIds.VARCHAR_TYPE_ID)
1:111785f: 						return dvf.getVarcharDataValue(sourceValue);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Check whether any non-blank characters will be truncated.
1:eac0369: 				*/
1:eac0369: 				for (posn = maxWidth; posn < sourceWidth; posn++)
1:eac0369: 				{
1:eac0369: 					if (sourceValue.charAt(posn) != ' ')
1:eac0369: 					{
1:eac0369: 						String typeName = null;
1:111785f: 						if (formatId == StoredFormatIds.VARCHAR_TYPE_ID)
1:eac0369: 								typeName = TypeId.VARCHAR_NAME;
1:eac0369: 						throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, 
1:eac0369: 													 typeName,
1:eac0369: 													 StringUtil.formatForPrint(sourceValue), 
1:eac0369: 													 String.valueOf(maxWidth));
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:111785f: 				if (formatId == StoredFormatIds.VARCHAR_TYPE_ID)
1:111785f: 					return dvf.getVarcharDataValue(sourceValue.substring(0, maxWidth));
1:eac0369: 
1:eac0369: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
2:eac0369: 				//No need to check widths here (unlike varchar), since no max width
1:eac0369: 				return dvf.getLongvarcharDataValue(constantValue.getString());
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:c83a399:     public TableName getTableNameObject() {
1:c83a399:         return null;
1:c83a399:     }
1:eac0369: 
1:444aa52: 	/* Get the wrapped reference if any */
1:3c6be53: 	public	ColumnReference	getReference() { return _reference; }
1:b0456a0: 
1:b0456a0:     /** Get the column descriptor */
1:b0456a0:     ColumnDescriptor    getColumnDescriptor() { return _columnDescriptor; }
1:eac0369: 	
1:eac0369: 	/**
1:abbaf4e: 	 * Get the source BaseColumnNode for this result column. The
1:abbaf4e: 	 * BaseColumnNode cannot be found unless the ResultColumn is bound
1:abbaf4e: 	 * and is a simple reference to a column in a BaseFromTable.
1:eac0369: 	 *
1:abbaf4e: 	 * @return a BaseColumnNode,
1:abbaf4e: 	 *   or null if a BaseColumnNode cannot be found
1:eac0369: 	 */
1:3bb140c:     BaseColumnNode getBaseColumnNode() {
1:b0456a0: 		ValueNode vn = _expression;
1:abbaf4e: 		while (true) {
1:abbaf4e: 			if (vn instanceof ResultColumn) {
1:b0456a0: 				vn = ((ResultColumn) vn)._expression;
1:abbaf4e: 			} else if (vn instanceof ColumnReference) {
1:abbaf4e: 				vn = ((ColumnReference) vn).getSource();
1:abbaf4e: 			} else if (vn instanceof VirtualColumnNode) {
1:abbaf4e: 				vn = ((VirtualColumnNode) vn).getSourceColumn();
1:abbaf4e: 			} else if (vn instanceof BaseColumnNode) {
1:abbaf4e: 				return (BaseColumnNode) vn;
1:abbaf4e: 			} else {
1:abbaf4e: 				return null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6718a25: 	 * Search the tree beneath this ResultColumn until we find
1:6718a25: 	 * the number of the table to which this RC points, and
1:6718a25: 	 * return that table number.  If we can't determine which
1:6718a25: 	 * table this RC is for, then return -1.
1:eac0369: 	 *
1:6718a25: 	 * There are two places we can find the table number: 1) if
1:6718a25: 	 * our expression is a ColumnReference, then we can get the
1:6718a25: 	 * target table number from the ColumnReference and that's
1:6718a25: 	 * it; 2) if expression is a VirtualColumnNode, then if
1:6718a25: 	 * the VirtualColumnNode points to a FromBaseTable, we can
1:6718a25: 	 * get that FBT's table number; otherwise, we walk the
1:6718a25: 	 * VirtualColumnNode-ResultColumn chain and do a recursive
1:6718a25: 	 * search.
1:eac0369: 	 *
1:6718a25: 	 * @return The number of the table to which this ResultColumn	
1:6718a25: 	 *  points, or -1 if we can't determine that from where we are.
1:eac0369: 	 */
1:3bb140c:     int getTableNumber()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:b0456a0: 		if (_expression instanceof ColumnReference)
1:b0456a0: 			return ((ColumnReference)_expression).getTableNumber();
1:b0456a0: 		else if (_expression instanceof VirtualColumnNode)
1:eac0369: 		{
1:b0456a0: 			VirtualColumnNode vcn = (VirtualColumnNode)_expression;
1:eac0369: 
1:6718a25: 			// If the VCN points to a FromBaseTable, just get that
1:6718a25: 			// table's number.
1:6718a25: 			if (vcn.getSourceResultSet() instanceof FromBaseTable)
1:eac0369: 			{
1:6718a25: 				return ((FromBaseTable)vcn.getSourceResultSet()).
1:6718a25: 					getTableNumber();
1:eac0369: 			}
1:eac0369: 
1:6718a25: 			// Else recurse down the VCN.
1:6718a25: 			return vcn.getSourceColumn().getTableNumber();
1:eac0369: 		}
1:eac0369: 
1:6718a25: 		// We can get here if expression has neither a column
1:6718a25: 		// reference nor a FromBaseTable beneath it--for example,
1:6718a25: 		// if it is of type BaseColumnNode. 
1:6718a25: 		return -1;
1:01217c2: 	}
1:01217c2: 	
1:3bb140c:     boolean isEquivalent(ValueNode o) throws StandardException
1:01217c2: 	{
1:2706d1f:         if (isSameNodeKind(o)) {
1:01217c2:         	ResultColumn other = (ResultColumn)o;
1:b0456a0:         	if (_expression != null) {
1:b0456a0:         		return _expression.isEquivalent(other._expression);
1:01217c2:         	}
1:01217c2:         }
1:2706d1f: 
1:01217c2:         return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:c533cd2: 	 * Return true if this result column represents a generated column.
1:c533cd2: 	 */
1:c533cd2: 	public boolean hasGenerationClause()
1:c533cd2: 	{
1:b0456a0:         if ( (_columnDescriptor != null) && _columnDescriptor.hasGenerationClause() ) { return true; }
1:c533cd2:         else { return false; }
1:c533cd2: 	}
1:c533cd2:     
1:eac0369: }
1:c533cd2: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b9e22cc
/////////////////////////////////////////////////////////////////////////
1:  	/**
1: 	 * Returns true if this column is updatable.
1: 	 *
1: 	 * This method is used for determining if updateRow and insertRow
1: 	 * are allowed for this cursor (DERBY-1773). Since the updateRow
1: 	 * and insertRow implementations dynamically build SQL statements
1: 	 * on the fly, the critical issue here is whether we have a
1: 	 * column that has been aliased, because if it has been
1: 	 * aliased, the dynamic SQL generation logic won't be able to
1: 	 * compute the proper true base column name when it needs to.
1: 	 *
1: 	 * @return true if this result column is updatable.
1: 	 */
1: 	boolean isUpdatable()
1: 	{
1: 		return _derivedColumnName == null ||
1: 			_underlyingName.equals(_derivedColumnName);
1: 	}
1: 
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:497ffc7
/////////////////////////////////////////////////////////////////////////
1: 	 * Return TRUE if this result column matches the provided column name.
1: 	 *
1: 	 * This function is used by ORDER BY column resolution. For the
1: 	 * ORDER BY clause, Derby will prefer to match on the column's
0: 	 * alias (exposedName), but will also successfully match on the
1: 	 * underlying column name. Thus the following statements are
1: 	 * treated equally:
1: 	 *  select name from person order by name;
1: 	 *  select name as person_name from person order by name;
1: 	 *  select name as person_name from person order by person_name;
1: 	 * See DERBY-2351 for more discussion.
1: 	 */
1: 	boolean columnNameMatches(String columnName)
1: 	{
0: 		return columnName.equals(exposedName) ||
0: 			columnName.equals(name) ||
1: 			columnName.equals(getSourceColumnName());
1: 	}
1: 	/**
1: 	 * Returns the underlying source column name, if this ResultColumn
1: 	 * is a simple direct reference to a table column, or NULL otherwise.
1: 	 */
1: 	String getSourceColumnName()
1: 	{
0: 		if (expression instanceof ColumnReference)
0: 			return ((ColumnReference)expression).getColumnName();
1: 		return null;
1: 	}
1: 	/**
commit:2bb13ac
/////////////////////////////////////////////////////////////////////////
1: 	 * Adjust this virtualColumnId to account for the removal of a column
1: 	 *
1: 	 * This routine is called when bind processing finds and removes
1: 	 * duplicate columns in the result list which were pulled up due to their
1: 	 * presence in the ORDER BY clause, but were later found to be duplicate.
1: 	 * 
1: 	 * If this column is a virtual column, and if this column's virtual
1: 	 * column id is greater than the column id which is being removed, then
1: 	 * we must logically shift this column to the left by decrementing its
1: 	 * virtual column id.
1: 	 *
1: 	 * @param removedColumnId   id of the column being removed.
1: 	 */
0: 	public void collapseVirtualColumnIdGap(int removedColumnId)
1: 	{
0: 		if (columnDescriptor == null && virtualColumnId > removedColumnId)
1: 			virtualColumnId--;
1: 	}
1: 
1: 	/**
commit:9f654e5
/////////////////////////////////////////////////////////////////////////
1: 
1: 		// Are we inserting/updating an XML column?  If so, we always
1: 		// return false so that normalization will occur.  We have to
1: 		// do this because there are different "kinds" of XML values
1: 		// and we need to make sure they match--but we don't know
1: 		// the "kind" until execution time.  See the "normalize"
1: 		// method in org.apache.derby.iapi.types.XML for more.
1: 		if (resultColumnType.getTypeId().isXMLTypeId())
1: 			return false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// Are we inserting/updating an XML column?  If so, we always
1: 		// return false so that normalization will occur.  We have to
1: 		// do this because there are different "kinds" of XML values
1: 		// and we need to make sure they match--but we don't know
1: 		// the "kind" until execution time.  See the "normalize"
1: 		// method in org.apache.derby.iapi.types.XML for more.
0: 		if (resultColumnType.getTypeId().isXMLTypeId())
1: 			return false;
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2f8e6fb
/////////////////////////////////////////////////////////////////////////
1: 		if (
1:             _reference != null &&
1:             _reference.getTableName() != null &&
1:             (_reference.getMergeTableID() == ColumnReference.MERGE_UNKNOWN)
1:             ) 
commit:3c6be53
/////////////////////////////////////////////////////////////////////////
1: 	private boolean			_autoincrementGenerated;
1: 	private boolean 		_autoincrement;
1: 	private ColumnReference _reference; // used to verify quals at bind time, if given.
/////////////////////////////////////////////////////////////////////////
1:         _reference = cr;
/////////////////////////////////////////////////////////////////////////
1:         _autoincrement = cd.isAutoincrement();
/////////////////////////////////////////////////////////////////////////
1:             _reference = (ColumnReference)expression;
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(_reference == null || 
1: 				name.equals(_reference.getColumnName()), 
/////////////////////////////////////////////////////////////////////////
1: 			if (_reference != null)
1: 				_reference.treePrint(depth + 1);
/////////////////////////////////////////////////////////////////////////
1: 			_autoincrement = ((ColumnReference)_expression).getSource().isAutoincrement();
/////////////////////////////////////////////////////////////////////////
0: 		if (_reference != null && _reference.getTableName() != null) 
1: 					_reference.getTableName()) ) 
/////////////////////////////////////////////////////////////////////////
1: 				String refName = _reference.getTableName();
/////////////////////////////////////////////////////////////////////////
1: 		return _autoincrementGenerated;
1: 		_autoincrementGenerated = true;
1: 		_autoincrementGenerated = false;
1: 		return _autoincrement;
1:   		_autoincrement = true;
/////////////////////////////////////////////////////////////////////////
1: 	public	ColumnReference	getReference() { return _reference; }
commit:feecfdd
/////////////////////////////////////////////////////////////////////////
1:      * @param underlyingName The name of the column, if any.
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 	/* _underlyingName and _derivedColumnName should point to the same string, unless there is a
1: 	 * derived column list, in which case _underlyingName will point to the underlying name
1: 	 * and _derivedColumnName will point to the name from the derived column list.
1: 	private String			_underlyingName; // name from the actual data source
1: 	private String			_derivedColumnName;
1: 	private String			_unqualifiedTableName;
1: 	private String			_unqualifiedSourceTableName;
1: 	private String			_sourceSchemaName;
1: 	private ValueNode		_expression;
1: 	private ColumnDescriptor	_columnDescriptor;
1: 	private boolean			_isGenerated;
1: 	private boolean			_isGeneratedForUnmatchedColumnInInsert;
1: 	private boolean			_isGroupingColumn;
1: 	private boolean			_isReferenced;
1: 	private boolean			_isRedundant;
1: 	private boolean			_isNameGenerated;
1: 	private boolean			_updated;
1: 	private boolean			_updatableByCursor;
/////////////////////////////////////////////////////////////////////////
1:             String underlyingName,
1:         _underlyingName = underlyingName;
1:         _derivedColumnName = _underlyingName;
/////////////////////////////////////////////////////////////////////////
1:         _underlyingName = cr.getColumnName();
1:         _derivedColumnName = cr.getColumnName();
/////////////////////////////////////////////////////////////////////////
1:         _underlyingName = cd.getColumnName();
1:         _derivedColumnName = _underlyingName;
1:         _columnDescriptor = cd;
/////////////////////////////////////////////////////////////////////////
1:         if (_expression instanceof ColumnReference) {
/////////////////////////////////////////////////////////////////////////
1: 	 * alias (_derivedColumnName), but will also successfully match on the
/////////////////////////////////////////////////////////////////////////
1: 		return columnName.equals(_derivedColumnName) ||
1: 			columnName.equals( _underlyingName ) ||
/////////////////////////////////////////////////////////////////////////
1:         {
1:         }
1: 		else if ( _underlyingName != null )
1:         {
1: 			return _underlyingName;
1:         }
1:         {
1: 			return _derivedColumnName;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression instanceof ColumnReference)
1: 			return ((ColumnReference)_expression).getColumnName();
/////////////////////////////////////////////////////////////////////////
1: 		return _derivedColumnName;
1: 		if ((_columnDescriptor!=null) &&
1: 			(_columnDescriptor.getTableDescriptor() != null))
1: 			return _columnDescriptor.getTableDescriptor().getSchemaName();
1: 			if (_expression != null)
1: 				return _expression.getSchemaName();
/////////////////////////////////////////////////////////////////////////
1: 		if (_unqualifiedTableName != null)
1: 			return _unqualifiedTableName;
1: 		if ((_columnDescriptor!=null) &&
1: 			(_columnDescriptor.getTableDescriptor() != null))
1: 			return _columnDescriptor.getTableDescriptor().getName();
1: 			return _expression.getTableName();
/////////////////////////////////////////////////////////////////////////
1: 		return _unqualifiedSourceTableName;
/////////////////////////////////////////////////////////////////////////
1: 		return _sourceSchemaName;
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression instanceof ColumnReference)
1: 			((ColumnReference) _expression).setQualifiedTableName( (TableName) null );
/////////////////////////////////////////////////////////////////////////
1: 		if (_columnDescriptor!=null)
1: 			return _columnDescriptor.getPosition();
/////////////////////////////////////////////////////////////////////////
1: 		_expression = expression;
/////////////////////////////////////////////////////////////////////////
1: 		return _expression;
/////////////////////////////////////////////////////////////////////////
1: 		if ( _underlyingName == null )
1: 			_underlyingName = name;
/////////////////////////////////////////////////////////////////////////
1: 		_derivedColumnName = name;
/////////////////////////////////////////////////////////////////////////
1: 		return _isNameGenerated;
/////////////////////////////////////////////////////////////////////////
1: 		_isNameGenerated = value;
/////////////////////////////////////////////////////////////////////////
1: 		if (_columnDescriptor == null && virtualColumnId > removedColumnId)
/////////////////////////////////////////////////////////////////////////
1: 		if (_derivedColumnName == null)
1: 			_derivedColumnName ="SQLCol" + getCompilerContext().getNextColumnNumber();
1: 			_isNameGenerated = true;
/////////////////////////////////////////////////////////////////////////
1: 			return "derivedColumnName: " + _derivedColumnName + "\n" +
1: 				"underlyingName: " + _underlyingName + "\n" +
1: 				"tableName: " + _unqualifiedTableName + "\n" +
1: 				"isNameGenerated: " + _isNameGenerated + "\n" +
1: 				"sourceTableName: " + _unqualifiedSourceTableName + "\n" +
1: 				"columnDescriptor: " + _columnDescriptor + "\n" +
1: 				"isGenerated: " + _isGenerated + "\n" +
1: 				"isGeneratedForUnmatchedColumnInInsert: " + _isGeneratedForUnmatchedColumnInInsert + "\n" +
1: 				"isGroupingColumn: " + _isGroupingColumn + "\n" +
1: 				"isReferenced: " + _isReferenced + "\n" +
1: 				"isRedundant: " + _isRedundant + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 			if (_expression != null)
1: 				_expression.treePrint(depth + 1);
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression.requiresTypeFromContext())
1: 				_expression.setType(getTypeServices());
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression.getTableName() == null) {
1: 		setExpression( _expression.bindExpression(fromList, subqueryList,
1: 		if (_expression instanceof ColumnReference)
0: 			autoincrement = ((ColumnReference)_expression).getSource().isAutoincrement();
/////////////////////////////////////////////////////////////////////////
1:         colDesc = tableDescriptor.getColumnDescriptor(_derivedColumnName);
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, _derivedColumnName, errorString);
/////////////////////////////////////////////////////////////////////////
1:         if( _expression instanceof UntypedNullConstantNode)
1:         else if( ( _expression instanceof ColumnReference) && _expression.getTypeServices() == null)
1:             _expression.setType( bindingRC.getType());
/////////////////////////////////////////////////////////////////////////
1: 		if ( columnDescriptor != null ) { setType(columnDescriptor.getType()); }
1: 		_columnDescriptor = columnDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 			if ( (tableDescriptor != null) && ! tableDescriptor.getName().equals(
1: 				**	reference.getQualifiedTableName().getSchemaName())) {
/////////////////////////////////////////////////////////////////////////
1: 		setType(_expression.getTypeServices());
1: 		if (_expression instanceof ColumnReference)
1: 			ColumnReference cr = (ColumnReference) _expression;
1: 			_unqualifiedTableName = cr.getTableName();
1: 			_unqualifiedSourceTableName = cr.getSourceTableName();
1: 			_sourceSchemaName = cr.getSourceSchemaName();
/////////////////////////////////////////////////////////////////////////
1: 		_unqualifiedSourceTableName = t;
/////////////////////////////////////////////////////////////////////////
1: 		_sourceSchemaName = s;
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression == null)
1: 		setExpression( _expression.preprocess(numTables, outerFromList,
/////////////////////////////////////////////////////////////////////////
1:         _expression.generateExpression(ecb, mb);
/////////////////////////////////////////////////////////////////////////
1: 			(_expression.requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
1: 		return (_isGenerated == true);
/////////////////////////////////////////////////////////////////////////
1: 		return (_isGeneratedForUnmatchedColumnInInsert == true);
/////////////////////////////////////////////////////////////////////////
1: 		_isGenerated = true;
1: 		_isReferenced = true;
/////////////////////////////////////////////////////////////////////////
1: 		_isGeneratedForUnmatchedColumnInInsert = true;
1: 		_isReferenced = true;
/////////////////////////////////////////////////////////////////////////
1: 		return _isReferenced;
/////////////////////////////////////////////////////////////////////////
1: 		_isReferenced = true;
/////////////////////////////////////////////////////////////////////////
1:         for( ValueNode expr = _expression; expr != null && (expr instanceof VirtualColumnNode);)
/////////////////////////////////////////////////////////////////////////
1: 		_isReferenced = false;
/////////////////////////////////////////////////////////////////////////
1: 		ValueNode vn = _expression;
/////////////////////////////////////////////////////////////////////////
1: 		return _isRedundant;
/////////////////////////////////////////////////////////////////////////
1: 		_isRedundant = true;
/////////////////////////////////////////////////////////////////////////
1: 		_isGroupingColumn = true;
/////////////////////////////////////////////////////////////////////////
1: 		if ((_expression != null) && (_expression.isParameterNode()))
/////////////////////////////////////////////////////////////////////////
1: 		_updated = true;
/////////////////////////////////////////////////////////////////////////
1: 		_updatableByCursor = true;
/////////////////////////////////////////////////////////////////////////
1: 		return _updated;
/////////////////////////////////////////////////////////////////////////
1: 		return _updatableByCursor;
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression instanceof ColumnReference)
1: 			cloneExpr = ((ColumnReference) _expression).getClone();
1: 			cloneExpr = _expression;
1: 		if (_columnDescriptor != null)
1:                     _columnDescriptor, _expression, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         } else if (_expression != null) {
1:             expType = _expression.getOrderableVariantType();
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression != null)
1: 			setExpression( (ValueNode)_expression.accept(v) );
/////////////////////////////////////////////////////////////////////////
1: 	ColumnDescriptor getTableColumnDescriptor() {return _columnDescriptor;}
/////////////////////////////////////////////////////////////////////////
1:     public boolean isGroupingColumn()
1:     {
1:         return _isGroupingColumn;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the column descriptor */
1:     ColumnDescriptor    getColumnDescriptor() { return _columnDescriptor; }
/////////////////////////////////////////////////////////////////////////
1: 		ValueNode vn = _expression;
1: 				vn = ((ResultColumn) vn)._expression;
/////////////////////////////////////////////////////////////////////////
1: 		if (_expression instanceof ColumnReference)
1: 			return ((ColumnReference)_expression).getTableNumber();
1: 		else if (_expression instanceof VirtualColumnNode)
1: 			VirtualColumnNode vcn = (VirtualColumnNode)_expression;
/////////////////////////////////////////////////////////////////////////
1:         	if (_expression != null) {
1:         		return _expression.isEquivalent(other._expression);
/////////////////////////////////////////////////////////////////////////
1:         if ( (_columnDescriptor != null) && _columnDescriptor.hasGenerationClause() ) { return true; }
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1:         newResultColumn.copyTagsFrom( this );
1: 
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:97a8b1c
/////////////////////////////////////////////////////////////////////////
1:     private boolean wasDefault;
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns TRUE if the ResultColumn used to stand in for a DEFAULT keyword in
1: 	 * an insert/update statement.
1: 	 */
0: 	public boolean wasDefaultColumn()
1: 	{
1: 		return wasDefault;
1: 	}
1: 
0: 	public void setWasDefaultColumn(boolean value)
1: 	{
1: 		wasDefault = value;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 				"isDefaultColumn: " + defaultColumn + "\n" +
1: 				"wasDefaultColumn: " + wasDefault + "\n" +
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
0: 			setExpression( (ValueNode) arg2 );
/////////////////////////////////////////////////////////////////////////
0: 			setExpression( (ValueNode) arg2 );
/////////////////////////////////////////////////////////////////////////
0: 			setExpression( (ValueNode) arg2 );
0: 			setExpression( (ValueNode) arg2 );
/////////////////////////////////////////////////////////////////////////
1: 		setExpression( getNullNode(getTypeServices()) );
/////////////////////////////////////////////////////////////////////////
0: 		setExpression( expression.bindExpression(fromList, subqueryList,
0:                                                  aggregateVector) );
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:             setExpression( getNullNode(bindingRC.getTypeServices()) );
/////////////////////////////////////////////////////////////////////////
0: 		setExpression( expression.preprocess(numTables, outerFromList,
1:                                            outerPredicateList) );
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0: 			setExpression( (ValueNode)expression.accept(v) );
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return true if this result column represents a generated column.
1: 	 */
1: 	public boolean hasGenerationClause()
1: 	{
0:         if ( (columnDescriptor != null) && columnDescriptor.hasGenerationClause() ) { return true; }
1:         else { return false; }
1: 	}
1:     
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 expression instanceof DefaultNode) {
/////////////////////////////////////////////////////////////////////////
1:         if (isSameNodeKind(o)) {
1: 
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("fallthrough")
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
1: class ResultColumn extends ValueNode
1:                 implements ResultColumnDescriptor, Comparable<ResultColumn>
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn(ContextManager cm) {
1:         super(cm);
1:     }
1:     /**
0:      * @param name The name of the column, if any.
1:      * @param expression The expression this result column represents
1:      * @param cm context manager
1:      */
1:     ResultColumn(
0:             String name,
1:             ValueNode expression,
1:             ContextManager cm) throws StandardException {
1:         super(cm);
1:         setTypeExpressionAndDefault(expression);
0:         this.name = name;
0:         this.exposedName = this.name;
1:     }
1:     /**
1:      * @param cr A column reference node
1:      * @param expression The expression this result column represents
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     ResultColumn(
1:             ColumnReference cr,
1:             ValueNode expression,
1:             ContextManager cm) throws StandardException {
1:         super(cm);
1:         setTypeExpressionAndDefault(expression);
0:         this.name = cr.getColumnName();
0:         this.exposedName = cr.getColumnName();
1: 
1:         // When we bind, we'll want to make sure the reference has the right
1:         // table name.
0:         this.reference = cr;
1:     }
1: 
1:     /**
1:      * @param cd The column descriptor
1:      * @param expression The expression this result column represents
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     ResultColumn(
1:             ColumnDescriptor cd,
1:             ValueNode expression,
1:             ContextManager cm) throws StandardException {
1:         super(cm);
1:         setTypeExpressionAndDefault(expression);
0:         this.name = cd.getColumnName();
0:         this.exposedName = name;
1:         setType(cd.getType());
0:         this.columnDescriptor = cd;
0:         this.autoincrement = cd.isAutoincrement();
1:     }
1: 
1:     /**
1:      * @param dtd The type of the column
1:      * @param expression The expression this result column represents
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     ResultColumn(
1:             DataTypeDescriptor dtd,
1:             ValueNode expression,
1:             ContextManager cm) throws StandardException {
1:         super(cm);
1:         setTypeExpressionAndDefault(expression);
1:         setType(dtd);
1: 
0:         if (expression instanceof ColumnReference) {
0:             reference = (ColumnReference)expression;
1:         }
1:     }
1: 
1:     private void setTypeExpressionAndDefault(ValueNode expression) {
0:         setNodeType(C_NodeTypes.RESULT_COLUMN);
1:         setExpression(expression);
1: 
1:         if (expression != null &&
0:            expression.isInstanceOf(C_NodeTypes.DEFAULT_NODE)) {
1:             // This result column represents a <default> keyword in an insert or
1:             // update statement
1:             defaultColumn = true;
1:         }
1:     }
1: 
1:     /**
1:     boolean isRightOuterJoinUsingClause()
/////////////////////////////////////////////////////////////////////////
1:     void setRightOuterJoinUsingClause(boolean value)
/////////////////////////////////////////////////////////////////////////
1:     JoinNode getJoinResultSet() {
/////////////////////////////////////////////////////////////////////////
1:     void setJoinResultset(JoinNode resultSet)
/////////////////////////////////////////////////////////////////////////
1:     boolean isDefaultColumn()
1:     void setDefaultColumn(boolean value)
/////////////////////////////////////////////////////////////////////////
1:     boolean wasDefaultColumn()
1:     void setWasDefaultColumn(boolean value)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getSchemaName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getTableName()
/////////////////////////////////////////////////////////////////////////
1:     void clearTableName()
/////////////////////////////////////////////////////////////////////////
1:     void setExpression(ValueNode expression)
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getExpression()
/////////////////////////////////////////////////////////////////////////
1:     void setName(String name)
/////////////////////////////////////////////////////////////////////////
1:     boolean isNameGenerated()
/////////////////////////////////////////////////////////////////////////
1:     void setNameGenerated(boolean value)
/////////////////////////////////////////////////////////////////////////
1:     void setResultSetNumber(int resultSetNumber)
/////////////////////////////////////////////////////////////////////////
1:     void adjustVirtualColumnId(int adjust)
/////////////////////////////////////////////////////////////////////////
1:     void setVirtualColumnId(int id)
/////////////////////////////////////////////////////////////////////////
1:     int getVirtualColumnId()
/////////////////////////////////////////////////////////////////////////
1:     void collapseVirtualColumnIdGap(int removedColumnId)
/////////////////////////////////////////////////////////////////////////
1:     void guaranteeColumnName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         ColumnDescriptor    colDesc;
1:         colDesc = tableDescriptor.getColumnDescriptor(columnId);
1:         if (colDesc == null)
/////////////////////////////////////////////////////////////////////////
1:         setColumnDescriptor(tableDescriptor, colDesc);
/////////////////////////////////////////////////////////////////////////
1:     void bindResultColumnByName(TableDescriptor tableDescriptor,
1:         ColumnDescriptor    colDesc;
0:         colDesc = tableDescriptor.getColumnDescriptor(exposedName);
1:         if (colDesc == null)
/////////////////////////////////////////////////////////////////////////
1:         setColumnDescriptor(tableDescriptor, colDesc);
1:             getCompilerContext().addRequiredColumnPriv( colDesc);
/////////////////////////////////////////////////////////////////////////
1:     void typeUntypedNullExpression( ResultColumn bindingRC)
/////////////////////////////////////////////////////////////////////////
1:     void bindResultColumnToExpression()
/////////////////////////////////////////////////////////////////////////
1:     void setSourceTableName(String t) {
/////////////////////////////////////////////////////////////////////////
1:     void setSourceSchemaName(String s) {
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     void checkStorableExpression(ResultColumn toStore)
/////////////////////////////////////////////////////////////////////////
1:     void checkStorableExpression()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void generateNulls(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     boolean isGenerated()
/////////////////////////////////////////////////////////////////////////
1:     boolean isGeneratedForUnmatchedColumnInInsert()
/////////////////////////////////////////////////////////////////////////
1:     void markGenerated()
/////////////////////////////////////////////////////////////////////////
1:     void markGeneratedForUnmatchedColumnInInsert()
/////////////////////////////////////////////////////////////////////////
1:     boolean isReferenced()
/////////////////////////////////////////////////////////////////////////
1:     void setReferenced()
/////////////////////////////////////////////////////////////////////////
1:     void setUnreferenced()
/////////////////////////////////////////////////////////////////////////
1:     boolean isRedundant()
/////////////////////////////////////////////////////////////////////////
1:     void setRedundant()
/////////////////////////////////////////////////////////////////////////
1:     void markAsGroupingColumn()
/////////////////////////////////////////////////////////////////////////
1:     public int compareTo(ResultColumn other)
1:         ResultColumn otherResultColumn = other;
1:      * Mark this column as being updated by an update statement.
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             newResultColumn = new ResultColumn(
0:                     columnDescriptor, expression, getContextManager());
1:             newResultColumn = new ResultColumn(
1:                     getName(), cloneExpr, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     int getMaximumColumnSize()
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     boolean isAutoincrementGenerated()
1:     void setAutoincrementGenerated()
1:     void resetAutoincrementGenerated()
/////////////////////////////////////////////////////////////////////////
1:     void setAutoincrement()
/////////////////////////////////////////////////////////////////////////
1:     BaseColumnNode getBaseColumnNode() {
/////////////////////////////////////////////////////////////////////////
1:     int getTableNumber()
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
commit:f8a53ec
/////////////////////////////////////////////////////////////////////////
commit:7bfb37a
/////////////////////////////////////////////////////////////////////////
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Set the column source's table name
1: 	 * @param t The source table name
1: 	 */
0: 	public void setSourceTableName(String t) {
0: 		sourceTableName = t;
1: 	}
1: 
1: 	/**
1: 	 * Set the column source's schema name
1: 	 * @param s The source schema name
1: 	 */
0: 	public void setSourceSchemaName(String s) {
0: 		sourceSchemaName = s;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// For OFFSET/FETCH we need the also clone table name to avoid failing
1: 		// check #2 in EmbedResultSet#checksBeforeUpdateXXX. Clone schema for
1: 		// good measure...
1: 		newResultColumn.setSourceTableName(getSourceTableName());
1: 		newResultColumn.setSourceSchemaName(getSourceSchemaName());
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
commit:2b467cf
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder ecb, MethodBuilder mb)
0:         expression.generateExpression(ecb, mb);
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
0:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
0:         expression.generateExpression(acb, mb);
commit:dda453e
/////////////////////////////////////////////////////////////////////////
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:                                                  aggregates) );
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					List aggregateVector)
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
0: 		if (expression != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0eb98f1
/////////////////////////////////////////////////////////////////////////
1:  * the underlying expression will be the type of the source of the
1:  * the expression and the type of ResultColumn. This class does
/////////////////////////////////////////////////////////////////////////
1:     //Following 2 fields have been added for DERBY-4631. 
1:     //rightOuterJoinUsingClause will be set to true for following 2 cases
1:     //1)if this column represents the join column which is part of the 
1:     //  SELECT list of a RIGHT OUTER JOIN with USING/NATURAL. eg
1:     //     select c from t1 right join t2 using (c)
1:     //  This case is talking about column c as in "select c"
1:     //2)if this column represents the join column from the right table 
1:     //  for predicates generated for the USING/NATURAL of RIGHT OUTER JOIN
1:     //  eg
1:     //     select c from t1 right join t2 using (c)
1:     //  For "using(c)", a join predicate will be created as follows
1:     //    t1.c=t2.c
1:     //  This case is talking about column t2.c of the join predicate.
1:     private boolean rightOuterJoinUsingClause;
1:     //Following will be non-null for the case 1) above. It will show the
1:     // association of this result column to the join resultset created
1:     // for the RIGHT OUTER JOIN with USING/NATURAL. This information along
1:     // with rightOuterJoinUsingClause will be used during the code generation
1:     // time.
1:     private JoinNode joinResultSet = null;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Returns TRUE if the ResultColumn is join column for a RIGHT OUTER 
1: 	 *  JOIN with USING/NATURAL. More comments at the top of this class
1: 	 *  where rightOuterJoinUsingClause is defined.
1: 	 *  
1: 	 * @param value True/False
1: 	 */
0: 	public boolean isRightOuterJoinUsingClause()
1: 	{
1: 		return rightOuterJoinUsingClause;
1: 	}
1: 	 * Will be set to TRUE if this ResultColumn is join column for a 
1: 	 *  RIGHT OUTER JOIN with USING/NATURAL. More comments at the top of 
1: 	 *  this class where rightOuterJoinUsingClause is defined. 2 eg cases
1: 	 * 1)select c from t1 right join t2 using (c)
1: 	 *   This case is talking about column c as in "select c"
1: 	 * 2)select c from t1 right join t2 using (c)
1: 	 *   For "using(c)", a join predicate will be created as follows
1: 	 *     t1.c=t2.c
1: 	 *   This case is talking about column t2.c of the join predicate.
1: 	 *   
1: 	 * This method gets called for Case 1) during the bind phase of
1: 	 *  ResultColumn(ResultColumn.bindExpression).
1: 	 *   
1: 	 * This method gets called for Case 2) during the bind phase of
1: 	 *  JoinNode while we are going through the list of join columns
1: 	 *  for a NATURAL JOIN or user supplied list of join columns for
1: 	 *  USING clause(JoinNode.getMatchingColumn).
1: 	 *  
1: 	 * @param value True/False
1: 	 */
0: 	public void setRightOuterJoinUsingClause(boolean value)
1: 	{
1: 		rightOuterJoinUsingClause = value;
1: 	}
1: 
1: 	/**
1: 	 * Returns a non-null value if the ResultColumn represents the join
1: 	 * column which is part of the SELECT list of a RIGHT OUTER JOIN with
1: 	 * USING/NATURAL. eg
1: 	 *      select c from t1 right join t2 using (c)
1: 	 * The join column we are talking about is column c as in "select c"
1: 	 * The return value of following method will show the association of this 
1: 	 * result column to the join resultset created for the RIGHT OUTER JOIN 
1: 	 * with USING/NATURAL. This information along with 
1: 	 * rightOuterJoinUsingClause will be used during the code generation 
1: 	 * time.
1: 	 */
0: 	public JoinNode getJoinResultSet() {
1: 		return joinResultSet;
1: 	}
1: 
1: 	/**
1: 	 * This method gets called during the bind phase of a ResultColumn if it
1: 	 *  is determined that the ResultColumn represents the join column which
1: 	 *  is part of the SELECT list of a RIGHT OUTER JOIN with 
1: 	 *  USING/NATURAL. eg
1: 	 *      select c from t1 right join t2 using (c)
1: 	 *   This case is talking about column c as in "select c"
1: 	 * @param resultSet - The ResultColumn belongs to this JoinNode
1: 	 */
0: 	public void setJoinResultset(JoinNode resultSet)
1: 	{
1: 		joinResultSet = resultSet;
1: 	}
1: 	
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Get non-null column name. This method is called during the bind phase
1: 	 *  to see if we are dealing with ResultColumn in the SELECT list that 
1: 	 *  belongs to a RIGHT OUTER JOIN(NATURAL OR USING)'s join column.
1: 	 * 					
1: 	 * For a query like following, we want to use column name x and not the
1: 	 *  alias x1 when looking in the JoinNode for join column
1: 	 *   SELECT x x1
1: 	 *   	 FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;
1: 	 * For a query like following, getSourceColumnName() will return null
1: 	 *  because we are dealing with a function for the column. For this
1: 	 *  case, "name" will return the alias name cx
1: 	 *   SELECT coalesce(derby4631_t2.x, derby4631_t1.x) cx
1: 	 *   	 FROM derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1;	
1: 	 * For a query like following, getSourceColumnName() and name will 
1: 	 *  return null and hence need to use the generated name
1: 	 *   SELECT ''dummy="'|| TRIM(CHAR(x))|| '"'
1: 	 *        FROM (derby4631_t2 NATURAL RIGHT OUTER JOIN derby4631_t1);
1: 	 */
1: 	String getUnderlyingOrAliasName() 
1: 	{
1: 		if (getSourceColumnName() != null)
1: 			return getSourceColumnName();
0: 		else if (name != null)
0: 			return name;
1: 		else
0: 			return exposedName;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 				"rightOuterJoinUsingClause: " + rightOuterJoinUsingClause + "\n" +
1: 				"joinResultSet: " + joinResultSet + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 		//DERBY-4631
1: 		//Following code is for a join column(which obviously will not be 
1: 		// qualified with a table name because join columns are not
1: 		// associated with left or right table) of RIGHT OUTER JOIN  
1: 		// with USING/NATURAL join. For such columns, 
1: 		// isJoinColumnForRightOuterJoin() call will set 
1: 		// rightOuterJoinUsingClause to true and associate the  
1: 		// JoinResultSet with it. eg
1: 		//      select c from t1 right join t2 using (c)
1: 		// Here, we are talking about column c as in "select c"
0: 		if (expression.getTableName() == null) {
1: 			fromList.isJoinColumnForRightOuterJoin(this);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1:   		if (isRightOuterJoinUsingClause()) {
1:   			newResultColumn.setRightOuterJoinUsingClause(true);
1:   		}
1: 
1:   		if (getJoinResultSet() != null) {
1:   	  		newResultColumn.setJoinResultset(getJoinResultSet());
1:   		}
1:   		
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 					if(formatId == StoredFormatIds.VARCHAR_TYPE_ID)
1: 						return dvf.getVarcharDataValue(sourceValue);
/////////////////////////////////////////////////////////////////////////
1: 						if (formatId == StoredFormatIds.VARCHAR_TYPE_ID)
/////////////////////////////////////////////////////////////////////////
1: 				if (formatId == StoredFormatIds.VARCHAR_TYPE_ID)
1: 					return dvf.getVarcharDataValue(sourceValue.substring(0, maxWidth));
commit:89a444e
/////////////////////////////////////////////////////////////////////////
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the compilation schema
0: 				expression.setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the current schema
0: 				expression.getTypeServices().setCollationDerivation(
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 				expression.getTypeServices().setCollationType(
0: 						getLanguageConnectionContext().getDefaultSchema()
0: 								.getCollationType());
commit:45f198b
/////////////////////////////////////////////////////////////////////////
1: 					resultColumnType.getMaximumWidth(), 
1: 					oldValue);
/////////////////////////////////////////////////////////////////////////
1: 				//If we are dealing with StringDataValue, then make sure we 
1: 				//have correct collation type and derivaiton set and the value
1: 				//represented by collation is either SQLxxx or CollatorSQLxxx
1: 				//depending on the collation type.
1: 				if (newValue instanceof StringDataValue)
1: 				{
0: 					constant.getTypeServices().setCollationDerivation(
0: 							resultColumnType.getCollationDerivation());
0: 					constant.getTypeServices().setCollationType(
0: 							resultColumnType.getCollationType());
1: 					DataValueFactory dvf = getDataValueFactory();
1: 					newValue = ((StringDataValue)newValue).getValue(dvf.getCharacterCollator(
1: 							constant.getTypeServices().getCollationType()));
1: 					constant.setValue(newValue);
1: 				}
/////////////////////////////////////////////////////////////////////////
1: 	private DataValueDescriptor convertConstant(TypeId toTypeId, int maxWidth,
1: 			DataValueDescriptor constantValue)
commit:68f9f47
/////////////////////////////////////////////////////////////////////////
0: 									getContextManager(), getTypeServices().getCollationType(),
0: 									getTypeServices().getCollationDerivation());
/////////////////////////////////////////////////////////////////////////
1:         	//since we don't know the type of such a constant node, we just
1:         	//use the default values for collation type and derivation.
1:         	//eg insert into table1 values(1,null)
1:         	//When this method is executed for the sql above, we don't know
1:         	//the type of the null at this point.
0:             expression = getNullNode( typeId, getContextManager(),
0:             		StringDataValue.COLLATION_TYPE_UCS_BASIC,
0: 					StringDataValue.COLLATION_DERIVATION_IMPLICIT);
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
0: 		acb.generateNull(mb, getTypeCompiler(), getTypeServices().getCollationType());
author:Army
-------------------------------------------------------------------------------
commit:c723732
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Check whether this ResultColumn immediate expression is a window function 
0: 	 * column or not.
1: 	 *
0: 	 * @return true if RCs expression is a window function column, false if not.
1: 	 */
0: 	public boolean expressionIsWindowFunction() 
1: 	{			
0: 		if (getExpression() instanceof WindowFunctionColumnNode){
1: 			return true;
1: 		}
1: 		return false;
1: 	}
1: 	
1: 	/**
0: 	 * Check whether this ResultColumn is a window function column or not, but 
0: 	 * do not traverse the complete chain of references.
1: 	 *
0: 	 * @return true if RC is a window function column, false if not.
1: 	 */
0: 	public boolean isWindowFunction() 
1: 	{	
0: 		ValueNode expr = getExpression();
1: 		
0: 		if (expr instanceof WindowFunctionColumnNode || 
0: 			(expr instanceof VirtualColumnNode && 
0: 			 expr.getSourceResultColumn().getExpression() instanceof WindowFunctionColumnNode)){
1: 			return true;
1: 		}
1: 		return false;
1: 	}
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1:   		
1:   		if (isGenerated()) {
1:   			newResultColumn.markGenerated();
1:   		}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2e105f0
/////////////////////////////////////////////////////////////////////////
1:  * <P>
1:  * its underlying column is not. In an INSERT or UPDATE the ResultColumn
1:  * will represent the type of the column in the table, the type of
0:  * the underlying expresion will be the type of the source of the
1:  * value to be insert or updated. The method columnTypeAndLengthMatch()
1:  * can be used to detect when normalization is required between
0:  * the expression and the tyoe of ResultColumn. This class does
1:  * not implement any type normalization (conversion), this is
1:  * typically handled by a NormalizeResultSetNode.
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:                     constant.setCollationInfo(resultColumnType);
1:                     
commit:d1fbe3c
/////////////////////////////////////////////////////////////////////////
0: 		expression = getNullNode(getTypeServices());
/////////////////////////////////////////////////////////////////////////
0:             expression = getNullNode(bindingRC.getTypeServices());
commit:ed82406
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.StringDataValue;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
0: 			setType(coldes.getType());
/////////////////////////////////////////////////////////////////////////
1: 		return getTypeServices();
/////////////////////////////////////////////////////////////////////////
1: 				"type: " + getTypeServices() + "\n" +
/////////////////////////////////////////////////////////////////////////
1:         checkStorableExpression((ValueNode) toStore);
1:     
1:     private void checkStorableExpression(ValueNode source)
1:         throws StandardException
1:     {
1:         TypeId toStoreTypeId = source.getTypeId();
1:         
1:         if (!getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
1:         {
1:            throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
1:                     getTypeId().getSQLTypeName(),
1:                     toStoreTypeId.getSQLTypeName() );
1:         }   
1:     }
/////////////////////////////////////////////////////////////////////////
1:         checkStorableExpression(getExpression());
/////////////////////////////////////////////////////////////////////////
1: 		if (getExpression().requiresTypeFromContext())
1: 		if (getTypeId().isXMLTypeId())
1:         
1:         
1:         DataTypeDescriptor  expressionType = getExpression().getTypeServices();
1:         
0:         if (expressionType == null)
0:             System.out.println(getExpression().getClass());
1:         
1:         if (!getTypeServices().isExactTypeAndLengthMatch(expressionType))
1:             return false;
1: 		if ((! getTypeServices().isNullable()) && expressionType.isNullable())
/////////////////////////////////////////////////////////////////////////
1:         DataTypeDescriptor resultColumnType = getTypeServices();
1:         DataTypeDescriptor otherResultColumnType = otherColumn.getTypeServices();
/////////////////////////////////////////////////////////////////////////
1: 		return getTypeServices().getTypeId()
1: 			.getApproximateLengthInBytes(getTypeServices());
1:     
1:     public DataTypeDescriptor getTypeServices()
1:     {
1:         DataTypeDescriptor type = super.getTypeServices();
1:         if (type != null)
1:             return type;
1:         
1:         if (getExpression() != null)
1:             return getExpression().getTypeServices();
1:         
1:         return null;
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:ba1b7ec
/////////////////////////////////////////////////////////////////////////
1:  * 
1:  * The type of the ResultColumn can differ from its underlying expression,
1:  * for example in certain joins the ResultColumn can be nullable even if
0:  * its underlying column is not.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		TypeId toStoreTypeId = getExpression().getTypeId();
0:                 getTypeId().getSQLTypeName(),
commit:ac12b1f
/////////////////////////////////////////////////////////////////////////
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
commit:01217c2
/////////////////////////////////////////////////////////////////////////
1:   		if (isGroupingColumn()) 
1:   			newResultColumn.markAsGroupingColumn();
1:   		return newResultColumn;
/////////////////////////////////////////////////////////////////////////
1:         
0:         public boolean isGroupingColumn()
1:         {
0:         	return isGroupingColumn;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	public boolean isEquivalent(ValueNode o) throws StandardException 
1: 	{
0:         if (o.getNodeType() == getNodeType()) 
1:         {                
1:         	ResultColumn other = (ResultColumn)o;
0:         	if (expression != null) {
0:         		return expression.isEquivalent(other.expression);
1:         	}
1:         }
1:         return false;
1: 	}
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
1: 		if (isPrivilegeCollectionRequired())
0: 			getCompilerContext().addRequiredColumnPriv( columnDescriptor);
/////////////////////////////////////////////////////////////////////////
1: 	/** 
0: 	 * @see QueryTreeNode#disablePrivilegeCollection
1: 	 */
0: 	public void disablePrivilegeCollection()
1: 	{
0: 		super.disablePrivilegeCollection();
0: 		if (expression != null)
0: 			expression.disablePrivilegeCollection();
1: 	}
1: 
commit:b57ee34
/////////////////////////////////////////////////////////////////////////
1: 	//Used by metadata api ResultSetMetaData.getSchemaName to get a column's table's schema.
0: 	String			sourceSchemaName;
/////////////////////////////////////////////////////////////////////////
0: 	public String getSchemaName() throws StandardException
0: 		if ((columnDescriptor!=null) &&
0: 			(columnDescriptor.getTableDescriptor() != null))
1: 		else
/////////////////////////////////////////////////////////////////////////
0: 		if ((columnDescriptor!=null) &&
0: 			(columnDescriptor.getTableDescriptor() != null))
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultColumnDescriptor#getSourceSchemaName
1: 	 */
1: 	public String getSourceSchemaName()
1: 	{
0: 		return sourceSchemaName;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
0: 		return (expression == null) ?
0: 		if (columnDescriptor!=null)
/////////////////////////////////////////////////////////////////////////
0: 			sourceSchemaName = cr.getSourceSchemaName();
/////////////////////////////////////////////////////////////////////////
1: 	 * Tell whether this column is updatable by a positioned update.
1: 	public boolean updatableByCursor()
commit:c83a399
/////////////////////////////////////////////////////////////////////////
1: 
1:     public TableName getTableNameObject() {
1:         return null;
1:     }
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.ResultColumn
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import java.sql.Types;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A ResultColumn represents a result column in a SELECT, INSERT, or UPDATE
1:  * statement.  In a SELECT statement, the result column just represents an
1:  * expression in a row being returned to the client.  For INSERT and UPDATE
1:  * statements, the result column represents an column in a stored table.
1:  * So, a ResultColumn has to be bound differently depending on the type of
1:  * statement it appears in.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class ResultColumn extends ValueNode 
0: 				implements ResultColumnDescriptor, Comparable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* name and exposedName should point to the same string, unless there is a
0: 	 * derived column list, in which case name will point to the underlying name
0: 	 * and exposedName will point to the name from the derived column list.
1: 	 */
0: 	String			name;
0: 	String			exposedName;
0: 	String			tableName;
0: 	String			sourceTableName;
0: 	ValueNode		expression;
0: 	ColumnDescriptor	columnDescriptor;
0: 	boolean			isGenerated;
0: 	boolean			isGeneratedForUnmatchedColumnInInsert;
0: 	boolean			isGroupingColumn;
0: 	boolean			isReferenced;
0: 	boolean			isRedundant;
0: 	boolean			isNameGenerated;
0: 	boolean			updated;
0: 	boolean			updatableByCursor;
1: 	private boolean defaultColumn;
1: 
1: 	// tells us if this ResultColumn is a placeholder for a generated
1: 	// autoincrement value for an insert statement.
0: 	boolean			autoincrementGenerated;
1: 
1: 	// tells us if this ResultColumn represents an autoincrement column in a
1: 	// base table.
0: 	boolean 		autoincrement;
1: 
1: 	/* ResultSetNumber for the ResultSet (at generate() time) that we belong to */
1: 	private int		resultSetNumber = -1;
0: 	ColumnReference reference; // used to verify quals at bind time, if given.
1: 
1: 	/* virtualColumnId is the ResultColumn's position (1-based) within the ResultSet */
1: 	private int		virtualColumnId;
1: 
1: 	/**
0: 	 * Different types of initializer parameters indicate different
0: 	 * types of initialization.
1: 	 *
0: 	 * @param arg1	The name of the column, if any.
0: 	 * @param arg2	The expression this result column represents
1: 	 *
0: 	 * - OR -
1: 	 *
0: 	 * @param arg1	a column reference node
0: 	 * @param arg2	The expression this result column represents
1: 	 *
0: 	 * - OR -
1: 	 *
0: 	 * @param arg1	The column descriptor.
0: 	 * @param arg2	The expression this result column represents
1: 	 *
0: 	 * - OR -
1: 	 *
0: 	 * @param dtd			The type of the column
0: 	 * @param expression	The expression this result column represents
1: 	 *
0: 	 * @return	The newly initialized ResultColumn
1: 	 */
0: 	public void init(Object arg1, Object arg2)
1: 	{
0: 		// RESOLVE: This is something of a hack - it is not obvious that
0: 		// the first argument being null means it should be treated as
0: 		// a String.
0: 		if ((arg1 instanceof String) || (arg1 == null))
1: 		{
0: 			this.name = (String) arg1;
0: 			this.exposedName = this.name;
0: 			this.expression = (ValueNode) arg2;
1: 		}
0: 		else if (arg1 instanceof ColumnReference)
1: 		{
0: 			ColumnReference ref = (ColumnReference) arg1;
1: 
0: 			this.name = ref.getColumnName();
0: 			this.exposedName = ref.getColumnName();
1: 			/*
0: 				when we bind, we'll want to make sure
0: 				the reference has the right table name.
1: 		 	*/
0: 			this.reference = ref; 
0: 			this.expression = (ValueNode) arg2;
1: 		}
0: 		else if (arg1 instanceof ColumnDescriptor)
1: 		{
0: 			ColumnDescriptor coldes = (ColumnDescriptor) arg1;
0: 			DataTypeDescriptor colType = coldes.getType();
1: 
0: 			this.name = coldes.getColumnName();
0: 			this.exposedName = name;
0: 			/* Clone the type info here, so we can change nullability if needed */
0: 			setType(new DataTypeDescriptor(colType, colType.isNullable()));
0: 			this.columnDescriptor = coldes;
0: 			this.expression = (ValueNode) arg2;
0: 			this.autoincrement = coldes.isAutoincrement();
1: 		}
1: 		else
1: 		{
0: 			setType((DataTypeDescriptor) arg1);
0: 			this.expression = (ValueNode) arg2;
0: 			if (arg2 instanceof ColumnReference)
1: 			{
0: 				reference = (ColumnReference) arg2;
1: 			}
1: 		}
1: 		
0: 		/* this result column represents a <default> keyword in an insert or
0: 		 * update statement
1: 		 */
0: 		if (expression != null &&
0: 			expression.isInstanceOf(C_NodeTypes.DEFAULT_NODE))
0: 			defaultColumn = true;
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the ResultColumn is standing in for a DEFAULT keyword in
1: 	 * an insert/update statement.
1: 	 */
0: 	public boolean isDefaultColumn()
1: 	{
1: 		return defaultColumn;
1: 	}
1: 
0: 	public void setDefaultColumn(boolean value)
1: 	{
1: 		defaultColumn = value;
1: 	}
1: 
1: 	/**
1: 	 * The following methods implement the ResultColumnDescriptor
1: 	 * interface.  See the Language Module Interface for details.
1: 	 */
1: 
1: 	public String getName()
1: 	{
0: 		return exposedName;
1: 	}
1: 
0: 	public String getSchemaName()
1: 	{
0: 		if ((columnDescriptor!=null) && 
0: 			(columnDescriptor.getTableDescriptor() != null)) 
0: 			return columnDescriptor.getTableDescriptor().getSchemaName();
1: 		else 
1: 		{
0: 			if (expression != null)
1: 			// REMIND: could look in reference, if set.
0: 				return expression.getSchemaName();
1: 			else
1: 				return null;
1: 		}
1: 	}
1: 
0: 	public String getTableName()
1: 	{
0: 		if (tableName != null)
1: 		{
0: 			return tableName;
1: 		}
0: 		if ((columnDescriptor!=null) && 
0: 			(columnDescriptor.getTableDescriptor() != null)) 
1: 		{
0: 			return columnDescriptor.getTableDescriptor().getName();
1: 		}
1: 		else
1: 		{
0: 			return expression.getTableName();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see ResultColumnDescriptor#getSourceTableName
1: 	 */
1: 	public String getSourceTableName()
1: 	{
0: 		return sourceTableName;
1: 	}
1: 
1: 	/**
1: 	 * Clear the table name for the underlying ColumnReference.
0: 	 * See UpdateNode for full explaination.
1: 	 */
0: 	public void clearTableName()
1: 	{
0: 		if (expression instanceof ColumnReference)
1: 		{
0: 			((ColumnReference) expression).setTableNameNode((TableName) null);
1: 		}
1: 	}
1: 
1: 	public DataTypeDescriptor getType()
1: 	{
0: 		return dataTypeServices;
1: 	}
1: 
0: 	public DataTypeDescriptor getExpressionType()
1: 	{
0: 		return (expression == null) ? 
0: 			dataTypeServices :
0: 			expression.getTypeServices();
1: 	}
1: 
1: 	public int getColumnPosition()
1: 	{
0: 		if (columnDescriptor!=null) 
0: 			return columnDescriptor.getPosition();
1: 		else
1: 			return virtualColumnId;
1: 
1: 	}
1: 
1: 	/**
1: 	 * Set the expression in this ResultColumn.  This is useful in those
1: 	 * cases where you don't know the expression in advance, like for
1: 	 * INSERT statements with column lists, where the column list and
1: 	 * SELECT or VALUES clause are parsed separately, and then have to
1: 	 * be hooked up.
1: 	 *
1: 	 * @param expression	The expression to be set in this ResultColumn
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setExpression(ValueNode expression)
1: 	{
0: 		this.expression = expression;
1: 	}
1: 
1: 	/**
1: 	 * Get the expression in this ResultColumn.  
1: 	 *
1: 	 * @return ValueNode	this.expression
1: 	 */
1: 
0: 	public ValueNode getExpression()
1: 	{
0: 		return expression;
1: 	}
1: 
1: 	/**
1: 	 * Set the expression to a null node of the
1: 	 * correct type.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void setExpressionToNullNode()
1: 		throws StandardException
1: 	{
0: 		expression = getNullNode(getTypeId(), 
0: 									getContextManager());
1: 	}
1: 
1: 	/**
1: 	 * Set the name in this ResultColumn.  This is useful when you don't
1: 	 * know the name at the time you create the ResultColumn, for example,
1: 	 * in an insert-select statement, where you want the names of the
1: 	 * result columns to match the table being inserted into, not the
1: 	 * table they came from.
1: 	 *
1: 	 * @param name	The name to set in this ResultColumn
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void setName(String name)
1: 	{
0: 		if (this.name == null)
1: 		{
0: 			this.name = name;
1: 		}
1: 		else {
1: 			if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(reference == null || 
0: 				name.equals(reference.getColumnName()), 
1: 				"don't change name from reference name");
1: 		}
1: 
0: 		this.exposedName = name;
1: 	}
1: 
1: 	/**
1: 	 * Is the name for this ResultColumn generated?
1: 	 */
0: 	public boolean isNameGenerated()
1: 	{
0: 		return isNameGenerated;
1: 	}
1: 
1: 	/**
1: 	 * Set that this result column name is generated.
1: 	 */
0: 	public void setNameGenerated(boolean value)
1: 	{
0: 		isNameGenerated = value;
1: 	}
1: 
1: 	/**
1: 	 * Set the resultSetNumber for this ResultColumn.  This is the 
1: 	 * resultSetNumber for the ResultSet that we belong to.  This
1: 	 * is useful for generate() and necessary since we do not have a
1: 	 * back pointer to the RSN.
1: 	 *
1: 	 * @param resultSetNumber	The resultSetNumber.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setResultSetNumber(int resultSetNumber)
1: 	{
1: 		this.resultSetNumber = resultSetNumber;
1: 	}
1: 
1: 	/**
1: 	 * Get the resultSetNumber for this ResultColumn.
1: 	 *
1: 	 * @return int	The resultSetNumber.
1: 	 */
1: 	public int getResultSetNumber()
1: 	{
1: 		return resultSetNumber;
1: 	}
1: 
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
0: 		/* expression will be null for AllResultColumn */
0: 		if (expression != null)
1: 		{
0: 			expression.setClause(clause);
1: 		}
0: 		else if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(this instanceof AllResultColumn,
0: 				"this expected to be instanceof AllResultColumn when expression is null");
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Adjust the virtualColumnId for this ResultColumn	by the specified amount
1: 	 * 
1: 	 * @param adjust	The adjustment for the virtualColumnId
1: 	 *
0: 	 * @return Nothing
1: 	 */
1: 
0: 	public void adjustVirtualColumnId(int adjust)
1: 	{
1: 		virtualColumnId += adjust;
1: 	}
1: 
1: 	/** 
1: 	 * Set the virtualColumnId for this ResultColumn
1: 	 * 
1: 	 * @param id	The virtualColumnId for this ResultColumn
1: 	 *
0: 	 * @return Nothing
1: 	 */
1: 
0: 	public void setVirtualColumnId(int id)
1: 	{
1: 		virtualColumnId = id;
1: 	}
1: 
1: 	/**
1: 	 * Get the virtualColumnId for this ResultColumn
1: 	 *
1: 	 * @return virtualColumnId for this ResultColumn
1: 	 */
0: 	public int getVirtualColumnId()
1: 	{
1: 		return virtualColumnId;
1: 	}
1: 
1: 	/**
1: 	 * Generate a unique (across the entire statement) column name for unnamed
1: 	 * ResultColumns
1: 	 *
0: 	 * @return None.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void guaranteeColumnName() throws StandardException
1: 	{
0: 		if (exposedName == null)
1: 		{
1: 			/* Unions may also need generated names, if both sides name don't match */
0: 			exposedName ="SQLCol" + getCompilerContext().getNextColumnNumber();
0: 			isNameGenerated = true;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "exposedName: " + exposedName + "\n" +
0: 				"name: " + name + "\n" +
0: 				"tableName: " + tableName + "\n" +
0: 				"isNameGenerated: " + isNameGenerated + "\n" +
0: 				"sourceTableName: " + sourceTableName + "\n" +
0: 				"type: " + dataTypeServices + "\n" +
0: 				"columnDescriptor: " + columnDescriptor + "\n" +
0: 				"isGenerated: " + isGenerated + "\n" +
0: 				"isGeneratedForUnmatchedColumnInInsert: " + isGeneratedForUnmatchedColumnInInsert + "\n" +
0: 				"isGroupingColumn: " + isGroupingColumn + "\n" +
0: 				"isReferenced: " + isReferenced + "\n" +
0: 				"isRedundant: " + isRedundant + "\n" +
1: 				"virtualColumnId: " + virtualColumnId + "\n" +
1: 				"resultSetNumber: " + resultSetNumber + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
0: 			if (expression != null)
1: 			{
1: 				printLabel(depth, "expression: ");
0: 				expression.treePrint(depth + 1);
1: 			}
0: 			if (reference != null)
1: 			{
1: 				printLabel(depth, "reference: ");
0: 				reference.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions.
1: 	 * In this case, we figure out what the result type of this result
1: 	 * column is when we call one of the bindResultColumn*() methods.
1: 	 * The reason is that there are different ways of binding the
1: 	 * result columns depending on the statement type, and this is
1: 	 * a standard interface that does not take the statement type as
1: 	 * a parameter.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** Set the type of a parameter to the type of the result column.
1: 		** Don't do it if this result column doesn't have a type yet.
1: 		** This can happen if the parameter is part of a table constructor.
1: 		*/
0: 		if (expression.isParameterNode())
1: 		{
1: 			if (getTypeServices() != null)
1: 			{
0: 				((ParameterNode) expression).setDescriptor(getTypeServices());
1: 			}
1: 		}
1: 
0: 		expression = expression.bindExpression(fromList, subqueryList,
0: 									aggregateVector);
1: 
0: 		if (expression instanceof ColumnReference)
1: 		{
0: 			autoincrement = ((ColumnReference)expression).getSource().isAutoincrement();
1: 		}
1: 			
1: 
1: 		
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind this result column by ordinal position and set the VirtualColumnId.  
1: 	 * This is useful for INSERT statements like "insert into t values (1, 2, 3)", 
1: 	 * where the user did not specify a column list.
1: 	 * If a columnDescriptor is not found for a given position, then
1: 	 * the user has specified more values than the # of columns in
1: 	 * the table and an exception is thrown.
1: 	 *
1: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
1: 	 * construct the ResultColumnList in the usual way.
1: 	 *
1: 	 * @param tableDescriptor	The descriptor for the table being
1: 	 *				inserted into
1: 	 * @param columnId		The ordinal position of the column
1: 	 *						in the table, starting at 1.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	void bindResultColumnByPosition(TableDescriptor tableDescriptor,
1: 					int columnId)
1: 				throws StandardException
1: 	{
0: 		ColumnDescriptor	columnDescriptor;
1: 
0: 		columnDescriptor = tableDescriptor.getColumnDescriptor(columnId);
1: 
0: 		if (columnDescriptor == null)
1: 		{
1: 			String		errorString;
1: 			String		schemaName;
1: 
1: 			errorString = "";
1: 			schemaName = tableDescriptor.getSchemaName();
1: 			if (schemaName != null)
1: 				errorString += schemaName + ".";
1: 			errorString += tableDescriptor.getName();
1: 
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_RESULT_COLUMNS, errorString);
1: 		}
1: 
0: 		setColumnDescriptor(tableDescriptor, columnDescriptor);
1: 		setVirtualColumnId(columnId);
1: 	}
1: 
1: 	/**
1: 	 * Bind this result column by its name and set the VirtualColumnId.  
1: 	 * This is useful for update statements, and for INSERT statements 
1: 	 * like "insert into t (a, b, c) values (1, 2, 3)" where the user 
1: 	 * specified a column list.
1: 	 * An exception is thrown when a columnDescriptor cannot be found for a
1: 	 * given name.  (There is no column with that name.)
1: 	 *
1: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
1: 	 * construct the ResultColumnList in the usual way.
1: 	 *
1: 	 * @param tableDescriptor	The descriptor for the table being
1: 	 *				updated or inserted into
1: 	 * @param columnId		The ordinal position of the column
1: 	 *						in the table, starting at 1. (Used to
1: 	 *						set the VirtualColumnId.)
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindResultColumnByName(TableDescriptor tableDescriptor,
1: 					int columnId)
1: 				throws StandardException
1: 	{
0: 		ColumnDescriptor	columnDescriptor;
1: 
0: 		columnDescriptor = tableDescriptor.getColumnDescriptor(exposedName);
1: 
0: 		if (columnDescriptor == null)
1: 		{
1: 			String		errorString;
1: 			String		schemaName;
1: 
1: 			errorString = "";
1: 			schemaName = tableDescriptor.getSchemaName();
1: 			if (schemaName != null)
1: 				errorString += schemaName + ".";
1: 			errorString += tableDescriptor.getName();
1: 
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, exposedName, errorString);
1: 		}
1: 
0: 		setColumnDescriptor(tableDescriptor, columnDescriptor);
1: 		setVirtualColumnId(columnId);
1: 	}
1: 	
1: 	/**
1: 	 * Change an untyped null to a typed null.
1: 	 *
0: 	 * @param typeId	The type of the null.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void typeUntypedNullExpression( ResultColumn bindingRC)
1: 			throws StandardException
1: 	{
1:         TypeId typeId = bindingRC.getTypeId();
1: 		/* This is where we catch null in a VALUES clause outside
1: 		 * of INSERT VALUES()
1: 		 */
1: 		if (typeId == null)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NULL_IN_VALUES_CLAUSE);
1: 		}
1: 
0:         if( expression instanceof UntypedNullConstantNode)
0:             expression = getNullNode( typeId, getContextManager());
0:         else if( ( expression instanceof ColumnReference) && expression.getTypeServices() == null)
1:         {
1:             // The expression must be a reference to a null column in a values table.
0:             expression.setType( bindingRC.getType());
1:         }
1: 	}
1: 
1: 	/**
1: 	 * Set the column descriptor for this result column.  It also gets
1: 	 * the data type services from the column descriptor and stores it in
1: 	 * this result column: this is redundant, but we have to store the result
1: 	 * type here for SELECT statements, and it is more orthogonal if the type
1: 	 * can be found here regardless of what type of statement it is.
1: 	 *
1: 	 * @param tableDescriptor	The TableDescriptor for the table
1: 	 *				being updated or inserted into.
1: 	 *				This parameter is used only for
1: 	 *				error reporting.
1: 	 * @param columnDescriptor	The ColumnDescriptor to set in
1: 	 *				this ResultColumn.
1: 	 *
0: 	 * @return	Nothing
1: 	 * @exception StandardException tableNameMismatch
1: 	 */
1: 	void setColumnDescriptor(TableDescriptor tableDescriptor,
1: 				ColumnDescriptor columnDescriptor) throws StandardException
1: 	{
0: 		/* Callers are responsible for verifying that the column exists */
1: 		if (SanityManager.DEBUG)
0: 	    SanityManager.ASSERT(columnDescriptor != null,
0: 					"Caller is responsible for verifying that column exists");
1: 
0: 		setType(columnDescriptor.getType());
0: 		this.columnDescriptor = columnDescriptor;
1: 
1: 		/*
1: 			If the node was created using a reference, the table name
1: 			of the reference must agree with that of the tabledescriptor.
1: 		 */
0: 		if (reference != null && reference.getTableName() != null) 
1: 		{
0: 			if (! tableDescriptor.getName().equals(
0: 					reference.getTableName()) ) 
1: 			{
1: 				/* REMIND: need to have schema name comparison someday as well...
1: 				** left out for now, lots of null checking needed...
1: 				** || ! tableDescriptor.getSchemaName().equals(
0: 				**	reference.getTableNameNode().getSchemaName())) {
1: 				*/
1: 				String realName = tableDescriptor.getName();
0: 				String refName = reference.getTableName();
1: 				throw StandardException.newException(SQLState.LANG_TABLE_NAME_MISMATCH, 
1: 					realName, refName);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the result column to the expression that lives under it.
1: 	 * All this does is copy the datatype information to this node.
1: 	 * This is useful for SELECT statements, where the result type
1: 	 * of each column is the type of the column's expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindResultColumnToExpression()
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** This gets the same DataTypeServices object as
1: 		** is used in the expression.  It is probably not
1: 		** necessary to clone the object here.
1: 		*/
0: 		setType(expression.getTypeServices());
1: 
0: 		if (expression instanceof ColumnReference)
1: 		{
0: 			ColumnReference cr = (ColumnReference) expression;
0: 			tableName = cr.getTableName();
0: 			sourceTableName = cr.getSourceTableName();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return		The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
0: 		if (expression == null)
1: 			return this;
0: 		expression = expression.preprocess(numTables, outerFromList,
1: 										   outerSubqueryList,
0: 										   outerPredicateList);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 		This verifies that the expression is storable into the result column.
1: 		It checks versus the given ResultColumn.
1: 
1: 		This method should not be called until the result column and
1: 		expression both have a valid type, i.e. after they are bound
1: 		appropriately. Its use is for statements like insert, that need to
1: 		verify if a given value can be stored into a column.
1: 
1: 		@exception StandardException thrown if types not suitable.
1: 	 */
0: 	public void checkStorableExpression(ResultColumn toStore)
1: 					throws StandardException
1: 	{
0: 		TypeId columnTypeId, toStoreTypeId;
1: 
0: 		toStoreTypeId = toStore.getTypeId();
0:         if( toStoreTypeId == null)
1:             return;
1:         
0: 		columnTypeId = getTypeId();
1: 
0: 		if (! getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
0: 			throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 				columnTypeId.getSQLTypeName(),
0: 				toStoreTypeId.getSQLTypeName() );
1: 	}
1: 
1: 	/**
1: 		This verifies that the expression is storable into the result column.
1: 		It checks versus the expression under this ResultColumn.
1: 
1: 		This method should not be called until the result column and
1: 		expression both have a valid type, i.e. after they are bound
1: 		appropriately. Its use is for statements like update, that need to
1: 		verify if a given value can be stored into a column.
1: 
1: 		@exception StandardException thrown if types not suitable.
1: 	 */
0: 	public void checkStorableExpression()
1: 					throws StandardException
1: 	{
0: 		TypeId columnTypeId = getTypeId();
0: 		TypeId toStoreTypeId = getExpressionType().getTypeId();
1: 
0: 		if (! getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
0: 			throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 				columnTypeId.getSQLTypeName(),
0: 				toStoreTypeId.getSQLTypeName() );
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for a result column.  This consists of doing the code
1: 	 * generation for the underlying expression.
1: 	 *
1: 	 * @param ecb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder ecb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
0: 		expression.generateExpression(ecb, mb);
1: 	}
1: 
1: 	/**
1: 	 * Do code generation to return a Null of the appropriate type
1: 	 * for the result column.  
1: 	   Requires the getCOlumnExpress value pushed onto the stack
1: 	 *
1: 	 * @param acb		The ActivationClassBuilder for the class we're generating
1: 	 * @param eb		The ExpressionBlock that the generate code is to go into
1: 	 * @param getColumnExpression "fieldx.getColumn(y)"
1: 	 *
0: 	 * @return	An Expression representing a Null for the result
0: 	 *			column.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: /*PUSHCOMPILE
0: 	public void generateNulls(ExpressionClassBuilder acb,
1: 									MethodBuilder mb,
1: 									Expression getColumnExpress) 
1: 			throws StandardException
1: 	{
1: 
1: 		acb.pushDataValueFactory(mb);
1: 		getTypeCompiler().generateNull(mb, acb.getBaseClassName());
1: 
1: 		
1: 		mb.cast(ClassName.DataValueDescriptor);
1: 
1: 
1: 		return eb.newCastExpression(
1: 					ClassName.DataValueDescriptor, 
1: 					getTypeCompiler().
1: 						generateNull(
1: 									eb,
1: 									acb.getBaseClassName(),
1: 									acb.getDataValueFactory(eb),
1: 									getColumnExpress));
1: 	}
1: */
1: 	/**
0: 		Generate the code to create a column the same shape and
0: 		size as this ResultColumn.
1: 
0: 		Used in ResultColumnList.generateHolder().
1: 
0: 		@exception StandardException  thrown on failure
1: 	*/
0: 	public void generateHolder(ExpressionClassBuilder acb,
0: 									MethodBuilder mb)
1: 		throws StandardException
1: 	{
0: 		// generate expression of the form
0: 		// (DataValueDescriptor) columnSpace
1: 
0: 		acb.generateNull(mb, getTypeCompiler());
0: 		mb.upCast(ClassName.DataValueDescriptor);
1: 	}
1: 
1: 	/*
1: 	** Check whether the column length and type of this result column
1: 	** match the expression under the columns.  This is useful for
1: 	** INSERT and UPDATE statements.  For SELECT statements this method
1: 	** should always return true.  There is no need to call this for a
1: 	** DELETE statement.
1: 	**
1: 	** @return	true means the column matches its expressions,
1: 	**			false means it doesn't match.
1: 	*/
1: 
1: 	boolean columnTypeAndLengthMatch()
1: 		throws StandardException
1: 	{
0: 		DataTypeDescriptor	resultColumnType;
0: 		DataTypeDescriptor	expressionType = expression.getTypeServices();
1: 
1: 		/*
1: 		** We can never make any assumptions about
1: 		** parameters.  So don't even bother in this
1: 		** case.
1: 		*/
0: 		if (expression.isParameterNode())
1: 		{
1: 			return false;
1: 		}
1: 
0: 		resultColumnType = getType();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (! (resultColumnType != null))
1: 			{
0: 				SanityManager.THROWASSERT("Type is null for column " + 
0: 										  this);
1: 			}
1: 		}
1: 		/* Are they the same type? */
0: 		if ( ! resultColumnType.getTypeId().getSQLTypeName().equals(
0: 			expressionType.getTypeId().getSQLTypeName()
1: 				)
1: 			)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same precision? */
0: 		if (resultColumnType.getPrecision() != expressionType.getPrecision())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same scale? */
0: 		if (resultColumnType.getScale() != expressionType.getScale())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same width? */
0: 		if (resultColumnType.getMaximumWidth() != expressionType.getMaximumWidth())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Is the source nullable and the target non-nullable? */
0: 		if ((! resultColumnType.isNullable()) && expressionType.isNullable())
1: 		{
1: 			return false;
1: 		}
1: 
0: 		return true;
1: 	}
1: 
1: 	boolean columnTypeAndLengthMatch(ResultColumn otherColumn)
1: 		throws StandardException
1: 	{
0: 		DataTypeDescriptor	resultColumnType;
0: 		DataTypeDescriptor	otherResultColumnType;
1: 		ValueNode otherExpression = otherColumn.getExpression();
1: 
0: 		resultColumnType = getType();
1: 		otherResultColumnType = otherColumn.getType();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(resultColumnType != null,
1: 					"Type is null for column " + this);
1: 			SanityManager.ASSERT(otherResultColumnType != null,
1: 					"Type is null for column " + otherColumn);
1: 		}
1: 
1: 		/*
1: 		** We can never make any assumptions about
1: 		** parameters.  So don't even bother in this
1: 		** case.
1: 		*/
0: 		if ((otherExpression != null) && (otherExpression.isParameterNode()) ||
0: 			(expression.isParameterNode()))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same type? */
1: 		if ( ! resultColumnType.getTypeId().equals(
1: 			otherResultColumnType.getTypeId()
1: 				)
1: 			)
1: 		{
1: 			/* If the source is a constant of a different type then
1: 			 * we try to convert that constant to a constant of our
1: 			 * type. (The initial implementation only does the conversion
1: 			 * to string types because the most common problem is a char
1: 			 * constant with a varchar column.)  
1: 			 * NOTE: We do not attempt any conversion here if the source
1: 			 * is a string type and the target is not or vice versa in 
1: 			 * order to avoid problems with implicit varchar conversions.
1: 			 * Anyway, we will check if the "converted" constant has the
1: 			 * same type as the original constant.  If not, then the conversion
1: 			 * happened.  In that case, we will reuse the ConstantNode, for simplicity,
1: 			 * and reset the type to match the desired type.
1: 			 */
1: 			if (otherExpression instanceof ConstantNode)
1: 			{
1: 				ConstantNode constant = (ConstantNode)otherColumn.getExpression();
1: 				DataValueDescriptor oldValue = constant.getValue();
1: 
1: 
1: 				DataValueDescriptor newValue = convertConstant(
1: 					resultColumnType.getTypeId(),
0: 					resultColumnType.getMaximumWidth(), oldValue);
1: 
1: 				if ((oldValue != newValue) &&
1: 					(oldValue instanceof StringDataValue ==
1: 					 newValue instanceof StringDataValue))
1: 				{
1: 					constant.setValue(newValue);
1: 					constant.setType(getTypeServices());
1: 					otherColumn.bindResultColumnToExpression();
1: 					otherResultColumnType = otherColumn.getType();
1: 				}
1: 			}
1: 			if ( ! resultColumnType.getTypeId().equals(
1: 				otherResultColumnType.getTypeId()
1: 					)
1: 				)
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 
1: 		/* Are they the same precision? */
1: 		if (resultColumnType.getPrecision() !=
1: 										otherResultColumnType.getPrecision())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same scale? */
1: 		if (resultColumnType.getScale() != otherResultColumnType.getScale())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Are they the same width? */
1: 		if (resultColumnType.getMaximumWidth() !=
1: 										otherResultColumnType.getMaximumWidth())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/* Is the source nullable and the target non-nullable? 
1: 		 * The source is nullable if it is nullable or if the target is generated
1: 		 * for an unmatched column in an insert with a column list.
1: 		 * This additional check is needed because when we generate any additional
1: 		 * source RCs for an insert with a column list the generated RCs for any 
1: 		 * non-specified columns get the type info from the column.  Thus, 
1: 		 * for t1(non_nullable, nullable)
1: 		 *	insert into t2 (nullable) values 1;
1: 		 * RCType.isNullable() returns false for the generated source RC for 
1: 		 * non_nullable.  In this case, we want to see it as
1: 		 */
1: 		if ((! resultColumnType.isNullable()) &&
1: 					(otherResultColumnType.isNullable() || 
1: 					 otherColumn.isGeneratedForUnmatchedColumnInInsert()))
1: 		{
1: 			return false;
1: 		}
1: 
0: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Is this a generated column?
1: 	 *
1: 	 * @return Boolean - whether or not this column is a generated column.
1: 	 */
0: 	public boolean isGenerated()
1: 	{
0: 		return (isGenerated == true);
1: 	}
1: 
1: 	/**
1: 	 * Is this columm generated for an unmatched column in an insert?
1: 	 *
1: 	 * @return Boolean - whether or not this columm was generated for an unmatched column in an insert.
1: 	 */
0: 	public boolean isGeneratedForUnmatchedColumnInInsert()
1: 	{
0: 		return (isGeneratedForUnmatchedColumnInInsert == true);
1: 	}
1: 
1: 	/**
1: 	 * Mark this a columm as a generated column
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void markGenerated()
1: 	{
0: 		isGenerated = true;
1: 		/* A generated column is a referenced column */
0: 		isReferenced = true;
1: 	}
1: 
1: 	/**
1: 	 * Mark this a columm as generated for an unmatched column in an insert
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void markGeneratedForUnmatchedColumnInInsert()
1: 	{
0: 		isGeneratedForUnmatchedColumnInInsert = true;
1: 		/* A generated column is a referenced column */
0: 		isReferenced = true;
1: 	}
1: 
1: 	/**
1: 	 * Is this a referenced column?
1: 	 *
1: 	 * @return Boolean - whether or not this column is a referenced column.
1: 	 */
0: 	public boolean isReferenced()
1: 	{
0: 		return isReferenced;
1: 	}
1: 
1: 	/**
1: 	 * Mark this column as a referenced column.
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setReferenced()
1: 	{
0: 		isReferenced = true;
1: 	}
1: 
1:     /**
1:      * Mark this column as a referenced column if it is already marked as referenced or if any result column in
1:      * its chain of virtual columns is marked as referenced.
1:      */
1:     void pullVirtualIsReferenced()
1:     {
1:         if( isReferenced())
1:             return;
1:         
0:         for( ValueNode expr = expression; expr != null && (expr instanceof VirtualColumnNode);)
1:         {
1:             VirtualColumnNode vcn = (VirtualColumnNode) expr;
1:             ResultColumn src = vcn.getSourceColumn();
1:             if( src.isReferenced())
1:             {
1:                 setReferenced();
1:                 return;
1:             }
1:             expr = src.getExpression();
1:         }
1:     } // end of pullVirtualIsReferenced
1: 
1: 	/**
1: 	 * Mark this column as an unreferenced column.
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setUnreferenced()
1: 	{
0: 		isReferenced = false;
1: 	}
1: 
1: 	/**
1:  	 * Mark this RC and all RCs in the underlying
1: 	 * RC/VCN chain as referenced.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void markAllRCsInChainReferenced()
1: 	{
1: 		setReferenced();
1: 
0: 		ValueNode vn = expression;
1: 
1: 		while (vn instanceof VirtualColumnNode)
1: 		{
1: 			VirtualColumnNode vcn = (VirtualColumnNode) vn;
1: 			ResultColumn rc = vcn.getSourceColumn();
1: 			rc.setReferenced();
1: 			vn = rc.getExpression();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Is this a redundant ResultColumn?
1: 	 *
1: 	 * @return Boolean - whether or not this RC is redundant.
1: 	 */
0: 	public boolean isRedundant()
1: 	{
0: 		return isRedundant;
1: 	}
1: 
1: 	/**
1: 	 * Mark this ResultColumn as redundant.
1: 	 *
0: 	 * @return None.
1: 	 */
0: 	public void setRedundant()
1: 	{
0: 		isRedundant = true;
1: 	}
1: 
1: 	/**
1: 	 * Mark this ResultColumn as a grouping column in the SELECT list
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void markAsGroupingColumn()
1: 	{
0: 		isGroupingColumn = true;
1: 	}
1: 
1: 	/**
0: 	 * Look for and reject ? parameter under this ResultColumn.  This is
1: 	 * called for SELECT statements.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter was found
1: 	 *									directly under this ResultColumn.
1: 	 */
1: 
1: 	void rejectParameter() throws StandardException
1: 	{
0: 		if ((expression != null) && (expression.isParameterNode()))
1: 			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
1: 	}
1: 
1: 	/*
1: 	** The following methods implement the Comparable interface.
1: 	*/
0: 	public int compareTo(Object other)
1: 	{
0: 		ResultColumn otherResultColumn = (ResultColumn) other;
1: 
1: 		return this.getColumnPosition() - otherResultColumn.getColumnPosition();
1: 	}
1: 
1: 	/**
0: 	 * Mark this column as being updated by an update statemment.
1: 	 */
1: 	void markUpdated()
1: 	{
0: 		updated = true;
1: 	}
1: 
1: 	/**
1: 	 * Mark this column as being updatable, so we can make sure it is in the
1: 	 * "for update" list of a positioned update.
1: 	 */
1: 	void markUpdatableByCursor()
1: 	{
0: 		updatableByCursor = true;
1: 	}
1: 
1: 	/**
1: 	 * Tell whether this column is being updated.
1: 	 *
1: 	 * @return	true means this column is being updated.
1: 	 */
1: 	boolean updated()
1: 	{
0: 		return updated;
1: 	}
1: 
1: 	/**
0: 	 * Tell whether this column is updatable bay a positioned update.
1: 	 *
1: 	 * @return	true means this column is updatable
1: 	 */
0: 	boolean updatableByCursor()
1: 	{
0: 		return updatableByCursor;
1: 	}
1: 
1: 	/**
1: 	 * Make a copy of this ResultColumn in a new ResultColumn
1: 	 *
1: 	 * @return	A new ResultColumn with the same contents as this one
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	ResultColumn cloneMe() throws StandardException
1: 	{
1: 		ResultColumn	newResultColumn;
1: 		ValueNode		cloneExpr;
1: 
1: 		/* If expression is a ColumnReference, then we want to 
1: 		 * have the RC's clone have a clone of the ColumnReference
1: 		 * for it's expression.  This is for the special case of
1: 		 * cloning the SELECT list for the HAVING clause in the parser.
1: 		 * The SELECT generated for the HAVING needs its own copy
1: 		 * of the ColumnReferences.
1: 		 */
0: 		if (expression instanceof ColumnReference)
1: 		{
0: 			cloneExpr = ((ColumnReference) expression).getClone();
1: 		}
1: 		else
1: 		{
0: 			cloneExpr = expression;
1: 		}
1: 
1: 		/* If a columnDescriptor exists, then we must propagate it */
0: 		if (columnDescriptor != null)
1: 		{
0: 			newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 													C_NodeTypes.RESULT_COLUMN,
0: 													columnDescriptor,
0: 													expression,
0: 													getContextManager());
1: 			newResultColumn.setExpression(cloneExpr);
1: 		}
1: 		else
1: 		{
1: 
0: 			newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 													C_NodeTypes.RESULT_COLUMN,
0: 													getName(),
0: 													cloneExpr,
0: 													getContextManager());
1: 		}
1: 
1: 		/* Set the VirtualColumnId and name in the new node */
1: 		newResultColumn.setVirtualColumnId(getVirtualColumnId());
1: 
1: 		/* Set the type and name information in the new node */
1: 		newResultColumn.setName(getName());
1: 		newResultColumn.setType(getTypeServices());
1: 		newResultColumn.setNameGenerated(isNameGenerated());
1: 
1: 		/* Set the "is generated for unmatched column in insert" status in the new node
1: 		This if for bug 4194*/
1: 		if (isGeneratedForUnmatchedColumnInInsert())
1: 			newResultColumn.markGeneratedForUnmatchedColumnInInsert();
1: 
1: 		/* Set the "is referenced" status in the new node */
1: 		if (isReferenced())
1: 			newResultColumn.setReferenced();
1: 
1: 		/* Set the "updated" status in the new node */
1: 		if (updated())
1: 			newResultColumn.markUpdated();
1: 
1: 		/* Setthe "updatable by cursor" status in the new node */
1: 		if (updatableByCursor())
1: 			newResultColumn.markUpdatableByCursor();
1: 
1: 		if (isAutoincrementGenerated())
1: 			newResultColumn.setAutoincrementGenerated();
1: 
1:   		if (isAutoincrement())
1:   			newResultColumn.setAutoincrement();
1: 		
0: 		return newResultColumn;
1: 	}
1: 
1: 	/**
1: 	 * Get the maximum size of the column
1: 	 *
1: 	 * @return the max size
1: 	 */
0: 	public int getMaximumColumnSize()
1: 	{
0: 		return dataTypeServices.getTypeId()
0: 			.getApproximateLengthInBytes(dataTypeServices);
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (method calls and non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *		CONSTANT				- constant
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		/*
1: 		** If the expression is VARIANT, then
1: 		** return VARIANT.  Otherwise, we return
1: 		** CONSTANT. For result columns that are 
1: 		** generating autoincrement values, the result
0: 		** is variant-- note that there is no expression
0: 		** associated with an autoincrement column in 
0: 		** an insert statement.
1: 		*/
0: 		int expType = ((expression != null) ?
0: 					   expression.getOrderableVariantType() : 
0: 					   ((isAutoincrementGenerated()) ? 
0: 						Qualifier.VARIANT : Qualifier.CONSTANT));
1: 
1: 		switch (expType)
1: 		{
1: 			case Qualifier.VARIANT: 
1: 					return Qualifier.VARIANT;
1: 
1: 			case Qualifier.SCAN_INVARIANT: 
1: 			case Qualifier.QUERY_INVARIANT: 
1: 					return Qualifier.SCAN_INVARIANT;
1: 
1: 			default:
1: 					return Qualifier.CONSTANT;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 	
0: 		if (expression != null && !v.stopTraversal())
1: 		{
0: 			expression = (ValueNode)expression.accept(v);
1: 		}
0: 		return returnNode;
1: 	}
1: 
1: 	/**
0: 	 * Set the nullability of this ResultColumn.
1: 	 */
0: 	public void setNullability(boolean nullability)
1: 	{
0: 		dataTypeServices.setNullability(nullability);
1: 	}
1: 
1: 	/**
0: 	 * Is this column in this array of strings?
1: 	 *
0: 	 * @param list the array of column names to compare
1: 	 *
0: 	 * @return true/false
1: 	 */
0: 	public boolean foundInList(String[] list)
1: 	{
0: 		return foundString(list, name);
1: 	}
1: 
1: 	/**
1: 	 * Verify that this RC is orderable.
1: 	 *
0: 	 * @return Nothing.
1:      *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void verifyOrderable() throws StandardException
1: 	{
1: 		/*
1: 		 * Do not check to see if we can map user types
1: 		 * to built-in types.  The ability to do so does
1: 		 * not mean that ordering will work.  In fact,
1: 		 * as of version 2.0, ordering does not work on
1: 		 * user types.
1: 		 */
1: 		if (!getTypeId().orderable(getClassFactory()))
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1: 						getTypeId().getSQLTypeName());
1: 		}
1: 	}
1: 
1: 	/**
1: 	  If this ResultColumn is bound to a column in a table
1: 	  get the column descriptor for the column in the table.
1: 	  Otherwise return null.
1: 	  */
0: 	ColumnDescriptor getTableColumnDescriptor() {return columnDescriptor;}
1: 
1: 	/**
1: 	 * Returns true if this result column is a placeholder for a generated
1: 	 * autoincrement value.
1: 	 */
0: 	public boolean isAutoincrementGenerated()
1: 	{
0: 		return autoincrementGenerated;
1: 	}
1: 
0: 	public void setAutoincrementGenerated()
1: 	{
0: 		autoincrementGenerated = true;
1: 	}
1: 
0: 	public void resetAutoincrementGenerated()
1: 	{
0: 		autoincrementGenerated = false;
1: 	}
1: 
1:   	public boolean isAutoincrement()
1:   	{
0: 		return autoincrement;
1:   	}
1: 
0:   	public void setAutoincrement()
1:   	{
0:   		autoincrement = true;
1:   	}
1: 	/**
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	private DataValueDescriptor convertConstant(TypeId toTypeId, int maxWidth, DataValueDescriptor constantValue)
1: 		throws StandardException
1: 	{
1: 		int formatId = toTypeId.getTypeFormatId();
1: 		DataValueFactory dvf = getDataValueFactory();
1: 		switch (formatId)
1: 		{
1: 			default:
1: 			case StoredFormatIds.CHAR_TYPE_ID:
1: 				return constantValue;
1: 
1: 			case StoredFormatIds.VARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
1: 				String sourceValue = constantValue.getString();
1: 				int sourceWidth = sourceValue.length();
1: 				int posn;
1: 
1: 				/*
1: 				** If the input is already the right length, no normalization is
1: 				** necessary - just return the source.
1: 				** 
1: 				*/
1: 
1: 				if (sourceWidth <= maxWidth)
1: 				{
1: 					switch (formatId)
1: 					{
0: 						// For NCHAR we must pad the result, saves on normilization later if all
0: 						// constants are of the correct size
0: 						case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
1: 
0: 							if (sourceWidth < maxWidth)
1: 							{
0: 								StringBuffer stringBuffer = new StringBuffer(sourceValue);
1: 
0: 								int needed = maxWidth - sourceWidth;
0: 								char blankArray[] = new char[needed];
0: 								for (int i = 0; i < needed; i++)
0: 									blankArray[i] = ' ';
0: 								stringBuffer.append(blankArray, 0,
0: 												maxWidth - sourceWidth);
0: 								sourceValue = stringBuffer.toString();
1: 							}
0: 							return dvf.getNationalCharDataValue(sourceValue);
1: 
0: 						case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 							return dvf.getNationalVarcharDataValue(sourceValue);
1: 
1: 						case StoredFormatIds.VARCHAR_TYPE_ID:
0: 							return dvf.getVarcharDataValue(sourceValue);
1: 					}
1: 				}
1: 
1: 				/*
1: 				** Check whether any non-blank characters will be truncated.
1: 				*/
1: 				for (posn = maxWidth; posn < sourceWidth; posn++)
1: 				{
1: 					if (sourceValue.charAt(posn) != ' ')
1: 					{
1: 						String typeName = null;
1: 						switch (formatId)
1: 						{
0: 							case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 								typeName = TypeId.NATIONAL_CHAR_NAME;
0: 								break;
1: 
0: 							case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 								typeName = TypeId.NATIONAL_VARCHAR_NAME;
0: 								break;
1: 
1: 							case StoredFormatIds.VARCHAR_TYPE_ID:
1: 								typeName = TypeId.VARCHAR_NAME;
0: 								break;
1: 						}
1: 						throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, 
1: 													 typeName,
1: 													 StringUtil.formatForPrint(sourceValue), 
1: 													 String.valueOf(maxWidth));
1: 					}
1: 				}
1: 
1: 				switch (formatId)
1: 				{
0: 					case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 						return dvf.getNationalCharDataValue(sourceValue.substring(0, maxWidth));
1: 
0: 					case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 						return dvf.getNationalVarcharDataValue(sourceValue.substring(0, maxWidth));
1: 
1: 					case StoredFormatIds.VARCHAR_TYPE_ID:
0: 						return dvf.getVarcharDataValue(sourceValue.substring(0, maxWidth));
1: 				}
1: 
1: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1: 				//No need to check widths here (unlike varchar), since no max width
1: 				return dvf.getLongvarcharDataValue(constantValue.getString());
1: 
0: 			case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
1: 				//No need to check widths here (unlike varchar), since no max width
0: 				return dvf.getNationalLongvarcharDataValue(constantValue.getString());
1: 
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Get the TypeId from this Node.
1: 	 *
0: 	 * @return	The TypeId from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
1: 	 */
0: 	public TypeId getTypeId()
1: 	{
0:         TypeId t = super.getTypeId();
0:         if( t == null)
1:         {
0:             if( expression != null)
1:             {
0:                 DataTypeDescriptor dtd = getTypeServices();
0:                 if( dtd != null)
0:                     t = dtd.getTypeId();
1:             }
1:         }
0:         return t;
0: 	} // end of getTypeId
1: 
1: 	/**
0: 	 * Get the DataTypeServices from this Node.
1: 	 *
0: 	 * @return	The DataTypeServices from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
1: 	 */
0: 	public DataTypeDescriptor getTypeServices()
1: 	{
0:         DataTypeDescriptor dtd = super.getTypeServices();
0:         if( dtd == null && expression != null)
1:         {
0:             dtd = expression.getTypeServices();
0:             if( dtd != null)
0:                 setType( dtd);
1:         }
0:         return dtd;
0:     } // end of getTypeServices
1: }
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:28ce266
/////////////////////////////////////////////////////////////////////////
1: 		** is variant.
1:         int expType;
1:         if (isAutoincrementGenerated()) {
1:             expType = Qualifier.VARIANT;
0:         } else if (expression != null) {
0:             expType = expression.getOrderableVariantType();
1:         } else {
1:             expType = Qualifier.CONSTANT;
0:         }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b3bf9ca
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * types of initialization. Parameters may be:
0: 	 * <ul>
0: 	 * <li>arg1	The name of the column, if any.</li>
0: 	 * <li>arg2	The expression this result column represents</li>
0: 	 * </ul>
0: 	 * <p>
0: 	 * </p>
0: 	 * <ul>
0: 	 * <li>arg1	a column reference node</li>
0: 	 * <li>arg2	The expression this result column represents</li>
0: 	 * </ul>
0: 	 * <p>
0: 	 * </p>
0: 	 * <ul>
0: 	 * <li>arg1	The column descriptor.</li>
0: 	 * <li>arg2	The expression this result column represents</li>
0: 	 * </ul>
0: 	 * <p>
0: 	 * </p>
0: 	 * <ul>
0: 	 * <li>dtd			The type of the column</li>
0: 	 * <li>expression	The expression this result column represents</li>
0: 	 * </ul>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:444aa52
/////////////////////////////////////////////////////////////////////////
1: 	 * See UpdateNode.scrubResultColumns() for full explaination.
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 	/* Get the wrapped reference if any */
0: 	public	ColumnReference	getReference() { return reference; }
0: 	
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:6718a25
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Search the tree beneath this ResultColumn until we find
1: 	 * the number of the table to which this RC points, and
1: 	 * return that table number.  If we can't determine which
1: 	 * table this RC is for, then return -1.
0: 	 *
1: 	 * There are two places we can find the table number: 1) if
1: 	 * our expression is a ColumnReference, then we can get the
1: 	 * target table number from the ColumnReference and that's
1: 	 * it; 2) if expression is a VirtualColumnNode, then if
1: 	 * the VirtualColumnNode points to a FromBaseTable, we can
1: 	 * get that FBT's table number; otherwise, we walk the
1: 	 * VirtualColumnNode-ResultColumn chain and do a recursive
1: 	 * search.
0: 	 *
1: 	 * @return The number of the table to which this ResultColumn	
1: 	 *  points, or -1 if we can't determine that from where we are.
0: 	 */
0: 	public int getTableNumber()
0: 		throws StandardException
0: 	{
0: 		if (expression instanceof ColumnReference)
0: 			return ((ColumnReference)expression).getTableNumber();
0: 		else if (expression instanceof VirtualColumnNode)
0: 		{
0: 			VirtualColumnNode vcn = (VirtualColumnNode)expression;
0: 
1: 			// If the VCN points to a FromBaseTable, just get that
1: 			// table's number.
1: 			if (vcn.getSourceResultSet() instanceof FromBaseTable)
0: 			{
1: 				return ((FromBaseTable)vcn.getSourceResultSet()).
1: 					getTableNumber();
0: 			}
0: 
1: 			// Else recurse down the VCN.
1: 			return vcn.getSourceColumn().getTableNumber();
0: 		}
0: 
1: 		// We can get here if expression has neither a column
1: 		// reference nor a FromBaseTable beneath it--for example,
1: 		// if it is of type BaseColumnNode. 
1: 		return -1;
0: 	}
0: 
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().addRequiredColumnPriv( columnDescriptor);
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 	public void init(Object arg1, Object arg2) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public DataTypeDescriptor getExpressionType() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 		if (expression.requiresTypeFromContext())
0: 				expression.setType(getTypeServices());
/////////////////////////////////////////////////////////////////////////
0: 		if (expression.requiresTypeFromContext())
/////////////////////////////////////////////////////////////////////////
1: 		if ((otherExpression != null) && (otherExpression.requiresTypeFromContext()) ||
0: 			(expression.requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
1: 	 * Look for and reject ?/-?/+? parameter under this ResultColumn.  This is
1: 	 * @exception StandardException		Thrown if a ?/-?/+? parameter was found
/////////////////////////////////////////////////////////////////////////
0: 		if ((expression != null) && (expression instanceof UnaryOperatorNode) &&
0: 				((UnaryOperatorNode)expression).isUnaryMinusOrPlusWithParameter())
0: 			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
/////////////////////////////////////////////////////////////////////////
0: 	public TypeId getTypeId() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	public DataTypeDescriptor getTypeServices() throws StandardException
commit:abbaf4e
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Get the source BaseColumnNode for this result column. The
1: 	 * BaseColumnNode cannot be found unless the ResultColumn is bound
1: 	 * and is a simple reference to a column in a BaseFromTable.
0: 	 *
1: 	 * @return a BaseColumnNode,
1: 	 *   or null if a BaseColumnNode cannot be found
0: 	 */
0: 	public BaseColumnNode getBaseColumnNode() {
0: 		ValueNode vn = expression;
1: 		while (true) {
1: 			if (vn instanceof ResultColumn) {
0: 				vn = ((ResultColumn) vn).expression;
1: 			} else if (vn instanceof ColumnReference) {
1: 				vn = ((ColumnReference) vn).getSource();
1: 			} else if (vn instanceof VirtualColumnNode) {
1: 				vn = ((VirtualColumnNode) vn).getSourceColumn();
1: 			} else if (vn instanceof BaseColumnNode) {
1: 				return (BaseColumnNode) vn;
1: 			} else {
1: 				return null;
0: 			}
0: 		}
0: 	}
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.sql.Types;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A ResultColumn represents a result column in a SELECT, INSERT, or UPDATE
0:  * statement.  In a SELECT statement, the result column just represents an
0:  * expression in a row being returned to the client.  For INSERT and UPDATE
0:  * statements, the result column represents an column in a stored table.
0:  * So, a ResultColumn has to be bound differently depending on the type of
0:  * statement it appears in.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class ResultColumn extends ValueNode 
0: 				implements ResultColumnDescriptor, Comparable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* name and exposedName should point to the same string, unless there is a
0: 	 * derived column list, in which case name will point to the underlying name
0: 	 * and exposedName will point to the name from the derived column list.
0: 	 */
0: 	String			name;
0: 	String			exposedName;
0: 	String			tableName;
0: 	String			sourceTableName;
0: 	ValueNode		expression;
0: 	ColumnDescriptor	columnDescriptor;
0: 	boolean			isGenerated;
0: 	boolean			isGeneratedForUnmatchedColumnInInsert;
0: 	boolean			isGroupingColumn;
0: 	boolean			isReferenced;
0: 	boolean			isRedundant;
0: 	boolean			isNameGenerated;
0: 	boolean			updated;
0: 	boolean			updatableByCursor;
0: 	private boolean defaultColumn;
0: 
0: 	// tells us if this ResultColumn is a placeholder for a generated
0: 	// autoincrement value for an insert statement.
0: 	boolean			autoincrementGenerated;
0: 
0: 	// tells us if this ResultColumn represents an autoincrement column in a
0: 	// base table.
0: 	boolean 		autoincrement;
0: 
0: 	/* ResultSetNumber for the ResultSet (at generate() time) that we belong to */
0: 	private int		resultSetNumber = -1;
0: 	ColumnReference reference; // used to verify quals at bind time, if given.
0: 
0: 	/* virtualColumnId is the ResultColumn's position (1-based) within the ResultSet */
0: 	private int		virtualColumnId;
0: 
0: 	/**
0: 	 * Different types of initializer parameters indicate different
0: 	 * types of initialization.
0: 	 *
0: 	 * @param arg1	The name of the column, if any.
0: 	 * @param arg2	The expression this result column represents
0: 	 *
0: 	 * - OR -
0: 	 *
0: 	 * @param arg1	a column reference node
0: 	 * @param arg2	The expression this result column represents
0: 	 *
0: 	 * - OR -
0: 	 *
0: 	 * @param arg1	The column descriptor.
0: 	 * @param arg2	The expression this result column represents
0: 	 *
0: 	 * - OR -
0: 	 *
0: 	 * @param dtd			The type of the column
0: 	 * @param expression	The expression this result column represents
0: 	 *
0: 	 * @return	The newly initialized ResultColumn
0: 	 */
0: 	public void init(Object arg1, Object arg2)
0: 	{
0: 		// RESOLVE: This is something of a hack - it is not obvious that
0: 		// the first argument being null means it should be treated as
0: 		// a String.
0: 		if ((arg1 instanceof String) || (arg1 == null))
0: 		{
0: 			this.name = (String) arg1;
0: 			this.exposedName = this.name;
0: 			this.expression = (ValueNode) arg2;
0: 		}
0: 		else if (arg1 instanceof ColumnReference)
0: 		{
0: 			ColumnReference ref = (ColumnReference) arg1;
0: 
0: 			this.name = ref.getColumnName();
0: 			this.exposedName = ref.getColumnName();
0: 			/*
0: 				when we bind, we'll want to make sure
0: 				the reference has the right table name.
0: 		 	*/
0: 			this.reference = ref; 
0: 			this.expression = (ValueNode) arg2;
0: 		}
0: 		else if (arg1 instanceof ColumnDescriptor)
0: 		{
0: 			ColumnDescriptor coldes = (ColumnDescriptor) arg1;
0: 			DataTypeDescriptor colType = coldes.getType();
0: 
0: 			this.name = coldes.getColumnName();
0: 			this.exposedName = name;
0: 			/* Clone the type info here, so we can change nullability if needed */
0: 			setType(new DataTypeDescriptor(colType, colType.isNullable()));
0: 			this.columnDescriptor = coldes;
0: 			this.expression = (ValueNode) arg2;
0: 			this.autoincrement = coldes.isAutoincrement();
0: 		}
0: 		else
0: 		{
0: 			setType((DataTypeDescriptor) arg1);
0: 			this.expression = (ValueNode) arg2;
0: 			if (arg2 instanceof ColumnReference)
0: 			{
0: 				reference = (ColumnReference) arg2;
0: 			}
0: 		}
0: 		
0: 		/* this result column represents a <default> keyword in an insert or
0: 		 * update statement
0: 		 */
0: 		if (expression != null &&
0: 			expression.isInstanceOf(C_NodeTypes.DEFAULT_NODE))
0: 			defaultColumn = true;
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if the ResultColumn is standing in for a DEFAULT keyword in
0: 	 * an insert/update statement.
0: 	 */
0: 	public boolean isDefaultColumn()
0: 	{
0: 		return defaultColumn;
0: 	}
0: 
0: 	public void setDefaultColumn(boolean value)
0: 	{
0: 		defaultColumn = value;
0: 	}
0: 
0: 	/**
0: 	 * The following methods implement the ResultColumnDescriptor
0: 	 * interface.  See the Language Module Interface for details.
0: 	 */
0: 
0: 	public String getName()
0: 	{
0: 		return exposedName;
0: 	}
0: 
0: 	public String getSchemaName()
0: 	{
0: 		if ((columnDescriptor!=null) && 
0: 			(columnDescriptor.getTableDescriptor() != null)) 
0: 			return columnDescriptor.getTableDescriptor().getSchemaName();
0: 		else 
0: 		{
0: 			if (expression != null)
0: 			// REMIND: could look in reference, if set.
0: 				return expression.getSchemaName();
0: 			else
0: 				return null;
0: 		}
0: 	}
0: 
0: 	public String getTableName()
0: 	{
0: 		if (tableName != null)
0: 		{
0: 			return tableName;
0: 		}
0: 		if ((columnDescriptor!=null) && 
0: 			(columnDescriptor.getTableDescriptor() != null)) 
0: 		{
0: 			return columnDescriptor.getTableDescriptor().getName();
0: 		}
0: 		else
0: 		{
0: 			return expression.getTableName();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see ResultColumnDescriptor#getSourceTableName
0: 	 */
0: 	public String getSourceTableName()
0: 	{
0: 		return sourceTableName;
0: 	}
0: 
0: 	/**
0: 	 * Clear the table name for the underlying ColumnReference.
0: 	 * See UpdateNode for full explaination.
0: 	 */
0: 	public void clearTableName()
0: 	{
0: 		if (expression instanceof ColumnReference)
0: 		{
0: 			((ColumnReference) expression).setTableNameNode((TableName) null);
0: 		}
0: 	}
0: 
0: 	public DataTypeDescriptor getType()
0: 	{
0: 		return dataTypeServices;
0: 	}
0: 
0: 	public DataTypeDescriptor getExpressionType()
0: 	{
0: 		return (expression == null) ? 
0: 			dataTypeServices :
0: 			expression.getTypeServices();
0: 	}
0: 
0: 	public int getColumnPosition()
0: 	{
0: 		if (columnDescriptor!=null) 
0: 			return columnDescriptor.getPosition();
0: 		else
0: 			return virtualColumnId;
0: 
0: 	}
0: 
0: 	/**
0: 	 * Set the expression in this ResultColumn.  This is useful in those
0: 	 * cases where you don't know the expression in advance, like for
0: 	 * INSERT statements with column lists, where the column list and
0: 	 * SELECT or VALUES clause are parsed separately, and then have to
0: 	 * be hooked up.
0: 	 *
0: 	 * @param expression	The expression to be set in this ResultColumn
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setExpression(ValueNode expression)
0: 	{
0: 		this.expression = expression;
0: 	}
0: 
0: 	/**
0: 	 * Get the expression in this ResultColumn.  
0: 	 *
0: 	 * @return ValueNode	this.expression
0: 	 */
0: 
0: 	public ValueNode getExpression()
0: 	{
0: 		return expression;
0: 	}
0: 
0: 	/**
0: 	 * Set the expression to a null node of the
0: 	 * correct type.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void setExpressionToNullNode()
0: 		throws StandardException
0: 	{
0: 		expression = getNullNode(getTypeId(), 
0: 									getContextManager());
0: 	}
0: 
0: 	/**
0: 	 * Set the name in this ResultColumn.  This is useful when you don't
0: 	 * know the name at the time you create the ResultColumn, for example,
0: 	 * in an insert-select statement, where you want the names of the
0: 	 * result columns to match the table being inserted into, not the
0: 	 * table they came from.
0: 	 *
0: 	 * @param name	The name to set in this ResultColumn
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void setName(String name)
0: 	{
0: 		if (this.name == null)
0: 		{
0: 			this.name = name;
0: 		}
0: 		else {
0: 			if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(reference == null || 
0: 				name.equals(reference.getColumnName()), 
0: 				"don't change name from reference name");
0: 		}
0: 
0: 		this.exposedName = name;
0: 	}
0: 
0: 	/**
0: 	 * Is the name for this ResultColumn generated?
0: 	 */
0: 	public boolean isNameGenerated()
0: 	{
0: 		return isNameGenerated;
0: 	}
0: 
0: 	/**
0: 	 * Set that this result column name is generated.
0: 	 */
0: 	public void setNameGenerated(boolean value)
0: 	{
0: 		isNameGenerated = value;
0: 	}
0: 
0: 	/**
0: 	 * Set the resultSetNumber for this ResultColumn.  This is the 
0: 	 * resultSetNumber for the ResultSet that we belong to.  This
0: 	 * is useful for generate() and necessary since we do not have a
0: 	 * back pointer to the RSN.
0: 	 *
0: 	 * @param resultSetNumber	The resultSetNumber.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setResultSetNumber(int resultSetNumber)
0: 	{
0: 		this.resultSetNumber = resultSetNumber;
0: 	}
0: 
0: 	/**
0: 	 * Get the resultSetNumber for this ResultColumn.
0: 	 *
0: 	 * @return int	The resultSetNumber.
0: 	 */
0: 	public int getResultSetNumber()
0: 	{
0: 		return resultSetNumber;
0: 	}
0: 
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		/* expression will be null for AllResultColumn */
0: 		if (expression != null)
0: 		{
0: 			expression.setClause(clause);
0: 		}
0: 		else if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(this instanceof AllResultColumn,
0: 				"this expected to be instanceof AllResultColumn when expression is null");
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Adjust the virtualColumnId for this ResultColumn	by the specified amount
0: 	 * 
0: 	 * @param adjust	The adjustment for the virtualColumnId
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 
0: 	public void adjustVirtualColumnId(int adjust)
0: 	{
0: 		virtualColumnId += adjust;
0: 	}
0: 
0: 	/** 
0: 	 * Set the virtualColumnId for this ResultColumn
0: 	 * 
0: 	 * @param id	The virtualColumnId for this ResultColumn
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 
0: 	public void setVirtualColumnId(int id)
0: 	{
0: 		virtualColumnId = id;
0: 	}
0: 
0: 	/**
0: 	 * Get the virtualColumnId for this ResultColumn
0: 	 *
0: 	 * @return virtualColumnId for this ResultColumn
0: 	 */
0: 	public int getVirtualColumnId()
0: 	{
0: 		return virtualColumnId;
0: 	}
0: 
0: 	/**
0: 	 * Generate a unique (across the entire statement) column name for unnamed
0: 	 * ResultColumns
0: 	 *
0: 	 * @return None.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void guaranteeColumnName() throws StandardException
0: 	{
0: 		if (exposedName == null)
0: 		{
0: 			/* Unions may also need generated names, if both sides name don't match */
0: 			exposedName ="SQLCol" + getCompilerContext().getNextColumnNumber();
0: 			isNameGenerated = true;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "exposedName: " + exposedName + "\n" +
0: 				"name: " + name + "\n" +
0: 				"tableName: " + tableName + "\n" +
0: 				"isNameGenerated: " + isNameGenerated + "\n" +
0: 				"sourceTableName: " + sourceTableName + "\n" +
0: 				"type: " + dataTypeServices + "\n" +
0: 				"columnDescriptor: " + columnDescriptor + "\n" +
0: 				"isGenerated: " + isGenerated + "\n" +
0: 				"isGeneratedForUnmatchedColumnInInsert: " + isGeneratedForUnmatchedColumnInInsert + "\n" +
0: 				"isGroupingColumn: " + isGroupingColumn + "\n" +
0: 				"isReferenced: " + isReferenced + "\n" +
0: 				"isRedundant: " + isRedundant + "\n" +
0: 				"virtualColumnId: " + virtualColumnId + "\n" +
0: 				"resultSetNumber: " + resultSetNumber + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 			if (expression != null)
0: 			{
0: 				printLabel(depth, "expression: ");
0: 				expression.treePrint(depth + 1);
0: 			}
0: 			if (reference != null)
0: 			{
0: 				printLabel(depth, "reference: ");
0: 				reference.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions.
0: 	 * In this case, we figure out what the result type of this result
0: 	 * column is when we call one of the bindResultColumn*() methods.
0: 	 * The reason is that there are different ways of binding the
0: 	 * result columns depending on the statement type, and this is
0: 	 * a standard interface that does not take the statement type as
0: 	 * a parameter.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 					Vector	aggregateVector)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** Set the type of a parameter to the type of the result column.
0: 		** Don't do it if this result column doesn't have a type yet.
0: 		** This can happen if the parameter is part of a table constructor.
0: 		*/
0: 		if (expression.isParameterNode())
0: 		{
0: 			if (getTypeServices() != null)
0: 			{
0: 				((ParameterNode) expression).setDescriptor(getTypeServices());
0: 			}
0: 		}
0: 
0: 		expression = expression.bindExpression(fromList, subqueryList,
0: 									aggregateVector);
0: 
0: 		if (expression instanceof ColumnReference)
0: 		{
0: 			autoincrement = ((ColumnReference)expression).getSource().isAutoincrement();
0: 		}
0: 			
0: 
0: 		
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind this result column by ordinal position and set the VirtualColumnId.  
0: 	 * This is useful for INSERT statements like "insert into t values (1, 2, 3)", 
0: 	 * where the user did not specify a column list.
0: 	 * If a columnDescriptor is not found for a given position, then
0: 	 * the user has specified more values than the # of columns in
0: 	 * the table and an exception is thrown.
0: 	 *
0: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
0: 	 * construct the ResultColumnList in the usual way.
0: 	 *
0: 	 * @param tableDescriptor	The descriptor for the table being
0: 	 *				inserted into
0: 	 * @param columnId		The ordinal position of the column
0: 	 *						in the table, starting at 1.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	void bindResultColumnByPosition(TableDescriptor tableDescriptor,
0: 					int columnId)
0: 				throws StandardException
0: 	{
0: 		ColumnDescriptor	columnDescriptor;
0: 
0: 		columnDescriptor = tableDescriptor.getColumnDescriptor(columnId);
0: 
0: 		if (columnDescriptor == null)
0: 		{
0: 			String		errorString;
0: 			String		schemaName;
0: 
0: 			errorString = "";
0: 			schemaName = tableDescriptor.getSchemaName();
0: 			if (schemaName != null)
0: 				errorString += schemaName + ".";
0: 			errorString += tableDescriptor.getName();
0: 
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_RESULT_COLUMNS, errorString);
0: 		}
0: 
0: 		setColumnDescriptor(tableDescriptor, columnDescriptor);
0: 		setVirtualColumnId(columnId);
0: 	}
0: 
0: 	/**
0: 	 * Bind this result column by its name and set the VirtualColumnId.  
0: 	 * This is useful for update statements, and for INSERT statements 
0: 	 * like "insert into t (a, b, c) values (1, 2, 3)" where the user 
0: 	 * specified a column list.
0: 	 * An exception is thrown when a columnDescriptor cannot be found for a
0: 	 * given name.  (There is no column with that name.)
0: 	 *
0: 	 * NOTE: We must set the VirtualColumnId here because INSERT does not
0: 	 * construct the ResultColumnList in the usual way.
0: 	 *
0: 	 * @param tableDescriptor	The descriptor for the table being
0: 	 *				updated or inserted into
0: 	 * @param columnId		The ordinal position of the column
0: 	 *						in the table, starting at 1. (Used to
0: 	 *						set the VirtualColumnId.)
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindResultColumnByName(TableDescriptor tableDescriptor,
0: 					int columnId)
0: 				throws StandardException
0: 	{
0: 		ColumnDescriptor	columnDescriptor;
0: 
0: 		columnDescriptor = tableDescriptor.getColumnDescriptor(exposedName);
0: 
0: 		if (columnDescriptor == null)
0: 		{
0: 			String		errorString;
0: 			String		schemaName;
0: 
0: 			errorString = "";
0: 			schemaName = tableDescriptor.getSchemaName();
0: 			if (schemaName != null)
0: 				errorString += schemaName + ".";
0: 			errorString += tableDescriptor.getName();
0: 
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE, exposedName, errorString);
0: 		}
0: 
0: 		setColumnDescriptor(tableDescriptor, columnDescriptor);
0: 		setVirtualColumnId(columnId);
0: 	}
0: 	
0: 	/**
0: 	 * Change an untyped null to a typed null.
0: 	 *
0: 	 * @param typeId	The type of the null.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void typeUntypedNullExpression( ResultColumn bindingRC)
0: 			throws StandardException
0: 	{
0:         TypeId typeId = bindingRC.getTypeId();
0: 		/* This is where we catch null in a VALUES clause outside
0: 		 * of INSERT VALUES()
0: 		 */
0: 		if (typeId == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NULL_IN_VALUES_CLAUSE);
0: 		}
0: 
0:         if( expression instanceof UntypedNullConstantNode)
0:             expression = getNullNode( typeId, getContextManager());
0:         else if( ( expression instanceof ColumnReference) && expression.getTypeServices() == null)
0:         {
0:             // The expression must be a reference to a null column in a values table.
0:             expression.setType( bindingRC.getType());
0:         }
0: 	}
0: 
0: 	/**
0: 	 * Set the column descriptor for this result column.  It also gets
0: 	 * the data type services from the column descriptor and stores it in
0: 	 * this result column: this is redundant, but we have to store the result
0: 	 * type here for SELECT statements, and it is more orthogonal if the type
0: 	 * can be found here regardless of what type of statement it is.
0: 	 *
0: 	 * @param tableDescriptor	The TableDescriptor for the table
0: 	 *				being updated or inserted into.
0: 	 *				This parameter is used only for
0: 	 *				error reporting.
0: 	 * @param columnDescriptor	The ColumnDescriptor to set in
0: 	 *				this ResultColumn.
0: 	 *
0: 	 * @return	Nothing
0: 	 * @exception StandardException tableNameMismatch
0: 	 */
0: 	void setColumnDescriptor(TableDescriptor tableDescriptor,
0: 				ColumnDescriptor columnDescriptor) throws StandardException
0: 	{
0: 		/* Callers are responsible for verifying that the column exists */
0: 		if (SanityManager.DEBUG)
0: 	    SanityManager.ASSERT(columnDescriptor != null,
0: 					"Caller is responsible for verifying that column exists");
0: 
0: 		setType(columnDescriptor.getType());
0: 		this.columnDescriptor = columnDescriptor;
0: 
0: 		/*
0: 			If the node was created using a reference, the table name
0: 			of the reference must agree with that of the tabledescriptor.
0: 		 */
0: 		if (reference != null && reference.getTableName() != null) 
0: 		{
0: 			if (! tableDescriptor.getName().equals(
0: 					reference.getTableName()) ) 
0: 			{
0: 				/* REMIND: need to have schema name comparison someday as well...
0: 				** left out for now, lots of null checking needed...
0: 				** || ! tableDescriptor.getSchemaName().equals(
0: 				**	reference.getTableNameNode().getSchemaName())) {
0: 				*/
0: 				String realName = tableDescriptor.getName();
0: 				String refName = reference.getTableName();
0: 				throw StandardException.newException(SQLState.LANG_TABLE_NAME_MISMATCH, 
0: 					realName, refName);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the result column to the expression that lives under it.
0: 	 * All this does is copy the datatype information to this node.
0: 	 * This is useful for SELECT statements, where the result type
0: 	 * of each column is the type of the column's expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindResultColumnToExpression()
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** This gets the same DataTypeServices object as
0: 		** is used in the expression.  It is probably not
0: 		** necessary to clone the object here.
0: 		*/
0: 		setType(expression.getTypeServices());
0: 
0: 		if (expression instanceof ColumnReference)
0: 		{
0: 			ColumnReference cr = (ColumnReference) expression;
0: 			tableName = cr.getTableName();
0: 			sourceTableName = cr.getSourceTableName();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return		The modified expression
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode preprocess(int numTables,
0: 								FromList outerFromList,
0: 								SubqueryList outerSubqueryList,
0: 								PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		if (expression == null)
0: 			return this;
0: 		expression = expression.preprocess(numTables, outerFromList,
0: 										   outerSubqueryList,
0: 										   outerPredicateList);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 		This verifies that the expression is storable into the result column.
0: 		It checks versus the given ResultColumn.
0: 
0: 		This method should not be called until the result column and
0: 		expression both have a valid type, i.e. after they are bound
0: 		appropriately. Its use is for statements like insert, that need to
0: 		verify if a given value can be stored into a column.
0: 
0: 		@exception StandardException thrown if types not suitable.
0: 	 */
0: 	public void checkStorableExpression(ResultColumn toStore)
0: 					throws StandardException
0: 	{
0: 		TypeId columnTypeId, toStoreTypeId;
0: 
0: 		toStoreTypeId = toStore.getTypeId();
0:         if( toStoreTypeId == null)
0:             return;
0:         
0: 		columnTypeId = getTypeId();
0: 
0: 		if (! getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
0: 			throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 				columnTypeId.getSQLTypeName(),
0: 				toStoreTypeId.getSQLTypeName() );
0: 	}
0: 
0: 	/**
0: 		This verifies that the expression is storable into the result column.
0: 		It checks versus the expression under this ResultColumn.
0: 
0: 		This method should not be called until the result column and
0: 		expression both have a valid type, i.e. after they are bound
0: 		appropriately. Its use is for statements like update, that need to
0: 		verify if a given value can be stored into a column.
0: 
0: 		@exception StandardException thrown if types not suitable.
0: 	 */
0: 	public void checkStorableExpression()
0: 					throws StandardException
0: 	{
0: 		TypeId columnTypeId = getTypeId();
0: 		TypeId toStoreTypeId = getExpressionType().getTypeId();
0: 
0: 		if (! getTypeCompiler().storable(toStoreTypeId, getClassFactory()))
0: 			throw StandardException.newException(SQLState.LANG_NOT_STORABLE, 
0: 				columnTypeId.getSQLTypeName(),
0: 				toStoreTypeId.getSQLTypeName() );
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for a result column.  This consists of doing the code
0: 	 * generation for the underlying expression.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder ecb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		expression.generateExpression(ecb, mb);
0: 	}
0: 
0: 	/**
0: 	 * Do code generation to return a Null of the appropriate type
0: 	 * for the result column.  
0: 	   Requires the getCOlumnExpress value pushed onto the stack
0: 	 *
0: 	 * @param acb		The ActivationClassBuilder for the class we're generating
0: 	 * @param eb		The ExpressionBlock that the generate code is to go into
0: 	 * @param getColumnExpression "fieldx.getColumn(y)"
0: 	 *
0: 	 * @return	An Expression representing a Null for the result
0: 	 *			column.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: /*PUSHCOMPILE
0: 	public void generateNulls(ExpressionClassBuilder acb,
0: 									MethodBuilder mb,
0: 									Expression getColumnExpress) 
0: 			throws StandardException
0: 	{
0: 
0: 		acb.pushDataValueFactory(mb);
0: 		getTypeCompiler().generateNull(mb, acb.getBaseClassName());
0: 
0: 		
0: 		mb.cast(ClassName.DataValueDescriptor);
0: 
0: 
0: 		return eb.newCastExpression(
0: 					ClassName.DataValueDescriptor, 
0: 					getTypeCompiler().
0: 						generateNull(
0: 									eb,
0: 									acb.getBaseClassName(),
0: 									acb.getDataValueFactory(eb),
0: 									getColumnExpress));
0: 	}
0: */
0: 	/**
0: 		Generate the code to create a column the same shape and
0: 		size as this ResultColumn.
0: 
0: 		Used in ResultColumnList.generateHolder().
0: 
0: 		@exception StandardException  thrown on failure
0: 	*/
0: 	public void generateHolder(ExpressionClassBuilder acb,
0: 									MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		// generate expression of the form
0: 		// (DataValueDescriptor) columnSpace
0: 
0: 		acb.generateNull(mb, getTypeCompiler());
0: 		mb.upCast(ClassName.DataValueDescriptor);
0: 	}
0: 
0: 	/*
0: 	** Check whether the column length and type of this result column
0: 	** match the expression under the columns.  This is useful for
0: 	** INSERT and UPDATE statements.  For SELECT statements this method
0: 	** should always return true.  There is no need to call this for a
0: 	** DELETE statement.
0: 	**
0: 	** @return	true means the column matches its expressions,
0: 	**			false means it doesn't match.
0: 	*/
0: 
0: 	boolean columnTypeAndLengthMatch()
0: 		throws StandardException
0: 	{
0: 		DataTypeDescriptor	resultColumnType;
0: 		DataTypeDescriptor	expressionType = expression.getTypeServices();
0: 
0: 		/*
0: 		** We can never make any assumptions about
0: 		** parameters.  So don't even bother in this
0: 		** case.
0: 		*/
0: 		if (expression.isParameterNode())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		resultColumnType = getType();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (! (resultColumnType != null))
0: 			{
0: 				SanityManager.THROWASSERT("Type is null for column " + 
0: 										  this);
0: 			}
0: 		}
0: 		/* Are they the same type? */
0: 		if ( ! resultColumnType.getTypeId().getSQLTypeName().equals(
0: 			expressionType.getTypeId().getSQLTypeName()
0: 				)
0: 			)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same precision? */
0: 		if (resultColumnType.getPrecision() != expressionType.getPrecision())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same scale? */
0: 		if (resultColumnType.getScale() != expressionType.getScale())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same width? */
0: 		if (resultColumnType.getMaximumWidth() != expressionType.getMaximumWidth())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Is the source nullable and the target non-nullable? */
0: 		if ((! resultColumnType.isNullable()) && expressionType.isNullable())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	boolean columnTypeAndLengthMatch(ResultColumn otherColumn)
0: 		throws StandardException
0: 	{
0: 		DataTypeDescriptor	resultColumnType;
0: 		DataTypeDescriptor	otherResultColumnType;
0: 		ValueNode otherExpression = otherColumn.getExpression();
0: 
0: 		resultColumnType = getType();
0: 		otherResultColumnType = otherColumn.getType();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(resultColumnType != null,
0: 					"Type is null for column " + this);
0: 			SanityManager.ASSERT(otherResultColumnType != null,
0: 					"Type is null for column " + otherColumn);
0: 		}
0: 
0: 		/*
0: 		** We can never make any assumptions about
0: 		** parameters.  So don't even bother in this
0: 		** case.
0: 		*/
0: 		if ((otherExpression != null) && (otherExpression.isParameterNode()) ||
0: 			(expression.isParameterNode()))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same type? */
0: 		if ( ! resultColumnType.getTypeId().equals(
0: 			otherResultColumnType.getTypeId()
0: 				)
0: 			)
0: 		{
0: 			/* If the source is a constant of a different type then
0: 			 * we try to convert that constant to a constant of our
0: 			 * type. (The initial implementation only does the conversion
0: 			 * to string types because the most common problem is a char
0: 			 * constant with a varchar column.)  
0: 			 * NOTE: We do not attempt any conversion here if the source
0: 			 * is a string type and the target is not or vice versa in 
0: 			 * order to avoid problems with implicit varchar conversions.
0: 			 * Anyway, we will check if the "converted" constant has the
0: 			 * same type as the original constant.  If not, then the conversion
0: 			 * happened.  In that case, we will reuse the ConstantNode, for simplicity,
0: 			 * and reset the type to match the desired type.
0: 			 */
0: 			if (otherExpression instanceof ConstantNode)
0: 			{
0: 				ConstantNode constant = (ConstantNode)otherColumn.getExpression();
0: 				DataValueDescriptor oldValue = constant.getValue();
0: 
0: 
0: 				DataValueDescriptor newValue = convertConstant(
0: 					resultColumnType.getTypeId(),
0: 					resultColumnType.getMaximumWidth(), oldValue);
0: 
0: 				if ((oldValue != newValue) &&
0: 					(oldValue instanceof StringDataValue ==
0: 					 newValue instanceof StringDataValue))
0: 				{
0: 					constant.setValue(newValue);
0: 					constant.setType(getTypeServices());
0: 					otherColumn.bindResultColumnToExpression();
0: 					otherResultColumnType = otherColumn.getType();
0: 				}
0: 			}
0: 			if ( ! resultColumnType.getTypeId().equals(
0: 				otherResultColumnType.getTypeId()
0: 					)
0: 				)
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 
0: 		/* Are they the same precision? */
0: 		if (resultColumnType.getPrecision() !=
0: 										otherResultColumnType.getPrecision())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same scale? */
0: 		if (resultColumnType.getScale() != otherResultColumnType.getScale())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Are they the same width? */
0: 		if (resultColumnType.getMaximumWidth() !=
0: 										otherResultColumnType.getMaximumWidth())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/* Is the source nullable and the target non-nullable? 
0: 		 * The source is nullable if it is nullable or if the target is generated
0: 		 * for an unmatched column in an insert with a column list.
0: 		 * This additional check is needed because when we generate any additional
0: 		 * source RCs for an insert with a column list the generated RCs for any 
0: 		 * non-specified columns get the type info from the column.  Thus, 
0: 		 * for t1(non_nullable, nullable)
0: 		 *	insert into t2 (nullable) values 1;
0: 		 * RCType.isNullable() returns false for the generated source RC for 
0: 		 * non_nullable.  In this case, we want to see it as
0: 		 */
0: 		if ((! resultColumnType.isNullable()) &&
0: 					(otherResultColumnType.isNullable() || 
0: 					 otherColumn.isGeneratedForUnmatchedColumnInInsert()))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Is this a generated column?
0: 	 *
0: 	 * @return Boolean - whether or not this column is a generated column.
0: 	 */
0: 	public boolean isGenerated()
0: 	{
0: 		return (isGenerated == true);
0: 	}
0: 
0: 	/**
0: 	 * Is this columm generated for an unmatched column in an insert?
0: 	 *
0: 	 * @return Boolean - whether or not this columm was generated for an unmatched column in an insert.
0: 	 */
0: 	public boolean isGeneratedForUnmatchedColumnInInsert()
0: 	{
0: 		return (isGeneratedForUnmatchedColumnInInsert == true);
0: 	}
0: 
0: 	/**
0: 	 * Mark this a columm as a generated column
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void markGenerated()
0: 	{
0: 		isGenerated = true;
0: 		/* A generated column is a referenced column */
0: 		isReferenced = true;
0: 	}
0: 
0: 	/**
0: 	 * Mark this a columm as generated for an unmatched column in an insert
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void markGeneratedForUnmatchedColumnInInsert()
0: 	{
0: 		isGeneratedForUnmatchedColumnInInsert = true;
0: 		/* A generated column is a referenced column */
0: 		isReferenced = true;
0: 	}
0: 
0: 	/**
0: 	 * Is this a referenced column?
0: 	 *
0: 	 * @return Boolean - whether or not this column is a referenced column.
0: 	 */
0: 	public boolean isReferenced()
0: 	{
0: 		return isReferenced;
0: 	}
0: 
0: 	/**
0: 	 * Mark this column as a referenced column.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setReferenced()
0: 	{
0: 		isReferenced = true;
0: 	}
0: 
0:     /**
0:      * Mark this column as a referenced column if it is already marked as referenced or if any result column in
0:      * its chain of virtual columns is marked as referenced.
0:      */
0:     void pullVirtualIsReferenced()
0:     {
0:         if( isReferenced())
0:             return;
0:         
0:         for( ValueNode expr = expression; expr != null && (expr instanceof VirtualColumnNode);)
0:         {
0:             VirtualColumnNode vcn = (VirtualColumnNode) expr;
0:             ResultColumn src = vcn.getSourceColumn();
0:             if( src.isReferenced())
0:             {
0:                 setReferenced();
0:                 return;
0:             }
0:             expr = src.getExpression();
0:         }
0:     } // end of pullVirtualIsReferenced
0: 
0: 	/**
0: 	 * Mark this column as an unreferenced column.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setUnreferenced()
0: 	{
0: 		isReferenced = false;
0: 	}
0: 
0: 	/**
0:  	 * Mark this RC and all RCs in the underlying
0: 	 * RC/VCN chain as referenced.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markAllRCsInChainReferenced()
0: 	{
0: 		setReferenced();
0: 
0: 		ValueNode vn = expression;
0: 
0: 		while (vn instanceof VirtualColumnNode)
0: 		{
0: 			VirtualColumnNode vcn = (VirtualColumnNode) vn;
0: 			ResultColumn rc = vcn.getSourceColumn();
0: 			rc.setReferenced();
0: 			vn = rc.getExpression();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Is this a redundant ResultColumn?
0: 	 *
0: 	 * @return Boolean - whether or not this RC is redundant.
0: 	 */
0: 	public boolean isRedundant()
0: 	{
0: 		return isRedundant;
0: 	}
0: 
0: 	/**
0: 	 * Mark this ResultColumn as redundant.
0: 	 *
0: 	 * @return None.
0: 	 */
0: 	public void setRedundant()
0: 	{
0: 		isRedundant = true;
0: 	}
0: 
0: 	/**
0: 	 * Mark this ResultColumn as a grouping column in the SELECT list
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markAsGroupingColumn()
0: 	{
0: 		isGroupingColumn = true;
0: 	}
0: 
0: 	/**
0: 	 * Look for and reject ? parameter under this ResultColumn.  This is
0: 	 * called for SELECT statements.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter was found
0: 	 *									directly under this ResultColumn.
0: 	 */
0: 
0: 	void rejectParameter() throws StandardException
0: 	{
0: 		if ((expression != null) && (expression.isParameterNode()))
0: 			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
0: 	}
0: 
0: 	/*
0: 	** The following methods implement the Comparable interface.
0: 	*/
0: 	public int compareTo(Object other)
0: 	{
0: 		ResultColumn otherResultColumn = (ResultColumn) other;
0: 
0: 		return this.getColumnPosition() - otherResultColumn.getColumnPosition();
0: 	}
0: 
0: 	/**
0: 	 * Mark this column as being updated by an update statemment.
0: 	 */
0: 	void markUpdated()
0: 	{
0: 		updated = true;
0: 	}
0: 
0: 	/**
0: 	 * Mark this column as being updatable, so we can make sure it is in the
0: 	 * "for update" list of a positioned update.
0: 	 */
0: 	void markUpdatableByCursor()
0: 	{
0: 		updatableByCursor = true;
0: 	}
0: 
0: 	/**
0: 	 * Tell whether this column is being updated.
0: 	 *
0: 	 * @return	true means this column is being updated.
0: 	 */
0: 	boolean updated()
0: 	{
0: 		return updated;
0: 	}
0: 
0: 	/**
0: 	 * Tell whether this column is updatable bay a positioned update.
0: 	 *
0: 	 * @return	true means this column is updatable
0: 	 */
0: 	boolean updatableByCursor()
0: 	{
0: 		return updatableByCursor;
0: 	}
0: 
0: 	/**
0: 	 * Make a copy of this ResultColumn in a new ResultColumn
0: 	 *
0: 	 * @return	A new ResultColumn with the same contents as this one
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	ResultColumn cloneMe() throws StandardException
0: 	{
0: 		ResultColumn	newResultColumn;
0: 		ValueNode		cloneExpr;
0: 
0: 		/* If expression is a ColumnReference, then we want to 
0: 		 * have the RC's clone have a clone of the ColumnReference
0: 		 * for it's expression.  This is for the special case of
0: 		 * cloning the SELECT list for the HAVING clause in the parser.
0: 		 * The SELECT generated for the HAVING needs its own copy
0: 		 * of the ColumnReferences.
0: 		 */
0: 		if (expression instanceof ColumnReference)
0: 		{
0: 			cloneExpr = ((ColumnReference) expression).getClone();
0: 		}
0: 		else
0: 		{
0: 			cloneExpr = expression;
0: 		}
0: 
0: 		/* If a columnDescriptor exists, then we must propagate it */
0: 		if (columnDescriptor != null)
0: 		{
0: 			newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 													C_NodeTypes.RESULT_COLUMN,
0: 													columnDescriptor,
0: 													expression,
0: 													getContextManager());
0: 			newResultColumn.setExpression(cloneExpr);
0: 		}
0: 		else
0: 		{
0: 
0: 			newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 													C_NodeTypes.RESULT_COLUMN,
0: 													getName(),
0: 													cloneExpr,
0: 													getContextManager());
0: 		}
0: 
0: 		/* Set the VirtualColumnId and name in the new node */
0: 		newResultColumn.setVirtualColumnId(getVirtualColumnId());
0: 
0: 		/* Set the type and name information in the new node */
0: 		newResultColumn.setName(getName());
0: 		newResultColumn.setType(getTypeServices());
0: 		newResultColumn.setNameGenerated(isNameGenerated());
0: 
0: 		/* Set the "is generated for unmatched column in insert" status in the new node
0: 		This if for bug 4194*/
0: 		if (isGeneratedForUnmatchedColumnInInsert())
0: 			newResultColumn.markGeneratedForUnmatchedColumnInInsert();
0: 
0: 		/* Set the "is referenced" status in the new node */
0: 		if (isReferenced())
0: 			newResultColumn.setReferenced();
0: 
0: 		/* Set the "updated" status in the new node */
0: 		if (updated())
0: 			newResultColumn.markUpdated();
0: 
0: 		/* Setthe "updatable by cursor" status in the new node */
0: 		if (updatableByCursor())
0: 			newResultColumn.markUpdatableByCursor();
0: 
0: 		if (isAutoincrementGenerated())
0: 			newResultColumn.setAutoincrementGenerated();
0: 
0:   		if (isAutoincrement())
0:   			newResultColumn.setAutoincrement();
0: 		
0: 		return newResultColumn;
0: 	}
0: 
0: 	/**
0: 	 * Get the maximum size of the column
0: 	 *
0: 	 * @return the max size
0: 	 */
0: 	public int getMaximumColumnSize()
0: 	{
0: 		return dataTypeServices.getTypeId()
0: 			.getApproximateLengthInBytes(dataTypeServices);
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (method calls and non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *		CONSTANT				- constant
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		/*
0: 		** If the expression is VARIANT, then
0: 		** return VARIANT.  Otherwise, we return
0: 		** CONSTANT. For result columns that are 
0: 		** generating autoincrement values, the result
0: 		** is variant-- note that there is no expression
0: 		** associated with an autoincrement column in 
0: 		** an insert statement.
0: 		*/
0: 		int expType = ((expression != null) ?
0: 					   expression.getOrderableVariantType() : 
0: 					   ((isAutoincrementGenerated()) ? 
0: 						Qualifier.VARIANT : Qualifier.CONSTANT));
0: 
0: 		switch (expType)
0: 		{
0: 			case Qualifier.VARIANT: 
0: 					return Qualifier.VARIANT;
0: 
0: 			case Qualifier.SCAN_INVARIANT: 
0: 			case Qualifier.QUERY_INVARIANT: 
0: 					return Qualifier.SCAN_INVARIANT;
0: 
0: 			default:
0: 					return Qualifier.CONSTANT;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable returnNode = v.visit(this);
0: 
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 	
0: 		if (expression != null && !v.stopTraversal())
0: 		{
0: 			expression = (ValueNode)expression.accept(v);
0: 		}
0: 		return returnNode;
0: 	}
0: 
0: 	/**
0: 	 * Set the nullability of this ResultColumn.
0: 	 */
0: 	public void setNullability(boolean nullability)
0: 	{
0: 		dataTypeServices.setNullability(nullability);
0: 	}
0: 
0: 	/**
0: 	 * Is this column in this array of strings?
0: 	 *
0: 	 * @param list the array of column names to compare
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean foundInList(String[] list)
0: 	{
0: 		return foundString(list, name);
0: 	}
0: 
0: 	/**
0: 	 * Verify that this RC is orderable.
0: 	 *
0: 	 * @return Nothing.
0:      *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void verifyOrderable() throws StandardException
0: 	{
0: 		/*
0: 		 * Do not check to see if we can map user types
0: 		 * to built-in types.  The ability to do so does
0: 		 * not mean that ordering will work.  In fact,
0: 		 * as of version 2.0, ordering does not work on
0: 		 * user types.
0: 		 */
0: 		if (!getTypeId().orderable(getClassFactory()))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
0: 						getTypeId().getSQLTypeName());
0: 		}
0: 	}
0: 
0: 	/**
0: 	  If this ResultColumn is bound to a column in a table
0: 	  get the column descriptor for the column in the table.
0: 	  Otherwise return null.
0: 	  */
0: 	ColumnDescriptor getTableColumnDescriptor() {return columnDescriptor;}
0: 
0: 	/**
0: 	 * Returns true if this result column is a placeholder for a generated
0: 	 * autoincrement value.
0: 	 */
0: 	public boolean isAutoincrementGenerated()
0: 	{
0: 		return autoincrementGenerated;
0: 	}
0: 
0: 	public void setAutoincrementGenerated()
0: 	{
0: 		autoincrementGenerated = true;
0: 	}
0: 
0: 	public void resetAutoincrementGenerated()
0: 	{
0: 		autoincrementGenerated = false;
0: 	}
0: 
0:   	public boolean isAutoincrement()
0:   	{
0: 		return autoincrement;
0:   	}
0: 
0:   	public void setAutoincrement()
0:   	{
0:   		autoincrement = true;
0:   	}
0: 	/**
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private DataValueDescriptor convertConstant(TypeId toTypeId, int maxWidth, DataValueDescriptor constantValue)
0: 		throws StandardException
0: 	{
0: 		int formatId = toTypeId.getTypeFormatId();
0: 		DataValueFactory dvf = getDataValueFactory();
0: 		switch (formatId)
0: 		{
0: 			default:
0: 			case StoredFormatIds.CHAR_TYPE_ID:
0: 				return constantValue;
0: 
0: 			case StoredFormatIds.VARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 				String sourceValue = constantValue.getString();
0: 				int sourceWidth = sourceValue.length();
0: 				int posn;
0: 
0: 				/*
0: 				** If the input is already the right length, no normalization is
0: 				** necessary - just return the source.
0: 				** 
0: 				*/
0: 
0: 				if (sourceWidth <= maxWidth)
0: 				{
0: 					switch (formatId)
0: 					{
0: 						// For NCHAR we must pad the result, saves on normilization later if all
0: 						// constants are of the correct size
0: 						case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 
0: 							if (sourceWidth < maxWidth)
0: 							{
0: 								StringBuffer stringBuffer = new StringBuffer(sourceValue);
0: 
0: 								int needed = maxWidth - sourceWidth;
0: 								char blankArray[] = new char[needed];
0: 								for (int i = 0; i < needed; i++)
0: 									blankArray[i] = ' ';
0: 								stringBuffer.append(blankArray, 0,
0: 												maxWidth - sourceWidth);
0: 								sourceValue = stringBuffer.toString();
0: 							}
0: 							return dvf.getNationalCharDataValue(sourceValue);
0: 
0: 						case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 							return dvf.getNationalVarcharDataValue(sourceValue);
0: 
0: 						case StoredFormatIds.VARCHAR_TYPE_ID:
0: 							return dvf.getVarcharDataValue(sourceValue);
0: 					}
0: 				}
0: 
0: 				/*
0: 				** Check whether any non-blank characters will be truncated.
0: 				*/
0: 				for (posn = maxWidth; posn < sourceWidth; posn++)
0: 				{
0: 					if (sourceValue.charAt(posn) != ' ')
0: 					{
0: 						String typeName = null;
0: 						switch (formatId)
0: 						{
0: 							case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 								typeName = TypeId.NATIONAL_CHAR_NAME;
0: 								break;
0: 
0: 							case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 								typeName = TypeId.NATIONAL_VARCHAR_NAME;
0: 								break;
0: 
0: 							case StoredFormatIds.VARCHAR_TYPE_ID:
0: 								typeName = TypeId.VARCHAR_NAME;
0: 								break;
0: 						}
0: 						throw StandardException.newException(SQLState.LANG_STRING_TRUNCATION, 
0: 													 typeName,
0: 													 StringUtil.formatForPrint(sourceValue), 
0: 													 String.valueOf(maxWidth));
0: 					}
0: 				}
0: 
0: 				switch (formatId)
0: 				{
0: 					case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 						return dvf.getNationalCharDataValue(sourceValue.substring(0, maxWidth));
0: 
0: 					case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 						return dvf.getNationalVarcharDataValue(sourceValue.substring(0, maxWidth));
0: 
0: 					case StoredFormatIds.VARCHAR_TYPE_ID:
0: 						return dvf.getVarcharDataValue(sourceValue.substring(0, maxWidth));
0: 				}
0: 
0: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0: 				//No need to check widths here (unlike varchar), since no max width
0: 				return dvf.getLongvarcharDataValue(constantValue.getString());
0: 
0: 			case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0: 				//No need to check widths here (unlike varchar), since no max width
0: 				return dvf.getNationalLongvarcharDataValue(constantValue.getString());
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the TypeId from this Node.
0: 	 *
0: 	 * @return	The TypeId from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
0: 	 */
0: 	public TypeId getTypeId()
0: 	{
0:         TypeId t = super.getTypeId();
0:         if( t == null)
0:         {
0:             if( expression != null)
0:             {
0:                 DataTypeDescriptor dtd = getTypeServices();
0:                 if( dtd != null)
0:                     t = dtd.getTypeId();
0:             }
0:         }
0:         return t;
0: 	} // end of getTypeId
0: 
0: 	/**
0: 	 * Get the DataTypeServices from this Node.
0: 	 *
0: 	 * @return	The DataTypeServices from this Node.  This
0: 	 *		may be null if the node isn't bound yet.
0: 	 */
0: 	public DataTypeDescriptor getTypeServices()
0: 	{
0:         DataTypeDescriptor dtd = super.getTypeServices();
0:         if( dtd == null && expression != null)
0:         {
0:             dtd = expression.getTypeServices();
0:             if( dtd != null)
0:                 setType( dtd);
0:         }
0:         return dtd;
0:     } // end of getTypeServices
0: }
============================================================================