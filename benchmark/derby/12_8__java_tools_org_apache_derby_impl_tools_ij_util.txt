1:fe77ca5: /*
1:3b11818: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.ij.util
1:b658373: 
1:11bc2d0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11bc2d0:    contributor license agreements.  See the NOTICE file distributed with
1:11bc2d0:    this work for additional information regarding copyright ownership.
1:11bc2d0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:11bc2d0:    (the "License"); you may not use this file except in compliance with
1:11bc2d0:    the License.  You may obtain a copy of the License at
1:12a6309: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:985fc85: 
1:fe77ca5:  */
1:b658373: 
1:fe77ca5: package org.apache.derby.impl.tools.ij;
1:12a6309: 
1:fe77ca5: import org.apache.derby.tools.JDBCDisplayUtil;
1:fe77ca5: import org.apache.derby.iapi.tools.i18n.*;
1:985fc85: 
1:fe77ca5: import java.io.BufferedInputStream;
1:fe77ca5: import java.io.FileInputStream;
1:fe77ca5: import java.io.InputStream;
1:fe77ca5: import java.io.IOException;
1:6daf45b: import java.lang.reflect.InvocationTargetException;
1:985fc85: 
1:38520af: import java.security.AccessController;
1:38520af: import java.security.PrivilegedAction;
1:fe77ca5: import java.sql.Connection;
1:59f29e4: import java.sql.Driver;
1:fe77ca5: import java.sql.DriverManager;
1:fe77ca5: import java.sql.SQLException;
1:fe77ca5: import java.sql.Statement;
1:fe77ca5: import java.sql.PreparedStatement;
1:fe77ca5: import java.sql.ResultSet;
1:fe77ca5: import java.sql.ResultSetMetaData;
1:fe77ca5: import java.sql.Types;
14:fe77ca5: 
1:fe77ca5: import java.util.Properties;
1:fe77ca5: import java.util.Vector;
1:0bbfdac: import java.util.Locale;
1:59f29e4: import javax.sql.DataSource;
1:fe77ca5: 
1:fe77ca5: /**
1:fe77ca5: 	Methods used to control setup for apps as
1:fe77ca5: 	well as display some internal ij structures.
1:fe77ca5: 
1:fe77ca5: 	@see org.apache.derby.tools.JDBCDisplayUtil
1:fe77ca5:  */
1:16d3334: public final class util implements java.security.PrivilegedAction<String> {
1:fe77ca5: 	
1:fe77ca5: 	private util() {}
1:fe77ca5: 
1:fe77ca5: 	//-----------------------------------------------------------------
1:fe77ca5: 	// Methods for starting up JBMS
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Find the argument that follows the specified parameter.
1:fe77ca5: 	 *
1:fe77ca5: 	 *	@param param the parameter (e.g. "-p")
1:fe77ca5: 	 *	@param args	the argument list to consider.
1:fe77ca5: 	 *
1:fe77ca5: 	 *	@return the argument that follows the parameter, or null if not found
1:fe77ca5: 	 */
1:fe77ca5: 	static public String getArg(String param, String[] args)
1:b658373: 	{
1:fe77ca5: 		int pLocn;
1:fe77ca5: 		Properties p;
1:fe77ca5: 
1:fe77ca5: 		if (args == null) return null;
1:fe77ca5: 
1:fe77ca5: 		for (pLocn=0; pLocn<args.length; pLocn++) {
1:fe77ca5: 			if (param.equals(args[pLocn])) break;
13:fe77ca5: 		}
1:fe77ca5: 		if (pLocn >= (args.length-1))  // not found or no file
4:fe77ca5: 			return null;
1:fe77ca5: 
1:fe77ca5: 		return args[pLocn+1];
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		ij is started with "-p[r] file OtherArgs";
1:fe77ca5: 		the file contains properties to control the driver and database
1:fe77ca5: 		used to run ij, and can provide additional system properties.
3:fe77ca5: 		<p>
1:fe77ca5: 		getPropertyArg will look at the args and take out a "-p <file>" pair,
1:fe77ca5: 		reading the file into the system properties.
1:fe77ca5: 		<p>
1:fe77ca5: 		If there was a -p without a following <file>, no action is taken.
1:fe77ca5: 
2:fe77ca5: 		@exception IOException thrown if file not found
1:fe77ca5: 
2:fe77ca5: 		@param args	the argument list to consider.
1:fe77ca5: 		@return true if a property item was found and loaded.
1:fe77ca5: 	 */
1:fe77ca5: 	static public boolean getPropertyArg(String[] args) throws IOException {
2:fe77ca5: 		String n;
2:fe77ca5: 		InputStream in1;
1:fe77ca5: 		Properties p;
1:fe77ca5: 
1:fe77ca5: 		if ((n = getArg("-p", args))!= null){
2:fe77ca5: 			in1 = new FileInputStream(n);
2:fe77ca5: 			in1 = new BufferedInputStream(in1);
1:fe77ca5: 		}
1:fe77ca5: 		else if ((n = getArg("-pr", args)) != null) {
2:fe77ca5: 			in1 = getResourceAsStream(n);
2:fe77ca5: 			if (in1 == null) throw ijException.resourceNotFound();
1:fe77ca5: 		}
4:fe77ca5: 		else
1:fe77ca5: 			return false;
1:fe77ca5: 
1:fe77ca5: 		p = System.getProperties();
1:fe77ca5: 
2:fe77ca5: 		// Trim off excess whitespace in property file, if any, and
2:fe77ca5: 		// then load those properties into 'p'.
2:fe77ca5: 		util.loadWithTrimmedValues(in1, p);
1:fe77ca5: 
1:fe77ca5: 		return true;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Convenience routine to qualify a resource name with "ij.defaultPackageName"
1:fe77ca5: 	  if it is not qualified (does not begin with a "/").
1:fe77ca5: 
1:fe77ca5: 	  @param absolute true means return null if the name is not absolute and false
1:fe77ca5: 	  means return partial names. 
1:fe77ca5: 	  */
1:fe77ca5: 	static String qualifyResourceName(String resourceName, boolean absolute)
6:fe77ca5: 	{
1:fe77ca5: 		resourceName=resourceName.trim();
1:fe77ca5: 		if (resourceName.startsWith("/"))
1:fe77ca5: 		{
1:fe77ca5: 			return resourceName;
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			String pName = util.getSystemProperty("ij.defaultResourcePackage").trim();
1:fe77ca5: 			if (pName == null) return null;
1:fe77ca5: 			if ((pName).endsWith("/"))
1:fe77ca5: 				resourceName = pName+resourceName;
1:fe77ca5: 			else
1:fe77ca5: 				resourceName = pName+"/"+resourceName;
1:fe77ca5: 			if (absolute && !resourceName.startsWith("/"))
1:fe77ca5: 				return null;
1:fe77ca5: 			else
1:fe77ca5: 				return resourceName;
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 	/**
1:fe77ca5: 	  Convenience routine to get a resource as a BufferedInputStream. If the
1:fe77ca5: 	  resourceName is not absolute (does not begin with a "/") this qualifies
1:fe77ca5: 	  the name with the "ij.defaultResourcePackage" name.
1:fe77ca5: 
1:f0b0870: 	  @param resourceName the name of the resource
1:fe77ca5: 	  @return a buffered stream for the resource if it exists and null otherwise.
1:fe77ca5: 	  */
1:8d64950:     static InputStream getResourceAsStream(String resourceName)
1:fe77ca5: 	{
1:38520af: 		final Class c = util.class;
1:38520af: 		final String resource = qualifyResourceName(resourceName,true);
1:38520af: 		if (resource == null) 
1:fe77ca5: 			return null;
1:16d3334: 		InputStream is = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
1:16d3334:             public InputStream run() { 
1:38520af:                       InputStream locis = 
1:38520af:                           c.getResourceAsStream(resource);
1:38520af:                                   return locis;
1:38520af:             }
1:38520af:         }
1:38520af:      );
1:38520af: 
1:fe77ca5: 		if (is != null) 
1:fe77ca5: 			is = new BufferedInputStream(is, utilMain.BUFFEREDFILESIZE);
1:fe77ca5: 		return is;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Return the name of the ij command file or null if none is
1:fe77ca5: 	  specified. The command file may be proceeded with -f flag on
1:fe77ca5: 	  the command line. Alternatively, the command file may be 
1:fe77ca5: 	  specified without a -f flag. In this case we assume the first
1:fe77ca5: 	  unknown argument is the command file.
1:fe77ca5: 
1:fe77ca5: 	  <P>
1:fe77ca5: 	  This should only be called after calling invalidArgs.
1:fe77ca5: 
1:fe77ca5: 	  <p>
1:fe77ca5: 	  If there is no such argument, a null is returned.
1:fe77ca5: 
1:fe77ca5: 	  @param args	the argument list to consider.
1:fe77ca5: 	  @return the name of the first argument not preceded by "-p",
1:fe77ca5: 	  null if none found.
1:fe77ca5: 	  
1:fe77ca5: 	  @exception IOException thrown if file not found
1:fe77ca5: 	 */
1:fe77ca5: 	static public String getFileArg(String[] args) throws IOException {
1:fe77ca5: 		String fileName;
1:fe77ca5: 		int fLocn;
1:fe77ca5: 		boolean foundP = false;
1:fe77ca5: 
1:fe77ca5: 		if (args == null) return null;
1:fe77ca5: 		if ((fileName=getArg("-f",args))!=null) return fileName;
1:fe77ca5: 		//
1:fe77ca5: 		//The first unknown arg is the file
1:fe77ca5: 		for (int ix=0; ix < args.length; ix++)
1:fe77ca5: 			if(args[ix].equals("-f")  ||
1:fe77ca5: 			   args[ix].equals("-fr") ||
1:fe77ca5: 			   args[ix].equals("-p")  ||
1:fe77ca5: 			   args[ix].equals("-pr"))
1:fe77ca5: 				ix++; //skip the parameter to these args
1:fe77ca5: 			else
1:fe77ca5: 				return args[ix];
1:fe77ca5: 		return null;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Return the name of a resource containing input commands or
1:fe77ca5: 	  null iff none has been specified.
1:fe77ca5: 	  */
1:fe77ca5:  	static public String getInputResourceNameArg(String[] args) {
1:fe77ca5: 		return getArg("-fr", args);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:4b8ef80: 	  Verify the ij line arguments command arguments. Also used to detect --help.
1:fe77ca5: 	  @return true if the args are invalid
1:fe77ca5: 	  <UL>
1:fe77ca5: 	  <LI>Only legal argument provided.
1:fe77ca5: 	  <LI>Only specify a quantity once.
1:fe77ca5: 	  </UL>
1:fe77ca5: 	 */
1:4b8ef80: 	static public boolean invalidArgs(String[] args) {
1:fe77ca5: 		int countSupported = 0;
1:fe77ca5: 		boolean haveInput = false;
1:fe77ca5: 		for (int ix=0; ix < args.length; ix++)
1:fe77ca5: 		{
1:fe77ca5: 			//
1:fe77ca5: 			//If the arguemnt is a supported flag skip the flags argument
1:fe77ca5: 			if(!haveInput && (args[ix].equals("-f") || args[ix].equals("-fr")))
1:fe77ca5: 			{
1:fe77ca5: 				haveInput = true;
1:fe77ca5: 				ix++;
1:fe77ca5: 				if (ix >= args.length) return true;
1:fe77ca5: 			}
1:fe77ca5: 
1:1b0debd: 			else if ((args[ix].equals("-p") || args[ix].equals("-pr") ))
1:fe77ca5: 			{
1:fe77ca5: 				// next arg is the file/resource name
1:fe77ca5: 				ix++;
1:fe77ca5: 				if (ix >= args.length) return true;
1:4b8ef80: 			} else if (args[ix].equals("--help")) { return true; }
1:fe77ca5: 
1:fe77ca5: 			//
1:fe77ca5: 			//Assume the first unknown arg is a file name.
1:fe77ca5: 			else if (!haveInput)
1:fe77ca5: 			{
1:fe77ca5: 				haveInput = true;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				return true;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 		return false;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * print a usage message for invocations of main().
1:fe77ca5: 	 */
1:fe77ca5: 	static void Usage(LocalizedOutput out) {
1:fe77ca5:      	out.println(
1:fe77ca5: 		LocalizedResource.getMessage("IJ_UsageJavaComCloudToolsIjPPropeInput"));
1:fe77ca5: 		out.flush();
1:fe77ca5:    	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     private static final Class[] STRING_P = { "".getClass() };
1:fe77ca5:     private static final Class[] INT_P = { Integer.TYPE };
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5:     /**
1:9952cc5:      * Sets up a data source with values specified in ij.dataSource.* properties or
1:9952cc5:      * passed as parameters of this method
1:9952cc5:      * 
1:9952cc5:      * @param ds DataSource object
1:9952cc5:      * @param dbName Database Name
1:9952cc5:      * @param firstTime If firstTime is false, ij.dataSource.createDatabase and ij.dataSource.databaseName 
1:9952cc5:      * properties will not be used. The value in parameter dbName will be used instead of 
1:9952cc5:      * ij.dataSource.databaseName.
1:9952cc5:      * 
1:9952cc5:      * @throws Exception
1:fe77ca5:      */
1:9952cc5:     static public void setupDataSource(Object ds,String dbName,boolean firstTime) throws Exception {
1:fe77ca5: 	// Loop over set methods on Datasource object, if there is a property
1:9952cc5: 	// then call the method with corresponding value. Call setCreateDatabase based on
1:9952cc5:     //parameter create. 	
1:fe77ca5:    java.lang.reflect.Method[] methods = ds.getClass().getMethods();
1:fe77ca5: 	for (int i = 0; i < methods.length; i++) {
1:fe77ca5: 	    java.lang.reflect.Method m = methods[i];
1:fe77ca5: 	    String name = m.getName();
1:fe77ca5: 	    
1:fe77ca5: 	    if (name.startsWith("set") && (name.length() > "set".length())) {
1:9952cc5: 	     	//Check if setCreateDatabase has to be called based on create parameter
1:9952cc5: 	    	if(name.equals("setCreateDatabase") && !firstTime)
1:9952cc5: 	    		continue;
1:fe77ca5: 	    	
1:fe77ca5: 	    	String property = name.substring("set".length()); // setXyyyZwww
1:fe77ca5: 	    	property = "ij.dataSource."+property.substring(0,1).toLowerCase(java.util.Locale.ENGLISH)+ property.substring(1); // xyyyZwww
1:fe77ca5: 	    	String value = util.getSystemProperty(property);
1:9952cc5: 	    	if(name.equals("setDatabaseName") && !firstTime)
1:9952cc5: 	    		value = dbName;
1:fe77ca5: 	    	if (value != null) {
1:3b11818: 	    		try {
1:fe77ca5: 	    			// call string method
1:fe77ca5: 	    			m.invoke(ds, new Object[] {value});
1:fe77ca5: 	    		} catch (Throwable ignore) {
1:fe77ca5: 	    			// failed, assume it's an integer parameter
1:fe77ca5: 	    			m.invoke(ds, new Object[] {Integer.valueOf(value)});
1:3b11818: 	    		}
1:b658373: 	    	}
1:b658373: 	    }
1:fe77ca5: 	}
1:fe77ca5:     }
1:b658373:     
1:fe77ca5:     /**
1:9952cc5:      * Returns a connection obtained using the DataSource. This method will be called when ij.dataSource
1:9952cc5:      * property is set. It uses ij.dataSource.* properties to get details for the connection. 
1:9952cc5:      * 
1:9952cc5:      * @param dsName Data Source name
1:9952cc5:      * @param user User name
1:9952cc5:      * @param password Password
1:9952cc5:      * @param dbName Database Name
1:9952cc5:      * @param firstTime Indicates if the method is called first time. This is passed to setupDataSource 
1:9952cc5:      * method.
1:9952cc5:      *   
1:9952cc5:      * @throws SQLException
1:fe77ca5:      */
1:9952cc5:     public static Connection getDataSourceConnection(String dsName,String user,String password,
1:9952cc5:     												String dbName,boolean firstTime) throws SQLException{
1:fe77ca5: 		// Get a new proxied connection through DataSource
1:59f29e4:         DataSource ds;
1:b658373: 		try {
1:fe77ca5: 			
1:16d3334: 		    Class<?> dc = Class.forName(dsName);
1:59f29e4:             if (DataSource.class.isAssignableFrom(dc)) {
1:4469400:                 ds = (DataSource) dc.getConstructor().newInstance();
1:59f29e4:             } else {
1:59f29e4:                 throw new ijException(LocalizedResource.getMessage(
1:59f29e4:                     "TL_notInstanceOf", dsName, DataSource.class.getName()));
1:59f29e4:             }
1:59f29e4: 
1:fe77ca5: 		    // set datasource properties
1:9952cc5: 		    setupDataSource(ds,dbName,firstTime);	   
1:12a6309: 
1:59f29e4:             return user == null
1:59f29e4:                     ? ds.getConnection()
1:59f29e4:                     : ds.getConnection(user, password);
1:6daf45b: 		} catch (InvocationTargetException ite)
1:6daf45b: 		{
1:6daf45b: 			if (ite.getTargetException() instanceof SQLException)
1:6daf45b: 				throw (SQLException) ite.getTargetException();
1:6daf45b: 			ite.printStackTrace(System.out);
1:6daf45b: 		} catch (Exception e)
1:6daf45b: 		{
1:6daf45b: 			e.printStackTrace(System.out);
1:6daf45b: 		}
1:6daf45b: 		return null;
1:fe77ca5:     }
1:6daf45b: 
1:fe77ca5: 	/**
1:fe77ca5: 		This will look for the System properties "ij.driver" and "ij.database"
1:fe77ca5: 		and return a java.sql.Connection if it successfully connects.
1:fe77ca5: 		The deprecated driver and database properties are examined first.
1:fe77ca5: 		<p>
1:fe77ca5: 		If no connection was possible, it will return a null.
1:fe77ca5: 		<p>
1:fe77ca5: 		Failure to load the driver class is quietly ignored.
1:fe77ca5: 
1:fe77ca5: 		@param defaultDriver the driver to use if no property value found
1:fe77ca5: 		@param defaultURL the database URL to use if no property value found
1:fe77ca5: 		@param connInfo Connection attributes to pass to getConnection
1:fe77ca5: 		@return a connection to the defaultURL if possible; null if not.
1:fe77ca5: 		@exception SQLException on failure to connect.
1:fe77ca5: 		@exception ClassNotFoundException on failure to load driver.
1:fe77ca5: 		@exception InstantiationException on failure to load driver.
1:fe77ca5: 		@exception IllegalAccessException on failure to load driver.
1:fe77ca5: 	 */
1:fe77ca5:     static public Connection startJBMS(String defaultDriver, String defaultURL,
1:fe77ca5: 				       Properties connInfo) 
1:4469400:       throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException,
1:4469400:         NoSuchMethodException, InvocationTargetException
1:fe77ca5:     {
1:fe77ca5: 	Connection con = null;
1:fe77ca5:         String driverName;
1:fe77ca5:         String databaseURL;
1:fe77ca5: 
1:fe77ca5: 	// deprecate the non-ij prefix.  actually, we should defer to jdbc.drivers...
1:fe77ca5:         driverName = util.getSystemProperty("driver");
1:fe77ca5:         if (driverName == null) driverName = util.getSystemProperty("ij.driver");
1:fe77ca5: 	if (driverName == null || driverName.length()==0) driverName = defaultDriver;
1:5465561:         if (driverName != null) {
1:fe77ca5: 	    util.loadDriver(driverName);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	String jdbcProtocol = util.getSystemProperty("ij.protocol");
1:5465561: 	if (jdbcProtocol != null)
1:fe77ca5: 	    util.loadDriverIfKnown(jdbcProtocol);
1:12a6309: 	
1:12a6309:     String user = util.getSystemProperty("ij.user");
1:12a6309:     String password = util.getSystemProperty("ij.password");
1:fe77ca5: 
1:fe77ca5: 	// deprecate the non-ij prefix name
1:fe77ca5: 	databaseURL = util.getSystemProperty("database");
1:fe77ca5: 	if (databaseURL == null) databaseURL = util.getSystemProperty("ij.database");
1:fe77ca5: 	if (databaseURL == null || databaseURL.length()==0) databaseURL = defaultURL;
1:5465561: 	if (databaseURL != null) {
1:fe77ca5: 	    // add protocol if might help find driver.
1:fe77ca5: 		// if have full URL, load driver for it
1:fe77ca5: 		if (databaseURL.startsWith("jdbc:"))
1:fe77ca5: 		    util.loadDriverIfKnown(databaseURL);
1:93229b0: 	    if (!databaseURL.startsWith("jdbc:") && jdbcProtocol != null)
1:fe77ca5: 		databaseURL = jdbcProtocol+databaseURL;
1:fe77ca5: 
1:fe77ca5: 	    // Update connInfo for ij system properties and
1:fe77ca5: 	    // framework network server
1:fe77ca5: 
1:fe77ca5: 	    connInfo = updateConnInfo(user, password,connInfo);
1:fe77ca5: 
1:fe77ca5: 	    // JDBC driver
1:12a6309: 	    String driver = util.getSystemProperty("driver");
1:fe77ca5: 	    if (driver == null) {
1:fe77ca5: 		driver = "org.apache.derby.jdbc.EmbeddedDriver";
1:fe77ca5: 	    }
1:6daf45b: 	    
1:6daf45b: 	    loadDriver(driver);
1:6daf45b: 		con = DriverManager.getConnection(databaseURL,connInfo);
1:6daf45b: 		return con;  
1:6daf45b: 	}
1:fe77ca5: 
1:fe77ca5: 	    // handle datasource property
1:12a6309: 	    String dsName = util.getSystemProperty("ij.dataSource");
1:6daf45b: 	    if (dsName == null)
1:7dca0be: 	    	return null;
1:7dca0be:         
1:9952cc5: 	    //First connection - pass firstTime=true, dbName=null. For database name, 
1:9952cc5: 	    //value in ij.dataSource.databaseName will be used. 
1:9952cc5: 	    con = getDataSourceConnection(dsName,user,password,null,true);
2:fe77ca5: 	    return con;
1:fe77ca5:    }
1:6daf45b: 
1:fe77ca5: 
1:fe77ca5: 	public static Properties updateConnInfo(String user, String password, Properties connInfo)
1:fe77ca5: 	{
1:fe77ca5: 		String ijGetMessages = util.getSystemProperty("ij.retrieveMessagesFromServerOnGetMessage");
1:fe77ca5: 		boolean retrieveMessages = false;
1:fe77ca5: 		
1:fe77ca5: 		
1:fe77ca5: 		// For JCC make sure we set it to retrieve messages
1:91eacad: 		if (isJCCFramework())
1:fe77ca5: 			retrieveMessages = true;
1:fe77ca5: 		
1:fe77ca5: 		if (ijGetMessages != null)
1:fe77ca5: 		{
1:fe77ca5: 			if (ijGetMessages.equals("false"))
1:fe77ca5: 				retrieveMessages = false;
1:3b11818: 			else
1:fe77ca5: 				retrieveMessages = true;
1:fe77ca5: 			
1:fe77ca5: 		}
1:fe77ca5: 		
1:fe77ca5: 		if (connInfo == null)
1:fe77ca5: 			connInfo = new Properties();
1:fe77ca5: 		
1:fe77ca5: 		if (retrieveMessages == true)
1:fe77ca5: 		{
1:fe77ca5: 			connInfo.put("retrieveMessagesFromServerOnGetMessage",
1:fe77ca5: 						 "true");
1:fe77ca5: 		}
1:fe77ca5: 		if (user != null)
1:fe77ca5: 			connInfo.put("user",user);
1:fe77ca5: 		if (password != null)
1:fe77ca5: 			connInfo.put("password", password);
1:fe77ca5: 		
1:fe77ca5: 		return connInfo;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Utility interface that defaults driver and database to null.
1:fe77ca5: 
1:fe77ca5: 		@return a connection to the defaultURL if possible; null if not.
1:fe77ca5: 		@exception SQLException on failure to connect.
1:fe77ca5: 		@exception ClassNotFoundException on failure to load driver.
1:fe77ca5: 		@exception InstantiationException on failure to load driver.
1:fe77ca5: 		@exception IllegalAccessException on failure to load driver.
1:fe77ca5: 	 */
1:4469400:     static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
1:fe77ca5: 		return startJBMS(null,null);
1:fe77ca5: 	}
1:fe77ca5: 	
1:fe77ca5: 	/**
1:fe77ca5: 	   Utility interface that defaults connInfo to null
1:fe77ca5: 	   <p>
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 		@param defaultDriver the driver to use if no property value found
1:fe77ca5: 		@param defaultURL the database URL to use if no property value found
1:fe77ca5: 		@return a connection to the defaultURL if possible; null if not.
1:fe77ca5: 		@exception SQLException on failure to connect.
1:fe77ca5: 		@exception ClassNotFoundException on failure to load driver.
1:fe77ca5: 		@exception InstantiationException on failure to load driver.
1:fe77ca5: 		@exception IllegalAccessException on failure to load driver.
1:fe77ca5: 	 */
1:fe77ca5:     static public Connection startJBMS(String defaultDriver, String defaultURL) 
1:fe77ca5: 			throws SQLException, ClassNotFoundException, InstantiationException,
1:4469400:                    IllegalAccessException, NoSuchMethodException, InvocationTargetException {
1:fe77ca5: 		return startJBMS(defaultDriver,defaultURL,null);
1:fe77ca5: 		
1:fe77ca5: 	}
1:fe77ca5: 	//-----------------------------------------------------------------
1:fe77ca5: 	// Methods for displaying and checking results
1:fe77ca5: 	// See org.apache.derby.tools.JDBCDisplayUtil for more general displays.
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Display a vector of strings to the out stream.
1:fe77ca5: 	 */
1:fe77ca5: 	public static void DisplayVector(LocalizedOutput out, Vector v) {
1:fe77ca5: 		int l = v.size();
1:fe77ca5: 		for (int i=0;i<l;i++)
1:fe77ca5: 			out.println(v.elementAt(i));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Display a vector of statements to the out stream.
1:fe77ca5: 	public static void DisplayVector(AppStreamWriter out, Vector v, Connection conn) throws SQLException {
1:fe77ca5: 		int l = v.size();
1:fe77ca5: AppUI.out.println("SIZE="+l);
1:fe77ca5: 		for (int i=0;i<l;i++) {
1:fe77ca5: 			Object o = v.elementAt(i);
1:fe77ca5: 			if (o instanceof Integer) { // update count
1:fe77ca5: 				JDBCDisplayUtil.DisplayUpdateCount(out,((Integer)o).intValue());
1:fe77ca5: 			} else { // o instanceof ResultSet
1:fe77ca5: 			    JDBCDisplayUtil.DisplayResults(out,(ResultSet)o,conn);
1:fe77ca5: 				((ResultSet)o).close(); // release the result set
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 	 */
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Display a statement that takes parameters by
1:fe77ca5: 		stuffing it with rows from the result set and
1:fe77ca5: 		displaying each result each time through.
1:fe77ca5: 		Deal with autocommit behavior along the way.
1:fe77ca5: 
1:fe77ca5: 		@exception SQLException thrown on db error
1:fe77ca5: 		@exception ijException thrown on ij error
1:fe77ca5: 	 */
1:fe77ca5: 	public static void DisplayMulti(LocalizedOutput out, PreparedStatement ps,
1:fe77ca5: 		ResultSet rs, Connection conn) throws SQLException, ijException {
1:fe77ca5: 
1:fe77ca5: 		boolean autoCommited = false; // mark if autocommit in place
1:fe77ca5: 		boolean exec = false; // mark the first time through
1:fe77ca5: 		boolean anotherUsingRow = false;	// remember if there's another row 
1:fe77ca5: 											// from using.
1:fe77ca5: 		ResultSetMetaData rsmd = rs.getMetaData();
1:fe77ca5: 		int numCols = rsmd.getColumnCount();
1:fe77ca5: 
1:fe77ca5: 		/* NOTE: We need to close the USING RS first
1:fe77ca5: 		 * so that RunTimeStatistic gets info from
1:fe77ca5: 		 * the user query.
1:fe77ca5: 		 */
1:fe77ca5: 		anotherUsingRow = rs.next();
1:fe77ca5: 
1:fe77ca5: 		while (! autoCommited && anotherUsingRow) {
1:fe77ca5: 			// note the first time through
1:fe77ca5: 			if (!exec) {
1:fe77ca5: 				exec = true;
1:fe77ca5: 
1:fe77ca5: 				// send a warning if additional results may be lost
1:fe77ca5: 				if (conn.getAutoCommit()) {
1:fe77ca5: 					out.println(LocalizedResource.getMessage("IJ_IjWarniAutocMayCloseUsingResulSet"));
1:fe77ca5: 					autoCommited = true;
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			// We need to make sure we pass along the scale, because
1:fe77ca5: 			// setObject assumes a scale of zero (beetle 4365)
1:fe77ca5: 			for (int c=1; c<=numCols; c++) {
1:b658373: 				int sqlType = rsmd.getColumnType(c);
1:b658373: 				
1:b658373: 				if (sqlType == Types.DECIMAL)
1:b658373: 				{
1:5465561:                     ps.setObject(c, rs.getObject(c), sqlType, rsmd.getScale(c));
1:b658373: 				}
1:b658373: 				else
1:b658373: 				{
2:b658373: 					ps.setObject(c,rs.getObject(c),
1:b658373: 							 sqlType);					
1:b658373: 				}
1:b658373: 				
1:b658373: 				
1:b658373: 
1:b658373: 			}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 			// Advance in the USING RS
1:fe77ca5: 			anotherUsingRow = rs.next();
1:fe77ca5: 			// Close the USING RS when exhausted and appropriate
1:fe77ca5: 			// NOTE: Close before the user query
1:fe77ca5: 			if (! anotherUsingRow || conn.getAutoCommit()) //if no more rows or if auto commit is on, close the resultset
1:b658373: 			{
1:fe77ca5: 				rs.close();
1:b658373: 			}
1:fe77ca5: 
1:fe77ca5: 			/*
1:fe77ca5: 				4. execute the statement against those parameters
1:fe77ca5: 			 */
1:fe77ca5: 
1:fe77ca5: 			ps.execute();
1:fe77ca5: 			JDBCDisplayUtil.DisplayResults(out,ps,conn);
1:fe77ca5: 
1:fe77ca5: 			/*
1:fe77ca5: 				5. clear the parameters
1:fe77ca5: 			 */
1:fe77ca5: 			ps.clearParameters();
1:b658373: 		}
1:fe77ca5: 		if (!exec) {
1:fe77ca5: 			rs.close(); //this means, using clause didn't qualify any rows. Just close the resultset associated with using clause
1:fe77ca5: 			throw ijException.noUsingResults();
1:fe77ca5: 		}
1:fe77ca5: 		// REMIND: any way to look for more rsUsing rows if autoCommit?
1:fe77ca5: 		// perhaps just document the behavior... 
1:fe77ca5: 	}
1:fe77ca5: 
1:7a92d1f: 	static final String getSystemProperty(String propertyName) {
1:fe77ca5: 		try
1:b658373: 		{
1:fe77ca5: 			if (propertyName.startsWith("ij.") || propertyName.startsWith("derby."))
1:b658373: 			{
1:fe77ca5: 				util u = new util();
1:fe77ca5: 				u.key = propertyName;
1:16d3334: 				return java.security.AccessController.doPrivileged(u);
1:fe77ca5: 			}
1:b658373: 			else
1:fe77ca5: 			{
1:fe77ca5: 				return System.getProperty(propertyName);
1:fe77ca5: 			}
1:fe77ca5: 		} catch (SecurityException se) {
1:6daf45b: 			return null;
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private String key;
1:fe77ca5: 
1:16d3334: 	public final String run() {
1:fe77ca5: 		return System.getProperty(key);
1:fe77ca5: 	}
1:fe77ca5: 	/** 
1:fe77ca5: 	 * Read a set of properties from the received input stream, strip
1:fe77ca5: 	 * off any excess white space that exists in those property values,
1:fe77ca5: 	 * and then add those newly-read properties to the received
1:fe77ca5: 	 * Properties object; not explicitly removing the whitespace here can
1:fe77ca5: 	 * lead to problems.
1:fe77ca5: 	 *
1:fe77ca5: 	 * This method exists because of the manner in which the jvm reads
1:fe77ca5: 	 * properties from file--extra spaces are ignored after a _key_, but
1:fe77ca5: 	 * if they exist at the _end_ of a property decl line (i.e. as part
1:fe77ca5: 	 * of a _value_), they are preserved, as outlined in the Java API:
1:fe77ca5: 	 *
1:fe77ca5: 	 * "Any whitespace after the key is skipped; if the first non-
1:fe77ca5: 	 * whitespace character after the key is = or :, then it is ignored
1:fe77ca5:  	 * and any whitespace characters after it are also skipped. All
1:fe77ca5: 	 * remaining characters on the line become part of the associated
1:fe77ca5: 	 * element string."
1:fe77ca5: 	 *
1:6b50965: 	 * Creates final properties set consisting of 'prop' plus all
1:fe77ca5: 	 * properties loaded from 'iStr' (with the extra whitespace (if any)
1:fe77ca5: 	 *  removed from all values), will be returned via the parameter.
1:6b50965: 	 *
1:f0b0870: 	 * @param iStr An input stream from which the new properties are to be
1:fe77ca5: 	 *  loaded (should already be initialized).
1:f0b0870: 	 * @param prop A set of properties to which the properties from
1:fe77ca5: 	 *  iStr will be added (should already be initialized).
1:fe77ca5: 	 *
1:6b50965: 	 * Copied here to avoid dependency on an engine class.
1:fe77ca5: 	 **/
1:fe77ca5: 	private static void loadWithTrimmedValues(InputStream iStr,
1:fe77ca5: 		Properties prop) throws IOException {
1:fe77ca5: 
1:fe77ca5: 		// load the properties from the received input stream.
2:fe77ca5: 		Properties p = new Properties();
1:fe77ca5: 		p.load(iStr);
1:fe77ca5: 
1:fe77ca5: 		// Now, trim off any excess whitespace, if any, and then
1:fe77ca5: 		// add the properties from file to the received Properties
1:fe77ca5: 		// set.
1:fe77ca5: 		for (java.util.Enumeration propKeys = p.propertyNames();
1:fe77ca5: 		  propKeys.hasMoreElements();) {
1:fe77ca5: 		// get the value, trim off the whitespace, then store it
1:fe77ca5: 		// in the received properties object.
1:fe77ca5: 			String tmpKey = (String)propKeys.nextElement();
1:fe77ca5: 			String tmpValue = p.getProperty(tmpKey);
1:fe77ca5: 			tmpValue = tmpValue.trim();
1:fe77ca5: 			prop.put(tmpKey, tmpValue);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return;
1:fe77ca5: 
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private static final String[][] protocolDrivers =
1:fe77ca5: 		{
1:fe77ca5: 		  { "jdbc:derby:net:",			"com.ibm.db2.jcc.DB2Driver"},
1:0bbfdac: 		  { "jdbc:derby://",            "org.apache.derby.jdbc.ClientDriver"},
1:fe77ca5: 
1:fe77ca5: 		  { "jdbc:derby:",				"org.apache.derby.jdbc.EmbeddedDriver" },
1:fe77ca5: 		};
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Find the appropriate driver and load it, given a JDBC URL.
1:fe77ca5: 		No action if no driver known for a given URL.
1:fe77ca5: 
1:fe77ca5: 		@param jdbcProtocol the protocol to try.
1:fe77ca5: 
1:fe77ca5: 		@exception ClassNotFoundException if unable to
1:fe77ca5: 			locate class for driver.
1:fe77ca5: 		@exception InstantiationException if unable to
1:fe77ca5: 			create an instance.
1:fe77ca5: 		@exception IllegalAccessException if driver class constructor not visible.
1:fe77ca5: 	 */
1:4469400: 	public static void loadDriverIfKnown(String jdbcProtocol) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
1:fe77ca5: 		for (int i=0; i < protocolDrivers.length; i++) {
1:fe77ca5: 			if (jdbcProtocol.startsWith(protocolDrivers[i][0])) {
1:fe77ca5: 				loadDriver(protocolDrivers[i][1]);
1:fe77ca5: 				break; // only want the first one
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Load a driver given a class name.
1:fe77ca5: 
1:fe77ca5: 		@exception ClassNotFoundException if unable to
1:fe77ca5: 			locate class for driver.
1:fe77ca5: 		@exception InstantiationException if unable to
1:fe77ca5: 			create an instance.
1:fe77ca5: 		@exception IllegalAccessException if driver class constructor not visible.
1:fe77ca5: 	 */
1:59f29e4:     static void loadDriver(String driverClass)
1:4469400:         throws
1:4469400:             ClassNotFoundException, InstantiationException,
1:4469400:             IllegalAccessException, NoSuchMethodException, InvocationTargetException {
1:59f29e4:         Class<?> klass = Class.forName(driverClass);
1:59f29e4:         if (Driver.class.isAssignableFrom(klass)) {
1:4469400:             klass.getConstructor().newInstance();
1:59f29e4:         } else {
1:59f29e4:             throw new ijException(LocalizedResource.getMessage(
1:59f29e4:                     "TL_notInstanceOf", driverClass, Driver.class.getName()));
1:59f29e4:         }
1:fe77ca5: 	}
1:fe77ca5: 
2:9952cc5: 	/**
1:91eacad: 	 * Used to determine if this is a JCC testing framework 
1:0bbfdac: 	 * So that retrieveMessages can be sent.  The plan is to have  
1:0bbfdac: 	 * ij will retrieve messages by default and not look at the testing 
1:0bbfdac: 	 * frameworks. So, ulitmately  this function will look at the driver
1:0bbfdac: 	 * rather than the framework.
1:0bbfdac: 	 * 
1:f0b0870: 	 * @return true if the framework contains Net or JCC.
2:9952cc5: 	 */
1:91eacad: 	private static boolean isJCCFramework()
1:fe77ca5: 	{
1:fe77ca5: 		String framework = util.getSystemProperty("framework");
1:0bbfdac: 		return ((framework != null)  &&
1:91eacad: 			((framework.toUpperCase(Locale.ENGLISH).equals("DERBYNET")) ||
1:0bbfdac: 			 (framework.toUpperCase(Locale.ENGLISH).indexOf("JCC") != -1)));
1:fe77ca5: 	}
1:fe77ca5: 	
1:a9217e9: 	/**
1:a9217e9: 	 * Selects the current schema from the given connection.
1:a9217e9: 	 * 
1:a9217e9: 	 * As there are no way of getting current schema supported by
1:a9217e9: 	 * all major DBMS-es, this method may return null.
1:a9217e9: 	 * 
1:a9217e9: 	 * @param theConnection  Connection to get current schema for
1:a9217e9: 	 * @return the current schema of the connection, or null if error.
1:a9217e9: 	 */
1:a9217e9: 	public static String getSelectedSchema(Connection theConnection) throws SQLException {
1:a9217e9: 		String schema = null;
1:a9217e9:                 if (theConnection == null)
1:a9217e9:                   return null;
1:a9217e9: 		Statement st = theConnection.createStatement();
1:a9217e9: 		try {
1:a9217e9: 			if(!st.execute("VALUES CURRENT SCHEMA"))
1:a9217e9: 				return null;
1:a9217e9: 			
1:a9217e9: 			ResultSet rs = st.getResultSet();
1:a9217e9: 			if(rs==null || !rs.next())
1:a9217e9: 				return null;
1:a9217e9: 			schema = rs.getString(1);
1:a9217e9: 		} catch(SQLException e) {
1:a9217e9: 			// There are no standard way of getting schema.
1:a9217e9: 			// Getting default schema may fail.
1:a9217e9: 		} finally {
1:a9217e9: 			st.close();
1:a9217e9: 		}
1:a9217e9: 		return schema;
1:a9217e9: 	}
1:fe77ca5: }
1:fe77ca5: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                 ds = (DataSource) dc.getConstructor().newInstance();
/////////////////////////////////////////////////////////////////////////
1:       throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException,
1:         NoSuchMethodException, InvocationTargetException
/////////////////////////////////////////////////////////////////////////
1:     static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
/////////////////////////////////////////////////////////////////////////
1:                    IllegalAccessException, NoSuchMethodException, InvocationTargetException {
/////////////////////////////////////////////////////////////////////////
1: 	public static void loadDriverIfKnown(String jdbcProtocol) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
/////////////////////////////////////////////////////////////////////////
1:         throws
1:             ClassNotFoundException, InstantiationException,
1:             IllegalAccessException, NoSuchMethodException, InvocationTargetException {
1:             klass.getConstructor().newInstance();
commit:16d3334
/////////////////////////////////////////////////////////////////////////
1: public final class util implements java.security.PrivilegedAction<String> {
/////////////////////////////////////////////////////////////////////////
1: 		InputStream is = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
1:             public InputStream run() { 
/////////////////////////////////////////////////////////////////////////
1: 		    Class<?> dc = Class.forName(dsName);
/////////////////////////////////////////////////////////////////////////
1: 				return java.security.AccessController.doPrivileged(u);
/////////////////////////////////////////////////////////////////////////
1: 	public final String run() {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:59f29e4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Driver;
/////////////////////////////////////////////////////////////////////////
1: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         DataSource ds;
1:             if (DataSource.class.isAssignableFrom(dc)) {
0:                 ds = (DataSource) dc.newInstance();
1:             } else {
1:                 throw new ijException(LocalizedResource.getMessage(
1:                     "TL_notInstanceOf", dsName, DataSource.class.getName()));
1:             }
1: 
1:             return user == null
1:                     ? ds.getConnection()
1:                     : ds.getConnection(user, password);
/////////////////////////////////////////////////////////////////////////
1:     static void loadDriver(String driverClass)
0:             throws ClassNotFoundException, InstantiationException,
0:                    IllegalAccessException {
1:         Class<?> klass = Class.forName(driverClass);
1:         if (Driver.class.isAssignableFrom(klass)) {
0:             klass.newInstance();
1:         } else {
1:             throw new ijException(LocalizedResource.getMessage(
1:                     "TL_notInstanceOf", driverClass, Driver.class.getName()));
1:         }
commit:8d64950
/////////////////////////////////////////////////////////////////////////
1:     static InputStream getResourceAsStream(String resourceName)
commit:5465561
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (driverName != null) {
1: 	if (jdbcProtocol != null)
/////////////////////////////////////////////////////////////////////////
1: 	if (databaseURL != null) {
/////////////////////////////////////////////////////////////////////////
1:                     ps.setObject(c, rs.getObject(c), sqlType, rsmd.getScale(c));
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:1b0debd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			else if ((args[ix].equals("-p") || args[ix].equals("-pr") ))
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c2603cc
/////////////////////////////////////////////////////////////////////////
0:         if (driverName != null && IS_AT_LEAST_JDBC2) {
0: 	if (jdbcProtocol != null && IS_AT_LEAST_JDBC2)
/////////////////////////////////////////////////////////////////////////
0: 	if (databaseURL != null && IS_AT_LEAST_JDBC2) {
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:b314297
/////////////////////////////////////////////////////////////////////////
commit:7dca0be
/////////////////////////////////////////////////////////////////////////
0: 	    // if we have no URL at this point, we should not attempt to get a
0: 	    // connection. Just start ij without connection. 
0: 	    if (databaseURL == null && defaultURL == null)
1: 	    	return null;
1:         
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:38520af
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 		final Class c = util.class;
1: 		final String resource = qualifyResourceName(resourceName,true);
1: 		if (resource == null) 
0: 		InputStream is = (InputStream) AccessController.doPrivileged(new PrivilegedAction() {
0:             public Object run() { 
1:                       InputStream locis = 
1:                           c.getResourceAsStream(resource);
1:                                   return locis;
1:             }
1:         }
1:      );
1: 
commit:a9217e9
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Selects the current schema from the given connection.
1: 	 * 
1: 	 * As there are no way of getting current schema supported by
1: 	 * all major DBMS-es, this method may return null.
1: 	 * 
1: 	 * @param theConnection  Connection to get current schema for
1: 	 * @return the current schema of the connection, or null if error.
1: 	 */
1: 	public static String getSelectedSchema(Connection theConnection) throws SQLException {
1: 		String schema = null;
1:                 if (theConnection == null)
1:                   return null;
1: 		Statement st = theConnection.createStatement();
1: 		try {
1: 			if(!st.execute("VALUES CURRENT SCHEMA"))
1: 				return null;
1: 			
1: 			ResultSet rs = st.getResultSet();
1: 			if(rs==null || !rs.next())
1: 				return null;
1: 			schema = rs.getString(1);
1: 		} catch(SQLException e) {
1: 			// There are no standard way of getting schema.
1: 			// Getting default schema may fail.
1: 		} finally {
1: 			st.close();
1: 		}
1: 		return schema;
1: 	}
commit:4b8ef80
/////////////////////////////////////////////////////////////////////////
1: 	  Verify the ij line arguments command arguments. Also used to detect --help.
1: 	static public boolean invalidArgs(String[] args) {
/////////////////////////////////////////////////////////////////////////
1: 			} else if (args[ix].equals("--help")) { return true; }
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
1: 	  @param resourceName the name of the resource
/////////////////////////////////////////////////////////////////////////
1: 	 * @param iStr An input stream from which the new properties are to be
1: 	 * @param prop A set of properties to which the properties from
/////////////////////////////////////////////////////////////////////////
1: 	 * @return true if the framework contains Net or JCC.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3b11818
/////////////////////////////////////////////////////////////////////////
0: 	private static boolean IS_AT_LEAST_JDBC2;
0: 		boolean isAtLeastJDBC2;
0:             // Need to test to see if this is
0:             // currently JDBC 2 or JSR169.
0:             // Checking for BigDecimal doesn't work because
0:             // BigDecimal exists in J2ME/CDC/Foundation 1.1
0:             Class.forName("java.sql.Driver");
0: 			isAtLeastJDBC2 = true;
0: 			isAtLeastJDBC2 = false;
0: 		IS_AT_LEAST_JDBC2 = isAtLeastJDBC2;
/////////////////////////////////////////////////////////////////////////
0: 					if (util.IS_AT_LEAST_JDBC2)
/////////////////////////////////////////////////////////////////////////
0: 						// an integral type. Of course in JSR169 we have
0:                         // no way to determine the parameter types,
0:                         // ParameterMetaData is not supported.
0:                         // So convert as string, and on a conversion error
0:                         // try as a long.
1:                         
1:                         try {
0:                             ps.setString(c, rs.getString(c));
0:                         } catch (SQLException e) {
0:                             // 22018 - invalid format
0:                             if ("22018".equals(e.getSQLState()))
0:                                 ps.setLong(c, rs.getLong(c));
1:                             else
0:                                 throw e;
1:                         }						
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0: public final class util implements java.security.PrivilegedAction {
/////////////////////////////////////////////////////////////////////////
1: 	static final String getSystemProperty(String propertyName) {
commit:b658373
/////////////////////////////////////////////////////////////////////////
0: 	private static boolean HAVE_BIG_DECIMAL;
1: 	
1: 	{
0: 		boolean haveBigDecimal;
1: 		try {
0: 			Class.forName("java.math.BigDecimal");
0: 			haveBigDecimal = true;
0: 		} catch (Throwable t) {
0: 			haveBigDecimal = false;
1: 		}
0: 		HAVE_BIG_DECIMAL = haveBigDecimal;
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 				int sqlType = rsmd.getColumnType(c);
1: 				
1: 				if (sqlType == Types.DECIMAL)
1: 				{
0: 					if (util.HAVE_BIG_DECIMAL)
1: 					{
1: 						ps.setObject(c,rs.getObject(c),
0: 								 sqlType,
0: 								 rsmd.getScale(c));							
1: 					}
1: 					else
1: 					{
0: 						// In J2ME there is no object that represents
0: 						// a DECIMAL value. By default use String to
0: 						// pass values around, but for integral types
0: 						// first convert to a integral type from the DECIMAL
0: 						// because strings like 3.4 are not convertible to
0: 						// an integral type.
0: 						switch (ps.getMetaData().getColumnType(c))
1: 						{
0: 						case Types.BIGINT:
0: 							ps.setLong(c, rs.getLong(c));
0: 						    break;
0: 						case Types.INTEGER:
0: 						case Types.SMALLINT:
0: 						case Types.TINYINT:
0: 							ps.setInt(c, rs.getInt(c));
0: 							break;
0: 						default:
0: 							ps.setString(c,rs.getString(c));
0: 						    break;
1: 						}								
1: 					}
1: 					
1: 				}
1: 				else
1: 				{
1: 					ps.setObject(c,rs.getObject(c),
1: 							 sqlType);					
1: 				}
1: 				
1: 				
1: 
commit:12a6309
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	private static final Class[] DS_GET_CONN_TYPES = {"".getClass(), "".getClass()};
/////////////////////////////////////////////////////////////////////////
1: 	
1:     String user = util.getSystemProperty("ij.user");
1:     String password = util.getSystemProperty("ij.password");
/////////////////////////////////////////////////////////////////////////
1: 	    String driver = util.getSystemProperty("driver");
/////////////////////////////////////////////////////////////////////////
1: 	    String dsName = util.getSystemProperty("ij.dataSource");
/////////////////////////////////////////////////////////////////////////
0: 		    setupDataSource(ds);	   
0: 		    // or con = ds.getConnection(user, password)
1: 		    	
0: 			java.lang.reflect.Method m = 
0: 				user == null ? dc.getMethod("getConnection", null) :
0: 					 dc.getMethod("getConnection", DS_GET_CONN_TYPES);
1: 				
0: 			return (java.sql.Connection) m.invoke(ds,
0: 					 user == null ? null : new String[] {user, password});
commit:6daf45b
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1: 	    
1: 	    loadDriver(driver);
1: 		con = DriverManager.getConnection(databaseURL,connInfo);
1: 		return con;  
1: 	}
1: 	    if (dsName == null)
1: 	    	return null;
1: 			
/////////////////////////////////////////////////////////////////////////
0: 			return (java.sql.Connection) m.invoke(ds, new Object[] {});
1: 		} catch (InvocationTargetException ite)
1: 		{
1: 			if (ite.getTargetException() instanceof SQLException)
1: 				throw (SQLException) ite.getTargetException();
1: 			ite.printStackTrace(System.out);
1: 		} catch (Exception e)
1: 		{
1: 			e.printStackTrace(System.out);
1: 		
1: 		return null;
1:    }
commit:93229b0
/////////////////////////////////////////////////////////////////////////
1: 	    if (!databaseURL.startsWith("jdbc:") && jdbcProtocol != null)
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.ij.util
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.ij;
1: 
1: import org.apache.derby.tools.JDBCDisplayUtil;
1: import org.apache.derby.iapi.tools.i18n.*;
1: 
1: import java.io.BufferedInputStream;
1: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
1: import java.io.InputStream;
1: import java.io.IOException;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.Types;
1: 
1: import java.util.Properties;
1: import java.util.Vector;
0: import java.util.Stack;
0: import java.math.BigDecimal;
1: 
1: /**
1: 	Methods used to control setup for apps as
1: 	well as display some internal ij structures.
1: 
1: 	@see org.apache.derby.tools.JDBCDisplayUtil
0: 	@author ames
1:  */
0: public class util implements java.security.PrivilegedAction {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private util() {}
1: 
1: 	//-----------------------------------------------------------------
1: 	// Methods for starting up JBMS
1: 
1: 	/**
1: 	 * Find the argument that follows the specified parameter.
1: 	 *
1: 	 *	@param param the parameter (e.g. "-p")
1: 	 *	@param args	the argument list to consider.
1: 	 *
1: 	 *	@return the argument that follows the parameter, or null if not found
1: 	 */
1: 	static public String getArg(String param, String[] args)
1: 	{
1: 		int pLocn;
1: 		Properties p;
1: 
1: 		if (args == null) return null;
1: 
1: 		for (pLocn=0; pLocn<args.length; pLocn++) {
1: 			if (param.equals(args[pLocn])) break;
1: 		}
1: 		if (pLocn >= (args.length-1))  // not found or no file
1: 			return null;
1: 
1: 		return args[pLocn+1];
1: 	}
1: 
1: 	/**
1: 		ij is started with "-p[r] file OtherArgs";
1: 		the file contains properties to control the driver and database
1: 		used to run ij, and can provide additional system properties.
1: 		<p>
1: 		getPropertyArg will look at the args and take out a "-p <file>" pair,
1: 		reading the file into the system properties.
1: 		<p>
1: 		If there was a -p without a following <file>, no action is taken.
1: 
1: 		@exception IOException thrown if file not found
1: 
1: 		@param args	the argument list to consider.
1: 		@return true if a property item was found and loaded.
1: 	 */
1: 	static public boolean getPropertyArg(String[] args) throws IOException {
1: 		String n;
1: 		InputStream in1;
1: 		Properties p;
1: 
1: 		if ((n = getArg("-p", args))!= null){
1: 			in1 = new FileInputStream(n);
1: 			in1 = new BufferedInputStream(in1);
1: 		}
1: 		else if ((n = getArg("-pr", args)) != null) {
1: 			in1 = getResourceAsStream(n);
1: 			if (in1 == null) throw ijException.resourceNotFound();
1: 		}
1: 		else
1: 			return false;
1: 
1: 		p = System.getProperties();
1: 
1: 		// Trim off excess whitespace in property file, if any, and
1: 		// then load those properties into 'p'.
1: 		util.loadWithTrimmedValues(in1, p);
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
0: 		ij is started with "-ca[r] file OtherArgs";
0: 		the file contains connection attibute properties 
0: 		to pass to getConnection
1: 		<p>
0: 		getConnAttributeArg will look at the args and take out a 
0: 		"-ca[r] <file>" pair and returning the Properties
1: 		<p>
1: 
1: 		@exception IOException thrown if file not found
1: 
1: 		@param args	the argument list to consider.
0: 		@return  properties in the file
1: 	 */
0: 	static public Properties getConnAttributeArg(String[] args) 
0: 		throws IOException 
1: 	{
1: 		String n;
1: 		InputStream in1;
1: 		Properties p = new Properties();
1: 
0: 		if ((n = getArg("-ca", args))!= null){
1: 			in1 = new FileInputStream(n);
1: 			in1 = new BufferedInputStream(in1);
1: 		}
0: 		else if ((n = getArg("-car", args)) != null) {
1: 			in1 = getResourceAsStream(n);
1: 			if (in1 == null) throw ijException.resourceNotFound();
1: 		}
1: 		else
1: 			return null;
1: 
1: 		// Trim off excess whitespace in property file, if any, and
1: 		// then load those properties into 'p'.
1: 		util.loadWithTrimmedValues(in1, p);
1: 
0: 		return p;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	  Convenience routine to qualify a resource name with "ij.defaultPackageName"
1: 	  if it is not qualified (does not begin with a "/").
1: 
1: 	  @param absolute true means return null if the name is not absolute and false
1: 	  means return partial names. 
1: 	  */
1: 	static String qualifyResourceName(String resourceName, boolean absolute)
1: 	{
1: 		resourceName=resourceName.trim();
1: 		if (resourceName.startsWith("/"))
1: 		{
1: 			return resourceName;
1: 		}
1: 		else
1: 		{
1: 			String pName = util.getSystemProperty("ij.defaultResourcePackage").trim();
1: 			if (pName == null) return null;
1: 			if ((pName).endsWith("/"))
1: 				resourceName = pName+resourceName;
1: 			else
1: 				resourceName = pName+"/"+resourceName;
1: 			if (absolute && !resourceName.startsWith("/"))
1: 				return null;
1: 			else
1: 				return resourceName;
1: 		}
1: 	}
1: 	/**
1: 	  Convenience routine to get a resource as a BufferedInputStream. If the
1: 	  resourceName is not absolute (does not begin with a "/") this qualifies
1: 	  the name with the "ij.defaultResourcePackage" name.
1: 
0: 	  @param String the name of the resource
1: 	  @return a buffered stream for the resource if it exists and null otherwise.
1: 	  */
0: 	static public InputStream getResourceAsStream(String resourceName) 
1: 	{
0: 		Class c= util.class;
0: 		resourceName = qualifyResourceName(resourceName,true);
0: 		if (resourceName == null) 
1: 			return null;
0: 		InputStream is = c.getResourceAsStream(resourceName);
1: 		if (is != null) 
1: 			is = new BufferedInputStream(is, utilMain.BUFFEREDFILESIZE);
1: 		return is;
1: 	}
1: 
1: 	/**
1: 	  Return the name of the ij command file or null if none is
1: 	  specified. The command file may be proceeded with -f flag on
1: 	  the command line. Alternatively, the command file may be 
1: 	  specified without a -f flag. In this case we assume the first
1: 	  unknown argument is the command file.
1: 
1: 	  <P>
1: 	  This should only be called after calling invalidArgs.
1: 
1: 	  <p>
1: 	  If there is no such argument, a null is returned.
1: 
1: 	  @param args	the argument list to consider.
1: 	  @return the name of the first argument not preceded by "-p",
1: 	  null if none found.
1: 	  
1: 	  @exception IOException thrown if file not found
1: 	 */
1: 	static public String getFileArg(String[] args) throws IOException {
1: 		String fileName;
1: 		int fLocn;
1: 		boolean foundP = false;
1: 
1: 		if (args == null) return null;
1: 		if ((fileName=getArg("-f",args))!=null) return fileName;
1: 		//
1: 		//The first unknown arg is the file
1: 		for (int ix=0; ix < args.length; ix++)
1: 			if(args[ix].equals("-f")  ||
1: 			   args[ix].equals("-fr") ||
0: 			   args[ix].equals("-ca")  ||
0: 			   args[ix].equals("-car")  ||
1: 			   args[ix].equals("-p")  ||
1: 			   args[ix].equals("-pr"))
1: 				ix++; //skip the parameter to these args
1: 			else
1: 				return args[ix];
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	  Return the name of a resource containing input commands or
1: 	  null iff none has been specified.
1: 	  */
1:  	static public String getInputResourceNameArg(String[] args) {
1: 		return getArg("-fr", args);
1: 	}
1: 
1: 	/**
0: 	  Verify the ij line arguments command arguments.
1: 	  @return true if the args are invalid
1: 	  <UL>
1: 	  <LI>Only legal argument provided.
1: 	  <LI>Only specify a quantity once.
1: 	  </UL>
1: 	 */
0: 	static public boolean invalidArgs(String[] args, boolean gotProp, String file,
0: 									   String inputResourceName) {
1: 		int countSupported = 0;
1: 		boolean haveInput = false;
1: 		for (int ix=0; ix < args.length; ix++)
1: 		{
1: 			//
1: 			//If the arguemnt is a supported flag skip the flags argument
1: 			if(!haveInput && (args[ix].equals("-f") || args[ix].equals("-fr")))
1: 			{
1: 				haveInput = true;
1: 				ix++;
1: 				if (ix >= args.length) return true;
1: 			}
1: 
0: 			else if ((args[ix].equals("-p") || args[ix].equals("-pr") ||
0: 					  args[ix].equals("-ca") || args[ix].equals("-car") ))
1: 			{
1: 				// next arg is the file/resource name
1: 				ix++;
1: 				if (ix >= args.length) return true;
1: 			}
1: 
1: 
1: 			//
1: 			//Assume the first unknown arg is a file name.
1: 			else if (!haveInput)
1: 			{
1: 				haveInput = true;
1: 			}
1: 
1: 			else
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * print a usage message for invocations of main().
1: 	 */
1: 	static void Usage(LocalizedOutput out) {
1:      	out.println(
1: 		LocalizedResource.getMessage("IJ_UsageJavaComCloudToolsIjPPropeInput"));
1: 		out.flush();
1:    	}
1: 
1: 
1:     private static final Class[] STRING_P = { "".getClass() };
1:     private static final Class[] INT_P = { Integer.TYPE };
1: 
1: 
0:     static public void setupDataSource(Object ds) throws Exception {
1: 	// Loop over set methods on Datasource object, if there is a property
0: 	// then call the method with corresponding value.
1: 	java.lang.reflect.Method[] methods = ds.getClass().getMethods();
1: 	for (int i = 0; i < methods.length; i++) {
1: 	    java.lang.reflect.Method m = methods[i];
1: 	    String name = m.getName();
1: 	    if (name.startsWith("set") && (name.length() > "set".length())) {
1: 		String property = name.substring("set".length()); // setXyyyZwww
1: 		property = "ij.dataSource."+property.substring(0,1).toLowerCase(java.util.Locale.ENGLISH)+ property.substring(1); // xyyyZwww
1: 		String value = util.getSystemProperty(property);
0: 		//System.out.println("setupDateSource: method="+name+" property="+property+" value="+((value==null)?"null":value));
1: 		if (value != null) {
0: 		    try {
1: 			// call string method
1: 			m.invoke(ds, new Object[] {value});
1: 		    } catch (Throwable ignore) {
1: 			// failed, assume it's an integer parameter
1: 			m.invoke(ds, new Object[] {Integer.valueOf(value)});
1: 		    }
1: 		}
1: 	    }
1: 	}
1:     }
1: 
1: 	/**
1: 		This will look for the System properties "ij.driver" and "ij.database"
1: 		and return a java.sql.Connection if it successfully connects.
1: 		The deprecated driver and database properties are examined first.
1: 		<p>
1: 		If no connection was possible, it will return a null.
1: 		<p>
1: 		Failure to load the driver class is quietly ignored.
1: 
1: 		@param defaultDriver the driver to use if no property value found
1: 		@param defaultURL the database URL to use if no property value found
1: 		@param connInfo Connection attributes to pass to getConnection
1: 		@return a connection to the defaultURL if possible; null if not.
1: 		@exception SQLException on failure to connect.
1: 		@exception ClassNotFoundException on failure to load driver.
1: 		@exception InstantiationException on failure to load driver.
1: 		@exception IllegalAccessException on failure to load driver.
1: 	 */
1:     static public Connection startJBMS(String defaultDriver, String defaultURL,
1: 				       Properties connInfo) 
0: 	throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException
1:     {
1: 	Connection con = null;
1:         String driverName;
1:         String databaseURL;
1: 
1: 	// deprecate the non-ij prefix.  actually, we should defer to jdbc.drivers...
1:         driverName = util.getSystemProperty("driver");
1:         if (driverName == null) driverName = util.getSystemProperty("ij.driver");
1: 	if (driverName == null || driverName.length()==0) driverName = defaultDriver;
0:         if (driverName != null) {
1: 	    util.loadDriver(driverName);
1: 	}
1: 
1: 	String jdbcProtocol = util.getSystemProperty("ij.protocol");
0: 	if (jdbcProtocol != null)
1: 	    util.loadDriverIfKnown(jdbcProtocol);
1: 
1: 	// deprecate the non-ij prefix name
1: 	databaseURL = util.getSystemProperty("database");
1: 	if (databaseURL == null) databaseURL = util.getSystemProperty("ij.database");
1: 	if (databaseURL == null || databaseURL.length()==0) databaseURL = defaultURL;
0: 	if (databaseURL != null) {
1: 	    // add protocol if might help find driver.
0: 	    boolean noDriver = false;
0: 	    try {
1: 		// if have full URL, load driver for it
1: 		if (databaseURL.startsWith("jdbc:"))
1: 		    util.loadDriverIfKnown(databaseURL);
0: 		DriverManager.getDriver(databaseURL);
0: 	    } catch (SQLException se) {
0: 		noDriver = true;
1: 	    }
0: 	    if (noDriver && jdbcProtocol != null)
1: 		databaseURL = jdbcProtocol+databaseURL;
1: 
0: 	    String user = util.getSystemProperty("ij.user");
0: 	    String password = util.getSystemProperty("ij.password");
1: 
1: 	    // Update connInfo for ij system properties and
1: 	    // framework network server
1: 
1: 	    connInfo = updateConnInfo(user, password,connInfo);
1: 
1: 	    // JDBC driver
0: 	    String driver = System.getProperty("driver");
1: 	    if (driver == null) {
1: 		driver = "org.apache.derby.jdbc.EmbeddedDriver";
1: 	    }
1: 
1: 	    // handle datasource property
0: 	    String dsName = System.getProperty("ij.dataSource");
0: 	    if (dsName == null) {
0: 		loadDriver(driver);
0: 		con = DriverManager.getConnection(databaseURL,connInfo);
1: 		return con;
1: 
0: 	    } else { // a datasource
1: 		// Get a new proxied connection through DataSource
0: 		Object ds = null; // really javax.sql.DataSource
0: 		try {
0: 		    Class dc = Class.forName(dsName);
0: 		    ds = dc.newInstance();
1: 		    
1: 		    // set datasource properties
0: 		    setupDataSource(ds);
1: 
0: 		    // Java method call "by hand" {  con = ds.getConnection(); }
1: 		    {
0: 			java.lang.reflect.Method m = dc.getMethod("getConnection", null); 
0: 			con = (java.sql.Connection) m.invoke(ds, new Object[] {});
1: 		    }
0: 		} catch (Throwable error) {
0: 		    error.printStackTrace(System.out);
1: 		}
1: 		return con;
0: 	    } // datasource
1: 	}
0: 	// failed
1: 	return null;
1:     }
1: 
1: 
1: 	public static Properties updateConnInfo(String user, String password, Properties connInfo)
1: 	{
1: 		String framework = util.getSystemProperty("framework");
1: 		String ijGetMessages = util.getSystemProperty("ij.retrieveMessagesFromServerOnGetMessage");
1: 		boolean retrieveMessages = false;
1: 		
1: 		
1: 		// For JCC make sure we set it to retrieve messages
0: 		if (framework != null  && ((framework.equals("DB2jNet") 
0: 									|| framework.equals("DB2jcc"))))
1: 			retrieveMessages = true;
1: 		
1: 		if (ijGetMessages != null)
1: 		{
1: 			if (ijGetMessages.equals("false"))
1: 				retrieveMessages = false;
1: 			else
1: 				retrieveMessages = true;
1: 			
1: 		}
1: 		
1: 		if (connInfo == null)
1: 			connInfo = new Properties();
1: 		
1: 		if (retrieveMessages == true)
1: 		{
1: 			connInfo.put("retrieveMessagesFromServerOnGetMessage",
1: 						 "true");
1: 		}
1: 		if (user != null)
1: 			connInfo.put("user",user);
1: 		if (password != null)
1: 			connInfo.put("password", password);
1: 		
1: 		return connInfo;
1: 	}
1: 
1: 	/**
1: 		Utility interface that defaults driver and database to null.
1: 
1: 		@return a connection to the defaultURL if possible; null if not.
1: 		@exception SQLException on failure to connect.
1: 		@exception ClassNotFoundException on failure to load driver.
1: 		@exception InstantiationException on failure to load driver.
1: 		@exception IllegalAccessException on failure to load driver.
1: 	 */
0:     static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {
1: 		return startJBMS(null,null);
1: 	}
1: 	
1: 	/**
1: 	   Utility interface that defaults connInfo to null
1: 	   <p>
1: 
1: 
1: 		@param defaultDriver the driver to use if no property value found
1: 		@param defaultURL the database URL to use if no property value found
1: 		@return a connection to the defaultURL if possible; null if not.
1: 		@exception SQLException on failure to connect.
1: 		@exception ClassNotFoundException on failure to load driver.
1: 		@exception InstantiationException on failure to load driver.
1: 		@exception IllegalAccessException on failure to load driver.
1: 	 */
1:     static public Connection startJBMS(String defaultDriver, String defaultURL) 
1: 			throws SQLException, ClassNotFoundException, InstantiationException,
0: 				   IllegalAccessException {
1: 		return startJBMS(defaultDriver,defaultURL,null);
1: 		
1: 	}
1: 	//-----------------------------------------------------------------
1: 	// Methods for displaying and checking results
1: 	// See org.apache.derby.tools.JDBCDisplayUtil for more general displays.
1: 
1: 
1: 	/**
1: 		Display a vector of strings to the out stream.
1: 	 */
1: 	public static void DisplayVector(LocalizedOutput out, Vector v) {
1: 		int l = v.size();
1: 		for (int i=0;i<l;i++)
1: 			out.println(v.elementAt(i));
1: 	}
1: 
1: 	/**
1: 		Display a vector of statements to the out stream.
1: 	public static void DisplayVector(AppStreamWriter out, Vector v, Connection conn) throws SQLException {
1: 		int l = v.size();
1: AppUI.out.println("SIZE="+l);
1: 		for (int i=0;i<l;i++) {
1: 			Object o = v.elementAt(i);
1: 			if (o instanceof Integer) { // update count
1: 				JDBCDisplayUtil.DisplayUpdateCount(out,((Integer)o).intValue());
1: 			} else { // o instanceof ResultSet
1: 			    JDBCDisplayUtil.DisplayResults(out,(ResultSet)o,conn);
1: 				((ResultSet)o).close(); // release the result set
1: 			}
1: 		}
1: 	}
1: 	 */
1: 
1: 	/**
1: 		Display a statement that takes parameters by
1: 		stuffing it with rows from the result set and
1: 		displaying each result each time through.
1: 		Deal with autocommit behavior along the way.
1: 
1: 		@exception SQLException thrown on db error
1: 		@exception ijException thrown on ij error
1: 	 */
1: 	public static void DisplayMulti(LocalizedOutput out, PreparedStatement ps,
1: 		ResultSet rs, Connection conn) throws SQLException, ijException {
1: 
1: 		boolean autoCommited = false; // mark if autocommit in place
1: 		boolean exec = false; // mark the first time through
1: 		boolean anotherUsingRow = false;	// remember if there's another row 
1: 											// from using.
1: 		ResultSetMetaData rsmd = rs.getMetaData();
1: 		int numCols = rsmd.getColumnCount();
1: 
1: 		/* NOTE: We need to close the USING RS first
1: 		 * so that RunTimeStatistic gets info from
1: 		 * the user query.
1: 		 */
1: 		anotherUsingRow = rs.next();
1: 
1: 		while (! autoCommited && anotherUsingRow) {
1: 			// note the first time through
1: 			if (!exec) {
1: 				exec = true;
1: 
1: 				// send a warning if additional results may be lost
1: 				if (conn.getAutoCommit()) {
1: 					out.println(LocalizedResource.getMessage("IJ_IjWarniAutocMayCloseUsingResulSet"));
1: 					autoCommited = true;
1: 				}
1: 			}
1: 
1: 			// We need to make sure we pass along the scale, because
1: 			// setObject assumes a scale of zero (beetle 4365)
1: 			for (int c=1; c<=numCols; c++) {
0: 				ps.setObject(c,rs.getObject(c),
0: 					 rsmd.getColumnType(c),
0: 					 rsmd.getScale(c));
1: 			}
1: 
1: 
1: 			// Advance in the USING RS
1: 			anotherUsingRow = rs.next();
1: 			// Close the USING RS when exhausted and appropriate
1: 			// NOTE: Close before the user query
1: 			if (! anotherUsingRow || conn.getAutoCommit()) //if no more rows or if auto commit is on, close the resultset
1: 			{
1: 				rs.close();
1: 			}
1: 
1: 			/*
1: 				4. execute the statement against those parameters
1: 			 */
1: 
1: 			ps.execute();
1: 			JDBCDisplayUtil.DisplayResults(out,ps,conn);
1: 
1: 			/*
1: 				5. clear the parameters
1: 			 */
1: 			ps.clearParameters();
1: 		}
1: 		if (!exec) {
1: 			rs.close(); //this means, using clause didn't qualify any rows. Just close the resultset associated with using clause
1: 			throw ijException.noUsingResults();
1: 		}
1: 		// REMIND: any way to look for more rsUsing rows if autoCommit?
1: 		// perhaps just document the behavior... 
1: 	}
1: 
0: 	public static final String getSystemProperty(String propertyName) {
1: 		try
1: 		{
1: 			if (propertyName.startsWith("ij.") || propertyName.startsWith("derby."))
1: 			{
1: 				util u = new util();
1: 				u.key = propertyName;
0: 				return (String) java.security.AccessController.doPrivileged(u);
1: 			}
1: 			else
1: 			{
1: 				return System.getProperty(propertyName);
1: 			}
1: 		} catch (SecurityException se) {
1: 			return null;
1: 		}
1: 	}
1: 
1: 	private String key;
1: 
0: 	public final Object run() {
1: 		return System.getProperty(key);
1: 	}
1: 	/** 
1: 	 * Read a set of properties from the received input stream, strip
1: 	 * off any excess white space that exists in those property values,
1: 	 * and then add those newly-read properties to the received
1: 	 * Properties object; not explicitly removing the whitespace here can
1: 	 * lead to problems.
1: 	 *
1: 	 * This method exists because of the manner in which the jvm reads
1: 	 * properties from file--extra spaces are ignored after a _key_, but
1: 	 * if they exist at the _end_ of a property decl line (i.e. as part
1: 	 * of a _value_), they are preserved, as outlined in the Java API:
1: 	 *
1: 	 * "Any whitespace after the key is skipped; if the first non-
1: 	 * whitespace character after the key is = or :, then it is ignored
1:  	 * and any whitespace characters after it are also skipped. All
1: 	 * remaining characters on the line become part of the associated
1: 	 * element string."
1: 	 *
0: 	 * @param iStr: An input stream from which the new properties are to be
1: 	 *  loaded (should already be initialized).
0: 	 * @param prop: A set of properties to which the properties from
1: 	 *  iStr will be added (should already be initialized).
0: 	 * @return A final properties set consisting of 'prop' plus all
1: 	 * properties loaded from 'iStr' (with the extra whitespace (if any)
1: 	 *  removed from all values), will be returned via the parameter.
1: 	 *
0: 		Copied here to avoid dependency on an engine class.
1: 	 **/
1: 	private static void loadWithTrimmedValues(InputStream iStr,
1: 		Properties prop) throws IOException {
1: 
1: 		// load the properties from the received input stream.
1: 		Properties p = new Properties();
1: 		p.load(iStr);
1: 
1: 		// Now, trim off any excess whitespace, if any, and then
1: 		// add the properties from file to the received Properties
1: 		// set.
1: 		for (java.util.Enumeration propKeys = p.propertyNames();
1: 		  propKeys.hasMoreElements();) {
1: 		// get the value, trim off the whitespace, then store it
1: 		// in the received properties object.
1: 			String tmpKey = (String)propKeys.nextElement();
1: 			String tmpValue = p.getProperty(tmpKey);
1: 			tmpValue = tmpValue.trim();
1: 			prop.put(tmpKey, tmpValue);
1: 		}
1: 
1: 		return;
1: 
1: 	}
1: 
1: 	private static final String[][] protocolDrivers =
1: 		{
1: 		  { "jdbc:derby:net:",			"com.ibm.db2.jcc.DB2Driver"},
1: 		  { "jdbc:derby:",				"org.apache.derby.jdbc.EmbeddedDriver" },
1: 		};
1: 
1: 	/**
1: 		Find the appropriate driver and load it, given a JDBC URL.
1: 		No action if no driver known for a given URL.
1: 
1: 		@param jdbcProtocol the protocol to try.
1: 
1: 		@exception ClassNotFoundException if unable to
1: 			locate class for driver.
1: 		@exception InstantiationException if unable to
1: 			create an instance.
1: 		@exception IllegalAccessException if driver class constructor not visible.
1: 	 */
0: 	public static void loadDriverIfKnown(String jdbcProtocol) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
1: 		for (int i=0; i < protocolDrivers.length; i++) {
1: 			if (jdbcProtocol.startsWith(protocolDrivers[i][0])) {
1: 				loadDriver(protocolDrivers[i][1]);
1: 				break; // only want the first one
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		Load a driver given a class name.
1: 
1: 		@exception ClassNotFoundException if unable to
1: 			locate class for driver.
1: 		@exception InstantiationException if unable to
1: 			create an instance.
1: 		@exception IllegalAccessException if driver class constructor not visible.
1: 	 */
0: 	public static void loadDriver(String driverClass) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
0:         Class.forName(driverClass).newInstance();
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11bc2d0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Creates final properties set consisting of 'prop' plus all
0: 	 * properties loaded from 'iStr' (with the extra whitespace (if any)
0: 	 *  removed from all values), will be returned via the parameter.
1: 	 *
1: 	 * Copied here to avoid dependency on an engine class.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:9952cc5
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets up a data source with values specified in ij.dataSource.* properties or
1:      * passed as parameters of this method
1:      * 
1:      * @param ds DataSource object
1:      * @param dbName Database Name
1:      * @param firstTime If firstTime is false, ij.dataSource.createDatabase and ij.dataSource.databaseName 
1:      * properties will not be used. The value in parameter dbName will be used instead of 
1:      * ij.dataSource.databaseName.
1:      * 
1:      * @throws Exception
1:      */
1:     static public void setupDataSource(Object ds,String dbName,boolean firstTime) throws Exception {
1: 	// then call the method with corresponding value. Call setCreateDatabase based on
1:     //parameter create. 	
0:    java.lang.reflect.Method[] methods = ds.getClass().getMethods();
0: 	    
1: 	     	//Check if setCreateDatabase has to be called based on create parameter
1: 	    	if(name.equals("setCreateDatabase") && !firstTime)
1: 	    		continue;
0: 	    	
0: 	    	String property = name.substring("set".length()); // setXyyyZwww
0: 	    	property = "ij.dataSource."+property.substring(0,1).toLowerCase(java.util.Locale.ENGLISH)+ property.substring(1); // xyyyZwww
0: 	    	String value = util.getSystemProperty(property);
1: 	    	if(name.equals("setDatabaseName") && !firstTime)
1: 	    		value = dbName;
0: 	    	if (value != null) {
0: 	    		try {
0: 	    			// call string method
0: 	    			m.invoke(ds, new Object[] {value});
0: 	    		} catch (Throwable ignore) {
0: 	    			// failed, assume it's an integer parameter
0: 	    			m.invoke(ds, new Object[] {Integer.valueOf(value)});
0: 	    		}
0: 	    	}
0:     
1:     /**
1:      * Returns a connection obtained using the DataSource. This method will be called when ij.dataSource
1:      * property is set. It uses ij.dataSource.* properties to get details for the connection. 
1:      * 
1:      * @param dsName Data Source name
1:      * @param user User name
1:      * @param password Password
1:      * @param dbName Database Name
1:      * @param firstTime Indicates if the method is called first time. This is passed to setupDataSource 
1:      * method.
1:      *   
0:      * @return
1:      * @throws SQLException
1:      */
1:     public static Connection getDataSourceConnection(String dsName,String user,String password,
1:     												String dbName,boolean firstTime) throws SQLException{
0: 		// Get a new proxied connection through DataSource
0: 		Object ds = null; // really javax.sql.DataSource
0: 		try {
0: 			
0: 		    Class dc = Class.forName(dsName);
0: 		    ds = dc.newInstance();
0: 		    
0: 		    // set datasource properties
1: 		    setupDataSource(ds,dbName,firstTime);	   
0: 
0: 		    // Java method call "by hand" {  con = ds.getConnection(); }
0: 		    // or con = ds.getConnection(user, password)
0: 		    	
0: 			java.lang.reflect.Method m = 
0: 				user == null ? dc.getMethod("getConnection", null) :
0: 					 dc.getMethod("getConnection", DS_GET_CONN_TYPES);
0: 				
0: 			return (java.sql.Connection) m.invoke(ds,
0: 					 user == null ? null : new String[] {user, password});
0: 		} catch (InvocationTargetException ite)
0: 		{
0: 			if (ite.getTargetException() instanceof SQLException)
0: 				throw (SQLException) ite.getTargetException();
0: 			ite.printStackTrace(System.out);
0: 		} catch (Exception e)
0: 		{
0: 			e.printStackTrace(System.out);
0: 		}
0: 		return null;
0:     }
/////////////////////////////////////////////////////////////////////////
0: 	    
1: 	    //First connection - pass firstTime=true, dbName=null. For database name, 
1: 	    //value in ij.dataSource.databaseName will be used. 
1: 	    con = getDataSourceConnection(dsName,user,password,null,true);
0: 	    return con;
commit:91eacad
/////////////////////////////////////////////////////////////////////////
1: 		if (isJCCFramework())
/////////////////////////////////////////////////////////////////////////
1: 	 * Used to determine if this is a JCC testing framework 
/////////////////////////////////////////////////////////////////////////
1: 	private static boolean isJCCFramework()
1: 			((framework.toUpperCase(Locale.ENGLISH).equals("DERBYNET")) ||
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
0: 		if (isNetFramework())
/////////////////////////////////////////////////////////////////////////
1: 		  { "jdbc:derby://",            "org.apache.derby.jdbc.ClientDriver"},
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Used to determine if this is a network testing framework 
1: 	 * So that retrieveMessages can be sent.  The plan is to have  
1: 	 * ij will retrieve messages by default and not look at the testing 
1: 	 * frameworks. So, ulitmately  this function will look at the driver
1: 	 * rather than the framework.
1: 	 * 
0: 	 * @ return true if the framework contains Net or JCC.
0: 	 */
0: 	private static boolean isNetFramework()
0: 	{
0: 		String framework = util.getSystemProperty("framework");
1: 		return ((framework != null)  &&
0: 			((framework.toUpperCase(Locale.ENGLISH).indexOf("NET") != -1) ||
1: 			 (framework.toUpperCase(Locale.ENGLISH).indexOf("JCC") != -1)));
0: 	}
0: 	
0: 
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.tools.ij;
0: 
0: import org.apache.derby.tools.JDBCDisplayUtil;
0: import org.apache.derby.iapi.tools.i18n.*;
0: 
0: import java.io.BufferedInputStream;
0: import java.io.FileInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.InputStream;
0: import java.io.IOException;
0: 
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.Types;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: import java.util.Stack;
0: import java.math.BigDecimal;
0: 
0: /**
0: 	Methods used to control setup for apps as
0: 	well as display some internal ij structures.
0: 
0: 	@see org.apache.derby.tools.JDBCDisplayUtil
0: 	@author ames
0:  */
0: public class util implements java.security.PrivilegedAction {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private util() {}
0: 
0: 	//-----------------------------------------------------------------
0: 	// Methods for starting up JBMS
0: 
0: 	/**
0: 	 * Find the argument that follows the specified parameter.
0: 	 *
0: 	 *	@param param the parameter (e.g. "-p")
0: 	 *	@param args	the argument list to consider.
0: 	 *
0: 	 *	@return the argument that follows the parameter, or null if not found
0: 	 */
0: 	static public String getArg(String param, String[] args)
0: 	{
0: 		int pLocn;
0: 		Properties p;
0: 
0: 		if (args == null) return null;
0: 
0: 		for (pLocn=0; pLocn<args.length; pLocn++) {
0: 			if (param.equals(args[pLocn])) break;
0: 		}
0: 		if (pLocn >= (args.length-1))  // not found or no file
0: 			return null;
0: 
0: 		return args[pLocn+1];
0: 	}
0: 
0: 	/**
0: 		ij is started with "-p[r] file OtherArgs";
0: 		the file contains properties to control the driver and database
0: 		used to run ij, and can provide additional system properties.
0: 		<p>
0: 		getPropertyArg will look at the args and take out a "-p <file>" pair,
0: 		reading the file into the system properties.
0: 		<p>
0: 		If there was a -p without a following <file>, no action is taken.
0: 
0: 		@exception IOException thrown if file not found
0: 
0: 		@param args	the argument list to consider.
0: 		@return true if a property item was found and loaded.
0: 	 */
0: 	static public boolean getPropertyArg(String[] args) throws IOException {
0: 		String n;
0: 		InputStream in1;
0: 		Properties p;
0: 
0: 		if ((n = getArg("-p", args))!= null){
0: 			in1 = new FileInputStream(n);
0: 			in1 = new BufferedInputStream(in1);
0: 		}
0: 		else if ((n = getArg("-pr", args)) != null) {
0: 			in1 = getResourceAsStream(n);
0: 			if (in1 == null) throw ijException.resourceNotFound();
0: 		}
0: 		else
0: 			return false;
0: 
0: 		p = System.getProperties();
0: 
0: 		// Trim off excess whitespace in property file, if any, and
0: 		// then load those properties into 'p'.
0: 		util.loadWithTrimmedValues(in1, p);
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 		ij is started with "-ca[r] file OtherArgs";
0: 		the file contains connection attibute properties 
0: 		to pass to getConnection
0: 		<p>
0: 		getConnAttributeArg will look at the args and take out a 
0: 		"-ca[r] <file>" pair and returning the Properties
0: 		<p>
0: 
0: 		@exception IOException thrown if file not found
0: 
0: 		@param args	the argument list to consider.
0: 		@return  properties in the file
0: 	 */
0: 	static public Properties getConnAttributeArg(String[] args) 
0: 		throws IOException 
0: 	{
0: 		String n;
0: 		InputStream in1;
0: 		Properties p = new Properties();
0: 
0: 		if ((n = getArg("-ca", args))!= null){
0: 			in1 = new FileInputStream(n);
0: 			in1 = new BufferedInputStream(in1);
0: 		}
0: 		else if ((n = getArg("-car", args)) != null) {
0: 			in1 = getResourceAsStream(n);
0: 			if (in1 == null) throw ijException.resourceNotFound();
0: 		}
0: 		else
0: 			return null;
0: 
0: 		// Trim off excess whitespace in property file, if any, and
0: 		// then load those properties into 'p'.
0: 		util.loadWithTrimmedValues(in1, p);
0: 
0: 		return p;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	  Convenience routine to qualify a resource name with "ij.defaultPackageName"
0: 	  if it is not qualified (does not begin with a "/").
0: 
0: 	  @param absolute true means return null if the name is not absolute and false
0: 	  means return partial names. 
0: 	  */
0: 	static String qualifyResourceName(String resourceName, boolean absolute)
0: 	{
0: 		resourceName=resourceName.trim();
0: 		if (resourceName.startsWith("/"))
0: 		{
0: 			return resourceName;
0: 		}
0: 		else
0: 		{
0: 			String pName = util.getSystemProperty("ij.defaultResourcePackage").trim();
0: 			if (pName == null) return null;
0: 			if ((pName).endsWith("/"))
0: 				resourceName = pName+resourceName;
0: 			else
0: 				resourceName = pName+"/"+resourceName;
0: 			if (absolute && !resourceName.startsWith("/"))
0: 				return null;
0: 			else
0: 				return resourceName;
0: 		}
0: 	}
0: 	/**
0: 	  Convenience routine to get a resource as a BufferedInputStream. If the
0: 	  resourceName is not absolute (does not begin with a "/") this qualifies
0: 	  the name with the "ij.defaultResourcePackage" name.
0: 
0: 	  @param String the name of the resource
0: 	  @return a buffered stream for the resource if it exists and null otherwise.
0: 	  */
0: 	static public InputStream getResourceAsStream(String resourceName) 
0: 	{
0: 		Class c= util.class;
0: 		resourceName = qualifyResourceName(resourceName,true);
0: 		if (resourceName == null) 
0: 			return null;
0: 		InputStream is = c.getResourceAsStream(resourceName);
0: 		if (is != null) 
0: 			is = new BufferedInputStream(is, utilMain.BUFFEREDFILESIZE);
0: 		return is;
0: 	}
0: 
0: 	/**
0: 	  Return the name of the ij command file or null if none is
0: 	  specified. The command file may be proceeded with -f flag on
0: 	  the command line. Alternatively, the command file may be 
0: 	  specified without a -f flag. In this case we assume the first
0: 	  unknown argument is the command file.
0: 
0: 	  <P>
0: 	  This should only be called after calling invalidArgs.
0: 
0: 	  <p>
0: 	  If there is no such argument, a null is returned.
0: 
0: 	  @param args	the argument list to consider.
0: 	  @return the name of the first argument not preceded by "-p",
0: 	  null if none found.
0: 	  
0: 	  @exception IOException thrown if file not found
0: 	 */
0: 	static public String getFileArg(String[] args) throws IOException {
0: 		String fileName;
0: 		int fLocn;
0: 		boolean foundP = false;
0: 
0: 		if (args == null) return null;
0: 		if ((fileName=getArg("-f",args))!=null) return fileName;
0: 		//
0: 		//The first unknown arg is the file
0: 		for (int ix=0; ix < args.length; ix++)
0: 			if(args[ix].equals("-f")  ||
0: 			   args[ix].equals("-fr") ||
0: 			   args[ix].equals("-ca")  ||
0: 			   args[ix].equals("-car")  ||
0: 			   args[ix].equals("-p")  ||
0: 			   args[ix].equals("-pr"))
0: 				ix++; //skip the parameter to these args
0: 			else
0: 				return args[ix];
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	  Return the name of a resource containing input commands or
0: 	  null iff none has been specified.
0: 	  */
0:  	static public String getInputResourceNameArg(String[] args) {
0: 		return getArg("-fr", args);
0: 	}
0: 
0: 	/**
0: 	  Verify the ij line arguments command arguments.
0: 	  @return true if the args are invalid
0: 	  <UL>
0: 	  <LI>Only legal argument provided.
0: 	  <LI>Only specify a quantity once.
0: 	  </UL>
0: 	 */
0: 	static public boolean invalidArgs(String[] args, boolean gotProp, String file,
0: 									   String inputResourceName) {
0: 		int countSupported = 0;
0: 		boolean haveInput = false;
0: 		for (int ix=0; ix < args.length; ix++)
0: 		{
0: 			//
0: 			//If the arguemnt is a supported flag skip the flags argument
0: 			if(!haveInput && (args[ix].equals("-f") || args[ix].equals("-fr")))
0: 			{
0: 				haveInput = true;
0: 				ix++;
0: 				if (ix >= args.length) return true;
0: 			}
0: 
0: 			else if ((args[ix].equals("-p") || args[ix].equals("-pr") ||
0: 					  args[ix].equals("-ca") || args[ix].equals("-car") ))
0: 			{
0: 				// next arg is the file/resource name
0: 				ix++;
0: 				if (ix >= args.length) return true;
0: 			}
0: 
0: 
0: 			//
0: 			//Assume the first unknown arg is a file name.
0: 			else if (!haveInput)
0: 			{
0: 				haveInput = true;
0: 			}
0: 
0: 			else
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * print a usage message for invocations of main().
0: 	 */
0: 	static void Usage(LocalizedOutput out) {
0:      	out.println(
0: 		LocalizedResource.getMessage("IJ_UsageJavaComCloudToolsIjPPropeInput"));
0: 		out.flush();
0:    	}
0: 
0: 
0:     private static final Class[] STRING_P = { "".getClass() };
0:     private static final Class[] INT_P = { Integer.TYPE };
0: 
0: 
0:     static public void setupDataSource(Object ds) throws Exception {
0: 	// Loop over set methods on Datasource object, if there is a property
0: 	// then call the method with corresponding value.
0: 	java.lang.reflect.Method[] methods = ds.getClass().getMethods();
0: 	for (int i = 0; i < methods.length; i++) {
0: 	    java.lang.reflect.Method m = methods[i];
0: 	    String name = m.getName();
0: 	    if (name.startsWith("set") && (name.length() > "set".length())) {
0: 		String property = name.substring("set".length()); // setXyyyZwww
0: 		property = "ij.dataSource."+property.substring(0,1).toLowerCase(java.util.Locale.ENGLISH)+ property.substring(1); // xyyyZwww
0: 		String value = util.getSystemProperty(property);
0: 		//System.out.println("setupDateSource: method="+name+" property="+property+" value="+((value==null)?"null":value));
0: 		if (value != null) {
0: 		    try {
0: 			// call string method
0: 			m.invoke(ds, new Object[] {value});
0: 		    } catch (Throwable ignore) {
0: 			// failed, assume it's an integer parameter
0: 			m.invoke(ds, new Object[] {Integer.valueOf(value)});
0: 		    }
0: 		}
0: 	    }
0: 	}
0:     }
0: 
0: 	/**
0: 		This will look for the System properties "ij.driver" and "ij.database"
0: 		and return a java.sql.Connection if it successfully connects.
0: 		The deprecated driver and database properties are examined first.
0: 		<p>
0: 		If no connection was possible, it will return a null.
0: 		<p>
0: 		Failure to load the driver class is quietly ignored.
0: 
0: 		@param defaultDriver the driver to use if no property value found
0: 		@param defaultURL the database URL to use if no property value found
0: 		@param connInfo Connection attributes to pass to getConnection
0: 		@return a connection to the defaultURL if possible; null if not.
0: 		@exception SQLException on failure to connect.
0: 		@exception ClassNotFoundException on failure to load driver.
0: 		@exception InstantiationException on failure to load driver.
0: 		@exception IllegalAccessException on failure to load driver.
0: 	 */
0:     static public Connection startJBMS(String defaultDriver, String defaultURL,
0: 				       Properties connInfo) 
0: 	throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException
0:     {
0: 	Connection con = null;
0:         String driverName;
0:         String databaseURL;
0: 
0: 	// deprecate the non-ij prefix.  actually, we should defer to jdbc.drivers...
0:         driverName = util.getSystemProperty("driver");
0:         if (driverName == null) driverName = util.getSystemProperty("ij.driver");
0: 	if (driverName == null || driverName.length()==0) driverName = defaultDriver;
0:         if (driverName != null) {
0: 	    util.loadDriver(driverName);
0: 	}
0: 
0: 	String jdbcProtocol = util.getSystemProperty("ij.protocol");
0: 	if (jdbcProtocol != null)
0: 	    util.loadDriverIfKnown(jdbcProtocol);
0: 
0: 	// deprecate the non-ij prefix name
0: 	databaseURL = util.getSystemProperty("database");
0: 	if (databaseURL == null) databaseURL = util.getSystemProperty("ij.database");
0: 	if (databaseURL == null || databaseURL.length()==0) databaseURL = defaultURL;
0: 	if (databaseURL != null) {
0: 	    // add protocol if might help find driver.
0: 	    boolean noDriver = false;
0: 	    try {
0: 		// if have full URL, load driver for it
0: 		if (databaseURL.startsWith("jdbc:"))
0: 		    util.loadDriverIfKnown(databaseURL);
0: 		DriverManager.getDriver(databaseURL);
0: 	    } catch (SQLException se) {
0: 		noDriver = true;
0: 	    }
0: 	    if (noDriver && jdbcProtocol != null)
0: 		databaseURL = jdbcProtocol+databaseURL;
0: 
0: 	    String user = util.getSystemProperty("ij.user");
0: 	    String password = util.getSystemProperty("ij.password");
0: 
0: 	    // Update connInfo for ij system properties and
0: 	    // framework network server
0: 
0: 	    connInfo = updateConnInfo(user, password,connInfo);
0: 
0: 	    // JDBC driver
0: 	    String driver = System.getProperty("driver");
0: 	    if (driver == null) {
0: 		driver = "org.apache.derby.jdbc.EmbeddedDriver";
0: 	    }
0: 
0: 	    // handle datasource property
0: 	    String dsName = System.getProperty("ij.dataSource");
0: 	    if (dsName == null) {
0: 		loadDriver(driver);
0: 		con = DriverManager.getConnection(databaseURL,connInfo);
0: 		return con;
0: 
0: 	    } else { // a datasource
0: 		// Get a new proxied connection through DataSource
0: 		Object ds = null; // really javax.sql.DataSource
0: 		try {
0: 		    Class dc = Class.forName(dsName);
0: 		    ds = dc.newInstance();
0: 		    
0: 		    // set datasource properties
0: 		    setupDataSource(ds);
0: 
0: 		    // Java method call "by hand" {  con = ds.getConnection(); }
0: 		    {
0: 			java.lang.reflect.Method m = dc.getMethod("getConnection", null); 
0: 			con = (java.sql.Connection) m.invoke(ds, new Object[] {});
0: 		    }
0: 		} catch (Throwable error) {
0: 		    error.printStackTrace(System.out);
0: 		}
0: 		return con;
0: 	    } // datasource
0: 	}
0: 	// failed
0: 	return null;
0:     }
0: 
0: 
0: 	public static Properties updateConnInfo(String user, String password, Properties connInfo)
0: 	{
0: 		String framework = util.getSystemProperty("framework");
0: 		String ijGetMessages = util.getSystemProperty("ij.retrieveMessagesFromServerOnGetMessage");
0: 		boolean retrieveMessages = false;
0: 		
0: 		
0: 		// For JCC make sure we set it to retrieve messages
0: 		if (framework != null  && ((framework.equals("DB2jNet") 
0: 									|| framework.equals("DB2jcc"))))
0: 			retrieveMessages = true;
0: 		
0: 		if (ijGetMessages != null)
0: 		{
0: 			if (ijGetMessages.equals("false"))
0: 				retrieveMessages = false;
0: 			else
0: 				retrieveMessages = true;
0: 			
0: 		}
0: 		
0: 		if (connInfo == null)
0: 			connInfo = new Properties();
0: 		
0: 		if (retrieveMessages == true)
0: 		{
0: 			connInfo.put("retrieveMessagesFromServerOnGetMessage",
0: 						 "true");
0: 		}
0: 		if (user != null)
0: 			connInfo.put("user",user);
0: 		if (password != null)
0: 			connInfo.put("password", password);
0: 		
0: 		return connInfo;
0: 	}
0: 
0: 	/**
0: 		Utility interface that defaults driver and database to null.
0: 
0: 		@return a connection to the defaultURL if possible; null if not.
0: 		@exception SQLException on failure to connect.
0: 		@exception ClassNotFoundException on failure to load driver.
0: 		@exception InstantiationException on failure to load driver.
0: 		@exception IllegalAccessException on failure to load driver.
0: 	 */
0:     static public Connection startJBMS() throws SQLException, ClassNotFoundException, InstantiationException, IllegalAccessException {
0: 		return startJBMS(null,null);
0: 	}
0: 	
0: 	/**
0: 	   Utility interface that defaults connInfo to null
0: 	   <p>
0: 
0: 
0: 		@param defaultDriver the driver to use if no property value found
0: 		@param defaultURL the database URL to use if no property value found
0: 		@return a connection to the defaultURL if possible; null if not.
0: 		@exception SQLException on failure to connect.
0: 		@exception ClassNotFoundException on failure to load driver.
0: 		@exception InstantiationException on failure to load driver.
0: 		@exception IllegalAccessException on failure to load driver.
0: 	 */
0:     static public Connection startJBMS(String defaultDriver, String defaultURL) 
0: 			throws SQLException, ClassNotFoundException, InstantiationException,
0: 				   IllegalAccessException {
0: 		return startJBMS(defaultDriver,defaultURL,null);
0: 		
0: 	}
0: 	//-----------------------------------------------------------------
0: 	// Methods for displaying and checking results
0: 	// See org.apache.derby.tools.JDBCDisplayUtil for more general displays.
0: 
0: 
0: 	/**
0: 		Display a vector of strings to the out stream.
0: 	 */
0: 	public static void DisplayVector(LocalizedOutput out, Vector v) {
0: 		int l = v.size();
0: 		for (int i=0;i<l;i++)
0: 			out.println(v.elementAt(i));
0: 	}
0: 
0: 	/**
0: 		Display a vector of statements to the out stream.
0: 	public static void DisplayVector(AppStreamWriter out, Vector v, Connection conn) throws SQLException {
0: 		int l = v.size();
0: AppUI.out.println("SIZE="+l);
0: 		for (int i=0;i<l;i++) {
0: 			Object o = v.elementAt(i);
0: 			if (o instanceof Integer) { // update count
0: 				JDBCDisplayUtil.DisplayUpdateCount(out,((Integer)o).intValue());
0: 			} else { // o instanceof ResultSet
0: 			    JDBCDisplayUtil.DisplayResults(out,(ResultSet)o,conn);
0: 				((ResultSet)o).close(); // release the result set
0: 			}
0: 		}
0: 	}
0: 	 */
0: 
0: 	/**
0: 		Display a statement that takes parameters by
0: 		stuffing it with rows from the result set and
0: 		displaying each result each time through.
0: 		Deal with autocommit behavior along the way.
0: 
0: 		@exception SQLException thrown on db error
0: 		@exception ijException thrown on ij error
0: 	 */
0: 	public static void DisplayMulti(LocalizedOutput out, PreparedStatement ps,
0: 		ResultSet rs, Connection conn) throws SQLException, ijException {
0: 
0: 		boolean autoCommited = false; // mark if autocommit in place
0: 		boolean exec = false; // mark the first time through
0: 		boolean anotherUsingRow = false;	// remember if there's another row 
0: 											// from using.
0: 		ResultSetMetaData rsmd = rs.getMetaData();
0: 		int numCols = rsmd.getColumnCount();
0: 
0: 		/* NOTE: We need to close the USING RS first
0: 		 * so that RunTimeStatistic gets info from
0: 		 * the user query.
0: 		 */
0: 		anotherUsingRow = rs.next();
0: 
0: 		while (! autoCommited && anotherUsingRow) {
0: 			// note the first time through
0: 			if (!exec) {
0: 				exec = true;
0: 
0: 				// send a warning if additional results may be lost
0: 				if (conn.getAutoCommit()) {
0: 					out.println(LocalizedResource.getMessage("IJ_IjWarniAutocMayCloseUsingResulSet"));
0: 					autoCommited = true;
0: 				}
0: 			}
0: 
0: 			// We need to make sure we pass along the scale, because
0: 			// setObject assumes a scale of zero (beetle 4365)
0: 			for (int c=1; c<=numCols; c++) {
0: 				ps.setObject(c,rs.getObject(c),
0: 					 rsmd.getColumnType(c),
0: 					 rsmd.getScale(c));
0: 			}
0: 
0: 
0: 			// Advance in the USING RS
0: 			anotherUsingRow = rs.next();
0: 			// Close the USING RS when exhausted and appropriate
0: 			// NOTE: Close before the user query
0: 			if (! anotherUsingRow || conn.getAutoCommit()) //if no more rows or if auto commit is on, close the resultset
0: 			{
0: 				rs.close();
0: 			}
0: 
0: 			/*
0: 				4. execute the statement against those parameters
0: 			 */
0: 
0: 			ps.execute();
0: 			JDBCDisplayUtil.DisplayResults(out,ps,conn);
0: 
0: 			/*
0: 				5. clear the parameters
0: 			 */
0: 			ps.clearParameters();
0: 		}
0: 		if (!exec) {
0: 			rs.close(); //this means, using clause didn't qualify any rows. Just close the resultset associated with using clause
0: 			throw ijException.noUsingResults();
0: 		}
0: 		// REMIND: any way to look for more rsUsing rows if autoCommit?
0: 		// perhaps just document the behavior... 
0: 	}
0: 
0: 	public static final String getSystemProperty(String propertyName) {
0: 		try
0: 		{
0: 			if (propertyName.startsWith("ij.") || propertyName.startsWith("derby."))
0: 			{
0: 				util u = new util();
0: 				u.key = propertyName;
0: 				return (String) java.security.AccessController.doPrivileged(u);
0: 			}
0: 			else
0: 			{
0: 				return System.getProperty(propertyName);
0: 			}
0: 		} catch (SecurityException se) {
0: 			return null;
0: 		}
0: 	}
0: 
0: 	private String key;
0: 
0: 	public final Object run() {
0: 		return System.getProperty(key);
0: 	}
0: 	/** 
0: 	 * Read a set of properties from the received input stream, strip
0: 	 * off any excess white space that exists in those property values,
0: 	 * and then add those newly-read properties to the received
0: 	 * Properties object; not explicitly removing the whitespace here can
0: 	 * lead to problems.
0: 	 *
0: 	 * This method exists because of the manner in which the jvm reads
0: 	 * properties from file--extra spaces are ignored after a _key_, but
0: 	 * if they exist at the _end_ of a property decl line (i.e. as part
0: 	 * of a _value_), they are preserved, as outlined in the Java API:
0: 	 *
0: 	 * "Any whitespace after the key is skipped; if the first non-
0: 	 * whitespace character after the key is = or :, then it is ignored
0:  	 * and any whitespace characters after it are also skipped. All
0: 	 * remaining characters on the line become part of the associated
0: 	 * element string."
0: 	 *
0: 	 * @param iStr: An input stream from which the new properties are to be
0: 	 *  loaded (should already be initialized).
0: 	 * @param prop: A set of properties to which the properties from
0: 	 *  iStr will be added (should already be initialized).
0: 	 * @return A final properties set consisting of 'prop' plus all
0: 	 * properties loaded from 'iStr' (with the extra whitespace (if any)
0: 	 *  removed from all values), will be returned via the parameter.
0: 	 *
0: 		Copied here to avoid dependency on an engine class.
0: 	 **/
0: 	private static void loadWithTrimmedValues(InputStream iStr,
0: 		Properties prop) throws IOException {
0: 
0: 		// load the properties from the received input stream.
0: 		Properties p = new Properties();
0: 		p.load(iStr);
0: 
0: 		// Now, trim off any excess whitespace, if any, and then
0: 		// add the properties from file to the received Properties
0: 		// set.
0: 		for (java.util.Enumeration propKeys = p.propertyNames();
0: 		  propKeys.hasMoreElements();) {
0: 		// get the value, trim off the whitespace, then store it
0: 		// in the received properties object.
0: 			String tmpKey = (String)propKeys.nextElement();
0: 			String tmpValue = p.getProperty(tmpKey);
0: 			tmpValue = tmpValue.trim();
0: 			prop.put(tmpKey, tmpValue);
0: 		}
0: 
0: 		return;
0: 
0: 	}
0: 
0: 	private static final String[][] protocolDrivers =
0: 		{
0: 		  { "jdbc:derby:net:",			"com.ibm.db2.jcc.DB2Driver"},
0: 		  { "jdbc:derby:",				"org.apache.derby.jdbc.EmbeddedDriver" },
0: 		};
0: 
0: 	/**
0: 		Find the appropriate driver and load it, given a JDBC URL.
0: 		No action if no driver known for a given URL.
0: 
0: 		@param jdbcProtocol the protocol to try.
0: 
0: 		@exception ClassNotFoundException if unable to
0: 			locate class for driver.
0: 		@exception InstantiationException if unable to
0: 			create an instance.
0: 		@exception IllegalAccessException if driver class constructor not visible.
0: 	 */
0: 	public static void loadDriverIfKnown(String jdbcProtocol) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
0: 		for (int i=0; i < protocolDrivers.length; i++) {
0: 			if (jdbcProtocol.startsWith(protocolDrivers[i][0])) {
0: 				loadDriver(protocolDrivers[i][1]);
0: 				break; // only want the first one
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Load a driver given a class name.
0: 
0: 		@exception ClassNotFoundException if unable to
0: 			locate class for driver.
0: 		@exception InstantiationException if unable to
0: 			create an instance.
0: 		@exception IllegalAccessException if driver class constructor not visible.
0: 	 */
0: 	public static void loadDriver(String driverClass) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
0:         Class.forName(driverClass).newInstance();
0: 	}
0: }
============================================================================