1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.DataType
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
11:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:4ecfb0e: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:4ecfb0e: import java.io.IOException;
1:9548d38: import java.math.BigDecimal;
1:75a4806: import java.sql.Blob;
1:75a4806: import java.sql.Clob;
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.ResultSet;
1:eac0369: 
1:eac0369: import java.util.Calendar;
1:eac0369: 
6:eac0369: /**
31:eac0369:  *
1:eac0369:  * DataType is the superclass for all data types. 
1:eac0369:  * It provides common behavior
1:eac0369:  * for datavalue descriptors -- it throws
1:eac0369:  * exceptions for all of the get* and setvalue(*)  methods of
1:eac0369:  * DataValueDescriptor; the subtypes need only
1:eac0369:  * override the one for the type they represent
1:eac0369:  * and all types it can also be returned as,
1:eac0369:  * and the methods dealing with nulls.
1:eac0369:  *
1:eac0369:  * Since all types satisfy getString 
1:eac0369:  * DataType does not define that
1:eac0369:  * interfaces of DataValueDescriptor.
1:eac0369:  *
1:eac0369:  * DataType is a little glue for columns to hold
1:eac0369:  * values with.
1:eac0369:  *
1:eac0369:  */
1:eac0369: public abstract class DataType
1:b4e2eb7:     implements DataValueDescriptor, Comparable
6:eac0369: {
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor Interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a boolean.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a boolean.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a boolean.
1:eac0369: 	 *
4:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean	getBoolean() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("boolean");
5:eac0369: 	}
1:eac0369: 
1:f73afdc: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a byte.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a byte.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a byte.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public byte	getByte() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("byte");
1:eac0369: 	}
1:eac0369: 
1:bb67ebd: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a short.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a short.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a short.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public short	getShort() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("short");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a int.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a int.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a int.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public int	getInt() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("int");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a long.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a long.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a long.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public long	getLong() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("long");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a float.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a float.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a float.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public float	getFloat() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("float");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a double.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a double.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a double.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public double	getDouble() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("double");
1:eac0369: 	}
1:eac0369: 
1:2c6f0a2: 	public int typeToBigDecimal() throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		throw dataTypeConversion("java.math.BigDecimal");
1:2c6f0a2: 	}
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a byte[].
1:eac0369: 	 * Throws an exception if the data value is not receivable as a Binary or Varbinary.
1:eac0369: 	 *
1:eac0369: 	 * @return	The Binary value as a byte[].
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public byte[]	getBytes() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("byte[]");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Date.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a Date.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 * @return	The data value as a java.sql.Date.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Date	getDate( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Date");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Time.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a Time.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 * @return	The data value as a java.sql.Time.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Time	getTime( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Time");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a Timestamp.
1:eac0369:      *	@param cal calendar for object creation
1:eac0369: 	 * @return	The data value as a java.sql.Timestamp.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Timestamp");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data stream descriptor as an InputStream.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a stream.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as an InputStream.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public InputStream	getStream() throws StandardException
1:eac0369: 	{
1:043a571: 		throw dataTypeConversion( "InputStream" );
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:541361f:      * Tells that the value isn't represented as a stream, which is true for
1:541361f:      * most Derby data types.
1:541361f:      * <p>
1:541361f:      * This method will be overridden by types able to use a stream as the
1:541361f:      * source.
1:541361f:      *
1:541361f:      * @return {@code false}
1:541361f:      */
1:541361f:     public boolean hasStream() {
1:541361f:         return false;
1:541361f:     }
1:541361f: 
1:541361f:     /**
1:f73afdc:      * Gets the value in the data stream descriptor as a trace string.
1:f73afdc:      * This default implementation simply forwards the call to
1:f73afdc:      * <code>getString</code>.
1:f73afdc:      *
1:f73afdc:      * @return The data value in a representation suitable for tracing.
1:f73afdc:      * @throws StandardException if getting the data value fails.
1:f73afdc:      * @see DataValueDescriptor#getString
1:f73afdc:      */
1:f73afdc:     public String getTraceString() throws StandardException {
1:f73afdc:         return getString();  
1:f73afdc:     }
1:f73afdc: 
1:109cb26:     /**
1:109cb26:      * Recycle this DataType object.
1:109cb26:      *
1:109cb26:      * @return this object with value set to null
1:109cb26:      */
1:109cb26:     public DataValueDescriptor recycle() {
1:109cb26:         restoreToNull();
1:109cb26:         return this;
1:109cb26:     }
1:109cb26: 
1:4ecfb0e:     /**
1:4ecfb0e:      * Read the DataValueDescriptor from the stream. The default implementation
1:4ecfb0e:      * calls {@code readExternal()}, which accesses the {@code ArrayInputStream}
1:4ecfb0e:      * as a generic stream. If sub-classes can implement it more efficiently
1:4ecfb0e:      * by accessing the array, they should override this method.
1:4ecfb0e:      *
1:4ecfb0e:      * @see DataValueDescriptor#readExternalFromArray
1:4ecfb0e:      * @see java.io.Externalizable#readExternal
1:4ecfb0e:      */
1:4ecfb0e:     public void readExternalFromArray(ArrayInputStream in)
1:4ecfb0e:             throws IOException, ClassNotFoundException {
1:4ecfb0e:         readExternal(in);
1:4ecfb0e:     }
1:4ecfb0e: 
1:eac0369: 	/*
1:eac0369: 	 * Column interface
1:eac0369: 	 */
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * The is null operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the operand is null
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue isNullOp()
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(isNull());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The is not null operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the operand is not null
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public final BooleanDataValue isNotNull()
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(!isNull());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Set the value of this DataValueDescriptor.
2:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:eac0369: 	 */
1:eac0369: 	public void setValue(Time theValue) throws StandardException
1:eac0369: 	{
1:eac0369:         setValue( theValue, (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database time value
1:eac0369: 	 */
1:eac0369: 	public void setValue(Time theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Time");
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp theValue) throws StandardException
1:eac0369: 	{
1:eac0369:         setValue( theValue, (Calendar) null);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database timestamp value
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Timestamp");
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date theValue) throws StandardException
1:eac0369: 	{
1:eac0369:         setValue( theValue, (Calendar) null);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:eac0369:      * @param cal The time zone from the calendar is used to construct the database date value
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Date");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:33bfdc0: 	 * @param theValue	The Object value to set this DataValueDescriptor to
1:33bfdc0: 	 */
1:33bfdc0: 	public void setValue(Object theValue) throws StandardException
1:33bfdc0: 	{
1:33bfdc0: 		throwLangSetMismatch("java.lang.Object");
1:33bfdc0: 	}
1:33bfdc0: 
1:33bfdc0: 	/**
1:33bfdc0: 	 * Set the value of this DataValueDescriptor.
1:33bfdc0: 	 * At DataType level just throws an error lower classes will override
1:33bfdc0: 	 *
2:eac0369: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
1:eac0369: 	 */
1:eac0369: 	public void setValue(String theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.lang.String");
1:eac0369: 	}
1:eac0369: 
1:75a4806: 	/**
1:75a4806: 	 * Set the value of this DataValueDescriptor.
1:75a4806: 	 * At DataType level just throws an error lower classes will override
1:75a4806: 	 *
1:75a4806: 	 * @param theValue	The Blob value to set this DataValueDescriptor to
1:75a4806: 	 */
1:75a4806: 	public void setValue(Blob theValue) throws StandardException
1:75a4806: 	{
1:75a4806: 		throwLangSetMismatch("java.sql.Blob");
1:75a4806: 	}
1:75a4806:  
1:75a4806: 	/**
1:75a4806: 	 * Set the value of this DataValueDescriptor.
1:75a4806: 	 * At DataType level just throws an error lower classes will override
1:75a4806: 	 *
1:75a4806: 	 * @param theValue	The Clob value to set this DataValueDescriptor to
1:75a4806: 	 */
1:75a4806: 	public void setValue(Clob theValue) throws StandardException
1:75a4806: 	{
1:75a4806: 		throwLangSetMismatch("java.sql.Clob");
1:75a4806: 	}
1:75a4806: 
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given int value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(int theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("int");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given double value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(double theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("double");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given float value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(float theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("float");
1:eac0369: 	}
1:eac0369:  
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given short value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(short theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("short");
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given long value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(long theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("long");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor to the given byte value
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(byte theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("byte");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	Contains the boolean value to set this to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(boolean theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("boolean");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this DataValueDescriptor.
1:eac0369: 	 * At DataType level just throws an error lower classes will override
1:eac0369: 	 *
1:eac0369: 	 * @param theValue	The byte value to set this DataValueDescriptor to
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(byte[] theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("byte[]");
1:eac0369: 	}
1:eac0369: 
1:d7f7457: 	/**
1:d7f7457: 		Only to be called when the application sets a value using BigDecimal
1:d7f7457: 	*/
1:9548d38: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
1:d7f7457: 	{
1:d7f7457: 		throwLangSetMismatch("java.math.BigDecimal");
1:d7f7457: 	}
1:d7f7457: 
1:eac0369: 
1:eac0369: 	public final void setValue(DataValueDescriptor dvd) throws StandardException {
1:eac0369: 
1:eac0369: 		if (dvd.isNull())
1:eac0369: 		{
2:eac0369: 			setToNull();
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			setFrom(dvd);
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			String msgId = se.getMessageId();
1:eac0369: 
1:eac0369: 			if (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE.equals(msgId))
1:eac0369: 				throw outOfRange();
1:eac0369: 
1:eac0369: 			if (SQLState.LANG_FORMAT_EXCEPTION.equals(msgId))
1:eac0369: 				throw invalidFormat();
1:eac0369: 
1:eac0369: 			throw se;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:bb67ebd: 	 * Set the value of this DataValueDescriptor based on the value
1:bb67ebd: 	 * of the specified DataValueDescriptor.
1:bb67ebd: 	 *
1:bb67ebd: 	 * @param dvd	The DataValueDescriptor that holds the value to
1:bb67ebd: 	 *  which we want to set this DataValueDescriptor's value.
1:bb67ebd: 	 *
1:bb67ebd: 	 */
1:eac0369: 	protected void setFrom(DataValueDescriptor dvd) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.NOT_IMPLEMENTED);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#setToNull
1:eac0369: 	 */
1:eac0369: 	 public void setToNull()
1:eac0369: 	 {
1:eac0369: 	 	restoreToNull();
1:eac0369: 	 }
1:eac0369: 
1:eac0369: 	/**
1:806114c: 	 * @see DataValueDescriptor#setObjectForCast
1:806114c: 	 * 
1:806114c: 	 * @exception StandardException
1:806114c: 	 *                thrown on failure
1:806114c: 	 * 
1:eac0369: 	 */
1:806114c: 	public void setObjectForCast(Object theValue, boolean instanceOfResultType,
1:806114c: 			String resultTypeClassName) throws StandardException {
1:806114c: 		
1:806114c: 		if (theValue == null)
1:806114c: 		{
1:806114c: 			setToNull();
1:806114c: 			return;
1:806114c: 		}
1:806114c: 			
1:806114c: 		/*
1:806114c: 		 * Is the object of the right type? (only do the check if value is
1:806114c: 		 * non-null
1:806114c: 		 */
1:806114c: 		if (!instanceOfResultType) {
1:806114c: 				throw StandardException.newException(
1:806114c: 						SQLState.LANG_DATA_TYPE_SET_MISMATCH,
1:806114c: 						theValue.getClass().getName(), getTypeName(resultTypeClassName));
1:806114c: 		}
1:eac0369: 
1:806114c: 		setObject(theValue);
1:806114c: 	}
1:806114c: 		
1:eac0369: 	/**
1:806114c: 	 * Set the value from an non-null object. Usually overridden.
1:806114c: 	 * This implementation throws an exception.
1:806114c: 	 * The object will have been correctly typed from the call to setObjectForCast.
1:806114c: 	 */
1:806114c: 	void setObject(Object theValue)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:806114c: 		genericSetObject(theValue);
1:eac0369: 	}
1:806114c: 	
1:806114c: 	/**
1:806114c: 	 * Get the type name of this value, possibly overriding
1:806114c: 	 * with the passed in class name (for user/java types).
1:806114c: 	 * @param className
1:806114c: 	 */
1:806114c: 	String getTypeName(String className)
1:806114c: 	{
1:806114c: 		return getTypeName();
1:806114c: 	}
1:806114c: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the value in the data value descriptor as a int.
1:eac0369: 	 * Throws an exception if the data value is not receivable as a int.
1:eac0369: 	 *
1:eac0369: 	 * @return	The data value as a int.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Object	getObject() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.lang.Object");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:806114c: 	void genericSetObject(Object theValue) throws StandardException {
1:eac0369: 
1:806114c: 		throwLangSetMismatch(theValue);
1:eac0369: 	}
1:eac0369: 
1:b4e2eb7:     /**
1:b4e2eb7:      * Default implementation of shallow cloning, which forwards to the deep
1:b4e2eb7:      * clone method.
1:b4e2eb7:      * <p>
1:b4e2eb7:      * For many of the data types, a shallow clone will be the same as a deep
1:b4e2eb7:      * clone. The data types requiring special handling of shallow clones have
1:b4e2eb7:      * to override this method (for instance types whose value can be
1:b4e2eb7:      * represented as a stream).
1:b4e2eb7:      *
1:b4e2eb7:      * @return A shallow clone.
1:b4e2eb7:      */
1:9495437:     public DataValueDescriptor cloneHolder() {
1:854dd10: 		return cloneValue(false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void throwLangSetMismatch(Object value) throws StandardException {
1:eac0369: 		throwLangSetMismatch(value.getClass().getName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void throwLangSetMismatch(String argTypeName) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, 
1:eac0369: 									   argTypeName, this.getTypeName());
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1:eac0369: 
1:eac0369: 		ps.setObject(position, getObject());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
1:eac0369: 		or ResultSet.updateRow. This method will only be called for non-null values.
1:eac0369: 
1:eac0369: 		@exception SQLException thrown by the ResultSet object
1:eac0369: 		@exception StandardException thrown by me accessing my value.
1:eac0369: 	*/
1:eac0369: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException {
1:eac0369: 		rs.updateObject(position, getObject());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Default normalization method. No information needed from DataTypeDescriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param desiredType	The type to normalize the source column to
1:eac0369: 	 * @param source		The value to normalize
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException				Thrown normalization error.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void normalize(
1:eac0369: 				DataTypeDescriptor desiredType,
1:eac0369: 				DataValueDescriptor source)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		((DataValueDescriptor) this).setValue(source);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
1:eac0369: 	 * how to do type promotion when using binary operators.  For example, float
1:eac0369: 	 * has a higher precedence than int, so when adding an int to a float, the
1:eac0369: 	 * result type is float.
1:eac0369: 	 *
1:eac0369: 	 * The precedence for some types is arbitrary.  For example, it doesn't
1:eac0369: 	 * matter what the precedence of the boolean type is, since it can't be
1:eac0369: 	 * mixed with other types.  But the precedence for the number types is
1:eac0369: 	 * critical.  The SQL standard requires that exact numeric types be
1:eac0369: 	 * promoted to approximate numeric when one operator uses both.  Also,
1:eac0369: 	 * the precedence is arranged so that one will not lose precision when
1:eac0369: 	 * promoting a type.
1:eac0369: 	 *
1:eac0369: 	 * @return		The precedence of this type.
1:eac0369: 	 */
1:eac0369: 	public int					typePrecedence() {
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The = operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module. This default implementations uses compare().
1:eac0369: 	 *
1:eac0369: 	 * @param left			The value on the left side of the =
1:eac0369: 	 * @param right			The value on the right side of the =
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue equals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(right) == 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module. This default implementations uses compare().
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the &lt;&gt;
1:dbed020: 	 * @param right			The value on the right side of the &lt;&gt;
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters
1:eac0369: 	 *			are not equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(right) != 0);
1:eac0369: 	}
1:eac0369: 	/**
1:dbed020: 	* The &lt; operator as called from the language module, as opposed to
1:eac0369: 	* the storage module.
1:eac0369: 	*
1:dbed020: 	* @param left   The value on the left side of the &lt;
1:dbed020: 	* @param right   The value on the right side of the &lt;
1:eac0369: 	*
1:eac0369: 	* @return A SQL boolean value telling whether the first operand is less
1:eac0369: 	*   than the second operand
1:eac0369: 	*
1:eac0369: 	* @exception StandardException  Thrown on error
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1:eac0369: 	   DataValueDescriptor right)
1:eac0369: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 		  right,
1:eac0369: 		  left.compare(right) < 0);
1:eac0369: 	}
1:eac0369: 	/**
1:dbed020: 	 * The &gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module. This default implementations uses compare().
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the &gt;
1:dbed020: 	 * @param right			The value on the right side of the &gt;
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is greater
1:eac0369: 	 *			than the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(right) > 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module. This default implementations uses compare().
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the &lt;=
1:dbed020: 	 * @param right			The value on the right side of the &lt;=
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is less
1:eac0369: 	 *			than or equal to the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(right) <= 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &gt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module. This default implementation uses compare().
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the &gt;=
1:dbed020: 	 * @param right			The value on the right side of the &gt;=
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the first operand is greater
1:eac0369: 	 *			than or equal to the second operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1:eac0369: 							DataValueDescriptor right)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		return SQLBoolean.truthValue(left,
1:eac0369: 									 right,
1:eac0369: 									 left.compare(right) >= 0);
1:eac0369: 	}
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, flipping the operator
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return other.compare(flip(op), this, orderedNulls, unknownRV);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int result = compare(other);
1:eac0369: 
1:eac0369: 		switch(op)
1:eac0369: 		{
1:eac0369: 		case ORDER_OP_LESSTHAN:
1:eac0369: 			return (result < 0);   // this <  other
1:eac0369: 		case ORDER_OP_EQUALS:
1:eac0369: 			return (result == 0);  // this == other
1:eac0369: 		case ORDER_OP_LESSOREQUALS:
1:eac0369: 			return (result <= 0);  // this <= other
1:eac0369: 		// flipped operators
1:eac0369: 		case ORDER_OP_GREATERTHAN:
1:eac0369: 			return (result > 0);   // this > other
1:eac0369: 		case ORDER_OP_GREATEROREQUALS:
1:eac0369: 			return (result >= 0);  // this >= other
1:eac0369: 		default:
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.THROWASSERT("Invalid Operator");
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cc30c0c: 	 * Compare this Orderable with another, with configurable null ordering.
1:cc30c0c: 	 * The caller gets to determine how nulls
1:cc30c0c: 	 * should be treated - they can either be ordered values or unknown
1:cc30c0c: 	 * values. The caller also gets to decide, if they are ordered,
1:cc30c0c:          * whether they should be lower than non-NULL values, or higher
1:cc30c0c: 	 *
1:cc30c0c: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1:dbed020: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
1:cc30c0c: 	 * @param other	The DataValueDescriptor to compare this one to.
1:cc30c0c: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1:cc30c0c: 	 *						that is, treat SQL null as equal to null, and either greater or less
1:cc30c0c: 	 *						than all other values.
1:cc30c0c: 	 *						False means to treat nulls as unknown values,
1:cc30c0c: 	 *						that is, the result of any comparison with a null
1:cc30c0c: 	 *						is the UNKNOWN truth value.
1:cc30c0c:          * @param nullsOrderedLow       True means NULL less than non-NULL,
1:cc30c0c:          *                              false means NULL greater than non-NULL.
1:cc30c0c:          *                              Only relevant if orderedNulls is true.
1:cc30c0c: 	 * @param unknownRV		The return value to use if the result of the
1:cc30c0c: 	 *						comparison is the UNKNOWN truth value.  In other
1:cc30c0c: 	 *						words, if orderedNulls is false, and a null is
1:cc30c0c: 	 *						involved in the comparison, return unknownRV.
1:cc30c0c: 	 *						This parameter is not used orderedNulls is true.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @return	true if the comparison is true (duh!)
1:cc30c0c: 	 *
1:cc30c0c: 	 * @exception StandardException		Thrown on error
1:cc30c0c: 	 */
1:cc30c0c: 	public boolean compare(int op,
1:cc30c0c: 						   DataValueDescriptor other,
1:cc30c0c: 						   boolean orderedNulls,
1:cc30c0c: 						   boolean nullsOrderedLow,
1:cc30c0c: 						   boolean unknownRV)
1:cc30c0c: 		throws StandardException
1:cc30c0c: 	{
1:cc30c0c: 		/* Use compare method from dominant type, flipping the operator
1:cc30c0c: 		 * to reflect flipping of sides.
1:cc30c0c: 		 */
1:cc30c0c: 		if (typePrecedence() < other.typePrecedence())
1:cc30c0c: 		{
1:cc30c0c: 			return other.compare(flip(op), this, orderedNulls,
1:cc30c0c:                                 nullsOrderedLow, unknownRV);
1:cc30c0c: 		}
1:cc30c0c: 
1:cc30c0c: 		int result = compare(other, nullsOrderedLow);
1:cc30c0c: 
1:cc30c0c: 		switch(op)
1:cc30c0c: 		{
1:cc30c0c: 		case ORDER_OP_LESSTHAN:
1:cc30c0c: 			return (result < 0);   // this <  other
1:cc30c0c: 		case ORDER_OP_EQUALS:
1:cc30c0c: 			return (result == 0);  // this == other
1:cc30c0c: 		case ORDER_OP_LESSOREQUALS:
1:cc30c0c: 			return (result <= 0);  // this <= other
1:cc30c0c: 		// flipped operators
1:cc30c0c: 		case ORDER_OP_GREATERTHAN:
1:cc30c0c: 			return (result > 0);   // this > other
1:cc30c0c: 		case ORDER_OP_GREATEROREQUALS:
1:cc30c0c: 			return (result >= 0);  // this >= other
1:cc30c0c: 		default:
1:cc30c0c: 			if (SanityManager.DEBUG)
1:cc30c0c: 				SanityManager.THROWASSERT("Invalid Operator");
1:cc30c0c: 			return false;
1:cc30c0c: 		}
1:cc30c0c: 	}
1:cc30c0c: 
1:cc30c0c: 	/**
1:cc30c0c: 	 * Compare this Orderable with another, with configurable null ordering.
1:cc30c0c: 	 * This method treats nulls as ordered values, but allows the caller
1:cc30c0c:          * to specify whether they should be lower than all non-NULL values,
1:cc30c0c:          * or higher than all non-NULL values.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @param other		The Orderable to compare this one to.
1:cc30c0c:          % @param nullsOrderedLow True if null should be lower than non-NULL
1:cc30c0c: 	 *
1:dbed020: 	 * @return  &lt;0 - this Orderable is less than other.
1:cc30c0c: 	 * 			 0 - this Orderable equals other.
1:dbed020: 	 *			&gt;0 - this Orderable is greater than other.
1:cc30c0c:      *
1:cc30c0c:      *			The code should not explicitly look for -1, or 1.
1:cc30c0c: 	 *
1:cc30c0c: 	 * @exception StandardException		Thrown on error
1:cc30c0c: 	 */
1:cc30c0c: 	public int compare(DataValueDescriptor other, boolean nullsOrderedLow)
1:cc30c0c:             throws StandardException
1:cc30c0c:         {
1:cc30c0c:             if (this.isNull() || other.isNull())
1:cc30c0c:             {
1:cc30c0c:                 if (!isNull())
1:cc30c0c:                     return nullsOrderedLow ? 1 : -1;
1:cc30c0c:                 if (!other.isNull())
1:cc30c0c:                     return nullsOrderedLow ? -1 : 1;
1:cc30c0c:                 return 0; // both null
1:cc30c0c:             }
1:cc30c0c:             return compare(other);
1:cc30c0c:         } 
1:cc30c0c: 
1:cc30c0c: 	/**
1:028077e: 	 * Wrapper method for the "compare(DataValueDescriptor)" method of
1:028077e: 	 * this class.  Allows sorting of an array of DataValueDescriptors
1:028077e: 	 * using the JVMs own sorting algorithm.  Currently used for
1:028077e: 	 * execution-time sorting of IN-list values to allow proper handling
1:028077e: 	 * (i.e. elimination) of duplicates.
1:028077e: 	 *
1:028077e: 	 * @see java.lang.Comparable#compareTo
1:028077e: 	 */
1:028077e: 	public int compareTo(Object otherDVD)
1:028077e: 	{
1:028077e: 		DataValueDescriptor other = (DataValueDescriptor)otherDVD;
1:028077e: 		try {
1:028077e: 
1:028077e: 			// Use compare method from the dominant type.
1:028077e: 			if (typePrecedence() < other.typePrecedence())
1:028077e: 				return (-1 * other.compare(this));
1:028077e: 
1:028077e: 			return compare(other);
1:028077e: 
1:028077e: 		} catch (StandardException se) {
1:028077e: 
1:028077e: 			if (SanityManager.DEBUG)
1:028077e: 			{
1:028077e: 				SanityManager.THROWASSERT("Encountered error while " +
1:028077e: 					"trying to compare two DataValueDescriptors: " +
1:028077e: 					se.getMessage());
1:028077e: 			}
1:028077e: 
1:028077e: 			/* In case of an error in insane mode, just treat the
1:028077e: 			 * values as "equal".
1:028077e: 			 */
1:028077e: 			return 0;
1:028077e: 		}
1:028077e: 	}
1:028077e: 
1:028077e: 	/**
1:dbed020: 	 * Flip the operator used in a comparison (&lt; -&gt; &gt;).
1:eac0369: 	 * This is useful when flipping a comparison due to
1:eac0369: 	 * type precedence.
1:eac0369: 	 * 
1:eac0369: 	 * @param operator	The operator to flip.
1:eac0369: 	 * 
1:eac0369: 	 * @return The flipped operator.
1:eac0369: 	 */
1:eac0369: 	protected static int flip(int operator)
1:eac0369: 	{
1:eac0369: 		switch (operator)
1:eac0369: 		{
1:eac0369: 			case Orderable.ORDER_OP_LESSTHAN:
1:eac0369: 				// < -> > 
1:eac0369: 				return Orderable.ORDER_OP_GREATERTHAN;
1:eac0369: 			case Orderable.ORDER_OP_LESSOREQUALS:
1:eac0369: 				// <= -> >= 
1:eac0369: 				return Orderable.ORDER_OP_GREATEROREQUALS;
1:eac0369: 			case Orderable.ORDER_OP_EQUALS:
1:eac0369: 				// = -> = 
1:eac0369: 				return Orderable.ORDER_OP_EQUALS;
1:eac0369: 			default:
1:eac0369: 				// These operators only appear due to flipping.
1:eac0369: 				// They should never be flipped themselves.
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"Attempting to flip an operator that is not " +
1:eac0369: 						"expected to be flipped.");
1:eac0369: 				}
1:eac0369: 				return operator;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#coalesce
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor coalesce(DataValueDescriptor[] argumentsList, DataValueDescriptor returnValue)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		// arguments list should have at least 2 arguments
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(argumentsList != null,
1:eac0369: 				"argumentsList expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(argumentsList.length > 1,
1:eac0369: 				"argumentsList.length expected to be > 1");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Walk the arguments list until we find a non-null value. Otherwise we will return null
1:eac0369: 		 */
1:eac0369: 		int index;
1:eac0369: 		for (index = 0; index < argumentsList.length; index++)
1:eac0369: 		{
1:eac0369: 			if (!(argumentsList[index].isNull()))
1:eac0369: 			{
1:eac0369: 				returnValue.setValue(argumentsList[index]);
1:eac0369: 				return returnValue;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		returnValue.setToNull();
1:eac0369: 		return returnValue;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#in
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue in(DataValueDescriptor left,
1:eac0369: 							   DataValueDescriptor[] inList,
1:eac0369: 							   boolean orderedList) 
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		BooleanDataValue retval = null;
1:eac0369: 
1:eac0369: 		// in list should be non-empty
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(inList != null,
1:eac0369: 				"inList expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(inList.length > 0,
1:eac0369: 				"inList.length expected to be > 0");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if left is null then just return false
1:eac0369: 		if (left.isNull())
1:eac0369: 		{
1:eac0369: 			return SQLBoolean.truthValue(left,
1:eac0369: 									 inList[0],
1:eac0369: 									 false);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int start = 0;
1:eac0369: 		int finish = inList.length;
1:eac0369: 
1:eac0369: 		/* Do a binary search if the list is ordered until the 
1:eac0369: 		 * range of values to search is 3 or less.
1:0b0252d: 		 *
1:0b0252d: 		 * NOTE: We may have sorted the IN-lst values at compile time using
1:0b0252d: 		 * a specific (dominant) type, but we did *not* actually cast the
1:0b0252d: 		 * values to that type.  So it's possible that different IN-list
1:0b0252d: 		 * values have different precedences (verses each other and also
1:0b0252d: 		 * verses the type of the left operand) when we get here.  Thus
1:0b0252d: 		 * when we do any comparisons here we have to make sure we always
1:0b0252d: 		 * compare using the dominant type of the two values being compared.
1:0b0252d: 		 * Otherwise we can end up with wrong results when doing the binary
1:0b0252d: 		 * search (ex. as caused by incorrect truncation).  DERBY-2256.
1:4d09732:          *
1:4d09732:          * DERBY-6017: Actually, it's not good enough to compare using the
1:4d09732:          * dominant type of the two values being compared. It has to be the
1:4d09732:          * dominant type of *all* the values in the left operand and the right
1:4d09732:          * operand. Therefore, InListOperatorNode.preprocess() inserts a
1:4d09732:          * cast if necessary to ensure that either the left side or the right
1:4d09732:          * side of each comparison is of the overall dominating type.
1:eac0369: 		 */
1:0b0252d: 		int leftPrecedence = left.typePrecedence();
1:0b0252d: 		DataValueDescriptor comparator = null;
1:eac0369: 		if (orderedList)
1:eac0369: 		{
1:eac0369: 			while (finish - start > 2)
1:eac0369: 			{
1:eac0369: 				int mid = ((finish - start) / 2) + start;
1:0b0252d: 				comparator =
1:0b0252d: 					(leftPrecedence < inList[mid].typePrecedence())
1:0b0252d: 						? inList[mid]
1:0b0252d: 						: left;
1:0b0252d: 
1:eac0369: 				// Search left
1:0b0252d: 				retval = comparator.equals(left, inList[mid]);
1:eac0369: 				if (retval.equals(true))
1:eac0369: 				{
1:eac0369: 					return retval;
1:eac0369: 				}
1:0b0252d: 				BooleanDataValue goLeft =
1:0b0252d: 					comparator.greaterThan(inList[mid], left);
1:eac0369: 				if (goLeft.equals(true))
1:eac0369: 				{
1:eac0369: 					// search left
1:eac0369: 					finish = mid;
1:eac0369: 				}
2:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					// search right
1:eac0369: 					start = mid;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Walk the in list comparing the values.  Return as soon as we
1:eac0369: 		 * find a match.  If the list is ordered, return as soon as the left
1:eac0369: 		 * value is greater than an element in the in list.
1:0b0252d: 		 *
1:0b0252d: 		 * Note: for the same reasons outlined above we must be sure to always
1:0b0252d: 		 * do the comparisons using the dominant type of the two values being
1:0b0252d: 		 * compared.
1:eac0369: 		 */
1:eac0369: 		for (int index = start; index < finish; index++)
1:eac0369: 		{
1:0b0252d: 			comparator =
1:0b0252d: 				(leftPrecedence < inList[index].typePrecedence())
1:0b0252d: 					? inList[index]
1:0b0252d: 					: left;
1:0b0252d: 
1:0b0252d: 			retval = comparator.equals(left, inList[index]);
1:eac0369: 			if (retval.equals(true))
1:eac0369: 			{
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Can we stop searching?
1:eac0369: 			if (orderedList)
1:eac0369: 			{
1:0b0252d: 				BooleanDataValue stop =
1:0b0252d: 					comparator.greaterThan(inList[index], left);
1:eac0369: 				if (stop.equals(true))
1:eac0369: 				{
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * equals
1:eac0369: 	 */
1:eac0369: 	public boolean equals(Object other)
1:eac0369: 	{
1:eac0369: 		if (! (other instanceof DataValueDescriptor))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			return compare(ORDER_OP_EQUALS, (DataValueDescriptor) other, true, false);
1:eac0369: 		}
1:eac0369: 		catch (StandardException se)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:40bcd6b: 	public void setValue(InputStream theStream, int valueLength) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.io.InputStream");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check the value to seem if it conforms to the restrictions
1:eac0369: 		imposed by DB2/JCC on host variables for this type.
1:eac0369: 
1:eac0369: 		@exception StandardException Variable is too big.
1:eac0369: 	*/
1:eac0369: 	public void checkHostVariable(int declaredLength) throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:40bcd6b: 		Return an conversion exception from this type to another.
1:eac0369: 	*/
1:eac0369: 	protected final StandardException dataTypeConversion(String targetType) {
1:eac0369: 		return StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1:eac0369: 			targetType, this.getTypeName());
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return an out of range exception for this type.
1:eac0369: 	*/
1:eac0369: 	protected final StandardException outOfRange()
1:eac0369: 	{
1:eac0369: 		return StandardException.newException(
1:eac0369: 				SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return an out of range exception for this type.
1:eac0369: 	*/
1:eac0369: 	protected final StandardException invalidFormat()
1:eac0369: 	{
1:eac0369: 		return StandardException.newException(
1:eac0369: 				SQLState.LANG_FORMAT_EXCEPTION, getTypeName());
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the &lt;&gt;
1: 	 * @param right			The value on the right side of the &lt;&gt;
/////////////////////////////////////////////////////////////////////////
1: 	* The &lt; operator as called from the language module, as opposed to
1: 	* @param left   The value on the left side of the &lt;
1: 	* @param right   The value on the right side of the &lt;
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the &gt;
1: 	 * @param right			The value on the right side of the &gt;
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the &lt;=
1: 	 * @param right			The value on the right side of the &lt;=
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the &gt;=
1: 	 * @param right			The value on the right side of the &gt;=
/////////////////////////////////////////////////////////////////////////
1: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this &lt; other.
1: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this &lt;= other.
/////////////////////////////////////////////////////////////////////////
1: 	 * @return  &lt;0 - this Orderable is less than other.
1: 	 *			&gt;0 - this Orderable is greater than other.
/////////////////////////////////////////////////////////////////////////
1: 	 * Flip the operator used in a comparison (&lt; -&gt; &gt;).
commit:043a571
/////////////////////////////////////////////////////////////////////////
1: 		throw dataTypeConversion( "InputStream" );
commit:9495437
/////////////////////////////////////////////////////////////////////////
1:     public DataValueDescriptor cloneHolder() {
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:     public DataValueDescriptor cloneHolder() throws StandardException {
commit:75a4806
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.Clob;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Blob value to set this DataValueDescriptor to
1: 	 */
1: 	public void setValue(Blob theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Blob");
1: 	}
1:  
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Clob value to set this DataValueDescriptor to
1: 	 */
1: 	public void setValue(Clob theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Clob");
1: 	}
1: 
commit:33bfdc0
/////////////////////////////////////////////////////////////////////////
1: 	 * @param theValue	The Object value to set this DataValueDescriptor to
1: 	 */
1: 	public void setValue(Object theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.lang.Object");
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1: 	 * Compare this Orderable with another, with configurable null ordering.
1: 	 * The caller gets to determine how nulls
1: 	 * should be treated - they can either be ordered values or unknown
1: 	 * values. The caller also gets to decide, if they are ordered,
1:          * whether they should be lower than non-NULL values, or higher
1: 	 *
1: 	 * @param op	Orderable.ORDER_OP_EQUALS means do an = comparison.
0: 	 *				Orderable.ORDER_OP_LESSTHAN means compare this < other.
0: 	 *				Orderable.ORDER_OP_LESSOREQUALS means compare this <= other.
1: 	 * @param other	The DataValueDescriptor to compare this one to.
1: 	 * @param orderedNulls	True means to treat nulls as ordered values,
1: 	 *						that is, treat SQL null as equal to null, and either greater or less
1: 	 *						than all other values.
1: 	 *						False means to treat nulls as unknown values,
1: 	 *						that is, the result of any comparison with a null
1: 	 *						is the UNKNOWN truth value.
1:          * @param nullsOrderedLow       True means NULL less than non-NULL,
1:          *                              false means NULL greater than non-NULL.
1:          *                              Only relevant if orderedNulls is true.
1: 	 * @param unknownRV		The return value to use if the result of the
1: 	 *						comparison is the UNKNOWN truth value.  In other
1: 	 *						words, if orderedNulls is false, and a null is
1: 	 *						involved in the comparison, return unknownRV.
1: 	 *						This parameter is not used orderedNulls is true.
1: 	 *
1: 	 * @return	true if the comparison is true (duh!)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean nullsOrderedLow,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, flipping the operator
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return other.compare(flip(op), this, orderedNulls,
1:                                 nullsOrderedLow, unknownRV);
1: 		}
1: 
1: 		int result = compare(other, nullsOrderedLow);
1: 
1: 		switch(op)
1: 		{
1: 		case ORDER_OP_LESSTHAN:
1: 			return (result < 0);   // this <  other
1: 		case ORDER_OP_EQUALS:
1: 			return (result == 0);  // this == other
1: 		case ORDER_OP_LESSOREQUALS:
1: 			return (result <= 0);  // this <= other
1: 		// flipped operators
1: 		case ORDER_OP_GREATERTHAN:
1: 			return (result > 0);   // this > other
1: 		case ORDER_OP_GREATEROREQUALS:
1: 			return (result >= 0);  // this >= other
1: 		default:
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT("Invalid Operator");
1: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Compare this Orderable with another, with configurable null ordering.
1: 	 * This method treats nulls as ordered values, but allows the caller
1:          * to specify whether they should be lower than all non-NULL values,
1:          * or higher than all non-NULL values.
1: 	 *
1: 	 * @param other		The Orderable to compare this one to.
1:          % @param nullsOrderedLow True if null should be lower than non-NULL
1: 	 *
0: 	 * @return  <0 - this Orderable is less than other.
1: 	 * 			 0 - this Orderable equals other.
0: 	 *			>0 - this Orderable is greater than other.
1:      *
1:      *			The code should not explicitly look for -1, or 1.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public int compare(DataValueDescriptor other, boolean nullsOrderedLow)
1:             throws StandardException
1:         {
1:             if (this.isNull() || other.isNull())
1:             {
1:                 if (!isNull())
1:                     return nullsOrderedLow ? 1 : -1;
1:                 if (!other.isNull())
1:                     return nullsOrderedLow ? -1 : 1;
1:                 return 0; // both null
1:             }
1:             return compare(other);
1:         } 
1: 
1: 	/**
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
commit:4d09732
/////////////////////////////////////////////////////////////////////////
1:          *
1:          * DERBY-6017: Actually, it's not good enough to compare using the
1:          * dominant type of the two values being compared. It has to be the
1:          * dominant type of *all* the values in the left operand and the right
1:          * operand. Therefore, InListOperatorNode.preprocess() inserts a
1:          * cast if necessary to ensure that either the left side or the right
1:          * side of each comparison is of the overall dominating type.
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Read the DataValueDescriptor from the stream. The default implementation
1:      * calls {@code readExternal()}, which accesses the {@code ArrayInputStream}
1:      * as a generic stream. If sub-classes can implement it more efficiently
1:      * by accessing the array, they should override this method.
1:      *
1:      * @see DataValueDescriptor#readExternalFromArray
1:      * @see java.io.Externalizable#readExternal
1:      */
1:     public void readExternalFromArray(ArrayInputStream in)
1:             throws IOException, ClassNotFoundException {
1:         readExternal(in);
1:     }
1: 
commit:109cb26
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Recycle this DataType object.
1:      *
1:      * @return this object with value set to null
1:      */
1:     public DataValueDescriptor recycle() {
1:         restoreToNull();
1:         return this;
1:     }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aff8c99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:      * Tells that the value isn't represented as a stream, which is true for
1:      * most Derby data types.
1:      * <p>
1:      * This method will be overridden by types able to use a stream as the
1:      * source.
1:      *
1:      * @return {@code false}
1:      */
1:     public boolean hasStream() {
1:         return false;
1:     }
1: 
1:     /**
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 		return cloneValue(false);
commit:d7aa761
/////////////////////////////////////////////////////////////////////////
0:     public DataValueDescriptor cloneHolder() {
commit:b4e2eb7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     implements DataValueDescriptor, Comparable
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Default implementation of shallow cloning, which forwards to the deep
1:      * clone method.
1:      * <p>
1:      * For many of the data types, a shallow clone will be the same as a deep
1:      * clone. The data types requiring special handling of shallow clones have
1:      * to override this method (for instance types whose value can be
1:      * represented as a stream).
1:      *
1:      * @return A shallow clone.
1:      */
0:     public DataValueDescriptor cloneObject()
commit:f73afdc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the value in the data stream descriptor as a trace string.
1:      * This default implementation simply forwards the call to
1:      * <code>getString</code>.
1:      *
1:      * @return The data value in a representation suitable for tracing.
1:      * @throws StandardException if getting the data value fails.
1:      * @see DataValueDescriptor#getString
1:      */
1:     public String getTraceString() throws StandardException {
1:         return getString();  
1:     }
1: 
author:Army
-------------------------------------------------------------------------------
commit:0b0252d
/////////////////////////////////////////////////////////////////////////
1: 		 *
1: 		 * NOTE: We may have sorted the IN-lst values at compile time using
1: 		 * a specific (dominant) type, but we did *not* actually cast the
1: 		 * values to that type.  So it's possible that different IN-list
1: 		 * values have different precedences (verses each other and also
1: 		 * verses the type of the left operand) when we get here.  Thus
1: 		 * when we do any comparisons here we have to make sure we always
1: 		 * compare using the dominant type of the two values being compared.
1: 		 * Otherwise we can end up with wrong results when doing the binary
1: 		 * search (ex. as caused by incorrect truncation).  DERBY-2256.
1: 		int leftPrecedence = left.typePrecedence();
1: 		DataValueDescriptor comparator = null;
1: 				comparator =
1: 					(leftPrecedence < inList[mid].typePrecedence())
1: 						? inList[mid]
1: 						: left;
1: 
1: 				retval = comparator.equals(left, inList[mid]);
1: 				BooleanDataValue goLeft =
1: 					comparator.greaterThan(inList[mid], left);
/////////////////////////////////////////////////////////////////////////
1: 		 *
1: 		 * Note: for the same reasons outlined above we must be sure to always
1: 		 * do the comparisons using the dominant type of the two values being
1: 		 * compared.
1: 			comparator =
1: 				(leftPrecedence < inList[index].typePrecedence())
1: 					? inList[index]
1: 					: left;
1: 
1: 			retval = comparator.equals(left, inList[index]);
/////////////////////////////////////////////////////////////////////////
1: 				BooleanDataValue stop =
1: 					comparator.greaterThan(inList[index], left);
commit:028077e
/////////////////////////////////////////////////////////////////////////
0: import java.lang.Comparable;
/////////////////////////////////////////////////////////////////////////
0: 	implements DataValueDescriptor, CloneableObject, Comparable
/////////////////////////////////////////////////////////////////////////
1: 	 * Wrapper method for the "compare(DataValueDescriptor)" method of
1: 	 * this class.  Allows sorting of an array of DataValueDescriptors
1: 	 * using the JVMs own sorting algorithm.  Currently used for
1: 	 * execution-time sorting of IN-list values to allow proper handling
1: 	 * (i.e. elimination) of duplicates.
1: 	 *
1: 	 * @see java.lang.Comparable#compareTo
1: 	 */
1: 	public int compareTo(Object otherDVD)
1: 	{
1: 		DataValueDescriptor other = (DataValueDescriptor)otherDVD;
1: 		try {
1: 
1: 			// Use compare method from the dominant type.
1: 			if (typePrecedence() < other.typePrecedence())
1: 				return (-1 * other.compare(this));
1: 
1: 			return compare(other);
1: 
1: 		} catch (StandardException se) {
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT("Encountered error while " +
1: 					"trying to compare two DataValueDescriptors: " +
1: 					se.getMessage());
1: 			}
1: 
1: 			/* In case of an error in insane mode, just treat the
1: 			 * values as "equal".
1: 			 */
1: 			return 0;
1: 		}
1: 	}
1: 
1: 	/**
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:bb67ebd
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set the value of this DataValueDescriptor based on the value
1: 	 * of the specified DataValueDescriptor.
1: 	 *
1: 	 * @param dvd	The DataValueDescriptor that holds the value to
1: 	 *  which we want to set this DataValueDescriptor's value.
1: 	 *
1: 	 */
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:40bcd6b
/////////////////////////////////////////////////////////////////////////
1: 	public void setValue(InputStream theStream, int valueLength) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		Return an conversion exception from this type to another.
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	 * @see DataValueDescriptor#setObjectForCast
1: 	 * 
1: 	 * @exception StandardException
1: 	 *                thrown on failure
1: 	 * 
0: 	 * @return me
1: 	public void setObjectForCast(Object theValue, boolean instanceOfResultType,
1: 			String resultTypeClassName) throws StandardException {
1: 		
1: 		if (theValue == null)
1: 		{
1: 			setToNull();
1: 			return;
1: 		}
1: 			
1: 		/*
1: 		 * Is the object of the right type? (only do the check if value is
1: 		 * non-null
1: 		 */
1: 		if (!instanceOfResultType) {
1: 				throw StandardException.newException(
1: 						SQLState.LANG_DATA_TYPE_SET_MISMATCH,
1: 						theValue.getClass().getName(), getTypeName(resultTypeClassName));
1: 		}
1: 		setObject(theValue);
1: 	}
1: 		
1: 	 * Set the value from an non-null object. Usually overridden.
1: 	 * This implementation throws an exception.
1: 	 * The object will have been correctly typed from the call to setObjectForCast.
1: 	 */
1: 	void setObject(Object theValue)
1: 		genericSetObject(theValue);
1: 	
1: 	/**
1: 	 * Get the type name of this value, possibly overriding
1: 	 * with the passed in class name (for user/java types).
1: 	 * @param className
0: 	 * @return
1: 	 */
1: 	String getTypeName(String className)
1: 	{
1: 		return getTypeName();
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	void genericSetObject(Object theValue) throws StandardException {
1: 		throwLangSetMismatch(theValue);
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
1: 	public int typeToBigDecimal() throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.math.BigDecimal");
1: 	}
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 		Only to be called when the application sets a value using BigDecimal
1: 	*/
0: 	public void setBigDecimal(Number bigDecimal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.math.BigDecimal");
1: 	}
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.DataType
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.Orderable;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: 
0: import java.io.IOException;
1: import java.io.InputStream;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.math.BigDecimal;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.ResultSet;
1: 
1: import java.util.Calendar;
1: 
1: /**
1:  *
1:  * DataType is the superclass for all data types. 
1:  * It provides common behavior
1:  * for datavalue descriptors -- it throws
1:  * exceptions for all of the get* and setvalue(*)  methods of
1:  * DataValueDescriptor; the subtypes need only
1:  * override the one for the type they represent
1:  * and all types it can also be returned as,
1:  * and the methods dealing with nulls.
1:  *
1:  * Since all types satisfy getString 
1:  * DataType does not define that
1:  * interfaces of DataValueDescriptor.
1:  *
1:  * DataType is a little glue for columns to hold
1:  * values with.
1:  *
1:  */
1: public abstract class DataType
0: 	implements DataValueDescriptor, CloneableObject
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1: 	 * DataValueDescriptor Interface
1: 	 */
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a boolean.
1: 	 * Throws an exception if the data value is not receivable as a boolean.
1: 	 *
1: 	 * @return	The data value as a boolean.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean	getBoolean() throws StandardException
1: 	{
1: 		throw dataTypeConversion("boolean");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a byte.
1: 	 * Throws an exception if the data value is not receivable as a byte.
1: 	 *
1: 	 * @return	The data value as a byte.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public byte	getByte() throws StandardException
1: 	{
1: 		throw dataTypeConversion("byte");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a short.
1: 	 * Throws an exception if the data value is not receivable as a short.
1: 	 *
1: 	 * @return	The data value as a short.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public short	getShort() throws StandardException
1: 	{
1: 		throw dataTypeConversion("short");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a int.
1: 	 * Throws an exception if the data value is not receivable as a int.
1: 	 *
1: 	 * @return	The data value as a int.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public int	getInt() throws StandardException
1: 	{
1: 		throw dataTypeConversion("int");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a long.
1: 	 * Throws an exception if the data value is not receivable as a long.
1: 	 *
1: 	 * @return	The data value as a long.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public long	getLong() throws StandardException
1: 	{
1: 		throw dataTypeConversion("long");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a float.
1: 	 * Throws an exception if the data value is not receivable as a float.
1: 	 *
1: 	 * @return	The data value as a float.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public float	getFloat() throws StandardException
1: 	{
1: 		throw dataTypeConversion("float");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a double.
1: 	 * Throws an exception if the data value is not receivable as a double.
1: 	 *
1: 	 * @return	The data value as a double.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public double	getDouble() throws StandardException
1: 	{
1: 		throw dataTypeConversion("double");
1: 	}
1: 
1: 	/**
0: 	 * Gets the value in the data value descriptor as a BigDecimal.
0: 	 * Throws an exception if the data value is not receivable as a BigDecimal.
1: 	 *
0: 	 * @return	The data value as a java.lang.BigDecimal.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public BigDecimal	getBigDecimal() throws StandardException
1: 	{
0: 		throw dataTypeConversion("java.math.BigDecimal");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a byte[].
1: 	 * Throws an exception if the data value is not receivable as a Binary or Varbinary.
1: 	 *
1: 	 * @return	The Binary value as a byte[].
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public byte[]	getBytes() throws StandardException
1: 	{
1: 		throw dataTypeConversion("byte[]");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Date.
1: 	 * Throws an exception if the data value is not receivable as a Date.
1:      *	@param cal calendar for object creation
1: 	 * @return	The data value as a java.sql.Date.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Date	getDate( Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Date");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Time.
1: 	 * Throws an exception if the data value is not receivable as a Time.
1:      *	@param cal calendar for object creation
1: 	 * @return	The data value as a java.sql.Time.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Time	getTime( Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Time");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
1: 	 * Throws an exception if the data value is not receivable as a Timestamp.
1:      *	@param cal calendar for object creation
1: 	 * @return	The data value as a java.sql.Timestamp.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Timestamp");
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data stream descriptor as an InputStream.
1: 	 * Throws an exception if the data value is not receivable as a stream.
1: 	 *
1: 	 * @return	The data value as an InputStream.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public InputStream	getStream() throws StandardException
1: 	{
0: 		throw dataTypeConversion( 
0: 			MessageService.getTextMessage(SQLState.LANG_STREAM));
1: 	}
1: 
1: 	/*
1: 	 * Column interface
1: 	 */
1: 	
1: 	/**
1: 	 * The is null operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the operand is null
1: 	 *
1: 	 */
1: 
1: 	public final BooleanDataValue isNullOp()
1: 	{
1: 		return SQLBoolean.truthValue(isNull());
1: 	}
1: 
1: 	/**
1: 	 * The is not null operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the operand is not null
1: 	 *
1: 	 */
1: 
1: 	public final BooleanDataValue isNotNull()
1: 	{
1: 		return SQLBoolean.truthValue(!isNull());
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Time theValue) throws StandardException
1: 	{
1:         setValue( theValue, (Calendar) null);
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Time value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database time value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Time theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Time");
1: 	}
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Timestamp theValue) throws StandardException
1: 	{
1:         setValue( theValue, (Calendar) null);
1: 	}
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database timestamp value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Timestamp");
1: 	}
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Date theValue) throws StandardException
1: 	{
1:         setValue( theValue, (Calendar) null);
1: 	}
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The Date value to set this DataValueDescriptor to
1:      * @param cal The time zone from the calendar is used to construct the database date value
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(Date theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Date");
1: 	}
1: 	
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 
0: 	public void setValue(BigDecimal theValue) throws StandardException
1: 	{
0: 		throwLangSetMismatch("java.math.BigDecimal");
1: 	}
1: 
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(String theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.lang.String");
1: 	}
1: 
1: 
1:     /**
1: 	 * Set the value of this DataValueDescriptor to the given int value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(int theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("int");
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given double value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(double theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("double");
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given float value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(float theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("float");
1: 	}
1:  
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given short value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(short theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("short");
1: 	}
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given long value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(long theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("long");
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor to the given byte value
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(byte theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("byte");
1: 	}
1: 
1: 	/**
1: 	 * Set the value.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	Contains the boolean value to set this to
1: 	 *
0: 	 * @return	This value
1: 	 *
1: 	 */
1: 	public void setValue(boolean theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("boolean");
1: 	}
1: 
1: 	/**
1: 	 * Set the value of this DataValueDescriptor.
1: 	 * At DataType level just throws an error lower classes will override
1: 	 *
1: 	 * @param theValue	The byte value to set this DataValueDescriptor to
1: 	 *
0: 	 * @return	This DataValueDescriptor
1: 	 *
1: 	 */
1: 	public void setValue(byte[] theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("byte[]");
1: 	}
1: 
1: 
1: 	public final void setValue(DataValueDescriptor dvd) throws StandardException {
1: 
1: 		if (dvd.isNull())
1: 		{
1: 			setToNull();
1: 			return;
1: 		}
1: 
1: 		try {
1: 			setFrom(dvd);
1: 		} catch (StandardException se) {
1: 			String msgId = se.getMessageId();
1: 
1: 			if (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE.equals(msgId))
1: 				throw outOfRange();
1: 
1: 			if (SQLState.LANG_FORMAT_EXCEPTION.equals(msgId))
1: 				throw invalidFormat();
1: 
1: 			throw se;
1: 
1: 		}
1: 	}
1: 
1: 	protected void setFrom(DataValueDescriptor dvd) throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.NOT_IMPLEMENTED);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#setToNull
1: 	 */
1: 	 public void setToNull()
1: 	 {
1: 	 	restoreToNull();
1: 	 }
1: 
1: 	/**
0: 	 * Set the Object that this Data Type contains (for an explicit cast).
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void setObjectForCast(Object value, boolean instanceOf, String resultTypeClassName) throws StandardException
1: 	{
0: 		setValue(value);
1: 	}
1: 
1: 	/**
0: 		Set the value from an object.
0: 		Usually overridden. This implementation sets this to
0: 		NULL if the passed in value is null, otherwise an exception
0: 		is thrown.
1: 	*/
0: 	public void setValue(Object theValue)
1: 		throws StandardException
1: 	{
0: 		if (theValue == null)
1: 			setToNull();
1: 		else
0: 			throwLangSetMismatch(theValue);
1: 	}
1: 
1: 	/**
1: 	 * Gets the value in the data value descriptor as a int.
1: 	 * Throws an exception if the data value is not receivable as a int.
1: 	 *
1: 	 * @return	The data value as a int.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Object	getObject() throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.lang.Object");
1: 	}
1: 
1: 
0: 	protected void genericSetObject(Object theValue) throws StandardException {
1: 
0: 		//if (theValue instanceof String)
0: 		//	((DataValueDescriptor) this).setValue((String) theValue);
0: 		//else
0: 			throwLangSetMismatch(theValue);
1: 	}
1: 
1: 	/**
0: 	 * From CloneableObject
1: 	 *
0: 	 * @return clone of me as an Object
1: 	 */
0: 	public Object cloneObject()
1: 	{
0: 		return getClone();
1: 	}
1: 
0: 	// International support
1: 
1: 	/**
0: 	 * International version of getString(). Overridden for date, time,
0: 	 * and timestamp in SQLDate, SQLTime, SQLTimestamp.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
1: 	{
0: 		return getString();
1: 	}
1: 
1: 	public void throwLangSetMismatch(Object value) throws StandardException {
1: 		throwLangSetMismatch(value.getClass().getName());
1: 	}
1: 
1: 	void throwLangSetMismatch(String argTypeName) throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, 
1: 									   argTypeName, this.getTypeName());
1: 		
1: 	}
1: 
1: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1: 
1: 		ps.setObject(position, getObject());
1: 	}
1: 
1: 	/**
1: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
1: 		or ResultSet.updateRow. This method will only be called for non-null values.
1: 
1: 		@exception SQLException thrown by the ResultSet object
1: 		@exception StandardException thrown by me accessing my value.
1: 	*/
1: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException {
1: 		rs.updateObject(position, getObject());
1: 	}
1: 
1: 
1: 	/**
1: 	 * Default normalization method. No information needed from DataTypeDescriptor.
1: 	 *
1: 	 * @param desiredType	The type to normalize the source column to
1: 	 * @param source		The value to normalize
1: 	 *
1: 	 *
1: 	 * @exception StandardException				Thrown normalization error.
1: 	 */
1: 
1: 	public void normalize(
1: 				DataTypeDescriptor desiredType,
1: 				DataValueDescriptor source)
1: 					throws StandardException
1: 	{
1: 		((DataValueDescriptor) this).setValue(source);
1: 	}
1: 	/**
1: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
1: 	 * how to do type promotion when using binary operators.  For example, float
1: 	 * has a higher precedence than int, so when adding an int to a float, the
1: 	 * result type is float.
1: 	 *
1: 	 * The precedence for some types is arbitrary.  For example, it doesn't
1: 	 * matter what the precedence of the boolean type is, since it can't be
1: 	 * mixed with other types.  But the precedence for the number types is
1: 	 * critical.  The SQL standard requires that exact numeric types be
1: 	 * promoted to approximate numeric when one operator uses both.  Also,
1: 	 * the precedence is arranged so that one will not lose precision when
1: 	 * promoting a type.
1: 	 *
1: 	 * @return		The precedence of this type.
1: 	 */
1: 	public int					typePrecedence() {
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 	 * The = operator as called from the language module, as opposed to
1: 	 * the storage module. This default implementations uses compare().
1: 	 *
1: 	 * @param left			The value on the left side of the =
1: 	 * @param right			The value on the right side of the =
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue equals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(right) == 0);
1: 	}
1: 
1: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
1: 	 * the storage module. This default implementations uses compare().
1: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters
1: 	 *			are not equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(right) != 0);
1: 	}
1: 	/**
0: 	* The < operator as called from the language module, as opposed to
1: 	* the storage module.
1: 	*
0: 	* @param left   The value on the left side of the <
0: 	* @param right   The value on the right side of the <
1: 	*
1: 	* @return A SQL boolean value telling whether the first operand is less
1: 	*   than the second operand
1: 	*
1: 	* @exception StandardException  Thrown on error
1: 	*/
1: 
1: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1: 	   DataValueDescriptor right)
1: 	throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 		  right,
1: 		  left.compare(right) < 0);
1: 	}
1: 	/**
0: 	 * The > operator as called from the language module, as opposed to
1: 	 * the storage module. This default implementations uses compare().
1: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is greater
1: 	 *			than the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(right) > 0);
1: 	}
1: 
1: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
1: 	 * the storage module. This default implementations uses compare().
1: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is less
1: 	 *			than or equal to the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(right) <= 0);
1: 	}
1: 
1: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
1: 	 * the storage module. This default implementation uses compare().
1: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the first operand is greater
1: 	 *			than or equal to the second operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1: 							DataValueDescriptor right)
1: 			throws StandardException
1: 	{
1: 		return SQLBoolean.truthValue(left,
1: 									 right,
1: 									 left.compare(right) >= 0);
1: 	}
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, flipping the operator
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return other.compare(flip(op), this, orderedNulls, unknownRV);
1: 		}
1: 
1: 		int result = compare(other);
1: 
1: 		switch(op)
1: 		{
1: 		case ORDER_OP_LESSTHAN:
1: 			return (result < 0);   // this <  other
1: 		case ORDER_OP_EQUALS:
1: 			return (result == 0);  // this == other
1: 		case ORDER_OP_LESSOREQUALS:
1: 			return (result <= 0);  // this <= other
1: 		// flipped operators
1: 		case ORDER_OP_GREATERTHAN:
1: 			return (result > 0);   // this > other
1: 		case ORDER_OP_GREATEROREQUALS:
1: 			return (result >= 0);  // this >= other
1: 		default:
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT("Invalid Operator");
1: 			return false;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Flip the operator used in a comparison (< -> >).
1: 	 * This is useful when flipping a comparison due to
1: 	 * type precedence.
1: 	 * 
1: 	 * @param operator	The operator to flip.
1: 	 * 
1: 	 * @return The flipped operator.
1: 	 */
1: 	protected static int flip(int operator)
1: 	{
1: 		switch (operator)
1: 		{
1: 			case Orderable.ORDER_OP_LESSTHAN:
1: 				// < -> > 
1: 				return Orderable.ORDER_OP_GREATERTHAN;
1: 			case Orderable.ORDER_OP_LESSOREQUALS:
1: 				// <= -> >= 
1: 				return Orderable.ORDER_OP_GREATEROREQUALS;
1: 			case Orderable.ORDER_OP_EQUALS:
1: 				// = -> = 
1: 				return Orderable.ORDER_OP_EQUALS;
1: 			default:
1: 				// These operators only appear due to flipping.
1: 				// They should never be flipped themselves.
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"Attempting to flip an operator that is not " +
1: 						"expected to be flipped.");
1: 				}
1: 				return operator;
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#coalesce
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataValueDescriptor coalesce(DataValueDescriptor[] argumentsList, DataValueDescriptor returnValue)
1: 						throws StandardException
1: 	{
1: 		// arguments list should have at least 2 arguments
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(argumentsList != null,
1: 				"argumentsList expected to be non-null");
1: 			SanityManager.ASSERT(argumentsList.length > 1,
1: 				"argumentsList.length expected to be > 1");
1: 		}
1: 
1: 		/* Walk the arguments list until we find a non-null value. Otherwise we will return null
1: 		 */
1: 		int index;
1: 		for (index = 0; index < argumentsList.length; index++)
1: 		{
1: 			if (!(argumentsList[index].isNull()))
1: 			{
1: 				returnValue.setValue(argumentsList[index]);
1: 				return returnValue;
1: 			}
1: 		}
1: 
1: 		returnValue.setToNull();
1: 		return returnValue;
1: 
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#in
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public BooleanDataValue in(DataValueDescriptor left,
1: 							   DataValueDescriptor[] inList,
1: 							   boolean orderedList) 
1: 						throws StandardException
1: 	{
1: 		BooleanDataValue retval = null;
1: 
1: 		// in list should be non-empty
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(inList != null,
1: 				"inList expected to be non-null");
1: 			SanityManager.ASSERT(inList.length > 0,
1: 				"inList.length expected to be > 0");
1: 		}
1: 
1: 		// if left is null then just return false
1: 		if (left.isNull())
1: 		{
1: 			return SQLBoolean.truthValue(left,
1: 									 inList[0],
1: 									 false);
1: 		}
1: 
1: 		int start = 0;
1: 		int finish = inList.length;
1: 
1: 		/* Do a binary search if the list is ordered until the 
1: 		 * range of values to search is 3 or less.
0: 		 * NOTE: We've ensured that the IN list and the left all have
0: 		 * the same precedence at compile time.  If we don't enforce 
0: 		 * the same precendence then
0: 		 * we could get the wrong result when doing a binary search.
1: 		 */
1: 		if (orderedList)
1: 		{
1: 			while (finish - start > 2)
1: 			{
1: 				int mid = ((finish - start) / 2) + start;
1: 				// Search left
0: 				retval = equals(left, inList[mid]);
1: 				if (retval.equals(true))
1: 				{
1: 					return retval;
1: 				}
0: 				BooleanDataValue goLeft = greaterThan(inList[mid], left);
1: 				if (goLeft.equals(true))
1: 				{
1: 					// search left
1: 					finish = mid;
1: 				}
1: 				else
1: 				{
1: 					// search right
1: 					start = mid;
1: 				}
1: 			}
1: 		}
1: 
1: 		/* Walk the in list comparing the values.  Return as soon as we
1: 		 * find a match.  If the list is ordered, return as soon as the left
1: 		 * value is greater than an element in the in list.
1: 		 */
1: 		for (int index = start; index < finish; index++)
1: 		{
0: 			retval = equals(left, inList[index]);
1: 			if (retval.equals(true))
1: 			{
1: 				break;
1: 			}
1: 
1: 			// Can we stop searching?
1: 			if (orderedList)
1: 			{
0: 				BooleanDataValue stop = greaterThan(inList[index], left);
1: 				if (stop.equals(true))
1: 				{
1: 					break;
1: 				}
1: 			}
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	/*
1: 	 * equals
1: 	 */
1: 	public boolean equals(Object other)
1: 	{
1: 		if (! (other instanceof DataValueDescriptor))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		try
1: 		{
1: 			return compare(ORDER_OP_EQUALS, (DataValueDescriptor) other, true, false);
1: 		}
1: 		catch (StandardException se)
1: 		{
1: 			return false;
1: 		}
1: 	}
1: 
0: 	public void setValue(InputStream theStream, int streamLength) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.io.InputStream");
1: 	}
1: 
1: 	/**
1: 		Check the value to seem if it conforms to the restrictions
1: 		imposed by DB2/JCC on host variables for this type.
1: 
1: 		@exception StandardException Variable is too big.
1: 	*/
1: 	public void checkHostVariable(int declaredLength) throws StandardException
1: 	{
1: 	}
1: 
1: 
1: 	/**
0: 		Return an conversion exception for this type.
1: 	*/
1: 	protected final StandardException dataTypeConversion(String targetType) {
1: 		return StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1: 			targetType, this.getTypeName());
1: 
1: 	}
1: 
1: 	/**
1: 		Return an out of range exception for this type.
1: 	*/
1: 	protected final StandardException outOfRange()
1: 	{
1: 		return StandardException.newException(
1: 				SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
1: 	}
1: 
1: 	/**
1: 		Return an out of range exception for this type.
1: 	*/
1: 	protected final StandardException invalidFormat()
1: 	{
1: 		return StandardException.newException(
1: 				SQLState.LANG_FORMAT_EXCEPTION, getTypeName());
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.Orderable;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: 
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.math.BigDecimal;
0: import java.sql.PreparedStatement;
0: import java.sql.SQLException;
0: import java.sql.ResultSet;
0: 
0: import java.util.Calendar;
0: 
0: /**
0:  *
0:  * DataType is the superclass for all data types. 
0:  * It provides common behavior
0:  * for datavalue descriptors -- it throws
0:  * exceptions for all of the get* and setvalue(*)  methods of
0:  * DataValueDescriptor; the subtypes need only
0:  * override the one for the type they represent
0:  * and all types it can also be returned as,
0:  * and the methods dealing with nulls.
0:  *
0:  * Since all types satisfy getString 
0:  * DataType does not define that
0:  * interfaces of DataValueDescriptor.
0:  *
0:  * DataType is a little glue for columns to hold
0:  * values with.
0:  *
0:  */
0: public abstract class DataType
0: 	implements DataValueDescriptor, CloneableObject
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0: 	 * DataValueDescriptor Interface
0: 	 */
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a boolean.
0: 	 * Throws an exception if the data value is not receivable as a boolean.
0: 	 *
0: 	 * @return	The data value as a boolean.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean	getBoolean() throws StandardException
0: 	{
0: 		throw dataTypeConversion("boolean");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a byte.
0: 	 * Throws an exception if the data value is not receivable as a byte.
0: 	 *
0: 	 * @return	The data value as a byte.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public byte	getByte() throws StandardException
0: 	{
0: 		throw dataTypeConversion("byte");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a short.
0: 	 * Throws an exception if the data value is not receivable as a short.
0: 	 *
0: 	 * @return	The data value as a short.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public short	getShort() throws StandardException
0: 	{
0: 		throw dataTypeConversion("short");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a int.
0: 	 * Throws an exception if the data value is not receivable as a int.
0: 	 *
0: 	 * @return	The data value as a int.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public int	getInt() throws StandardException
0: 	{
0: 		throw dataTypeConversion("int");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a long.
0: 	 * Throws an exception if the data value is not receivable as a long.
0: 	 *
0: 	 * @return	The data value as a long.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public long	getLong() throws StandardException
0: 	{
0: 		throw dataTypeConversion("long");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a float.
0: 	 * Throws an exception if the data value is not receivable as a float.
0: 	 *
0: 	 * @return	The data value as a float.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public float	getFloat() throws StandardException
0: 	{
0: 		throw dataTypeConversion("float");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a double.
0: 	 * Throws an exception if the data value is not receivable as a double.
0: 	 *
0: 	 * @return	The data value as a double.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public double	getDouble() throws StandardException
0: 	{
0: 		throw dataTypeConversion("double");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a BigDecimal.
0: 	 * Throws an exception if the data value is not receivable as a BigDecimal.
0: 	 *
0: 	 * @return	The data value as a java.lang.BigDecimal.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BigDecimal	getBigDecimal() throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.math.BigDecimal");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a byte[].
0: 	 * Throws an exception if the data value is not receivable as a Binary or Varbinary.
0: 	 *
0: 	 * @return	The Binary value as a byte[].
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public byte[]	getBytes() throws StandardException
0: 	{
0: 		throw dataTypeConversion("byte[]");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Date.
0: 	 * Throws an exception if the data value is not receivable as a Date.
0:      *	@param cal calendar for object creation
0: 	 * @return	The data value as a java.sql.Date.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Date	getDate( Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Date");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Time.
0: 	 * Throws an exception if the data value is not receivable as a Time.
0:      *	@param cal calendar for object creation
0: 	 * @return	The data value as a java.sql.Time.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Time	getTime( Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Time");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a java.sql.Timestamp.
0: 	 * Throws an exception if the data value is not receivable as a Timestamp.
0:      *	@param cal calendar for object creation
0: 	 * @return	The data value as a java.sql.Timestamp.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Timestamp	getTimestamp( Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Timestamp");
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data stream descriptor as an InputStream.
0: 	 * Throws an exception if the data value is not receivable as a stream.
0: 	 *
0: 	 * @return	The data value as an InputStream.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public InputStream	getStream() throws StandardException
0: 	{
0: 		throw dataTypeConversion( 
0: 			MessageService.getTextMessage(SQLState.LANG_STREAM));
0: 	}
0: 
0: 	/*
0: 	 * Column interface
0: 	 */
0: 	
0: 	/**
0: 	 * The is null operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the operand is null
0: 	 *
0: 	 */
0: 
0: 	public final BooleanDataValue isNullOp()
0: 	{
0: 		return SQLBoolean.truthValue(isNull());
0: 	}
0: 
0: 	/**
0: 	 * The is not null operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the operand is not null
0: 	 *
0: 	 */
0: 
0: 	public final BooleanDataValue isNotNull()
0: 	{
0: 		return SQLBoolean.truthValue(!isNull());
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Time value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Time theValue) throws StandardException
0: 	{
0:         setValue( theValue, (Calendar) null);
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Time value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database time value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Time theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Time");
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Timestamp theValue) throws StandardException
0: 	{
0:         setValue( theValue, (Calendar) null);
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Timestamp value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database timestamp value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Timestamp");
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Date value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Date theValue) throws StandardException
0: 	{
0:         setValue( theValue, (Calendar) null);
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The Date value to set this DataValueDescriptor to
0:      * @param cal The time zone from the calendar is used to construct the database date value
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(Date theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Date");
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 
0: 	public void setValue(BigDecimal theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.math.BigDecimal");
0: 	}
0: 
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The BigDecimal value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(String theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.lang.String");
0: 	}
0: 
0: 
0:     /**
0: 	 * Set the value of this DataValueDescriptor to the given int value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(int theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("int");
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given double value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(double theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("double");
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given float value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(float theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("float");
0: 	}
0:  
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given short value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(short theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("short");
0: 	}
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given long value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(long theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("long");
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor to the given byte value
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(byte theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("byte");
0: 	}
0: 
0: 	/**
0: 	 * Set the value.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	Contains the boolean value to set this to
0: 	 *
0: 	 * @return	This value
0: 	 *
0: 	 */
0: 	public void setValue(boolean theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("boolean");
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this DataValueDescriptor.
0: 	 * At DataType level just throws an error lower classes will override
0: 	 *
0: 	 * @param theValue	The byte value to set this DataValueDescriptor to
0: 	 *
0: 	 * @return	This DataValueDescriptor
0: 	 *
0: 	 */
0: 	public void setValue(byte[] theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("byte[]");
0: 	}
0: 
0: 
0: 	public final void setValue(DataValueDescriptor dvd) throws StandardException {
0: 
0: 		if (dvd.isNull())
0: 		{
0: 			setToNull();
0: 			return;
0: 		}
0: 
0: 		try {
0: 			setFrom(dvd);
0: 		} catch (StandardException se) {
0: 			String msgId = se.getMessageId();
0: 
0: 			if (SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE.equals(msgId))
0: 				throw outOfRange();
0: 
0: 			if (SQLState.LANG_FORMAT_EXCEPTION.equals(msgId))
0: 				throw invalidFormat();
0: 
0: 			throw se;
0: 
0: 		}
0: 	}
0: 
0: 	protected void setFrom(DataValueDescriptor dvd) throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.NOT_IMPLEMENTED);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#setToNull
0: 	 */
0: 	 public void setToNull()
0: 	 {
0: 	 	restoreToNull();
0: 	 }
0: 
0: 	/**
0: 	 * Set the Object that this Data Type contains (for an explicit cast).
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setObjectForCast(Object value, boolean instanceOf, String resultTypeClassName) throws StandardException
0: 	{
0: 		setValue(value);
0: 	}
0: 
0: 	/**
0: 		Set the value from an object.
0: 		Usually overridden. This implementation sets this to
0: 		NULL if the passed in value is null, otherwise an exception
0: 		is thrown.
0: 	*/
0: 	public void setValue(Object theValue)
0: 		throws StandardException
0: 	{
0: 		if (theValue == null)
0: 			setToNull();
0: 		else
0: 			throwLangSetMismatch(theValue);
0: 	}
0: 
0: 	/**
0: 	 * Gets the value in the data value descriptor as a int.
0: 	 * Throws an exception if the data value is not receivable as a int.
0: 	 *
0: 	 * @return	The data value as a int.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Object	getObject() throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.lang.Object");
0: 	}
0: 
0: 
0: 	protected void genericSetObject(Object theValue) throws StandardException {
0: 
0: 		//if (theValue instanceof String)
0: 		//	((DataValueDescriptor) this).setValue((String) theValue);
0: 		//else
0: 			throwLangSetMismatch(theValue);
0: 	}
0: 
0: 	/**
0: 	 * From CloneableObject
0: 	 *
0: 	 * @return clone of me as an Object
0: 	 */
0: 	public Object cloneObject()
0: 	{
0: 		return getClone();
0: 	}
0: 
0: 	// International support
0: 
0: 	/**
0: 	 * International version of getString(). Overridden for date, time,
0: 	 * and timestamp in SQLDate, SQLTime, SQLTimestamp.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
0: 	{
0: 		return getString();
0: 	}
0: 
0: 	public void throwLangSetMismatch(Object value) throws StandardException {
0: 		throwLangSetMismatch(value.getClass().getName());
0: 	}
0: 
0: 	void throwLangSetMismatch(String argTypeName) throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, 
0: 									   argTypeName, this.getTypeName());
0: 		
0: 	}
0: 
0: 	public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
0: 
0: 		ps.setObject(position, getObject());
0: 	}
0: 
0: 	/**
0: 		Set this value into a ResultSet for a subsequent ResultSet.insertRow
0: 		or ResultSet.updateRow. This method will only be called for non-null values.
0: 
0: 		@exception SQLException thrown by the ResultSet object
0: 		@exception StandardException thrown by me accessing my value.
0: 	*/
0: 	public void setInto(ResultSet rs, int position) throws SQLException, StandardException {
0: 		rs.updateObject(position, getObject());
0: 	}
0: 
0: 
0: 	/**
0: 	 * Default normalization method. No information needed from DataTypeDescriptor.
0: 	 *
0: 	 * @param desiredType	The type to normalize the source column to
0: 	 * @param source		The value to normalize
0: 	 *
0: 	 *
0: 	 * @exception StandardException				Thrown normalization error.
0: 	 */
0: 
0: 	public void normalize(
0: 				DataTypeDescriptor desiredType,
0: 				DataValueDescriptor source)
0: 					throws StandardException
0: 	{
0: 		((DataValueDescriptor) this).setValue(source);
0: 	}
0: 	/**
0: 	 * Each built-in type in JSQL has a precedence.  This precedence determines
0: 	 * how to do type promotion when using binary operators.  For example, float
0: 	 * has a higher precedence than int, so when adding an int to a float, the
0: 	 * result type is float.
0: 	 *
0: 	 * The precedence for some types is arbitrary.  For example, it doesn't
0: 	 * matter what the precedence of the boolean type is, since it can't be
0: 	 * mixed with other types.  But the precedence for the number types is
0: 	 * critical.  The SQL standard requires that exact numeric types be
0: 	 * promoted to approximate numeric when one operator uses both.  Also,
0: 	 * the precedence is arranged so that one will not lose precision when
0: 	 * promoting a type.
0: 	 *
0: 	 * @return		The precedence of this type.
0: 	 */
0: 	public int					typePrecedence() {
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 	 * The = operator as called from the language module, as opposed to
0: 	 * the storage module. This default implementations uses compare().
0: 	 *
0: 	 * @param left			The value on the left side of the =
0: 	 * @param right			The value on the right side of the =
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters are equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue equals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(right) == 0);
0: 	}
0: 
0: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
0: 	 * the storage module. This default implementations uses compare().
0: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters
0: 	 *			are not equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue notEquals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(right) != 0);
0: 	}
0: 	/**
0: 	* The < operator as called from the language module, as opposed to
0: 	* the storage module.
0: 	*
0: 	* @param left   The value on the left side of the <
0: 	* @param right   The value on the right side of the <
0: 	*
0: 	* @return A SQL boolean value telling whether the first operand is less
0: 	*   than the second operand
0: 	*
0: 	* @exception StandardException  Thrown on error
0: 	*/
0: 
0: 	public BooleanDataValue lessThan(DataValueDescriptor left,
0: 	   DataValueDescriptor right)
0: 	throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 		  right,
0: 		  left.compare(right) < 0);
0: 	}
0: 	/**
0: 	 * The > operator as called from the language module, as opposed to
0: 	 * the storage module. This default implementations uses compare().
0: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is greater
0: 	 *			than the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(right) > 0);
0: 	}
0: 
0: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
0: 	 * the storage module. This default implementations uses compare().
0: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is less
0: 	 *			than or equal to the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(right) <= 0);
0: 	}
0: 
0: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
0: 	 * the storage module. This default implementation uses compare().
0: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the first operand is greater
0: 	 *			than or equal to the second operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
0: 							DataValueDescriptor right)
0: 			throws StandardException
0: 	{
0: 		return SQLBoolean.truthValue(left,
0: 									 right,
0: 									 left.compare(right) >= 0);
0: 	}
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, flipping the operator
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return other.compare(flip(op), this, orderedNulls, unknownRV);
0: 		}
0: 
0: 		int result = compare(other);
0: 
0: 		switch(op)
0: 		{
0: 		case ORDER_OP_LESSTHAN:
0: 			return (result < 0);   // this <  other
0: 		case ORDER_OP_EQUALS:
0: 			return (result == 0);  // this == other
0: 		case ORDER_OP_LESSOREQUALS:
0: 			return (result <= 0);  // this <= other
0: 		// flipped operators
0: 		case ORDER_OP_GREATERTHAN:
0: 			return (result > 0);   // this > other
0: 		case ORDER_OP_GREATEROREQUALS:
0: 			return (result >= 0);  // this >= other
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Invalid Operator");
0: 			return false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Flip the operator used in a comparison (< -> >).
0: 	 * This is useful when flipping a comparison due to
0: 	 * type precedence.
0: 	 * 
0: 	 * @param operator	The operator to flip.
0: 	 * 
0: 	 * @return The flipped operator.
0: 	 */
0: 	protected static int flip(int operator)
0: 	{
0: 		switch (operator)
0: 		{
0: 			case Orderable.ORDER_OP_LESSTHAN:
0: 				// < -> > 
0: 				return Orderable.ORDER_OP_GREATERTHAN;
0: 			case Orderable.ORDER_OP_LESSOREQUALS:
0: 				// <= -> >= 
0: 				return Orderable.ORDER_OP_GREATEROREQUALS;
0: 			case Orderable.ORDER_OP_EQUALS:
0: 				// = -> = 
0: 				return Orderable.ORDER_OP_EQUALS;
0: 			default:
0: 				// These operators only appear due to flipping.
0: 				// They should never be flipped themselves.
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"Attempting to flip an operator that is not " +
0: 						"expected to be flipped.");
0: 				}
0: 				return operator;
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#coalesce
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor coalesce(DataValueDescriptor[] argumentsList, DataValueDescriptor returnValue)
0: 						throws StandardException
0: 	{
0: 		// arguments list should have at least 2 arguments
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(argumentsList != null,
0: 				"argumentsList expected to be non-null");
0: 			SanityManager.ASSERT(argumentsList.length > 1,
0: 				"argumentsList.length expected to be > 1");
0: 		}
0: 
0: 		/* Walk the arguments list until we find a non-null value. Otherwise we will return null
0: 		 */
0: 		int index;
0: 		for (index = 0; index < argumentsList.length; index++)
0: 		{
0: 			if (!(argumentsList[index].isNull()))
0: 			{
0: 				returnValue.setValue(argumentsList[index]);
0: 				return returnValue;
0: 			}
0: 		}
0: 
0: 		returnValue.setToNull();
0: 		return returnValue;
0: 
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#in
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public BooleanDataValue in(DataValueDescriptor left,
0: 							   DataValueDescriptor[] inList,
0: 							   boolean orderedList) 
0: 						throws StandardException
0: 	{
0: 		BooleanDataValue retval = null;
0: 
0: 		// in list should be non-empty
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(inList != null,
0: 				"inList expected to be non-null");
0: 			SanityManager.ASSERT(inList.length > 0,
0: 				"inList.length expected to be > 0");
0: 		}
0: 
0: 		// if left is null then just return false
0: 		if (left.isNull())
0: 		{
0: 			return SQLBoolean.truthValue(left,
0: 									 inList[0],
0: 									 false);
0: 		}
0: 
0: 		int start = 0;
0: 		int finish = inList.length;
0: 
0: 		/* Do a binary search if the list is ordered until the 
0: 		 * range of values to search is 3 or less.
0: 		 * NOTE: We've ensured that the IN list and the left all have
0: 		 * the same precedence at compile time.  If we don't enforce 
0: 		 * the same precendence then
0: 		 * we could get the wrong result when doing a binary search.
0: 		 */
0: 		if (orderedList)
0: 		{
0: 			while (finish - start > 2)
0: 			{
0: 				int mid = ((finish - start) / 2) + start;
0: 				// Search left
0: 				retval = equals(left, inList[mid]);
0: 				if (retval.equals(true))
0: 				{
0: 					return retval;
0: 				}
0: 				BooleanDataValue goLeft = greaterThan(inList[mid], left);
0: 				if (goLeft.equals(true))
0: 				{
0: 					// search left
0: 					finish = mid;
0: 				}
0: 				else
0: 				{
0: 					// search right
0: 					start = mid;
0: 				}
0: 			}
0: 		}
0: 
0: 		/* Walk the in list comparing the values.  Return as soon as we
0: 		 * find a match.  If the list is ordered, return as soon as the left
0: 		 * value is greater than an element in the in list.
0: 		 */
0: 		for (int index = start; index < finish; index++)
0: 		{
0: 			retval = equals(left, inList[index]);
0: 			if (retval.equals(true))
0: 			{
0: 				break;
0: 			}
0: 
0: 			// Can we stop searching?
0: 			if (orderedList)
0: 			{
0: 				BooleanDataValue stop = greaterThan(inList[index], left);
0: 				if (stop.equals(true))
0: 				{
0: 					break;
0: 				}
0: 			}
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/*
0: 	 * equals
0: 	 */
0: 	public boolean equals(Object other)
0: 	{
0: 		if (! (other instanceof DataValueDescriptor))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		try
0: 		{
0: 			return compare(ORDER_OP_EQUALS, (DataValueDescriptor) other, true, false);
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			return false;
0: 		}
0: 	}
0: 
0: 	public void setValue(InputStream theStream, int streamLength) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.io.InputStream");
0: 	}
0: 
0: 	/**
0: 		Check the value to seem if it conforms to the restrictions
0: 		imposed by DB2/JCC on host variables for this type.
0: 
0: 		@exception StandardException Variable is too big.
0: 	*/
0: 	public void checkHostVariable(int declaredLength) throws StandardException
0: 	{
0: 	}
0: 
0: 
0: 	/**
0: 		Return an conversion exception for this type.
0: 	*/
0: 	protected final StandardException dataTypeConversion(String targetType) {
0: 		return StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
0: 			targetType, this.getTypeName());
0: 
0: 	}
0: 
0: 	/**
0: 		Return an out of range exception for this type.
0: 	*/
0: 	protected final StandardException outOfRange()
0: 	{
0: 		return StandardException.newException(
0: 				SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, getTypeName());
0: 	}
0: 
0: 	/**
0: 		Return an out of range exception for this type.
0: 	*/
0: 	protected final StandardException invalidFormat()
0: 	{
0: 		return StandardException.newException(
0: 				SQLState.LANG_FORMAT_EXCEPTION, getTypeName());
0: 	}
0: }
============================================================================