1:b8d1d8a: /*
1:b8d1d8a: 
1:b8d1d8a:  Derby - Class org.apache.derbyTesting.system.nstest.tester.TesterObject
1:b8d1d8a: 
1:b8d1d8a:  Licensed to the Apache Software Foundation (ASF) under one or more
1:b8d1d8a:  contributor license agreements.  See the NOTICE file distributed with
1:b8d1d8a:  this work for additional information regarding copyright ownership.
1:b8d1d8a:  The ASF licenses this file to You under the Apache License, Version 2.0
1:b8d1d8a:  (the "License"); you may not use this file except in compliance with
1:b8d1d8a:  the License.  You may obtain a copy of the License at
1:b8d1d8a: 
1:b8d1d8a:  http://www.apache.org/licenses/LICENSE-2.0
1:b8d1d8a: 
1:b8d1d8a:  Unless required by applicable law or agreed to in writing, software
1:b8d1d8a:  distributed under the License is distributed on an "AS IS" BASIS,
1:b8d1d8a:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b8d1d8a:  See the License for the specific language governing permissions and
1:b8d1d8a:  limitations under the License.
1:b8d1d8a: 
1:b8d1d8a:  */
1:b8d1d8a: 
1:b8d1d8a: package org.apache.derbyTesting.system.nstest.tester;
1:b8d1d8a: 
1:b8d1d8a: import java.sql.SQLException;
1:b8d1d8a: import java.sql.DriverManager;
1:b8d1d8a: import java.sql.Statement;
1:b8d1d8a: import java.sql.ResultSet;
1:b8d1d8a: import java.sql.Date;
1:b8d1d8a: import java.sql.Time;
1:b8d1d8a: import java.sql.Timestamp;
1:b8d1d8a: import java.sql.Connection;
1:b8d1d8a: 
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.NsTest;
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.utils.DbUtil;
1:b8d1d8a: 
1:b8d1d8a: /**
1:b8d1d8a:  * TesterObject - The base tester class for all the testers
1:b8d1d8a:  */
1:b8d1d8a: public class TesterObject {
1:b8d1d8a: 
1:b8d1d8a: 	private String thread_id;
1:5a56bcc:     private boolean _deadConnection = false;
1:b8d1d8a: 
1:b8d1d8a: 	protected Connection connex = null;
1:b8d1d8a: 
1:b8d1d8a: 	protected DbUtil dbutil;
1:b8d1d8a: 
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// Constructor. Get's the name of the thread running this for use in
1:b8d1d8a: 	// messages
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	public TesterObject(String name) {
1:b8d1d8a: 		this.thread_id = name;
1:b8d1d8a: 		dbutil = new DbUtil(getThread_id());
1:c043274: 		NsTest.logger.println("==========> " + getThread_id()
1:b8d1d8a: 				+ " THREAD starting <======");
2:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// Gets the connection to the database. Implemented so that threads that
1:b8d1d8a: 	// need to
1:b8d1d8a: 	// frequently get a connection can just call this method instead.
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 
1:b8d1d8a: 	public Connection getConnection() {
1:b8d1d8a: 		Connection conn = null;
1:b8d1d8a: 		String jdbcurl = "";
2:b8d1d8a: 		try {
1:c043274: 			NsTest.logger.println(getThread_id()
1:b8d1d8a: 					+ " is getting a connection to the database...");
1:b8d1d8a: 
1:b8d1d8a: 			if (NsTest.embeddedMode) {
1:b8d1d8a: 				jdbcurl = NsTest.embedDbURL + ";" + NsTest.bootPwd;
1:b8d1d8a: 			} else {
1:b8d1d8a: 				if (NsTest.driver_type.equalsIgnoreCase("DerbyClient"))
1:b8d1d8a: 					jdbcurl = NsTest.clientDbURL + ";" + NsTest.bootPwd;
1:b8d1d8a: 
1:b8d1d8a: 			}
1:c043274: 			NsTest.logger.println("-->Thread " + getThread_id()
1:b8d1d8a: 					+ " starting with url " + jdbcurl + " <--");
1:b8d1d8a: 			conn = DriverManager.getConnection(jdbcurl, NsTest.prop);
2:b8d1d8a: 		} catch (Exception e) {
1:c043274:             e.printStackTrace( NsTest.logger );
1:c043274: 			NsTest.logger.println("FAIL: " + getThread_id()
1:b8d1d8a: 					+ " could not get the database connection");
1:b8d1d8a: 			printException("Failed getting database connection using "
1:b8d1d8a: 					+ jdbcurl, e);
1:b8d1d8a: 		}
1:b8d1d8a: 		// for statistical purposes, add one to the num of connections makde
1:b8d1d8a: 		NsTest.addStats(NsTest.CONNECTIONS_MADE, 1);
1:c043274: 		NsTest.logger.println("Connection number: " + NsTest.numConnections);
1:b8d1d8a: 		return conn; // null if there was a problem, else a valid connection
1:b8d1d8a: 	}
1:b8d1d8a: 
1:0c997ed:     /** Get a new connection and raise an error if this can't be done */
1:0c997ed:     public  Connection  getNewConnection()
1:0c997ed:     {
1:0c997ed:         Connection  conn = getConnection();
1:0c997ed: 
1:0c997ed:         if ( conn == null )
1:0c997ed:         {
1:0c997ed:             throw new RuntimeException( "Could not get a connection!" );
1:0c997ed:         }
1:0c997ed: 
1:0c997ed:         return conn;
1:0c997ed:     }
1:0c997ed: 
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// Sets the isolation level to that indicated.
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	public void setIsolationLevel(int level) {
1:b8d1d8a: 		try {
1:b8d1d8a: 			connex.setTransactionIsolation(level);
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger.println("FAIL: " + getThread_id()
1:b8d1d8a: 					+ " could not set isolation level");
1:b8d1d8a: 			printException("setting transaction isolation", e);
1:b8d1d8a: 		}
1:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// Closes the connection to the database. Implemented so that threads that
1:b8d1d8a: 	// need to
1:b8d1d8a: 	// frequently close their connection can just call this method instead.
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	public void closeConnection() {
1:b8d1d8a: 		try {
1:c043274: 			NsTest.logger.println(getThread_id()
1:e276048: 					+ " is closing its connection to the database...");
1:b8d1d8a: 			connex.close();
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger.println("FAIL: " + getThread_id()
1:b8d1d8a: 					+ " could not close the database connection");
1:b8d1d8a: 			printException("closing database connection", e);
1:b8d1d8a: 		}
1:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	// ******************************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// This method will do a basic Insert/Delete/Update operation. We randomly
1:b8d1d8a: 	// decide whether
1:b8d1d8a: 	// we want to do either an Insert, a delete or an update
1:b8d1d8a: 	//
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************************
1:b8d1d8a: 	public void doIUDOperation() {
1:b8d1d8a: 		// decide Insert, Update or Delete
1:b8d1d8a: 		int decider = (int) (Math.random() * 100) % 3;
1:b8d1d8a: 
1:0c997ed:         if ( connex == null ) { connex = getNewConnection(); }
1:0c997ed: 
1:b8d1d8a: 		switch (decider) {
1:b8d1d8a: 
1:b8d1d8a: 		case 0: // do an Insert
1:b8d1d8a: 			try {
1:b8d1d8a: 				int numInsert = dbutil.add_one_row(connex, getThread_id());
1:b8d1d8a: 				if (numInsert == 1)
1:b8d1d8a: 					NsTest.addStats(NsTest.INSERT, 1);
1:b8d1d8a: 				else
1:b8d1d8a: 					NsTest.addStats(NsTest.FAILED_INSERT, 1);
1:b8d1d8a: 			} catch (Exception e) {
1:b8d1d8a: 				printException("executing add_one_row()", e);
1:5a56bcc:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
1:b8d1d8a: 			}
1:b8d1d8a: 
1:b8d1d8a: 			break;
1:b8d1d8a: 
1:b8d1d8a: 		case 1: // do an update
1:b8d1d8a: 
1:b8d1d8a: 			try {
1:b8d1d8a: 				int numUpdate = dbutil.update_one_row(connex, getThread_id());
1:b8d1d8a: 				if (numUpdate == 1)
1:b8d1d8a: 					NsTest.addStats(NsTest.UPDATE, 1);
1:b8d1d8a: 				else
1:b8d1d8a: 					NsTest.addStats(NsTest.FAILED_UPDATE, 1);
1:b8d1d8a: 			} catch (Exception e) {
1:b8d1d8a: 				printException("executing update_one_row", e);
1:5ccbc16:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
1:b8d1d8a: 			}
1:b8d1d8a: 			break;
1:b8d1d8a: 
1:b8d1d8a: 		case 2: // do a delete
1:b8d1d8a: 
1:b8d1d8a: 			try {
1:b8d1d8a: 				int numDelete = dbutil.delete_one_row(connex, getThread_id());
1:b8d1d8a: 				if (numDelete == 1)
1:b8d1d8a: 					NsTest.addStats(NsTest.DELETE, 1);
1:b8d1d8a: 				else
1:b8d1d8a: 					NsTest.addStats(NsTest.FAILED_DELETE, 1);
1:b8d1d8a: 			} catch (Exception e) {
1:b8d1d8a: 				printException("executing delete_one_row()", e);
1:5ccbc16:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
1:b8d1d8a: 			}
1:b8d1d8a: 			break;
1:b8d1d8a: 
1:b8d1d8a: 		}// end of switch(decider)
1:b8d1d8a: 	}// end of method doIUDOperation()
1:b8d1d8a: 
1:b8d1d8a: 	// ******************************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// This method will do a basic Select operation based on the following
1:b8d1d8a: 	// criteria
1:b8d1d8a: 	// The query should return approximately nstest.MAX_LOW_STRESS number of
1:e276048: 	// rows that we loop through via a result set and perform operations 
1:e276048: 	// (getXX calls) in order to ensure that data flows properly. The method 
1:e276048: 	// will return the total number of rows selected. Note that we do not touch
1:e276048: 	// rows with serialkey less than nstest.NUM_UNTOUCHED_ROWS, and the selects
1:e276048: 	// will be based on the parameter passed in, viz numRowsToSelect which is
1:e276048: 	// <= nstest.NUM_UNTOUCHED_ROWS
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************************
1:b8d1d8a: 	public int doSelectOperation(int numRowsToSelect) throws SQLException {
1:b8d1d8a: 
1:b8d1d8a: 		int numRowsSelected = 0;
1:b8d1d8a: 		ResultSet rSet = null;
1:b8d1d8a: 		Statement s = null;
1:b8d1d8a: 
1:c043274: 		NsTest.logger.println(getThread_id() + " is selecting " + numRowsToSelect
2:b8d1d8a: 				+ " rows");
1:b8d1d8a: 		try {
1:b8d1d8a: 			// create the statement
1:b8d1d8a: 
1:b8d1d8a: 			s = connex.createStatement();
1:b8d1d8a: 			// Execute the query
1:b8d1d8a: 			rSet = s
1:b8d1d8a: 			.executeQuery("select id, t_char,"
1:b8d1d8a: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1:b8d1d8a: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1:b8d1d8a: 					+ " t_real, t_smallint, t_time, t_timestamp,"
1:b13fb1c: 					+ " t_varchar, serialkey, sequenceColumn from nstesttab where serialkey <= "
1:b8d1d8a: 					+ numRowsToSelect);
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println("FAIL: doSelectOperation() had problems creating/executing query");
1:b8d1d8a: 			printException(
1:b8d1d8a: 					"FAIL: doSelectOperation() had problems creating/executing query",
1:b8d1d8a: 					e);
1:5a56bcc:             if ( rSet != null ) { rSet.close(); }
1:5a56bcc: 			if ( s != null ) { s.close(); }
1:5a56bcc: 
1:5a56bcc:             return numRowsSelected;
1:b8d1d8a: 		}
1:b8d1d8a: 
1:3d7c2ea: 		if (rSet != null) {
1:e276048: 		    // Now work over the returned ResultSet and keep track of number of
1:e276048: 		    // rows returned
1:3d7c2ea: 		    // We execute the getXXX methods on each of the selected columns so that
1:e276048: 		    // data flow out from the network server is also tested.
1:3d7c2ea: 		    try {
1:3d7c2ea: 		        while (rSet.next()) {
1:3d7c2ea: 		            // get value of column id
1:3d7c2ea: 		            int id1 = rSet.getInt(1);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_char
1:3d7c2ea: 		            String str1 = rSet.getString(2);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_date
1:3d7c2ea: 		            Date dt = rSet.getDate(3);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_decimal
1:3d7c2ea: 		            double doub1 = rSet.getDouble(4);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_decimal_nn
1:3d7c2ea: 		            double doub2 = rSet.getDouble(5);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_double
1:3d7c2ea: 		            double doub3 = rSet.getDouble(6);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_float
1:3d7c2ea: 		            float flt1 = rSet.getFloat(7);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_int
1:3d7c2ea: 		            int id2 = rSet.getInt(8);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_longint
1:3d7c2ea: 		            long lg1 = rSet.getLong(9);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_numeric_large
1:3d7c2ea: 		            double doub4 = rSet.getDouble(10);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_real
1:3d7c2ea: 		            float flt2 = rSet.getFloat(11);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_smallint
1:3d7c2ea: 		            int id3 = rSet.getInt(12);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_time
1:3d7c2ea: 		            Time tm = rSet.getTime(13);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_timestamp
1:3d7c2ea: 		            Timestamp tstmp = rSet.getTimestamp(14);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column t_varchar
1:3d7c2ea: 		            String str2 = rSet.getString(15);
1:b8d1d8a: 
1:3d7c2ea: 		            // get value of column serialkey
1:3d7c2ea: 		            long lg2 = rSet.getLong(16);
1:b8d1d8a: 
1:b13fb1c: 		            // get value of sequence column
1:b13fb1c: 		            long lg3 = rSet.getLong(17);
1:b13fb1c: 
1:3d7c2ea: 		            numRowsSelected++;
1:3d7c2ea: 		        }
1:3d7c2ea: 		        NsTest.addStats(NsTest.SELECT, 1);
1:c043274: 		        NsTest.logger.println(this.thread_id + " selected " + numRowsSelected
1:3d7c2ea: 		                + " rows");
1:3d7c2ea: 		    } catch (Exception e) {
1:c043274: 		        NsTest.logger
1:3d7c2ea: 		        .println("FAIL: doSelectOperation() had problems working over the ResultSet");
1:3d7c2ea: 		        NsTest.addStats(NsTest.FAILED_SELECT, 1);
1:3d7c2ea: 		        printException("processing ResultSet during row data retrieval", e);
1:5a56bcc: 		        if ( rSet != null ) { rSet.close(); }
1:5a56bcc: 		        if ( s != null ) { s.close(); }
1:c043274: 		        NsTest.logger.println("Closed the select statement");
1:b8d1d8a: 		    }
1:b8d1d8a: 		}
1:b8d1d8a: 
1:e276048: 		// close the ResultSet and statement and release its resources.
1:b8d1d8a: 		try {
1:b8d1d8a: 			if ((rSet != null) && (s != null)) {
1:3d7c2ea: 				rSet.close();
1:3d7c2ea: 				s.close();
1:c043274: 				NsTest.logger.println("Closed the select statement");
1:3d7c2ea: 			}
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println("FAIL: doSelectOperation() had problems closing the ResultSet");
1:b8d1d8a: 			printException("closing ResultSet of query to get row data", e);
1:b8d1d8a: 		}
1:b8d1d8a: 
1:b8d1d8a: 		return numRowsSelected;
1:b8d1d8a: 	}// end of doSelectOperation()
1:b8d1d8a: 
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	//
1:b8d1d8a: 	// This starts the acutal test operations
1:b8d1d8a: 	//
1:b8d1d8a: 	// *******************************************************************************
1:b8d1d8a: 	public void startTesting() {
1:b8d1d8a: 
1:b8d1d8a: 		// This method needs to be overridden by the child classes in order for
1:e276048: 		// a Tester to be able to do work. The specifics such as how often the
1:e276048: 		// connection is opened and closed and how many transactions are done 
1:e276048: 		// etc etc which form individual test cases or sorts are left to the 
1:e276048: 		// child class to implement in their overridden version of this method.
1:b8d1d8a: 
1:b8d1d8a: 	}// end of startTesting()
1:b8d1d8a: 
1:b8d1d8a: 	// ** This method abstracts exception message printing for all exception
1:e276048: 	// messages. You may want to change it if more detailed exception messages
1:e276048: 	// are desired.
1:b8d1d8a: 	// ***Method is synchronized so that the output file will contain sensible
1:e276048: 	// stack traces that are not mixed but one exception printed at a time
1:b8d1d8a: 	public synchronized void printException(String where, Exception e) {
1:c043274:         if ( NsTest.justCountErrors() )
1:c043274:         {
1:c043274:             NsTest.addError( e );
1:c043274:             return;
1:c043274:         }
1:c043274: 
1:b8d1d8a: 		if (e instanceof SQLException) {
1:b8d1d8a: 			SQLException se = (SQLException) e;
1:b8d1d8a: 
1:b8d1d8a: 			if (se.getSQLState().equals("40001"))
1:c043274: 				NsTest.logger.println("TObj --> deadlocked detected");
1:b8d1d8a: 			if (se.getSQLState().equals("40XL1"))
1:c043274: 				NsTest.logger.println("TObj --> lock timeout exception");
1:b8d1d8a: 			if (se.getSQLState().equals("23500"))
1:c043274: 				NsTest.logger.println("TObj --> duplicate key violation");
1:b8d1d8a: 			if (se.getNextException() != null) {
1:b8d1d8a: 				String m = se.getNextException().getSQLState();
1:c043274: 				NsTest.logger.println(se.getNextException().getMessage()
1:b8d1d8a: 						+ " SQLSTATE: " + m);
1:b8d1d8a: 			}
1:b8d1d8a: 		}
1:b8d1d8a: 		if (e.getMessage() == null) {
1:c043274: 			NsTest.logger.println("TObj -->NULL error message detected");
1:c043274: 			NsTest.logger.println("TObj -->Here is the NULL exception - "
1:b8d1d8a: 					+ e.toString());
1:c043274: 			NsTest.logger.println("TObj -->Stack trace of the NULL exception - ");
1:c043274: 			e.printStackTrace( NsTest.logger );
1:b8d1d8a: 		}
1:c043274: 		NsTest.logger.println("TObj -->At this point - " + where
1:b8d1d8a: 				+ ", exception thrown was : " + e.getMessage());
1:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	public String getTimestamp() {
1:b8d1d8a: 		Timestamp ts = new Timestamp(System.currentTimeMillis());
1:b8d1d8a: 		return ts.toString();
1:b8d1d8a: 	}
1:b8d1d8a: 
1:b8d1d8a: 	public String getThread_id() {
1:b8d1d8a: 		return thread_id;
1:b8d1d8a: 	}
1:b8d1d8a: 
1:5a56bcc:     public  void    markDeadConnection() { _deadConnection = true; }
1:5a56bcc: 
1:5a56bcc:     public  boolean deadConnection() { return _deadConnection; }
1:5a56bcc: 
1:b8d1d8a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5ccbc16
/////////////////////////////////////////////////////////////////////////
1:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
/////////////////////////////////////////////////////////////////////////
1:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
commit:0c997ed
/////////////////////////////////////////////////////////////////////////
1:     /** Get a new connection and raise an error if this can't be done */
1:     public  Connection  getNewConnection()
1:     {
1:         Connection  conn = getConnection();
1: 
1:         if ( conn == null )
1:         {
1:             throw new RuntimeException( "Could not get a connection!" );
1:         }
1: 
1:         return conn;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( connex == null ) { connex = getNewConnection(); }
1: 
commit:5a56bcc
/////////////////////////////////////////////////////////////////////////
1:     private boolean _deadConnection = false;
/////////////////////////////////////////////////////////////////////////
1:                 if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }
/////////////////////////////////////////////////////////////////////////
1:             if ( rSet != null ) { rSet.close(); }
1: 			if ( s != null ) { s.close(); }
1: 
1:             return numRowsSelected;
/////////////////////////////////////////////////////////////////////////
1: 		        if ( rSet != null ) { rSet.close(); }
1: 		        if ( s != null ) { s.close(); }
/////////////////////////////////////////////////////////////////////////
1:     public  void    markDeadConnection() { _deadConnection = true; }
1: 
1:     public  boolean deadConnection() { return _deadConnection; }
1: 
commit:b13fb1c
/////////////////////////////////////////////////////////////////////////
1: 					+ " t_varchar, serialkey, sequenceColumn from nstesttab where serialkey <= "
/////////////////////////////////////////////////////////////////////////
1: 		            // get value of sequence column
1: 		            long lg3 = rSet.getLong(17);
1: 
commit:c043274
/////////////////////////////////////////////////////////////////////////
1: 		NsTest.logger.println("==========> " + getThread_id()
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println(getThread_id()
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println("-->Thread " + getThread_id()
1:             e.printStackTrace( NsTest.logger );
1: 			NsTest.logger.println("FAIL: " + getThread_id()
1: 		NsTest.logger.println("Connection number: " + NsTest.numConnections);
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println("FAIL: " + getThread_id()
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println(getThread_id()
1: 			NsTest.logger.println("FAIL: " + getThread_id()
/////////////////////////////////////////////////////////////////////////
1: 		NsTest.logger.println(getThread_id() + " is selecting " + numRowsToSelect
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger
/////////////////////////////////////////////////////////////////////////
1: 		        NsTest.logger.println(this.thread_id + " selected " + numRowsSelected
1: 		        NsTest.logger
1: 		        NsTest.logger.println("Closed the select statement");
/////////////////////////////////////////////////////////////////////////
1: 				NsTest.logger.println("Closed the select statement");
1: 			NsTest.logger
/////////////////////////////////////////////////////////////////////////
1:         if ( NsTest.justCountErrors() )
1:         {
1:             NsTest.addError( e );
1:             return;
1:         }
1: 
1: 				NsTest.logger.println("TObj --> deadlocked detected");
1: 				NsTest.logger.println("TObj --> lock timeout exception");
1: 				NsTest.logger.println("TObj --> duplicate key violation");
1: 				NsTest.logger.println(se.getNextException().getMessage()
1: 			NsTest.logger.println("TObj -->NULL error message detected");
1: 			NsTest.logger.println("TObj -->Here is the NULL exception - "
1: 			NsTest.logger.println("TObj -->Stack trace of the NULL exception - ");
1: 			e.printStackTrace( NsTest.logger );
1: 		NsTest.logger.println("TObj -->At this point - " + where
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:e276048
/////////////////////////////////////////////////////////////////////////
1: 					+ " is closing its connection to the database...");
/////////////////////////////////////////////////////////////////////////
1: 	// rows that we loop through via a result set and perform operations 
1: 	// (getXX calls) in order to ensure that data flows properly. The method 
1: 	// will return the total number of rows selected. Note that we do not touch
1: 	// rows with serialkey less than nstest.NUM_UNTOUCHED_ROWS, and the selects
1: 	// will be based on the parameter passed in, viz numRowsToSelect which is
1: 	// <= nstest.NUM_UNTOUCHED_ROWS
/////////////////////////////////////////////////////////////////////////
1: 		    // Now work over the returned ResultSet and keep track of number of
1: 		    // rows returned
1: 		    // data flow out from the network server is also tested.
/////////////////////////////////////////////////////////////////////////
1: 		// close the ResultSet and statement and release its resources.
/////////////////////////////////////////////////////////////////////////
1: 		// a Tester to be able to do work. The specifics such as how often the
1: 		// connection is opened and closed and how many transactions are done 
1: 		// etc etc which form individual test cases or sorts are left to the 
1: 		// child class to implement in their overridden version of this method.
1: 	// messages. You may want to change it if more detailed exception messages
1: 	// are desired.
1: 	// stack traces that are not mixed but one exception printed at a time
commit:3d7c2ea
/////////////////////////////////////////////////////////////////////////
1: 		if (rSet != null) {
0: 		    // Now work over the returned ResultSet and keep track of number of rows
0: 		    // returned
1: 		    // We execute the getXXX methods on each of the selected columns so that
0: 		    // data flow out
0: 		    // from the network server is also tested.
1: 		    try {
1: 		        while (rSet.next()) {
1: 		            // get value of column id
1: 		            int id1 = rSet.getInt(1);
1: 		            // get value of column t_char
1: 		            String str1 = rSet.getString(2);
1: 		            // get value of column t_date
1: 		            Date dt = rSet.getDate(3);
1: 		            // get value of column t_decimal
1: 		            double doub1 = rSet.getDouble(4);
1: 		            // get value of column t_decimal_nn
1: 		            double doub2 = rSet.getDouble(5);
1: 		            // get value of column t_double
1: 		            double doub3 = rSet.getDouble(6);
1: 		            // get value of column t_float
1: 		            float flt1 = rSet.getFloat(7);
1: 		            // get value of column t_int
1: 		            int id2 = rSet.getInt(8);
1: 		            // get value of column t_longint
1: 		            long lg1 = rSet.getLong(9);
1: 		            // get value of column t_numeric_large
1: 		            double doub4 = rSet.getDouble(10);
1: 		            // get value of column t_real
1: 		            float flt2 = rSet.getFloat(11);
1: 		            // get value of column t_smallint
1: 		            int id3 = rSet.getInt(12);
1: 		            // get value of column t_time
1: 		            Time tm = rSet.getTime(13);
1: 		            // get value of column t_timestamp
1: 		            Timestamp tstmp = rSet.getTimestamp(14);
1: 		            // get value of column t_varchar
1: 		            String str2 = rSet.getString(15);
1: 		            // get value of column serialkey
1: 		            long lg2 = rSet.getLong(16);
1: 		            numRowsSelected++;
1: 		        }
1: 		        NsTest.addStats(NsTest.SELECT, 1);
0: 		        System.out.println(this.thread_id + " selected " + numRowsSelected
1: 		                + " rows");
1: 		    } catch (Exception e) {
0: 		        System.out
1: 		        .println("FAIL: doSelectOperation() had problems working over the ResultSet");
1: 		        NsTest.addStats(NsTest.FAILED_SELECT, 1);
1: 		        printException("processing ResultSet during row data retrieval", e);
1: 		        rSet.close();
1: 		        s.close();
0: 		        System.out.println("Closed the select statement");
1: 		    }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:b8d1d8a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:  Derby - Class org.apache.derbyTesting.system.nstest.tester.TesterObject
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.system.nstest.tester;
1: 
1: import java.sql.SQLException;
1: import java.sql.DriverManager;
1: import java.sql.Statement;
1: import java.sql.ResultSet;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Connection;
1: 
1: import org.apache.derbyTesting.system.nstest.NsTest;
1: import org.apache.derbyTesting.system.nstest.utils.DbUtil;
1: 
1: /**
1:  * TesterObject - The base tester class for all the testers
1:  */
1: public class TesterObject {
1: 
1: 	private String thread_id;
1: 
1: 	protected Connection connex = null;
1: 
1: 	protected DbUtil dbutil;
1: 
1: 	// *******************************************************************************
1: 	//
1: 	// Constructor. Get's the name of the thread running this for use in
1: 	// messages
1: 	//
1: 	// *******************************************************************************
1: 	public TesterObject(String name) {
1: 		this.thread_id = name;
1: 		dbutil = new DbUtil(getThread_id());
0: 		System.out.println("==========> " + getThread_id()
1: 				+ " THREAD starting <======");
1: 	}
1: 
1: 	// *******************************************************************************
1: 	//
1: 	// Gets the connection to the database. Implemented so that threads that
1: 	// need to
1: 	// frequently get a connection can just call this method instead.
1: 	//
1: 	// *******************************************************************************
1: 
1: 	public Connection getConnection() {
1: 		Connection conn = null;
1: 		String jdbcurl = "";
1: 		try {
0: 			System.out.println(getThread_id()
1: 					+ " is getting a connection to the database...");
1: 
1: 			if (NsTest.embeddedMode) {
1: 				jdbcurl = NsTest.embedDbURL + ";" + NsTest.bootPwd;
1: 			} else {
1: 				if (NsTest.driver_type.equalsIgnoreCase("DerbyClient"))
1: 					jdbcurl = NsTest.clientDbURL + ";" + NsTest.bootPwd;
1: 
1: 			}
0: 			System.out.println("-->Thread " + getThread_id()
1: 					+ " starting with url " + jdbcurl + " <--");
1: 			conn = DriverManager.getConnection(jdbcurl, NsTest.prop);
1: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 			System.out.println("FAIL: " + getThread_id()
1: 					+ " could not get the database connection");
1: 			printException("Failed getting database connection using "
1: 					+ jdbcurl, e);
1: 		}
1: 		// for statistical purposes, add one to the num of connections makde
1: 		NsTest.addStats(NsTest.CONNECTIONS_MADE, 1);
0: 		System.out.println("Connection number: " + NsTest.numConnections);
1: 		return conn; // null if there was a problem, else a valid connection
1: 	}
1: 
1: 	// *******************************************************************************
1: 	//
1: 	// Sets the isolation level to that indicated.
1: 	//
1: 	// *******************************************************************************
1: 	public void setIsolationLevel(int level) {
1: 		try {
1: 			connex.setTransactionIsolation(level);
1: 		} catch (Exception e) {
0: 			System.out.println("FAIL: " + getThread_id()
1: 					+ " could not set isolation level");
1: 			printException("setting transaction isolation", e);
1: 		}
1: 	}
1: 
1: 	// *******************************************************************************
1: 	//
1: 	// Closes the connection to the database. Implemented so that threads that
1: 	// need to
1: 	// frequently close their connection can just call this method instead.
1: 	//
1: 	// *******************************************************************************
1: 	public void closeConnection() {
1: 		try {
0: 			System.out.println(getThread_id()
0: 					+ " is closing it's connection to the database...");
1: 			connex.close();
1: 		} catch (Exception e) {
0: 			System.out.println("FAIL: " + getThread_id()
1: 					+ " could not close the database connection");
1: 			printException("closing database connection", e);
1: 		}
1: 	}
1: 
1: 	// ******************************************************************************************
1: 	//
1: 	// This method will do a basic Insert/Delete/Update operation. We randomly
1: 	// decide whether
1: 	// we want to do either an Insert, a delete or an update
1: 	//
1: 	//
1: 	// *******************************************************************************************
1: 	public void doIUDOperation() {
1: 		// decide Insert, Update or Delete
1: 		int decider = (int) (Math.random() * 100) % 3;
1: 
1: 		switch (decider) {
1: 
1: 		case 0: // do an Insert
1: 			try {
1: 				int numInsert = dbutil.add_one_row(connex, getThread_id());
1: 				if (numInsert == 1)
1: 					NsTest.addStats(NsTest.INSERT, 1);
1: 				else
1: 					NsTest.addStats(NsTest.FAILED_INSERT, 1);
1: 			} catch (Exception e) {
1: 				printException("executing add_one_row()", e);
1: 			}
1: 
1: 			break;
1: 
1: 		case 1: // do an update
1: 
1: 			try {
1: 				int numUpdate = dbutil.update_one_row(connex, getThread_id());
1: 				if (numUpdate == 1)
1: 					NsTest.addStats(NsTest.UPDATE, 1);
1: 				else
1: 					NsTest.addStats(NsTest.FAILED_UPDATE, 1);
1: 			} catch (Exception e) {
1: 				printException("executing update_one_row", e);
1: 			}
1: 			break;
1: 
1: 		case 2: // do a delete
1: 
1: 			try {
1: 				int numDelete = dbutil.delete_one_row(connex, getThread_id());
1: 				if (numDelete == 1)
1: 					NsTest.addStats(NsTest.DELETE, 1);
1: 				else
1: 					NsTest.addStats(NsTest.FAILED_DELETE, 1);
1: 			} catch (Exception e) {
1: 				printException("executing delete_one_row()", e);
1: 			}
1: 			break;
1: 
1: 		}// end of switch(decider)
1: 	}// end of method doIUDOperation()
1: 
1: 	// ******************************************************************************************
1: 	//
1: 	// This method will do a basic Select operation based on the following
1: 	// criteria
1: 	// The query should return approximately nstest.MAX_LOW_STRESS number of
0: 	// rows that we
0: 	// loop through via a result set and perform operations (getXX calls) in
0: 	// order to ensure
0: 	// that data flows properly. The method will
0: 	// return the total number of rows selected. Note that we do not touch rows
0: 	// with serialkey
0: 	// less than nstest.NUM_UNTOUCHED_ROWS, and the selects will be based on the
0: 	// parameter passed
0: 	// in, viz numRowsToSelect which is <= nstest.NUM_UNTOUCHED_ROWS
1: 	//
1: 	// *******************************************************************************************
1: 	public int doSelectOperation(int numRowsToSelect) throws SQLException {
1: 
1: 		int numRowsSelected = 0;
1: 		ResultSet rSet = null;
1: 		Statement s = null;
1: 
0: 		System.out.println(getThread_id() + " is selecting " + numRowsToSelect
1: 				+ " rows");
1: 		try {
1: 			// create the statement
1: 
1: 			s = connex.createStatement();
1: 			// Execute the query
1: 			rSet = s
1: 			.executeQuery("select id, t_char,"
1: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1: 					+ " t_real, t_smallint, t_time, t_timestamp,"
0: 					+ " t_varchar, serialkey from nstesttab where serialkey <= "
1: 					+ numRowsToSelect);
1: 		} catch (Exception e) {
0: 			System.out
1: 			.println("FAIL: doSelectOperation() had problems creating/executing query");
1: 			printException(
1: 					"FAIL: doSelectOperation() had problems creating/executing query",
1: 					e);
0: 			s.close();
1: 		}
1: 
0: 		// Now work over the returned ResultSet and keep track of number of rows
0: 		// returned
0: 		// We execute the getXXX methods on each of the selected columns so that
0: 		// data flow out
0: 		// from the network server is also tested.
1: 		try {
0: 			while (rSet.next()) {
0: 				// get value of column id
0: 				int id1 = rSet.getInt(1);
1: 
0: 				// get value of column t_char
0: 				String str1 = rSet.getString(2);
1: 
0: 				// get value of column t_date
0: 				Date dt = rSet.getDate(3);
1: 
0: 				// get value of column t_decimal
0: 				double doub1 = rSet.getDouble(4);
1: 
0: 				// get value of column t_decimal_nn
0: 				double doub2 = rSet.getDouble(5);
1: 
0: 				// get value of column t_double
0: 				double doub3 = rSet.getDouble(6);
1: 
0: 				// get value of column t_float
0: 				float flt1 = rSet.getFloat(7);
1: 
0: 				// get value of column t_int
0: 				int id2 = rSet.getInt(8);
1: 
0: 				// get value of column t_longint
0: 				long lg1 = rSet.getLong(9);
1: 
0: 				// get value of column t_numeric_large
0: 				double doub4 = rSet.getDouble(10);
1: 
0: 				// get value of column t_real
0: 				float flt2 = rSet.getFloat(11);
1: 
0: 				// get value of column t_smallint
0: 				int id3 = rSet.getInt(12);
1: 
0: 				// get value of column t_time
0: 				Time tm = rSet.getTime(13);
1: 
0: 				// get value of column t_timestamp
0: 				Timestamp tstmp = rSet.getTimestamp(14);
1: 
0: 				// get value of column t_varchar
0: 				String str2 = rSet.getString(15);
1: 
0: 				// get value of column serialkey
0: 				long lg2 = rSet.getLong(16);
1: 
0: 				numRowsSelected++;
1: 			}
0: 			NsTest.addStats(NsTest.SELECT, 1);
0: 			System.out.println(this.thread_id + " selected " + numRowsSelected
1: 					+ " rows");
1: 		} catch (Exception e) {
0: 			System.out
0: 			.println("FAIL: doSelectOperation() had problems working over the ResultSet");
0: 			NsTest.addStats(NsTest.FAILED_SELECT, 1);
0: 			printException("processing ResultSet during row data retrieval", e);
0: 			rSet.close();
0: 			s.close();
0: 			System.out.println("Closed the select statement");
1: 		}
1: 
0: 		// close the ResultSet and statement and release it's resources.
1: 		try {
1: 			if ((rSet != null) && (s != null)) {
0: 				rSet.close();
0: 				s.close();
0: 				System.out.println("Closed the select statement");
1: 			}
1: 		} catch (Exception e) {
0: 			System.out
1: 			.println("FAIL: doSelectOperation() had problems closing the ResultSet");
1: 			printException("closing ResultSet of query to get row data", e);
1: 		}
1: 
1: 		return numRowsSelected;
1: 	}// end of doSelectOperation()
1: 
1: 	// *******************************************************************************
1: 	//
1: 	// This starts the acutal test operations
1: 	//
1: 	// *******************************************************************************
1: 	public void startTesting() {
1: 
1: 		// This method needs to be overridden by the child classes in order for
0: 		// a Tester to
0: 		// be able to do work. The specifics such as how often the connection is
0: 		// opened and
0: 		// closed and how many transactions are done etc etc which form
0: 		// individual test cases or
0: 		// sorts are left to the child class to implement in their overridden
0: 		// version of this
0: 		// method
1: 
1: 	}// end of startTesting()
1: 
1: 	// ** This method abstracts exception message printing for all exception
0: 	// messages. You may want to change
0: 	// ****it if more detailed exception messages are desired.
1: 	// ***Method is synchronized so that the output file will contain sensible
0: 	// stack traces that are not
0: 	// ****mixed but rather one exception printed at a time
1: 	public synchronized void printException(String where, Exception e) {
1: 		if (e instanceof SQLException) {
1: 			SQLException se = (SQLException) e;
1: 
1: 			if (se.getSQLState().equals("40001"))
0: 				System.out.println("TObj --> deadlocked detected");
1: 			if (se.getSQLState().equals("40XL1"))
0: 				System.out.println("TObj --> lock timeout exception");
1: 			if (se.getSQLState().equals("23500"))
0: 				System.out.println("TObj --> duplicate key violation");
1: 			if (se.getNextException() != null) {
1: 				String m = se.getNextException().getSQLState();
0: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 			}
1: 		}
1: 		if (e.getMessage() == null) {
0: 			System.out.println("TObj -->NULL error message detected");
0: 			System.out.println("TObj -->Here is the NULL exception - "
1: 					+ e.toString());
0: 			System.out.println("TObj -->Stack trace of the NULL exception - ");
0: 			e.printStackTrace(System.out);
1: 		}
0: 		System.out.println("TObj -->At this point - " + where
1: 				+ ", exception thrown was : " + e.getMessage());
1: 	}
1: 
1: 	public String getTimestamp() {
1: 		Timestamp ts = new Timestamp(System.currentTimeMillis());
1: 		return ts.toString();
1: 	}
1: 
1: 	public String getThread_id() {
1: 		return thread_id;
1: 	}
1: 
1: }
============================================================================