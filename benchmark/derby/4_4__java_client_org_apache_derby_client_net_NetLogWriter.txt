1:33776ff: /*
15:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetLogWriter
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:33776ff: // network traffic tracer.
1:b13b17c: 
1:69e3d06: import java.io.PrintWriter;
1:69e3d06: import org.apache.derby.client.am.ClientConnection;
1:b13b17c: import org.apache.derby.client.am.LogWriter;
1:b13b17c: import org.apache.derby.jdbc.ClientDataSource;
1:b13b17c: 
1:33776ff: // This class traces communication buffers for both sends and receives.
1:33776ff: // The value of the hex bytes are traced along with the ascii and ebcdic translations.
1:33776ff: 
1:b13b17c: public class NetLogWriter extends LogWriter {
1:33776ff: 
1:70f7692:     // The recevie constant is used to indicate that the bytes were read to a Stream.
1:70f7692:     // It indicates to this class that a receive header should be used.
1:0326967:     static final int TYPE_TRACE_RECEIVE = 2;
1:33776ff: 
1:70f7692:     // The send constant is used to indicate that the bytes were written to
1:70f7692:     // a Stream.  It indicates to this class that a send header should be used.
1:0326967:     static final int TYPE_TRACE_SEND = 1;
1:33776ff: 
1:70f7692:     //------------------------------ internal constants --------------------------
1:33776ff: 
1:70f7692:     // This class was implemented using character arrays to translate bytes
1:70f7692:     // into ascii and ebcdic.  The goal was to be able to quickly index into the
1:70f7692:     // arrays to find the characters.  Char arrays instead of strings were used as
1:70f7692:     // much as possible in an attempt to help speed up performance.
1:33776ff: 
1:70f7692:     // An array of characters used to translate bytes to ascii.
1:70f7692:     // The position in the array corresponds to the hex value of the character.
1:70f7692:     private static final char asciiChar__ [] = {
1:70f7692:         // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //0
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //1
1:70f7692:         ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', //2
1:70f7692:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', //3
1:70f7692:         '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', //4
1:70f7692:         'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', //5
1:70f7692:         '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', //6
1:70f7692:         'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '.', //7
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //8
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //9
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //A
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //B
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //C
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //D
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //E
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'   //F
1:70f7692:     };
1:33776ff: 
1:70f7692:     // This column position header is used to mark offsets into the trace.
1:70f7692:     private static final String colPosHeader__ =
1:70f7692:             "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
1:33776ff: 
1:70f7692:     // An array of characters used to translate bytes to ebcdic.
1:70f7692:     // The position in the array corresponds to the hex value of the
1:70f7692:     // character.
1:70f7692:     private static final char ebcdicChar__[] = {
1:70f7692:         // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //0
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //1
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //2
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //3
1:70f7692:         ' ', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '<', '(', '+', '|', //4
1:70f7692:         '&', '.', '.', '.', '.', '.', '.', '.', '.', '.', '!', '$', '*', ')', ';', '.', //5
1:70f7692:         '-', '/', '.', '.', '.', '.', '.', '.', '.', '.', '|', ',', '%', '_', '>', '?', //6
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '`', ':', '#', '@', '\'', '=', '"', //7
1:70f7692:         '.', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', '.', '.', '.', '.', '.', '.', //8
1:70f7692:         '.', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', '.', '.', '.', '.', '.', '.', //9
1:70f7692:         '.', '~', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', '.', '.', '.', '.', '.', //A
1:70f7692:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //B
1:70f7692:         '{', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', '.', '.', '.', '.', '.', '.', //C
1:70f7692:         '}', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', '.', '.', '.', '.', '.', '.', //D
1:70f7692:         '\\', '.', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '.', '.', '.', '.', '.', '.', //E
1:70f7692:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '.', '.', '.', '.', '.'   //F
1:70f7692:     };
1:33776ff: 
1:70f7692:     // An array of characters representing hex numbers.
1:70f7692:     private static final char hexDigit__ [] = {
1:70f7692:         '0', '1', '2', '3', '4', '5', '6', '7',
1:70f7692:         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
1:70f7692:     };
1:33776ff: 
1:70f7692:     // The receive header comes befor bytes which would be read from a stream.
1:70f7692:     private static final String receiveHeader__ =
1:70f7692:             "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
1:33776ff: 
1:70f7692:     // The send header comes before bytes which would be written to a stream.
1:70f7692:     private static final String sendHeader__ =
1:70f7692:             "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
1:33776ff: 
1:70f7692:     private static final char spaceChar__ = ' ';
1:33776ff: 
1:70f7692:     private static final char zeroChar__ = '0';
1:33776ff: 
1:70f7692:     // This mapping table associates a codepoint to a String describing the codepoint.
1:70f7692:     // This is needed because the trace prints the first codepoint in send and receive buffers.
1:70f7692:     // This is created lazily because there is no need to create the mapping if tracing isn't used.
1:70f7692:     // So this array will only be created when the com buffer trace is started.
1:70f7692:     private static CodePointNameTable codePointNameTable__ = null;
1:33776ff: 
1:70f7692:     //-----------------------------internal state---------------------------------
1:33776ff: 
1:70f7692:     //-----------------------------constructors/finalizer-------------------------
1:33776ff: 
1:70f7692:     // One NetLogWriter object is created per data source, iff tracing is enabled.
1:69e3d06:     public NetLogWriter(PrintWriter printWriter, int traceLevel) {
1:70f7692:         super(printWriter, traceLevel);
1:70f7692: 
1:70f7692:         // Initialize the codepoint name table if not previously initialized.
1:70f7692:         // This is done lazily so that it is not created if the trace isn't used (save some init time).
1:49be70b: 
1:49be70b:         if (codePointNameTable__ == null) {
1:49be70b:             initCodePointTable();
1:49be70b:         }
1:49be70b:     }
1:49be70b: 
1:49be70b:     // synchonized so only one thread can initialize the table
1:49be70b:     private synchronized void initCodePointTable() {
1:70f7692:         if (codePointNameTable__ == null) {
1:70f7692:             codePointNameTable__ = new CodePointNameTable();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     //------------------------------entry points----------------------------------
1:33776ff: 
1:70f7692:     // Specialization of LogWriter.traceConnectsExit()
1:69e3d06:     public void traceConnectsExit(ClientConnection connection) {
1:70f7692:         NetConnection c = (NetConnection) connection;
1:70f7692:         synchronized (printWriter_) {
1:70f7692:             super.traceConnectsExit(c);
1:70f7692:             dncnetprint("  PROTOCOL manager levels: { ");
1:70f7692:             printWriter_.print("SQLAM=" + c.getSQLAM() + ", ");
1:70f7692:             printWriter_.print("AGENT=" + c.getAGENT() + ", ");
1:70f7692:             printWriter_.print("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
1:70f7692:             printWriter_.print("RDB=" + c.getRDB() + ", ");
1:70f7692:             printWriter_.print("SECMGR=" + c.getSECMGR() + ", ");
1:70f7692:             printWriter_.print("XAMGR=" + c.getXAMGR() + ", ");
1:70f7692:             printWriter_.print("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
1:70f7692:             printWriter_.print("RSYNCMGR=" + c.getRSYNCMGR());
1:70f7692:             printWriter_.println(" }");
1:70f7692:             printWriter_.flush();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public void traceConnectsResetExit(ClientConnection connection) {
1:70f7692:         NetConnection c = (NetConnection) connection;
1:70f7692:         synchronized (printWriter_) {
1:70f7692:             super.traceConnectsResetExit(c);
1:70f7692:             dncnetprint("  PROTOCOL manager levels: { ");
1:70f7692:             printWriter_.print("SQLAM=" + c.getSQLAM() + ", ");
1:70f7692:             printWriter_.print("AGENT=" + c.getAGENT() + ", ");
1:70f7692:             printWriter_.print("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
1:70f7692:             printWriter_.print("RDB=" + c.getRDB() + ", ");
1:70f7692:             printWriter_.print("SECMGR=" + c.getSECMGR() + ", ");
1:70f7692:             printWriter_.print("XAMGR=" + c.getXAMGR() + ", ");
1:70f7692:             printWriter_.print("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
1:70f7692:             printWriter_.print("RSYNCMGR=" + c.getRSYNCMGR());
1:70f7692:             printWriter_.println(" }");
1:70f7692:             printWriter_.flush();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // Pass the connection handle and print it in the header
1:70f7692:     // What exactly is supposed to be passed,  assume one complete DSS packet
1:70f7692:     // Write the communication buffer data to the trace.
1:70f7692:     // The data is passed in via a byte array.  The start and length of the data is given.
1:70f7692:     // The type is needed to indicate if the data is part of the send or receive buffer.
1:70f7692:     // The class name, method name, and trcPt number are also written to the trace.
1:70f7692:     // Not much checking is performed on the parameters.  This is done to help performance.
1:0326967:     synchronized void traceProtocolFlow(byte[] buff,
1:70f7692:                                                int offset,
1:70f7692:                                                int len,
1:70f7692:                                                int type,
1:70f7692:                                                String className,
1:70f7692:                                                String methodName,
1:70f7692:                                                int tracepoint) {
1:b13b17c:         if (!loggingEnabled(ClientDataSource.TRACE_PROTOCOL_FLOWS)) {
4:70f7692:             return;
1:70f7692:         }
1:70f7692:         synchronized (printWriter_) {
1:49be70b:             tracepoint("[net]", tracepoint, className, methodName);
1:33776ff: 
1:70f7692:             int fullLen = len;
1:70f7692:             boolean printColPos = true;
1:70f7692:             while (fullLen >= 2) { // format each DssHdr seperately
1:70f7692:                 // get the length of this DssHdr
1:49be70b:                 len = ((buff[offset] & 0xff) << 8) + (buff[offset + 1] & 0xff);
1:33776ff: 
1:70f7692:                 // check for valid dss header or not all of dss block
1:70f7692:                 if ((len < 10) || (len > fullLen)) {
1:70f7692:                     len = fullLen;
1:70f7692:                 }
1:33776ff: 
1:70f7692:                 // subtract that length from the full length
1:70f7692:                 fullLen -= len;
1:70f7692:                 // The data will only be written if there is a non-zero positive length.
1:70f7692:                 if (len != 0) {
1:70f7692:                     String codePointName = null;
1:70f7692:                     // If the length <= 10, lookup the first codepoint so it's name can be printed
1:70f7692:                     if (len >= 10) {
1:70f7692:                         // Get the int value of the two byte unsigned codepoint.
1:70f7692:                         int codePoint = getCodePoint(buff, offset + 8);
1:70f7692:                         codePointName = codePointNameTable__.lookup(codePoint);
1:33776ff: 
1:70f7692:                         // if this is not a valid codepoint then format the entire buffer
1:70f7692:                         // as one block.
1:70f7692:                         if (codePointName == null) {
1:70f7692:                             len += fullLen;
1:70f7692:                             fullLen = 0;
1:70f7692:                         }
1:70f7692:                     }
1:70f7692: 
1:70f7692:                     if (!printColPos) { // not 1st Dss header of this buffer, write seperator
1:70f7692:                         dncnetprintln("");
1:70f7692:                     }
1:70f7692: 
1:70f7692:                     if (codePointName == null) {
1:70f7692:                         // codePointName was still null so either < 10 bytes were given or
1:70f7692:                         // the codepoint wasn't found in the table.  Just print the plain send header.
1:70f7692:                         dncnetprintln(getHeader(type));
1:70f7692:                     } else {
1:70f7692:                         // codePointName isn't null so the name of the codepoint will be printed.
1:70f7692:                         printHeaderWithCodePointName(codePointName, type);
1:70f7692:                     }
1:70f7692: 
1:70f7692:                     // Print the col position header in the trace.
1:70f7692:                     if (printColPos) { // first Dss header of buffer, need column position header
1:70f7692:                         dncnetprintln(colPosHeader__);
1:70f7692:                         printColPos = false;
1:70f7692:                     }
1:70f7692: 
1:70f7692:                     // A char array will be used to translate the bytes to their character
1:70f7692:                     // representations along with ascii and ebcdic representations.
1:70f7692:                     char trcDump[] = new char[77];
1:70f7692: 
1:70f7692:                     // bCounter, aCounter, eCounter are offsets used to help position the characters
1:70f7692:                     short bCounter = 7;
1:70f7692:                     short aCounter = 43;
1:70f7692:                     short eCounter = 61;
1:70f7692: 
1:70f7692:                     // The lines will be counted starting at zero.
1:70f7692:                     // This is hard coded since we are at the beginning.
1:70f7692:                     trcDump[0] = zeroChar__;
1:70f7692:                     trcDump[1] = zeroChar__;
1:70f7692:                     trcDump[2] = zeroChar__;
1:70f7692:                     trcDump[3] = zeroChar__;
1:70f7692: 
1:70f7692:                     // The 0's are already in the trace so bump the line counter up a row.
1:70f7692:                     int lineCounter = 0x10;
1:70f7692: 
1:70f7692:                     // Make sure the character array has all blanks in it.
1:70f7692:                     // Some of these blanks will be replaced later with values.
1:70f7692:                     // The 0's were not wrote over.
1:70f7692:                     for (int j = 4; j < 77; j++) {
1:70f7692:                         trcDump[j] = spaceChar__;
1:70f7692:                     }
1:70f7692: 
1:70f7692:                     // i will maintain the position in the byte array to be traced.
1:70f7692:                     int i = 0;
1:70f7692: 
1:70f7692:                     do {
1:70f7692:                         // Get the unsigned value of the byte.
1:70f7692:                         //                  int num = b[off++] & 0xff;
1:70f7692:                         int num = (buff[offset] < 0) ? buff[offset] + 256 : buff[offset];
1:70f7692:                         offset++;
1:70f7692:                         i++;
1:70f7692:                         // Place the characters representing the bytes in the array.
1:70f7692:                         trcDump[bCounter++] = hexDigit__[((num >>> 4) & 0xf)];
1:70f7692:                         trcDump[bCounter++] = hexDigit__[(num & 0xf)];
1:70f7692: 
1:70f7692:                         // Place the ascii and ebcdc representations in the array.
1:70f7692:                         trcDump[aCounter++] = asciiChar__[num];
1:70f7692:                         trcDump[eCounter++] = ebcdicChar__[num];
1:70f7692: 
1:70f7692:                         if (((i % 8) == 0)) {
1:70f7692:                             if (((i % 16) == 0)) {
1:70f7692:                                 // Print the array each time 16 bytes are processed.
1:70f7692:                                 dncnetprintln(trcDump);
1:70f7692:                                 if (i != len) {
1:70f7692:                                     // Not yet at the end of the byte array.
1:70f7692:                                     if ((len - i) < 16) {
1:70f7692:                                         // This is the last line so blank it all out.
1:70f7692:                                         // This keeps the last line looking pretty in case
1:70f7692:                                         // < 16 bytes remain.
1:70f7692:                                         for (int j = 0; j < trcDump.length; j++) {
1:70f7692:                                             trcDump[j] = spaceChar__;
1:70f7692:                                         }
1:70f7692:                                     }
1:70f7692:                                     // Reset the counters.
1:70f7692:                                     bCounter = 0;
1:70f7692:                                     aCounter = 43;
1:70f7692:                                     eCounter = 61;
1:70f7692:                                     // Reset the lineCounter if it starts to get too large.
1:70f7692:                                     if (lineCounter == 0x100000) {
1:70f7692:                                         lineCounter = 0;
1:70f7692:                                     }
1:70f7692:                                     // Place the characters representing the line counter in the array.
1:70f7692:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 12) & 0xf)];
1:70f7692:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 8) & 0xf)];
1:70f7692:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 4) & 0xf)];
1:70f7692:                                     trcDump[bCounter++] = hexDigit__[(lineCounter & 0xf)];
1:70f7692:                                     bCounter += 3;
1:70f7692:                                     // Bump up the line counter.
1:70f7692:                                     lineCounter += 0x10;
1:70f7692:                                 }
1:70f7692:                             } else {
1:70f7692:                                 // 8 bytes were processed so move the counter to adjust for
1:70f7692:                                 // spaces between the columns of bytes.
1:70f7692:                                 bCounter += 2;
1:70f7692:                             }
1:70f7692:                         }
1:70f7692:                         // do this until we all the data has been traced.
1:70f7692:                     } while (i < len);
1:70f7692: 
1:70f7692:                     // print the last line and add some blank lines to make it easier to read.
1:70f7692:                     if (len % 16 != 0) {
1:70f7692:                         dncnetprintln(trcDump);
1:70f7692:                     }
1:70f7692:                 }
1:70f7692:             }
1:70f7692:             dncnetprintln("");
1:70f7692:         }
32:33776ff:     }
1:33776ff: 
1:70f7692:     // Gets the int value of the two byte unsigned codepoint.
1:70f7692:     private static int getCodePoint(byte[] buff, int offset) {
1:70f7692:         return ((buff[offset++] & 0xff) << 8) +
1:49be70b:                 (buff[offset] & 0xff);
1:33776ff:     }
1:33776ff: 
1:70f7692:     private static String getHeader(int type) {
1:70f7692:         switch (type) {
1:70f7692:         case TYPE_TRACE_SEND:
1:70f7692:             return sendHeader__;
1:70f7692:         case TYPE_TRACE_RECEIVE:
1:70f7692:             return receiveHeader__;
1:70f7692:         default:
1:70f7692:             return null;
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private static int getStartPosition(int type) {
1:70f7692:         switch (type) {
1:70f7692:         case TYPE_TRACE_SEND:
1:70f7692:             return 20; // This is right after 'SEND BUFFER: '.
1:70f7692:         case TYPE_TRACE_RECEIVE:
1:70f7692:             return 23; // This is right after 'RECEIVE BUFFER: '.
1:70f7692:         default:
1:70f7692:             return 0;
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void printHeaderWithCodePointName(String codePointName, int type) {
1:70f7692:         // Create a char array so some of the characters
1:70f7692:         // can be replaced with the name of the codepoint.
1:70f7692:         char headerArray[] = getHeader(type).toCharArray();
1:33776ff: 
1:70f7692:         // At most, 16 character name will be used.  This is so
1:70f7692:         // the headers on top of the ascii and ebcdic rows aren't shifted.
1:70f7692:         int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
1:33776ff: 
1:70f7692:         int offset = getStartPosition(type);
1:70f7692:         for (int i = 0; i < replaceLen; i++) {
1:70f7692:             headerArray[offset++] = codePointName.charAt(i);
1:70f7692:         }
1:70f7692:         dncnetprintln(headerArray);
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void dncnetprint(String s) {
1:70f7692:         synchronized (printWriter_) {
1:70f7692:             printWriter_.print("[derby] " + s);
1:70f7692:             printWriter_.flush();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void dncnetprintln(String s) {
1:70f7692:         synchronized (printWriter_) {
1:70f7692:             printWriter_.println("[derby] " + s);
1:70f7692:             printWriter_.flush();
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void dncnetprintln(char[] s) {
1:70f7692:         synchronized (printWriter_) {
1:70f7692:             printWriter_.print("[derby] ");
1:70f7692:             printWriter_.println(s);
1:70f7692:             printWriter_.flush();
1:70f7692:         }
1:33776ff:     }
1:33776ff: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     static final int TYPE_TRACE_RECEIVE = 2;
1:     static final int TYPE_TRACE_SEND = 1;
/////////////////////////////////////////////////////////////////////////
1:     synchronized void traceProtocolFlow(byte[] buff,
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import org.apache.derby.client.am.ClientConnection;
/////////////////////////////////////////////////////////////////////////
1:     public NetLogWriter(PrintWriter printWriter, int traceLevel) {
/////////////////////////////////////////////////////////////////////////
1:     public void traceConnectsExit(ClientConnection connection) {
/////////////////////////////////////////////////////////////////////////
1:     public void traceConnectsResetExit(ClientConnection connection) {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: 
0: import org.apache.derby.client.am.Connection;
1: import org.apache.derby.client.am.LogWriter;
1: import org.apache.derby.jdbc.ClientDataSource;
1: 
1: public class NetLogWriter extends LogWriter {
/////////////////////////////////////////////////////////////////////////
0:     public void traceConnectsExit(Connection connection) {
/////////////////////////////////////////////////////////////////////////
0:     public void traceConnectsResetExit(Connection connection) {
/////////////////////////////////////////////////////////////////////////
1:         if (!loggingEnabled(ClientDataSource.TRACE_PROTOCOL_FLOWS)) {
commit:49be70b
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (codePointNameTable__ == null) {
1:             initCodePointTable();
1:         }
1:     }
1: 
1:     // synchonized so only one thread can initialize the table
1:     private synchronized void initCodePointTable() {
/////////////////////////////////////////////////////////////////////////
1:             tracepoint("[net]", tracepoint, className, methodName);
1:                 len = ((buff[offset] & 0xff) << 8) + (buff[offset + 1] & 0xff);
/////////////////////////////////////////////////////////////////////////
1:                 (buff[offset] & 0xff);
commit:9fd9272
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class NetLogWriter extends org.apache.derby.client.am.LogWriter {
1:     // The recevie constant is used to indicate that the bytes were read to a Stream.
1:     // It indicates to this class that a receive header should be used.
0:     public static final int TYPE_TRACE_RECEIVE = 2;
1:     // The send constant is used to indicate that the bytes were written to
1:     // a Stream.  It indicates to this class that a send header should be used.
0:     public static final int TYPE_TRACE_SEND = 1;
1:     //------------------------------ internal constants --------------------------
1:     // This class was implemented using character arrays to translate bytes
1:     // into ascii and ebcdic.  The goal was to be able to quickly index into the
1:     // arrays to find the characters.  Char arrays instead of strings were used as
1:     // much as possible in an attempt to help speed up performance.
1:     // An array of characters used to translate bytes to ascii.
1:     // The position in the array corresponds to the hex value of the character.
1:     private static final char asciiChar__ [] = {
1:         // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //0
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //1
1:         ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', //2
1:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', //3
1:         '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', //4
1:         'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', //5
1:         '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', //6
1:         'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '.', //7
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //8
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //9
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //A
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //B
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //C
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //D
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //E
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'   //F
1:     };
1:     // This column position header is used to mark offsets into the trace.
1:     private static final String colPosHeader__ =
1:             "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
1:     // An array of characters used to translate bytes to ebcdic.
1:     // The position in the array corresponds to the hex value of the
1:     // character.
1:     private static final char ebcdicChar__[] = {
1:         // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //0
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //1
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //2
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //3
1:         ' ', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '<', '(', '+', '|', //4
1:         '&', '.', '.', '.', '.', '.', '.', '.', '.', '.', '!', '$', '*', ')', ';', '.', //5
1:         '-', '/', '.', '.', '.', '.', '.', '.', '.', '.', '|', ',', '%', '_', '>', '?', //6
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '`', ':', '#', '@', '\'', '=', '"', //7
1:         '.', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', '.', '.', '.', '.', '.', '.', //8
1:         '.', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', '.', '.', '.', '.', '.', '.', //9
1:         '.', '~', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', '.', '.', '.', '.', '.', //A
1:         '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', //B
1:         '{', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', '.', '.', '.', '.', '.', '.', //C
1:         '}', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', '.', '.', '.', '.', '.', '.', //D
1:         '\\', '.', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '.', '.', '.', '.', '.', '.', //E
1:         '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '.', '.', '.', '.', '.'   //F
1:     };
1:     // An array of characters representing hex numbers.
1:     private static final char hexDigit__ [] = {
1:         '0', '1', '2', '3', '4', '5', '6', '7',
1:         '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
1:     };
1:     // The receive header comes befor bytes which would be read from a stream.
1:     private static final String receiveHeader__ =
1:             "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
1:     // The send header comes before bytes which would be written to a stream.
1:     private static final String sendHeader__ =
1:             "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
1:     private static final char spaceChar__ = ' ';
1:     private static final char zeroChar__ = '0';
1:     // This mapping table associates a codepoint to a String describing the codepoint.
1:     // This is needed because the trace prints the first codepoint in send and receive buffers.
1:     // This is created lazily because there is no need to create the mapping if tracing isn't used.
1:     // So this array will only be created when the com buffer trace is started.
1:     private static CodePointNameTable codePointNameTable__ = null;
1:     //-----------------------------internal state---------------------------------
1:     //-----------------------------constructors/finalizer-------------------------
1:     // One NetLogWriter object is created per data source, iff tracing is enabled.
0:     public NetLogWriter(java.io.PrintWriter printWriter, int traceLevel) {
1:         super(printWriter, traceLevel);
1: 
1:         // Initialize the codepoint name table if not previously initialized.
1:         // This is done lazily so that it is not created if the trace isn't used (save some init time).
1:         if (codePointNameTable__ == null) {
1:             codePointNameTable__ = new CodePointNameTable();
1:         }
1:     //------------------------------entry points----------------------------------
1:     // Specialization of LogWriter.traceConnectsExit()
0:     public void traceConnectsExit(org.apache.derby.client.am.Connection connection) {
0:         if (traceSuspended()) {
1:             return;
1:         }
1:         NetConnection c = (NetConnection) connection;
1:         synchronized (printWriter_) {
1:             super.traceConnectsExit(c);
1:             dncnetprint("  PROTOCOL manager levels: { ");
1:             printWriter_.print("SQLAM=" + c.getSQLAM() + ", ");
1:             printWriter_.print("AGENT=" + c.getAGENT() + ", ");
1:             printWriter_.print("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
1:             printWriter_.print("RDB=" + c.getRDB() + ", ");
1:             printWriter_.print("SECMGR=" + c.getSECMGR() + ", ");
1:             printWriter_.print("XAMGR=" + c.getXAMGR() + ", ");
1:             printWriter_.print("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
1:             printWriter_.print("RSYNCMGR=" + c.getRSYNCMGR());
1:             printWriter_.println(" }");
1:             printWriter_.flush();
1:         }
0:     public void traceConnectsResetExit(org.apache.derby.client.am.Connection connection) {
0:         if (traceSuspended()) {
1:             return;
1:         }
1:         NetConnection c = (NetConnection) connection;
1:         synchronized (printWriter_) {
1:             super.traceConnectsResetExit(c);
1:             dncnetprint("  PROTOCOL manager levels: { ");
1:             printWriter_.print("SQLAM=" + c.getSQLAM() + ", ");
1:             printWriter_.print("AGENT=" + c.getAGENT() + ", ");
1:             printWriter_.print("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
1:             printWriter_.print("RDB=" + c.getRDB() + ", ");
1:             printWriter_.print("SECMGR=" + c.getSECMGR() + ", ");
1:             printWriter_.print("XAMGR=" + c.getXAMGR() + ", ");
1:             printWriter_.print("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
1:             printWriter_.print("RSYNCMGR=" + c.getRSYNCMGR());
1:             printWriter_.println(" }");
1:             printWriter_.flush();
1:         }
1:     // Pass the connection handle and print it in the header
1:     // What exactly is supposed to be passed,  assume one complete DSS packet
1:     // Write the communication buffer data to the trace.
1:     // The data is passed in via a byte array.  The start and length of the data is given.
1:     // The type is needed to indicate if the data is part of the send or receive buffer.
1:     // The class name, method name, and trcPt number are also written to the trace.
1:     // Not much checking is performed on the parameters.  This is done to help performance.
0:     synchronized public void traceProtocolFlow(byte[] buff,
1:                                                int offset,
1:                                                int len,
1:                                                int type,
1:                                                String className,
1:                                                String methodName,
1:                                                int tracepoint) {
0:         if (traceSuspended()) {
1:             return;
1:         }
0:         if (!loggingEnabled(org.apache.derby.jdbc.ClientDataSource.TRACE_PROTOCOL_FLOWS)) {
1:             return;
1:         }
1:         synchronized (printWriter_) {
0:             super.tracepoint("[net]", tracepoint, className, methodName);
1:             int fullLen = len;
1:             boolean printColPos = true;
1:             while (fullLen >= 2) { // format each DssHdr seperately
1:                 // get the length of this DssHdr
0:                 len = ((buff[offset] & 0xff) << 8) + ((buff[offset + 1] & 0xff) << 0);
1:                 // check for valid dss header or not all of dss block
1:                 if ((len < 10) || (len > fullLen)) {
1:                     len = fullLen;
1:                 }
1:                 // subtract that length from the full length
1:                 fullLen -= len;
1:                 // The data will only be written if there is a non-zero positive length.
1:                 if (len != 0) {
1:                     String codePointName = null;
1:                     // If the length <= 10, lookup the first codepoint so it's name can be printed
1:                     if (len >= 10) {
1:                         // Get the int value of the two byte unsigned codepoint.
1:                         int codePoint = getCodePoint(buff, offset + 8);
1:                         codePointName = codePointNameTable__.lookup(codePoint);
1:                         // if this is not a valid codepoint then format the entire buffer
1:                         // as one block.
1:                         if (codePointName == null) {
1:                             len += fullLen;
1:                             fullLen = 0;
1:                         }
1:                     }
1: 
1:                     if (!printColPos) { // not 1st Dss header of this buffer, write seperator
1:                         dncnetprintln("");
1:                     }
1: 
1:                     if (codePointName == null) {
1:                         // codePointName was still null so either < 10 bytes were given or
1:                         // the codepoint wasn't found in the table.  Just print the plain send header.
1:                         dncnetprintln(getHeader(type));
1:                     } else {
1:                         // codePointName isn't null so the name of the codepoint will be printed.
1:                         printHeaderWithCodePointName(codePointName, type);
1:                     }
1: 
1:                     // Print the col position header in the trace.
1:                     if (printColPos) { // first Dss header of buffer, need column position header
1:                         dncnetprintln(colPosHeader__);
1:                         printColPos = false;
1:                     }
1: 
1:                     // A char array will be used to translate the bytes to their character
1:                     // representations along with ascii and ebcdic representations.
1:                     char trcDump[] = new char[77];
1: 
1:                     // bCounter, aCounter, eCounter are offsets used to help position the characters
1:                     short bCounter = 7;
1:                     short aCounter = 43;
1:                     short eCounter = 61;
1: 
1:                     // The lines will be counted starting at zero.
1:                     // This is hard coded since we are at the beginning.
1:                     trcDump[0] = zeroChar__;
1:                     trcDump[1] = zeroChar__;
1:                     trcDump[2] = zeroChar__;
1:                     trcDump[3] = zeroChar__;
1: 
1:                     // The 0's are already in the trace so bump the line counter up a row.
1:                     int lineCounter = 0x10;
1: 
1:                     // Make sure the character array has all blanks in it.
1:                     // Some of these blanks will be replaced later with values.
1:                     // The 0's were not wrote over.
1:                     for (int j = 4; j < 77; j++) {
1:                         trcDump[j] = spaceChar__;
1:                     }
1: 
1:                     // i will maintain the position in the byte array to be traced.
1:                     int i = 0;
1: 
1:                     do {
1:                         // Get the unsigned value of the byte.
1:                         //                  int num = b[off++] & 0xff;
1:                         int num = (buff[offset] < 0) ? buff[offset] + 256 : buff[offset];
1:                         offset++;
1:                         i++;
1:                         // Place the characters representing the bytes in the array.
1:                         trcDump[bCounter++] = hexDigit__[((num >>> 4) & 0xf)];
1:                         trcDump[bCounter++] = hexDigit__[(num & 0xf)];
1: 
1:                         // Place the ascii and ebcdc representations in the array.
1:                         trcDump[aCounter++] = asciiChar__[num];
1:                         trcDump[eCounter++] = ebcdicChar__[num];
1: 
1:                         if (((i % 8) == 0)) {
1:                             if (((i % 16) == 0)) {
1:                                 // Print the array each time 16 bytes are processed.
1:                                 dncnetprintln(trcDump);
1:                                 if (i != len) {
1:                                     // Not yet at the end of the byte array.
1:                                     if ((len - i) < 16) {
1:                                         // This is the last line so blank it all out.
1:                                         // This keeps the last line looking pretty in case
1:                                         // < 16 bytes remain.
1:                                         for (int j = 0; j < trcDump.length; j++) {
1:                                             trcDump[j] = spaceChar__;
1:                                         }
1:                                     }
1:                                     // Reset the counters.
1:                                     bCounter = 0;
1:                                     aCounter = 43;
1:                                     eCounter = 61;
1:                                     // Reset the lineCounter if it starts to get too large.
1:                                     if (lineCounter == 0x100000) {
1:                                         lineCounter = 0;
1:                                     }
1:                                     // Place the characters representing the line counter in the array.
1:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 12) & 0xf)];
1:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 8) & 0xf)];
1:                                     trcDump[bCounter++] = hexDigit__[((lineCounter >>> 4) & 0xf)];
1:                                     trcDump[bCounter++] = hexDigit__[(lineCounter & 0xf)];
1:                                     bCounter += 3;
1:                                     // Bump up the line counter.
1:                                     lineCounter += 0x10;
1:                                 }
1:                             } else {
1:                                 // 8 bytes were processed so move the counter to adjust for
1:                                 // spaces between the columns of bytes.
1:                                 bCounter += 2;
1:                             }
1:                         }
1:                         // do this until we all the data has been traced.
1:                     } while (i < len);
1: 
1:                     // print the last line and add some blank lines to make it easier to read.
1:                     if (len % 16 != 0) {
1:                         dncnetprintln(trcDump);
1:                     }
1:                 }
1:             }
1:             dncnetprintln("");
1:         }
1:     // Gets the int value of the two byte unsigned codepoint.
1:     private static int getCodePoint(byte[] buff, int offset) {
1:         return ((buff[offset++] & 0xff) << 8) +
0:                 ((buff[offset] & 0xff) << 0);
1:     private static String getHeader(int type) {
1:         switch (type) {
1:         case TYPE_TRACE_SEND:
1:             return sendHeader__;
1:         case TYPE_TRACE_RECEIVE:
1:             return receiveHeader__;
1:         default:
1:             return null;
1:         }
1:     private static int getStartPosition(int type) {
1:         switch (type) {
1:         case TYPE_TRACE_SEND:
1:             return 20; // This is right after 'SEND BUFFER: '.
1:         case TYPE_TRACE_RECEIVE:
1:             return 23; // This is right after 'RECEIVE BUFFER: '.
1:         default:
1:             return 0;
1:         }
1:     private void printHeaderWithCodePointName(String codePointName, int type) {
1:         // Create a char array so some of the characters
1:         // can be replaced with the name of the codepoint.
1:         char headerArray[] = getHeader(type).toCharArray();
1:         // At most, 16 character name will be used.  This is so
1:         // the headers on top of the ascii and ebcdic rows aren't shifted.
1:         int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
1:         int offset = getStartPosition(type);
1:         for (int i = 0; i < replaceLen; i++) {
1:             headerArray[offset++] = codePointName.charAt(i);
1:         }
1:         dncnetprintln(headerArray);
1:     private void dncnetprint(String s) {
1:         synchronized (printWriter_) {
1:             printWriter_.print("[derby] " + s);
1:             printWriter_.flush();
1:         }
1:     private void dncnetprintln(String s) {
1:         synchronized (printWriter_) {
1:             printWriter_.println("[derby] " + s);
1:             printWriter_.flush();
1:         }
1:     private void dncnetprintln(char[] s) {
1:         synchronized (printWriter_) {
1:             printWriter_.print("[derby] ");
1:             printWriter_.println(s);
1:             printWriter_.flush();
1:         }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetLogWriter
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
1: // network traffic tracer.
1: // This class traces communication buffers for both sends and receives.
1: // The value of the hex bytes are traced along with the ascii and ebcdic translations.
0: public class NetLogWriter extends org.apache.derby.client.am.LogWriter
0: {
1: 
0:   // The recevie constant is used to indicate that the bytes were read to a Stream.
0:   // It indicates to this class that a receive header should be used.
0:   public static final int TYPE_TRACE_RECEIVE = 2;
1: 
0:   // The send constant is used to indicate that the bytes were written to
0:   // a Stream.  It indicates to this class that a send header should be used.
0:   public static final int TYPE_TRACE_SEND = 1;
1: 
0:   //------------------------------ internal constants --------------------------
1: 
0:   // This class was implemented using character arrays to translate bytes
0:   // into ascii and ebcdic.  The goal was to be able to quickly index into the
0:   // arrays to find the characters.  Char arrays instead of strings were used as
0:   // much as possible in an attempt to help speed up performance.
1: 
0:   // An array of characters used to translate bytes to ascii.
0:   // The position in the array corresponds to the hex value of the character.
0:   private static final char asciiChar__ [] = {
0:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
0:     ' ','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/', //2
0:     '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',  //3
0:     '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',  //4
0:     'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_', //5
0:     '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',  //6
0:     'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~','.',  //7
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //8
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //9
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //A
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //C
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //D
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //E
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.'   //F
0:   };
1: 
0:   // This column position header is used to mark offsets into the trace.
0:   private static final String colPosHeader__ =
0:     "       0 1 2 3 4 5 6 7   8 9 A B C D E F   0123456789ABCDEF  0123456789ABCDEF";
1: 
0:   // An array of characters used to translate bytes to ebcdic.
0:   // The position in the array corresponds to the hex value of the
0:   // character.
0:   private static final char ebcdicChar__[] = {
0:     // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //0
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //1
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //2
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //3
0:     ' ','.','.','.','.','.','.','.','.','.','.','.','<','(','+','|',  //4
0:     '&','.','.','.','.','.','.','.','.','.','!','$','*',')',';','.',  //5
0:     '-','/','.','.','.','.','.','.','.','.','|',',','%','_','>','?',  //6
0:     '.','.','.','.','.','.','.','.','.','`',':','#','@','\'','=','"', //7
0:     '.','a','b','c','d','e','f','g','h','i','.','.','.','.','.','.',  //8
0:     '.','j','k','l','m','n','o','p','q','r','.','.','.','.','.','.',  //9
0:     '.','~','s','t','u','v','w','x','y','z','.','.','.','.','.','.',  //A
0:     '.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.',  //B
0:     '{','A','B','C','D','E','F','G','H','I','.','.','.','.','.','.',  //C
0:     '}','J','K','L','M','N','O','P','Q','R','.','.','.','.','.','.',  //D
0:     '\\','.','S','T','U','V','W','X','Y','Z','.','.','.','.','.','.', //E
0:     '0','1','2','3','4','5','6','7','8','9','.','.','.','.','.','.'   //F
0:   };
1: 
0:   // An array of characters representing hex numbers.
0:   private static final char hexDigit__ [] = {
0:     '0','1','2','3','4','5','6','7',
0:     '8','9','A','B','C','D','E','F'
0:   };
1: 
0:   // The receive header comes befor bytes which would be read from a stream.
0:   private static final String receiveHeader__ =
0:     "       RECEIVE BUFFER:                     (ASCII)           (EBCDIC)";
1: 
0:   // The send header comes before bytes which would be written to a stream.
0:   private static final String sendHeader__ =
0:     "       SEND BUFFER:                        (ASCII)           (EBCDIC)";
1: 
0:   private static final char spaceChar__ = ' ';
1: 
0:   private static final char zeroChar__ = '0';
1: 
0:   // This mapping table associates a codepoint to a String describing the codepoint.
0:   // This is needed because the trace prints the first codepoint in send and receive buffers.
0:   // This is created lazily because there is no need to create the mapping if tracing isn't used.
0:   // So this array will only be created when the com buffer trace is started.
0:   private static CodePointNameTable codePointNameTable__ = null;
1: 
0:   //-----------------------------internal state---------------------------------
1: 
0:   //-----------------------------constructors/finalizer-------------------------
1: 
0:   // One NetLogWriter object is created per data source, iff tracing is enabled.
0:   public NetLogWriter (java.io.PrintWriter printWriter, int traceLevel)
0:   {
0:     super (printWriter, traceLevel);
1: 
0:     // Initialize the codepoint name table if not previously initialized.
0:     // This is done lazily so that it is not created if the trace isn't used (save some init time).
0:     if (codePointNameTable__ == null) {
0:       codePointNameTable__ = new CodePointNameTable();
1:     }
1:   }
1: 
0:   //------------------------------entry points----------------------------------
1: 
0:   // Specialization of LogWriter.traceConnectsExit()
0:   public void traceConnectsExit (org.apache.derby.client.am.Connection connection)
0:   {
0:     if (traceSuspended()) return;
0:     NetConnection c = (NetConnection) connection;
0:     synchronized (printWriter_) {
0:       super.traceConnectsExit (c);
0:       dncnetprint  ("  PROTOCOL manager levels: { ");
0:       printWriter_.print ("SQLAM=" + c.getSQLAM() + ", ");
0:       printWriter_.print ("AGENT=" + c.getAGENT() + ", ");
0:       printWriter_.print ("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
0:       printWriter_.print ("RDB=" + c.getRDB() + ", ");
0:       printWriter_.print ("SECMGR=" + c.getSECMGR() + ", ");
0:       printWriter_.print ("XAMGR=" + c.getXAMGR() + ", ");
0:       printWriter_.print ("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
0:       printWriter_.print ("RSYNCMGR=" + c.getRSYNCMGR());
0:       printWriter_.println  (" }");
0:       printWriter_.flush();
1:     }
1:   }
1: 
0:   public void traceConnectsResetExit (org.apache.derby.client.am.Connection connection)
0:   {
0:     if (traceSuspended()) return;
0:     NetConnection c = (NetConnection) connection;
0:     synchronized (printWriter_) {
0:       super.traceConnectsResetExit (c);
0:       dncnetprint  ("  PROTOCOL manager levels: { ");
0:       printWriter_.print ("SQLAM=" + c.getSQLAM() + ", ");
0:       printWriter_.print ("AGENT=" + c.getAGENT() + ", ");
0:       printWriter_.print ("CMNTCPIP=" + c.getCMNTCPIP() + ", ");
0:       printWriter_.print ("RDB=" + c.getRDB() + ", ");
0:       printWriter_.print ("SECMGR=" + c.getSECMGR() + ", ");
0:       printWriter_.print ("XAMGR=" + c.getXAMGR() + ", ");
0:       printWriter_.print ("SYNCPTMGR=" + c.getSYNCPTMGR() + ", ");
0:       printWriter_.print ("RSYNCMGR=" + c.getRSYNCMGR());
0:       printWriter_.println  (" }");
0:       printWriter_.flush();
1:     }
1:   }
1: 
0:   // Pass the connection handle and print it in the header 
0:   // What exactly is supposed to be passed,  assume one complete DSS packet
0:   // Write the communication buffer data to the trace.
0:   // The data is passed in via a byte array.  The start and length of the data is given.
0:   // The type is needed to indicate if the data is part of the send or receive buffer.
0:   // The class name, method name, and trcPt number are also written to the trace.
0:   // Not much checking is performed on the parameters.  This is done to help performance.
0:   synchronized public void traceProtocolFlow (byte[] buff,
0: 					       int offset,
0: 					       int len,
0: 					       int type,
0: 					       String className,
0: 					       String methodName,
0: 					       int tracepoint)
0:   {
0:     if (traceSuspended()) return;
0:     if (!loggingEnabled (org.apache.derby.jdbc.ClientDataSource.TRACE_PROTOCOL_FLOWS)) return;
0:     synchronized (printWriter_) {
0:       super.tracepoint ("[net]", tracepoint, className, methodName);
1: 
0:       int fullLen = len;
0:       boolean printColPos = true;
0:       while( fullLen >= 2 )
0:       { // format each DssHdr seperately
0:         // get the length of this DssHdr
0:         len = ((buff[offset] & 0xff) << 8) + ((buff[offset+1] & 0xff) << 0);
1: 
0:         // check for valid dss header or not all of dss block
0:         if ((len < 10) || (len > fullLen))
0:           len = fullLen;
1: 
0:         // subtract that length from the full length
0:         fullLen -= len;
0:       // The data will only be written if there is a non-zero positive length.
0:       if (len != 0) {
0: 	String codePointName = null;
0: 	// If the length <= 10, lookup the first codepoint so it's name can be printed
0: 	if (len >= 10) {
0: 	  // Get the int value of the two byte unsigned codepoint.
0: 	  int codePoint = getCodePoint (buff, offset+8);
0: 	  codePointName = codePointNameTable__.lookup (codePoint);
1: 
0:     // if this is not a valid codepoint then format the entire buffer
0:     // as one block.
0:     if (codePointName == null)
0:     {
0:       len += fullLen;
0:       fullLen = 0;
1:     }
1: 	}
1: 
0:           if( !printColPos )
0:           { // not 1st Dss header of this buffer, write seperator
0:             dncnetprintln( "" );
1:           }
1: 
0: 	if (codePointName == null) {
0: 	  // codePointName was still null so either < 10 bytes were given or
0: 	  // the codepoint wasn't found in the table.  Just print the plain send header.
0: 	  dncnetprintln (getHeader (type));
1: 	}
0: 	else {
0: 	  // codePointName isn't null so the name of the codepoint will be printed.
0: 	  printHeaderWithCodePointName (codePointName, type);
1: 	}
1: 
0: 	// Print the col position header in the trace.
0:           if( printColPos )
0:           { // first Dss header of buffer, need column position header
0: 	dncnetprintln (colPosHeader__);
0:             printColPos = false;
1:           }
1: 
0: 	// A char array will be used to translate the bytes to their character
0: 	// representations along with ascii and ebcdic representations.
0: 	char trcDump[] = new char[77];
1: 
0: 	// bCounter, aCounter, eCounter are offsets used to help position the characters
0: 	short bCounter = 7;
0: 	short aCounter = 43;
0: 	short eCounter = 61;
1: 
0: 	// The lines will be counted starting at zero.
0:         // This is hard coded since we are at the beginning.
0: 	trcDump[0] = zeroChar__;
0: 	trcDump[1] = zeroChar__;
0: 	trcDump[2] = zeroChar__;
0: 	trcDump[3] = zeroChar__;
1: 
0: 	// The 0's are already in the trace so bump the line counter up a row.
0: 	int lineCounter = 0x10;
1: 
0: 	// Make sure the character array has all blanks in it.
0: 	// Some of these blanks will be replaced later with values.
0: 	// The 0's were not wrote over.
0: 	for (int j = 4; j < 77; j++) {
0: 	  trcDump[j] = spaceChar__;
1: 	}
1: 
0: 	// i will maintain the position in the byte array to be traced.
0: 	int i = 0;
1: 
0: 	do {
0: 	  // Get the unsigned value of the byte.
0: 	  //                  int num = b[off++] & 0xff;
0: 	  int num = (buff[offset] < 0)? buff[offset] + 256 : buff[offset];
0: 	  offset++;
0: 	  i++;
0: 	  // Place the characters representing the bytes in the array.
0: 	  trcDump[bCounter++] = hexDigit__[((num >>> 4) & 0xf)];
0: 	  trcDump[bCounter++] = hexDigit__[(num & 0xf)];
1: 
0: 	  // Place the ascii and ebcdc representations in the array.
0: 	  trcDump[aCounter++] = asciiChar__[num];
0: 	  trcDump[eCounter++] = ebcdicChar__[num];
1: 
0: 	  if (((i%8) == 0)) {
0: 	    if (((i%16) == 0)) {
0: 	      // Print the array each time 16 bytes are processed.
0:               dncnetprintln (trcDump);
0: 	      if (i != len) {
0: 		// Not yet at the end of the byte array.
0: 		if ((len - i) < 16) {
0: 		  // This is the last line so blank it all out.
0: 		  // This keeps the last line looking pretty in case
0: 		  // < 16 bytes remain.
0: 		  for (int j = 0; j < trcDump.length; j++) {
0: 		    trcDump[j] = spaceChar__;
1: 		  }
1: 		}
0: 		// Reset the counters.
0: 		bCounter = 0;
0: 		aCounter = 43;
0: 		eCounter = 61;
0: 		// Reset the lineCounter if it starts to get too large.
0: 		if (lineCounter == 0x100000) {
0: 		  lineCounter = 0;
1: 		}
0: 		// Place the characters representing the line counter in the array.
0: 		trcDump[bCounter++] = hexDigit__[((lineCounter >>> 12) & 0xf)];
0: 		trcDump[bCounter++] = hexDigit__[((lineCounter >>> 8) & 0xf)];
0: 		trcDump[bCounter++] = hexDigit__[((lineCounter >>> 4) & 0xf)];
0: 		trcDump[bCounter++] = hexDigit__[(lineCounter & 0xf)];
0: 		bCounter += 3;
0: 		// Bump up the line counter.
0: 		lineCounter += 0x10;
1: 	      }
1: 	    }
0: 	    else {
0: 	      // 8 bytes were processed so move the counter to adjust for
0: 	      // spaces between the columns of bytes.
0: 	      bCounter += 2;
1: 	    }
1: 	  }
0: 	  // do this until we all the data has been traced.
1: 	}
0:         while (i < len);
1: 
0: 	// print the last line and add some blank lines to make it easier to read.
0: 	if (len % 16 != 0) {
0:           dncnetprintln (trcDump);
1: 	}
1:       }
1:       }
0:       dncnetprintln ("");
1:     }
1:   }
1: 
0:   // Gets the int value of the two byte unsigned codepoint.
0:   private static int getCodePoint (byte[] buff, int offset)
0:   {
0:     return ((buff[offset++] & 0xff) << 8) +
0:       ((buff[offset] & 0xff) << 0);
1:   }
1: 
0:   private static String getHeader (int type)
0:   {
0:     switch (type) {
0:     case TYPE_TRACE_SEND:
0:       return sendHeader__;
0:     case TYPE_TRACE_RECEIVE:
0:       return receiveHeader__;
0:     default:
0:       return null;
1:     }
1:   }
1: 
0:   private static int getStartPosition (int type)
0:   {
0:     switch (type) {
0:     case TYPE_TRACE_SEND:
0:       return 20; // This is right after 'SEND BUFFER: '.
0:     case TYPE_TRACE_RECEIVE:
0:       return 23; // This is right after 'RECEIVE BUFFER: '.
0:     default:
0:       return 0;
1:     }
1:   }
1: 
0:   private void printHeaderWithCodePointName (String codePointName, int type)
0:   {
0:     // Create a char array so some of the characters
0:     // can be replaced with the name of the codepoint.
0:     char headerArray[] = getHeader(type).toCharArray();
1: 
0:     // At most, 16 character name will be used.  This is so
0:     // the headers on top of the ascii and ebcdic rows aren't shifted.
0:     int replaceLen = (codePointName.length() < 17) ? codePointName.length() : 16;
1: 
0:     int offset = getStartPosition (type);
0:     for (int i = 0; i < replaceLen; i++) {
0:       headerArray[offset++] = codePointName.charAt (i); 
1:     }
0:     dncnetprintln (headerArray);
1:   }
1: 
0:   private void dncnetprint (String s)
0:   {
0:     synchronized (printWriter_) {
0:       printWriter_.print ("[derby] " + s);
0:       printWriter_.flush();
1:     }
1:   }
1: 
0:   private void dncnetprintln (String s)
0:   {
0:     synchronized (printWriter_) {
0:       printWriter_.println ("[derby] " + s);
0:       printWriter_.flush();
1:     }
1:   }
1: 
0:   private void dncnetprintln (char[] s)
0:   {
0:     synchronized (printWriter_) {
0:       printWriter_.print ("[derby] ");
0:       printWriter_.println (s);
0:       printWriter_.flush();
1:     }
1:   }
1: }
============================================================================