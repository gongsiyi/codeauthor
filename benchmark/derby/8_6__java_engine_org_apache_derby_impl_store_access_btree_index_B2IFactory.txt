1:eac0369: /*
2:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2IFactory
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree.index;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:888d12e: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:c6ca304: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:888d12e: import org.apache.derby.iapi.store.raw.PageKey;
1:b61f876: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:888d12e: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.btree.BTree;
1:eac0369: import org.apache.derby.impl.store.access.btree.ControlRow;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   The "B2I" (acronym for b-tree secondary index) factory manages b-tree
1:eac0369:   conglomerates implemented	on the raw store which are used as secondary
1:eac0369:   indexes.
1:eac0369:   <p>
1:eac0369:   Most of this code is generic to all conglomerates.  This class might be
1:eac0369:   more easily maintained as an abstract class in Raw/Conglomerate/Generic.
1:eac0369:   The concrete ConglomerateFactories would simply have to supply the 
1:eac0369:   IMPLEMENTATIONID, FORMATUUIDSTRING, and implement createConglomerate
1:eac0369:   and defaultProperties.  Conglomerates which support more than one format
1:eac0369:   would have to override supportsFormat, and conglomerates which support
1:eac0369:   more than one implementation would have to override supportsImplementation.
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class B2IFactory implements ConglomerateFactory, ModuleControl
1:eac0369: {
1:eac0369: 
1:eac0369: 	private static final String IMPLEMENTATIONID = "BTREE";
1:eac0369: 	private static final String FORMATUUIDSTRING = "C6CEEEF0-DAD3-11d0-BB01-0060973F0942";
1:eac0369: 	private UUID formatUUID;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of MethodFactory (via ConglomerateFactory)
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the default properties for this kind of conglomerate.
1:eac0369: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#defaultProperties
1:eac0369: 	**/
1:eac0369: 	public Properties defaultProperties()
1:eac0369: 	{
1:eac0369: 		// XXX (nat) Need to return the default b-tree secondary index properties.
1:eac0369: 		return new Properties();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return whether this access method implements the implementation
1:eac0369: 	type given in the argument string.
1:eac0369: 	The btree only has one implementation type, "BTREE".
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsImplementation
1:eac0369: 	**/
1:eac0369: 	public boolean supportsImplementation(String implementationId)
1:eac0369: 	{
1:eac0369: 		return implementationId.equals(IMPLEMENTATIONID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the primary implementation type for this access method.
1:eac0369: 	The btree only has one implementation type, "BTREE".
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryImplementationType
1:eac0369: 	**/
1:eac0369: 	public String primaryImplementationType()
1:eac0369: 	{
1:eac0369: 		return IMPLEMENTATIONID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return whether this access method supports the format supplied in
1:eac0369: 	the argument.
1:eac0369: 	The btree currently only supports one format.
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsFormat
1:eac0369: 	**/
1:eac0369: 	public boolean supportsFormat(UUID formatid)
1:eac0369: 	{
1:eac0369: 		return formatid.equals(formatUUID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the primary format that this access method supports.
1:eac0369: 	The btree currently only supports one format.
1:eac0369: 
1:eac0369: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryFormat
1:eac0369: 	**/
1:eac0369: 	public UUID primaryFormat()
1:eac0369: 	{
1:eac0369: 		return formatUUID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ConglomerateFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the conglomerate factory id.
1:eac0369:      * <p>
1:eac0369:      * Return a number in the range of 0-15 which identifies this factory.
1:eac0369:      * Code which names conglomerates depends on this range currently, but
1:eac0369:      * could be easily changed to handle larger ranges.   One hex digit seemed
1:eac0369:      * reasonable for the number of conglomerate types being currently 
1:eac0369:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
1:eac0369:      * <p>
1:eac0369: 	 * @see ConglomerateFactory#getConglomerateFactoryId
2:eac0369:      *
1:eac0369: 	 * @return an unique identifier used to the factory into the conglomid.
1:eac0369:      **/
1:eac0369:     public int getConglomerateFactoryId()
1:eac0369:     {
1:eac0369:         return(ConglomerateFactory.BTREE_FACTORY_ID);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Create the conglomerate and return a conglomerate object for it.
1:eac0369: 
1:eac0369: 	@see ConglomerateFactory#createConglomerate
1:eac0369: 
1:eac0369:     @exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public Conglomerate createConglomerate(	
1:eac0369:     TransactionManager      xact_mgr,
1:eac0369:     int                     segment,
1:eac0369:     long                    input_containerid,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369: 	ColumnOrdering[]        columnOrder,
1:b61f876:     int[]                   collationIds,
1:eac0369:     Properties              properties,
1:eac0369: 	int                     temporaryFlag)
1:eac0369:             throws StandardException
1:eac0369: 	{
1:b61f876:         B2I btree = null;
1:b61f876: 
1:c6ca304:         if ((temporaryFlag & TransactionController.IS_TEMPORARY) != 0 &&
1:c6ca304:                 xact_mgr.getAccessManager().isReadOnly())
1:c6ca304:         {
1:c6ca304:             // If this is a temporary conglomerate created for a read-only
1:c6ca304:             // database, we don't really care which disk format we use, since
1:c6ca304:             // it is not used for persisting data in the database. Use the
1:c6ca304:             // current format. A special case is needed because checkVersion()
1:c6ca304:             // throws an exception in read-only databases (DERBY-2354).
1:c6ca304:             btree = new B2I();
1:c6ca304:         }
1:c6ca304:         else if (xact_mgr.checkVersion(
1:b61f876:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
1:28e234d:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_4,
1:28e234d:                 null)) 
1:b61f876:         {
1:28e234d:             // on disk databases with version higher than 10.3 should use
1:b61f876:             // current disk format B2I.  This includes new databases or
1:b61f876:             // hard upgraded databases.
1:b61f876:             btree = new B2I();
1:28e234d:             
1:28e234d:         }
1:28e234d:         else if (xact_mgr.checkVersion(
1:28e234d:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
1:28e234d:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_3,
1:28e234d:                 null))
1:28e234d:         {
1:28e234d:             // Old databases that are running in new versions of the software,
1:28e234d:             // but are running in soft upgrade mode at release level 10.3
1:28e234d:             // use the 10.3 B2I version.  This version will
1:28e234d:             // continue to write metadata that can be read by 10.3.
1:28e234d:             btree = new B2I_10_3();
1:b61f876:         }
1:b61f876:         else
1:b61f876:         {
1:b61f876:             // Old databases that are running in new versions of the software,
1:b61f876:             // but are running in soft upgrade mode at release level 10.2
1:b61f876:             // and before should use the old B2I version.  This version will
1:b61f876:             // continue to write metadata that can be read by 10.2 and previous
1:b61f876:             // versions.
1:b61f876:             btree = new B2I_v10_2();
1:b61f876:         }
1:b61f876: 
1:eac0369: 		btree.create(
1:eac0369:             xact_mgr, segment, input_containerid, template, columnOrder, 
1:b61f876:             collationIds, properties, temporaryFlag);
1:eac0369: 
1:eac0369: 		return(btree);
1:eac0369: 	}
1:eac0369: 
1:888d12e:     /**
1:eac0369:      * Return Conglomerate object for conglomerate with conglomid.
1:eac0369:      * <p>
1:eac0369:      * Return the Conglomerate Object.  This is implementation specific.
1:eac0369:      * Examples of what will be done is using the id to find the file where
1:eac0369:      * the conglomerate is located, and then executing implementation specific
1:eac0369:      * code to instantiate an object from reading a "special" row from a
1:eac0369:      * known location in the file.  In the btree case the btree conglomerate
1:eac0369:      * is stored as a column in the control row on the root page.
1:eac0369:      * <p>
1:eac0369:      * This operation is costly so it is likely an implementation using this
1:eac0369:      * will cache the conglomerate row in memory so that subsequent accesses
1:eac0369:      * need not perform this operation.
1:eac0369:      * <p>
1:eac0369:      * The btree object returned by this routine may be installed in a cache
1:eac0369:      * so the object must not change.
1:eac0369:      *
1:eac0369: 	 * @return An instance of the conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public Conglomerate readConglomerate(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     ContainerKey        container_key)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Conglomerate    btree      = null;
1:eac0369:         ContainerHandle container  = null;
1:eac0369:         ControlRow      root       = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // open readonly, with no locks.  Dirty read is ok as it is the
1:eac0369:             // responsibility of client code to make sure this data is not
1:eac0369:             // changing while being read.  The only changes that currently
1:eac0369:             // happen to this data is creation and deletion - no updates
1:eac0369:             // ever happen to btree conglomerates.
1:eac0369:             container = 
1:eac0369:                 (xact_manager.getRawStoreXact()).openContainer(
1:eac0369:                     container_key,
1:eac0369:                     (LockingPolicy) null,
1:eac0369:                     ContainerHandle.MODE_READONLY);
1:eac0369: 
1:eac0369:             if (container == null)
1:eac0369:             {
1:eac0369:                 // thrown a "known" error if the conglomerate does not exist 
1:eac0369:                 // which is checked for explicitly by callers of the store 
1:eac0369:                 // interface.
1:eac0369: 
1:eac0369:                 throw StandardException.newException(
1:eac0369:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
1:ce40a31:                     container_key.getContainerId());
1:eac0369:             }
1:eac0369: 
1:eac0369:             // The conglomerate is located in the control row on the root page.
1:4a2b0d9:             root = ControlRow.get(container, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(root.getPage().isLatched());
1:eac0369: 
1:eac0369:             // read the Conglomerate from it's entry in the control row.
1:7af858d:             btree = (Conglomerate) root.getConglom(B2I.FORMAT_NUMBER);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(btree instanceof B2I);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369: 
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369: 
1:eac0369:             if (container != null)
1:eac0369:                 container.close();
1:eac0369:         }
1:eac0369: 
1:eac0369:         // if any error, just return null - meaning can't access the container.
1:eac0369: 
1:eac0369:         return(btree);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:888d12e:      * Interface to be called when an undo of an insert is processed.
1:888d12e:      * <p>
1:888d12e:      * Implementer of this class provides interface to be called by the raw
1:888d12e:      * store when an undo of an insert is processed.  Initial implementation
1:888d12e:      * will be by Access layer to queue space reclaiming events if necessary
1:888d12e:      * when a rows is logically "deleted" as part of undo of the original
1:888d12e:      * insert.  This undo can happen a lot for many applications if they
1:888d12e:      * generate expected and handled duplicate key errors.
1:888d12e:      * <p>
1:888d12e:      * Caller may decide to call or not based on deleted row count of the
1:888d12e:      * page, or if overflow rows/columns are present.
1:888d12e:      *
1:888d12e:      *
1:888d12e:      * @param access_factory    current access_factory of the aborted insert.
1:888d12e:      * @param xact              transaction that is being backed out.
1:888d12e:      * @param page_key          page key of the aborted insert.
1:888d12e:      *
1:888d12e:      * @exception  StandardException  Standard exception policy.
1:888d12e:      **/
1:888d12e:     public void insertUndoNotify(
1:888d12e:     AccessFactory       access_factory,
1:888d12e:     Transaction         xact,
1:888d12e:     PageKey             page_key)
1:888d12e:         throws StandardException
1:888d12e:     {
1:888d12e:         // Currently a no-op, btree's can reclaim space at split time. 
1:888d12e:         // TODO - see if it makes sense to add postAbort action if the 
1:888d12e:         // page has all deleted keys.  Shrinks don't work very well currently
1:888d12e:         // as they require table level locks, so may not help much until that
1:888d12e:         // issue is resolved.  see DERBY-5473
1:888d12e: 
1:888d12e:     }
1:888d12e: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ModuleControl.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:eac0369: 
1:eac0369: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
1:eac0369: 		if (impl == null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		return supportsImplementation(impl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Find the UUID factory.
1:eac0369: 		UUIDFactory uuidFactory = 
1:56c1dc2:             getMonitor().getUUIDFactory();
1:eac0369: 
1:eac0369: 		// Make a UUID that identifies this conglomerate's format.
1:eac0369: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	stop()
1:eac0369: 	{
1:eac0369: 	}
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                     container_key.getContainerId());
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1:             getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.AccessFactory;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.PageKey;
1: import org.apache.derby.iapi.store.raw.Transaction;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Interface to be called when an undo of an insert is processed.
1:      * <p>
1:      * Implementer of this class provides interface to be called by the raw
1:      * store when an undo of an insert is processed.  Initial implementation
1:      * will be by Access layer to queue space reclaiming events if necessary
1:      * when a rows is logically "deleted" as part of undo of the original
1:      * insert.  This undo can happen a lot for many applications if they
1:      * generate expected and handled duplicate key errors.
1:      * <p>
1:      * Caller may decide to call or not based on deleted row count of the
1:      * page, or if overflow rows/columns are present.
1:      *
1:      *
1:      * @param access_factory    current access_factory of the aborted insert.
1:      * @param xact              transaction that is being backed out.
1:      * @param page_key          page key of the aborted insert.
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void insertUndoNotify(
1:     AccessFactory       access_factory,
1:     Transaction         xact,
1:     PageKey             page_key)
1:         throws StandardException
1:     {
1:         // Currently a no-op, btree's can reclaim space at split time. 
1:         // TODO - see if it makes sense to add postAbort action if the 
1:         // page has all deleted keys.  Shrinks don't work very well currently
1:         // as they require table level locks, so may not help much until that
1:         // issue is resolved.  see DERBY-5473
1: 
1:     }
1: 
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_4,
1:                 null)) 
1:             // on disk databases with version higher than 10.3 should use
1:             
1:         }
1:         else if (xact_mgr.checkVersion(
1:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
1:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_3,
1:                 null))
1:         {
1:             // Old databases that are running in new versions of the software,
1:             // but are running in soft upgrade mode at release level 10.3
1:             // use the 10.3 B2I version.  This version will
1:             // continue to write metadata that can be read by 10.3.
1:             btree = new B2I_10_3();
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
/////////////////////////////////////////////////////////////////////////
1:     int[]                   collationIds,
1:         B2I btree = null;
1: 
0:         if (xact_mgr.checkVersion(
1:                 RawStoreFactory.DERBY_STORE_MAJOR_VERSION_10,
0:                 RawStoreFactory.DERBY_STORE_MINOR_VERSION_3,
0:                 null))
1:         {
0:             // on disk databases with version higher than 10.2 should use
1:             // current disk format B2I.  This includes new databases or
1:             // hard upgraded databases.
1:             btree = new B2I();
1:         }
1:         else
1:         {
1:             // Old databases that are running in new versions of the software,
1:             // but are running in soft upgrade mode at release level 10.2
1:             // and before should use the old B2I version.  This version will
1:             // continue to write metadata that can be read by 10.2 and previous
1:             // versions.
1:             btree = new B2I_v10_2();
1:         }
1: 
1:             collationIds, properties, temporaryFlag);
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7af858d
/////////////////////////////////////////////////////////////////////////
1:             btree = (Conglomerate) root.getConglom(B2I.FORMAT_NUMBER);
commit:c6ca304
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1:         if ((temporaryFlag & TransactionController.IS_TEMPORARY) != 0 &&
1:                 xact_mgr.getAccessManager().isReadOnly())
1:         {
1:             // If this is a temporary conglomerate created for a read-only
1:             // database, we don't really care which disk format we use, since
1:             // it is not used for persisting data in the database. Use the
1:             // current format. A special case is needed because checkVersion()
1:             // throws an exception in read-only databases (DERBY-2354).
1:             btree = new B2I();
1:         }
1:         else if (xact_mgr.checkVersion(
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(container, BTree.ROOTPAGEID);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2IFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree.index;
1: 
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: 
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.impl.store.access.btree.BTree;
0: import org.apache.derby.impl.store.access.btree.BranchControlRow;
1: import org.apache.derby.impl.store.access.btree.ControlRow;
0: import org.apache.derby.impl.store.access.btree.BTreeController;
0: import org.apache.derby.impl.store.access.btree.LeafControlRow;
0: import org.apache.derby.impl.store.access.btree.OpenBTree;
1: 
1: /**
1: 
1:   The "B2I" (acronym for b-tree secondary index) factory manages b-tree
1:   conglomerates implemented	on the raw store which are used as secondary
1:   indexes.
1:   <p>
1:   Most of this code is generic to all conglomerates.  This class might be
1:   more easily maintained as an abstract class in Raw/Conglomerate/Generic.
1:   The concrete ConglomerateFactories would simply have to supply the 
1:   IMPLEMENTATIONID, FORMATUUIDSTRING, and implement createConglomerate
1:   and defaultProperties.  Conglomerates which support more than one format
1:   would have to override supportsFormat, and conglomerates which support
1:   more than one implementation would have to override supportsImplementation.
1: 
1: **/
1: 
1: public class B2IFactory implements ConglomerateFactory, ModuleControl
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private static final String IMPLEMENTATIONID = "BTREE";
1: 	private static final String FORMATUUIDSTRING = "C6CEEEF0-DAD3-11d0-BB01-0060973F0942";
1: 	private UUID formatUUID;
1: 
1: 
1: 	/*
1: 	** Methods of MethodFactory (via ConglomerateFactory)
1: 	*/
1: 
1: 	/**
1: 	Return the default properties for this kind of conglomerate.
1: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#defaultProperties
1: 	**/
1: 	public Properties defaultProperties()
1: 	{
1: 		// XXX (nat) Need to return the default b-tree secondary index properties.
1: 		return new Properties();
1: 	}
1: 
1: 	/**
1: 	Return whether this access method implements the implementation
1: 	type given in the argument string.
1: 	The btree only has one implementation type, "BTREE".
1: 
1: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsImplementation
1: 	**/
1: 	public boolean supportsImplementation(String implementationId)
1: 	{
1: 		return implementationId.equals(IMPLEMENTATIONID);
1: 	}
1: 
1: 	/**
1: 	Return the primary implementation type for this access method.
1: 	The btree only has one implementation type, "BTREE".
1: 
1: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryImplementationType
1: 	**/
1: 	public String primaryImplementationType()
1: 	{
1: 		return IMPLEMENTATIONID;
1: 	}
1: 
1: 	/**
1: 	Return whether this access method supports the format supplied in
1: 	the argument.
1: 	The btree currently only supports one format.
1: 
1: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsFormat
1: 	**/
1: 	public boolean supportsFormat(UUID formatid)
1: 	{
1: 		return formatid.equals(formatUUID);
1: 	}
1: 
1: 	/**
1: 	Return the primary format that this access method supports.
1: 	The btree currently only supports one format.
1: 
1: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryFormat
1: 	**/
1: 	public UUID primaryFormat()
1: 	{
1: 		return formatUUID;
1: 	}
1: 
1: 	/*
1: 	** Methods of ConglomerateFactory
1: 	*/
1: 
1:     /**
1:      * Return the conglomerate factory id.
1:      * <p>
1:      * Return a number in the range of 0-15 which identifies this factory.
1:      * Code which names conglomerates depends on this range currently, but
1:      * could be easily changed to handle larger ranges.   One hex digit seemed
1:      * reasonable for the number of conglomerate types being currently 
1:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
1:      * <p>
1: 	 * @see ConglomerateFactory#getConglomerateFactoryId
1:      *
1: 	 * @return an unique identifier used to the factory into the conglomid.
1:      **/
1:     public int getConglomerateFactoryId()
1:     {
1:         return(ConglomerateFactory.BTREE_FACTORY_ID);
1:     }
1: 
1: 	/**
1: 	Create the conglomerate and return a conglomerate object for it.
1: 
1: 	@see ConglomerateFactory#createConglomerate
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	public Conglomerate createConglomerate(	
1:     TransactionManager      xact_mgr,
1:     int                     segment,
1:     long                    input_containerid,
1:     DataValueDescriptor[]   template,
1: 	ColumnOrdering[]        columnOrder,
1:     Properties              properties,
1: 	int                     temporaryFlag)
1:             throws StandardException
1: 	{
0: 		B2I btree = new B2I();
1: 		btree.create(
1:             xact_mgr, segment, input_containerid, template, columnOrder, 
0:             properties, temporaryFlag);
1: 
1: 		return(btree);
1: 	}
1: 
1:     /**
1:      * Return Conglomerate object for conglomerate with conglomid.
1:      * <p>
1:      * Return the Conglomerate Object.  This is implementation specific.
1:      * Examples of what will be done is using the id to find the file where
1:      * the conglomerate is located, and then executing implementation specific
1:      * code to instantiate an object from reading a "special" row from a
1:      * known location in the file.  In the btree case the btree conglomerate
1:      * is stored as a column in the control row on the root page.
1:      * <p>
1:      * This operation is costly so it is likely an implementation using this
1:      * will cache the conglomerate row in memory so that subsequent accesses
1:      * need not perform this operation.
1:      * <p>
1:      * The btree object returned by this routine may be installed in a cache
1:      * so the object must not change.
1:      *
0:      * @param conglomid      The unique id of the existing conglomerate.
1:      *
1: 	 * @return An instance of the conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public Conglomerate readConglomerate(
1:     TransactionManager  xact_manager,
1:     ContainerKey        container_key)
1: 		throws StandardException
1:     {
1:         Conglomerate    btree      = null;
1:         ContainerHandle container  = null;
1:         ControlRow      root       = null;
1: 
1:         try
1:         {
1:             // open readonly, with no locks.  Dirty read is ok as it is the
1:             // responsibility of client code to make sure this data is not
1:             // changing while being read.  The only changes that currently
1:             // happen to this data is creation and deletion - no updates
1:             // ever happen to btree conglomerates.
1:             container = 
1:                 (xact_manager.getRawStoreXact()).openContainer(
1:                     container_key,
1:                     (LockingPolicy) null,
1:                     ContainerHandle.MODE_READONLY);
1: 
1:             if (container == null)
1:             {
1:                 // thrown a "known" error if the conglomerate does not exist 
1:                 // which is checked for explicitly by callers of the store 
1:                 // interface.
1: 
1:                 throw StandardException.newException(
1:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
0:                     new Long(container_key.getContainerId()));
1:             }
1: 
1:             // The conglomerate is located in the control row on the root page.
0:             root = ControlRow.Get(container, BTree.ROOTPAGEID);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(root.getPage().isLatched());
1: 
1:             // read the Conglomerate from it's entry in the control row.
0:             btree = (B2I) root.getConglom(B2I.FORMAT_NUMBER);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(btree instanceof B2I);
1:         }
1:         finally
1:         {
1: 
1:             if (root != null)
1:                 root.release();
1: 
1:             if (container != null)
1:                 container.close();
1:         }
1: 
1:         // if any error, just return null - meaning can't access the container.
1: 
1:         return(btree);
1:     }
1: 
1: 	/*
1: 	** Methods of ModuleControl.
1: 	*/
1: 
1: 	public boolean canSupport(Properties startParams) {
1: 
1: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
1: 		if (impl == null)
1: 			return false;
1: 
1: 		return supportsImplementation(impl);
1: 	}
1: 
1: 	public void	boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		// Find the UUID factory.
1: 		UUIDFactory uuidFactory = 
0:             Monitor.getMonitor().getUUIDFactory();
1: 
1: 		// Make a UUID that identifies this conglomerate's format.
1: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1: 	}
1: 
1: 	public void	stop()
1: 	{
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree.index;
0: 
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.ConglomerateFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.store.access.btree.BTree;
0: import org.apache.derby.impl.store.access.btree.BranchControlRow;
0: import org.apache.derby.impl.store.access.btree.ControlRow;
0: import org.apache.derby.impl.store.access.btree.BTreeController;
0: import org.apache.derby.impl.store.access.btree.LeafControlRow;
0: import org.apache.derby.impl.store.access.btree.OpenBTree;
0: 
0: /**
0: 
0:   The "B2I" (acronym for b-tree secondary index) factory manages b-tree
0:   conglomerates implemented	on the raw store which are used as secondary
0:   indexes.
0:   <p>
0:   Most of this code is generic to all conglomerates.  This class might be
0:   more easily maintained as an abstract class in Raw/Conglomerate/Generic.
0:   The concrete ConglomerateFactories would simply have to supply the 
0:   IMPLEMENTATIONID, FORMATUUIDSTRING, and implement createConglomerate
0:   and defaultProperties.  Conglomerates which support more than one format
0:   would have to override supportsFormat, and conglomerates which support
0:   more than one implementation would have to override supportsImplementation.
0: 
0: **/
0: 
0: public class B2IFactory implements ConglomerateFactory, ModuleControl
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private static final String IMPLEMENTATIONID = "BTREE";
0: 	private static final String FORMATUUIDSTRING = "C6CEEEF0-DAD3-11d0-BB01-0060973F0942";
0: 	private UUID formatUUID;
0: 
0: 
0: 	/*
0: 	** Methods of MethodFactory (via ConglomerateFactory)
0: 	*/
0: 
0: 	/**
0: 	Return the default properties for this kind of conglomerate.
0: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#defaultProperties
0: 	**/
0: 	public Properties defaultProperties()
0: 	{
0: 		// XXX (nat) Need to return the default b-tree secondary index properties.
0: 		return new Properties();
0: 	}
0: 
0: 	/**
0: 	Return whether this access method implements the implementation
0: 	type given in the argument string.
0: 	The btree only has one implementation type, "BTREE".
0: 
0: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsImplementation
0: 	**/
0: 	public boolean supportsImplementation(String implementationId)
0: 	{
0: 		return implementationId.equals(IMPLEMENTATIONID);
0: 	}
0: 
0: 	/**
0: 	Return the primary implementation type for this access method.
0: 	The btree only has one implementation type, "BTREE".
0: 
0: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryImplementationType
0: 	**/
0: 	public String primaryImplementationType()
0: 	{
0: 		return IMPLEMENTATIONID;
0: 	}
0: 
0: 	/**
0: 	Return whether this access method supports the format supplied in
0: 	the argument.
0: 	The btree currently only supports one format.
0: 
0: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#supportsFormat
0: 	**/
0: 	public boolean supportsFormat(UUID formatid)
0: 	{
0: 		return formatid.equals(formatUUID);
0: 	}
0: 
0: 	/**
0: 	Return the primary format that this access method supports.
0: 	The btree currently only supports one format.
0: 
0: 	@see org.apache.derby.iapi.store.access.conglomerate.MethodFactory#primaryFormat
0: 	**/
0: 	public UUID primaryFormat()
0: 	{
0: 		return formatUUID;
0: 	}
0: 
0: 	/*
0: 	** Methods of ConglomerateFactory
0: 	*/
0: 
0:     /**
0:      * Return the conglomerate factory id.
0:      * <p>
0:      * Return a number in the range of 0-15 which identifies this factory.
0:      * Code which names conglomerates depends on this range currently, but
0:      * could be easily changed to handle larger ranges.   One hex digit seemed
0:      * reasonable for the number of conglomerate types being currently 
0:      * considered (heap, btree, gist, gist btree, gist rtree, hash, others? ).
0:      * <p>
0: 	 * @see ConglomerateFactory#getConglomerateFactoryId
0:      *
0: 	 * @return an unique identifier used to the factory into the conglomid.
0:      **/
0:     public int getConglomerateFactoryId()
0:     {
0:         return(ConglomerateFactory.BTREE_FACTORY_ID);
0:     }
0: 
0: 	/**
0: 	Create the conglomerate and return a conglomerate object for it.
0: 
0: 	@see ConglomerateFactory#createConglomerate
0: 
0:     @exception StandardException Standard exception policy.
0: 	**/
0: 	public Conglomerate createConglomerate(	
0:     TransactionManager      xact_mgr,
0:     int                     segment,
0:     long                    input_containerid,
0:     DataValueDescriptor[]   template,
0: 	ColumnOrdering[]        columnOrder,
0:     Properties              properties,
0: 	int                     temporaryFlag)
0:             throws StandardException
0: 	{
0: 		B2I btree = new B2I();
0: 		btree.create(
0:             xact_mgr, segment, input_containerid, template, columnOrder, 
0:             properties, temporaryFlag);
0: 
0: 		return(btree);
0: 	}
0: 
0:     /**
0:      * Return Conglomerate object for conglomerate with conglomid.
0:      * <p>
0:      * Return the Conglomerate Object.  This is implementation specific.
0:      * Examples of what will be done is using the id to find the file where
0:      * the conglomerate is located, and then executing implementation specific
0:      * code to instantiate an object from reading a "special" row from a
0:      * known location in the file.  In the btree case the btree conglomerate
0:      * is stored as a column in the control row on the root page.
0:      * <p>
0:      * This operation is costly so it is likely an implementation using this
0:      * will cache the conglomerate row in memory so that subsequent accesses
0:      * need not perform this operation.
0:      * <p>
0:      * The btree object returned by this routine may be installed in a cache
0:      * so the object must not change.
0:      *
0:      * @param conglomid      The unique id of the existing conglomerate.
0:      *
0: 	 * @return An instance of the conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public Conglomerate readConglomerate(
0:     TransactionManager  xact_manager,
0:     ContainerKey        container_key)
0: 		throws StandardException
0:     {
0:         Conglomerate    btree      = null;
0:         ContainerHandle container  = null;
0:         ControlRow      root       = null;
0: 
0:         try
0:         {
0:             // open readonly, with no locks.  Dirty read is ok as it is the
0:             // responsibility of client code to make sure this data is not
0:             // changing while being read.  The only changes that currently
0:             // happen to this data is creation and deletion - no updates
0:             // ever happen to btree conglomerates.
0:             container = 
0:                 (xact_manager.getRawStoreXact()).openContainer(
0:                     container_key,
0:                     (LockingPolicy) null,
0:                     ContainerHandle.MODE_READONLY);
0: 
0:             if (container == null)
0:             {
0:                 // thrown a "known" error if the conglomerate does not exist 
0:                 // which is checked for explicitly by callers of the store 
0:                 // interface.
0: 
0:                 throw StandardException.newException(
0:                     SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST, 
0:                     new Long(container_key.getContainerId()));
0:             }
0: 
0:             // The conglomerate is located in the control row on the root page.
0:             root = ControlRow.Get(container, BTree.ROOTPAGEID);
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(root.getPage().isLatched());
0: 
0:             // read the Conglomerate from it's entry in the control row.
0:             btree = (B2I) root.getConglom(B2I.FORMAT_NUMBER);
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(btree instanceof B2I);
0:         }
0:         finally
0:         {
0: 
0:             if (root != null)
0:                 root.release();
0: 
0:             if (container != null)
0:                 container.close();
0:         }
0: 
0:         // if any error, just return null - meaning can't access the container.
0: 
0:         return(btree);
0:     }
0: 
0: 	/*
0: 	** Methods of ModuleControl.
0: 	*/
0: 
0: 	public boolean canSupport(Properties startParams) {
0: 
0: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
0: 		if (impl == null)
0: 			return false;
0: 
0: 		return supportsImplementation(impl);
0: 	}
0: 
0: 	public void	boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		// Find the UUID factory.
0: 		UUIDFactory uuidFactory = 
0:             Monitor.getMonitor().getUUIDFactory();
0: 
0: 		// Make a UUID that identifies this conglomerate's format.
0: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
0: 	}
0: 
0: 	public void	stop()
0: 	{
0: 	}
0: }
============================================================================