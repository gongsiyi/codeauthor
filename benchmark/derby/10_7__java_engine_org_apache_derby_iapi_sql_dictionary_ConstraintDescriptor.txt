1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
6:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:eac0369: 
1:9f0dc0e: import java.util.Arrays;
2:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
2:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
2:eac0369: import org.apache.derby.iapi.sql.depend.Dependent;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:bc2c59e: import org.apache.derby.iapi.services.io.ArrayUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.catalog.DependableFinder;
1:eac0369: import org.apache.derby.catalog.Dependable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:eac0369: import	org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:997ee7f: import org.apache.derby.iapi.store.access.TransactionController;
1:e87a9fd: 
6:eac0369: /**
1:eac0369:  * This class is used to get information from a ConstraintDescriptor.
1:eac0369:  * A ConstraintDescriptor can represent a constraint on a table or on a
1:eac0369:  * column.
2:eac0369:  *
1:eac0369:  * @version 0.1
1:eac0369:  */
1:eac0369: 
1:eac0369: public abstract class ConstraintDescriptor 
1:f2fad75: 	extends UniqueTupleDescriptor
1:f2fad75: 	implements Provider, Dependent
8:eac0369: {
1:eac0369: 	// used to indicate what type of constraints we 
1:eac0369: 	// are interested in
1:eac0369: 	public static final int ENABLED		= 1;
1:eac0369: 	public static final int DISABLED	= 2;
1:eac0369: 	public static final int ALL			= 3;
1:eac0369: 
1:eac0369: 	// field that we want users to be able to know about
1:eac0369: 	public static final int SYSCONSTRAINTS_STATE_FIELD = 6;
1:eac0369: 
1:09bee7d:     TableDescriptor       table;
1:09bee7d:     final String          constraintName;
1:09bee7d:     private boolean deferrable;
1:09bee7d:     private boolean initiallyDeferred;
1:09bee7d:     private boolean enforced;
1:4eece41: 	private final int[]				referencedColumns;
1:4eece41: 	final UUID					constraintId;
1:4eece41: 	private final SchemaDescriptor	schemaDesc;
1:4eece41: 	private ColumnDescriptorList	colDL;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a ConstraintDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1:eac0369: 	 * @param table		The descriptor of the table the constraint is on
1:eac0369: 	 * @param constraintName	The name of the constraint.
1:eac0369: 	 * @param deferrable		If the constraint can be deferred.
1:eac0369: 	 * @param initiallyDeferred If the constraint starts life deferred.
1:eac0369: 	 * @param referencedColumns columns that the constraint references
1:eac0369: 	 * @param constraintId		UUID of constraint
1:eac0369: 	 * @param schemaDesc		SchemaDescriptor
1:09bee7d:      * @param enforced          Is the constraint enforced?
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	ConstraintDescriptor(
1:eac0369: 		    DataDictionary dataDictionary,
1:eac0369: 			TableDescriptor table,
1:eac0369: 			String constraintName,
1:eac0369: 			boolean deferrable,
1:eac0369: 			boolean initiallyDeferred,
1:eac0369: 			int[] referencedColumns,
1:eac0369: 			UUID constraintId,
1:eac0369: 			SchemaDescriptor schemaDesc,
1:09bee7d:             boolean enforced
1:eac0369: 			)
1:eac0369: 	{
1:eac0369: 		super( dataDictionary );
1:eac0369: 
1:eac0369: 		this.table = table;
1:eac0369: 		this.constraintName = constraintName;
1:eac0369: 		this.deferrable = deferrable;
1:09bee7d:         this.initiallyDeferred = initiallyDeferred;
1:eac0369: 		this.referencedColumns = referencedColumns;
2:eac0369: 		this.constraintId = constraintId;
1:eac0369: 		this.schemaDesc = schemaDesc;
1:09bee7d:         this.enforced = enforced;
6:eac0369: 	}
1:997ee7f: 
1:eac0369: 
1:997ee7f: 	/**
1:eac0369: 	 * Gets the UUID of the table the constraint is on.
1:eac0369: 	 *
1:eac0369: 	 * @return	The UUID of the table the constraint is on.
1:eac0369: 	 */
1:eac0369: 	public UUID	getTableId()
1:eac0369: 	{
1:eac0369: 		return table.getUUID();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the UUID of the constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return	The UUID of the constraint.
1:eac0369: 	 */
1:eac0369: 	public UUID	getUUID()
1:eac0369: 	{
1:eac0369: 		return constraintId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the name of the constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String containing the name of the constraint.
1:eac0369: 	 */
1:eac0369: 	public String	getConstraintName()
1:eac0369: 	{
1:eac0369: 		return constraintName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets an identifier telling what type of descriptor it is
1:eac0369: 	 * (UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
1:eac0369: 	 *
1:eac0369: 	 * @return	An identifier telling what type of descriptor it is
1:eac0369: 	 *		(UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
1:eac0369: 	 */
1:eac0369: 	public abstract int	getConstraintType();
1:eac0369: 
1:eac0369: 	public abstract UUID getConglomerateId();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the text of the constraint. (Only non-null/meaningful for check
1:eac0369: 	 * constraints.)
1:eac0369: 	 * @return	The constraint text.
1:eac0369: 	 */
1:eac0369: 	public String getConstraintText()
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if the constraint is deferrable
1:eac0369: 	 *
1:09bee7d:      * @return  TRUE if the constraint is DEFERRABLE, FALSE if it is
1:09bee7d:      *          NOT DEFERRABLE.
1:eac0369: 	 */
1:09bee7d:     public boolean deferrable()
1:eac0369: 	{
1:eac0369: 		return deferrable;
1:eac0369: 	}
1:eac0369: 
1:09bee7d:     public void setDeferrable(boolean b) {
1:09bee7d:         deferrable = b;
1:09bee7d:     }
1:09bee7d: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if the constraint is initially deferred
1:eac0369: 	 *
1:09bee7d:      * @return  TRUE if the constraint is initially DEFERRED,
1:09bee7d:      *      FALSE if the constraint is initially IMMEDIATE
1:eac0369: 	 */
1:eac0369: 	public boolean	initiallyDeferred()
1:eac0369: 	{
1:09bee7d:         return initiallyDeferred;
1:eac0369: 	}
1:eac0369: 
1:09bee7d:     public void setInitiallyDeferred(boolean b) {
1:09bee7d:         initiallyDeferred = b;
1:09bee7d:     }
1:09bee7d: 
1:eac0369: 	/**
1:eac0369: 	 * Returns an array of column ids (i.e. ordinal positions) for
1:eac0369: 	 * the columns referenced in this table for a primary key, unique
1:eac0369: 	 * key, referential, or check constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return	An array of column ids for those constraints that can
1:eac0369: 	 *		be on columns (primary, unique key, referential
1:eac0369: 	 *		constraints, and check constraints).  For check and
1:eac0369: 	 *		unique constraints, it returns an array of columns ids
1:eac0369: 	 *		that are referenced in the constraint.  For primary key
1:eac0369: 	 *		and referential constraints, it returns an array of
1:eac0369: 	 *		column ids for the columns in this table (i.e. the
1:eac0369: 	 *		primary key columns for a primary key constraint,
1:eac0369: 	 *		and the foreign key columns for a foreign key
1:eac0369: 	 *		constraint.
1:eac0369: 	 */
1:eac0369: 	public int[]	getReferencedColumns()
1:eac0369: 	{
1:bc2c59e: 		return ArrayUtil.copy( referencedColumns );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this constraint have a backing index?
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not there is a backing index for this constraint.
1:eac0369: 	 */
1:eac0369: 	public abstract boolean hasBackingIndex();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the SchemaDescriptor for the schema that this constraint
1:eac0369: 	 * belongs to.
1:eac0369: 	 *
1:eac0369: 	 * @return SchemaDescriptor The SchemaDescriptor for this constraint.
1:eac0369: 	 */
1:eac0369: 	public SchemaDescriptor getSchemaDescriptor()
1:eac0369: 	{
1:eac0369: 		return schemaDesc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  RESOLVE: For now the ConstraintDescriptor code stores the array of key
1:eac0369: 	  columns in the field 'otherColumns'. Jerry plans to re-organize things.
1:eac0369: 	  For now to minimize his rototill I've implemented this function on the
1:eac0369: 	  old structures. All new code should use getKeyColumns to get a constraint's
1:eac0369: 	  key columns.
1:eac0369: 	  
1:eac0369: 	  @see org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor#getKeyColumns
1:eac0369: 	  */
1:eac0369: 	public int[]	getKeyColumns()
1:eac0369: 	{
1:eac0369: 		return getReferencedColumns();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Is this constraint enforced?
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:09bee7d:     public boolean enforced()
1:eac0369: 	{
1:09bee7d:         return enforced;
1:eac0369: 	}
1:eac0369: 
1:09bee7d:     public void setEnforced(boolean b) {
1:09bee7d:         enforced = b;
1:09bee7d:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this constraint referenced?  Return
1:eac0369: 	 * false.  Overridden by ReferencedKeyConstraints.
1:eac0369: 	 *
1:eac0369: 	 * @return false
1:eac0369: 	 */
1:eac0369: 	public boolean isReferenced()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:09bee7d:      * Get the number of enforced fks that
1:eac0369: 	 * reference this key.  Overriden by
1:eac0369: 	 * ReferencedKeyConstraints.
1:eac0369: 	 *
1:eac0369: 	 * @return the number of fks
1:eac0369: 	 */
1:eac0369: 	public int getReferenceCount()
1:eac0369: 	{
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does this constraint need to fire on this type of
1:eac0369: 	 * DML?
1:eac0369: 	 *
1:6b50965: 	 * @param stmtType	the type of DML 
1:eac0369: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
1:eac0369: 	 * @param modifiedCols	the columns modified, or null for all
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:eac0369: 	public abstract boolean needsToFire(int stmtType, int[] modifiedCols);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the table descriptor upon which this constraint
1:eac0369: 	 * is declared.
1:eac0369: 	 *
1:eac0369: 	 * @return the table descriptor
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getTableDescriptor()
1:eac0369: 	{
1:eac0369: 		return table;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the column descriptors for all the columns
1:eac0369: 	 * referenced by this constraint.
1:eac0369: 	 *
1:eac0369: 	 * @return the column descriptor list
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public ColumnDescriptorList getColumnDescriptors()
1:997ee7f: 		throws StandardException
1:997ee7f: 	{
1:eac0369: 		if (colDL == null)
1:997ee7f: 		{
1:eac0369: 			colDL = new ColumnDescriptorList();
1:eac0369: 	
1:eac0369: 			int[]	refCols = getReferencedColumns();
1:eac0369: 			for (int i = 0; i < refCols.length; i++)
1:997ee7f: 			{
1:eac0369: 				colDL.add(table.getColumnDescriptor(refCols[i]));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return colDL;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicates whether the column descriptor list is
1:eac0369: 	 * type comparable with the constraints columns.  The
1:eac0369: 	 * types have to be identical AND in the same order 
1:eac0369: 	 * to succeed.
1:eac0369: 	 *
1:eac0369: 	 * @param otherColumns the columns to compare
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public boolean areColumnsComparable(ColumnDescriptorList otherColumns)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ColumnDescriptor		myColumn;
1:eac0369: 		ColumnDescriptor		otherColumn;
1:eac0369: 
1:eac0369: 		ColumnDescriptorList	myColDl = getColumnDescriptors();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Check the lenghts of the lists
1:eac0369: 		*/
1:eac0369: 		if (otherColumns.size() != myColDl.size())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int mySize = myColDl.size();
1:eac0369: 		int otherSize = otherColumns.size();
1:eac0369: 		int index;
1:eac0369: 		for (index = 0; index < mySize && index < otherSize; index++)
1:eac0369: 		{
1:801cf0d:             myColumn = myColDl.elementAt(index);
1:801cf0d:             otherColumn = otherColumns.elementAt(index);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Just compare the types.  Note that this will
1:eac0369: 	 		** say a decimal(x,y) != numeric(x,y) even though
1:eac0369: 			** it does.
1:eac0369: 			*/
1:eac0369: 			if (!(myColumn.getType()).isExactTypeAndLengthMatch(
1:eac0369: 					(otherColumn.getType())))
1:eac0369: 			{
1:997ee7f: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return (index == mySize && index == otherSize);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does a column intersect with our referenced columns
1:6b50965: 	 * @param columnArray columns to check
1:eac0369: 	 * 
1:eac0369: 	 * Note-- this is not a static method.
1:eac0369: 	 */
1:eac0369: 	public boolean columnIntersects(int columnArray[])
1:eac0369: 	{
1:eac0369: 		// call static method.
1:eac0369: 		return doColumnsIntersect(getReferencedColumns(), columnArray);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Does a column in the input set intersect with
1:eac0369: 	 * our referenced columns?
1:eac0369: 	 *
1:eac0369: 	 * @param otherColumns the columns to compare. If
1:eac0369: 	 *	null, asssumed to mean all columns
1:eac0369: 	 *
1:6b50965: 	 * @param referencedColumns the columns referenced by the caller
1:eac0369: 	 *
1:eac0369: 	 * @return true/false
1:eac0369: 	 */
1:eac0369: 	static boolean doColumnsIntersect(int[] otherColumns, int[] referencedColumns)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** It is assumed that if otherColumns is null, then
1:eac0369: 		** all other columns are modified.  In this case,
1:eac0369: 		** it is assumed that it intersects with some column
1:eac0369: 	 	** of ours, so just return true.
1:eac0369: 		*/
1:eac0369: 		if ((otherColumns == null) || (referencedColumns == null))
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int outer = 0; outer < referencedColumns.length; outer++)
1:eac0369: 		{	
1:eac0369: 			for (int inner = 0; inner < otherColumns.length; inner++)
1:eac0369: 			{
1:eac0369: 				if (referencedColumns[outer] == otherColumns[inner])
1:eac0369: 				{
1:eac0369: 					return true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert the ColumnDescriptor to a String.
1:eac0369: 	 *
1:eac0369: 	 * @return	A String representation of this ColumnDescriptor
1:eac0369: 	 */
1:eac0369: 
1:801cf0d:     @Override
1:801cf0d:     public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			String tableDesc =
1:eac0369: 				"table: " +
1:eac0369: 				table.getQualifiedName() + "(" +
1:eac0369: 				table.getUUID()+","+
1:eac0369: 				table.getTableType()+")";
1:eac0369: 
1:eac0369: 			return tableDesc + "\n"+
1:eac0369: 				"constraintName: " + constraintName + "\n" +
1:eac0369: 				"constraintId: " + constraintId + "\n" +
1:eac0369: 				"deferrable: " + deferrable + "\n" +
1:09bee7d:                 "initiallyDeferred: " + initiallyDeferred + "\n" +
1:9f0dc0e:                "referencedColumns: " +
1:9f0dc0e:                     Arrays.toString(referencedColumns) + "\n" +
1:eac0369: 				"schemaDesc: " + schemaDesc + "\n"
1:eac0369: 				;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:f8fa8cf: 	//
1:eac0369: 	// PROVIDER INTERFACE
2:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 		@return the stored form of this provider
1:eac0369: 
1:eac0369: 			@see Dependable#getDependableFinder
1:eac0369: 	 */
1:eac0369: 	public DependableFinder getDependableFinder() 
1:eac0369: 	{
1:eac0369: 	    return	getDependableFinder(StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the name of this Provider.  (Useful for errors.)
1:eac0369: 	 *
1:eac0369: 	 * @return String	The name of this provider.
1:eac0369: 	 */
1:eac0369: 	public String getObjectName()
1:eac0369: 	{
1:eac0369: 		return constraintName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's UUID
1:eac0369: 	 *
1:eac0369: 	 * @return 	The provider's UUID
1:eac0369: 	 */
1:eac0369: 	public UUID getObjectID()
1:eac0369: 	{
1:eac0369: 		return constraintId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the provider's type.
1:eac0369: 	 *
1:eac0369: 	 * @return char		The provider's type.
1:eac0369: 	 */
1:eac0369: 	public String getClassType()
1:eac0369: 	{
1:eac0369: 		return Dependable.CONSTRAINT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// DEPENDENT INTERFACE
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Check that all of the dependent's dependencies are valid.
1:eac0369: 	 *
1:eac0369: 	 * @return true if the dependent is currently valid
1:eac0369: 	 */
1:eac0369: 	public synchronized boolean isValid()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prepare to mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).
1:eac0369: 	 *
1:eac0369: 	 * @param action	The action causing the invalidation
1:eac0369: 	 * @param p		the provider
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if unable to make it invalid
1:eac0369: 	 */
1:eac0369: 	public void prepareToInvalidate(Provider p, int action,
1:eac0369: 					LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		DependencyManager dm = getDataDictionary().getDependencyManager();
1:eac0369: 
1:eac0369: 		switch (action)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** A SET CONSTRAINT stmt will throw an SET_CONSTRAINTS action
1:eac0369: 			** when enabling/disabling constraints.  We'll ignore it.
1:eac0369: 			** Same for SET TRIGGERS
1:eac0369: 			*/
1:eac0369: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1:eac0369: 		    case DependencyManager.SET_CONSTRAINTS_DISABLE:
1:eac0369: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1:eac0369: 		    case DependencyManager.SET_TRIGGERS_DISABLE:
1:f80e3ce: 		    case DependencyManager.RENAME:
1:71408ab: 			//When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1:71408ab: 			//types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1:71408ab: 			//don't do anything here. Later in makeInvalid method, we make  
1:71408ab: 			//the ConstraintDescriptor drop itself. 
1:eb38311: 			//Ditto for role grant conferring a privilege.
1:08313de: 		    case DependencyManager.REVOKE_PRIVILEGE:
1:eb38311: 		    case DependencyManager.REVOKE_ROLE:
1:1a63d73: 		    case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
1:e4caed2: 				// Only used by Activations
1:e4caed2: 		    case DependencyManager.RECHECK_PRIVILEGES:
2:eac0369: 				break;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Currently, the only thing we are depenedent
1:eac0369: 			** on is another constraint or an alias..
1:eac0369: 			*/
1:71408ab: 			//Notice that REVOKE_PRIVILEGE_RESTRICT is not caught earlier.
1:71408ab: 		    //It gets handled in this default: action where an exception
1:71408ab: 		    //will be thrown. This is because, if such an invalidation 
1:71408ab: 		    //action type is ever received by a dependent, the dependent 
1:71408ab: 		    //should throw an exception.
1:71408ab: 			//In Derby, at this point, REVOKE_PRIVILEGE_RESTRICT gets sent
1:71408ab: 		    //when execute privilege on a routine is getting revoked.
1:71408ab: 		    //Currently, in Derby, a constraint can't depend on a routine 
1:71408ab: 		    //and hence a REVOKE_PRIVILEGE_RESTRICT invalidation action
1:71408ab: 		    //should never be received by a ConstraintDescriptor. But this
1:71408ab: 		    //may change in future and when it does, the code to do the right
1:71408ab: 		    //thing is already here.
1:eac0369: 		    default:
1:eac0369: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
1:eac0369: 									dm.getActionString(action), 
1:eac0369: 									p.getObjectName(), "CONSTRAINT", constraintName);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the dependent as invalid (due to at least one of
1:eac0369: 	 * its dependencies being invalid).  Always an error
1:eac0369: 	 * for a constraint -- should never have gotten here.
1:eac0369: 	 *
1:eac0369: 	 * @param	action	The action causing the invalidation
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if called in sanity mode
1:eac0369: 	 */
1:eac0369: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1:eac0369: 		throws StandardException
1:08313de: 	{
1:71408ab: 		/*
1:71408ab: 		** For ConstraintDescriptor, SET_CONSTRAINTS/TRIGGERS and 
1:71408ab: 		*  REVOKE_PRIVILEGE are the only valid actions
1:71408ab: 		*/
1:71408ab: 
1:eb38311: 		//Let's handle REVOKE_PRIVILEGE and REVOKE_ROLE first
1:eb38311: 		if (action == DependencyManager.REVOKE_PRIVILEGE ||
1:eb38311: 			action == DependencyManager.REVOKE_ROLE)
1:eac0369: 		{
1:71408ab: 			//At this point (Derby 10.2), only a FOREIGN KEY key constraint can
1:f8fa8cf: 			//depend on a privilege. None of the other constraint types 
1:f8fa8cf: 			//can be dependent on a privilege becuse those constraint types
1:f8fa8cf: 			//can not reference a table/routine.
1:c437565: 			ConglomerateDescriptor newBackingConglomCD = drop(lcc, true);
1:eb38311: 
1:3d2d88b:             //
1:3d2d88b:             // Invalidate every statement which depends on the table.
1:3d2d88b:             // This causes us to follow the same code path which we pursue
1:3d2d88b:             // when the CHECK constraint is dropped explicitly.
1:3d2d88b:             //
1:3d2d88b:             getDataDictionary().getDependencyManager().invalidateFor( table, DependencyManager.ALTER_TABLE, lcc );
1:3d2d88b: 
1:eb38311: 			lcc.getLastActivation().addWarning(
1:eb38311: 				StandardException.newWarning(
1:eb38311: 					SQLState.LANG_CONSTRAINT_DROPPED,
1:eb38311: 					getConstraintName(),
1:eb38311: 					getTableDescriptor().getName()));
1:eb38311: 
1:c437565: 			if (newBackingConglomCD != null)
1:c437565: 			{
1:c437565: 				/* Since foreign keys can never be unique, and since
1:c437565: 				 * we only (currently) share conglomerates if two
1:c437565: 				 * constraints/indexes have identical columns, dropping
1:c437565: 				 * a foreign key should not necessitate the creation of
1:c437565: 				 * another physical conglomerate.  That will change if
1:c437565: 				 * DERBY-2204 is implemented, but for now we don't expect
1:c437565: 				 * it to happen...
1:c437565: 				 */
1:c437565: 				if (SanityManager.DEBUG)
1:c437565: 				{
1:c437565: 					SanityManager.THROWASSERT(
1:c437565: 						"Dropped shared conglomerate due to a REVOKE " +
1:c437565: 						"and found that a new conglomerate was needed " +
1:c437565: 						"to replace it...but that shouldn't happen!");
1:c437565: 				}
1:c437565: 			}
1:08313de: 			return;
1:08313de: 		}
1:08313de: 
1:eac0369: 		/*
1:71408ab: 		** Now, handle SET_CONSTRAINTS/TRIGGERS
1:eac0369: 		*/
1:eac0369: 		if ((action != DependencyManager.SET_CONSTRAINTS_DISABLE) &&
1:eac0369: 			(action != DependencyManager.SET_CONSTRAINTS_ENABLE) &&
1:eac0369: 			(action != DependencyManager.SET_TRIGGERS_ENABLE) &&
1:1a63d73: 			(action != DependencyManager.SET_TRIGGERS_DISABLE) &&
1:e4caed2: 			(action != DependencyManager.INTERNAL_RECOMPILE_REQUEST) &&
1:f80e3ce: 			(action != DependencyManager.RECHECK_PRIVILEGES) &&
1:f80e3ce: 			(action != DependencyManager.RENAME)
1:eac0369: 		   )
1:eac0369: 		{
1:eac0369: 			/* 
1:eac0369: 			** We should never get here, we should have barfed on 
1:eac0369: 			** prepareToInvalidate().
1:eac0369: 			*/
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				DependencyManager dm;
1:eac0369: 		
1:eac0369: 				dm = getDataDictionary().getDependencyManager();
1:eac0369: 	
1:eac0369: 				SanityManager.THROWASSERT("makeInvalid("+
1:eac0369: 					dm.getActionString(action)+
1:eac0369: 					") not expected to get called");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:     
1:eac0369:     /**
1:997ee7f:      * Drop the constraint.  Clears dependencies, drops 
1:997ee7f:      * the backing index and removes the constraint
1:997ee7f:      * from the list on the table descriptor.  Does NOT
1:997ee7f:      * do an dm.invalidateFor()
1:c92685e:      *
1:c92685e:      * @return If the backing conglomerate for this constraint
1:c92685e:      *  was a) dropped and b) shared by other constraints/indexes,
1:c92685e:      *  then this method will return a ConglomerateDescriptor that
1:c92685e:      *  describes what a new backing conglomerate must look like
1:c92685e:      *  to stay "sharable" across the remaining constraints/indexes.
1:c92685e:      *  It is then up to the caller to create a corresponding 
1:c92685e:      *  conglomerate.  We don't create the conglomerate here
1:c92685e:      *  because depending on who called us, it might not make
1:c92685e:      *  sense to create it--ex. if we get here because of a DROP
1:c92685e:      *  TABLE, the DropTable action doesn't need to create a
1:c92685e:      *  new backing conglomerate since the table (and all of
1:c92685e:      *  its constraints/indexes) are going to disappear anyway.
1:997ee7f:      */
1:c92685e:     public ConglomerateDescriptor drop(LanguageConnectionContext lcc,
1:c92685e:         boolean clearDependencies) throws StandardException
1:997ee7f:     {       
1:997ee7f:         DataDictionary dd = getDataDictionary();
1:997ee7f:         TransactionController tc = lcc.getTransactionExecute();
1:997ee7f: 
1:997ee7f:         if (clearDependencies)
1:997ee7f:         {
1:c7a1d17:             DependencyManager dm = dd.getDependencyManager();
1:997ee7f:             dm.clearDependencies(lcc, this);
1:997ee7f:         }
1:997ee7f: 
1:997ee7f:         /* Drop the constraint.
1:997ee7f:          * NOTE: This must occur before dropping any backing index, since
1:997ee7f:          * a user is not allowed to drop a backing index without dropping
1:997ee7f:          * the constraint.
1:997ee7f:          */
1:997ee7f:         dd.dropConstraintDescriptor(this, tc);
1:997ee7f: 
1:997ee7f:         /* Drop the index, if there's one for this constraint.
1:997ee7f:          * NOTE: There will always be an indexAction. We don't
1:997ee7f:          * force the constraint to exist at bind time, so we always
1:997ee7f:          * generate one.
1:997ee7f:          */
1:c92685e:         ConglomerateDescriptor newBackingConglomCD = null;
1:997ee7f:         if (hasBackingIndex())
1:997ee7f:         {
1:997ee7f: 
1:997ee7f:             // it may have duplicates, and we drop a backing index
1:997ee7f:             // Bug 4307
1:997ee7f:             // We need to get the conglomerate descriptors from the 
1:997ee7f:             // dd in case we dropped other constraints in a cascade operation. 
1:0c5bc3a:             ConglomerateDescriptor[]conglomDescs =
1:0c5bc3a:                     dd.getConglomerateDescriptors(getConglomerateId());
1:997ee7f: 
1:0c5bc3a:             // Typically there is only one ConglomerateDescriptor
1:0c5bc3a:             // for a given UUID, but due to an old bug
1:0c5bc3a:             // there may be more than one. If there is more
1:0c5bc3a:             // than one then which one is remvoed does not
1:0c5bc3a:             // matter since they will all have the same critical
1:0c5bc3a:             // information since they point to the same physical index.
1:0c5bc3a:             for (ConglomerateDescriptor cd : conglomDescs) {
1:0c5bc3a:                 if (cd.isConstraint()) {
1:0c5bc3a:                     newBackingConglomCD = cd.drop(lcc, table);
1:0c5bc3a:                     break;
1:997ee7f:                 }
1:997ee7f:             }
1:997ee7f:         }
1:997ee7f: 
1:997ee7f:         table.removeConstraintDescriptor(this);
1:c92685e:         return newBackingConglomCD;
1:997ee7f:     }
1:eac0369: 	
1:eac0369: 	/** @see TupleDescriptor#getDescriptorName */
1:801cf0d:     @Override
1:eac0369: 	public String getDescriptorName() { return constraintName; }
1:eac0369: 	
1:801cf0d:     @Override
1:eac0369: 	public String getDescriptorType() { return "Constraint"; }
1:997ee7f: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
0:                     lcc.forgetDeferredConstraintsData(
0:         } else {
0:             lcc.forgetDeferredConstraintsData(
0:                     getTableDescriptor().getHeapConglomerateId());
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:             ConglomerateDescriptor[]conglomDescs =
1:                     dd.getConglomerateDescriptors(getConglomerateId());
1:             // Typically there is only one ConglomerateDescriptor
1:             // for a given UUID, but due to an old bug
1:             // there may be more than one. If there is more
1:             // than one then which one is remvoed does not
1:             // matter since they will all have the same critical
1:             // information since they point to the same physical index.
1:             for (ConglomerateDescriptor cd : conglomDescs) {
1:                 if (cd.isConstraint()) {
0:                     lcc.invalidateDeferredConstraintsData(
0:                             cd.getConglomerateNumber());
1:                     newBackingConglomCD = cd.drop(lcc, table);
1:                     break;
commit:09bee7d
/////////////////////////////////////////////////////////////////////////
1:     TableDescriptor       table;
1:     final String          constraintName;
1:     private boolean deferrable;
1:     private boolean initiallyDeferred;
1:     private boolean enforced;
/////////////////////////////////////////////////////////////////////////
1:      * @param enforced          Is the constraint enforced?
/////////////////////////////////////////////////////////////////////////
1:             boolean enforced
/////////////////////////////////////////////////////////////////////////
1:         this.initiallyDeferred = initiallyDeferred;
1:         this.enforced = enforced;
/////////////////////////////////////////////////////////////////////////
1:      * @return  TRUE if the constraint is DEFERRABLE, FALSE if it is
1:      *          NOT DEFERRABLE.
1:     public boolean deferrable()
1:     public void setDeferrable(boolean b) {
1:         deferrable = b;
1:     }
1: 
1:      * @return  TRUE if the constraint is initially DEFERRED,
1:      *      FALSE if the constraint is initially IMMEDIATE
1:         return initiallyDeferred;
1:     public void setInitiallyDeferred(boolean b) {
1:         initiallyDeferred = b;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Is this constraint enforced?
1:     public boolean enforced()
1:         return enforced;
1:     public void setEnforced(boolean b) {
1:         enforced = b;
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * Get the number of enforced fks that
/////////////////////////////////////////////////////////////////////////
1:                 "initiallyDeferred: " + initiallyDeferred + "\n" +
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             myColumn = myColDl.elementAt(index);
1:             otherColumn = otherColumns.elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public String toString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
commit:9f0dc0e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:                "referencedColumns: " +
1:                     Arrays.toString(referencedColumns) + "\n" +
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
1: 				// Only used by Activations
1: 		    case DependencyManager.RECHECK_PRIVILEGES:
/////////////////////////////////////////////////////////////////////////
1: 			(action != DependencyManager.INTERNAL_RECOMPILE_REQUEST) &&
0: 			(action != DependencyManager.RECHECK_PRIVILEGES)
commit:eb38311
/////////////////////////////////////////////////////////////////////////
1: 			//Ditto for role grant conferring a privilege.
1: 		    case DependencyManager.REVOKE_ROLE:
/////////////////////////////////////////////////////////////////////////
1: 		//Let's handle REVOKE_PRIVILEGE and REVOKE_ROLE first
1: 		if (action == DependencyManager.REVOKE_PRIVILEGE ||
1: 			action == DependencyManager.REVOKE_ROLE)
1: 
1: 			lcc.getLastActivation().addWarning(
1: 				StandardException.newWarning(
1: 					SQLState.LANG_CONSTRAINT_DROPPED,
1: 					getConstraintName(),
1: 					getTableDescriptor().getName()));
1: 
commit:1a63d73
/////////////////////////////////////////////////////////////////////////
1: 		    case DependencyManager.INTERNAL_RECOMPILE_REQUEST:
/////////////////////////////////////////////////////////////////////////
1: 			(action != DependencyManager.SET_TRIGGERS_DISABLE) &&
0: 			(action != DependencyManager.INTERNAL_RECOMPILE_REQUEST)
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f80e3ce
/////////////////////////////////////////////////////////////////////////
1: 		    case DependencyManager.RENAME:
/////////////////////////////////////////////////////////////////////////
1: 			(action != DependencyManager.RECHECK_PRIVILEGES) &&
1: 			(action != DependencyManager.RENAME)
commit:3d2d88b
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // Invalidate every statement which depends on the table.
1:             // This causes us to follow the same code path which we pursue
1:             // when the CHECK constraint is dropped explicitly.
1:             //
1:             getDataDictionary().getDependencyManager().invalidateFor( table, DependencyManager.ALTER_TABLE, lcc );
1: 
commit:f2fad75
/////////////////////////////////////////////////////////////////////////
1: 	extends UniqueTupleDescriptor
1: 	implements Provider, Dependent
commit:bc2c59e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1: 		return ArrayUtil.copy( referencedColumns );
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c7a1d17
/////////////////////////////////////////////////////////////////////////
1:             DependencyManager dm = dd.getDependencyManager();
author:Army
-------------------------------------------------------------------------------
commit:c437565
/////////////////////////////////////////////////////////////////////////
1: 			ConglomerateDescriptor newBackingConglomCD = drop(lcc, true);
1: 			if (newBackingConglomCD != null)
1: 			{
1: 				/* Since foreign keys can never be unique, and since
1: 				 * we only (currently) share conglomerates if two
1: 				 * constraints/indexes have identical columns, dropping
1: 				 * a foreign key should not necessitate the creation of
1: 				 * another physical conglomerate.  That will change if
1: 				 * DERBY-2204 is implemented, but for now we don't expect
1: 				 * it to happen...
1: 				 */
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"Dropped shared conglomerate due to a REVOKE " +
1: 						"and found that a new conglomerate was needed " +
1: 						"to replace it...but that shouldn't happen!");
1: 				}
1: 			}
commit:c92685e
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return If the backing conglomerate for this constraint
1:      *  was a) dropped and b) shared by other constraints/indexes,
1:      *  then this method will return a ConglomerateDescriptor that
1:      *  describes what a new backing conglomerate must look like
1:      *  to stay "sharable" across the remaining constraints/indexes.
1:      *  It is then up to the caller to create a corresponding 
1:      *  conglomerate.  We don't create the conglomerate here
1:      *  because depending on who called us, it might not make
1:      *  sense to create it--ex. if we get here because of a DROP
1:      *  TABLE, the DropTable action doesn't need to create a
1:      *  new backing conglomerate since the table (and all of
1:      *  its constraints/indexes) are going to disappear anyway.
1:     public ConglomerateDescriptor drop(LanguageConnectionContext lcc,
1:         boolean clearDependencies) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         ConglomerateDescriptor newBackingConglomCD = null;
/////////////////////////////////////////////////////////////////////////
0:                         newBackingConglomCD = conglomDescs[i].drop(lcc, table);
/////////////////////////////////////////////////////////////////////////
1:         return newBackingConglomCD;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:997ee7f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
0: 			drop(lcc, true);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Drop the constraint.  Clears dependencies, drops 
1:      * the backing index and removes the constraint
1:      * from the list on the table descriptor.  Does NOT
1:      * do an dm.invalidateFor()
1:      */
0:     public void drop(LanguageConnectionContext lcc,
0:             boolean clearDependencies)
1:         throws StandardException
1:     {       
1:         DataDictionary dd = getDataDictionary();
0:         DependencyManager dm = dd.getDependencyManager();
1:         TransactionController tc = lcc.getTransactionExecute();
1: 
1:         if (clearDependencies)
1:         {
1:             dm.clearDependencies(lcc, this);
1:         }
1: 
1:         /* Drop the constraint.
1:          * NOTE: This must occur before dropping any backing index, since
1:          * a user is not allowed to drop a backing index without dropping
1:          * the constraint.
1:          */
1:         dd.dropConstraintDescriptor(this, tc);
1: 
1:         /* Drop the index, if there's one for this constraint.
1:          * NOTE: There will always be an indexAction. We don't
1:          * force the constraint to exist at bind time, so we always
1:          * generate one.
1:          */
1:         if (hasBackingIndex())
1:         {
1: 
1:             // it may have duplicates, and we drop a backing index
1:             // Bug 4307
1:             // We need to get the conglomerate descriptors from the 
1:             // dd in case we dropped other constraints in a cascade operation. 
0:              ConglomerateDescriptor[]conglomDescs =
0:                  dd.getConglomerateDescriptors(getConglomerateId());
1: 
0:             if (conglomDescs.length != 0)
1:             {
0:                 // Typically there is only one ConglomerateDescriptor
0:                 // for a given UUID, but due to an old bug
0:                 // there may be more than one. If there is more
0:                 // than one then which one is remvoed does not
0:                 // matter since they will all have the same critical
0:                 // information since they point to the same physical index.
0:                 for (int i = 0; i < conglomDescs.length; i++)
1:                 {
0:                     if (conglomDescs[i].isConstraint())
1:                     {
0:                         conglomDescs[i].drop(lcc, table);
1:                         break;
1:                     }
1:                 }
1:             }
1:         }
1: 
1:         table.removeConstraintDescriptor(this);
1:     }
commit:08d2c15
/////////////////////////////////////////////////////////////////////////
commit:71408ab
/////////////////////////////////////////////////////////////////////////
1: 			//When REVOKE_PRIVILEGE gets sent (this happens for privilege 
1: 			//types SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER), we  
1: 			//don't do anything here. Later in makeInvalid method, we make  
1: 			//the ConstraintDescriptor drop itself. 
/////////////////////////////////////////////////////////////////////////
1: 			//Notice that REVOKE_PRIVILEGE_RESTRICT is not caught earlier.
1: 		    //It gets handled in this default: action where an exception
1: 		    //will be thrown. This is because, if such an invalidation 
1: 		    //action type is ever received by a dependent, the dependent 
1: 		    //should throw an exception.
1: 			//In Derby, at this point, REVOKE_PRIVILEGE_RESTRICT gets sent
1: 		    //when execute privilege on a routine is getting revoked.
1: 		    //Currently, in Derby, a constraint can't depend on a routine 
1: 		    //and hence a REVOKE_PRIVILEGE_RESTRICT invalidation action
1: 		    //should never be received by a ConstraintDescriptor. But this
1: 		    //may change in future and when it does, the code to do the right
1: 		    //thing is already here.
/////////////////////////////////////////////////////////////////////////
1: 		/*
1: 		** For ConstraintDescriptor, SET_CONSTRAINTS/TRIGGERS and 
1: 		*  REVOKE_PRIVILEGE are the only valid actions
1: 		*/
1: 
0: 		//Let's handle REVOKE_PRIVILEGE first
1: 			//At this point (Derby 10.2), only a FOREIGN KEY key constraint can
/////////////////////////////////////////////////////////////////////////
1: 		** Now, handle SET_CONSTRAINTS/TRIGGERS
commit:f8fa8cf
/////////////////////////////////////////////////////////////////////////
0: 			//Notice that REVOKE_EXECUTE_PRIVILEGE is not included here.
0: 			//In Derby, at this point, a constraint can't depend on a 
0: 		    //routine and hence a REVOKE_EXECUTE_PRIVILEGE invalidation
0: 		    //action should never be received by a ConstraintDescriptor.
0: 		    //Don't know how, but if it ever happened for some mysterious
0: 		    //reason, it will be caught in the default: case.
1: 			//
0: 			//For all the other types of revoke privileges, for instance,
0: 			//SELECT, UPDATE, DELETE, INSERT, REFERENCES, TRIGGER, we don't 
0: 			//do anything here and later in makeInvalid, we make the 
0: 			//ConstraintDescriptor drop itself. 
/////////////////////////////////////////////////////////////////////////
0:     	//Notice that REVOKE_EXECUTE_PRIVILEGE is not included here.
0:     	//This is because, in Derby, at this point, a constraint can't 
0: 		//depend on a routine and hence a REVOKE_EXECUTE_PRIVILEGE 
0: 		//invalidation action should never be received by a 
0: 		//ConstraintDescriptor. Don't know how, but if it ever happened 
0: 		//for some mysterious reason, it will be caught in prepareToInvalidate 
0: 		//method
0: 			//At this point (Derby 10.2), only a foreign key constraint can
1: 			//depend on a privilege. None of the other constraint types 
1: 			//can be dependent on a privilege becuse those constraint types
1: 			//can not reference a table/routine.
commit:e87a9fd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.execute.DropConstraintConstantAction;
1: 
/////////////////////////////////////////////////////////////////////////
0: 			DropConstraintConstantAction.dropConstraintAndIndex(
0: 					getDataDictionary().getDependencyManager(),
0: 					table,
0: 					getDataDictionary(),
0: 					this,
0: 					lcc.getTransactionExecute(),
0: 					lcc, true);
commit:08313de
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				//for now, ignore revoke privilege action
1: 		    case DependencyManager.REVOKE_PRIVILEGE:
/////////////////////////////////////////////////////////////////////////
0: 		if (action == DependencyManager.REVOKE_PRIVILEGE) 
1: 		{
0: 			//for now, ignore revoke privilege action
1: 			return;
1: 		}
1: 
commit:4eece41
/////////////////////////////////////////////////////////////////////////
0: 	final String				constraintName;
0: 	private final boolean				deferrable;
0: 	private final boolean				initiallyDeferred;
1: 	private final int[]				referencedColumns;
1: 	final UUID					constraintId;
1: 	private final SchemaDescriptor	schemaDesc;
1: 	private ColumnDescriptorList	colDL;
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.StatementType;
1: import org.apache.derby.catalog.DependableFinder;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import	org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: /**
1:  * This class is used to get information from a ConstraintDescriptor.
1:  * A ConstraintDescriptor can represent a constraint on a table or on a
1:  * column.
1:  *
1:  * @version 0.1
0:  * @author Jeff Lichtman
1:  */
1: 
1: public abstract class ConstraintDescriptor 
0: 	extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Provider, Dependent
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	// used to indicate what type of constraints we 
1: 	// are interested in
1: 	public static final int ENABLED		= 1;
1: 	public static final int DISABLED	= 2;
1: 	public static final int ALL			= 3;
1: 
1: 	// field that we want users to be able to know about
1: 	public static final int SYSCONSTRAINTS_STATE_FIELD = 6;
1: 
0: 	TableDescriptor		table;
0: 	String				constraintName;
0: 	boolean				deferrable;
0: 	boolean				initiallyDeferred;
0: 	boolean				isEnabled;
0: 	int[]				referencedColumns;
0: 	UUID					constraintId;
0: 	SchemaDescriptor	schemaDesc;
0: 	ColumnDescriptorList	colDL;
1: 
1: 	/**
1: 	 * Constructor for a ConstraintDescriptor
1: 	 *
1: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
1: 	 * @param table		The descriptor of the table the constraint is on
1: 	 * @param constraintName	The name of the constraint.
1: 	 * @param deferrable		If the constraint can be deferred.
1: 	 * @param initiallyDeferred If the constraint starts life deferred.
1: 	 * @param referencedColumns columns that the constraint references
0: 	 * @param checkConstraint	the expression for a check constraint.
1: 	 * @param constraintId		UUID of constraint
1: 	 * @param schemaDesc		SchemaDescriptor
1: 	 */
1: 
1: 	ConstraintDescriptor(
1: 		    DataDictionary dataDictionary,
1: 			TableDescriptor table,
1: 			String constraintName,
1: 			boolean deferrable,
1: 			boolean initiallyDeferred,
1: 			int[] referencedColumns,
1: 			UUID constraintId,
1: 			SchemaDescriptor schemaDesc,
0: 			boolean isEnabled
1: 			)
1: 	{
1: 		super( dataDictionary );
1: 
1: 		this.table = table;
1: 		this.constraintName = constraintName;
1: 		this.deferrable = deferrable;
0: 		this.initiallyDeferred = initiallyDeferred;
1: 		this.referencedColumns = referencedColumns;
1: 		this.constraintId = constraintId;
1: 		this.schemaDesc = schemaDesc;
0: 		this.isEnabled = isEnabled;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Gets the UUID of the table the constraint is on.
1: 	 *
1: 	 * @return	The UUID of the table the constraint is on.
1: 	 */
1: 	public UUID	getTableId()
1: 	{
1: 		return table.getUUID();
1: 	}
1: 
1: 	/**
0: 	 * Sets the UUID of the constraint.
1: 	 *
0: 	 * @param constraintId	The constraint Id.
0: 	 * @return	Nothing.
1: 	 */
0: 	public void	setConstraintId(UUID constraintId)
1: 	{
1: 		this.constraintId = constraintId;
1: 	}
1: 
1: 	/**
1: 	 * Gets the UUID of the constraint.
1: 	 *
1: 	 * @return	The UUID of the constraint.
1: 	 */
1: 	public UUID	getUUID()
1: 	{
1: 		return constraintId;
1: 	}
1: 
1: 	/**
1: 	 * Gets the name of the constraint.
1: 	 *
1: 	 * @return	A String containing the name of the constraint.
1: 	 */
1: 	public String	getConstraintName()
1: 	{
1: 		return constraintName;
1: 	}
1: 
1: 	/**
1: 	 * Gets an identifier telling what type of descriptor it is
1: 	 * (UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
1: 	 *
1: 	 * @return	An identifier telling what type of descriptor it is
1: 	 *		(UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
1: 	 */
1: 	public abstract int	getConstraintType();
1: 
1: 	public abstract UUID getConglomerateId();
1: 
1: 	/**
1: 	 * Get the text of the constraint. (Only non-null/meaningful for check
1: 	 * constraints.)
1: 	 * @return	The constraint text.
1: 	 */
1: 	public String getConstraintText()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the constraint is deferrable
0: 	 * (we will probably not do deferrable constraints in the
0: 	 * initial release, but I want this to be part of the interface).
1: 	 *
0: 	 * @return	TRUE if the constraint is deferrable, FALSE if not
1: 	 */
0: 	public boolean	deferrable()
1: 	{
1: 		return deferrable;
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the constraint is initially deferred
0: 	 * (we will probably not do initially deferred constraints
0: 	 * in the initial release, but I want this to be part of the interface).
1: 	 *
0: 	 * @return	TRUE if the constraint is initially deferred,
0: 	 *		FALSE if not
1: 	 */
1: 	public boolean	initiallyDeferred()
1: 	{
0: 		return initiallyDeferred;
1: 	}
1: 
1: 	/**
1: 	 * Returns an array of column ids (i.e. ordinal positions) for
1: 	 * the columns referenced in this table for a primary key, unique
1: 	 * key, referential, or check constraint.
1: 	 *
1: 	 * @return	An array of column ids for those constraints that can
1: 	 *		be on columns (primary, unique key, referential
1: 	 *		constraints, and check constraints).  For check and
1: 	 *		unique constraints, it returns an array of columns ids
1: 	 *		that are referenced in the constraint.  For primary key
1: 	 *		and referential constraints, it returns an array of
1: 	 *		column ids for the columns in this table (i.e. the
1: 	 *		primary key columns for a primary key constraint,
1: 	 *		and the foreign key columns for a foreign key
1: 	 *		constraint.
1: 	 */
1: 	public int[]	getReferencedColumns()
1: 	{
0: 		return referencedColumns;
1: 	}
1: 
1: 	/**
1: 	 * Does this constraint have a backing index?
1: 	 *
1: 	 * @return boolean	Whether or not there is a backing index for this constraint.
1: 	 */
1: 	public abstract boolean hasBackingIndex();
1: 
1: 	/**
1: 	 * Get the SchemaDescriptor for the schema that this constraint
1: 	 * belongs to.
1: 	 *
1: 	 * @return SchemaDescriptor The SchemaDescriptor for this constraint.
1: 	 */
1: 	public SchemaDescriptor getSchemaDescriptor()
1: 	{
1: 		return schemaDesc;
1: 	}
1: 
1: 	/**
1: 	  RESOLVE: For now the ConstraintDescriptor code stores the array of key
1: 	  columns in the field 'otherColumns'. Jerry plans to re-organize things.
1: 	  For now to minimize his rototill I've implemented this function on the
1: 	  old structures. All new code should use getKeyColumns to get a constraint's
1: 	  key columns.
1: 	  
1: 	  @see org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor#getKeyColumns
1: 	  */
1: 	public int[]	getKeyColumns()
1: 	{
1: 		return getReferencedColumns();
1: 	}
1: 
1: 	/**
0: 	 * Is this constraint active?
1: 	 *
1: 	 * @return true/false
1: 	 */
0: 	public boolean isEnabled()
1: 	{
0: 		return isEnabled;
1: 	}
1: 
1: 	/**
0: 	 * Set the constraint to enabled.
0: 	 * Does not update the data dictionary
1: 	 */
0: 	public void setEnabled()
1: 	{
0: 		isEnabled = true;
1: 	}
1: 
1: 	/**
0: 	 * Set the constraint to disabled.
0: 	 * Does not update the data dictionary
1: 	 */
0: 	public void setDisabled()
1: 	{
0: 		isEnabled = false;
1: 	}
1: 
1: 	/**
1: 	 * Is this constraint referenced?  Return
1: 	 * false.  Overridden by ReferencedKeyConstraints.
1: 	 *
1: 	 * @return false
1: 	 */
1: 	public boolean isReferenced()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Get the number of enabled fks that
1: 	 * reference this key.  Overriden by
1: 	 * ReferencedKeyConstraints.
1: 	 *
1: 	 * @return the number of fks
1: 	 */
1: 	public int getReferenceCount()
1: 	{
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Does this constraint need to fire on this type of
1: 	 * DML?
1: 	 *
0: 	 * @param dmlType	the type of DML 
1: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
1: 	 * @param modifiedCols	the columns modified, or null for all
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	public abstract boolean needsToFire(int stmtType, int[] modifiedCols);
1: 
1: 	/**
1: 	 * Get the table descriptor upon which this constraint
1: 	 * is declared.
1: 	 *
1: 	 * @return the table descriptor
1: 	 */
1: 	public TableDescriptor getTableDescriptor()
1: 	{
1: 		return table;
1: 	}
1: 
1: 	/**
1: 	 * Get the column descriptors for all the columns
1: 	 * referenced by this constraint.
1: 	 *
1: 	 * @return the column descriptor list
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public ColumnDescriptorList getColumnDescriptors()
1: 		throws StandardException
1: 	{
1: 		if (colDL == null)
1: 		{
0: 			DataDictionary dd = getDataDictionary();
1: 			colDL = new ColumnDescriptorList();
1: 	
1: 			int[]	refCols = getReferencedColumns();
1: 			for (int i = 0; i < refCols.length; i++)
1: 			{
1: 				colDL.add(table.getColumnDescriptor(refCols[i]));
1: 			}
1: 		}
1: 		return colDL;
1: 	}
1: 
1: 	/**
1: 	 * Indicates whether the column descriptor list is
1: 	 * type comparable with the constraints columns.  The
1: 	 * types have to be identical AND in the same order 
1: 	 * to succeed.
1: 	 *
1: 	 * @param otherColumns the columns to compare
1: 	 *
1: 	 * @return true/false
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public boolean areColumnsComparable(ColumnDescriptorList otherColumns)
1: 		throws StandardException
1: 	{
1: 		ColumnDescriptor		myColumn;
1: 		ColumnDescriptor		otherColumn;
1: 
1: 		ColumnDescriptorList	myColDl = getColumnDescriptors();
1: 
1: 		/*
1: 		** Check the lenghts of the lists
1: 		*/
1: 		if (otherColumns.size() != myColDl.size())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		int mySize = myColDl.size();
1: 		int otherSize = otherColumns.size();
1: 		int index;
1: 		for (index = 0; index < mySize && index < otherSize; index++)
1: 		{
0: 			myColumn = (ColumnDescriptor) myColDl.elementAt(index);	
0: 			otherColumn = (ColumnDescriptor) otherColumns.elementAt(index);	
1: 
1: 			/*
1: 			** Just compare the types.  Note that this will
1: 	 		** say a decimal(x,y) != numeric(x,y) even though
1: 			** it does.
1: 			*/
1: 			if (!(myColumn.getType()).isExactTypeAndLengthMatch(
1: 					(otherColumn.getType())))
1: 			{
1: 				break;
1: 			}
1: 		}
1: 
1: 		return (index == mySize && index == otherSize);
1: 	}
1: 
1: 	/**
1: 	 * Does a column intersect with our referenced columns
0: 	 * @param int ColumnNumber
1: 	 * 
1: 	 * Note-- this is not a static method.
1: 	 */
1: 	public boolean columnIntersects(int columnArray[])
1: 	{
1: 		// call static method.
1: 		return doColumnsIntersect(getReferencedColumns(), columnArray);
1: 	}
1: 
1: 	/**
1: 	 * Does a column in the input set intersect with
1: 	 * our referenced columns?
1: 	 *
1: 	 * @param otherColumns the columns to compare. If
1: 	 *	null, asssumed to mean all columns
1: 	 *
0: 	 * @param the columns referenced by the caller
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	static boolean doColumnsIntersect(int[] otherColumns, int[] referencedColumns)
1: 	{
1: 		/*
1: 		** It is assumed that if otherColumns is null, then
1: 		** all other columns are modified.  In this case,
1: 		** it is assumed that it intersects with some column
1: 	 	** of ours, so just return true.
1: 		*/
1: 		if ((otherColumns == null) || (referencedColumns == null))
1: 		{
1: 			return true;
1: 		}
1: 
1: 		for (int outer = 0; outer < referencedColumns.length; outer++)
1: 		{	
1: 			for (int inner = 0; inner < otherColumns.length; inner++)
1: 			{
1: 				if (referencedColumns[outer] == otherColumns[inner])
1: 				{
1: 					return true;
1: 				}
1: 			}
1: 		}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Convert the ColumnDescriptor to a String.
1: 	 *
1: 	 * @return	A String representation of this ColumnDescriptor
1: 	 */
1: 
0: 	public String	toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			String tableDesc =
1: 				"table: " +
1: 				table.getQualifiedName() + "(" +
1: 				table.getUUID()+","+
1: 				table.getTableType()+")";
1: 
1: 			return tableDesc + "\n"+
1: 				"constraintName: " + constraintName + "\n" +
1: 				"constraintId: " + constraintId + "\n" +
1: 				"deferrable: " + deferrable + "\n" +
0: 				"initiallyDeferred: " + initiallyDeferred + "\n" +
0: 				"referencedColumns: " + referencedColumns + "\n" +
1: 				"schemaDesc: " + schemaDesc + "\n"
1: 				;
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////
1: 	//
1: 	// PROVIDER INTERFACE
1: 	//
1: 	////////////////////////////////////////////////////////////////////
1: 
1: 	/**		
1: 		@return the stored form of this provider
1: 
1: 			@see Dependable#getDependableFinder
1: 	 */
1: 	public DependableFinder getDependableFinder() 
1: 	{
1: 	    return	getDependableFinder(StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID);
1: 	}
1: 
1: 	/**
1: 	 * Return the name of this Provider.  (Useful for errors.)
1: 	 *
1: 	 * @return String	The name of this provider.
1: 	 */
1: 	public String getObjectName()
1: 	{
1: 		return constraintName;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's UUID
1: 	 *
1: 	 * @return 	The provider's UUID
1: 	 */
1: 	public UUID getObjectID()
1: 	{
1: 		return constraintId;
1: 	}
1: 
1: 	/**
1: 	 * Get the provider's type.
1: 	 *
1: 	 * @return char		The provider's type.
1: 	 */
1: 	public String getClassType()
1: 	{
1: 		return Dependable.CONSTRAINT;
1: 	}
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// DEPENDENT INTERFACE
1: 	//
1: 	//////////////////////////////////////////////////////
1: 	/**
1: 	 * Check that all of the dependent's dependencies are valid.
1: 	 *
1: 	 * @return true if the dependent is currently valid
1: 	 */
1: 	public synchronized boolean isValid()
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Prepare to mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).
1: 	 *
1: 	 * @param action	The action causing the invalidation
1: 	 * @param p		the provider
1: 	 *
1: 	 * @exception StandardException thrown if unable to make it invalid
1: 	 */
1: 	public void prepareToInvalidate(Provider p, int action,
1: 					LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		DependencyManager dm = getDataDictionary().getDependencyManager();
1: 
1: 		switch (action)
1: 		{
1: 			/*
1: 			** A SET CONSTRAINT stmt will throw an SET_CONSTRAINTS action
1: 			** when enabling/disabling constraints.  We'll ignore it.
1: 			** Same for SET TRIGGERS
1: 			*/
1: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
1: 		    case DependencyManager.SET_CONSTRAINTS_DISABLE:
1: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
1: 		    case DependencyManager.SET_TRIGGERS_DISABLE:
1: 				break;
1: 
1: 			/*
1: 			** Currently, the only thing we are depenedent
1: 			** on is another constraint or an alias..
1: 			*/
1: 		    default:
1: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
1: 									dm.getActionString(action), 
1: 									p.getObjectName(), "CONSTRAINT", constraintName);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark the dependent as invalid (due to at least one of
1: 	 * its dependencies being invalid).  Always an error
1: 	 * for a constraint -- should never have gotten here.
1: 	 *
1: 	 * @param	action	The action causing the invalidation
1: 	 *
1: 	 * @exception StandardException thrown if called in sanity mode
1: 	 */
1: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
1: 		throws StandardException
1: 	{
1: 		/*
0: 		** SET_CONSTRAINTS/TRIGGERS is the only valid action
1: 		*/
1: 		if ((action != DependencyManager.SET_CONSTRAINTS_DISABLE) &&
1: 			(action != DependencyManager.SET_CONSTRAINTS_ENABLE) &&
1: 			(action != DependencyManager.SET_TRIGGERS_ENABLE) &&
0: 			(action != DependencyManager.SET_TRIGGERS_DISABLE)
1: 		   )
1: 		{
1: 			/* 
1: 			** We should never get here, we should have barfed on 
1: 			** prepareToInvalidate().
1: 			*/
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				DependencyManager dm;
1: 		
1: 				dm = getDataDictionary().getDependencyManager();
1: 	
1: 				SanityManager.THROWASSERT("makeInvalid("+
1: 					dm.getActionString(action)+
1: 					") not expected to get called");
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0:      * Attempt to revalidate the dependent. Meaningless
0: 	 * for constraints.
1: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
1: 	{
1: 	}
1: 	
1: 	/** @see TupleDescriptor#getDescriptorName */
1: 	public String getDescriptorName() { return constraintName; }
1: 	
1: 	public String getDescriptorType() { return "Constraint"; }
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param stmtType	the type of DML 
/////////////////////////////////////////////////////////////////////////
1: 	 * @param columnArray columns to check
/////////////////////////////////////////////////////////////////////////
1: 	 * @param referencedColumns the columns referenced by the caller
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.catalog.DependableFinder;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Dependency;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import	org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: /**
0:  * This class is used to get information from a ConstraintDescriptor.
0:  * A ConstraintDescriptor can represent a constraint on a table or on a
0:  * column.
0:  *
0:  * @version 0.1
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class ConstraintDescriptor 
0: 	extends TupleDescriptor
0: 	implements UniqueTupleDescriptor, Provider, Dependent
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	// used to indicate what type of constraints we 
0: 	// are interested in
0: 	public static final int ENABLED		= 1;
0: 	public static final int DISABLED	= 2;
0: 	public static final int ALL			= 3;
0: 
0: 	// field that we want users to be able to know about
0: 	public static final int SYSCONSTRAINTS_STATE_FIELD = 6;
0: 
0: 	TableDescriptor		table;
0: 	String				constraintName;
0: 	boolean				deferrable;
0: 	boolean				initiallyDeferred;
0: 	boolean				isEnabled;
0: 	int[]				referencedColumns;
0: 	UUID					constraintId;
0: 	SchemaDescriptor	schemaDesc;
0: 	ColumnDescriptorList	colDL;
0: 
0: 	/**
0: 	 * Constructor for a ConstraintDescriptor
0: 	 *
0: 	 * @param dataDictionary		The data dictionary that this descriptor lives in
0: 	 * @param table		The descriptor of the table the constraint is on
0: 	 * @param constraintName	The name of the constraint.
0: 	 * @param deferrable		If the constraint can be deferred.
0: 	 * @param initiallyDeferred If the constraint starts life deferred.
0: 	 * @param referencedColumns columns that the constraint references
0: 	 * @param checkConstraint	the expression for a check constraint.
0: 	 * @param constraintId		UUID of constraint
0: 	 * @param schemaDesc		SchemaDescriptor
0: 	 */
0: 
0: 	ConstraintDescriptor(
0: 		    DataDictionary dataDictionary,
0: 			TableDescriptor table,
0: 			String constraintName,
0: 			boolean deferrable,
0: 			boolean initiallyDeferred,
0: 			int[] referencedColumns,
0: 			UUID constraintId,
0: 			SchemaDescriptor schemaDesc,
0: 			boolean isEnabled
0: 			)
0: 	{
0: 		super( dataDictionary );
0: 
0: 		this.table = table;
0: 		this.constraintName = constraintName;
0: 		this.deferrable = deferrable;
0: 		this.initiallyDeferred = initiallyDeferred;
0: 		this.referencedColumns = referencedColumns;
0: 		this.constraintId = constraintId;
0: 		this.schemaDesc = schemaDesc;
0: 		this.isEnabled = isEnabled;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Gets the UUID of the table the constraint is on.
0: 	 *
0: 	 * @return	The UUID of the table the constraint is on.
0: 	 */
0: 	public UUID	getTableId()
0: 	{
0: 		return table.getUUID();
0: 	}
0: 
0: 	/**
0: 	 * Sets the UUID of the constraint.
0: 	 *
0: 	 * @param constraintId	The constraint Id.
0: 	 * @return	Nothing.
0: 	 */
0: 	public void	setConstraintId(UUID constraintId)
0: 	{
0: 		this.constraintId = constraintId;
0: 	}
0: 
0: 	/**
0: 	 * Gets the UUID of the constraint.
0: 	 *
0: 	 * @return	The UUID of the constraint.
0: 	 */
0: 	public UUID	getUUID()
0: 	{
0: 		return constraintId;
0: 	}
0: 
0: 	/**
0: 	 * Gets the name of the constraint.
0: 	 *
0: 	 * @return	A String containing the name of the constraint.
0: 	 */
0: 	public String	getConstraintName()
0: 	{
0: 		return constraintName;
0: 	}
0: 
0: 	/**
0: 	 * Gets an identifier telling what type of descriptor it is
0: 	 * (UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
0: 	 *
0: 	 * @return	An identifier telling what type of descriptor it is
0: 	 *		(UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK).
0: 	 */
0: 	public abstract int	getConstraintType();
0: 
0: 	public abstract UUID getConglomerateId();
0: 
0: 	/**
0: 	 * Get the text of the constraint. (Only non-null/meaningful for check
0: 	 * constraints.)
0: 	 * @return	The constraint text.
0: 	 */
0: 	public String getConstraintText()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if the constraint is deferrable
0: 	 * (we will probably not do deferrable constraints in the
0: 	 * initial release, but I want this to be part of the interface).
0: 	 *
0: 	 * @return	TRUE if the constraint is deferrable, FALSE if not
0: 	 */
0: 	public boolean	deferrable()
0: 	{
0: 		return deferrable;
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if the constraint is initially deferred
0: 	 * (we will probably not do initially deferred constraints
0: 	 * in the initial release, but I want this to be part of the interface).
0: 	 *
0: 	 * @return	TRUE if the constraint is initially deferred,
0: 	 *		FALSE if not
0: 	 */
0: 	public boolean	initiallyDeferred()
0: 	{
0: 		return initiallyDeferred;
0: 	}
0: 
0: 	/**
0: 	 * Returns an array of column ids (i.e. ordinal positions) for
0: 	 * the columns referenced in this table for a primary key, unique
0: 	 * key, referential, or check constraint.
0: 	 *
0: 	 * @return	An array of column ids for those constraints that can
0: 	 *		be on columns (primary, unique key, referential
0: 	 *		constraints, and check constraints).  For check and
0: 	 *		unique constraints, it returns an array of columns ids
0: 	 *		that are referenced in the constraint.  For primary key
0: 	 *		and referential constraints, it returns an array of
0: 	 *		column ids for the columns in this table (i.e. the
0: 	 *		primary key columns for a primary key constraint,
0: 	 *		and the foreign key columns for a foreign key
0: 	 *		constraint.
0: 	 */
0: 	public int[]	getReferencedColumns()
0: 	{
0: 		return referencedColumns;
0: 	}
0: 
0: 	/**
0: 	 * Does this constraint have a backing index?
0: 	 *
0: 	 * @return boolean	Whether or not there is a backing index for this constraint.
0: 	 */
0: 	public abstract boolean hasBackingIndex();
0: 
0: 	/**
0: 	 * Get the SchemaDescriptor for the schema that this constraint
0: 	 * belongs to.
0: 	 *
0: 	 * @return SchemaDescriptor The SchemaDescriptor for this constraint.
0: 	 */
0: 	public SchemaDescriptor getSchemaDescriptor()
0: 	{
0: 		return schemaDesc;
0: 	}
0: 
0: 	/**
0: 	  RESOLVE: For now the ConstraintDescriptor code stores the array of key
0: 	  columns in the field 'otherColumns'. Jerry plans to re-organize things.
0: 	  For now to minimize his rototill I've implemented this function on the
0: 	  old structures. All new code should use getKeyColumns to get a constraint's
0: 	  key columns.
0: 	  
0: 	  @see org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor#getKeyColumns
0: 	  */
0: 	public int[]	getKeyColumns()
0: 	{
0: 		return getReferencedColumns();
0: 	}
0: 
0: 	/**
0: 	 * Is this constraint active?
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isEnabled()
0: 	{
0: 		return isEnabled;
0: 	}
0: 
0: 	/**
0: 	 * Set the constraint to enabled.
0: 	 * Does not update the data dictionary
0: 	 */
0: 	public void setEnabled()
0: 	{
0: 		isEnabled = true;
0: 	}
0: 
0: 	/**
0: 	 * Set the constraint to disabled.
0: 	 * Does not update the data dictionary
0: 	 */
0: 	public void setDisabled()
0: 	{
0: 		isEnabled = false;
0: 	}
0: 
0: 	/**
0: 	 * Is this constraint referenced?  Return
0: 	 * false.  Overridden by ReferencedKeyConstraints.
0: 	 *
0: 	 * @return false
0: 	 */
0: 	public boolean isReferenced()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Get the number of enabled fks that
0: 	 * reference this key.  Overriden by
0: 	 * ReferencedKeyConstraints.
0: 	 *
0: 	 * @return the number of fks
0: 	 */
0: 	public int getReferenceCount()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Does this constraint need to fire on this type of
0: 	 * DML?
0: 	 *
0: 	 * @param dmlType	the type of DML 
0: 	 * (StatementType.INSERT|StatementType.UPDATE|StatementType.DELETE)
0: 	 * @param modifiedCols	the columns modified, or null for all
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public abstract boolean needsToFire(int stmtType, int[] modifiedCols);
0: 
0: 	/**
0: 	 * Get the table descriptor upon which this constraint
0: 	 * is declared.
0: 	 *
0: 	 * @return the table descriptor
0: 	 */
0: 	public TableDescriptor getTableDescriptor()
0: 	{
0: 		return table;
0: 	}
0: 
0: 	/**
0: 	 * Get the column descriptors for all the columns
0: 	 * referenced by this constraint.
0: 	 *
0: 	 * @return the column descriptor list
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ColumnDescriptorList getColumnDescriptors()
0: 		throws StandardException
0: 	{
0: 		if (colDL == null)
0: 		{
0: 			DataDictionary dd = getDataDictionary();
0: 			colDL = new ColumnDescriptorList();
0: 	
0: 			int[]	refCols = getReferencedColumns();
0: 			for (int i = 0; i < refCols.length; i++)
0: 			{
0: 				colDL.add(table.getColumnDescriptor(refCols[i]));
0: 			}
0: 		}
0: 		return colDL;
0: 	}
0: 
0: 	/**
0: 	 * Indicates whether the column descriptor list is
0: 	 * type comparable with the constraints columns.  The
0: 	 * types have to be identical AND in the same order 
0: 	 * to succeed.
0: 	 *
0: 	 * @param otherColumns the columns to compare
0: 	 *
0: 	 * @return true/false
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public boolean areColumnsComparable(ColumnDescriptorList otherColumns)
0: 		throws StandardException
0: 	{
0: 		ColumnDescriptor		myColumn;
0: 		ColumnDescriptor		otherColumn;
0: 
0: 		ColumnDescriptorList	myColDl = getColumnDescriptors();
0: 
0: 		/*
0: 		** Check the lenghts of the lists
0: 		*/
0: 		if (otherColumns.size() != myColDl.size())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		int mySize = myColDl.size();
0: 		int otherSize = otherColumns.size();
0: 		int index;
0: 		for (index = 0; index < mySize && index < otherSize; index++)
0: 		{
0: 			myColumn = (ColumnDescriptor) myColDl.elementAt(index);	
0: 			otherColumn = (ColumnDescriptor) otherColumns.elementAt(index);	
0: 
0: 			/*
0: 			** Just compare the types.  Note that this will
0: 	 		** say a decimal(x,y) != numeric(x,y) even though
0: 			** it does.
0: 			*/
0: 			if (!(myColumn.getType()).isExactTypeAndLengthMatch(
0: 					(otherColumn.getType())))
0: 			{
0: 				break;
0: 			}
0: 		}
0: 
0: 		return (index == mySize && index == otherSize);
0: 	}
0: 
0: 	/**
0: 	 * Does a column intersect with our referenced columns
0: 	 * @param int ColumnNumber
0: 	 * 
0: 	 * Note-- this is not a static method.
0: 	 */
0: 	public boolean columnIntersects(int columnArray[])
0: 	{
0: 		// call static method.
0: 		return doColumnsIntersect(getReferencedColumns(), columnArray);
0: 	}
0: 
0: 	/**
0: 	 * Does a column in the input set intersect with
0: 	 * our referenced columns?
0: 	 *
0: 	 * @param otherColumns the columns to compare. If
0: 	 *	null, asssumed to mean all columns
0: 	 *
0: 	 * @param the columns referenced by the caller
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	static boolean doColumnsIntersect(int[] otherColumns, int[] referencedColumns)
0: 	{
0: 		/*
0: 		** It is assumed that if otherColumns is null, then
0: 		** all other columns are modified.  In this case,
0: 		** it is assumed that it intersects with some column
0: 	 	** of ours, so just return true.
0: 		*/
0: 		if ((otherColumns == null) || (referencedColumns == null))
0: 		{
0: 			return true;
0: 		}
0: 
0: 		for (int outer = 0; outer < referencedColumns.length; outer++)
0: 		{	
0: 			for (int inner = 0; inner < otherColumns.length; inner++)
0: 			{
0: 				if (referencedColumns[outer] == otherColumns[inner])
0: 				{
0: 					return true;
0: 				}
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Convert the ColumnDescriptor to a String.
0: 	 *
0: 	 * @return	A String representation of this ColumnDescriptor
0: 	 */
0: 
0: 	public String	toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			String tableDesc =
0: 				"table: " +
0: 				table.getQualifiedName() + "(" +
0: 				table.getUUID()+","+
0: 				table.getTableType()+")";
0: 
0: 			return tableDesc + "\n"+
0: 				"constraintName: " + constraintName + "\n" +
0: 				"constraintId: " + constraintId + "\n" +
0: 				"deferrable: " + deferrable + "\n" +
0: 				"initiallyDeferred: " + initiallyDeferred + "\n" +
0: 				"referencedColumns: " + referencedColumns + "\n" +
0: 				"schemaDesc: " + schemaDesc + "\n"
0: 				;
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////
0: 	//
0: 	// PROVIDER INTERFACE
0: 	//
0: 	////////////////////////////////////////////////////////////////////
0: 
0: 	/**		
0: 		@return the stored form of this provider
0: 
0: 			@see Dependable#getDependableFinder
0: 	 */
0: 	public DependableFinder getDependableFinder() 
0: 	{
0: 	    return	getDependableFinder(StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID);
0: 	}
0: 
0: 	/**
0: 	 * Return the name of this Provider.  (Useful for errors.)
0: 	 *
0: 	 * @return String	The name of this provider.
0: 	 */
0: 	public String getObjectName()
0: 	{
0: 		return constraintName;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's UUID
0: 	 *
0: 	 * @return 	The provider's UUID
0: 	 */
0: 	public UUID getObjectID()
0: 	{
0: 		return constraintId;
0: 	}
0: 
0: 	/**
0: 	 * Get the provider's type.
0: 	 *
0: 	 * @return char		The provider's type.
0: 	 */
0: 	public String getClassType()
0: 	{
0: 		return Dependable.CONSTRAINT;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////
0: 	//
0: 	// DEPENDENT INTERFACE
0: 	//
0: 	//////////////////////////////////////////////////////
0: 	/**
0: 	 * Check that all of the dependent's dependencies are valid.
0: 	 *
0: 	 * @return true if the dependent is currently valid
0: 	 */
0: 	public synchronized boolean isValid()
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Prepare to mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).
0: 	 *
0: 	 * @param action	The action causing the invalidation
0: 	 * @param p		the provider
0: 	 *
0: 	 * @exception StandardException thrown if unable to make it invalid
0: 	 */
0: 	public void prepareToInvalidate(Provider p, int action,
0: 					LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		DependencyManager dm = getDataDictionary().getDependencyManager();
0: 
0: 		switch (action)
0: 		{
0: 			/*
0: 			** A SET CONSTRAINT stmt will throw an SET_CONSTRAINTS action
0: 			** when enabling/disabling constraints.  We'll ignore it.
0: 			** Same for SET TRIGGERS
0: 			*/
0: 		    case DependencyManager.SET_CONSTRAINTS_ENABLE:
0: 		    case DependencyManager.SET_CONSTRAINTS_DISABLE:
0: 		    case DependencyManager.SET_TRIGGERS_ENABLE:
0: 		    case DependencyManager.SET_TRIGGERS_DISABLE:
0: 				break;
0: 
0: 			/*
0: 			** Currently, the only thing we are depenedent
0: 			** on is another constraint or an alias..
0: 			*/
0: 		    default:
0: 				throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT, 
0: 									dm.getActionString(action), 
0: 									p.getObjectName(), "CONSTRAINT", constraintName);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark the dependent as invalid (due to at least one of
0: 	 * its dependencies being invalid).  Always an error
0: 	 * for a constraint -- should never have gotten here.
0: 	 *
0: 	 * @param	action	The action causing the invalidation
0: 	 *
0: 	 * @exception StandardException thrown if called in sanity mode
0: 	 */
0: 	public void makeInvalid(int action, LanguageConnectionContext lcc) 
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** SET_CONSTRAINTS/TRIGGERS is the only valid action
0: 		*/
0: 		if ((action != DependencyManager.SET_CONSTRAINTS_DISABLE) &&
0: 			(action != DependencyManager.SET_CONSTRAINTS_ENABLE) &&
0: 			(action != DependencyManager.SET_TRIGGERS_ENABLE) &&
0: 			(action != DependencyManager.SET_TRIGGERS_DISABLE)
0: 		   )
0: 		{
0: 			/* 
0: 			** We should never get here, we should have barfed on 
0: 			** prepareToInvalidate().
0: 			*/
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				DependencyManager dm;
0: 		
0: 				dm = getDataDictionary().getDependencyManager();
0: 	
0: 				SanityManager.THROWASSERT("makeInvalid("+
0: 					dm.getActionString(action)+
0: 					") not expected to get called");
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0:      * Attempt to revalidate the dependent. Meaningless
0: 	 * for constraints.
0: 	 */
0: 	public void makeValid(LanguageConnectionContext lcc) 
0: 	{
0: 	}
0: 	
0: 	/** @see TupleDescriptor#getDescriptorName */
0: 	public String getDescriptorName() { return constraintName; }
0: 	
0: 	public String getDescriptorType() { return "Constraint"; }
0: }
============================================================================