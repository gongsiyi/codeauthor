2:eac0369: /*
9:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.HeapRowLocation
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:fa09146: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:fa09146: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: import org.apache.derby.iapi.services.io.CompressedNumber;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:fa09146: import org.apache.derby.iapi.store.raw.RecordHandle;
1:fa09146: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataType;
1:fa09146: import org.apache.derby.iapi.types.DataValueDescriptor;
1:6ab1083: import org.apache.derby.iapi.types.RefDataValue;
1:fa09146: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
3:eac0369: /**
1:fa09146:  * A heap row location represents the location of a row in the heap.
1:fa09146:  * <P>
1:fa09146:  * It is implementad as a wrapper around a raw store record handle.
1:fa09146:  * 
1:787ceb4:  * @derby.formatId ACCESS_HEAP_ROW_LOCATION_V1_ID
1:eac0369:  *
1:787ceb4:  * @derby.purpose   Object used to store the location of a row within a Heap table.  
1:eac0369:  *            One of these is stored in every row of a btree secondary index 
1:eac0369:  *            built on a heap base table.
1:eac0369:  *
1:787ceb4:  * @derby.upgrade   The type of the btree determines the type of rowlocation stored.
1:eac0369:  *            In current btree implementations only one type of rowlocation can
1:eac0369:  *            be stored per tree, and it's type is stored in the format id 
1:eac0369:  *            array stored in the Conglomerate object.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout 
1:eac0369:  *     page number(CompressedNumber.writeLong())
1:eac0369:  *     record id(CompressedNumber.writeInt())
2:eac0369:  **/
1:eac0369: 
1:6ab1083: public class HeapRowLocation extends DataType implements RowLocation, RefDataValue
2:eac0369: {
1:eac0369: 	/**
1:eac0369: 	The HeapRowLocation simply maintains a raw store record handle.
1:eac0369: 	**/
1:eac0369:     private long         pageno;
1:eac0369:     private int          recid;
1:eac0369: 	private RecordHandle rh;
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( HeapRowLocation.class);
1:eac0369:     private static final int RECORD_HANDLE_MEMORY_USAGE
1:eac0369:     = ClassSize.estimateBaseFromCatalog( org.apache.derby.impl.store.raw.data.RecordId.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac0369:         int sz = BASE_MEMORY_USAGE;
1:eac0369: 
1:eac0369:         if( null != rh)
1:eac0369:             sz += RECORD_HANDLE_MEMORY_USAGE;
1:eac0369:         return sz;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369: 	public String getTypeName() {
1:eac0369: 		return "RowLocation";
3:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValueFromResultSet(java.sql.ResultSet resultSet, int colNumber,
1:eac0369: 		boolean isNullable) {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public DataValueDescriptor getNewNull() {
1:2700e3d: 		return new HeapRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object getObject() {
1:508a010: 		return this;
1:eac0369: 	}
1:eac0369: 
1:854dd10: 	public DataValueDescriptor cloneValue(boolean forceMaterialization) {
1:eac0369: 		return new HeapRowLocation(this);
1:eac0369: 	}
1:eac0369: 
1:109cb26:     /**
1:109cb26:      * Recycle this HeapRowLocation object.
1:109cb26:      *
1:109cb26:      * @return this object reset to its initial state
1:109cb26:      */
1:109cb26:     public DataValueDescriptor recycle() {
1:109cb26:         pageno = 0L;
1:109cb26:         recid = 0;
1:109cb26:         rh = null;
1:109cb26:         return this;
1:109cb26:     }
1:109cb26: 
1:eac0369: 	public int getLength() {
1:eac0369: 		return 10;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getString() {
1:eac0369: 		return toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Orderable (from RowLocation)
1:eac0369: 	**
1:eac0369: 	** see description in
1:eac0369: 	** protocol/Database/Storage/Access/Interface/Orderable.java 
1:eac0369: 	**
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 	{
1:eac0369: 		// HeapRowLocation should not be null, ignore orderedNulls
1:eac0369: 		int result = compare(other);
1:eac0369: 
1:eac0369: 		switch(op)
1:eac0369: 		{
1:eac0369: 		case ORDER_OP_LESSTHAN:
1:eac0369: 			return (result < 0); // this < other
1:eac0369: 		case ORDER_OP_EQUALS:
1:eac0369: 			return (result == 0);  // this == other
1:eac0369: 		case ORDER_OP_LESSOREQUALS:
1:eac0369: 			return (result <= 0);  // this <= other
1:eac0369: 		default:
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.THROWASSERT("Unexpected operation");
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int compare(DataValueDescriptor other)
1:eac0369: 	{
1:eac0369: 		// REVISIT: do we need this check?
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(other instanceof HeapRowLocation);
1:eac0369: 
1:eac0369: 		HeapRowLocation arg = (HeapRowLocation) other;
1:eac0369: 		
1:eac0369: 		// XXX (nat) assumption is that these HeapRowLocations are
1:eac0369: 		// never null.  However, if they ever become null, need
1:eac0369: 		// to add null comparison logic.
1:eac0369:         //
1:eac0369:         // RESOLVE - change these to be state based
1:eac0369:         /*
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(getRecordHandle() != null);
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(arg.getRecordHandle() != null);
1:eac0369:         */
1:eac0369: 
1:eac0369: 		long myPage     = this.pageno;
1:eac0369: 		long otherPage  = arg.pageno;
1:eac0369: 
1:eac0369: 		if (myPage < otherPage)
1:eac0369: 			return -1;
1:eac0369: 		else if (myPage > otherPage)
1:eac0369: 			return 1;
1:eac0369: 
1:eac0369: 		int myRecordId      = this.recid;
1:eac0369: 		int otherRecordId   = arg.recid;
1:eac0369: 
1:eac0369: 		if (myRecordId == otherRecordId)
1:eac0369: 			return 0;
1:eac0369: 		else if (myRecordId < otherRecordId)
1:eac0369: 			return -1;
1:eac0369: 		else
1:eac0369: 			return 1;
1:eac0369: 	}
1:eac0369: 
1:6ab1083:     public  void    setValue( RowLocation rowLocation )
1:6ab1083:     {
1:6ab1083:         HeapRowLocation hrl = (HeapRowLocation) rowLocation;
1:6ab1083: 
1:6ab1083:         setFrom( hrl.rh );
1:6ab1083:     }
1:6ab1083: 
1:eac0369: 	/*
1:eac0369: 	** Methods of HeapRowLocation
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	HeapRowLocation(RecordHandle rh)
1:eac0369: 	{
1:eac0369: 		setFrom(rh);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public HeapRowLocation()
1:eac0369: 	{
1:eac0369:         this.pageno = 0; 
1:eac0369:         this.recid  = RecordHandle.INVALID_RECORD_HANDLE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* For cloning */
1:eac0369: 	private HeapRowLocation(HeapRowLocation other)
1:eac0369: 	{
1:eac0369: 		this.pageno = other.pageno;
1:eac0369: 		this.recid = other.recid;
1:eac0369: 		this.rh = other.rh;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public RecordHandle getRecordHandle(ContainerHandle ch)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (rh != null)
1:eac0369: 			return rh;
1:eac0369: 
1:eac0369: 		return rh = ch.makeRecordHandle(this.pageno, this.recid);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void setFrom(RecordHandle rh)
1:eac0369: 	{
1:eac0369:         this.pageno = rh.getPageNumber();
1:eac0369:         this.recid  = rh.getId();
1:eac0369: 		this.rh = rh;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//public void setFrom(long pageno, int recid)
1:eac0369: 	//{
1:eac0369:     //    this.pageno = pageno;
1:eac0369:     //    this.recid  = recid;
1:eac0369: 	//}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * InternalRowLocation interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return a RecordHandle built from current RowLocation.
1:eac0369:      * <p>
1:eac0369:      * Build a RecordHandle from the current RowLocation.  The main client
1:eac0369:      * of this interface is row level locking secondary indexes which read
1:eac0369:      * the RowLocation field from a secondary index row, and then need a
1:eac0369:      * RecordHandle built from this RowLocation.
1:eac0369:      * <p>
1:eac0369:      * The interface is not as generic as one may have wanted in order to
1:eac0369:      * store as compressed a version of a RowLocation as possible.  So 
1:eac0369:      * if an implementation of a RowLocation does not have the segmentid, 
1:eac0369:      * and containerid stored, use the input parameters instead.  If the
1:eac0369:      * RowLocation does have the values stored use them and ignore the
1:eac0369:      * input parameters.
1:eac0369:      * <p>
1:eac0369:      * Example:
1:eac0369:      * <p>
1:eac0369:      * The HeapRowLocation implementation of RowLocation generated by the 
1:eac0369:      * Heap class, only stores the page and record id.  The B2I conglomerate
1:eac0369:      * implements a secondary index on top of a Heap class.  B2I knows the
1:eac0369:      * segmentid and containerid of it's base table, and knows that it can
1:eac0369:      * find an InternalRowLocation in a particular column of it's rows.  It
1:eac0369:      * uses InternalRowLocation.getRecordHandle() to build a RecordHandle
1:eac0369:      * from the InternalRowLocation, and uses it to set a row lock on that
1:eac0369:      * row in the btree.
1:eac0369:      *
1:eac0369: 	 * @return The newly allocated RecordHandle.
1:eac0369:      *
1:eac0369:      * @param segmentid     The segment id to store in RecordHandle.
1:eac0369:      * @param containerid   The segment id to store in RecordHandle.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     /*public RecordHandle getRecordHandle(
1:eac0369:     TransactionManager   tran,
1:eac0369:     long                 segmentid,
1:eac0369:     long                 containerid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(
1:eac0369:             this.getRecordHandle(
1:eac0369:                 tran.getRawStoreXact(), segmentid, containerid));
1:eac0369:     }
1:eac0369: */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public boolean isNull()
1:eac0369:     {
1:eac0369:         return false;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public void writeExternal(ObjectOutput out) 
1:eac0369:         throws IOException
1:eac0369:     {
1:eac0369:         // Write the page number, compressed
1:eac0369:         CompressedNumber.writeLong(out, this.pageno);
1:eac0369: 
1:eac0369:         // Write the record id
1:eac0369:         CompressedNumber.writeInt(out, this.recid);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @exception java.lang.ClassNotFoundException A class needed to read the
1:eac0369: 	  stored form of this object could not be found.
1:eac0369: 	  @see java.io.Externalizable#readExternal
1:eac0369: 	  */
1:eac0369: 	public void readExternal(ObjectInput in) 
1:eac0369:         throws IOException, ClassNotFoundException
1:eac0369:     {
1:eac0369:         this.pageno = CompressedNumber.readLong(in);
1:eac0369: 
1:eac0369:         this.recid  = CompressedNumber.readInt(in);
1:eac0369: 
1:eac0369: 		rh = null;
1:eac0369:     }
1:eac0369: 	public void readExternalFromArray(ArrayInputStream in) 
1:eac0369:         throws IOException, ClassNotFoundException
1:eac0369:     {
1:eac0369:         this.pageno = in.readCompressedLong();
1:eac0369: 
1:eac0369:         this.recid  = in.readCompressedInt();
1:eac0369: 
1:eac0369: 		rh = null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public void restoreToNull()
1:eac0369:     {
1:eac0369: 		if (SanityManager.DEBUG) 
1:eac0369: 			SanityManager.THROWASSERT("HeapRowLocation is never null");
1:eac0369:     }
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue)  {
1:eac0369:         if (SanityManager.DEBUG)
1:86e051f:             SanityManager.ASSERT(theValue instanceof HeapRowLocation,
1:86e051f:                     "Should only be set from another HeapRowLocation");
1:86e051f:         HeapRowLocation that = (HeapRowLocation) theValue;
1:86e051f:         this.pageno = that.pageno;
1:86e051f:         this.recid = that.recid;
1:86e051f:         this.rh = that.rh;
1:eac0369: 	}
1:eac0369: 	/*
1:eac0369: 	**		Methods of Object
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Implement value equality.
1:eac0369: 		<BR>
1:eac0369: 		MT - Thread safe
1:eac0369: 	*/
1:eac0369: 	public boolean equals(Object ref) 
1:eac0369:     {
1:eac0369: 
1:eac0369: 		if ((ref instanceof HeapRowLocation))
1:eac0369:         {
1:eac0369:             HeapRowLocation other = (HeapRowLocation) ref;
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 (this.pageno == other.pageno) && (this.recid == other.recid));
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369: 			return false;
1:eac0369:         }
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a hashcode based on value.
1:eac0369: 		<BR>
1:eac0369: 		MT - thread safe
1:eac0369: 	*/
1:eac0369: 	public int hashCode() 
1:eac0369:     {
1:eac0369: 		return ((int) this.pageno) ^ this.recid;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /*
1:eac0369:      * Standard toString() method.
1:eac0369:      */
1:eac0369:     public String toString()
1:eac0369:     {
1:eac0369:         String string = 
1:eac0369:            "(" + this.pageno + "," + this.recid + ")";
1:eac0369:         return(string);
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.RefDataValue;
/////////////////////////////////////////////////////////////////////////
1: public class HeapRowLocation extends DataType implements RowLocation, RefDataValue
/////////////////////////////////////////////////////////////////////////
1:     public  void    setValue( RowLocation rowLocation )
1:     {
1:         HeapRowLocation hrl = (HeapRowLocation) rowLocation;
1: 
1:         setFrom( hrl.rh );
1:     }
1: 
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: 		return this;
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_HEAP_ROW_LOCATION_V1_ID
1:  * @derby.purpose   Object used to store the location of a row within a Heap table.  
1:  * @derby.upgrade   The type of the btree determines the type of rowlocation stored.
1:  * @derby.diskLayout 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization) {
commit:a8bc217
/////////////////////////////////////////////////////////////////////////
commit:fa09146
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
1:  * A heap row location represents the location of a row in the heap.
1:  * <P>
1:  * It is implementad as a wrapper around a raw store record handle.
1:  * 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86e051f
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(theValue instanceof HeapRowLocation,
1:                     "Should only be set from another HeapRowLocation");
1:         HeapRowLocation that = (HeapRowLocation) theValue;
1:         this.pageno = that.pageno;
1:         this.recid = that.recid;
1:         this.rh = that.rh;
commit:109cb26
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Recycle this HeapRowLocation object.
1:      *
1:      * @return this object reset to its initial state
1:      */
1:     public DataValueDescriptor recycle() {
1:         pageno = 0L;
1:         recid = 0;
1:         rh = null;
1:         return this;
1:     }
1: 
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 		return new HeapRowLocation();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapRowLocation
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: /**
1: 
0:   A heap row location represents the location of a row in the heap.
0:   <P>
0:   It's implementad as a wrapper around a raw store record handle.
1: 
1: **/
1: 
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.CompressedNumber;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
1: import org.apache.derby.iapi.types.DataType;
1: 
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: /**
0:  * @format_id ACCESS_HEAP_ROW_LOCATION_V1_ID
1:  *
0:  * @purpose   Object used to store the location of a row within a Heap table.  
1:  *            One of these is stored in every row of a btree secondary index 
1:  *            built on a heap base table.
1:  *
0:  * @upgrade   The type of the btree determines the type of rowlocation stored.
1:  *            In current btree implementations only one type of rowlocation can
1:  *            be stored per tree, and it's type is stored in the format id 
1:  *            array stored in the Conglomerate object.
1:  *
0:  * @disk_layout 
1:  *     page number(CompressedNumber.writeLong())
1:  *     record id(CompressedNumber.writeInt())
1:  **/
1: 
0: public class HeapRowLocation extends DataType implements RowLocation
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	The HeapRowLocation simply maintains a raw store record handle.
1: 	**/
1:     private long         pageno;
1:     private int          recid;
1: 	private RecordHandle rh;
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( HeapRowLocation.class);
1:     private static final int RECORD_HANDLE_MEMORY_USAGE
1:     = ClassSize.estimateBaseFromCatalog( org.apache.derby.impl.store.raw.data.RecordId.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         int sz = BASE_MEMORY_USAGE;
1: 
1:         if( null != rh)
1:             sz += RECORD_HANDLE_MEMORY_USAGE;
1:         return sz;
1:     } // end of estimateMemoryUsage
1: 
1: 	public String getTypeName() {
1: 		return "RowLocation";
1: 	}
1: 
1: 	public void setValueFromResultSet(java.sql.ResultSet resultSet, int colNumber,
1: 		boolean isNullable) {
1: 	}
1: 
1: 	public DataValueDescriptor getNewNull() {
0: 		return null;
1: 	}
0: 	public void setValue(Object o) {
1: 	}
1: 
1: 	public Object getObject() {
0: 		return null;
1: 	}
1: 
1: 	/*
0: 	** Methods of CloneableObject.
1: 	*/
0: 	public Object cloneObject()
1: 	{
0: 		return getClone();
1: 		
1: 	}
1: 
0: 	public DataValueDescriptor getClone() {
1: 		return new HeapRowLocation(this);
1: 	}
1: 
1: 	public int getLength() {
1: 		return 10;
1: 	}
1: 
1: 	public String getString() {
1: 		return toString();
1: 	}
1: 
1: 	/*
1: 	** Methods of Orderable (from RowLocation)
1: 	**
1: 	** see description in
1: 	** protocol/Database/Storage/Access/Interface/Orderable.java 
1: 	**
1: 	*/
1: 
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 	{
1: 		// HeapRowLocation should not be null, ignore orderedNulls
1: 		int result = compare(other);
1: 
1: 		switch(op)
1: 		{
1: 		case ORDER_OP_LESSTHAN:
1: 			return (result < 0); // this < other
1: 		case ORDER_OP_EQUALS:
1: 			return (result == 0);  // this == other
1: 		case ORDER_OP_LESSOREQUALS:
1: 			return (result <= 0);  // this <= other
1: 		default:
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.THROWASSERT("Unexpected operation");
1: 			return false;
1: 		}
1: 	}
1: 
1: 	public int compare(DataValueDescriptor other)
1: 	{
1: 		// REVISIT: do we need this check?
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(other instanceof HeapRowLocation);
1: 
1: 		HeapRowLocation arg = (HeapRowLocation) other;
1: 		
1: 		// XXX (nat) assumption is that these HeapRowLocations are
1: 		// never null.  However, if they ever become null, need
1: 		// to add null comparison logic.
1:         //
1:         // RESOLVE - change these to be state based
1:         /*
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(getRecordHandle() != null);
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(arg.getRecordHandle() != null);
1:         */
1: 
1: 		long myPage     = this.pageno;
1: 		long otherPage  = arg.pageno;
1: 
1: 		if (myPage < otherPage)
1: 			return -1;
1: 		else if (myPage > otherPage)
1: 			return 1;
1: 
1: 		int myRecordId      = this.recid;
1: 		int otherRecordId   = arg.recid;
1: 
1: 		if (myRecordId == otherRecordId)
1: 			return 0;
1: 		else if (myRecordId < otherRecordId)
1: 			return -1;
1: 		else
1: 			return 1;
1: 	}
1: 
1: 	/*
1: 	** Methods of HeapRowLocation
1: 	*/
1: 
1: 	HeapRowLocation(RecordHandle rh)
1: 	{
1: 		setFrom(rh);
1: 	}
1: 
1: 	public HeapRowLocation()
1: 	{
1:         this.pageno = 0; 
1:         this.recid  = RecordHandle.INVALID_RECORD_HANDLE;
1: 	}
1: 
1: 	/* For cloning */
1: 	private HeapRowLocation(HeapRowLocation other)
1: 	{
1: 		this.pageno = other.pageno;
1: 		this.recid = other.recid;
1: 		this.rh = other.rh;
1: 	}
1: 
1: 	public RecordHandle getRecordHandle(ContainerHandle ch)
1:         throws StandardException
1: 	{
1: 		if (rh != null)
1: 			return rh;
1: 
1: 		return rh = ch.makeRecordHandle(this.pageno, this.recid);
1: 	}
1: 
1: 	void setFrom(RecordHandle rh)
1: 	{
1:         this.pageno = rh.getPageNumber();
1:         this.recid  = rh.getId();
1: 		this.rh = rh;
1: 	}
1: 
1: 	//public void setFrom(long pageno, int recid)
1: 	//{
1:     //    this.pageno = pageno;
1:     //    this.recid  = recid;
1: 	//}
1: 
1: 	/*
1: 	 * InternalRowLocation interface
1: 	 */
1: 
1:     /**
1:      * Return a RecordHandle built from current RowLocation.
1:      * <p>
1:      * Build a RecordHandle from the current RowLocation.  The main client
1:      * of this interface is row level locking secondary indexes which read
1:      * the RowLocation field from a secondary index row, and then need a
1:      * RecordHandle built from this RowLocation.
1:      * <p>
1:      * The interface is not as generic as one may have wanted in order to
1:      * store as compressed a version of a RowLocation as possible.  So 
1:      * if an implementation of a RowLocation does not have the segmentid, 
1:      * and containerid stored, use the input parameters instead.  If the
1:      * RowLocation does have the values stored use them and ignore the
1:      * input parameters.
1:      * <p>
1:      * Example:
1:      * <p>
1:      * The HeapRowLocation implementation of RowLocation generated by the 
1:      * Heap class, only stores the page and record id.  The B2I conglomerate
1:      * implements a secondary index on top of a Heap class.  B2I knows the
1:      * segmentid and containerid of it's base table, and knows that it can
1:      * find an InternalRowLocation in a particular column of it's rows.  It
1:      * uses InternalRowLocation.getRecordHandle() to build a RecordHandle
1:      * from the InternalRowLocation, and uses it to set a row lock on that
1:      * row in the btree.
1:      *
1: 	 * @return The newly allocated RecordHandle.
1:      *
1:      * @param segmentid     The segment id to store in RecordHandle.
1:      * @param containerid   The segment id to store in RecordHandle.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     /*public RecordHandle getRecordHandle(
1:     TransactionManager   tran,
1:     long                 segmentid,
1:     long                 containerid)
1:         throws StandardException
1:     {
1:         return(
1:             this.getRecordHandle(
1:                 tran.getRawStoreXact(), segmentid, containerid));
1:     }
1: */
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;
1: 	}
1: 
1:     public boolean isNull()
1:     {
1:         return false;
1:     }
1: 
1: 	public void writeExternal(ObjectOutput out) 
1:         throws IOException
1:     {
1:         // Write the page number, compressed
1:         CompressedNumber.writeLong(out, this.pageno);
1: 
1:         // Write the record id
1:         CompressedNumber.writeInt(out, this.recid);
1:     }
1: 
1: 	/**
1: 	  @exception java.lang.ClassNotFoundException A class needed to read the
1: 	  stored form of this object could not be found.
1: 	  @see java.io.Externalizable#readExternal
1: 	  */
1: 	public void readExternal(ObjectInput in) 
1:         throws IOException, ClassNotFoundException
1:     {
1:         this.pageno = CompressedNumber.readLong(in);
1: 
1:         this.recid  = CompressedNumber.readInt(in);
1: 
1: 		rh = null;
1:     }
1: 	public void readExternalFromArray(ArrayInputStream in) 
1:         throws IOException, ClassNotFoundException
1:     {
1:         this.pageno = in.readCompressedLong();
1: 
1:         this.recid  = in.readCompressedInt();
1: 
1: 		rh = null;
1:     }
1: 
1:     public void restoreToNull()
1:     {
1: 		if (SanityManager.DEBUG) 
1: 			SanityManager.THROWASSERT("HeapRowLocation is never null");
1:     }
1: 	protected void setFrom(DataValueDescriptor theValue)  {
1:         if (SanityManager.DEBUG)
0:             SanityManager.THROWASSERT("SHOULD NOT BE CALLED");
1: 	}
1: 	/*
1: 	**		Methods of Object
1: 	*/
1: 
1: 	/**
1: 		Implement value equality.
1: 		<BR>
1: 		MT - Thread safe
1: 	*/
1: 	public boolean equals(Object ref) 
1:     {
1: 
1: 		if ((ref instanceof HeapRowLocation))
1:         {
1:             HeapRowLocation other = (HeapRowLocation) ref;
1: 
1:             return(
1:                 (this.pageno == other.pageno) && (this.recid == other.recid));
1:         }
1:         else
1:         {
1: 			return false;
1:         }
1: 
1: 	}
1: 
1: 	/**
1: 		Return a hashcode based on value.
1: 		<BR>
1: 		MT - thread safe
1: 	*/
1: 	public int hashCode() 
1:     {
1: 		return ((int) this.pageno) ^ this.recid;
1: 	}
1: 
1:     /*
1:      * Standard toString() method.
1:      */
1:     public String toString()
1:     {
1:         String string = 
1:            "(" + this.pageno + "," + this.recid + ")";
1:         return(string);
1:     }
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: /**
0: 
0:   A heap row location represents the location of a row in the heap.
0:   <P>
0:   It's implementad as a wrapper around a raw store record handle.
0: 
0: **/
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.CompressedNumber;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.types.CloneableObject;
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: import org.apache.derby.iapi.types.DataType;
0: 
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0:  * @format_id ACCESS_HEAP_ROW_LOCATION_V1_ID
0:  *
0:  * @purpose   Object used to store the location of a row within a Heap table.  
0:  *            One of these is stored in every row of a btree secondary index 
0:  *            built on a heap base table.
0:  *
0:  * @upgrade   The type of the btree determines the type of rowlocation stored.
0:  *            In current btree implementations only one type of rowlocation can
0:  *            be stored per tree, and it's type is stored in the format id 
0:  *            array stored in the Conglomerate object.
0:  *
0:  * @disk_layout 
0:  *     page number(CompressedNumber.writeLong())
0:  *     record id(CompressedNumber.writeInt())
0:  **/
0: 
0: public class HeapRowLocation extends DataType implements RowLocation
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	The HeapRowLocation simply maintains a raw store record handle.
0: 	**/
0:     private long         pageno;
0:     private int          recid;
0: 	private RecordHandle rh;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( HeapRowLocation.class);
0:     private static final int RECORD_HANDLE_MEMORY_USAGE
0:     = ClassSize.estimateBaseFromCatalog( org.apache.derby.impl.store.raw.data.RecordId.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE;
0: 
0:         if( null != rh)
0:             sz += RECORD_HANDLE_MEMORY_USAGE;
0:         return sz;
0:     } // end of estimateMemoryUsage
0: 
0: 	public String getTypeName() {
0: 		return "RowLocation";
0: 	}
0: 
0: 	public void setValueFromResultSet(java.sql.ResultSet resultSet, int colNumber,
0: 		boolean isNullable) {
0: 	}
0: 
0: 	public DataValueDescriptor getNewNull() {
0: 		return null;
0: 	}
0: 	public void setValue(Object o) {
0: 	}
0: 
0: 	public Object getObject() {
0: 		return null;
0: 	}
0: 
0: 	/*
0: 	** Methods of CloneableObject.
0: 	*/
0: 	public Object cloneObject()
0: 	{
0: 		return getClone();
0: 		
0: 	}
0: 
0: 	public DataValueDescriptor getClone() {
0: 		return new HeapRowLocation(this);
0: 	}
0: 
0: 	public int getLength() {
0: 		return 10;
0: 	}
0: 
0: 	public String getString() {
0: 		return toString();
0: 	}
0: 
0: 	/*
0: 	** Methods of Orderable (from RowLocation)
0: 	**
0: 	** see description in
0: 	** protocol/Database/Storage/Access/Interface/Orderable.java 
0: 	**
0: 	*/
0: 
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 	{
0: 		// HeapRowLocation should not be null, ignore orderedNulls
0: 		int result = compare(other);
0: 
0: 		switch(op)
0: 		{
0: 		case ORDER_OP_LESSTHAN:
0: 			return (result < 0); // this < other
0: 		case ORDER_OP_EQUALS:
0: 			return (result == 0);  // this == other
0: 		case ORDER_OP_LESSOREQUALS:
0: 			return (result <= 0);  // this <= other
0: 		default:
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.THROWASSERT("Unexpected operation");
0: 			return false;
0: 		}
0: 	}
0: 
0: 	public int compare(DataValueDescriptor other)
0: 	{
0: 		// REVISIT: do we need this check?
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(other instanceof HeapRowLocation);
0: 
0: 		HeapRowLocation arg = (HeapRowLocation) other;
0: 		
0: 		// XXX (nat) assumption is that these HeapRowLocations are
0: 		// never null.  However, if they ever become null, need
0: 		// to add null comparison logic.
0:         //
0:         // RESOLVE - change these to be state based
0:         /*
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(getRecordHandle() != null);
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(arg.getRecordHandle() != null);
0:         */
0: 
0: 		long myPage     = this.pageno;
0: 		long otherPage  = arg.pageno;
0: 
0: 		if (myPage < otherPage)
0: 			return -1;
0: 		else if (myPage > otherPage)
0: 			return 1;
0: 
0: 		int myRecordId      = this.recid;
0: 		int otherRecordId   = arg.recid;
0: 
0: 		if (myRecordId == otherRecordId)
0: 			return 0;
0: 		else if (myRecordId < otherRecordId)
0: 			return -1;
0: 		else
0: 			return 1;
0: 	}
0: 
0: 	/*
0: 	** Methods of HeapRowLocation
0: 	*/
0: 
0: 	HeapRowLocation(RecordHandle rh)
0: 	{
0: 		setFrom(rh);
0: 	}
0: 
0: 	public HeapRowLocation()
0: 	{
0:         this.pageno = 0; 
0:         this.recid  = RecordHandle.INVALID_RECORD_HANDLE;
0: 	}
0: 
0: 	/* For cloning */
0: 	private HeapRowLocation(HeapRowLocation other)
0: 	{
0: 		this.pageno = other.pageno;
0: 		this.recid = other.recid;
0: 		this.rh = other.rh;
0: 	}
0: 
0: 	public RecordHandle getRecordHandle(ContainerHandle ch)
0:         throws StandardException
0: 	{
0: 		if (rh != null)
0: 			return rh;
0: 
0: 		return rh = ch.makeRecordHandle(this.pageno, this.recid);
0: 	}
0: 
0: 	void setFrom(RecordHandle rh)
0: 	{
0:         this.pageno = rh.getPageNumber();
0:         this.recid  = rh.getId();
0: 		this.rh = rh;
0: 	}
0: 
0: 	//public void setFrom(long pageno, int recid)
0: 	//{
0:     //    this.pageno = pageno;
0:     //    this.recid  = recid;
0: 	//}
0: 
0: 	/*
0: 	 * InternalRowLocation interface
0: 	 */
0: 
0:     /**
0:      * Return a RecordHandle built from current RowLocation.
0:      * <p>
0:      * Build a RecordHandle from the current RowLocation.  The main client
0:      * of this interface is row level locking secondary indexes which read
0:      * the RowLocation field from a secondary index row, and then need a
0:      * RecordHandle built from this RowLocation.
0:      * <p>
0:      * The interface is not as generic as one may have wanted in order to
0:      * store as compressed a version of a RowLocation as possible.  So 
0:      * if an implementation of a RowLocation does not have the segmentid, 
0:      * and containerid stored, use the input parameters instead.  If the
0:      * RowLocation does have the values stored use them and ignore the
0:      * input parameters.
0:      * <p>
0:      * Example:
0:      * <p>
0:      * The HeapRowLocation implementation of RowLocation generated by the 
0:      * Heap class, only stores the page and record id.  The B2I conglomerate
0:      * implements a secondary index on top of a Heap class.  B2I knows the
0:      * segmentid and containerid of it's base table, and knows that it can
0:      * find an InternalRowLocation in a particular column of it's rows.  It
0:      * uses InternalRowLocation.getRecordHandle() to build a RecordHandle
0:      * from the InternalRowLocation, and uses it to set a row lock on that
0:      * row in the btree.
0:      *
0: 	 * @return The newly allocated RecordHandle.
0:      *
0:      * @param segmentid     The segment id to store in RecordHandle.
0:      * @param containerid   The segment id to store in RecordHandle.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     /*public RecordHandle getRecordHandle(
0:     TransactionManager   tran,
0:     long                 segmentid,
0:     long                 containerid)
0:         throws StandardException
0:     {
0:         return(
0:             this.getRecordHandle(
0:                 tran.getRawStoreXact(), segmentid, containerid));
0:     }
0: */
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.ACCESS_HEAP_ROW_LOCATION_V1_ID;
0: 	}
0: 
0:     public boolean isNull()
0:     {
0:         return false;
0:     }
0: 
0: 	public void writeExternal(ObjectOutput out) 
0:         throws IOException
0:     {
0:         // Write the page number, compressed
0:         CompressedNumber.writeLong(out, this.pageno);
0: 
0:         // Write the record id
0:         CompressedNumber.writeInt(out, this.recid);
0:     }
0: 
0: 	/**
0: 	  @exception java.lang.ClassNotFoundException A class needed to read the
0: 	  stored form of this object could not be found.
0: 	  @see java.io.Externalizable#readExternal
0: 	  */
0: 	public void readExternal(ObjectInput in) 
0:         throws IOException, ClassNotFoundException
0:     {
0:         this.pageno = CompressedNumber.readLong(in);
0: 
0:         this.recid  = CompressedNumber.readInt(in);
0: 
0: 		rh = null;
0:     }
0: 	public void readExternalFromArray(ArrayInputStream in) 
0:         throws IOException, ClassNotFoundException
0:     {
0:         this.pageno = in.readCompressedLong();
0: 
0:         this.recid  = in.readCompressedInt();
0: 
0: 		rh = null;
0:     }
0: 
0:     public void restoreToNull()
0:     {
0: 		if (SanityManager.DEBUG) 
0: 			SanityManager.THROWASSERT("HeapRowLocation is never null");
0:     }
0: 	protected void setFrom(DataValueDescriptor theValue)  {
0:         if (SanityManager.DEBUG)
0:             SanityManager.THROWASSERT("SHOULD NOT BE CALLED");
0: 	}
0: 	/*
0: 	**		Methods of Object
0: 	*/
0: 
0: 	/**
0: 		Implement value equality.
0: 		<BR>
0: 		MT - Thread safe
0: 	*/
0: 	public boolean equals(Object ref) 
0:     {
0: 
0: 		if ((ref instanceof HeapRowLocation))
0:         {
0:             HeapRowLocation other = (HeapRowLocation) ref;
0: 
0:             return(
0:                 (this.pageno == other.pageno) && (this.recid == other.recid));
0:         }
0:         else
0:         {
0: 			return false;
0:         }
0: 
0: 	}
0: 
0: 	/**
0: 		Return a hashcode based on value.
0: 		<BR>
0: 		MT - thread safe
0: 	*/
0: 	public int hashCode() 
0:     {
0: 		return ((int) this.pageno) ^ this.recid;
0: 	}
0: 
0:     /*
0:      * Standard toString() method.
0:      */
0:     public String toString()
0:     {
0:         String string = 
0:            "(" + this.pageno + "," + this.recid + ")";
0:         return(string);
0:     }
0: }
============================================================================