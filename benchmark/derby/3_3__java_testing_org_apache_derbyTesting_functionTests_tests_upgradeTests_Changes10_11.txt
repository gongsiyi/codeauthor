1:d9878ca: /*
9:d9878ca: 
1:d9878ca: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_11
1:d9878ca: 
1:d9878ca: Licensed to the Apache Software Foundation (ASF) under one or more
1:d9878ca: contributor license agreements.  See the NOTICE file distributed with
1:d9878ca: this work for additional information regarding copyright ownership.
1:d9878ca: The ASF licenses this file to You under the Apache License, Version 2.0
1:d9878ca: (the "License"); you may not use this file except in compliance with
1:d9878ca: the License.  You may obtain a copy of the License at
1:d9878ca: 
1:d9878ca:    http://www.apache.org/licenses/LICENSE-2.0
1:d9878ca: 
1:d9878ca: Unless required by applicable law or agreed to in writing, software
1:d9878ca: distributed under the License is distributed on an "AS IS" BASIS,
1:d9878ca: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d9878ca: See the License for the specific language governing permissions and
1:d9878ca: limitations under the License.
1:d9878ca: 
1:d9878ca: */
1:d9878ca: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:d9878ca: 
1:9cfeeb1: import java.sql.Connection;
1:9cfeeb1: import java.sql.PreparedStatement;
1:7fd0c6e: import java.sql.ResultSet;
1:d9878ca: import java.sql.SQLException;
1:9cfeeb1: import java.sql.SQLWarning;
1:d9878ca: import java.sql.Statement;
1:9cfeeb1: import java.util.ArrayList;
1:9cfeeb1: import java.util.Arrays;
1:96e2ea4: import java.util.Properties;
1:d9878ca: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:d9878ca: import org.apache.derbyTesting.junit.JDBC;
1:96e2ea4: import org.apache.derbyTesting.junit.TestConfiguration;
1:d9878ca: 
1:d9878ca: 
1:23362a4: /**
1:d9878ca:  * Upgrade test cases for 10.11.
1:d9878ca:  */
1:d9878ca: public class Changes10_11 extends UpgradeChange
1:d9878ca: {
1:23362a4: 
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:d9878ca:     //
1:d9878ca:     // CONSTANTS
1:d9878ca:     //
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:23362a4: 
1:d9878ca:     private static  final   String  SYNTAX_ERROR = "42X01";
1:d9878ca:     private static  final   String  HARD_UPGRADE_REQUIRED = "XCL47";
1:ee5954e:     private static  final   String  NOT_IMPLEMENTED = "0A000";
1:9cfeeb1:     private static  final   String  NO_ROWS_AFFECTED = "02000";
1:96e2ea4:     private static  final   String  UNKNOWN_OPTIONAL_TOOL = "X0Y88";
1:12086f0:     private static  final   String  UNRECOGNIZED_PROCEDURE = "42Y03";
1:d9878ca: 
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:d9878ca:     //
1:d9878ca:     // CONSTRUCTOR
1:d9878ca:     //
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:d9878ca: 
1:d9878ca:     public Changes10_11(String name) {
1:d9878ca:         super(name);
5:d9878ca:     }
1:531b469: 
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:d9878ca:     //
1:d9878ca:     // JUnit BEHAVIOR
1:d9878ca:     //
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:23362a4: 
1:531b469:     /**
1:d9878ca:      * Return the suite of tests to test the changes made in 10.11.
1:d9878ca:      *
1:d9878ca:      * @param phase an integer that indicates the current phase in
1:d9878ca:      *              the upgrade test.
1:d9878ca:      * @return the test suite created.
1:d9878ca:      */
1:d9878ca:     public static Test suite(int phase) {
1:1ae02c9:         return new BaseTestSuite(Changes10_11.class, "Upgrade test for 10.11");
1:23362a4:     }
1:23362a4: 
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:d9878ca:     //
1:d9878ca:     // TESTS
1:d9878ca:     //
1:d9878ca:     //////////////////////////////////////////////////////////////////
1:23362a4: 
1:d9878ca:     public void testTriggerWhenClause() throws SQLException {
1:d9878ca:         String createTrigger =
1:d9878ca:                 "create trigger d534_tr1 after insert on d534_t1 "
1:d9878ca:                 + "referencing new as new for each row mode db2sql "
1:d9878ca:                 + "when (new.x <> 2) insert into d534_t2 values new.x";
1:23362a4: 
1:d9878ca:         Statement s = createStatement();
1:d9878ca:         switch (getPhase()) {
1:d9878ca:             case PH_CREATE:
1:d9878ca:                 s.execute("create table d534_t1(x int)");
1:d9878ca:                 s.execute("create table d534_t2(y int)");
1:d9878ca:                 assertCompileError(SYNTAX_ERROR, createTrigger);
1:d9878ca:                 break;
1:d9878ca:             case PH_SOFT_UPGRADE:
1:d9878ca:                 assertCompileError(HARD_UPGRADE_REQUIRED, createTrigger);
1:d9878ca:                 break;
1:d9878ca:             case PH_POST_SOFT_UPGRADE:
1:d9878ca:                 assertCompileError(SYNTAX_ERROR, createTrigger);
1:d9878ca:                 break;
1:d9878ca:             case PH_HARD_UPGRADE:
1:d9878ca:                 s.execute(createTrigger);
1:d9878ca:                 s.execute("insert into d534_t1 values 1, 2, 3");
1:d9878ca:                 JDBC.assertFullResultSet(
1:d9878ca:                         s.executeQuery("select * from d534_t2 order by y"),
1:d9878ca:                         new String[][]{{"1"}, {"3"}});
1:d9878ca:                 break;
1:23362a4:         }
1:23362a4:     }
1:ee5954e: 
1:ee5954e:     /**
1:23362a4:      * Test how dropping trigger dependencies works across upgrade and
1:23362a4:      * downgrade. Regression test for DERBY-2041.
1:23362a4:      */
1:23362a4:     public void testDropTriggerDependencies() throws SQLException {
1:23362a4:         if (!oldAtLeast(10, 2)) {
1:23362a4:             // Support for SYNONYMS was added in 10.1. Support for CALL
1:23362a4:             // statements in trigger actions was added in 10.2. Since this
1:23362a4:             // test case uses both of those features, skip it on the oldest
1:23362a4:             // versions.
1:23362a4:             return;
1:23362a4:         }
1:ee5954e: 
1:23362a4:         setAutoCommit(false);
1:23362a4:         Statement s = createStatement();
1:23362a4:         switch (getPhase()) {
1:23362a4:             case PH_CREATE:
1:23362a4:                 // Let's create some objects to use in the triggers.
1:23362a4:                 s.execute("create table d2041_t(x int)");
1:23362a4:                 s.execute("create table d2041_table(x int)");
1:23362a4:                 s.execute("create table d2041_synonym_table(x int)");
1:23362a4:                 s.execute("create synonym d2041_synonym "
1:23362a4:                         + "for d2041_synonym_table");
1:23362a4:                 s.execute("create view d2041_view(x) as values 1");
1:23362a4:                 s.execute("create function d2041_func(i int) returns int "
1:23362a4:                         + "language java parameter style java "
1:23362a4:                         + "external name 'java.lang.Math.abs' no sql");
1:23362a4:                 s.execute("create procedure d2041_proc() "
1:23362a4:                         + "language java parameter style java "
1:23362a4:                         + "external name 'java.lang.Thread.yield' no sql");
1:ee5954e: 
1:23362a4:                 // Create the triggers with the old version.
1:23362a4:                 createDerby2041Triggers(s);
1:23362a4:                 commit();
1:23362a4:                 break;
1:23362a4:             case PH_SOFT_UPGRADE:
1:23362a4:                 // Drop the trigger dependencies. Since the triggers were
1:23362a4:                 // created with the old version, the dependencies were not
1:23362a4:                 // registered, so expect the DROP operations to succeed.
1:23362a4:                 dropDerby2041TriggerDeps(s, false);
1:9cfeeb1: 
1:23362a4:                 // The triggers still exist, so it is possible to drop them.
1:23362a4:                 dropDerby2041Triggers(s);
1:ee5954e: 
1:23362a4:                 // We want to use the objects further, so roll back the
1:23362a4:                 // DROP operations.
1:23362a4:                 rollback();
1:ee5954e: 
1:23362a4:                 // Recreate the triggers with the new version.
1:23362a4:                 dropDerby2041Triggers(s);
1:23362a4:                 createDerby2041Triggers(s);
1:23362a4:                 commit();
1:ee5954e: 
1:23362a4:                 // Dropping the dependencies now should fail.
1:23362a4:                 dropDerby2041TriggerDeps(s, true);
1:23362a4:                 break;
1:23362a4:             case PH_POST_SOFT_UPGRADE:
1:23362a4:                 // After downgrade, the behaviour isn't quite consistent. The
1:23362a4:                 // dependencies were registered when the triggers were created
1:23362a4:                 // with the new version, but the old versions only have code
1:23362a4:                 // to detect some of the dependencies. So some will fail and
1:23362a4:                 // others will succeed.
1:ee5954e: 
1:23362a4:                 // Dependencies on tables and synonyms are detected.
1:23362a4:                 assertStatementError("X0Y25", s, "drop table d2041_table");
1:23362a4:                 assertStatementError("X0Y25", s, "drop synonym d2041_synonym");
1:23362a4: 
1:23362a4:                 // Dependencies on views, functions and procedures are not
1:23362a4:                 // detected.
1:23362a4:                 s.execute("drop view d2041_view");
1:23362a4:                 s.execute("drop function d2041_func");
1:23362a4:                 s.execute("drop procedure d2041_proc");
1:23362a4: 
1:23362a4:                 // Restore the database state.
1:23362a4:                 rollback();
1:23362a4:                 break;
1:23362a4:             case PH_HARD_UPGRADE:
1:23362a4:                 // In hard upgrade, we should be able to detect the
1:23362a4:                 // dependencies registered when the triggers were created
1:23362a4:                 // in the soft-upgraded database.
1:23362a4:                 dropDerby2041TriggerDeps(s, true);
1:ee5954e:         }
1:ee5954e:     }
1:23362a4: 
1:23362a4:     private void createDerby2041Triggers(Statement s) throws SQLException {
1:23362a4:         s.execute("create trigger d2041_tr1 after insert on d2041_t "
1:23362a4:                 + "for each row mode db2sql insert into d2041_table values 1");
1:23362a4:         s.execute("create trigger d2041_tr2 after insert on d2041_t "
1:23362a4:                 + "for each row mode db2sql "
1:23362a4:                 + "insert into d2041_synonym values 1");
1:23362a4:         s.execute("create trigger d2041_tr3 after insert on d2041_t "
1:23362a4:                 + "for each row mode db2sql select * from d2041_view");
1:23362a4:         s.execute("create trigger d2041_tr4 after insert on d2041_t "
1:23362a4:                 + "for each row mode db2sql values d2041_func(1)");
1:23362a4:         s.execute("create trigger d2041_tr5 after insert on d2041_t "
1:23362a4:                 + "for each row mode db2sql call d2041_proc()");
1:ee5954e:     }
1:23362a4: 
1:23362a4:     private void dropDerby2041Triggers(Statement s) throws SQLException {
1:23362a4:         for (int i = 1; i <= 5; i++) {
1:23362a4:             s.execute("drop trigger d2041_tr" + i);
1:23362a4:         }
1:23362a4:     }
1:23362a4: 
1:23362a4:     private void dropDerby2041TriggerDeps(Statement s, boolean expectFailure)
1:23362a4:             throws SQLException {
1:23362a4:         String[] stmts = {
1:23362a4:             "drop table d2041_table",
1:23362a4:             "drop synonym d2041_synonym",
1:23362a4:             "drop view d2041_view",
1:23362a4:             "drop function d2041_func",
1:23362a4:             "drop procedure d2041_proc",
1:23362a4:         };
1:23362a4: 
1:23362a4:         for (String stmt : stmts) {
1:23362a4:             if (expectFailure) {
1:23362a4:                 assertStatementError("X0Y25", s, stmt);
1:23362a4:             } else {
1:23362a4:                 assertUpdateCount(s, 0, stmt);
1:23362a4:             }
1:23362a4:         }
1:23362a4:     }
1:23362a4: 
1:d9878ca:     /**
1:531b469:      * Create a trigger in each upgrade phase and verify that they fire in
1:531b469:      * the order in which they were created. DERBY-5866 changed how the
1:531b469:      * trigger creation timestamp was stored (from local time zone to UTC),
1:531b469:      * and we want to test that this change doesn't affect the trigger
1:531b469:      * execution order when the triggers have been created with different
1:531b469:      * versions.
1:531b469:      */
1:531b469:     public void testDerby5866TriggerExecutionOrder() throws SQLException {
1:531b469:         Statement s = createStatement();
1:531b469:         switch (getPhase()) {
1:531b469:             case PH_CREATE:
1:531b469:                 s.execute("create table d5866_t1(x int)");
1:531b469:                 s.execute("create table d5866_t2(x int "
1:531b469:                         + "generated always as identity, y varchar(100))");
1:531b469:                 s.execute("create trigger d5866_create after insert "
1:531b469:                         + "on d5866_t1 for each statement mode db2sql "
1:531b469:                         + "insert into d5866_t2(y) values 'CREATE'");
1:531b469:                 break;
1:531b469:             case PH_SOFT_UPGRADE:
1:531b469:                 s.execute("create trigger d5866_soft after insert on d5866_t1 "
1:531b469:                         + "insert into d5866_t2(y) values 'SOFT UPGRADE'");
1:531b469:                 break;
1:531b469:             case PH_POST_SOFT_UPGRADE:
1:531b469:                 s.execute("create trigger d5866_post_soft after insert "
1:531b469:                         + "on d5866_t1 for each statement mode db2sql "
1:531b469:                         + "insert into d5866_t2(y) values 'POST SOFT UPGRADE'");
1:531b469:                 break;
1:531b469:             case PH_HARD_UPGRADE:
1:531b469:                 s.execute("create trigger d5866_hard after insert on d5866_t1 "
1:531b469:                         + "insert into d5866_t2(y) values 'HARD UPGRADE'");
1:531b469: 
1:531b469:                 // Fire all the triggers and verify that they executed in
1:531b469:                 // the right order.
1:531b469:                 s.execute("insert into d5866_t1 values 1,2,3");
1:531b469:                 JDBC.assertFullResultSet(
1:531b469:                         s.executeQuery("select y from d5866_t2 order by x"),
1:531b469:                         new String[][] {
1:531b469:                             { "CREATE" }, { "SOFT UPGRADE" },
1:531b469:                             { "POST SOFT UPGRADE" }, { "HARD UPGRADE" }
1:531b469:                         });
1:531b469:                 break;
1:531b469:         }
1:531b469:     }
1:23362a4: 
1:d9878ca:     /**
1:ee5954e:      * Test how deferrable constraints work across upgrade and
1:ee5954e:      * downgrade. Regression test for DERBY-532.
1:ee5954e:      * 
1:ee5954e:      * @throws java.sql.SQLException
1:ee5954e:      */
1:ee5954e:     public void testDeferrableConstraints() throws SQLException {
1:ee5954e:         if (!oldAtLeast(10, 4)) {
1:ee5954e:             // Support for nullable UNIQUE constraints wasn't added before
1:ee5954e:             // 10.4
1:ee5954e:             return;
1:ee5954e:         }
1:ee5954e: 
1:ee5954e:         setAutoCommit(false);
1:ee5954e:         Statement st = createStatement();
1:ee5954e:         
1:ee5954e:         String[] cDeferrableCol = new String[]{
1:ee5954e:             "create table t532(i int not null primary key deferrable)",
1:ee5954e:             "create table t532(i int unique deferrable)",
1:af1c18c:             "create table t532(i int not null unique deferrable)",
1:4cc0287:             "create table t532(i int check (i > 0) deferrable)",
1:af1c18c:             "create table t532(i int references referenced(i) deferrable)"};
1:ee5954e: 
1:ee5954e:         String[] cDeferrableTab = new String[]{
1:ee5954e:             "create table t532(i int not null, constraint c primary key(i) deferrable)",
1:ee5954e:             "create table t532(i int, constraint c unique(i) deferrable)",
1:ee5954e:             "create table t532(i int not null, constraint c unique(i) " + 
1:af1c18c:                 "deferrable)",
1:4cc0287:             "create table t532(i int, constraint c check (i > 0) deferrable)",
1:ee5954e:             "create table t532(i int, constraint c foreign key(i) " + 
1:af1c18c:                 "references referenced(i) deferrable)"};
1:ee5954e: 
1:ee5954e:         st.executeUpdate("create table referenced(i int primary key)");
1:ee5954e:         commit();
1:ee5954e:         
1:ee5954e:         try {
1:ee5954e:             switch (getPhase()) {
1:ee5954e:             
1:ee5954e:             case PH_CREATE:
1:ee5954e:                 for (String s : cDeferrableCol) {
5:ee5954e:                     assertStatementError(SYNTAX_ERROR, st, s);
1:ee5954e:                     assertStatementError(SYNTAX_ERROR, st, s);
1:ee5954e:                 }
1:ee5954e:                 break;
1:ee5954e:                 
1:ee5954e:             case PH_POST_SOFT_UPGRADE:
1:ee5954e:                 for (String s : cDeferrableCol) {
1:ee5954e:                     assertStatementError(SYNTAX_ERROR, st, s);
1:ee5954e:                     assertStatementError(SYNTAX_ERROR, st, s);
1:ee5954e:                 }
1:ee5954e:                 break;
1:ee5954e:                 
1:ee5954e:             case PH_SOFT_UPGRADE:
1:ee5954e:                 for (String s : cDeferrableCol) {
3:ee5954e:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:ee5954e:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:ee5954e:                 }
1:ee5954e:                 break;
1:ee5954e:                 
1:ee5954e:             case PH_HARD_UPGRADE:
1:ee5954e:                 for (String s : cDeferrableCol) {
1:ee5954e:                     st.execute(s);
1:ee5954e:                     rollback();
1:ee5954e:                     st.execute(s);
1:ee5954e:                     rollback();
1:ee5954e:                 }
1:ee5954e:                 break;
1:ee5954e:             }
1:ee5954e:         } finally {
1:ee5954e:             st.executeUpdate("drop table referenced");
1:ee5954e:             commit();
1:ee5954e:         }
1:ee5954e:     }
1:ee5954e: 
1:96e2ea4:     /** Test the MERGE statement introduced by 10.11 */
1:9cfeeb1:     public void testMerge() throws Exception
1:9cfeeb1:     {
1:9cfeeb1:         String mergeStatement =
1:9cfeeb1:             "merge into targetTable t using sourceTable s on t.a = s.a\n" +
1:9cfeeb1:             "when matched then delete\n";
1:9cfeeb1: 
1:9cfeeb1:         Statement s = createStatement();
1:9cfeeb1:         switch (getPhase())
1:9cfeeb1:         {
1:9cfeeb1:             case PH_CREATE:
1:9cfeeb1:                 s.execute("create table targetTable( a int )");
1:9cfeeb1:                 s.execute("create table sourceTable( a int )");
1:9cfeeb1:                 assertCompileError( SYNTAX_ERROR, mergeStatement );
1:9cfeeb1:                 break;
1:9cfeeb1:             case PH_SOFT_UPGRADE:
1:9cfeeb1:                 assertCompileError( HARD_UPGRADE_REQUIRED,  mergeStatement );
1:9cfeeb1:                 break;
1:9cfeeb1:             case PH_POST_SOFT_UPGRADE:
1:9cfeeb1:                 assertCompileError( SYNTAX_ERROR, mergeStatement );
1:9cfeeb1:                 break;
1:9cfeeb1:             case PH_HARD_UPGRADE:
1:9cfeeb1:                 expectExecutionWarning( getConnection(), NO_ROWS_AFFECTED, mergeStatement );
1:9cfeeb1:                 break;
1:9cfeeb1:         }
1:9cfeeb1:     }
1:9cfeeb1: 
1:4222fe9:     /** Test that identity columns handle self-deadlock in soft-upgrade mode */
1:4222fe9:     public void test_derby6692() throws Exception
1:4222fe9:     {
1:4222fe9:         Connection  conn = getConnection();
1:4222fe9:         
1:4222fe9:         switch (getPhase())
1:4222fe9:         {
1:4222fe9:             case PH_CREATE:
1:4222fe9:             case PH_SOFT_UPGRADE:
1:4222fe9:             case PH_POST_SOFT_UPGRADE:
1:4222fe9:             case PH_HARD_UPGRADE:
1:4222fe9: 
1:4222fe9:                 boolean originalAutoCommit = conn.getAutoCommit();
1:4222fe9:                 try
1:4222fe9:                 {
1:4222fe9:                     conn.setAutoCommit( false );
1:4222fe9: 
1:4222fe9:                     conn.prepareStatement( "create table t_6692(i int generated always as identity)" ).execute();
1:4222fe9:                     conn.prepareStatement( "insert into t_6692 values (default)" ).execute();
1:4222fe9: 
1:4222fe9:                     conn.rollback();
1:4222fe9:                 }
1:4222fe9:                 finally
1:4222fe9:                 {
1:4222fe9:                     conn.setAutoCommit( originalAutoCommit );
1:4222fe9:                 }
1:4222fe9:                 break;
1:4222fe9:         }
1:4222fe9:     }
1:4222fe9: 
1:96e2ea4:     /** Test the Lucene plugin */
1:96e2ea4:     public void testLuceneSupport() throws Exception
1:96e2ea4:     {
1:96e2ea4:         Properties  properties = TestConfiguration.getSystemProperties();
1:96e2ea4:         if ( getBooleanProperty( properties, TestConfiguration.KEY_OMIT_LUCENE ) )  { return; }
1:96e2ea4: 
1:12086f0:         Version initialVersion = new Version( getOldMajor(), getOldMinor(), 0, 0 );
1:12086f0:         Version firstVersionHavingBooleanType = new Version( 10, 7, 0, 0 );
1:12086f0:         Version firstVersionHavingOptionalTools = new Version( 10, 10, 0, 0 );
1:12086f0: 
1:12086f0:         boolean hasBooleanDatatype = initialVersion.compareTo( firstVersionHavingBooleanType ) >= 0;
1:12086f0:         boolean hasOptionalTools  = initialVersion.compareTo( firstVersionHavingOptionalTools ) >= 0;
1:12086f0: 
1:12086f0:         String  originalSQLState;
1:12086f0:         if ( !hasBooleanDatatype ) { originalSQLState = SYNTAX_ERROR; }
1:12086f0:         else if ( !hasOptionalTools ) { originalSQLState = UNRECOGNIZED_PROCEDURE; }
1:12086f0:         else { originalSQLState = UNKNOWN_OPTIONAL_TOOL; }
1:12086f0: 
1:12086f0:         String  softUpgradeSQLState;
1:12086f0:         if ( !hasOptionalTools ) { softUpgradeSQLState = UNRECOGNIZED_PROCEDURE; }
1:12086f0:         else { softUpgradeSQLState = HARD_UPGRADE_REQUIRED; }
1:12086f0: 
1:96e2ea4:         String loadTool = "call syscs_util.syscs_register_tool( 'luceneSupport', true )";
1:96e2ea4:         String unloadTool = "call syscs_util.syscs_register_tool( 'luceneSupport', false )";
1:96e2ea4: 
1:96e2ea4:         Statement statement = createStatement();
1:96e2ea4:         switch (getPhase())
1:96e2ea4:         {
1:96e2ea4:             case PH_CREATE:
1:96e2ea4:             case PH_POST_SOFT_UPGRADE:
1:12086f0:                 assertStatementError( originalSQLState, statement, loadTool );
1:96e2ea4:                 break;
1:96e2ea4:             case PH_SOFT_UPGRADE:
1:12086f0:                 assertStatementError( softUpgradeSQLState, statement, loadTool );
1:96e2ea4:                 break;
1:96e2ea4:             case PH_HARD_UPGRADE:
1:96e2ea4:                 statement.executeUpdate( loadTool );
1:96e2ea4:                 statement.executeUpdate( unloadTool );
1:96e2ea4:                 break;
1:96e2ea4:         }
1:96e2ea4:     }
1:96e2ea4: 
1:7fd0c6e:     /** Test the addition of sequence generators to back identity columns */
1:7fd0c6e:     public void testIdentitySequence() throws Exception
1:7fd0c6e:     {
1:7fd0c6e:         Properties  properties = TestConfiguration.getSystemProperties();
1:7fd0c6e:         if ( getBooleanProperty( properties, TestConfiguration.KEY_OMIT_LUCENE ) )  { return; }
1:7fd0c6e: 
1:7fd0c6e:         Version initialVersion = new Version( getOldMajor(), getOldMinor(), 0, 0 );
1:7fd0c6e:         Version firstVersionHavingSequences = new Version( 10, 6, 0, 0 );
1:7fd0c6e:         boolean hasSequences = initialVersion.compareTo( firstVersionHavingSequences ) >= 0;
1:7fd0c6e: 
1:7fd0c6e:         Statement statement = createStatement();
1:7fd0c6e: 
1:7fd0c6e:         String  peek = "values syscs_util.syscs_peek_at_identity( 'APP', 'IDSEQ1' )";
1:7fd0c6e:         
1:7fd0c6e:         switch ( getPhase() )
1:7fd0c6e:         {
1:7fd0c6e:             case PH_CREATE:
1:7fd0c6e:                 statement.executeUpdate
1:7fd0c6e:                     (
1:7fd0c6e:                      "create function uuidToSequenceName( uuid char( 36 ) ) returns varchar( 128 )\n" +
1:7fd0c6e:                      "language java parameter style java no sql\n" +
1:7fd0c6e:                      "external name 'org.apache.derbyTesting.functionTests.tests.lang.IdentitySequenceTest.uuidToSequenceName'\n"
1:7fd0c6e:                      );
1:7fd0c6e:                 statement.executeUpdate
1:7fd0c6e:                     ( "create table idseq1( a int generated always as identity ( start with 10, increment by 20 ), b int )" );
1:7fd0c6e:                 statement.executeUpdate( "insert into idseq1( b ) values ( 1 ), ( 20 )" );
1:7fd0c6e:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:7fd0c6e:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:7fd0c6e:                 break;
1:7fd0c6e:             case PH_POST_SOFT_UPGRADE:
1:7fd0c6e:                 statement.executeUpdate( "create table idseq2( a int generated always as identity, b int )" );
1:7fd0c6e:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:7fd0c6e:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:7fd0c6e:                 break;
1:7fd0c6e:             case PH_SOFT_UPGRADE:
1:7fd0c6e:                 statement.executeUpdate( "create table idseq3( a int generated always as identity, b int )" );
1:7fd0c6e:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:7fd0c6e:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:7fd0c6e:                 break;
1:7fd0c6e:             case PH_HARD_UPGRADE:
1:7fd0c6e:                 statement.executeUpdate( "create table idseq4( a int generated always as identity, b int )" );
1:7fd0c6e:                 assertEquals
1:7fd0c6e:                     (
1:7fd0c6e:                      4,
1:7fd0c6e:                      count
1:7fd0c6e:                      (
1:7fd0c6e:                       statement,
1:7fd0c6e:                       "select count(*)\n" +
1:7fd0c6e:                       "from sys.systables t, sys.syssequences s\n" +
1:7fd0c6e:                       "where uuidToSequenceName( t.tableid ) = s.sequencename\n" +
1:7fd0c6e:                       "and t.tablename like 'IDSEQ%'"
1:7fd0c6e:                       )
1:7fd0c6e:                      );
1:7fd0c6e:                 JDBC.assertFullResultSet
1:7fd0c6e:                     (
1:7fd0c6e:                      statement.executeQuery( peek ),
1:7fd0c6e:                      new String[][]
1:7fd0c6e:                      {
1:7fd0c6e:                          { "50" },
1:7fd0c6e:                      }
1:7fd0c6e:                      );
1:7fd0c6e:                 JDBC.assertFullResultSet
1:7fd0c6e:                     (
1:7fd0c6e:                      statement.executeQuery
1:7fd0c6e:                      (
1:7fd0c6e:                       "select sch.schemaName,\n" +
1:7fd0c6e:                       "s.currentvalue, s.startvalue, s.minimumvalue, s.maximumvalue, s.increment, s.cycleoption\n" +
1:7fd0c6e:                       "from sys.sysschemas sch, sys.systables t, sys.syssequences s\n" +
1:7fd0c6e:                       "where t.tablename = 'IDSEQ1'\n" +
1:7fd0c6e:                       "and uuidToSequenceName( t.tableid ) = s.sequencename\n" +
1:7fd0c6e:                       "and sch.schemaid = s.schemaid\n"
1:7fd0c6e:                       ),
1:7fd0c6e:                      new String[][]
1:7fd0c6e:                      {
1:7fd0c6e:                          { "SYS", "50", "10", "-2147483648", "2147483647", "20", "N" },
1:7fd0c6e:                      }
1:7fd0c6e:                      );
1:7fd0c6e:                 break;
1:7fd0c6e:         }
1:7fd0c6e:     }
1:7fd0c6e:     private int countSequences( Statement statement )
1:7fd0c6e:         throws Exception
1:7fd0c6e:     {
1:7fd0c6e:         return count( statement, "select count(*) from sys.syssequences" );
1:7fd0c6e:     }
1:7fd0c6e:     private int count( Statement statement, String query ) throws Exception
1:7fd0c6e:     {
1:7fd0c6e:         ResultSet   rs = statement.executeQuery( query );
1:7fd0c6e:         rs.next();
1:7fd0c6e: 
1:7fd0c6e:         try {
1:7fd0c6e:             return rs.getInt( 1 );
1:7fd0c6e:         }
1:7fd0c6e:         finally
1:7fd0c6e:         {
1:7fd0c6e:             rs.close();
1:7fd0c6e:         }
1:7fd0c6e:     }
1:7fd0c6e: 
1:96e2ea4:     /** Return the boolean value of a system property */
1:96e2ea4:     private static  boolean getBooleanProperty( Properties properties, String key )
1:96e2ea4:     {
1:96e2ea4:         return Boolean.valueOf( properties.getProperty( key ) ).booleanValue();
1:96e2ea4:     }
1:96e2ea4: 
1:9cfeeb1:     /**
1:9cfeeb1:      * Assert that the statement text, when executed, raises a warning.
1:9cfeeb1:      */
1:9cfeeb1:     private void    expectExecutionWarning( Connection conn, String sqlState, String query )
1:9cfeeb1:         throws Exception
1:9cfeeb1:     {
1:9cfeeb1:         expectExecutionWarnings( conn, new String[] { sqlState }, query );
1:9cfeeb1:     }
1:9cfeeb1: 
1:9cfeeb1:     /**
1:9cfeeb1:      * Assert that the statement text, when executed, raises a warning.
1:9cfeeb1:      */
1:9cfeeb1:     private void    expectExecutionWarnings( Connection conn, String[] sqlStates, String query )
1:9cfeeb1:         throws Exception
1:9cfeeb1:     {
1:9cfeeb1:         println( "\nExpecting warnings " + fill( sqlStates ).toString() + " when executing:\n\t"  );
1:9cfeeb1:         PreparedStatement   ps = chattyPrepare( conn, query );
1:9cfeeb1: 
1:9cfeeb1:         ps.execute();
1:9cfeeb1: 
1:9cfeeb1:         int idx = 0;
1:9cfeeb1: 
1:9cfeeb1:         for ( SQLWarning sqlWarning = ps.getWarnings(); sqlWarning != null; sqlWarning = sqlWarning.getNextWarning() )
1:9cfeeb1:         {
1:9cfeeb1:             String          actualSQLState = sqlWarning.getSQLState();
1:9cfeeb1: 
1:9cfeeb1:             if ( idx >= sqlStates.length )
1:9cfeeb1:             {
1:9cfeeb1:                 fail( "Got more warnings than we expected." );
1:9cfeeb1:             }
1:9cfeeb1: 
1:9cfeeb1:             String  expectedSqlState = sqlStates[ idx++ ];
1:9cfeeb1: 
1:9cfeeb1:             assertEquals( expectedSqlState, actualSQLState );
1:9cfeeb1:         }
1:9cfeeb1: 
1:9cfeeb1:         assertEquals( idx, sqlStates.length );
1:9cfeeb1: 
1:9cfeeb1:         ps.close();
1:9cfeeb1:     }
1:9cfeeb1: 
1:9cfeeb1:     /**
1:9cfeeb1:      * <p>
1:9cfeeb1:      * Fill an ArrayList from an array.
1:9cfeeb1:      * </p>
1:9cfeeb1:      */
1:9cfeeb1:     protected <T> ArrayList<T> fill( T[] raw )
1:9cfeeb1:     {
1:9cfeeb1:         return new ArrayList<T>(Arrays.asList(raw));
1:9cfeeb1:     }
1:ee5954e: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4222fe9
/////////////////////////////////////////////////////////////////////////
1:     /** Test that identity columns handle self-deadlock in soft-upgrade mode */
1:     public void test_derby6692() throws Exception
1:     {
1:         Connection  conn = getConnection();
1:         
1:         switch (getPhase())
1:         {
1:             case PH_CREATE:
1:             case PH_SOFT_UPGRADE:
1:             case PH_POST_SOFT_UPGRADE:
1:             case PH_HARD_UPGRADE:
1: 
1:                 boolean originalAutoCommit = conn.getAutoCommit();
1:                 try
1:                 {
1:                     conn.setAutoCommit( false );
1: 
1:                     conn.prepareStatement( "create table t_6692(i int generated always as identity)" ).execute();
1:                     conn.prepareStatement( "insert into t_6692 values (default)" ).execute();
1: 
1:                     conn.rollback();
1:                 }
1:                 finally
1:                 {
1:                     conn.setAutoCommit( originalAutoCommit );
1:                 }
1:                 break;
1:         }
1:     }
1: 
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     /** Test the addition of sequence generators to back identity columns */
1:     public void testIdentitySequence() throws Exception
1:     {
1:         Properties  properties = TestConfiguration.getSystemProperties();
1:         if ( getBooleanProperty( properties, TestConfiguration.KEY_OMIT_LUCENE ) )  { return; }
1: 
1:         Version initialVersion = new Version( getOldMajor(), getOldMinor(), 0, 0 );
1:         Version firstVersionHavingSequences = new Version( 10, 6, 0, 0 );
1:         boolean hasSequences = initialVersion.compareTo( firstVersionHavingSequences ) >= 0;
1: 
1:         Statement statement = createStatement();
1: 
1:         String  peek = "values syscs_util.syscs_peek_at_identity( 'APP', 'IDSEQ1' )";
1:         
1:         switch ( getPhase() )
1:         {
1:             case PH_CREATE:
1:                 statement.executeUpdate
1:                     (
1:                      "create function uuidToSequenceName( uuid char( 36 ) ) returns varchar( 128 )\n" +
1:                      "language java parameter style java no sql\n" +
1:                      "external name 'org.apache.derbyTesting.functionTests.tests.lang.IdentitySequenceTest.uuidToSequenceName'\n"
1:                      );
1:                 statement.executeUpdate
1:                     ( "create table idseq1( a int generated always as identity ( start with 10, increment by 20 ), b int )" );
1:                 statement.executeUpdate( "insert into idseq1( b ) values ( 1 ), ( 20 )" );
1:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 statement.executeUpdate( "create table idseq2( a int generated always as identity, b int )" );
1:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 statement.executeUpdate( "create table idseq3( a int generated always as identity, b int )" );
1:                 if ( hasSequences ) { assertEquals( 0, countSequences( statement ) ); }
1:                 assertStatementError( UNRECOGNIZED_PROCEDURE, statement, peek );
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 statement.executeUpdate( "create table idseq4( a int generated always as identity, b int )" );
1:                 assertEquals
1:                     (
1:                      4,
1:                      count
1:                      (
1:                       statement,
1:                       "select count(*)\n" +
1:                       "from sys.systables t, sys.syssequences s\n" +
1:                       "where uuidToSequenceName( t.tableid ) = s.sequencename\n" +
1:                       "and t.tablename like 'IDSEQ%'"
1:                       )
1:                      );
1:                 JDBC.assertFullResultSet
1:                     (
1:                      statement.executeQuery( peek ),
1:                      new String[][]
1:                      {
1:                          { "50" },
1:                      }
1:                      );
1:                 JDBC.assertFullResultSet
1:                     (
1:                      statement.executeQuery
1:                      (
1:                       "select sch.schemaName,\n" +
1:                       "s.currentvalue, s.startvalue, s.minimumvalue, s.maximumvalue, s.increment, s.cycleoption\n" +
1:                       "from sys.sysschemas sch, sys.systables t, sys.syssequences s\n" +
1:                       "where t.tablename = 'IDSEQ1'\n" +
1:                       "and uuidToSequenceName( t.tableid ) = s.sequencename\n" +
1:                       "and sch.schemaid = s.schemaid\n"
1:                       ),
1:                      new String[][]
1:                      {
1:                          { "SYS", "50", "10", "-2147483648", "2147483647", "20", "N" },
1:                      }
1:                      );
1:                 break;
1:         }
1:     }
1:     private int countSequences( Statement statement )
1:         throws Exception
1:     {
1:         return count( statement, "select count(*) from sys.syssequences" );
1:     }
1:     private int count( Statement statement, String query ) throws Exception
1:     {
1:         ResultSet   rs = statement.executeQuery( query );
1:         rs.next();
1: 
1:         try {
1:             return rs.getInt( 1 );
1:         }
1:         finally
1:         {
1:             rs.close();
1:         }
1:     }
1: 
commit:12086f0
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  UNRECOGNIZED_PROCEDURE = "42Y03";
/////////////////////////////////////////////////////////////////////////
1:         Version initialVersion = new Version( getOldMajor(), getOldMinor(), 0, 0 );
1:         Version firstVersionHavingBooleanType = new Version( 10, 7, 0, 0 );
1:         Version firstVersionHavingOptionalTools = new Version( 10, 10, 0, 0 );
1: 
1:         boolean hasBooleanDatatype = initialVersion.compareTo( firstVersionHavingBooleanType ) >= 0;
1:         boolean hasOptionalTools  = initialVersion.compareTo( firstVersionHavingOptionalTools ) >= 0;
1: 
1:         String  originalSQLState;
1:         if ( !hasBooleanDatatype ) { originalSQLState = SYNTAX_ERROR; }
1:         else if ( !hasOptionalTools ) { originalSQLState = UNRECOGNIZED_PROCEDURE; }
1:         else { originalSQLState = UNKNOWN_OPTIONAL_TOOL; }
1: 
1:         String  softUpgradeSQLState;
1:         if ( !hasOptionalTools ) { softUpgradeSQLState = UNRECOGNIZED_PROCEDURE; }
1:         else { softUpgradeSQLState = HARD_UPGRADE_REQUIRED; }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 assertStatementError( originalSQLState, statement, loadTool );
1:                 assertStatementError( softUpgradeSQLState, statement, loadTool );
commit:96e2ea4
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  UNKNOWN_OPTIONAL_TOOL = "X0Y88";
/////////////////////////////////////////////////////////////////////////
1:     /** Test the MERGE statement introduced by 10.11 */
/////////////////////////////////////////////////////////////////////////
1:     /** Test the Lucene plugin */
1:     public void testLuceneSupport() throws Exception
1:     {
1:         Properties  properties = TestConfiguration.getSystemProperties();
1:         if ( getBooleanProperty( properties, TestConfiguration.KEY_OMIT_LUCENE ) )  { return; }
1: 
1:         String loadTool = "call syscs_util.syscs_register_tool( 'luceneSupport', true )";
1:         String unloadTool = "call syscs_util.syscs_register_tool( 'luceneSupport', false )";
1: 
1:         Statement statement = createStatement();
1:         switch (getPhase())
1:         {
1:             case PH_CREATE:
1:             case PH_POST_SOFT_UPGRADE:
0:                 assertStatementError( UNKNOWN_OPTIONAL_TOOL, statement, loadTool );
1:                 break;
1:             case PH_SOFT_UPGRADE:
0:                 assertStatementError( HARD_UPGRADE_REQUIRED, statement, loadTool );
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 statement.executeUpdate( loadTool );
1:                 statement.executeUpdate( unloadTool );
1:                 break;
1:         }
1:     }
1: 
1:     /** Return the boolean value of a system property */
1:     private static  boolean getBooleanProperty( Properties properties, String key )
1:     {
1:         return Boolean.valueOf( properties.getProperty( key ) ).booleanValue();
1:     }
1: 
commit:9cfeeb1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLWarning;
1: import java.util.Arrays;
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NO_ROWS_AFFECTED = "02000";
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testMerge() throws Exception
1:     {
1:         String mergeStatement =
1:             "merge into targetTable t using sourceTable s on t.a = s.a\n" +
1:             "when matched then delete\n";
1: 
1:         Statement s = createStatement();
1:         switch (getPhase())
1:         {
1:             case PH_CREATE:
1:                 s.execute("create table targetTable( a int )");
1:                 s.execute("create table sourceTable( a int )");
1:                 assertCompileError( SYNTAX_ERROR, mergeStatement );
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 assertCompileError( HARD_UPGRADE_REQUIRED,  mergeStatement );
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 assertCompileError( SYNTAX_ERROR, mergeStatement );
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 expectExecutionWarning( getConnection(), NO_ROWS_AFFECTED, mergeStatement );
1:                 break;
1:         }
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when executed, raises a warning.
1:      */
1:     private void    expectExecutionWarning( Connection conn, String sqlState, String query )
1:         throws Exception
1:     {
1:         expectExecutionWarnings( conn, new String[] { sqlState }, query );
1:     }
1: 
1:     /**
1:      * Assert that the statement text, when executed, raises a warning.
1:      */
1:     private void    expectExecutionWarnings( Connection conn, String[] sqlStates, String query )
1:         throws Exception
1:     {
1:         println( "\nExpecting warnings " + fill( sqlStates ).toString() + " when executing:\n\t"  );
1:         PreparedStatement   ps = chattyPrepare( conn, query );
1: 
1:         ps.execute();
1: 
1:         int idx = 0;
1: 
1:         for ( SQLWarning sqlWarning = ps.getWarnings(); sqlWarning != null; sqlWarning = sqlWarning.getNextWarning() )
1:         {
1:             String          actualSQLState = sqlWarning.getSQLState();
1: 
1:             if ( idx >= sqlStates.length )
1:             {
1:                 fail( "Got more warnings than we expected." );
1:             }
1: 
1:             String  expectedSqlState = sqlStates[ idx++ ];
1: 
1:             assertEquals( expectedSqlState, actualSQLState );
1:         }
1: 
1:         assertEquals( idx, sqlStates.length );
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Fill an ArrayList from an array.
1:      * </p>
1:      */
1:     protected <T> ArrayList<T> fill( T[] raw )
1:     {
1:         return new ArrayList<T>(Arrays.asList(raw));
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import java.util.Arrays;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         return new BaseTestSuite(Changes10_11.class, "Upgrade test for 10.11");
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:             "create table t532(i int check (i > 0) deferrable)",
/////////////////////////////////////////////////////////////////////////
1:             "create table t532(i int, constraint c check (i > 0) deferrable)",
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:             "create table t532(i int not null unique deferrable)",
0:             "create table t532(i int check (i > 0) deferrable)"};
1:             "create table t532(i int references referenced(i) deferrable)"};
1:                 "deferrable)",
0:             "create table t532(i int, constraint c check (i > 0) deferrable)"};
1:                 "references referenced(i) deferrable)"};
commit:ee5954e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  NOT_IMPLEMENTED = "0A000";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test how deferrable constraints work across upgrade and
1:      * downgrade. Regression test for DERBY-532.
1:      * 
1:      * @throws java.sql.SQLException
1:      */
1:     public void testDeferrableConstraints() throws SQLException {
1:         if (!oldAtLeast(10, 4)) {
1:             // Support for nullable UNIQUE constraints wasn't added before
1:             // 10.4
1:             return;
1:         }
1: 
1:         setAutoCommit(false);
1:         Statement st = createStatement();
1:         
1:         String[] cDeferrableCol = new String[]{
1:             "create table t532(i int not null primary key deferrable)",
1:             "create table t532(i int unique deferrable)",
0:             "create table t532(i int not null unique deferrable)"};
1: 
0:         String[] cDeferrableColNotYet = new String[]{
0:             "create table t532(i int references referenced(i) deferrable)",
0:             "create table t532(i int check(i>3) deferrable)"};
1: 
1:         String[] cDeferrableTab = new String[]{
1:             "create table t532(i int not null, constraint c primary key(i) deferrable)",
1:             "create table t532(i int, constraint c unique(i) deferrable)",
1:             "create table t532(i int not null, constraint c unique(i) " + 
0:                 "deferrable)"};
1:         
0:         String[] cDeferrableTabNotYet = new String[]{
1:             "create table t532(i int, constraint c foreign key(i) " + 
0:                 "references referenced(i) deferrable)",
0:             "create table t532(i int, constraint c check(i>3) deferrable)"};
1: 
1:         st.executeUpdate("create table referenced(i int primary key)");
1:         commit();
1:         
1:         try {
1:             switch (getPhase()) {
1:             
1:             case PH_CREATE:
1:                 for (String s : cDeferrableCol) {
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                 }
1:                 
0:                 for (String s : cDeferrableColNotYet) {
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                 }
1:                 break;
1:                 
1:             case PH_POST_SOFT_UPGRADE:
1:                 for (String s : cDeferrableCol) {
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                 }
1: 
0:                 for (String s : cDeferrableColNotYet) {
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                     assertStatementError(SYNTAX_ERROR, st, s);
1:                 }
1:                 break;
1:                 
1:             case PH_SOFT_UPGRADE:
1:                 for (String s : cDeferrableCol) {
1:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:                 }
1:                 
0:                 for (String s : cDeferrableColNotYet) {
1:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:                     assertStatementError(HARD_UPGRADE_REQUIRED, st, s);
1:                 }
1:                 break;
1:                 
1:             case PH_HARD_UPGRADE:
1:                 for (String s : cDeferrableCol) {
1:                     st.execute(s);
1:                     rollback();
1:                     st.execute(s);
1:                     rollback();
1:                 }
1: 
0:                 for (String s : cDeferrableColNotYet) {
0:                     assertStatementError(NOT_IMPLEMENTED, st, s);
0:                     assertStatementError(NOT_IMPLEMENTED, st, s);
1:                 }
1:                 
1:                 break;
1:             }
1:         } finally {
1:             st.executeUpdate("drop table referenced");
1:             commit();
1:         }
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:531b469
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a trigger in each upgrade phase and verify that they fire in
1:      * the order in which they were created. DERBY-5866 changed how the
1:      * trigger creation timestamp was stored (from local time zone to UTC),
1:      * and we want to test that this change doesn't affect the trigger
1:      * execution order when the triggers have been created with different
1:      * versions.
1:      */
1:     public void testDerby5866TriggerExecutionOrder() throws SQLException {
1:         Statement s = createStatement();
1:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 s.execute("create table d5866_t1(x int)");
1:                 s.execute("create table d5866_t2(x int "
1:                         + "generated always as identity, y varchar(100))");
1:                 s.execute("create trigger d5866_create after insert "
1:                         + "on d5866_t1 for each statement mode db2sql "
1:                         + "insert into d5866_t2(y) values 'CREATE'");
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 s.execute("create trigger d5866_soft after insert on d5866_t1 "
1:                         + "insert into d5866_t2(y) values 'SOFT UPGRADE'");
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 s.execute("create trigger d5866_post_soft after insert "
1:                         + "on d5866_t1 for each statement mode db2sql "
1:                         + "insert into d5866_t2(y) values 'POST SOFT UPGRADE'");
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 s.execute("create trigger d5866_hard after insert on d5866_t1 "
1:                         + "insert into d5866_t2(y) values 'HARD UPGRADE'");
1: 
1:                 // Fire all the triggers and verify that they executed in
1:                 // the right order.
1:                 s.execute("insert into d5866_t1 values 1,2,3");
1:                 JDBC.assertFullResultSet(
1:                         s.executeQuery("select y from d5866_t2 order by x"),
1:                         new String[][] {
1:                             { "CREATE" }, { "SOFT UPGRADE" },
1:                             { "POST SOFT UPGRADE" }, { "HARD UPGRADE" }
1:                         });
1:                 break;
1:         }
1:     }
commit:23362a4
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test how dropping trigger dependencies works across upgrade and
1:      * downgrade. Regression test for DERBY-2041.
1:      */
1:     public void testDropTriggerDependencies() throws SQLException {
1:         if (!oldAtLeast(10, 2)) {
1:             // Support for SYNONYMS was added in 10.1. Support for CALL
1:             // statements in trigger actions was added in 10.2. Since this
1:             // test case uses both of those features, skip it on the oldest
1:             // versions.
1:             return;
1:         }
1: 
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 // Let's create some objects to use in the triggers.
1:                 s.execute("create table d2041_t(x int)");
1:                 s.execute("create table d2041_table(x int)");
1:                 s.execute("create table d2041_synonym_table(x int)");
1:                 s.execute("create synonym d2041_synonym "
1:                         + "for d2041_synonym_table");
1:                 s.execute("create view d2041_view(x) as values 1");
1:                 s.execute("create function d2041_func(i int) returns int "
1:                         + "language java parameter style java "
1:                         + "external name 'java.lang.Math.abs' no sql");
1:                 s.execute("create procedure d2041_proc() "
1:                         + "language java parameter style java "
1:                         + "external name 'java.lang.Thread.yield' no sql");
1: 
1:                 // Create the triggers with the old version.
1:                 createDerby2041Triggers(s);
1:                 commit();
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 // Drop the trigger dependencies. Since the triggers were
1:                 // created with the old version, the dependencies were not
1:                 // registered, so expect the DROP operations to succeed.
1:                 dropDerby2041TriggerDeps(s, false);
1: 
1:                 // The triggers still exist, so it is possible to drop them.
1:                 dropDerby2041Triggers(s);
1: 
1:                 // We want to use the objects further, so roll back the
1:                 // DROP operations.
1:                 rollback();
1: 
1:                 // Recreate the triggers with the new version.
1:                 dropDerby2041Triggers(s);
1:                 createDerby2041Triggers(s);
1:                 commit();
1: 
1:                 // Dropping the dependencies now should fail.
1:                 dropDerby2041TriggerDeps(s, true);
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 // After downgrade, the behaviour isn't quite consistent. The
1:                 // dependencies were registered when the triggers were created
1:                 // with the new version, but the old versions only have code
1:                 // to detect some of the dependencies. So some will fail and
1:                 // others will succeed.
1: 
1:                 // Dependencies on tables and synonyms are detected.
1:                 assertStatementError("X0Y25", s, "drop table d2041_table");
1:                 assertStatementError("X0Y25", s, "drop synonym d2041_synonym");
1: 
1:                 // Dependencies on views, functions and procedures are not
1:                 // detected.
1:                 s.execute("drop view d2041_view");
1:                 s.execute("drop function d2041_func");
1:                 s.execute("drop procedure d2041_proc");
1: 
1:                 // Restore the database state.
1:                 rollback();
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 // In hard upgrade, we should be able to detect the
1:                 // dependencies registered when the triggers were created
1:                 // in the soft-upgraded database.
1:                 dropDerby2041TriggerDeps(s, true);
1:         }
1:     }
1: 
1:     private void createDerby2041Triggers(Statement s) throws SQLException {
1:         s.execute("create trigger d2041_tr1 after insert on d2041_t "
1:                 + "for each row mode db2sql insert into d2041_table values 1");
1:         s.execute("create trigger d2041_tr2 after insert on d2041_t "
1:                 + "for each row mode db2sql "
1:                 + "insert into d2041_synonym values 1");
1:         s.execute("create trigger d2041_tr3 after insert on d2041_t "
1:                 + "for each row mode db2sql select * from d2041_view");
1:         s.execute("create trigger d2041_tr4 after insert on d2041_t "
1:                 + "for each row mode db2sql values d2041_func(1)");
1:         s.execute("create trigger d2041_tr5 after insert on d2041_t "
1:                 + "for each row mode db2sql call d2041_proc()");
1:     }
1: 
1:     private void dropDerby2041Triggers(Statement s) throws SQLException {
1:         for (int i = 1; i <= 5; i++) {
1:             s.execute("drop trigger d2041_tr" + i);
1:         }
1:     }
1: 
1:     private void dropDerby2041TriggerDeps(Statement s, boolean expectFailure)
1:             throws SQLException {
1:         String[] stmts = {
1:             "drop table d2041_table",
1:             "drop synonym d2041_synonym",
1:             "drop view d2041_view",
1:             "drop function d2041_func",
1:             "drop procedure d2041_proc",
1:         };
1: 
1:         for (String stmt : stmts) {
1:             if (expectFailure) {
1:                 assertStatementError("X0Y25", s, stmt);
1:             } else {
1:                 assertUpdateCount(s, 0, stmt);
1:             }
1:         }
1:     }
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_11
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: 
1: /**
1:  * Upgrade test cases for 10.11.
1:  */
1: public class Changes10_11 extends UpgradeChange
1: {
1: 
1:     //////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     //////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  SYNTAX_ERROR = "42X01";
1:     private static  final   String  HARD_UPGRADE_REQUIRED = "XCL47";
1: 
1:     //////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     //////////////////////////////////////////////////////////////////
1: 
1:     public Changes10_11(String name) {
1:         super(name);
1:     }
1: 
1:     //////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     //////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the suite of tests to test the changes made in 10.11.
1:      *
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
1:      */
1:     public static Test suite(int phase) {
0:         return new TestSuite(Changes10_11.class, "Upgrade test for 10.11");
1:     }
1: 
1:     //////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     //////////////////////////////////////////////////////////////////
1: 
1:     public void testTriggerWhenClause() throws SQLException {
1:         String createTrigger =
1:                 "create trigger d534_tr1 after insert on d534_t1 "
1:                 + "referencing new as new for each row mode db2sql "
1:                 + "when (new.x <> 2) insert into d534_t2 values new.x";
1: 
1:         Statement s = createStatement();
1:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 s.execute("create table d534_t1(x int)");
1:                 s.execute("create table d534_t2(y int)");
1:                 assertCompileError(SYNTAX_ERROR, createTrigger);
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 assertCompileError(HARD_UPGRADE_REQUIRED, createTrigger);
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 assertCompileError(SYNTAX_ERROR, createTrigger);
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 s.execute(createTrigger);
1:                 s.execute("insert into d534_t1 values 1, 2, 3");
1:                 JDBC.assertFullResultSet(
1:                         s.executeQuery("select * from d534_t2 order by y"),
1:                         new String[][]{{"1"}, {"3"}});
1:                 break;
1:         }
1:     }
1: }
============================================================================