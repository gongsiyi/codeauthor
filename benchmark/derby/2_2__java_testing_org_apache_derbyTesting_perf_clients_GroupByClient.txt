1:130cfe6: /*
1:130cfe6: 
1:130cfe6: Derby - Class org.apache.derbyTesting.perf.clients.GroupByClient
1:130cfe6: 
1:130cfe6: Licensed to the Apache Software Foundation (ASF) under one or more
1:130cfe6: contributor license agreements.  See the NOTICE file distributed with
1:130cfe6: this work for additional information regarding copyright ownership.
1:130cfe6: The ASF licenses this file to You under the Apache License, Version 2.0
1:130cfe6: (the "License"); you may not use this file except in compliance with
1:130cfe6: the License.  You may obtain a copy of the License at
1:130cfe6: 
1:130cfe6:    http://www.apache.org/licenses/LICENSE-2.0
1:130cfe6: 
1:130cfe6: Unless required by applicable law or agreed to in writing, software
1:130cfe6: distributed under the License is distributed on an "AS IS" BASIS,
1:130cfe6: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:130cfe6: See the License for the specific language governing permissions and
1:130cfe6: limitations under the License.
1:130cfe6: 
1:130cfe6: */
1:130cfe6: 
1:130cfe6: package org.apache.derbyTesting.perf.clients;
1:130cfe6: 
1:9a05e65: import java.io.PrintStream;
1:130cfe6: import java.sql.Connection;
1:130cfe6: import java.sql.PreparedStatement;
1:130cfe6: import java.sql.Statement;
1:130cfe6: import java.sql.SQLException;
1:130cfe6: import java.sql.ResultSet;
1:130cfe6: import java.sql.DatabaseMetaData;
1:130cfe6: 
1:130cfe6: /**
1:130cfe6:  * Test client which performs iterated GROUP BY statements on the
1:130cfe6:  * {@code ONEKTUP} tables generated by {@code WisconsinFiller}.
1:130cfe6:  *
1:130cfe6:  * Based on the parameters specified when run, we perform a particular
1:130cfe6:  * GROUP BY statement, and fetch and check the number of rows returned,
1:130cfe6:  * as part of a performance run controlled by perf.clients.Runner.
1:130cfe6:  *
1:130cfe6:  * For example, you could cause this benchmark's GROUP BY to be:
1:130cfe6:  * - one which returns 10 groups, with 1000 rows in each group, or
1:130cfe6:  * - one which returns 100 groups, with 100 rows in each group, or
1:130cfe6:  * - one which returns 1000 groups, with 10 rows in each group, etc.
1:130cfe6:  * With correspondingly larger numbers of groups as the scale factor grows.
1:130cfe6:  *
1:130cfe6:  * You can use more rows by passing '-load_opts numRows=100000', e.g. Note that
1:130cfe6:  * this only has an effect when you run -init. Note that changing the number
1:130cfe6:  * of rows in the table also changes the expected size of each group; we issue
1:130cfe6:  * a select count(*) query at the start to figure out the expected group size,
1:130cfe6:  * but this hack only works with table sizes that are multiples of 1000.
1:130cfe6:  *
1:130cfe6:  * If you use a substantially larger number of rows (say, 100000 or more), you
1:130cfe6:  * should specify '-rt 300' or higher so that a valid number of executions
1:130cfe6:  * can occur, as the benchmark starts to slow down dramatically with large
1:130cfe6:  * numbers of rows.
1:130cfe6:  *
1:130cfe6:  * To prepare the database for this little benchmark:
1:130cfe6:  *  java org.apache.derbyTesting.perf.clients.Runner -init -load group_by
1:130cfe6:  *       -load_opts numRows=NNNNNN (if you want more than 10,000 rows in DB)
1:130cfe6:  * (this will also run the default GROUP BY, which is GROUP BY TEN)
1:130cfe6:  *
1:130cfe6:  * On subsequent runs you can skip the '-init', and should instead specify
1:130cfe6:  * a particular GROUP BY to run, which you do by specifying:
1:130cfe6:  * - the number of GROUP_BY columns (-load_opts numGroupingCols=N), and
1:130cfe6:  * - the number of groups for each column (-load_opts numGroupsK=NNNN)
1:130cfe6:  *   (NOTE: we count from 1, not from 0, with these parameters!)
1:130cfe6:  *
1:130cfe6:  * I've tried this benchmark up to 5 grouping columns, which seemed like
1:130cfe6:  * plenty for the benchmarking I wanted to do. The code supports more, but
1:130cfe6:  * I'm not sure if it works or not.
1:130cfe6:  *
1:130cfe6:  * For example, this runs a 2-column group by:
1:130cfe6:  *
1:130cfe6:  * -load group_by -load_opts numGroupingCols=2,numGroups1=10,numGroups2=100
1:130cfe6:  *
1:130cfe6:  * The resulting SQL will be:
1:130cfe6:  *
1:130cfe6:  *  SELECT TEN, ONEPERCENT, COUNT(*) FROM TENKTUP1 GROUP BY TEN,ONEPERCENT
1:130cfe6:  *
1:130cfe6:  * Note that due to the way that the data in the TEN and ONEPERCENT columns
1:130cfe6:  * are loaded, they are not independent, so this actually produces 100 groups.
1:130cfe6:  *
1:130cfe6:  * If numGroupingCols == 1, and thus the code can predict the number of
1:130cfe6:  * rows that ought to be in each group, and the total number of groups, then
1:130cfe6:  * it checks those values in the result as well.
1:130cfe6:  */
1:130cfe6: public class GroupByClient implements Client
1:130cfe6: {
1:130cfe6:     private static final int  MAX_GROUPING_COLS = 25;
1:130cfe6: 
1:130cfe6:     private Connection        conn;
1:130cfe6:     private PreparedStatement ps;
1:130cfe6:     private int               numGroupingCols;
1:130cfe6:     //                        Note that we count from 1. Index 0 is unused.
1:130cfe6:     private int               numGroups[] = new int[MAX_GROUPING_COLS+1];
1:130cfe6:     private String            groupingExpr[] = new String[MAX_GROUPING_COLS+1];
1:130cfe6:     private int               totalExpectedGroups;
1:130cfe6:     private int               tableSize = 0;
1:130cfe6:     private String            sql;
1:130cfe6: 
1:130cfe6:     public GroupByClient()
1:130cfe6:     {
1:130cfe6:         numGroupingCols = Runner.getLoadOpt("numGroupingCols", -1);
1:130cfe6:         if (numGroupingCols > 0)
1:130cfe6:         {
1:130cfe6:             totalExpectedGroups = 1;
1:130cfe6:             for (int i = 1; i < numGroups.length; i++)
1:130cfe6:             {
1:130cfe6:                 numGroups[i] = Runner.getLoadOpt("numGroups"+i, 1);
1:130cfe6:                 totalExpectedGroups *= numGroups[i];
1:130cfe6:                 getGroupingExpr(i);
1:130cfe6:             }
1:130cfe6:         }
1:130cfe6:         else
1:130cfe6:         {
1:130cfe6:             // default statement is 1 grouping column with 10 groups:
1:130cfe6:             numGroupingCols = 1;
1:130cfe6:             numGroups[1] = 10;
1:130cfe6:             totalExpectedGroups = 10;
1:130cfe6:             getGroupingExpr(1);
1:130cfe6:         }
1:130cfe6:         sql = buildStatement();
1:130cfe6:     }
1:130cfe6: 
1:130cfe6:     public void init(Connection c)
1:130cfe6:         throws SQLException
1:130cfe6:     {
1:130cfe6:         conn = c;
1:130cfe6:         //dumpTables();
1:130cfe6:         getTableSize();
1:130cfe6:         System.out.println("We'll run '"+sql+"'");
1:130cfe6:         if (numGroupingCols == 1)
1:130cfe6:            System.out.println("... which should produce " +
1:130cfe6:                 totalExpectedGroups + " total groups, each containing " +
1:130cfe6:                 (tableSize / totalExpectedGroups) + " rows.");
1:130cfe6: 
1:130cfe6:         ps = c.prepareStatement( sql );
1:130cfe6:         c.setAutoCommit(false);
1:130cfe6:     }
1:130cfe6:     private void getGroupingExpr(int i)
1:130cfe6:     {
1:130cfe6:         if (numGroups[i] == 1)
1:130cfe6:             groupingExpr[i] = null;
1:130cfe6:         else if (numGroups[i] == 10)
1:130cfe6:             groupingExpr[i] = "TEN";
1:130cfe6:         else if (numGroups[i] == 100)
1:130cfe6:             groupingExpr[i] = "ONEPERCENT";
1:130cfe6:         else
1:130cfe6:             groupingExpr[i] = "MOD(UNIQUE1,"+numGroups[i]+")";
1:130cfe6:     }
1:130cfe6:     private String buildStatement()
1:130cfe6:     {
1:130cfe6:         StringBuffer buf = new StringBuffer();
1:130cfe6:         buf.append("SELECT ");
1:130cfe6:         appendGroups(buf);
1:130cfe6:         buf.append( ", COUNT(*) FROM TENKTUP1 GROUP BY ");
1:130cfe6:         appendGroups(buf);
1:130cfe6:         return buf.toString();
1:130cfe6:     }
1:130cfe6:     private void appendGroups(StringBuffer buf)
1:130cfe6:     {
1:130cfe6:         for (int i = 1; i < numGroups.length && numGroups[i] > 1; i++)
1:130cfe6:         {
1:130cfe6:             if (i > 1)
1:130cfe6:                 buf.append(",");
1:130cfe6:             buf.append(groupingExpr[i]);
1:130cfe6:         }
1:130cfe6:     }
1:130cfe6:     private void dumpTables()
1:130cfe6:         throws SQLException
1:130cfe6:     {
1:130cfe6:         ResultSet rs = conn.getMetaData().getTables(null,null,"%",null);
1:130cfe6:         while (rs.next()) {
1:130cfe6:             System.out.println("Schem=" + rs.getString("TABLE_SCHEM") +
1:130cfe6:                     " name=" + rs.getString("TABLE_NAME"));
1:130cfe6:         }
1:130cfe6:         rs.close();
1:130cfe6:         conn.commit();
1:130cfe6:     }
1:130cfe6:     private void getTableSize()
1:130cfe6:         throws SQLException
1:130cfe6:     {
1:130cfe6:         // Since the TENKTUP1 table can have more or less rows, depending
1:130cfe6:         // on the value of the -load_opts numRows=N parameter, we run a
1:130cfe6:         // count query here to figure out how many rows there actually are.
1:130cfe6: 
1:130cfe6:         Statement s = conn.createStatement();
1:130cfe6:         ResultSet rs = s.executeQuery("select count(*) from tenktup1");
1:130cfe6:         if (!rs.next())
1:130cfe6:             throw new RuntimeException("Unable to find size of tenktup1");
1:130cfe6:         tableSize = rs.getInt(1);
1:130cfe6:         rs.close();
1:130cfe6:         s.close();
1:130cfe6:         conn.commit();
1:130cfe6:     }
1:130cfe6: 
1:130cfe6:     public void doWork()
1:130cfe6:         throws SQLException
1:130cfe6:     {
1:130cfe6:         ResultSet rs = ps.executeQuery();
1:130cfe6:         int expectedCount = tableSize / totalExpectedGroups;
1:130cfe6:         int numRows = 0;
1:130cfe6:         while (rs.next()) {
1:130cfe6:             numRows++;
1:130cfe6:             int groupName = rs.getInt(1);
1:130cfe6:             int theCount = rs.getInt(2);
1:130cfe6:             if (numGroupingCols == 1 && theCount != expectedCount)
1:130cfe6:                 System.out.println("group="+groupName+", count="+theCount+
1:130cfe6:                         ",expectedCount="+expectedCount);
1:130cfe6:         }
1:130cfe6:         if (numGroupingCols == 1 && numRows != totalExpectedGroups)
1:130cfe6:             System.out.println("Total rows from GROUP BY was " + numRows +
1:130cfe6:                     ", expected total rows to be " + totalExpectedGroups);
1:130cfe6:         rs.close();
1:130cfe6:         conn.commit();
1:130cfe6:     }
1:130cfe6: 
1:9a05e65:     public void printReport(PrintStream out) {}
1:9a05e65:     
1:130cfe6: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9a05e65
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintStream;
/////////////////////////////////////////////////////////////////////////
1:     public void printReport(PrintStream out) {}
1:     
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:130cfe6
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.perf.clients.GroupByClient
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.perf.clients;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.Statement;
1: import java.sql.SQLException;
1: import java.sql.ResultSet;
1: import java.sql.DatabaseMetaData;
1: 
1: /**
1:  * Test client which performs iterated GROUP BY statements on the
1:  * {@code ONEKTUP} tables generated by {@code WisconsinFiller}.
1:  *
1:  * Based on the parameters specified when run, we perform a particular
1:  * GROUP BY statement, and fetch and check the number of rows returned,
1:  * as part of a performance run controlled by perf.clients.Runner.
1:  *
1:  * For example, you could cause this benchmark's GROUP BY to be:
1:  * - one which returns 10 groups, with 1000 rows in each group, or
1:  * - one which returns 100 groups, with 100 rows in each group, or
1:  * - one which returns 1000 groups, with 10 rows in each group, etc.
1:  * With correspondingly larger numbers of groups as the scale factor grows.
1:  *
1:  * You can use more rows by passing '-load_opts numRows=100000', e.g. Note that
1:  * this only has an effect when you run -init. Note that changing the number
1:  * of rows in the table also changes the expected size of each group; we issue
1:  * a select count(*) query at the start to figure out the expected group size,
1:  * but this hack only works with table sizes that are multiples of 1000.
1:  *
1:  * If you use a substantially larger number of rows (say, 100000 or more), you
1:  * should specify '-rt 300' or higher so that a valid number of executions
1:  * can occur, as the benchmark starts to slow down dramatically with large
1:  * numbers of rows.
1:  *
1:  * To prepare the database for this little benchmark:
1:  *  java org.apache.derbyTesting.perf.clients.Runner -init -load group_by
1:  *       -load_opts numRows=NNNNNN (if you want more than 10,000 rows in DB)
1:  * (this will also run the default GROUP BY, which is GROUP BY TEN)
1:  *
1:  * On subsequent runs you can skip the '-init', and should instead specify
1:  * a particular GROUP BY to run, which you do by specifying:
1:  * - the number of GROUP_BY columns (-load_opts numGroupingCols=N), and
1:  * - the number of groups for each column (-load_opts numGroupsK=NNNN)
1:  *   (NOTE: we count from 1, not from 0, with these parameters!)
1:  *
1:  * I've tried this benchmark up to 5 grouping columns, which seemed like
1:  * plenty for the benchmarking I wanted to do. The code supports more, but
1:  * I'm not sure if it works or not.
1:  *
1:  * For example, this runs a 2-column group by:
1:  *
1:  * -load group_by -load_opts numGroupingCols=2,numGroups1=10,numGroups2=100
1:  *
1:  * The resulting SQL will be:
1:  *
1:  *  SELECT TEN, ONEPERCENT, COUNT(*) FROM TENKTUP1 GROUP BY TEN,ONEPERCENT
1:  *
1:  * Note that due to the way that the data in the TEN and ONEPERCENT columns
1:  * are loaded, they are not independent, so this actually produces 100 groups.
1:  *
1:  * If numGroupingCols == 1, and thus the code can predict the number of
1:  * rows that ought to be in each group, and the total number of groups, then
1:  * it checks those values in the result as well.
1:  */
1: public class GroupByClient implements Client
1: {
1:     private static final int  MAX_GROUPING_COLS = 25;
1: 
1:     private Connection        conn;
1:     private PreparedStatement ps;
1:     private int               numGroupingCols;
1:     //                        Note that we count from 1. Index 0 is unused.
1:     private int               numGroups[] = new int[MAX_GROUPING_COLS+1];
1:     private String            groupingExpr[] = new String[MAX_GROUPING_COLS+1];
1:     private int               totalExpectedGroups;
1:     private int               tableSize = 0;
1:     private String            sql;
1: 
1:     public GroupByClient()
1:     {
1:         numGroupingCols = Runner.getLoadOpt("numGroupingCols", -1);
1:         if (numGroupingCols > 0)
1:         {
1:             totalExpectedGroups = 1;
1:             for (int i = 1; i < numGroups.length; i++)
1:             {
1:                 numGroups[i] = Runner.getLoadOpt("numGroups"+i, 1);
1:                 totalExpectedGroups *= numGroups[i];
1:                 getGroupingExpr(i);
1:             }
1:         }
1:         else
1:         {
1:             // default statement is 1 grouping column with 10 groups:
1:             numGroupingCols = 1;
1:             numGroups[1] = 10;
1:             totalExpectedGroups = 10;
1:             getGroupingExpr(1);
1:         }
1:         sql = buildStatement();
1:     }
1: 
1:     public void init(Connection c)
1:         throws SQLException
1:     {
1:         conn = c;
1:         //dumpTables();
1:         getTableSize();
1:         System.out.println("We'll run '"+sql+"'");
1:         if (numGroupingCols == 1)
1:            System.out.println("... which should produce " +
1:                 totalExpectedGroups + " total groups, each containing " +
1:                 (tableSize / totalExpectedGroups) + " rows.");
1: 
1:         ps = c.prepareStatement( sql );
1:         c.setAutoCommit(false);
1:     }
1:     private void getGroupingExpr(int i)
1:     {
1:         if (numGroups[i] == 1)
1:             groupingExpr[i] = null;
1:         else if (numGroups[i] == 10)
1:             groupingExpr[i] = "TEN";
1:         else if (numGroups[i] == 100)
1:             groupingExpr[i] = "ONEPERCENT";
1:         else
1:             groupingExpr[i] = "MOD(UNIQUE1,"+numGroups[i]+")";
1:     }
1:     private String buildStatement()
1:     {
1:         StringBuffer buf = new StringBuffer();
1:         buf.append("SELECT ");
1:         appendGroups(buf);
1:         buf.append( ", COUNT(*) FROM TENKTUP1 GROUP BY ");
1:         appendGroups(buf);
1:         return buf.toString();
1:     }
1:     private void appendGroups(StringBuffer buf)
1:     {
1:         for (int i = 1; i < numGroups.length && numGroups[i] > 1; i++)
1:         {
1:             if (i > 1)
1:                 buf.append(",");
1:             buf.append(groupingExpr[i]);
1:         }
1:     }
1:     private void dumpTables()
1:         throws SQLException
1:     {
1:         ResultSet rs = conn.getMetaData().getTables(null,null,"%",null);
1:         while (rs.next()) {
1:             System.out.println("Schem=" + rs.getString("TABLE_SCHEM") +
1:                     " name=" + rs.getString("TABLE_NAME"));
1:         }
1:         rs.close();
1:         conn.commit();
1:     }
1:     private void getTableSize()
1:         throws SQLException
1:     {
1:         // Since the TENKTUP1 table can have more or less rows, depending
1:         // on the value of the -load_opts numRows=N parameter, we run a
1:         // count query here to figure out how many rows there actually are.
1: 
1:         Statement s = conn.createStatement();
1:         ResultSet rs = s.executeQuery("select count(*) from tenktup1");
1:         if (!rs.next())
1:             throw new RuntimeException("Unable to find size of tenktup1");
1:         tableSize = rs.getInt(1);
1:         rs.close();
1:         s.close();
1:         conn.commit();
1:     }
1: 
1:     public void doWork()
1:         throws SQLException
1:     {
1:         ResultSet rs = ps.executeQuery();
1:         int expectedCount = tableSize / totalExpectedGroups;
1:         int numRows = 0;
1:         while (rs.next()) {
1:             numRows++;
1:             int groupName = rs.getInt(1);
1:             int theCount = rs.getInt(2);
1:             if (numGroupingCols == 1 && theCount != expectedCount)
1:                 System.out.println("group="+groupName+", count="+theCount+
1:                         ",expectedCount="+expectedCount);
1:         }
1:         if (numGroupingCols == 1 && numRows != totalExpectedGroups)
1:             System.out.println("Total rows from GROUP BY was " + numRows +
1:                     ", expected total rows to be " + totalExpectedGroups);
1:         rs.close();
1:         conn.commit();
1:     }
1: 
1: }
============================================================================