1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.data.AllocationCache
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.data;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
2:eac0369: /**
1:eac0369: 	An auxiliary object to cache the allocation information for a file container.
1:eac0369: 	<B>Only a FileContainer should use this object</B>
1:eac0369: 	<P>
1:eac0369: 	The allocation cache contains an array of AllocExtents and 3 arrays of longs:
1:eac0369: 	<OL><LI>ExtentPageNums[i] is the page number of the i'th extent
1:eac0369: 	<LI>lowRange[i] is the smallest page number managed by extent i
1:eac0369: 	<LI>hiRange[i] is the largest page number managed by extent i
1:eac0369: 	</OL>
1:eac0369: 	<P>
1:eac0369: 	Note thate extentPageNums and lowRange does not change once the extent has
1:eac0369: 	been created, but hiRange will change for the last extent as more pages are
1:eac0369: 	allocated.
1:eac0369: 	<P>
1:eac0369: 	Extents can be individually invalidated or the entire cache (all extends)
1:eac0369: 	can be invalidated at once.
1:eac0369: 	<P> MT - unsafe
1:eac0369:     Synrhonized access to all methods must be enforced by the caller of 
1:eac0369: 	AllocationCache
1:eac0369: */
1:eac0369: class AllocationCache
1:eac0369: {
1:eac0369: 	private int numExtents;
1:eac0369: 	private long[] lowRange;	// lowRange[i] to hiRange[i] defines the
1:eac0369: 	private long[] hiRange;		// smallest and largest logical page number
1:eac0369: 								// manages by extent i
1:eac0369: 
1:eac0369: 	private boolean[] isDirty;	// changes to the in memory allocation cache
1:eac0369: 	private AllocExtent[] extents;
1:eac0369: 	private long[] extentPageNums;
1:eac0369: 	private boolean isValid;
1:eac0369: 
1:eac0369: 	protected AllocationCache()
1:eac0369: 	{
1:eac0369: 		numExtents = 0;
1:eac0369: 		isValid = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* reset the allocation cache in case when filecontainer object is reused */
1:eac0369: 	protected void reset()
1:eac0369: 	{
1:eac0369: 		numExtents = 0;
1:eac0369: 		isValid = false;
1:eac0369: 
1:eac0369: 		if (lowRange != null)
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < lowRange.length; i++)
1:eac0369: 			{
1:eac0369: 				lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 				hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 				extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 				extents[i] = null;
1:eac0369: 				isDirty[i] = false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the page number for the allocation page that is managing this page number
1:eac0369: 	*/
1:eac0369: 	protected long getAllocPageNumber(BaseContainerHandle handle, 
1:eac0369: 								   long pageNumber, 
1:eac0369: 								   long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// try to see if we can figure this out without validating the cache
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1:eac0369: 				return extentPageNums[i];
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!isValid)
1:eac0369: 		{
1:eac0369: 			/* can't find the page. Validate the cache first, then try to find it again */
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 			
1:eac0369: 			for (int i = 0; i < numExtents; i++)
1:eac0369: 			{
1:eac0369: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1:eac0369: 					return extentPageNums[i];
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the last (allocated) page of the container
1:eac0369: 	  */
1:eac0369: 	protected long getLastPageNumber(BaseContainerHandle handle, long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!isValid)
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 		return hiRange[numExtents-1];
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Set the page number to be unfilled
1:eac0369: 	 */
1:eac0369: 	protected void trackUnfilledPage(long pagenumber, boolean unfilled)
1:eac0369: 	{
1:eac0369: 		// do not validate the alloc cache just for the purpose of updating the
1:eac0369: 		// unfilled bit
1:eac0369: 		if (!isValid ||  numExtents <= 0)
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// we are calling this without getting the allocCache semaphore - be
1:eac0369: 		// careful that extents[i] will go null at any time.
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (lowRange[i] <= pagenumber && pagenumber <= hiRange[i])
1:eac0369: 			{
1:eac0369: 				AllocExtent ext = extents[i];
1:eac0369: 				if (ext != null &&
1:eac0369: 					ext.trackUnfilledPage(pagenumber, unfilled) &&
1:eac0369: 					extents[i] != null)
1:eac0369: 				{
1:eac0369: 					isDirty[i] = true;
1:eac0369: 				}
1:eac0369: 					
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected long getUnfilledPageNumber(BaseContainerHandle handle, 
1:eac0369: 										 long firstAllocPageNumber,
1:eac0369: 										 long pagenum)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// get the next unfilled page number
1:eac0369: 		if (!isValid)
1:eac0369: 		{
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (pagenum == ContainerHandle.INVALID_PAGE_NUMBER)
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < numExtents; i++)
1:eac0369: 			{
1:eac0369: 				if (extents[i] != null)
1:eac0369: 					return extents[i].getUnfilledPageNumber(pagenum);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < numExtents; i++)
1:eac0369: 			{
1:eac0369: 				if (pagenum <= hiRange[i])
1:eac0369: 				{
1:eac0369: 					if (extents[i] != null)
1:eac0369: 						return extents[i].getUnfilledPageNumber(pagenum);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     returns estimated number of allocated pages
1:eac0369:     **/
1:eac0369: 	protected long getEstimatedPageCount(BaseContainerHandle handle,
1:eac0369: 										 long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!isValid)
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 
1:eac0369: 		long estPageCount = 0;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (extents[i] != null)
1:eac0369: 				estPageCount += extents[i].getAllocatedPageCount();
1:eac0369: 		}
1:eac0369: 		return estPageCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     protected SpaceInformation getAllPageCounts(
1:eac0369:         BaseContainerHandle handle,
1:eac0369:         long firstAllocPageNumber)
1:eac0369: 		    throws StandardException
1:eac0369:     {
1:eac0369:         long currAllocPages = 0;
1:eac0369:         long numAllocatedPages = 0;
1:eac0369:         long numFreePages = 0;
1:eac0369:         long numUnfilledPages = 0;
1:eac0369: 
1:eac0369: 		if (!isValid)
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (extents[i] != null)
1:eac0369:             {
1:eac0369:                 currAllocPages = extents[i].getAllocatedPageCount();
1:eac0369: 				numAllocatedPages += currAllocPages;
1:eac0369:                 numUnfilledPages += extents[i].getUnfilledPageCount();
1:44fe060:                 numFreePages += 
1:44fe060:                     (extents[i].getTotalPageCount() - currAllocPages);
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:44fe060:             {
1:eac0369:                 SanityManager.ASSERT(numUnfilledPages <= numAllocatedPages,
1:44fe060:                     "more unfilled pages than allocated pages on extent[" + i +
1:44fe060:                     "], " +
1:44fe060:                     "numUnfilledPages = "    + numUnfilledPages + 
1:44fe060:                     ", numAllocatedPages = " + numAllocatedPages +
1:44fe060:                     ", numFreePages = "      + numFreePages);
1:44fe060:             }
1:eac0369: 		}
1:eac0369:         return new SpaceInformation(
1:eac0369:             numAllocatedPages,
1:eac0369:             numFreePages,
1:eac0369:             numUnfilledPages);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* invalidate all extents */
1:eac0369: 	protected void invalidate()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     FileContainer.SPACE_TRACE, "alloc cache invalidated");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			isDirty[i] = false;
1:eac0369: 			extents[i] = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		isValid = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* invalidate the extent that is managed by this alloc page */
1:eac0369: 	protected void invalidate(AllocPage allocPage, long allocPagenum)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     FileContainer.SPACE_TRACE, "alloc cache for page " + 
1:eac0369:                     allocPagenum + " invalidated");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		isValid = false;
1:eac0369: 
1:eac0369: 		if (numExtents == 0)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (extentPageNums[i] == allocPagenum)
1:eac0369: 			{
1:eac0369: 				// update unfilled page info
1:eac0369: 				if (allocPage != null && extents[i] != null &&
1:eac0369: 					isDirty[i])
1:eac0369: 				{
1:eac0369: 					// replace unFilledPage bitmap with the one in the allocation
1:eac0369: 					// cache, which has the more current information
1:eac0369: 					// call this ONLY in invalidate, when the reference to the
1:eac0369: 					// extent is about to be nulled out
1:eac0369: 					allocPage.updateUnfilledPageInfo(extents[i]);
1:eac0369: 					isDirty[i] = false;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				extents[i] = null;
1:eac0369: 				return;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// handle the case where a new alloc page that has never been entered
1:eac0369: 		// into the cache is asked to be invalidated
1:eac0369: 		if (allocPagenum > hiRange[numExtents-1])
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("cannot find extent managed by " +
1:eac0369: 									  allocPagenum);
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* invalidate the last extent */
1:eac0369: 	protected void invalidateLastExtent()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     FileContainer.SPACE_TRACE,
1:eac0369:                         "last extent (" + extentPageNums[numExtents-1] + 
1:eac0369:                             ") invalidated");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		isValid = false;
1:eac0369: 
1:eac0369: 		if (numExtents > 0)
1:eac0369: 			extents[numExtents - 1] = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the last valid page of the file container.  A valid page is one that
1:eac0369: 	  is not deallocated or freed.
1:eac0369: 	*/
1:eac0369: 	protected long getLastValidPage(BaseContainerHandle handle,
1:eac0369: 									long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		AllocExtent extent = null;
1:eac0369: 		int extentNumber;
1:eac0369: 		long lastValidPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 		if (!isValid)
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 
1:eac0369: 		if (numExtents == 0)	// no extent at all, no page in the container
1:eac0369: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 		// start from the last extent, goes backward till a valid page is found
1:eac0369: 
1:eac0369: 		for (extentNumber = numExtents-1;
1:eac0369: 			 extentNumber >= 0;
1:eac0369: 			 extentNumber--)
1:eac0369: 		{
1:eac0369: 			extent = extents[extentNumber];
1:eac0369: 			lastValidPageNumber = extent.getLastValidPageNumber();
1:eac0369: 			if (lastValidPageNumber != ContainerHandle.INVALID_PAGE_NUMBER)
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 		return lastValidPageNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Get the next page (after pageNumber) that is valid 
1:eac0369: 	  */
1:eac0369: 	protected long getNextValidPage(BaseContainerHandle handle, 
1:eac0369: 									long pageNumber, 
1:eac0369: 									long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		int extentNumber;
1:eac0369: 
1:eac0369: 		if (!isValid)
1:eac0369: 			validate(handle, firstAllocPageNumber);
1:eac0369: 
1:eac0369: 		if (numExtents == 0)	// no extent at all, no page in the container
1:eac0369: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 		// find the extent whose hiRange is > pageNumber.  Most of the time,
1:eac0369: 		// this is the extent this pageNumber is in, but some times, when
1:eac0369: 		// pageNumber == hiRange of extent i, extent i+1 is found.
1:eac0369: 		AllocExtent extent = null;
1:eac0369: 		for (extentNumber = 0; extentNumber < numExtents; extentNumber++)
1:eac0369: 		{
1:eac0369: 			if (pageNumber < hiRange[extentNumber])
1:eac0369: 			{
1:eac0369: 				extent = extents[extentNumber];
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (extent == null)		// extent has been invalidated or not there
1:eac0369: 		{
1:eac0369: 			// the cache is valid and up to date, 
1:eac0369: 			// the only reason why we cannot find an extent is if this is the
1:eac0369: 			// last valid page of the container
1:eac0369: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// extent == extents[extentNumber]
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(extent == extents[extentNumber]);
1:eac0369: 
1:eac0369: 		// we found an extent which may contain a valid page that is of higher
1:eac0369: 		// pagenumber than the passed in page number.  Still need to walk the
1:eac0369: 		// extent array to make sure 
1:eac0369: 
1:eac0369: 		long nextValidPage = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369: 		while(extentNumber < numExtents)
1:eac0369: 		{
1:eac0369: 			extent = extents[extentNumber] ;
1:eac0369: 			nextValidPage = extent.getNextValidPageNumber(pageNumber);
1:eac0369: 			if (nextValidPage != ContainerHandle.INVALID_PAGE_NUMBER)
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			extentNumber++;
1:eac0369: 		}
1:eac0369: 		return nextValidPage;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the page status of a page
1:eac0369: 	*/
1:eac0369: 	protected int getPageStatus(BaseContainerHandle handle, long pageNumber,
1:eac0369: 								long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		AllocExtent extent = null;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < numExtents; i++)
1:eac0369: 		{
1:eac0369: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1:eac0369: 			{
1:eac0369: 				extent = extents[i];
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (extent == null)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 				if (isValid) {
1:eac0369: 
1:eac0369: 					SanityManager.DEBUG_PRINT("trace", "Allocation cache is " + 
1:eac0369: 								(isValid ? "Valid" : "Invalid"));
1:eac0369: 					
1:eac0369: 					for (int i = 0; i < numExtents; i++) {
1:eac0369: 						SanityManager.DEBUG_PRINT("trace", "Extent " + i + " at " + extentPageNums[i] +
1:eac0369: 										" range is " + lowRange[i] + " to " + hiRange[i]);
1:eac0369: 						if (extents[i] == null)
1:eac0369: 							SanityManager.DEBUG_PRINT("trace", "extent is null");
1:eac0369: 						else
1:eac0369: 							SanityManager.DEBUG_PRINT("trace", extents[i].toDebugString());
1:eac0369: 
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					SanityManager.THROWASSERT("valid cache cannot find page "+pageNumber);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (!isValid)
1:eac0369: 				validate(handle, firstAllocPageNumber);
1:eac0369: 			// try again
1:eac0369: 
1:eac0369: 			for (int i = 0; i < numExtents; i++)
1:eac0369: 			{
1:eac0369: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1:eac0369: 				{
1:eac0369: 					extent = extents[i];
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				if (extent == null)
1:eac0369: 					SanityManager.THROWASSERT("valid cache cannot find page " +
1:eac0369: 												pageNumber);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return extent.getPageStatus(pageNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Validate the cache, find all alloc pages and fill in the arrays
1:eac0369: 	  */
1:eac0369: 	private void validate(BaseContainerHandle handle, long firstAllocPageNumber)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (numExtents == 0)	// never been initialized, read it all in
1:eac0369: 		{
1:eac0369: 			long pagenum = firstAllocPageNumber;
1:eac0369: 
1:eac0369: 			while(!isValid)
1:eac0369: 			{
1:eac0369: 				growArrays(++numExtents);
1:eac0369: 
1:eac0369: 				Object obj = handle.getAllocPage(pagenum);
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					if (obj == null)
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							"cannot find " + numExtents +
1:eac0369: 							" alloc page at " + pagenum);
1:eac0369: 					if ( ! (obj instanceof AllocPage))
1:eac0369: 						SanityManager.THROWASSERT(
1:eac0369: 							"page at " + pagenum +
1:eac0369: 							" is not an allocPage, is a " +
1:eac0369: 							obj.getClass().getName());
1:eac0369: 				}	
1:eac0369: 
1:eac0369: 				AllocPage allocPage = (AllocPage)obj;
1:eac0369: 				setArrays(numExtents-1, allocPage);
1:eac0369: 
1:eac0369: 				if (allocPage.isLast())
1:eac0369: 					isValid = true;
1:eac0369: 				else
1:eac0369: 					// get next alloc page
1:eac0369: 					pagenum = allocPage.getNextAllocPageNumber();
1:eac0369: 
1:eac0369: 				allocPage.unlatch();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else		// has been initialized before, but is now invalidated
1:eac0369: 		{
1:eac0369: 			for (int i = 0; i < numExtents-1; i++)
1:eac0369: 			{
1:eac0369: 				if (extents[i] == null)	// reinitialize this extent
1:eac0369: 				{
1:eac0369: 					AllocPage allocPage = 
1:eac0369:                         (AllocPage)handle.getAllocPage(extentPageNums[i]);
1:eac0369: 
1:eac0369: 					setArrays(i, allocPage);
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						if (i < numExtents-1)
1:eac0369:                         {
1:eac0369:                             if (extentPageNums[i+1] != 
1:eac0369:                                     allocPage.getNextAllocPageNumber())
1:eac0369:                             {
1:eac0369:                                 SanityManager.THROWASSERT(
1:eac0369:                                     "bad alloc page - " +
1:eac0369:                                     ";extentPageNums[i+1] = " + 
1:eac0369:                                         extentPageNums[i+1] +
1:eac0369:                                     ";allocPage.getNextAllocPageNumber() = " + 
1:eac0369:                                         allocPage.getNextAllocPageNumber());
1:eac0369:                             }
1:eac0369:                         }
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					allocPage.unlatch();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			// always get the last alloc page to see if the number of alloc
1:eac0369: 			// pages remain the same
1:eac0369: 			long pagenum = extentPageNums[numExtents-1];
1:eac0369: 			while (!isValid)
1:eac0369: 			{
1:eac0369: 				AllocPage allocPage = (AllocPage)handle.getAllocPage(pagenum);
1:eac0369: 
1:eac0369: 				if (extents[numExtents-1] == null)
1:eac0369: 					setArrays(numExtents-1, allocPage);
1:eac0369: 
1:eac0369: 				if (!allocPage.isLast())
1:eac0369: 				{
1:eac0369: 					growArrays(++numExtents);
1:eac0369: 					pagenum = allocPage.getNextAllocPageNumber();
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 					isValid = true;
1:eac0369: 
1:eac0369: 				allocPage.unlatch();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* shorthand to set the 4 array values */
1:eac0369: 	private void setArrays(int i, AllocPage allocPage)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(
1:eac0369:                     FileContainer.SPACE_TRACE, 
1:eac0369:                     "Alloc page " + i + " at " + allocPage.getPageNumber() + 
1:eac0369:                     " updated");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		AllocExtent extent = allocPage.getAllocExtent();
1:eac0369: 		extents[i] = extent;
1:eac0369: 		lowRange[i] = extent.getFirstPagenum();
1:eac0369: 		hiRange[i] = extent.getLastPagenum();
1:eac0369: 		extentPageNums[i] = allocPage.getPageNumber();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* shorthand to grow the 4 arrays to the desired size */
1:eac0369: 	private void growArrays(int size)
1:eac0369: 	{
1:eac0369: 		int oldLength;
1:eac0369: 
1:eac0369: 		if (lowRange == null || lowRange.length == 0)
1:eac0369: 			oldLength = 0;
1:eac0369: 		else 
1:eac0369: 			oldLength = lowRange.length;
1:eac0369: 
1:eac0369: 		if (oldLength >= size)	// no need to grow
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		long[] saveLow = lowRange;
1:eac0369: 		long[] saveHi = hiRange;
1:eac0369: 		AllocExtent[] saveExtents = extents;
1:eac0369: 		boolean[] saveDirty = isDirty;
1:eac0369: 		long[] savePageNums = extentPageNums;
1:eac0369: 
1:eac0369: 		lowRange = new long[size];
1:eac0369: 		hiRange = new long[size];
1:eac0369: 		isDirty = new boolean[size];
1:eac0369: 		extents = new AllocExtent[size];
1:eac0369: 		extentPageNums = new long[size];
1:eac0369: 
1:eac0369: 		if (oldLength > 0)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(oldLength == saveHi.length);
1:eac0369: 				SanityManager.ASSERT(oldLength == saveExtents.length);
1:eac0369: 				SanityManager.ASSERT(oldLength == savePageNums.length);
1:eac0369: 			}
1:eac0369: 			System.arraycopy(saveLow, 	  0, lowRange, 	0, saveLow.length);
1:eac0369: 			System.arraycopy(saveHi,	  0, hiRange, 	0, saveHi.length);
1:eac0369: 			System.arraycopy(saveDirty,	  0, isDirty,   0, saveDirty.length);
1:eac0369: 			System.arraycopy(saveExtents, 0, extents,	0, saveExtents.length);
1:eac0369: 			System.arraycopy(savePageNums,0,extentPageNums,0, savePageNums.length);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = oldLength; i < size; i++)
1:eac0369: 		{
1:eac0369: 			lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 			hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 			isDirty[i] = false;
1:eac0369: 			extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 			extents[i] = null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	  dump the allocation cache information
1:eac0369: 	*/
1:eac0369: 	protected void dumpAllocationCache()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG(FileContainer.SPACE_TRACE, 
1:eac0369:                                     "Allocation cache is " + 
1:eac0369:                                     (isValid ? "Valid" : "Invalid"));
1:eac0369:                 for (int i = 0; i < numExtents; i++)
1:eac0369:                 {
1:eac0369:                     SanityManager.DEBUG(
1:eac0369:                         FileContainer.SPACE_TRACE, 
1:eac0369:                         "Extent " + i + " at " + extentPageNums[i] +
1:eac0369:                         " range is " + lowRange[i] + " to " + hiRange[i]);
1:eac0369: 
1:eac0369:                     if (extents[i] == null)
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(
1:eac0369:                             FileContainer.SPACE_TRACE, "extent is null");
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG(
1:eac0369:                             FileContainer.SPACE_TRACE, 
1:eac0369:                             extents[i].toDebugString());
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:44fe060
/////////////////////////////////////////////////////////////////////////
1:                 numFreePages += 
1:                     (extents[i].getTotalPageCount() - currAllocPages);
1:             {
1:                     "more unfilled pages than allocated pages on extent[" + i +
1:                     "], " +
1:                     "numUnfilledPages = "    + numUnfilledPages + 
1:                     ", numAllocatedPages = " + numAllocatedPages +
1:                     ", numFreePages = "      + numFreePages);
1:             }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.data.AllocationCache
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:c6ad534
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.data;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: 
1: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
1: /**
1: 	An auxiliary object to cache the allocation information for a file container.
1: 	<B>Only a FileContainer should use this object</B>
1: 	<P>
1: 	The allocation cache contains an array of AllocExtents and 3 arrays of longs:
1: 	<OL><LI>ExtentPageNums[i] is the page number of the i'th extent
1: 	<LI>lowRange[i] is the smallest page number managed by extent i
1: 	<LI>hiRange[i] is the largest page number managed by extent i
1: 	</OL>
1: 	<P>
1: 	Note thate extentPageNums and lowRange does not change once the extent has
1: 	been created, but hiRange will change for the last extent as more pages are
1: 	allocated.
1: 	<P>
1: 	Extents can be individually invalidated or the entire cache (all extends)
1: 	can be invalidated at once.
1: 	<P> MT - unsafe
1:     Synrhonized access to all methods must be enforced by the caller of 
1: 	AllocationCache
1: */
1: class AllocationCache
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private int numExtents;
1: 	private long[] lowRange;	// lowRange[i] to hiRange[i] defines the
1: 	private long[] hiRange;		// smallest and largest logical page number
1: 								// manages by extent i
1: 
1: 	private boolean[] isDirty;	// changes to the in memory allocation cache
1: 	private AllocExtent[] extents;
1: 	private long[] extentPageNums;
1: 	private boolean isValid;
1: 
1: 	protected AllocationCache()
1: 	{
1: 		numExtents = 0;
1: 		isValid = false;
1: 	}
1: 
1: 	/* reset the allocation cache in case when filecontainer object is reused */
1: 	protected void reset()
1: 	{
1: 		numExtents = 0;
1: 		isValid = false;
1: 
1: 		if (lowRange != null)
1: 		{
1: 			for (int i = 0; i < lowRange.length; i++)
1: 			{
1: 				lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 				hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 				extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 				extents[i] = null;
1: 				isDirty[i] = false;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Get the page number for the allocation page that is managing this page number
1: 	*/
1: 	protected long getAllocPageNumber(BaseContainerHandle handle, 
1: 								   long pageNumber, 
1: 								   long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		// try to see if we can figure this out without validating the cache
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1: 				return extentPageNums[i];
1: 		}
1: 
1: 		if (!isValid)
1: 		{
1: 			/* can't find the page. Validate the cache first, then try to find it again */
1: 			validate(handle, firstAllocPageNumber);
1: 			
1: 			for (int i = 0; i < numExtents; i++)
1: 			{
1: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1: 					return extentPageNums[i];
1: 			}
1: 		}
1: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1: 	}
1: 
1: 	/**
1: 	  Get the last (allocated) page of the container
1: 	  */
1: 	protected long getLastPageNumber(BaseContainerHandle handle, long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		if (!isValid)
1: 			validate(handle, firstAllocPageNumber);
1: 		return hiRange[numExtents-1];
1: 	}
1: 
1: 	/**
1: 	  Set the page number to be unfilled
1: 	 */
1: 	protected void trackUnfilledPage(long pagenumber, boolean unfilled)
1: 	{
1: 		// do not validate the alloc cache just for the purpose of updating the
1: 		// unfilled bit
1: 		if (!isValid ||  numExtents <= 0)
1: 		{
1: 			return;
1: 		}
1: 
1: 		// we are calling this without getting the allocCache semaphore - be
1: 		// careful that extents[i] will go null at any time.
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (lowRange[i] <= pagenumber && pagenumber <= hiRange[i])
1: 			{
1: 				AllocExtent ext = extents[i];
1: 				if (ext != null &&
1: 					ext.trackUnfilledPage(pagenumber, unfilled) &&
1: 					extents[i] != null)
1: 				{
1: 					isDirty[i] = true;
1: 				}
1: 					
1: 				break;
1: 			}
1: 		}
1: 	}
1: 
1: 	protected long getUnfilledPageNumber(BaseContainerHandle handle, 
1: 										 long firstAllocPageNumber,
1: 										 long pagenum)
1: 		 throws StandardException
1: 	{
1: 		// get the next unfilled page number
1: 		if (!isValid)
1: 		{
1: 			validate(handle, firstAllocPageNumber);
1: 		}
1: 
1: 		if (pagenum == ContainerHandle.INVALID_PAGE_NUMBER)
1: 		{
1: 			for (int i = 0; i < numExtents; i++)
1: 			{
1: 				if (extents[i] != null)
1: 					return extents[i].getUnfilledPageNumber(pagenum);
1: 			}
1: 		}
1: 		else
1: 		{
1: 			for (int i = 0; i < numExtents; i++)
1: 			{
1: 				if (pagenum <= hiRange[i])
1: 				{
1: 					if (extents[i] != null)
1: 						return extents[i].getUnfilledPageNumber(pagenum);
1: 				}
1: 			}
1: 		}
1: 
1: 		return ContainerHandle.INVALID_PAGE_NUMBER;
1: 	}
1: 
1:     /**
1:     returns estimated number of allocated pages
1:     **/
1: 	protected long getEstimatedPageCount(BaseContainerHandle handle,
1: 										 long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		if (!isValid)
1: 			validate(handle, firstAllocPageNumber);
1: 
1: 		long estPageCount = 0;
1: 
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (extents[i] != null)
1: 				estPageCount += extents[i].getAllocatedPageCount();
1: 		}
1: 		return estPageCount;
1: 	}
1: 
1: 
1:     protected SpaceInformation getAllPageCounts(
1:         BaseContainerHandle handle,
1:         long firstAllocPageNumber)
1: 		    throws StandardException
1:     {
1:         long currAllocPages = 0;
1:         long numAllocatedPages = 0;
1:         long numFreePages = 0;
1:         long numUnfilledPages = 0;
1: 
1: 		if (!isValid)
1: 			validate(handle, firstAllocPageNumber);
1: 
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (extents[i] != null)
1:             {
1:                 currAllocPages = extents[i].getAllocatedPageCount();
1: 				numAllocatedPages += currAllocPages;
1:                 numUnfilledPages += extents[i].getUnfilledPageCount();
0:                 numFreePages += (extents[i].getTotalPageCount() - currAllocPages);
1:             }
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(numUnfilledPages <= numAllocatedPages,
0:                     "more unfilled pages than allocated pages on extent ");
1: 		}
1:         return new SpaceInformation(
1:             numAllocatedPages,
1:             numFreePages,
1:             numUnfilledPages);
1:     }
1: 
1: 
1: 	/* invalidate all extents */
1: 	protected void invalidate()
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:             {
1:                 SanityManager.DEBUG(
1:                     FileContainer.SPACE_TRACE, "alloc cache invalidated");
1:             }
1:         }
1: 
1: 
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			isDirty[i] = false;
1: 			extents[i] = null;
1: 		}
1: 
1: 		isValid = false;
1: 
1: 	}
1: 
1: 	/* invalidate the extent that is managed by this alloc page */
1: 	protected void invalidate(AllocPage allocPage, long allocPagenum)
1: 		 throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:             {
1:                 SanityManager.DEBUG(
1:                     FileContainer.SPACE_TRACE, "alloc cache for page " + 
1:                     allocPagenum + " invalidated");
1:             }
1:         }
1: 
1: 		isValid = false;
1: 
1: 		if (numExtents == 0)
1: 			return;
1: 
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (extentPageNums[i] == allocPagenum)
1: 			{
1: 				// update unfilled page info
1: 				if (allocPage != null && extents[i] != null &&
1: 					isDirty[i])
1: 				{
1: 					// replace unFilledPage bitmap with the one in the allocation
1: 					// cache, which has the more current information
1: 					// call this ONLY in invalidate, when the reference to the
1: 					// extent is about to be nulled out
1: 					allocPage.updateUnfilledPageInfo(extents[i]);
1: 					isDirty[i] = false;
1: 				}
1: 
1: 				extents[i] = null;
1: 				return;
1: 			}
1: 		}
1: 
1: 		// handle the case where a new alloc page that has never been entered
1: 		// into the cache is asked to be invalidated
1: 		if (allocPagenum > hiRange[numExtents-1])
1: 			return;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("cannot find extent managed by " +
1: 									  allocPagenum);
1: 
1: 
1: 	}
1: 
1: 	/* invalidate the last extent */
1: 	protected void invalidateLastExtent()
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:             {
1:                 SanityManager.DEBUG(
1:                     FileContainer.SPACE_TRACE,
1:                         "last extent (" + extentPageNums[numExtents-1] + 
1:                             ") invalidated");
1:             }
1:         }
1: 
1: 		isValid = false;
1: 
1: 		if (numExtents > 0)
1: 			extents[numExtents - 1] = null;
1: 	}
1: 
1: 	/**
1: 	  Get the last valid page of the file container.  A valid page is one that
1: 	  is not deallocated or freed.
1: 	*/
1: 	protected long getLastValidPage(BaseContainerHandle handle,
1: 									long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		AllocExtent extent = null;
1: 		int extentNumber;
1: 		long lastValidPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 		if (!isValid)
1: 			validate(handle, firstAllocPageNumber);
1: 
1: 		if (numExtents == 0)	// no extent at all, no page in the container
1: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 		// start from the last extent, goes backward till a valid page is found
1: 
1: 		for (extentNumber = numExtents-1;
1: 			 extentNumber >= 0;
1: 			 extentNumber--)
1: 		{
1: 			extent = extents[extentNumber];
1: 			lastValidPageNumber = extent.getLastValidPageNumber();
1: 			if (lastValidPageNumber != ContainerHandle.INVALID_PAGE_NUMBER)
1: 				break;
1: 		}
1: 		return lastValidPageNumber;
1: 	}
1: 
1: 	/*
1: 	  Get the next page (after pageNumber) that is valid 
1: 	  */
1: 	protected long getNextValidPage(BaseContainerHandle handle, 
1: 									long pageNumber, 
1: 									long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		int extentNumber;
1: 
1: 		if (!isValid)
1: 			validate(handle, firstAllocPageNumber);
1: 
1: 		if (numExtents == 0)	// no extent at all, no page in the container
1: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 		// find the extent whose hiRange is > pageNumber.  Most of the time,
1: 		// this is the extent this pageNumber is in, but some times, when
1: 		// pageNumber == hiRange of extent i, extent i+1 is found.
1: 		AllocExtent extent = null;
1: 		for (extentNumber = 0; extentNumber < numExtents; extentNumber++)
1: 		{
1: 			if (pageNumber < hiRange[extentNumber])
1: 			{
1: 				extent = extents[extentNumber];
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (extent == null)		// extent has been invalidated or not there
1: 		{
1: 			// the cache is valid and up to date, 
1: 			// the only reason why we cannot find an extent is if this is the
1: 			// last valid page of the container
1: 			return ContainerHandle.INVALID_PAGE_NUMBER;
1: 		}
1: 
1: 		// extent == extents[extentNumber]
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(extent == extents[extentNumber]);
1: 
1: 		// we found an extent which may contain a valid page that is of higher
1: 		// pagenumber than the passed in page number.  Still need to walk the
1: 		// extent array to make sure 
1: 
1: 		long nextValidPage = ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1: 		while(extentNumber < numExtents)
1: 		{
1: 			extent = extents[extentNumber] ;
1: 			nextValidPage = extent.getNextValidPageNumber(pageNumber);
1: 			if (nextValidPage != ContainerHandle.INVALID_PAGE_NUMBER)
1: 				break;
1: 
1: 			extentNumber++;
1: 		}
1: 		return nextValidPage;
1: 
1: 	}
1: 
1: 	/**
1: 	  Get the page status of a page
1: 	*/
1: 	protected int getPageStatus(BaseContainerHandle handle, long pageNumber,
1: 								long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		AllocExtent extent = null;
1: 
1: 		for (int i = 0; i < numExtents; i++)
1: 		{
1: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1: 			{
1: 				extent = extents[i];
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (extent == null)
1: 		{
1: 			if (SanityManager.DEBUG) {
1: 				if (isValid) {
1: 
1: 					SanityManager.DEBUG_PRINT("trace", "Allocation cache is " + 
1: 								(isValid ? "Valid" : "Invalid"));
1: 					
1: 					for (int i = 0; i < numExtents; i++) {
1: 						SanityManager.DEBUG_PRINT("trace", "Extent " + i + " at " + extentPageNums[i] +
1: 										" range is " + lowRange[i] + " to " + hiRange[i]);
1: 						if (extents[i] == null)
1: 							SanityManager.DEBUG_PRINT("trace", "extent is null");
1: 						else
1: 							SanityManager.DEBUG_PRINT("trace", extents[i].toDebugString());
1: 
1: 					}
1: 
1: 					SanityManager.THROWASSERT("valid cache cannot find page "+pageNumber);
1: 				}
1: 			}
1: 
1: 			if (!isValid)
1: 				validate(handle, firstAllocPageNumber);
1: 			// try again
1: 
1: 			for (int i = 0; i < numExtents; i++)
1: 			{
1: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
1: 				{
1: 					extent = extents[i];
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (SanityManager.DEBUG)
1: 				if (extent == null)
1: 					SanityManager.THROWASSERT("valid cache cannot find page " +
1: 												pageNumber);
1: 		}
1: 
1: 		return extent.getPageStatus(pageNumber);
1: 	}
1: 
1: 	/**
1: 	  Validate the cache, find all alloc pages and fill in the arrays
1: 	  */
1: 	private void validate(BaseContainerHandle handle, long firstAllocPageNumber)
1: 		 throws StandardException
1: 	{
1: 		if (numExtents == 0)	// never been initialized, read it all in
1: 		{
1: 			long pagenum = firstAllocPageNumber;
1: 
1: 			while(!isValid)
1: 			{
1: 				growArrays(++numExtents);
1: 
1: 				Object obj = handle.getAllocPage(pagenum);
1: 
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					if (obj == null)
1: 						SanityManager.THROWASSERT(
1: 							"cannot find " + numExtents +
1: 							" alloc page at " + pagenum);
1: 					if ( ! (obj instanceof AllocPage))
1: 						SanityManager.THROWASSERT(
1: 							"page at " + pagenum +
1: 							" is not an allocPage, is a " +
1: 							obj.getClass().getName());
1: 				}	
1: 
1: 				AllocPage allocPage = (AllocPage)obj;
1: 				setArrays(numExtents-1, allocPage);
1: 
1: 				if (allocPage.isLast())
1: 					isValid = true;
1: 				else
1: 					// get next alloc page
1: 					pagenum = allocPage.getNextAllocPageNumber();
1: 
1: 				allocPage.unlatch();
1: 			}
1: 		}
1: 		else		// has been initialized before, but is now invalidated
1: 		{
1: 			for (int i = 0; i < numExtents-1; i++)
1: 			{
1: 				if (extents[i] == null)	// reinitialize this extent
1: 				{
1: 					AllocPage allocPage = 
1:                         (AllocPage)handle.getAllocPage(extentPageNums[i]);
1: 
1: 					setArrays(i, allocPage);
1: 
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						if (i < numExtents-1)
1:                         {
1:                             if (extentPageNums[i+1] != 
1:                                     allocPage.getNextAllocPageNumber())
1:                             {
1:                                 SanityManager.THROWASSERT(
1:                                     "bad alloc page - " +
1:                                     ";extentPageNums[i+1] = " + 
1:                                         extentPageNums[i+1] +
1:                                     ";allocPage.getNextAllocPageNumber() = " + 
1:                                         allocPage.getNextAllocPageNumber());
1:                             }
1:                         }
1: 					}
1: 
1: 					allocPage.unlatch();
1: 				}
1: 			}
1: 			// always get the last alloc page to see if the number of alloc
1: 			// pages remain the same
1: 			long pagenum = extentPageNums[numExtents-1];
1: 			while (!isValid)
1: 			{
1: 				AllocPage allocPage = (AllocPage)handle.getAllocPage(pagenum);
1: 
1: 				if (extents[numExtents-1] == null)
1: 					setArrays(numExtents-1, allocPage);
1: 
1: 				if (!allocPage.isLast())
1: 				{
1: 					growArrays(++numExtents);
1: 					pagenum = allocPage.getNextAllocPageNumber();
1: 				}
1: 				else
1: 					isValid = true;
1: 
1: 				allocPage.unlatch();
1: 			}
1: 		}
1: 	}
1: 
1: 	/* shorthand to set the 4 array values */
1: 	private void setArrays(int i, AllocPage allocPage)
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:             {
1:                 SanityManager.DEBUG(
1:                     FileContainer.SPACE_TRACE, 
1:                     "Alloc page " + i + " at " + allocPage.getPageNumber() + 
1:                     " updated");
1:             }
1:         }
1: 
1: 		AllocExtent extent = allocPage.getAllocExtent();
1: 		extents[i] = extent;
1: 		lowRange[i] = extent.getFirstPagenum();
1: 		hiRange[i] = extent.getLastPagenum();
1: 		extentPageNums[i] = allocPage.getPageNumber();
1: 	}
1: 
1: 	/* shorthand to grow the 4 arrays to the desired size */
1: 	private void growArrays(int size)
1: 	{
1: 		int oldLength;
1: 
1: 		if (lowRange == null || lowRange.length == 0)
1: 			oldLength = 0;
1: 		else 
1: 			oldLength = lowRange.length;
1: 
1: 		if (oldLength >= size)	// no need to grow
1: 			return;
1: 
1: 		long[] saveLow = lowRange;
1: 		long[] saveHi = hiRange;
1: 		AllocExtent[] saveExtents = extents;
1: 		boolean[] saveDirty = isDirty;
1: 		long[] savePageNums = extentPageNums;
1: 
1: 		lowRange = new long[size];
1: 		hiRange = new long[size];
1: 		isDirty = new boolean[size];
1: 		extents = new AllocExtent[size];
1: 		extentPageNums = new long[size];
1: 
1: 		if (oldLength > 0)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(oldLength == saveHi.length);
1: 				SanityManager.ASSERT(oldLength == saveExtents.length);
1: 				SanityManager.ASSERT(oldLength == savePageNums.length);
1: 			}
1: 			System.arraycopy(saveLow, 	  0, lowRange, 	0, saveLow.length);
1: 			System.arraycopy(saveHi,	  0, hiRange, 	0, saveHi.length);
1: 			System.arraycopy(saveDirty,	  0, isDirty,   0, saveDirty.length);
1: 			System.arraycopy(saveExtents, 0, extents,	0, saveExtents.length);
1: 			System.arraycopy(savePageNums,0,extentPageNums,0, savePageNums.length);
1: 		}
1: 
1: 		for (int i = oldLength; i < size; i++)
1: 		{
1: 			lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 			hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 			isDirty[i] = false;
1: 			extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
1: 			extents[i] = null;
1: 		}
1: 	}
1: 
1: 	/** 
1: 	  dump the allocation cache information
1: 	*/
1: 	protected void dumpAllocationCache()
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
1:             {
1:                 SanityManager.DEBUG(FileContainer.SPACE_TRACE, 
1:                                     "Allocation cache is " + 
1:                                     (isValid ? "Valid" : "Invalid"));
1:                 for (int i = 0; i < numExtents; i++)
1:                 {
1:                     SanityManager.DEBUG(
1:                         FileContainer.SPACE_TRACE, 
1:                         "Extent " + i + " at " + extentPageNums[i] +
1:                         " range is " + lowRange[i] + " to " + hiRange[i]);
1: 
1:                     if (extents[i] == null)
1:                     {
1:                         SanityManager.DEBUG(
1:                             FileContainer.SPACE_TRACE, "extent is null");
1:                     }
1:                     else
1:                     {
1:                         SanityManager.DEBUG(
1:                             FileContainer.SPACE_TRACE, 
1:                             extents[i].toDebugString());
1:                     }
1:                 }
1:             }
1:         }
1: 	}
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.data
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.data;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: 
0: import org.apache.derby.impl.store.raw.data.BaseContainerHandle;
0: /**
0: 	An auxiliary object to cache the allocation information for a file container.
0: 	<B>Only a FileContainer should use this object</B>
0: 	<P>
0: 	The allocation cache contains an array of AllocExtents and 3 arrays of longs:
0: 	<OL><LI>ExtentPageNums[i] is the page number of the i'th extent
0: 	<LI>lowRange[i] is the smallest page number managed by extent i
0: 	<LI>hiRange[i] is the largest page number managed by extent i
0: 	</OL>
0: 	<P>
0: 	Note thate extentPageNums and lowRange does not change once the extent has
0: 	been created, but hiRange will change for the last extent as more pages are
0: 	allocated.
0: 	<P>
0: 	Extents can be individually invalidated or the entire cache (all extends)
0: 	can be invalidated at once.
0: 	<P> MT - unsafe
0:     Synrhonized access to all methods must be enforced by the caller of 
0: 	AllocationCache
0: */
0: class AllocationCache
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private int numExtents;
0: 	private long[] lowRange;	// lowRange[i] to hiRange[i] defines the
0: 	private long[] hiRange;		// smallest and largest logical page number
0: 								// manages by extent i
0: 
0: 	private boolean[] isDirty;	// changes to the in memory allocation cache
0: 	private AllocExtent[] extents;
0: 	private long[] extentPageNums;
0: 	private boolean isValid;
0: 
0: 	protected AllocationCache()
0: 	{
0: 		numExtents = 0;
0: 		isValid = false;
0: 	}
0: 
0: 	/* reset the allocation cache in case when filecontainer object is reused */
0: 	protected void reset()
0: 	{
0: 		numExtents = 0;
0: 		isValid = false;
0: 
0: 		if (lowRange != null)
0: 		{
0: 			for (int i = 0; i < lowRange.length; i++)
0: 			{
0: 				lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 				hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 				extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 				extents[i] = null;
0: 				isDirty[i] = false;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Get the page number for the allocation page that is managing this page number
0: 	*/
0: 	protected long getAllocPageNumber(BaseContainerHandle handle, 
0: 								   long pageNumber, 
0: 								   long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		// try to see if we can figure this out without validating the cache
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
0: 				return extentPageNums[i];
0: 		}
0: 
0: 		if (!isValid)
0: 		{
0: 			/* can't find the page. Validate the cache first, then try to find it again */
0: 			validate(handle, firstAllocPageNumber);
0: 			
0: 			for (int i = 0; i < numExtents; i++)
0: 			{
0: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
0: 					return extentPageNums[i];
0: 			}
0: 		}
0: 		return ContainerHandle.INVALID_PAGE_NUMBER;
0: 	}
0: 
0: 	/**
0: 	  Get the last (allocated) page of the container
0: 	  */
0: 	protected long getLastPageNumber(BaseContainerHandle handle, long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		if (!isValid)
0: 			validate(handle, firstAllocPageNumber);
0: 		return hiRange[numExtents-1];
0: 	}
0: 
0: 	/**
0: 	  Set the page number to be unfilled
0: 	 */
0: 	protected void trackUnfilledPage(long pagenumber, boolean unfilled)
0: 	{
0: 		// do not validate the alloc cache just for the purpose of updating the
0: 		// unfilled bit
0: 		if (!isValid ||  numExtents <= 0)
0: 		{
0: 			return;
0: 		}
0: 
0: 		// we are calling this without getting the allocCache semaphore - be
0: 		// careful that extents[i] will go null at any time.
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (lowRange[i] <= pagenumber && pagenumber <= hiRange[i])
0: 			{
0: 				AllocExtent ext = extents[i];
0: 				if (ext != null &&
0: 					ext.trackUnfilledPage(pagenumber, unfilled) &&
0: 					extents[i] != null)
0: 				{
0: 					isDirty[i] = true;
0: 				}
0: 					
0: 				break;
0: 			}
0: 		}
0: 	}
0: 
0: 	protected long getUnfilledPageNumber(BaseContainerHandle handle, 
0: 										 long firstAllocPageNumber,
0: 										 long pagenum)
0: 		 throws StandardException
0: 	{
0: 		// get the next unfilled page number
0: 		if (!isValid)
0: 		{
0: 			validate(handle, firstAllocPageNumber);
0: 		}
0: 
0: 		if (pagenum == ContainerHandle.INVALID_PAGE_NUMBER)
0: 		{
0: 			for (int i = 0; i < numExtents; i++)
0: 			{
0: 				if (extents[i] != null)
0: 					return extents[i].getUnfilledPageNumber(pagenum);
0: 			}
0: 		}
0: 		else
0: 		{
0: 			for (int i = 0; i < numExtents; i++)
0: 			{
0: 				if (pagenum <= hiRange[i])
0: 				{
0: 					if (extents[i] != null)
0: 						return extents[i].getUnfilledPageNumber(pagenum);
0: 				}
0: 			}
0: 		}
0: 
0: 		return ContainerHandle.INVALID_PAGE_NUMBER;
0: 	}
0: 
0:     /**
0:     returns estimated number of allocated pages
0:     **/
0: 	protected long getEstimatedPageCount(BaseContainerHandle handle,
0: 										 long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		if (!isValid)
0: 			validate(handle, firstAllocPageNumber);
0: 
0: 		long estPageCount = 0;
0: 
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (extents[i] != null)
0: 				estPageCount += extents[i].getAllocatedPageCount();
0: 		}
0: 		return estPageCount;
0: 	}
0: 
0: 
0:     protected SpaceInformation getAllPageCounts(
0:         BaseContainerHandle handle,
0:         long firstAllocPageNumber)
0: 		    throws StandardException
0:     {
0:         long currAllocPages = 0;
0:         long numAllocatedPages = 0;
0:         long numFreePages = 0;
0:         long numUnfilledPages = 0;
0: 
0: 		if (!isValid)
0: 			validate(handle, firstAllocPageNumber);
0: 
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (extents[i] != null)
0:             {
0:                 currAllocPages = extents[i].getAllocatedPageCount();
0: 				numAllocatedPages += currAllocPages;
0:                 numUnfilledPages += extents[i].getUnfilledPageCount();
0:                 numFreePages += (extents[i].getTotalPageCount() - currAllocPages);
0:             }
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(numUnfilledPages <= numAllocatedPages,
0:                     "more unfilled pages than allocated pages on extent ");
0: 		}
0:         return new SpaceInformation(
0:             numAllocatedPages,
0:             numFreePages,
0:             numUnfilledPages);
0:     }
0: 
0: 
0: 	/* invalidate all extents */
0: 	protected void invalidate()
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0:             {
0:                 SanityManager.DEBUG(
0:                     FileContainer.SPACE_TRACE, "alloc cache invalidated");
0:             }
0:         }
0: 
0: 
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			isDirty[i] = false;
0: 			extents[i] = null;
0: 		}
0: 
0: 		isValid = false;
0: 
0: 	}
0: 
0: 	/* invalidate the extent that is managed by this alloc page */
0: 	protected void invalidate(AllocPage allocPage, long allocPagenum)
0: 		 throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0:             {
0:                 SanityManager.DEBUG(
0:                     FileContainer.SPACE_TRACE, "alloc cache for page " + 
0:                     allocPagenum + " invalidated");
0:             }
0:         }
0: 
0: 		isValid = false;
0: 
0: 		if (numExtents == 0)
0: 			return;
0: 
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (extentPageNums[i] == allocPagenum)
0: 			{
0: 				// update unfilled page info
0: 				if (allocPage != null && extents[i] != null &&
0: 					isDirty[i])
0: 				{
0: 					// replace unFilledPage bitmap with the one in the allocation
0: 					// cache, which has the more current information
0: 					// call this ONLY in invalidate, when the reference to the
0: 					// extent is about to be nulled out
0: 					allocPage.updateUnfilledPageInfo(extents[i]);
0: 					isDirty[i] = false;
0: 				}
0: 
0: 				extents[i] = null;
0: 				return;
0: 			}
0: 		}
0: 
0: 		// handle the case where a new alloc page that has never been entered
0: 		// into the cache is asked to be invalidated
0: 		if (allocPagenum > hiRange[numExtents-1])
0: 			return;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("cannot find extent managed by " +
0: 									  allocPagenum);
0: 
0: 
0: 	}
0: 
0: 	/* invalidate the last extent */
0: 	protected void invalidateLastExtent()
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0:             {
0:                 SanityManager.DEBUG(
0:                     FileContainer.SPACE_TRACE,
0:                         "last extent (" + extentPageNums[numExtents-1] + 
0:                             ") invalidated");
0:             }
0:         }
0: 
0: 		isValid = false;
0: 
0: 		if (numExtents > 0)
0: 			extents[numExtents - 1] = null;
0: 	}
0: 
0: 	/**
0: 	  Get the last valid page of the file container.  A valid page is one that
0: 	  is not deallocated or freed.
0: 	*/
0: 	protected long getLastValidPage(BaseContainerHandle handle,
0: 									long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		AllocExtent extent = null;
0: 		int extentNumber;
0: 		long lastValidPageNumber = ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 		if (!isValid)
0: 			validate(handle, firstAllocPageNumber);
0: 
0: 		if (numExtents == 0)	// no extent at all, no page in the container
0: 			return ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 		// start from the last extent, goes backward till a valid page is found
0: 
0: 		for (extentNumber = numExtents-1;
0: 			 extentNumber >= 0;
0: 			 extentNumber--)
0: 		{
0: 			extent = extents[extentNumber];
0: 			lastValidPageNumber = extent.getLastValidPageNumber();
0: 			if (lastValidPageNumber != ContainerHandle.INVALID_PAGE_NUMBER)
0: 				break;
0: 		}
0: 		return lastValidPageNumber;
0: 	}
0: 
0: 	/*
0: 	  Get the next page (after pageNumber) that is valid 
0: 	  */
0: 	protected long getNextValidPage(BaseContainerHandle handle, 
0: 									long pageNumber, 
0: 									long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		int extentNumber;
0: 
0: 		if (!isValid)
0: 			validate(handle, firstAllocPageNumber);
0: 
0: 		if (numExtents == 0)	// no extent at all, no page in the container
0: 			return ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 		// find the extent whose hiRange is > pageNumber.  Most of the time,
0: 		// this is the extent this pageNumber is in, but some times, when
0: 		// pageNumber == hiRange of extent i, extent i+1 is found.
0: 		AllocExtent extent = null;
0: 		for (extentNumber = 0; extentNumber < numExtents; extentNumber++)
0: 		{
0: 			if (pageNumber < hiRange[extentNumber])
0: 			{
0: 				extent = extents[extentNumber];
0: 				break;
0: 			}
0: 		}
0: 
0: 		if (extent == null)		// extent has been invalidated or not there
0: 		{
0: 			// the cache is valid and up to date, 
0: 			// the only reason why we cannot find an extent is if this is the
0: 			// last valid page of the container
0: 			return ContainerHandle.INVALID_PAGE_NUMBER;
0: 		}
0: 
0: 		// extent == extents[extentNumber]
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(extent == extents[extentNumber]);
0: 
0: 		// we found an extent which may contain a valid page that is of higher
0: 		// pagenumber than the passed in page number.  Still need to walk the
0: 		// extent array to make sure 
0: 
0: 		long nextValidPage = ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0: 		while(extentNumber < numExtents)
0: 		{
0: 			extent = extents[extentNumber] ;
0: 			nextValidPage = extent.getNextValidPageNumber(pageNumber);
0: 			if (nextValidPage != ContainerHandle.INVALID_PAGE_NUMBER)
0: 				break;
0: 
0: 			extentNumber++;
0: 		}
0: 		return nextValidPage;
0: 
0: 	}
0: 
0: 	/**
0: 	  Get the page status of a page
0: 	*/
0: 	protected int getPageStatus(BaseContainerHandle handle, long pageNumber,
0: 								long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		AllocExtent extent = null;
0: 
0: 		for (int i = 0; i < numExtents; i++)
0: 		{
0: 			if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
0: 			{
0: 				extent = extents[i];
0: 				break;
0: 			}
0: 		}
0: 
0: 		if (extent == null)
0: 		{
0: 			if (SanityManager.DEBUG) {
0: 				if (isValid) {
0: 
0: 					SanityManager.DEBUG_PRINT("trace", "Allocation cache is " + 
0: 								(isValid ? "Valid" : "Invalid"));
0: 					
0: 					for (int i = 0; i < numExtents; i++) {
0: 						SanityManager.DEBUG_PRINT("trace", "Extent " + i + " at " + extentPageNums[i] +
0: 										" range is " + lowRange[i] + " to " + hiRange[i]);
0: 						if (extents[i] == null)
0: 							SanityManager.DEBUG_PRINT("trace", "extent is null");
0: 						else
0: 							SanityManager.DEBUG_PRINT("trace", extents[i].toDebugString());
0: 
0: 					}
0: 
0: 					SanityManager.THROWASSERT("valid cache cannot find page "+pageNumber);
0: 				}
0: 			}
0: 
0: 			if (!isValid)
0: 				validate(handle, firstAllocPageNumber);
0: 			// try again
0: 
0: 			for (int i = 0; i < numExtents; i++)
0: 			{
0: 				if (lowRange[i] <= pageNumber && pageNumber <= hiRange[i])
0: 				{
0: 					extent = extents[i];
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (SanityManager.DEBUG)
0: 				if (extent == null)
0: 					SanityManager.THROWASSERT("valid cache cannot find page " +
0: 												pageNumber);
0: 		}
0: 
0: 		return extent.getPageStatus(pageNumber);
0: 	}
0: 
0: 	/**
0: 	  Validate the cache, find all alloc pages and fill in the arrays
0: 	  */
0: 	private void validate(BaseContainerHandle handle, long firstAllocPageNumber)
0: 		 throws StandardException
0: 	{
0: 		if (numExtents == 0)	// never been initialized, read it all in
0: 		{
0: 			long pagenum = firstAllocPageNumber;
0: 
0: 			while(!isValid)
0: 			{
0: 				growArrays(++numExtents);
0: 
0: 				Object obj = handle.getAllocPage(pagenum);
0: 
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					if (obj == null)
0: 						SanityManager.THROWASSERT(
0: 							"cannot find " + numExtents +
0: 							" alloc page at " + pagenum);
0: 					if ( ! (obj instanceof AllocPage))
0: 						SanityManager.THROWASSERT(
0: 							"page at " + pagenum +
0: 							" is not an allocPage, is a " +
0: 							obj.getClass().getName());
0: 				}	
0: 
0: 				AllocPage allocPage = (AllocPage)obj;
0: 				setArrays(numExtents-1, allocPage);
0: 
0: 				if (allocPage.isLast())
0: 					isValid = true;
0: 				else
0: 					// get next alloc page
0: 					pagenum = allocPage.getNextAllocPageNumber();
0: 
0: 				allocPage.unlatch();
0: 			}
0: 		}
0: 		else		// has been initialized before, but is now invalidated
0: 		{
0: 			for (int i = 0; i < numExtents-1; i++)
0: 			{
0: 				if (extents[i] == null)	// reinitialize this extent
0: 				{
0: 					AllocPage allocPage = 
0:                         (AllocPage)handle.getAllocPage(extentPageNums[i]);
0: 
0: 					setArrays(i, allocPage);
0: 
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						if (i < numExtents-1)
0:                         {
0:                             if (extentPageNums[i+1] != 
0:                                     allocPage.getNextAllocPageNumber())
0:                             {
0:                                 SanityManager.THROWASSERT(
0:                                     "bad alloc page - " +
0:                                     ";extentPageNums[i+1] = " + 
0:                                         extentPageNums[i+1] +
0:                                     ";allocPage.getNextAllocPageNumber() = " + 
0:                                         allocPage.getNextAllocPageNumber());
0:                             }
0:                         }
0: 					}
0: 
0: 					allocPage.unlatch();
0: 				}
0: 			}
0: 			// always get the last alloc page to see if the number of alloc
0: 			// pages remain the same
0: 			long pagenum = extentPageNums[numExtents-1];
0: 			while (!isValid)
0: 			{
0: 				AllocPage allocPage = (AllocPage)handle.getAllocPage(pagenum);
0: 
0: 				if (extents[numExtents-1] == null)
0: 					setArrays(numExtents-1, allocPage);
0: 
0: 				if (!allocPage.isLast())
0: 				{
0: 					growArrays(++numExtents);
0: 					pagenum = allocPage.getNextAllocPageNumber();
0: 				}
0: 				else
0: 					isValid = true;
0: 
0: 				allocPage.unlatch();
0: 			}
0: 		}
0: 	}
0: 
0: 	/* shorthand to set the 4 array values */
0: 	private void setArrays(int i, AllocPage allocPage)
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0:             {
0:                 SanityManager.DEBUG(
0:                     FileContainer.SPACE_TRACE, 
0:                     "Alloc page " + i + " at " + allocPage.getPageNumber() + 
0:                     " updated");
0:             }
0:         }
0: 
0: 		AllocExtent extent = allocPage.getAllocExtent();
0: 		extents[i] = extent;
0: 		lowRange[i] = extent.getFirstPagenum();
0: 		hiRange[i] = extent.getLastPagenum();
0: 		extentPageNums[i] = allocPage.getPageNumber();
0: 	}
0: 
0: 	/* shorthand to grow the 4 arrays to the desired size */
0: 	private void growArrays(int size)
0: 	{
0: 		int oldLength;
0: 
0: 		if (lowRange == null || lowRange.length == 0)
0: 			oldLength = 0;
0: 		else 
0: 			oldLength = lowRange.length;
0: 
0: 		if (oldLength >= size)	// no need to grow
0: 			return;
0: 
0: 		long[] saveLow = lowRange;
0: 		long[] saveHi = hiRange;
0: 		AllocExtent[] saveExtents = extents;
0: 		boolean[] saveDirty = isDirty;
0: 		long[] savePageNums = extentPageNums;
0: 
0: 		lowRange = new long[size];
0: 		hiRange = new long[size];
0: 		isDirty = new boolean[size];
0: 		extents = new AllocExtent[size];
0: 		extentPageNums = new long[size];
0: 
0: 		if (oldLength > 0)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(oldLength == saveHi.length);
0: 				SanityManager.ASSERT(oldLength == saveExtents.length);
0: 				SanityManager.ASSERT(oldLength == savePageNums.length);
0: 			}
0: 			System.arraycopy(saveLow, 	  0, lowRange, 	0, saveLow.length);
0: 			System.arraycopy(saveHi,	  0, hiRange, 	0, saveHi.length);
0: 			System.arraycopy(saveDirty,	  0, isDirty,   0, saveDirty.length);
0: 			System.arraycopy(saveExtents, 0, extents,	0, saveExtents.length);
0: 			System.arraycopy(savePageNums,0,extentPageNums,0, savePageNums.length);
0: 		}
0: 
0: 		for (int i = oldLength; i < size; i++)
0: 		{
0: 			lowRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 			hiRange[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 			isDirty[i] = false;
0: 			extentPageNums[i] = ContainerHandle.INVALID_PAGE_NUMBER;
0: 			extents[i] = null;
0: 		}
0: 	}
0: 
0: 	/** 
0: 	  dump the allocation cache information
0: 	*/
0: 	protected void dumpAllocationCache()
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON(FileContainer.SPACE_TRACE))
0:             {
0:                 SanityManager.DEBUG(FileContainer.SPACE_TRACE, 
0:                                     "Allocation cache is " + 
0:                                     (isValid ? "Valid" : "Invalid"));
0:                 for (int i = 0; i < numExtents; i++)
0:                 {
0:                     SanityManager.DEBUG(
0:                         FileContainer.SPACE_TRACE, 
0:                         "Extent " + i + " at " + extentPageNums[i] +
0:                         " range is " + lowRange[i] + " to " + hiRange[i]);
0: 
0:                     if (extents[i] == null)
0:                     {
0:                         SanityManager.DEBUG(
0:                             FileContainer.SPACE_TRACE, "extent is null");
0:                     }
0:                     else
0:                     {
0:                         SanityManager.DEBUG(
0:                             FileContainer.SPACE_TRACE, 
0:                             extents[i].toDebugString());
0:                     }
0:                 }
0:             }
0:         }
0: 	}
0: 
0: }
0: 
============================================================================