1:eac0369: /*
1:2d3677b: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CreateAliasNode
1:75a4806: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:9ed7c4d: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:703bc91: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:345de35: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:345de35: 
1:e33b8d8: import java.sql.Types;
1:22d64f5: import java.util.List;
1:eac0369: import org.apache.derby.catalog.AliasInfo;
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:22d64f5: import org.apache.derby.catalog.types.AggregateAliasInfo;
1:eac0369: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:582425f: import org.apache.derby.catalog.types.SynonymAliasInfo;
1:fa292b9: import org.apache.derby.catalog.types.UDTAliasInfo;
1:afe6225: import org.apache.derby.iapi.error.StandardException;
1:afe6225: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:22d64f5: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:afe6225: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:afe6225: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:afe6225: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:afe6225: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:afe6225: import org.apache.derby.iapi.types.TypeId;
1:345de35: 
1:2d3677b: /**
1:eac0369:  * A CreateAliasNode represents a CREATE ALIAS statement.
3:eac0369:  *
1:2d3677b:  */
31:eac0369: 
1:3bb140c: class CreateAliasNode extends DDLStatementNode
1:fa292b9: {
1:9f4b339:     // indexes into routineElements
1:9f4b339:     public static final int PARAMETER_ARRAY = 0;
1:9f4b339:     public static final int TABLE_NAME = PARAMETER_ARRAY + 1;
1:9f4b339:     public static final int DYNAMIC_RESULT_SET_COUNT = TABLE_NAME + 1;
1:9f4b339:     public static final int LANGUAGE = DYNAMIC_RESULT_SET_COUNT + 1;
1:9f4b339:     public static final int EXTERNAL_NAME = LANGUAGE + 1;
1:9f4b339:     public static final int PARAMETER_STYLE = EXTERNAL_NAME + 1;
1:9f4b339:     public static final int SQL_CONTROL = PARAMETER_STYLE + 1;
1:9f4b339:     public static final int DETERMINISTIC = SQL_CONTROL + 1;
1:9f4b339:     public static final int NULL_ON_NULL_INPUT = DETERMINISTIC + 1;
1:9f4b339:     public static final int RETURN_TYPE = NULL_ON_NULL_INPUT + 1;
1:9f60172:     public static final int ROUTINE_SECURITY_DEFINER = RETURN_TYPE + 1;
1:f9596d4:     public static final int VARARGS = ROUTINE_SECURITY_DEFINER + 1;
1:9f60172: 
1:9f60172:     // Keep ROUTINE_ELEMENT_COUNT last (determines set cardinality).
1:9f60172:     // Note: Remember to also update the map ROUTINE_CLAUSE_NAMES in
1:9f60172:     // sqlgrammar.jj when elements are added.
1:f9596d4:     public static final int ROUTINE_ELEMENT_COUNT = VARARGS + 1;
1:9f60172: 
1:22d64f5:     //
1:22d64f5:     // These are the names of 1-arg builtin functions which are represented in the
1:22d64f5:     // grammar as non-reserved keywords. These names may not be used as
1:22d64f5:     // the unqualified names of user-defined aggregates.
1:22d64f5:     //
1:22d64f5:     // If additional 1-arg builtin functions are added to the grammar, they should
1:22d64f5:     // be put in this table.
1:22d64f5:     //
1:22d64f5:     private static  final   String[]  NON_RESERVED_FUNCTION_NAMES =
1:22d64f5:     {
1:22d64f5:         "ABS",
1:22d64f5:         "ABSVAL",
1:22d64f5:         "DATE",
1:22d64f5:         "DAY",
1:22d64f5:         "LCASE",
1:22d64f5:         "LENGTH",
1:22d64f5:         "MONTH",
1:22d64f5:         "SQRT",
1:22d64f5:         "TIME",
1:22d64f5:         "TIMESTAMP",
1:22d64f5:         "UCASE",
1:22d64f5:     };
1:22d64f5: 
1:22d64f5:     //
1:22d64f5:     // These are aggregate names defined by the SQL Standard which do not
1:22d64f5:     // behave as reserved keywords in Derby.
1:22d64f5:     //
1:22d64f5:     private static  final   String[]    NON_RESERVED_AGGREGATES =
1:22d64f5:     {
1:22d64f5:         "COLLECT",
1:22d64f5:         "COUNT",
1:22d64f5:         "EVERY",
1:22d64f5:         "FUSION",
1:22d64f5:         "INTERSECTION",
1:22d64f5:         "STDDEV_POP",
1:22d64f5:         "STDDEV_SAMP",
1:22d64f5:         "VAR_POP",
1:22d64f5:         "VAR_SAMP",
1:22d64f5:     };
1:22d64f5: 
1:22d64f5:     // aggregate arguments
1:22d64f5:     public  static  final   int AGG_FOR_TYPE = 0;
1:22d64f5:     public  static  final   int AGG_RETURN_TYPE = AGG_FOR_TYPE + 1;
1:22d64f5:     public  static  final   int AGG_ELEMENT_COUNT = AGG_RETURN_TYPE + 1;
1:22d64f5: 
1:703bc91: 	private String				javaClassName;
1:703bc91: 	private String				methodName;
1:703bc91: 	private char				aliasType; 
1:9f4b339: 
1:eac0369: 	private AliasInfo aliasInfo;
1:d66ce7b: 
1:eac0369: 
3:eac0369: 	/**
1:3bb140c:      * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param aliasName				The name of the alias
1:3bb140c:      * @param targetObject          Target name string or, if
1:3bb140c:      *        aliasType == ALIAS_TYPE_SYNONYM_AS_CHAR, a TableName
1:eac0369: 	 * @param methodName		    The method name
1:3bb140c:      * @param aliasSpecificInfo     An array of objects, see code for
1:3bb140c:      *                              interpretation
1:3bb140c:      * @param cm                    The context manager
1:3bb140c:      * @exception StandardException Thrown on error
1:eac0369: 	 */
1:3bb140c:     CreateAliasNode(    TableName aliasName,
1:582425f: 						Object targetObject,
1:3bb140c:                         String methodName,
1:eac0369: 						Object aliasSpecificInfo,
1:3bb140c:                         char aliasType,
1:3bb140c:                         ContextManager cm)
1:2d3677b: 		throws StandardException
8:eac0369: 	{		
1:3bb140c:         super(aliasName, cm);
1:3bb140c:         this.aliasType = aliasType;
1:eac0369: 
1:eac0369: 		switch (this.aliasType)
1:eac0369: 		{
1:22d64f5: 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:22d64f5: 				this.javaClassName = (String) targetObject;
1:22d64f5: 
1:22d64f5: 				Object[] aggElements = (Object[]) aliasSpecificInfo;
1:0acf797:                 TypeDescriptor  aggForType = bindUserCatalogType( (TypeDescriptor) aggElements[ AGG_FOR_TYPE ] );
1:0acf797:                 TypeDescriptor  aggReturnType = bindUserCatalogType( (TypeDescriptor) aggElements[ AGG_RETURN_TYPE ] );
1:22d64f5: 
1:f798a41:                 // XML not allowed because SQLXML support has not been implemented
1:f798a41:                 if (
1:e33b8d8:                     (aggForType.getJDBCTypeId() == Types.SQLXML) ||
1:e33b8d8:                     (aggReturnType.getJDBCTypeId() == Types.SQLXML)
1:f798a41:                    )
1:f798a41:                 {
1:f798a41:                     throw StandardException.newException( SQLState.LANG_XML_NOT_ALLOWED_DJRS );
1:f798a41:                 }
1:f798a41: 
1:22d64f5: 				aliasInfo = new AggregateAliasInfo( aggForType, aggReturnType );
1:22d64f5: 				implicitCreateSchema = true;
1:22d64f5:                 break;
1:22d64f5:                 
1:fa292b9: 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1:fa292b9: 				this.javaClassName = (String) targetObject;
1:fa292b9: 				aliasInfo = new UDTAliasInfo();
1:d039ced: 
1:fa292b9: 				implicitCreateSchema = true;
1:fa292b9:                 break;
1:fa292b9:                 
2:eac0369: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
2:eac0369: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1:2d3677b: 			{
1:582425f: 				this.javaClassName = (String) targetObject;
1:3bb140c:                 this.methodName = methodName;
1:fa292b9: 
1:eac0369: 				//routineElements contains the description of the procedure.
1:eac0369: 				// 
1:eac0369: 				// 0 - Object[] 3 element array for parameters
1:eac0369: 				// 1 - TableName - specific name
1:eac0369: 				// 2 - Integer - dynamic result set count
1:eac0369: 				// 3 - String language (always java) - ignore
1:eac0369: 				// 4 - String external name (also passed directly to create alias node - ignore
1:eac0369: 				// 5 - Integer parameter style 
1:eac0369: 				// 6 - Short - SQL control
1:9f4b339: 				// 7 - Boolean - whether the routine is DETERMINISTIC
1:9f4b339: 				// 8 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
1:9f4b339: 				// 9 - TypeDescriptor - return type (always NULL for procedures)
1:2d3677b: 
1:eac0369: 				Object[] routineElements = (Object[]) aliasSpecificInfo;
1:9f4b339: 				Object[] parameters = (Object[]) routineElements[PARAMETER_ARRAY];
1:47d4a4c: 				int paramCount = ((List) parameters[0]).size();
1:2d3677b: 				
1:703bc91: 				// Support for Java signatures in Derby was added in 10.1
1:703bc91: 				// Check to see the catalogs have been upgraded to 10.1 before
1:703bc91: 				// accepting such a method name for a routine. Otherwise
1:703bc91: 				// a routine that works in 10.1 soft upgrade mode would
1:703bc91: 				// exist when running 10.0 but not resolve to anything.
1:703bc91: 				if (this.methodName.indexOf('(') != -1)
1:2d3677b: 				{
1:703bc91: 					getDataDictionary().checkVersion(
1:703bc91: 							DataDictionary.DD_VERSION_DERBY_10_1,
1:703bc91:                             "EXTERNAL NAME 'class.method(<signature>)'");
1:2d3677b: 					
1:2d3677b: 				}
1:2d3677b: 
1:eac0369: 				String[] names = null;
1:eac0369: 				TypeDescriptor[] types = null;
1:eac0369: 				int[] modes = null;
1:703bc91: 				
1:eac0369: 				if (paramCount != 0) {
1:703bc91: 
1:a784994:                     names = new String[paramCount];
1:a784994:                     types = new TypeDescriptor[paramCount];
1:eac0369: 					modes = new int[paramCount];
1:a784994: 
1:eac0369: 					for (int i = 0; i < paramCount; i++) {
1:a784994:                         names[i] = (String) ((List) parameters[0]).get(i);
1:a784994:                         types[i] = (TypeDescriptor) ((List) parameters[1]).get(i);
1:47d4a4c:                         int currentMode =  ((Integer) (((List) parameters[2]).get(i))).intValue();
1:75a4806:                         modes[i] = currentMode;
1:75a4806:   
1:75a4806:                         //
1:94df7fb:                         // We still don't support XML values as parameters.
1:75a4806:                         // Presumably, the XML datatype would map to a JDBC java.sql.SQLXML type.
1:75a4806:                         // We have no support for that type today.
1:75a4806:                         //
1:75a4806:                         if ( !types[ i ].isUserDefinedType() )
1:75a4806:                         {
1:94df7fb:                             if (TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isXMLTypeId())
1:75a4806:                             { throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, names[i]); }
1:75a4806:                         }
1:75a4806:                     }
1:eac0369: 
1:eac0369: 					if (paramCount > 1) {
1:eac0369: 						String[] dupNameCheck = new String[paramCount];
1:eac0369: 						System.arraycopy(names, 0, dupNameCheck, 0, paramCount);
1:eac0369: 						java.util.Arrays.sort(dupNameCheck);
1:eac0369: 						for (int dnc = 1; dnc < dupNameCheck.length; dnc++) {
1:37a2f5e: 							if (! dupNameCheck[dnc].equals("") && dupNameCheck[dnc].equals(dupNameCheck[dnc - 1]))
1:eac0369: 								throw StandardException.newException(SQLState.LANG_DB2_DUPLICATE_NAMES, dupNameCheck[dnc], getFullName());
1:2d3677b: 						}
1:2d3677b: 					}
1:2d3677b: 				}
1:eac0369: 
1:9f4b339: 				Integer drso = (Integer) routineElements[DYNAMIC_RESULT_SET_COUNT];
1:eac0369: 				int drs = drso == null ? 0 : drso.intValue();
1:eac0369: 
1:eac0369: 				short sqlAllowed;
1:9f4b339: 				Short sqlAllowedObject = (Short) routineElements[SQL_CONTROL];
1:eac0369: 				if (sqlAllowedObject != null)
1:eac0369: 					sqlAllowed = sqlAllowedObject.shortValue();
1:eac0369: 				else
1:eac0369: 					sqlAllowed = (this.aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR ?
1:eac0369: 					RoutineAliasInfo.MODIFIES_SQL_DATA : RoutineAliasInfo.READS_SQL_DATA);
1:eac0369: 
1:9f4b339: 				Boolean isDeterministicO = (Boolean) routineElements[DETERMINISTIC];
1:9f4b339:                 boolean isDeterministic = (isDeterministicO == null) ? false : isDeterministicO.booleanValue();
1:9f4b339: 
1:f9596d4: 				Boolean hasVarargsO = (Boolean) routineElements[ VARARGS ];
1:f9596d4:                 boolean hasVarargs = (hasVarargsO == null) ? false : hasVarargsO.booleanValue();
1:f9596d4: 
1:9f60172:                 Boolean definersRightsO =
1:9f60172:                     (Boolean) routineElements[ROUTINE_SECURITY_DEFINER];
1:9f60172:                 boolean definersRights  =
1:9f60172:                     (definersRightsO == null) ? false :
1:9f60172:                     definersRightsO.booleanValue();
1:9f60172: 
1:9f4b339: 				Boolean calledOnNullInputO = (Boolean) routineElements[NULL_ON_NULL_INPUT];
1:eac0369: 				boolean calledOnNullInput;
1:eac0369: 				if (calledOnNullInputO == null)
1:eac0369: 					calledOnNullInput = true;
1:eac0369: 				else
1:eac0369: 					calledOnNullInput = calledOnNullInputO.booleanValue();
1:eac0369: 
1:d039ced:                 // bind the return type if it is a user defined type. this fills
1:d039ced:                 // in the class name.
1:d039ced:                 TypeDescriptor returnType = (TypeDescriptor) routineElements[RETURN_TYPE];
1:d039ced:                 if ( returnType != null )
1:d039ced:                 {
1:d039ced:                     DataTypeDescriptor dtd = DataTypeDescriptor.getType( returnType );
1:b4af7da:                     
1:b4af7da:                     dtd = bindUserType( dtd );
1:b4af7da:                     returnType = dtd.getCatalogType();
1:d039ced:                 }
1:d039ced: 
1:9f60172:                 aliasInfo = new RoutineAliasInfo(
1:9f60172:                     this.methodName,
1:9f60172:                     paramCount,
1:9f60172:                     names,
1:9f60172:                     types,
1:9f60172:                     modes,
1:9f60172:                     drs,
1:9f60172:                     // parameter style:
1:9f60172:                     ((Short) routineElements[PARAMETER_STYLE]).shortValue(),
1:9f60172:                     sqlAllowed,
1:9f60172:                     isDeterministic,
1:f9596d4:                     hasVarargs,
1:9f60172:                     definersRights,
1:9f60172:                     calledOnNullInput,
1:9f60172:                     returnType );
1:eac0369: 
1:eac0369: 				implicitCreateSchema = true;
1:d039ced: 				}
1:eac0369: 				break;
1:eac0369: 
1:582425f: 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1:582425f: 				String targetSchema;
1:50b6dfc: 				implicitCreateSchema = true;
1:582425f: 				TableName t = (TableName) targetObject;
1:582425f: 				if (t.getSchemaName() != null)
1:582425f: 					targetSchema = t.getSchemaName();
1:582425f: 				else targetSchema = getSchemaDescriptor().getSchemaName();
1:582425f: 				aliasInfo = new SynonymAliasInfo(targetSchema, t.getTableName());
1:eac0369: 				break;
1:eac0369: 
2:eac0369: 			default:
1:eac0369: 				if (SanityManager.DEBUG)
1:d039ced: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"Unexpected value for aliasType (" + aliasType + ")");
1:2d3677b: 				}
1:703bc91: 		}
10:eac0369: 	}
1:eac0369: 
1:3bb140c:     String statementToString()
1:2d3677b: 	{
1:eac0369: 		switch (this.aliasType)
1:2d3677b: 		{
1:22d64f5: 		case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1:22d64f5: 			return "CREATE DERBY AGGREGATE";
1:fa292b9: 		case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1:fa292b9: 			return "CREATE TYPE";
1:eac0369: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1:eac0369: 			return "CREATE PROCEDURE";
1:582425f: 		case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1:582425f: 			return "CREATE SYNONYM";
1:eac0369: 		default:
1:eac0369: 			return "CREATE FUNCTION";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     
1:eac0369: 	// We inherit the generate() method from DDLStatementNode.
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this CreateAliasNode.  This means doing any static error
1:eac0369: 	 * checking that can be done before actually creating the table.
1:eac0369: 	 * For example, verifying that the column name list does not
1:eac0369: 	 * contain any duplicate column names.
1:afe6225: 	 *
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:703bc91: 	{
1:6229908: 		//Are we dealing with user defined function or procedure?
1:6229908: 		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ||
1:6229908: 				aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) {
1:f9596d4: 
1:f9596d4:             RoutineAliasInfo    rai = (RoutineAliasInfo)aliasInfo;
1:eac0369:             
1:01b5961:             // Set the collation for all string types in parameters
1:01b5961:             // and return types including row multi-sets to be that of
1:01b5961:             // the schema the routine is being defined in.
1:f9596d4:             rai.setCollationTypeForAllStringTypes(
1:01b5961:                     getSchemaDescriptor().getCollationType());
1:01b5961: 
1:d039ced:             bindParameterTypes( (RoutineAliasInfo)aliasInfo );
1:f9596d4: 
1:f9596d4:             if ( rai.hasVarargs() )
1:f9596d4:             {
1:f9596d4:                 switch ( rai.getParameterStyle() )
1:f9596d4:                 {
1:f9596d4:                 case RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET:
1:f9596d4:                 case RoutineAliasInfo.PS_DERBY:
1:f9596d4:                     break;
1:f9596d4: 
1:f9596d4:                 default:
1:f9596d4:                     throw StandardException.newException( SQLState.LANG_VARARGS_PARAMETER_STYLE );
1:f9596d4:                 }
1:f9596d4: 
1:f9596d4:                 if ( rai.getMaxDynamicResultSets() > 0 )
1:f9596d4:                 {
1:f9596d4:                     throw StandardException.newException( SQLState.LANG_VARARGS_RETURN_RESULT_SETS );
1:f9596d4:                 }
1:f9596d4:             }
1:f9596d4: 
1:f9596d4:             if (
1:f9596d4:                 (rai.getParameterStyle() == RoutineAliasInfo.PS_DERBY) &&
1:f9596d4:                 !rai.hasVarargs()
1:f9596d4:                 )
1:f9596d4:             {
1:f9596d4:                 throw StandardException.newException( SQLState.LANG_DERBY_PARAMETER_STYLE );
1:f9596d4:             }
1:eac0369: 		}
1:f2a5622:         
1:f2a5622:         // validity checking for UDTs
1:f2a5622:         if ( aliasType == AliasInfo.ALIAS_TYPE_UDT_AS_CHAR )
1:f2a5622:         {
1:f2a5622:             //
1:f2a5622:             // Make sure that the java class name is not the name of a builtin
1:f2a5622:             // type. This skirts problems caused by logic across the system
1:f2a5622:             // which assumes a tight association between the builtin SQL types
1:f2a5622:             // and the Java classes which implement them.
1:f2a5622:             //
1:f2a5622:             // For security reasons we do not allow the user to bind a UDT
1:f2a5622:             // to a Derby class.
1:f2a5622:             //
1:f2a5622:             TypeId[] allSystemTypeIds = TypeId.getAllBuiltinTypeIds();
1:f2a5622:             int systemTypeCount = allSystemTypeIds.length;
1:f2a5622: 
1:f2a5622:             boolean foundConflict = javaClassName.startsWith( "org.apache.derby." );
1:f2a5622: 
1:f2a5622:             if ( !foundConflict )
1:f2a5622:             {
1:f2a5622:                 for ( int i = 0; i < systemTypeCount; i++ )
1:f2a5622:                 {
1:f2a5622:                     TypeId systemType = allSystemTypeIds[ i ];
1:f2a5622:                     String systemTypeName = systemType.getCorrespondingJavaTypeName();
1:f2a5622:                     
1:f2a5622:                     if ( systemTypeName.equals( javaClassName ) )
1:f2a5622:                     {
1:f2a5622:                         foundConflict = true;
1:f2a5622:                         break;
1:f2a5622:                     }
1:f2a5622:                 }
1:f2a5622:             }
1:f2a5622:             
1:f2a5622:             if ( foundConflict )
1:f2a5622:             {
1:f2a5622:                 throw StandardException.newException
1:f2a5622:                     ( SQLState.LANG_UDT_BUILTIN_CONFLICT, javaClassName );
1:f2a5622:             }
1:f2a5622:             
1:f2a5622:             return;
1:f2a5622:         }
1:f2a5622: 
1:22d64f5:         // validity checking for aggregates
1:22d64f5:         if ( aliasType == AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR ) { bindAggregate(); }
1:22d64f5:         
1:22d64f5: 		// Aggregates, procedures and functions do not check class or method validity until
1:582425f: 		// runtime execution. Synonyms do need some validity checks.
1:582425f: 		if (aliasType != AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
1:fa292b9: 			return;
1:fa292b9: 
1:8a3b297: 		// Don't allow creating synonyms in SESSION schema. Causes confusion if
1:8a3b297: 		// a temporary table is created later with same name.
1:8a3b297: 		if (isSessionSchema(getSchemaDescriptor().getSchemaName()))
1:8a3b297: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:eac0369: 
1:582425f: 		String targetSchema = ((SynonymAliasInfo)aliasInfo).getSynonymSchema();
1:582425f: 		String targetTable = ((SynonymAliasInfo)aliasInfo).getSynonymTable();
1:582425f: 		if (this.getObjectName().equals(targetSchema, targetTable))
1:582425f: 			throw StandardException.newException(SQLState.LANG_SYNONYM_CIRCULAR,
1:582425f: 						this.getFullName(),
1:582425f: 						targetSchema+"."+targetTable);
1:eac0369: 
1:50b6dfc: 		SchemaDescriptor targetSD = getSchemaDescriptor(targetSchema, false);
1:50b6dfc: 		if ((targetSD != null) && isSessionSchema(targetSD))
1:582425f: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
1:eac0369: 
1:fa292b9: 	}
1:eac0369: 
1:22d64f5:     /** Extra logic for binding user-defined aggregate definitions */
1:22d64f5:     private void    bindAggregate() throws StandardException
1:22d64f5:     {
1:22d64f5:         String                      unqualifiedName = getRelativeName();
1:22d64f5: 
1:22d64f5:         //
1:22d64f5:         // A user-defined aggregate cannot have the name of a builtin function which takes 1 argument.
1:22d64f5:         //
1:22d64f5:         SchemaDescriptor    sysfun = getSchemaDescriptor( "SYSFUN", true );
1:3bb140c:         List<AliasDescriptor> systemFunctions =
1:3bb140c:             getDataDictionary().getRoutineList(
1:3bb140c:                 sysfun.getUUID().toString(),
1:3bb140c:                 unqualifiedName,
1:3bb140c:                 AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
1:22d64f5: 
1:22d64f5:         for ( int i = 0; i < systemFunctions.size(); i++ )
1:22d64f5:         {
1:3bb140c:             AliasDescriptor function = systemFunctions.get(i);
1:22d64f5: 
1:22d64f5: 			RoutineAliasInfo routineInfo = (RoutineAliasInfo) function.getAliasInfo();
1:22d64f5: 			int parameterCount = routineInfo.getParameterCount();
1:22d64f5: 			if ( parameterCount == 1 )  { throw illegalAggregate(); }
1:22d64f5:         }
1:22d64f5:         
1:22d64f5:         //
1:22d64f5:         // Additional builtin 1-arg functions which are represented in the grammar
1:22d64f5:         // as non-reserved keywords.
1:22d64f5:         //
1:22d64f5:         for ( int i = 0; i < NON_RESERVED_FUNCTION_NAMES.length; i++ )
1:22d64f5:         {
1:22d64f5:             if ( NON_RESERVED_FUNCTION_NAMES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
1:22d64f5:         }
1:22d64f5: 
1:22d64f5:         //
1:22d64f5:         // Additional SQL Standard aggregate names which are not represented in
1:22d64f5:         // the Derby grammar as reserved keywords.
1:22d64f5:         //
1:22d64f5:         for ( int i = 0; i < NON_RESERVED_AGGREGATES.length; i++ )
1:22d64f5:         {
1:22d64f5:             if ( NON_RESERVED_AGGREGATES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
1:22d64f5:         }
1:a35cf8d: 
1:a35cf8d:         // now bind the input and return types
1:a35cf8d:         AggregateAliasInfo  aai = (AggregateAliasInfo) aliasInfo;
1:a35cf8d: 
1:a35cf8d:         aai.setCollationTypeForAllStringTypes( getSchemaDescriptor().getCollationType() );
1:22d64f5:     }
1:22d64f5: 
1:22d64f5:     /** Construct an exception flagging an illegal aggregate name */
1:22d64f5:     private StandardException   illegalAggregate()
1:22d64f5:     {
1:22d64f5:         return StandardException.newException( SQLState.LANG_ILLEGAL_UDA_NAME, getRelativeName() );
1:22d64f5:     }
1:22d64f5: 
1:d039ced:     /** Bind the class names for UDTs */
1:d039ced:     private void bindParameterTypes( RoutineAliasInfo aliasInfo ) throws StandardException
1:d039ced:     {
1:d039ced:         TypeDescriptor[] parameterTypes = aliasInfo.getParameterTypes();
1:d039ced: 
1:d039ced:         if ( parameterTypes == null ) { return; }
1:d039ced: 
1:d039ced:         int count = parameterTypes.length;
1:d039ced:         for ( int i = 0; i < count; i++ )
1:d039ced:         {
1:0acf797:             parameterTypes[ i ] = bindUserCatalogType( parameterTypes[ i ] );
1:d039ced:         }
1:57465ef: 
1:57465ef:         aliasInfo.setParameterTypes( parameterTypes );
1:d039ced:     }
1:d039ced: 
1:eac0369: 	/**
1:eac0369: 	 * Create the Constant information that will drive the guts of Execution.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:d039ced: 	{
1:fa292b9: 		String schemaName = getSchemaDescriptor().getSchemaName();
1:d039ced: 
1:eac0369: 		return	getGenericConstantActionFactory().getCreateAliasConstantAction(
1:eac0369: 											  getRelativeName(),
1:eac0369: 											  schemaName,
1:eac0369: 											  javaClassName,
1:eac0369: 											  aliasInfo,
1:eac0369: 											  aliasType);
1:d039ced: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:37a2f5e
/////////////////////////////////////////////////////////////////////////
1: 							if (! dupNameCheck[dnc].equals("") && dupNameCheck[dnc].equals(dupNameCheck[dnc - 1]))
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1: class CreateAliasNode extends DDLStatementNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor
1:      * @param targetObject          Target name string or, if
1:      *        aliasType == ALIAS_TYPE_SYNONYM_AS_CHAR, a TableName
1:      * @param aliasSpecificInfo     An array of objects, see code for
1:      *                              interpretation
1:      * @param cm                    The context manager
1:      * @exception StandardException Thrown on error
1:     CreateAliasNode(    TableName aliasName,
1:                         String methodName,
1:                         char aliasType,
1:                         ContextManager cm)
1:         super(aliasName, cm);
0:         setNodeType(C_NodeTypes.CREATE_ALIAS_NODE);
1:         this.aliasType = aliasType;
/////////////////////////////////////////////////////////////////////////
1:                 this.methodName = methodName;
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         List<AliasDescriptor> systemFunctions =
1:             getDataDictionary().getRoutineList(
1:                 sysfun.getUUID().toString(),
1:                 unqualifiedName,
1:                 AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
1:             AliasDescriptor function = systemFunctions.get(i);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
commit:afe6225
/////////////////////////////////////////////////////////////////////////
0: import java.util.Vector;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.Limits;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
/////////////////////////////////////////////////////////////////////////
0:                         Object aliasType)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:     public static final int ROUTINE_SECURITY_DEFINER = RETURN_TYPE + 1;
1: 
1:     // Keep ROUTINE_ELEMENT_COUNT last (determines set cardinality).
1:     // Note: Remember to also update the map ROUTINE_CLAUSE_NAMES in
1:     // sqlgrammar.jj when elements are added.
0:     public static final int ROUTINE_ELEMENT_COUNT =
0:         ROUTINE_SECURITY_DEFINER + 1;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 Boolean definersRightsO =
1:                     (Boolean) routineElements[ROUTINE_SECURITY_DEFINER];
1:                 boolean definersRights  =
1:                     (definersRightsO == null) ? false :
1:                     definersRightsO.booleanValue();
1: 
/////////////////////////////////////////////////////////////////////////
1:                 aliasInfo = new RoutineAliasInfo(
1:                     this.methodName,
1:                     paramCount,
1:                     names,
1:                     types,
1:                     modes,
1:                     drs,
1:                     // parameter style:
1:                     ((Short) routineElements[PARAMETER_STYLE]).shortValue(),
1:                     sqlAllowed,
1:                     isDeterministic,
1:                     definersRights,
1:                     calledOnNullInput,
1:                     returnType );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     (aggForType.getJDBCTypeId() == Types.SQLXML) ||
1:                     (aggReturnType.getJDBCTypeId() == Types.SQLXML)
commit:a784994
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     names = new String[paramCount];
1:                     types = new TypeDescriptor[paramCount];
1: 
1:                         names[i] = (String) ((List) parameters[0]).get(i);
1:                         types[i] = (TypeDescriptor) ((List) parameters[1]).get(i);
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				int paramCount = ((List) parameters[0]).size();
/////////////////////////////////////////////////////////////////////////
0:                     names = (String[]) ((List) parameters[0]).toArray(
0:                             new String[paramCount]);
0:                     types = (TypeDescriptor[]) ((List) parameters[1]).toArray(
0:                             new TypeDescriptor[paramCount]);
1:                         int currentMode =  ((Integer) (((List) parameters[2]).get(i))).intValue();
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0:                         int currentMode =  ((Integer) (((Vector) parameters[2]).get(i))).intValue();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:274c5ba
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
/////////////////////////////////////////////////////////////////////////
0:                     names = (String[]) ((List<String>) parameters[0]).toArray(
0:                     types = (TypeDescriptor[]) ((List<TypeDescriptor>) parameters[1]).toArray(
commit:57465ef
/////////////////////////////////////////////////////////////////////////
1: 
1:         aliasInfo.setParameterTypes( parameterTypes );
commit:c87505f
/////////////////////////////////////////////////////////////////////////
commit:f9596d4
/////////////////////////////////////////////////////////////////////////
1:     public static final int VARARGS = ROUTINE_SECURITY_DEFINER + 1;
1:     public static final int ROUTINE_ELEMENT_COUNT = VARARGS + 1;
/////////////////////////////////////////////////////////////////////////
1: 				Boolean hasVarargsO = (Boolean) routineElements[ VARARGS ];
1:                 boolean hasVarargs = (hasVarargsO == null) ? false : hasVarargsO.booleanValue();
1: 
/////////////////////////////////////////////////////////////////////////
1:                     hasVarargs,
/////////////////////////////////////////////////////////////////////////
1: 
1:             RoutineAliasInfo    rai = (RoutineAliasInfo)aliasInfo;
1:             rai.setCollationTypeForAllStringTypes(
1: 
1:             if ( rai.hasVarargs() )
1:             {
1:                 switch ( rai.getParameterStyle() )
1:                 {
1:                 case RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET:
1:                 case RoutineAliasInfo.PS_DERBY:
1:                     break;
1: 
1:                 default:
1:                     throw StandardException.newException( SQLState.LANG_VARARGS_PARAMETER_STYLE );
1:                 }
1: 
1:                 if ( rai.getMaxDynamicResultSets() > 0 )
1:                 {
1:                     throw StandardException.newException( SQLState.LANG_VARARGS_RETURN_RESULT_SETS );
1:                 }
1:             }
1: 
1:             if (
1:                 (rai.getParameterStyle() == RoutineAliasInfo.PS_DERBY) &&
1:                 !rai.hasVarargs()
1:                 )
1:             {
1:                 throw StandardException.newException( SQLState.LANG_DERBY_PARAMETER_STYLE );
1:             }
commit:a35cf8d
/////////////////////////////////////////////////////////////////////////
1: 
1:         // now bind the input and return types
1:         AggregateAliasInfo  aai = (AggregateAliasInfo) aliasInfo;
1: 
1:         aai.setCollationTypeForAllStringTypes( getSchemaDescriptor().getCollationType() );
commit:f798a41
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
1:                 // XML not allowed because SQLXML support has not been implemented
1:                 if (
0:                     (aggForType.getJDBCTypeId() == JDBC40Translation.SQLXML) ||
0:                     (aggReturnType.getJDBCTypeId() == JDBC40Translation.SQLXML)
1:                    )
1:                 {
1:                     throw StandardException.newException( SQLState.LANG_XML_NOT_ALLOWED_DJRS );
1:                 }
1: 
commit:0acf797
/////////////////////////////////////////////////////////////////////////
1:                 TypeDescriptor  aggForType = bindUserCatalogType( (TypeDescriptor) aggElements[ AGG_FOR_TYPE ] );
1:                 TypeDescriptor  aggReturnType = bindUserCatalogType( (TypeDescriptor) aggElements[ AGG_RETURN_TYPE ] );
/////////////////////////////////////////////////////////////////////////
1:             parameterTypes[ i ] = bindUserCatalogType( parameterTypes[ i ] );
commit:22d64f5
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.derby.catalog.types.AggregateAliasInfo;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // These are the names of 1-arg builtin functions which are represented in the
1:     // grammar as non-reserved keywords. These names may not be used as
1:     // the unqualified names of user-defined aggregates.
1:     //
1:     // If additional 1-arg builtin functions are added to the grammar, they should
1:     // be put in this table.
1:     //
1:     private static  final   String[]  NON_RESERVED_FUNCTION_NAMES =
1:     {
1:         "ABS",
1:         "ABSVAL",
1:         "DATE",
1:         "DAY",
1:         "LCASE",
1:         "LENGTH",
1:         "MONTH",
1:         "SQRT",
1:         "TIME",
1:         "TIMESTAMP",
1:         "UCASE",
1:     };
1: 
1:     //
1:     // These are aggregate names defined by the SQL Standard which do not
1:     // behave as reserved keywords in Derby.
1:     //
1:     private static  final   String[]    NON_RESERVED_AGGREGATES =
1:     {
1:         "COLLECT",
1:         "COUNT",
1:         "EVERY",
1:         "FUSION",
1:         "INTERSECTION",
1:         "STDDEV_POP",
1:         "STDDEV_SAMP",
1:         "VAR_POP",
1:         "VAR_SAMP",
1:     };
1: 
1:     // aggregate arguments
1:     public  static  final   int AGG_FOR_TYPE = 0;
1:     public  static  final   int AGG_RETURN_TYPE = AGG_FOR_TYPE + 1;
1:     public  static  final   int AGG_ELEMENT_COUNT = AGG_RETURN_TYPE + 1;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1: 				this.javaClassName = (String) targetObject;
1: 
1: 				Object[] aggElements = (Object[]) aliasSpecificInfo;
0:                 TypeDescriptor  aggForType = (TypeDescriptor) aggElements[ AGG_FOR_TYPE ];
0:                 TypeDescriptor  aggReturnType = (TypeDescriptor) aggElements[ AGG_RETURN_TYPE ];
1: 
1: 				aliasInfo = new AggregateAliasInfo( aggForType, aggReturnType );
1: 				implicitCreateSchema = true;
1:                 break;
1:                 
/////////////////////////////////////////////////////////////////////////
1: 		case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
1: 			return "CREATE DERBY AGGREGATE";
/////////////////////////////////////////////////////////////////////////
1:         // validity checking for aggregates
1:         if ( aliasType == AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR ) { bindAggregate(); }
1:         
1: 		// Aggregates, procedures and functions do not check class or method validity until
/////////////////////////////////////////////////////////////////////////
1:     /** Extra logic for binding user-defined aggregate definitions */
1:     private void    bindAggregate() throws StandardException
1:     {
1:         String                      unqualifiedName = getRelativeName();
1: 
1:         //
1:         // A user-defined aggregate cannot have the name of a builtin function which takes 1 argument.
1:         //
1:         SchemaDescriptor    sysfun = getSchemaDescriptor( "SYSFUN", true );
0:         List                        systemFunctions = getDataDictionary().getRoutineList
0:             (
0:              sysfun.getUUID().toString(), unqualifiedName,
0:              AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR
0:              );
1: 
1:         for ( int i = 0; i < systemFunctions.size(); i++ )
1:         {
0: 			AliasDescriptor function = (AliasDescriptor) systemFunctions.get(i);
1: 
1: 			RoutineAliasInfo routineInfo = (RoutineAliasInfo) function.getAliasInfo();
1: 			int parameterCount = routineInfo.getParameterCount();
1: 			if ( parameterCount == 1 )  { throw illegalAggregate(); }
1:         }
1:         
1:         //
1:         // Additional builtin 1-arg functions which are represented in the grammar
1:         // as non-reserved keywords.
1:         //
1:         for ( int i = 0; i < NON_RESERVED_FUNCTION_NAMES.length; i++ )
1:         {
1:             if ( NON_RESERVED_FUNCTION_NAMES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
1:         }
1: 
1:         //
1:         // Additional SQL Standard aggregate names which are not represented in
1:         // the Derby grammar as reserved keywords.
1:         //
1:         for ( int i = 0; i < NON_RESERVED_AGGREGATES.length; i++ )
1:         {
1:             if ( NON_RESERVED_AGGREGATES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
1:         }
1:     }
1: 
1:     /** Construct an exception flagging an illegal aggregate name */
1:     private StandardException   illegalAggregate()
1:     {
1:         return StandardException.newException( SQLState.LANG_ILLEGAL_UDA_NAME, getRelativeName() );
1:     }
1: 
commit:94df7fb
/////////////////////////////////////////////////////////////////////////
1:                         // We still don't support XML values as parameters.
1:                             if (TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isXMLTypeId())
commit:75a4806
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC30Translation;
/////////////////////////////////////////////////////////////////////////
0:                         int currentMode =  ((Integer) (((Vector) parameters[2]).elementAt(i))).intValue();
1:                         modes[i] = currentMode;
1:   
0:                         boolean isOutputParameter =
0:                             ( (currentMode == JDBC30Translation.PARAMETER_MODE_OUT) || (currentMode == JDBC30Translation.PARAMETER_MODE_IN_OUT) );
1:                         
1:                         //
0:                         // We used to forbid LOBs as method parameters. DERBY-4066 lifted this
0:                         // restriction except for the output parameters of
0:                         // procedures. In that case, we are not able to send the
0:                         // output LOB across the network to a client today. In addition, we still don't support XML values as parameters.
1:                         // Presumably, the XML datatype would map to a JDBC java.sql.SQLXML type.
1:                         // We have no support for that type today.
1:                         //
1:                         if ( !types[ i ].isUserDefinedType() )
1:                         {
0:                             if
0:                                 (
0:                                  ( TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isLongConcatableTypeId() && isOutputParameter )
0:                                  ||
0:                                  (TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isXMLTypeId())
0:                                  )
1:                             { throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, names[i]); }
1:                         }
1:                     }
commit:f2a5622
/////////////////////////////////////////////////////////////////////////
1:         
1:         // validity checking for UDTs
1:         if ( aliasType == AliasInfo.ALIAS_TYPE_UDT_AS_CHAR )
1:         {
1:             //
1:             // Make sure that the java class name is not the name of a builtin
1:             // type. This skirts problems caused by logic across the system
1:             // which assumes a tight association between the builtin SQL types
1:             // and the Java classes which implement them.
1:             //
1:             // For security reasons we do not allow the user to bind a UDT
1:             // to a Derby class.
1:             //
1:             TypeId[] allSystemTypeIds = TypeId.getAllBuiltinTypeIds();
1:             int systemTypeCount = allSystemTypeIds.length;
1: 
1:             boolean foundConflict = javaClassName.startsWith( "org.apache.derby." );
1: 
1:             if ( !foundConflict )
1:             {
1:                 for ( int i = 0; i < systemTypeCount; i++ )
1:                 {
1:                     TypeId systemType = allSystemTypeIds[ i ];
1:                     String systemTypeName = systemType.getCorrespondingJavaTypeName();
1:                     
1:                     if ( systemTypeName.equals( javaClassName ) )
1:                     {
1:                         foundConflict = true;
1:                         break;
1:                     }
1:                 }
1:             }
1:             
1:             if ( foundConflict )
1:             {
1:                 throw StandardException.newException
1:                     ( SQLState.LANG_UDT_BUILTIN_CONFLICT, javaClassName );
1:             }
1:             
1:             return;
1:         }
1: 
commit:b4af7da
/////////////////////////////////////////////////////////////////////////
1:                     
1:                     dtd = bindUserType( dtd );
1:                     returnType = dtd.getCatalogType();
commit:d039ced
/////////////////////////////////////////////////////////////////////////
0: 						if ( (!types[ i ].isUserDefinedType()) && TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isLongConcatableTypeId())
/////////////////////////////////////////////////////////////////////////
1:                 // bind the return type if it is a user defined type. this fills
1:                 // in the class name.
1:                 TypeDescriptor returnType = (TypeDescriptor) routineElements[RETURN_TYPE];
1:                 if ( returnType != null )
1:                 {
1:                     DataTypeDescriptor dtd = DataTypeDescriptor.getType( returnType );
0:                     if ( dtd.getTypeId().isUserDefinedTypeId() )
1:                     {
0:                         dtd = bindUserType( dtd );
0:                         returnType = dtd.getCatalogType();
1:                     }
1:                 }
1: 
0:                         sqlAllowed, isDeterministic, calledOnNullInput, returnType );
/////////////////////////////////////////////////////////////////////////
1:             bindParameterTypes( (RoutineAliasInfo)aliasInfo );
/////////////////////////////////////////////////////////////////////////
1:     /** Bind the class names for UDTs */
1:     private void bindParameterTypes( RoutineAliasInfo aliasInfo ) throws StandardException
1:     {
1:         TypeDescriptor[] parameterTypes = aliasInfo.getParameterTypes();
1: 
1:         if ( parameterTypes == null ) { return; }
1: 
1:         int count = parameterTypes.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             TypeDescriptor td = parameterTypes[ i ];
1: 
0:             // if this is a user defined type, resolve the Java class name
0:             if ( td.isUserDefinedType() )
1:             {
0:                 DataTypeDescriptor dtd = DataTypeDescriptor.getType( td );
1: 
0:                 dtd = bindUserType( dtd );
0:                 parameterTypes[ i ] = dtd.getCatalogType();
1:             }
1:         }
1:     }
1: 
commit:fa292b9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.UDTAliasInfo;
/////////////////////////////////////////////////////////////////////////
1: 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1: 				this.javaClassName = (String) targetObject;
1: 				aliasInfo = new UDTAliasInfo();
1: 
1: 				implicitCreateSchema = true;
1:                 break;
1:                 
/////////////////////////////////////////////////////////////////////////
1: 		case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
1: 			return "CREATE TYPE";
/////////////////////////////////////////////////////////////////////////
0:         // validity checking for UDTs
0:         if ( aliasType == AliasInfo.ALIAS_TYPE_UDT_AS_CHAR )
1:         {
0:             // nothing to do yet
1:             return;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		String schemaName = getSchemaDescriptor().getSchemaName();
commit:9f4b339
/////////////////////////////////////////////////////////////////////////
1:     // indexes into routineElements
1:     public static final int PARAMETER_ARRAY = 0;
1:     public static final int TABLE_NAME = PARAMETER_ARRAY + 1;
1:     public static final int DYNAMIC_RESULT_SET_COUNT = TABLE_NAME + 1;
1:     public static final int LANGUAGE = DYNAMIC_RESULT_SET_COUNT + 1;
1:     public static final int EXTERNAL_NAME = LANGUAGE + 1;
1:     public static final int PARAMETER_STYLE = EXTERNAL_NAME + 1;
1:     public static final int SQL_CONTROL = PARAMETER_STYLE + 1;
1:     public static final int DETERMINISTIC = SQL_CONTROL + 1;
1:     public static final int NULL_ON_NULL_INPUT = DETERMINISTIC + 1;
1:     public static final int RETURN_TYPE = NULL_ON_NULL_INPUT + 1;
0:     public static final int ROUTINE_ELEMENT_COUNT = RETURN_TYPE + 1;
1:     
/////////////////////////////////////////////////////////////////////////
1: 				// 7 - Boolean - whether the routine is DETERMINISTIC
1: 				// 8 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
1: 				// 9 - TypeDescriptor - return type (always NULL for procedures)
1: 				Object[] parameters = (Object[]) routineElements[PARAMETER_ARRAY];
/////////////////////////////////////////////////////////////////////////
1: 				Integer drso = (Integer) routineElements[DYNAMIC_RESULT_SET_COUNT];
1: 				Short sqlAllowedObject = (Short) routineElements[SQL_CONTROL];
1: 				Boolean isDeterministicO = (Boolean) routineElements[DETERMINISTIC];
1:                 boolean isDeterministic = (isDeterministicO == null) ? false : isDeterministicO.booleanValue();
1: 
1: 				Boolean calledOnNullInputO = (Boolean) routineElements[NULL_ON_NULL_INPUT];
/////////////////////////////////////////////////////////////////////////
0: 						((Short) routineElements[PARAMETER_STYLE]).shortValue(),	// parameter style
0:                         sqlAllowed, isDeterministic, calledOnNullInput, (TypeDescriptor) routineElements[RETURN_TYPE]);
commit:2d3677b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.RowMultiSetImpl;
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Set the collation of the columns in a Table Function's returned row set.
1: 	 */
0: 	private void    setTableFunctionCollations()
1:         throws StandardException
1:     {
0: 		if ( aliasInfo.isTableFunction() )
1:         {
0:             RoutineAliasInfo    info = (RoutineAliasInfo) aliasInfo;
0:             RowMultiSetImpl     tableFunctionReturnType = (RowMultiSetImpl) ((DataTypeDescriptor) info.getReturnType()).getTypeId().getBaseTypeId();
0:             TypeDescriptor[]    types = tableFunctionReturnType.getTypes();
0:             int                 returnedTableColumnCount = types.length;
0:             SchemaDescriptor    sd = getSchemaDescriptor();
1: 
0:             for ( int i = 0; i < returnedTableColumnCount; i++ )
1:             {
0:                 TypeDescriptorImpl  tdi = (TypeDescriptorImpl) types[ i ];
0:                 if ( tdi.isStringType() )
1:                 {
0:                     tdi.setCollationType( sd.getCollationType() );
1:                 }
1:             }
1:         }
1: 
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:             }
1:             
0:             // if this is a table function, then force its string columns to
0:             // have the correct collation.
0:             setTableFunctionCollations();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01b5961
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // Set the collation for all string types in parameters
1:             // and return types including row multi-sets to be that of
1:             // the schema the routine is being defined in.
0:             ((RoutineAliasInfo)aliasInfo).setCollationTypeForAllStringTypes(
1:                     getSchemaDescriptor().getCollationType());
1: 
commit:d66ce7b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             TypeDescriptor[]    types = info.getReturnType().getRowTypes();
1: 
0:             for ( int i = 0; i < types.length; i++ )
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:             newTDWithCorrectCollation =
0:                 newTDWithCorrectCollation.getCollatedType(
0: 					getSchemaDescriptor().getCollationType(),
0:                     StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			return newTDWithCorrectCollation.getCatalogType();
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
0: 			return;
/////////////////////////////////////////////////////////////////////////
commit:0061383
/////////////////////////////////////////////////////////////////////////
0: public class CreateAliasNode extends DDLStatementNode
commit:703bc91
/////////////////////////////////////////////////////////////////////////
1: 	private String				javaClassName;
1: 	private String				methodName;
1: 	private char				aliasType; 
0: 	private boolean				delimitedIdentifier;
/////////////////////////////////////////////////////////////////////////
1: 				
1: 				// Support for Java signatures in Derby was added in 10.1
1: 				// Check to see the catalogs have been upgraded to 10.1 before
1: 				// accepting such a method name for a routine. Otherwise
1: 				// a routine that works in 10.1 soft upgrade mode would
1: 				// exist when running 10.0 but not resolve to anything.
1: 				if (this.methodName.indexOf('(') != -1)
1: 				{
1: 					getDataDictionary().checkVersion(
1: 							DataDictionary.DD_VERSION_DERBY_10_1,
1:                             "EXTERNAL NAME 'class.method(<signature>)'");
1: 					
1: 				}
1: 				
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CreateAliasNode
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
1: 
1: import org.apache.derby.catalog.AliasInfo;
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: 
0: import java.lang.reflect.Member;
0: import java.util.Vector;
1: 
1: /**
1:  * A CreateAliasNode represents a CREATE ALIAS statement.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class CreateAliasNode extends CreateStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	String				javaClassName;
0: 	String				methodName;
0: 	char				aliasType; 
0: 	boolean				delimitedIdentifier;
1: 
1: 	private AliasInfo aliasInfo;
1: 
1: 
1: 	/**
0: 	 * Initializer for a CreateAliasNode
1: 	 *
1: 	 * @param aliasName				The name of the alias
0: 	 * @param javaClassName			The full class name
1: 	 * @param methodName		    The method name
0: 	 * @param aliasType				The alias type
0: 	 * @param delimitedIdentifier	Whether or not to treat the class name
0: 	 *								as a delimited identifier if trying to
0: 	 *								resolve it as a class alias
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(
0: 						Object aliasName,
0: 						Object javaClassName,
0: 						Object methodName,
1: 						Object aliasSpecificInfo,
0: 						Object aliasType,
0: 						Object delimitedIdentifier)
0: 		throws StandardException
1: 	{		
0: 		TableName qn = (TableName) aliasName;
1: 
0: 		initAndCheck(qn);
1: 			
0: 		this.javaClassName = (String) javaClassName;
0: 		this.methodName = (String) methodName;
0: 		this.aliasType = ((Character) aliasType).charValue();
0: 		this.delimitedIdentifier =
0: 								((Boolean) delimitedIdentifier).booleanValue();
1: 
1: 
1: 		switch (this.aliasType)
1: 		{
1: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
1: 			{
1: 				//routineElements contains the description of the procedure.
1: 				// 
1: 				// 0 - Object[] 3 element array for parameters
1: 				// 1 - TableName - specific name
1: 				// 2 - Integer - dynamic result set count
1: 				// 3 - String language (always java) - ignore
1: 				// 4 - String external name (also passed directly to create alias node - ignore
1: 				// 5 - Integer parameter style 
1: 				// 6 - Short - SQL control
0: 				// 7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
0: 				// 8 - TypeDescriptor - return type (always NULL for procedures)
1: 
1: 				Object[] routineElements = (Object[]) aliasSpecificInfo;
0: 				Object[] parameters = (Object[]) routineElements[0];
0: 				int paramCount = ((Vector) parameters[0]).size();
1: 
1: 				String[] names = null;
1: 				TypeDescriptor[] types = null;
1: 				int[] modes = null;
1: 
0: 				if (paramCount > DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE)
0: 					throw StandardException.newException(SQLState.LANG_TOO_MANY_PARAMETERS_FOR_STORED_PROC,
0: 							String.valueOf(DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE), aliasName, String.valueOf(paramCount));
1: 
1: 				if (paramCount != 0) {
1: 
0: 					names = new String[paramCount];
0: 					((Vector) parameters[0]).copyInto(names);
1: 
0: 					types = new TypeDescriptor[paramCount];
0: 					((Vector) parameters[1]).copyInto(types);
1: 
1: 					modes = new int[paramCount];
1: 					for (int i = 0; i < paramCount; i++) {
0: 						modes[i] = ((Integer) (((Vector) parameters[2]).elementAt(i))).intValue();
1: 
0: 						if (TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isLongConcatableTypeId())
0: 							throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, names[i]);
1: 
1: 					}
1: 
1: 					if (paramCount > 1) {
1: 						String[] dupNameCheck = new String[paramCount];
1: 						System.arraycopy(names, 0, dupNameCheck, 0, paramCount);
1: 						java.util.Arrays.sort(dupNameCheck);
1: 						for (int dnc = 1; dnc < dupNameCheck.length; dnc++) {
0: 							if (dupNameCheck[dnc].equals(dupNameCheck[dnc - 1]))
1: 								throw StandardException.newException(SQLState.LANG_DB2_DUPLICATE_NAMES, dupNameCheck[dnc], getFullName());
1: 						}
1: 					}
1: 				}
1: 
0: 				Integer drso = (Integer) routineElements[2];
1: 				int drs = drso == null ? 0 : drso.intValue();
1: 
1: 				short sqlAllowed;
0: 				Short sqlAllowedObject = (Short) routineElements[6];
1: 				if (sqlAllowedObject != null)
1: 					sqlAllowed = sqlAllowedObject.shortValue();
1: 				else
1: 					sqlAllowed = (this.aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR ?
1: 					RoutineAliasInfo.MODIFIES_SQL_DATA : RoutineAliasInfo.READS_SQL_DATA);
1: 
0: 				Boolean calledOnNullInputO = (Boolean) routineElements[7];
1: 				boolean calledOnNullInput;
1: 				if (calledOnNullInputO == null)
1: 					calledOnNullInput = true;
1: 				else
1: 					calledOnNullInput = calledOnNullInputO.booleanValue();
1: 
0: 				aliasInfo = new RoutineAliasInfo(this.methodName, paramCount, names, types, modes, drs,
0: 						((Short) routineElements[5]).shortValue(),	// parameter style
0: 						sqlAllowed, calledOnNullInput, (TypeDescriptor) routineElements[8]);
1: 
1: 				implicitCreateSchema = true;
1: 				}
1: 				break;
1: 
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"Unexpected value for aliasType (" + aliasType + ")");
1: 				}
1: 		}
1: 	}
1: 
0: 	public	String	getAliasName() { return getRelativeName(); }
0:     public	String	getJavaClassName() { return javaClassName; }
0:     public	String	getMethodName() { return methodName; }
0:     public	char	getAliasType() { return aliasType; }
1: 
1: 
0: 	public String statementToString()
1: 	{
1: 		switch (this.aliasType)
1: 		{
1: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1: 			return "CREATE PROCEDURE";
1: 		default:
1: 			return "CREATE FUNCTION";
1: 		}
1: 	}
1: 
1: 	// We inherit the generate() method from DDLStatementNode.
1: 
1: 	/**
1: 	 * Bind this CreateAliasNode.  This means doing any static error
1: 	 * checking that can be done before actually creating the table.
1: 	 * For example, verifying that the column name list does not
1: 	 * contain any duplicate column names.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		// Procedures do not check class or method validity until runtime execution of the procedure.
1: 
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Create the Constant information that will drive the guts of Execution.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
0: 		String schemaName;
0: 		switch (aliasType) {
1: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
1: 		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
0: 			schemaName = getSchemaDescriptor().getSchemaName();
1: 			break;
1: 		default:
0: 			schemaName = null;
1: 		}
1: 
1: 		return	getGenericConstantActionFactory().getCreateAliasConstantAction(
1: 											  getRelativeName(),
1: 											  schemaName,
1: 											  javaClassName,
1: 											  aliasInfo,
1: 											  aliasType);
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6229908
/////////////////////////////////////////////////////////////////////////
0: 	 * or procedure in it's init method, which is called by the parser. But at 
0: 	 * that time, we do not have the SchemaDescriptor ready to determine the 
0: 	 * collation type. Hence, at the bind time, when we do have the 
0: 	 * SchemaDescriptor available, we should go back and fix the 
0: 	 * RoutineAliasInfo to have correct collation for its character string 
0: 	 * parameters and also fix its return type (for functions) so as to have 
0: 	 * correct collation if it is returning character string type. 
/////////////////////////////////////////////////////////////////////////
0: 		TypeId compTypeId;
0: 		if (aType != null) //that means we are not dealing with a procedure
0: 		{
0: 			compTypeId = TypeId.getBuiltInTypeId(aType.getTypeName());
0: 			if (compTypeId != null && compTypeId.isStringTypeId()) 
0: 				return true;			
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 	 * associated with the definition of the user defined function/procedure 
0: 	 * should take the collation of the schema in which this user defined 
0: 	 * function is getting created.
0: 	 *   the function/procedure is getting created.
0: 		//We could have been called for the return type but for procedures 
0: 		//there is no return type and hence we should be careful that we
0: 		//don't run into null ptr exception. So before doing anything, check if
0: 		//the passed parameter is null and if so, then simply return.
0: 		if (changeTD == null) 
0: 			return changeTD;
/////////////////////////////////////////////////////////////////////////
1: 		//Are we dealing with user defined function or procedure?
1: 		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR ||
1: 				aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) {
0: 			//Does the user defined function/procedure have any character 
0: 			//string types in it's definition
/////////////////////////////////////////////////////////////////////////
0: 					//schema in which the function/procedure is getting defined.
commit:7183159
/////////////////////////////////////////////////////////////////////////
0: 					getSchemaDescriptor().getCollationType());
commit:7fb68b4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * CreateAliasNode creates the RoutineAliasInfo for a user defined function
0: 	 * in it's init method, which is called by the parser. But at that time, we
0: 	 * do not have the SchemaDescriptor ready to determine the collation
0: 	 * type. Hence, at the bind time, when we do have the SchemaDescriptor
0: 	 * available, we should go back and fix the RoutineAliasIno to have correct
0: 	 * collation for it's character string parameters and also fix it's return
0: 	 * type's collation if the return type is a character string.
0: 	 * 
0: 	 * This method here checks if the RoutineAliasInfo has any character string
0: 	 * types associated with it. If not, then the RoutineAliasInfo that got
0: 	 * created at parsing time is just fine. But if not, then we should take
0: 	 * care of the collation type of it's character string types. 
0: 	 * 
0: 	 * @return true if it has a parameter or return type of character string
0: 	 */
0: 	private boolean anyStringTypeDescriptor() {
0: 		RoutineAliasInfo rai = (RoutineAliasInfo)aliasInfo;
0: 		TypeDescriptor aType = rai.getReturnType();
0: 		/*
0: 		** Try for a built in type matching the
0: 		** type name.  
0: 		*/
0: 		TypeId compTypeId = TypeId.getBuiltInTypeId(aType.getTypeName());
0: 		if (compTypeId != null && compTypeId.isStringTypeId()) 
0: 			return true;
0: 		if (rai.getParameterCount() != 0) {
0: 			int paramCount = rai.getParameterCount();
0: 			TypeDescriptor[] paramTypes = rai.getParameterTypes();
0: 			for (int i = 0; i < paramCount; i++) {
0: 				compTypeId = TypeId.getBuiltInTypeId(paramTypes[i].getTypeName());
0: 				if (compTypeId != null && compTypeId.isStringTypeId()) 
0: 					return true;
0: 			}
0: 		}
0: 		return false;		
0: 	}
0: 	
0: 	/**
0: 	 * Take the passed TypeDescriptor and check if it corresponds to a 
0: 	 * character string type. If yes, then create a new one based on it's 
0: 	 * typeid, length and nullability to create a new DataTypeDescriptor and 
0: 	 * then have it take the collation type of the schema in which the method 
0: 	 * is getting defined in. This is because all the character strings 
0: 	 * associated with the definition of the user defined function should take  
0: 	 * the collation of the schema in which this user defined function is 
0: 	 * getting created.
0: 	 * 
0: 	 * @param changeTD TypeDescriptor with incorrect collation setting
0: 	 * @return New TypeDescriptor with collation of the schema in which 
0: 	 *   the function is getting created.
0: 	 * @throws StandardException
0: 	 */
0: 	private TypeDescriptor typeDescriptorWithCorrectCollation(TypeDescriptor changeTD)
0: 	throws StandardException {
0: 		TypeId compTypeId = TypeId.getBuiltInTypeId(changeTD.getTypeName());
0: 		//No work to do if type id does not correspond to a character string
0: 		if (compTypeId != null && compTypeId.isStringTypeId()) {
0: 			DataTypeDescriptor newTDWithCorrectCollation = 
0: 				new DataTypeDescriptor(compTypeId, 
0: 						changeTD.isNullable(),
0: 						changeTD.getMaximumWidth());
0: 			//Use the collation type and info of the schema in which this
0: 			//function is defined for the return value of the function
0: 			newTDWithCorrectCollation.setCollationType(
0: 		    	     getSchemaDescriptor(getObjectName().getSchemaName(), false).getCollationType());
0: 			newTDWithCorrectCollation.setCollationDerivation(
0: 	        		StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 			return newTDWithCorrectCollation;
0: 		}
0: 		return changeTD;
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 		//Are we dealing with user defined function?
0: 		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR) {
0: 			//Does the user defined function have any character string types
0: 			//in it's definition
0: 			if (anyStringTypeDescriptor()){
0: 				RoutineAliasInfo oldAliasInfo = (RoutineAliasInfo)aliasInfo;  
0: 				TypeDescriptor[] newParamTypes = null;
0: 				int paramCount = oldAliasInfo.getParameterCount();
0: 				//Does the user defined functio has any parameters to it?
0: 				if (paramCount > 0) {
0: 					newParamTypes = new TypeDescriptor[paramCount];
0: 					TypeDescriptor[] oldParamTypes = oldAliasInfo.getParameterTypes();
0: 					//Go through the parameters and pick the character string
0: 					//type and set their collation to the collation of the
0: 					//schema in which the function is getting defined.
0: 					for (int i = 0; i < paramCount; i++) 
0: 						newParamTypes[i] = typeDescriptorWithCorrectCollation(oldParamTypes[i]);
0: 				}
0: 				//Now create the RoutineAliasInfo again with it's character
0: 				//strings associated with correct collation type
0: 				aliasInfo = new RoutineAliasInfo(
0: 						oldAliasInfo.getMethodName(),
0: 						oldAliasInfo.getParameterCount(),
0: 						oldAliasInfo.getParameterNames(), 
0: 						newParamTypes, 
0: 						oldAliasInfo.getParameterModes(), 
0: 						oldAliasInfo.getMaxDynamicResultSets(),
0: 						oldAliasInfo.getParameterStyle(),
0: 						oldAliasInfo.getSQLAllowed(),
0: 						oldAliasInfo.calledOnNullInput(), 
0: 						typeDescriptorWithCorrectCollation(oldAliasInfo.getReturnType()));
0: 			}
0: 		}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e1987c6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
0: 				// 9 - Boolean - externalSecurity (false for invoker, true for definer)
/////////////////////////////////////////////////////////////////////////
0: 				// GrantRevoke TODO: Figure out how to save external security info. Putting this in
0: 				// RoutineAliasInfo may not be the best long term solution
0: 
commit:8a3b297
/////////////////////////////////////////////////////////////////////////
1: 		// Don't allow creating synonyms in SESSION schema. Causes confusion if
1: 		// a temporary table is created later with same name.
1: 		if (isSessionSchema(getSchemaDescriptor().getSchemaName()))
1: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
0: 
commit:50b6dfc
/////////////////////////////////////////////////////////////////////////
1: 				implicitCreateSchema = true;
/////////////////////////////////////////////////////////////////////////
1: 		SchemaDescriptor targetSD = getSchemaDescriptor(targetSchema, false);
1: 		if ((targetSD != null) && isSessionSchema(targetSD))
commit:582425f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.SynonymAliasInfo;
/////////////////////////////////////////////////////////////////////////
0: 	 * @param targetObject			Target name
/////////////////////////////////////////////////////////////////////////
1: 						Object targetObject,
/////////////////////////////////////////////////////////////////////////
0: 		this.aliasType = ((Character) aliasType).charValue();
1: 				this.javaClassName = (String) targetObject;
0: 				this.methodName = (String) methodName;
0: 				this.delimitedIdentifier =
0: 								((Boolean) delimitedIdentifier).booleanValue();
0: 
/////////////////////////////////////////////////////////////////////////
1: 			case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1: 				String targetSchema;
1: 				TableName t = (TableName) targetObject;
1: 				if (t.getSchemaName() != null)
1: 					targetSchema = t.getSchemaName();
1: 				else targetSchema = getSchemaDescriptor().getSchemaName();
1: 				aliasInfo = new SynonymAliasInfo(targetSchema, t.getTableName());
0: 				break;
/////////////////////////////////////////////////////////////////////////
1: 		case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
1: 			return "CREATE SYNONYM";
/////////////////////////////////////////////////////////////////////////
0: 		// Procedures and functions do not check class or method validity until
1: 		// runtime execution. Synonyms do need some validity checks.
1: 		if (aliasType != AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
0: 			return this;
0: 
1: 		String targetSchema = ((SynonymAliasInfo)aliasInfo).getSynonymSchema();
1: 		String targetTable = ((SynonymAliasInfo)aliasInfo).getSynonymTable();
1: 		if (this.getObjectName().equals(targetSchema, targetTable))
1: 			throw StandardException.newException(SQLState.LANG_SYNONYM_CIRCULAR,
1: 						this.getFullName(),
1: 						targetSchema+"."+targetTable);
0: 
0: 		// Raise error if targetSchema doesn't exists
0: 		SchemaDescriptor targetSD = getSchemaDescriptor(targetSchema);
0: 
0: 		// Synonym can't be defined on temporary tables.
0: 		TableDescriptor targetTD = getTableDescriptor(targetTable, targetSD);
0: 		if (targetTD != null &&
0: 			targetTD.getTableType() == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)
1: 			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
/////////////////////////////////////////////////////////////////////////
0: 		case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
0: 			schemaName = getSchemaDescriptor().getSchemaName();
0: 			break;
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 				if (paramCount > Limits.DB2_MAX_PARAMS_IN_STORED_PROCEDURE)
0: 							String.valueOf(Limits.DB2_MAX_PARAMS_IN_STORED_PROCEDURE), aliasName, String.valueOf(paramCount));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.execute.BaseActivation;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: 
0: import java.lang.reflect.Member;
0: import java.util.Vector;
0: 
0: /**
0:  * A CreateAliasNode represents a CREATE ALIAS statement.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class CreateAliasNode extends CreateStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	String				javaClassName;
0: 	String				methodName;
0: 	char				aliasType; 
0: 	boolean				delimitedIdentifier;
0: 
0: 	private AliasInfo aliasInfo;
0: 
0: 
0: 	/**
0: 	 * Initializer for a CreateAliasNode
0: 	 *
0: 	 * @param aliasName				The name of the alias
0: 	 * @param javaClassName			The full class name
0: 	 * @param methodName		    The method name
0: 	 * @param aliasType				The alias type
0: 	 * @param delimitedIdentifier	Whether or not to treat the class name
0: 	 *								as a delimited identifier if trying to
0: 	 *								resolve it as a class alias
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(
0: 						Object aliasName,
0: 						Object javaClassName,
0: 						Object methodName,
0: 						Object aliasSpecificInfo,
0: 						Object aliasType,
0: 						Object delimitedIdentifier)
0: 		throws StandardException
0: 	{		
0: 		TableName qn = (TableName) aliasName;
0: 
0: 		initAndCheck(qn);
0: 			
0: 		this.javaClassName = (String) javaClassName;
0: 		this.methodName = (String) methodName;
0: 		this.aliasType = ((Character) aliasType).charValue();
0: 		this.delimitedIdentifier =
0: 								((Boolean) delimitedIdentifier).booleanValue();
0: 
0: 
0: 		switch (this.aliasType)
0: 		{
0: 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
0: 			case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
0: 			{
0: 				//routineElements contains the description of the procedure.
0: 				// 
0: 				// 0 - Object[] 3 element array for parameters
0: 				// 1 - TableName - specific name
0: 				// 2 - Integer - dynamic result set count
0: 				// 3 - String language (always java) - ignore
0: 				// 4 - String external name (also passed directly to create alias node - ignore
0: 				// 5 - Integer parameter style 
0: 				// 6 - Short - SQL control
0: 				// 7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
0: 				// 8 - TypeDescriptor - return type (always NULL for procedures)
0: 
0: 				Object[] routineElements = (Object[]) aliasSpecificInfo;
0: 				Object[] parameters = (Object[]) routineElements[0];
0: 				int paramCount = ((Vector) parameters[0]).size();
0: 
0: 				String[] names = null;
0: 				TypeDescriptor[] types = null;
0: 				int[] modes = null;
0: 
0: 				if (paramCount > DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE)
0: 					throw StandardException.newException(SQLState.LANG_TOO_MANY_PARAMETERS_FOR_STORED_PROC,
0: 							String.valueOf(DB2Limit.DB2_MAX_PARAMS_IN_STORED_PROCEDURE), aliasName, String.valueOf(paramCount));
0: 
0: 				if (paramCount != 0) {
0: 
0: 					names = new String[paramCount];
0: 					((Vector) parameters[0]).copyInto(names);
0: 
0: 					types = new TypeDescriptor[paramCount];
0: 					((Vector) parameters[1]).copyInto(types);
0: 
0: 					modes = new int[paramCount];
0: 					for (int i = 0; i < paramCount; i++) {
0: 						modes[i] = ((Integer) (((Vector) parameters[2]).elementAt(i))).intValue();
0: 
0: 						if (TypeId.getBuiltInTypeId(types[i].getJDBCTypeId()).isLongConcatableTypeId())
0: 							throw StandardException.newException(SQLState.LANG_LONG_DATA_TYPE_NOT_ALLOWED, names[i]);
0: 
0: 					}
0: 
0: 					if (paramCount > 1) {
0: 						String[] dupNameCheck = new String[paramCount];
0: 						System.arraycopy(names, 0, dupNameCheck, 0, paramCount);
0: 						java.util.Arrays.sort(dupNameCheck);
0: 						for (int dnc = 1; dnc < dupNameCheck.length; dnc++) {
0: 							if (dupNameCheck[dnc].equals(dupNameCheck[dnc - 1]))
0: 								throw StandardException.newException(SQLState.LANG_DB2_DUPLICATE_NAMES, dupNameCheck[dnc], getFullName());
0: 						}
0: 					}
0: 				}
0: 
0: 				Integer drso = (Integer) routineElements[2];
0: 				int drs = drso == null ? 0 : drso.intValue();
0: 
0: 				short sqlAllowed;
0: 				Short sqlAllowedObject = (Short) routineElements[6];
0: 				if (sqlAllowedObject != null)
0: 					sqlAllowed = sqlAllowedObject.shortValue();
0: 				else
0: 					sqlAllowed = (this.aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR ?
0: 					RoutineAliasInfo.MODIFIES_SQL_DATA : RoutineAliasInfo.READS_SQL_DATA);
0: 
0: 				Boolean calledOnNullInputO = (Boolean) routineElements[7];
0: 				boolean calledOnNullInput;
0: 				if (calledOnNullInputO == null)
0: 					calledOnNullInput = true;
0: 				else
0: 					calledOnNullInput = calledOnNullInputO.booleanValue();
0: 
0: 				aliasInfo = new RoutineAliasInfo(this.methodName, paramCount, names, types, modes, drs,
0: 						((Short) routineElements[5]).shortValue(),	// parameter style
0: 						sqlAllowed, calledOnNullInput, (TypeDescriptor) routineElements[8]);
0: 
0: 				implicitCreateSchema = true;
0: 				}
0: 				break;
0: 
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"Unexpected value for aliasType (" + aliasType + ")");
0: 				}
0: 		}
0: 	}
0: 
0: 	public	String	getAliasName() { return getRelativeName(); }
0:     public	String	getJavaClassName() { return javaClassName; }
0:     public	String	getMethodName() { return methodName; }
0:     public	char	getAliasType() { return aliasType; }
0: 
0: 
0: 	public String statementToString()
0: 	{
0: 		switch (this.aliasType)
0: 		{
0: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
0: 			return "CREATE PROCEDURE";
0: 		default:
0: 			return "CREATE FUNCTION";
0: 		}
0: 	}
0: 
0: 	// We inherit the generate() method from DDLStatementNode.
0: 
0: 	/**
0: 	 * Bind this CreateAliasNode.  This means doing any static error
0: 	 * checking that can be done before actually creating the table.
0: 	 * For example, verifying that the column name list does not
0: 	 * contain any duplicate column names.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		// Procedures do not check class or method validity until runtime execution of the procedure.
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Create the Constant information that will drive the guts of Execution.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 		String schemaName;
0: 		switch (aliasType) {
0: 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
0: 		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
0: 			schemaName = getSchemaDescriptor().getSchemaName();
0: 			break;
0: 		default:
0: 			schemaName = null;
0: 		}
0: 
0: 		return	getGenericConstantActionFactory().getCreateAliasConstantAction(
0: 											  getRelativeName(),
0: 											  schemaName,
0: 											  javaClassName,
0: 											  aliasInfo,
0: 											  aliasType);
0: 	}
0: }
============================================================================