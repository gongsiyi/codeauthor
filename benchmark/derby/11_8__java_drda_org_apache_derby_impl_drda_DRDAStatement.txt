8:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.DRDAStatement
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
108:eac0369: 
1:4f996a4:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:788599f: import java.io.IOException;
1:db4c995: import java.lang.reflect.Array;
1:9ce79e7: import java.lang.reflect.Method;
1:9ce79e7: import java.math.BigInteger;
1:9ce79e7: import java.sql.CallableStatement;
1:eac0369: import java.sql.Connection;
1:db4c995: import java.sql.DataTruncation;
1:3634d6e: import java.sql.ParameterMetaData;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:9ce79e7: import java.sql.Statement;
1:eac0369: import java.util.ArrayList;
1:9ce79e7: import java.util.Hashtable;
1:f26c60c: import org.apache.derby.iapi.jdbc.EngineStatement;
1:aadfd42: import org.apache.derby.iapi.jdbc.EnginePreparedStatement;
1:38f02ec: import org.apache.derby.iapi.transaction.TransactionControl;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:9ce79e7: import org.apache.derby.impl.jdbc.Util;
1:eac0369: 
1:4f996a4: /**
1:4f996a4:     DRDAStatement stores information about the statement being executed
1:4f996a4: */
1:eac0369: class DRDAStatement
1:4f996a4: {
1:eac0369: 
1:4f996a4:     //NOTE!
1:4f996a4:     //
1:4f996a4:     // Since DRDAStatements are reused, ALL variables (except those noted in 
1:4f996a4:     // the comments for reset method) should be set to their default values 
1:4f996a4:     // in reset().
1:4f996a4:     
1:f0dcf0b: 
1:db9a013:     protected String typDefNam;     //TYPDEFNAM for this statement
1:4f996a4:     protected int byteOrder;        //deduced from typDefNam, save String comparisons
1:db9a013:     protected int ccsidSBC;         //CCSID for single byte characters
1:db9a013:     protected int ccsidDBC;         //CCSID for double byte characters
1:db9a013:     protected int ccsidMBC;         //CCSID for mixed byte characters
1:db9a013:     protected String ccsidSBCEncoding;  //Java encoding for CCSIDSBC
1:db9a013:     protected String ccsidDBCEncoding;  //Java encoding for CCSIDDBC
1:db9a013:     protected String ccsidMBCEncoding;  //Java encoding for CCSIDMBC
1:eac0369: 
1:4f996a4:     protected Database database;        // Database this statement is created for
1:db9a013:     private   Pkgnamcsn pkgnamcsn;      // Package name/section # and  consistency token
1:3c9599f:     
1:4f996a4:     int withHoldCursor = -1;     // hold cursor after commit attribute.
1:4f996a4:     protected int isolationLevel;         //JCC isolation level for Statement
1:4f996a4:     protected String cursorName;
1:db9a013:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;         // Sensitive or Insensitive scroll attribute
1:db9a013:     protected int concurType = ResultSet.CONCUR_READ_ONLY;;         // Concurency type
1:4f996a4:     protected long rowCount;            // Number of rows we have processed
1:4f996a4:     protected byte [] rslsetflg;        // Result Set Flags
1:4f996a4:     protected int maxrslcnt;            // Maximum Result set count
1:f26c60c:     protected EnginePreparedStatement ps;     // Prepared statement
1:3634d6e:     protected ParameterMetaData stmtPmeta; // param metadata
1:4f996a4:     protected boolean isCall;
1:db9a013:     protected String procName;          // callable statement's method name
1:4f996a4:     private   int[] outputTypes;        // jdbc type for output parameter or NOT_OUTPUT_PARAM
1:4f996a4:                                         // if not an output parameter.
1:4f996a4:     private int[] outputPrecision;
1:4f996a4:     private int[] outputScale;
1:6eb5042:         
1:4f996a4:     protected static int NOT_OUTPUT_PARAM = -100000;
1:db9a013:     protected boolean outputExpected;   // expect output from a callable statement
1:f26c60c:     private EngineStatement stmt;             // SQL statement
1:eac0369: 
1:eac0369: 
1:4f996a4:     private DRDAResultSet currentDrdaRs;  // Current ResultSet
1:27fbf33:     /** Hashtable with resultsets. */
1:27fbf33:     private Hashtable<ConsistencyToken, DRDAResultSet> resultSetTable;
1:27fbf33:     /** Ordered list of hash keys. */
1:27fbf33:     private ArrayList<ConsistencyToken> resultSetKeyList;
1:4f996a4:     private int numResultSets = 0;  
1:eac0369: 
1:b850119:     /**
1:b850119:      * A chain of warnings indicating whether some of the data values returned
1:b850119:      * by this statement had to be truncated before being sent to the client.
1:b850119:      */
1:b850119:     private DataTruncation truncationWarnings;
1:b850119: 
1:c050ed4:     /** This class is used to keep track of the statement's parameters
1:c050ed4:      * as they are received from the client. It uses arrays to track
1:c050ed4:      * the DRDA type, the length in bytes and the externalness of each
1:c050ed4:      * parameter. Arrays of int/byte are used rather than ArrayLists
1:c050ed4:      * of Integer/Byte in order to re-use the same storage each time
1:c050ed4:      * the statement is executed. */
1:c050ed4:     private static class DrdaParamState {
1:4f996a4:         // The last parameter may be streamed. 
1:4f996a4:         // We need to keep a record of it so we can drain it if it is not 
1:4f996a4:         // used.
1:4f996a4:         // Only the last parameter with an EXTDTA will be streamed. 
1:4f996a4:         //(See DRDAConnThread.readAndSetAllExtParams()). 
1:4f996a4:         private EXTDTAReaderInputStream streamedParameter = null;
1:c050ed4:         private int typeLstEnd_ = 0;
1:c050ed4:         private byte[] typeLst_ = new byte[10];
1:c050ed4:         private int[]  lenLst_ = new int[10];
1:c050ed4:         private int extLstEnd_ = 0;
1:c050ed4:         private int[]  extLst_ = new int[10];
1:c050ed4: 
1:c050ed4:         private static Object growArray(Object array) {
1:c050ed4:             final int oldLen = Array.getLength(array);
1:c050ed4:             Object tmp =
1:c050ed4:                 Array.newInstance(array.getClass().getComponentType(),
1:c050ed4:                                   Math.max(oldLen,1)*2);
1:c050ed4:             System.arraycopy(array, 0, tmp, 0, oldLen);
1:c050ed4:             return tmp;
1:c050ed4:         }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>clear</code> resets the arrays so that new parameters
1:c050ed4:          * will be added at the beginning. No initialization or
1:c050ed4:          * releasing of storage takes place unless the trim argument
1:c050ed4:          * is true.
1:c050ed4:          *
1:c050ed4:          * @param trim - if true; release excess storage
1:c050ed4:          */
1:c050ed4:         protected void clear(boolean trim) {
1:4f996a4:             streamedParameter = null;
1:c050ed4:             typeLstEnd_ = 0;
1:c050ed4:             extLstEnd_ = 0;
1:c050ed4:             if (trim && typeLst_.length > 10) {
1:c050ed4:                 typeLst_ = new byte[10];
1:c050ed4:                 lenLst_ = new int[10];
1:c050ed4:                 extLst_ = new int[10];
1:c050ed4:             }
1:c050ed4:         }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>addDrdaParam</code> adds a new parameter with its
1:c050ed4:          * DRDA type and byte length. The arrays are automatically
1:c050ed4:          * grown if needed.
1:c050ed4:          *
1:c050ed4:          * @param t a <code>byte</code> value, the DRDA type of the
1:c050ed4:          * parameter being added
1:c050ed4:          * @param s an <code>int</code> value, the length in bytes of
1:c050ed4:          * the parameter being added
1:c050ed4:          */
1:c050ed4:         protected void addDrdaParam(byte t, int s) {
1:c050ed4:             if (typeLstEnd_ >= typeLst_.length) {
1:c050ed4:                 typeLst_ = (byte[])growArray(typeLst_);
1:c050ed4:                 lenLst_ = (int[])growArray(lenLst_);
1:c050ed4:             }
1:c050ed4:             typeLst_[typeLstEnd_] = t;
1:c050ed4:             lenLst_[typeLstEnd_] = s;
1:c050ed4:             ++typeLstEnd_;
1:c050ed4:         }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>getDrdaParamCount</code> return the number of
1:c050ed4:          * parameters added so far (since last clear).
1:c050ed4:          *
1:c050ed4:          * @return an <code>int</code> value, the number of parameters
1:c050ed4:          */
1:c050ed4:         protected int  getDrdaParamCount() { return typeLstEnd_; }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>getDrdaType</code> returns a byte that represents the
1:c050ed4:          * DRDA type of the ith parameter.
1:c050ed4:          *
1:c050ed4:          * @param i an <code>int</code> value, a parameter position
1:c050ed4:          * (zero-based)
1:c050ed4:          * @return a <code>byte</code> value, the DRDA type
1:c050ed4:          */
1:c050ed4:         protected byte getDrdaType(int i) { return typeLst_[i]; }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>getDrdaLen</code> returns the length in bytes of the
1:c050ed4:          * ith parameter.
1:c050ed4:          *
1:c050ed4:          * @param i an <code>int</code> value, a parameter position
1:c050ed4:          * (zero-based)
1:c050ed4:          * @return an <code>int</code> value
1:c050ed4:          */
1:c050ed4:         protected int getDrdaLen(int i) { return lenLst_[i]; }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>addExtPos</code> marks parameter i as external. The
1:c050ed4:          * array is grown as needed.
1:c050ed4:          *
1:c050ed4:          * @param p an <code>int</code> value, a parameter position
1:c050ed4:          * (zero-based)
1:c050ed4:          */
1:c050ed4:         protected void addExtPos(int p) {
1:c050ed4:             if (extLstEnd_ >= extLst_.length) {
1:c050ed4:                 extLst_ = (int[])growArray(extLst_);
1:c050ed4:             }
1:c050ed4:             extLst_[extLstEnd_] = p;
1:c050ed4:             ++extLstEnd_;
1:c050ed4:         }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>getExtPosCount</code> returns the number of
1:c050ed4:          * parameters marked as external so far (since last clear).
1:c050ed4:          *
1:c050ed4:          * @return an <code>int</code> value, the number of external
1:c050ed4:          * parameters.
1:c050ed4:          */
1:c050ed4:         protected int getExtPosCount() { return extLstEnd_; }
1:c050ed4: 
1:c050ed4:         /**
1:c050ed4:          * <code>getExtPos</code> returns the actual parameter position
1:c050ed4:          * of the ith external parameter.
1:c050ed4:          *
1:c050ed4:          * @param i an <code>int</code> value, index into the list of
1:c050ed4:          * external parameters, zero-based
1:c050ed4:          * @return an <code>int</code> value, the parameter position
1:c050ed4:          * of the ith external parameter (zero-based)
1:c050ed4:          */
1:c050ed4:         protected int getExtPos(int i) { return extLst_[i]; }
1:788599f:         
1:4f996a4:         /**
1:4f996a4:          * Read the rest of the streamed parameter if not consumed
1:4f996a4:          * by the executing statement.  DERBY-3085
1:4f996a4:          * @throws IOException
1:4f996a4:          */
1:4f996a4:         protected void drainStreamedParameter() throws IOException
1:4f996a4:         {
1:4f996a4:             if (streamedParameter != null)
1:4f996a4:             {   
1:4f996a4:                 // we drain the buffer 1000 bytes at a time.
1:4f996a4:                 // 1000 is just a random selection that doesn't take
1:4f996a4:                 // too much memory. Perhaps something else would be 
1:4f996a4:                 // more efficient?
1:4f996a4:                 byte[] buffer = new byte[1000];
1:4f996a4:                 int i;
1:4f996a4:                 do {
1:4f996a4:                     i= streamedParameter.read(buffer,0,1000);
1:4f996a4:                 }  while (i != -1);
1:c050ed4:             }
1:4f996a4:         }
1:788599f:             
1:788599f: 
1:4f996a4:         public void setStreamedParameter(EXTDTAReaderInputStream eis) {
1:4f996a4:             streamedParameter = eis;    
1:4f996a4:         }
1:4f996a4:         
1:4f996a4:     }
1:c050ed4:     private DrdaParamState drdaParamState_ = new DrdaParamState();
1:788599f: 
1:4f996a4:     // Query options  sent on EXCSQLSTT
1:4f996a4:     // These the default for ResultSets created for this statement.
1:4f996a4:     // These can be overriden by OPNQRY or CNTQRY,
1:db9a013:     protected int nbrrow;           // number of fetch or insert rows
1:4f996a4:     protected int qryrowset;            // Query row set
1:db9a013:     protected int blksize;              // Query block size
1:4f996a4:     protected int maxblkext;            // Maximum number of extra blocks
1:4f996a4:     protected int outovropt;            // Output Override option
1:4f996a4:     protected boolean qryrfrtbl;        // Query refresh answer set table
1:4f996a4:     private int qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;   // Protocol type
1:4f996a4:     
1:4f996a4:     
1:41f1df9: 
1:4f996a4:     boolean needsToSendParamData = false;
1:4f996a4:     boolean explicitlyPrepared = false;    //Prepared with PRPSQLSTT (reusable) 
1:4b9c0f5: 
1:4f996a4:     /**
1:f9a0689:      * If this changes, we need to re-send result set metadata to client, since
1:f9a0689:      * a change indicates the engine has recompiled the prepared statement.
1:4f996a4:      */
1:f9a0689:     long versionCounter;
1:4b9c0f5: 
1:4f996a4:     /**
1:bc23e21:      * Saved value returned from {@link DRDAConnThread#parsePRPSQLSTT}.
1:bc23e21:      * Used to determine if the statement is such that we may
1:f9a0689:      * need to re-send metadata at execute time, see {@link #versionCounter}.
1:4f996a4:      */
1:f9a0689:     int sqldaType;
1:4b9c0f5: 
1:4f996a4:     // constructor
1:4f996a4:     /**
1:4f996a4:      * DRDAStatement constructor
1:4f996a4:      *
1:4f996a4:      * @param database
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     DRDAStatement (Database database) 
1:4f996a4:     {
1:4f996a4:         this.database = database;
1:4f996a4:         setTypDefValues();
1:4f996a4:         this.currentDrdaRs = new DRDAResultSet();
1:4f996a4:     }
1:4b9c0f5: 
1:4f996a4:     /**
1:4f996a4:      * set TypDef values
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     protected void setTypDefValues()
1:4f996a4:     {
1:4f996a4:         // initialize statement values to current database values
1:4f996a4:         this.typDefNam = database.typDefNam;
1:4f996a4:         this.byteOrder = database.byteOrder;
1:4f996a4:         this.ccsidSBC = database.ccsidSBC;
1:4f996a4:         this.ccsidDBC = database.ccsidDBC;
1:4f996a4:         this.ccsidMBC = database.ccsidMBC;
1:4f996a4:         this.ccsidSBCEncoding = database.ccsidSBCEncoding;
1:4f996a4:         this.ccsidDBCEncoding = database.ccsidDBCEncoding;
1:4f996a4:         this.ccsidMBCEncoding = database.ccsidMBCEncoding;
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Set database
1:4f996a4:      *
1:4f996a4:      * @param database
1:4f996a4:      */
1:4f996a4:     protected void setDatabase(Database database)
1:4f996a4:     {
1:4f996a4:         this.database = database;
1:4f996a4:         setTypDefValues();
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Set statement
1:4f996a4:      *
1:db9a013:      * @param conn  Connection
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:4f996a4:     protected void setStatement(Connection conn)
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:f26c60c:         stmt = (EngineStatement) conn.createStatement();
1:4f996a4:         //beetle 3849 -  see  prepareStatement for details
1:4f996a4:         if (cursorName != null)
1:4f996a4:             stmt.setCursorName(cursorName);
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get the statement
1:4f996a4:      *
1:4f996a4:      * @return statement
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:f26c60c:     protected EngineStatement getStatement() 
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:4f996a4:         return stmt;
1:4f996a4:     }
1:fd8a779: 
1:b850119:     /**
1:b850119:      * Add a warning about data having been truncated.
1:b850119:      * @param w the warning to add
1:b850119:      */
1:b850119:     protected void addTruncationWarning(DataTruncation w) {
1:b850119:         if (truncationWarnings == null) {
1:b850119:             truncationWarnings = w;
1:b850119:         } else {
1:b850119:             truncationWarnings.setNextWarning(w);
1:b850119:         }
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Get the chain of truncation warnings added to this statement.
1:b850119:      * @return chain of truncation warnings, possibly {@code null}
1:b850119:      */
1:b850119:     protected DataTruncation getTruncationWarnings() {
1:b850119:         return truncationWarnings;
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Clear the chain of truncation warnings for this statement.
1:b850119:      */
1:b850119:     protected void clearTruncationWarnings() {
1:b850119:         truncationWarnings = null;
1:b850119:     }
1:b850119: 
1:4f996a4:     /**Set resultSet defaults to match 
1:4f996a4:      * the statement defaults sent on EXCSQLSTT
1:4f996a4:      * This might be overridden on OPNQRY or CNTQRY
1:4f996a4:      **/
1:4383496: 
1:4f996a4:     protected void setRsDefaultOptions(DRDAResultSet drs)
1:4f996a4:     {
1:4f996a4:         drs.nbrrow = nbrrow;
1:db9a013:         drs.qryrowset = qryrowset;
1:db9a013:         drs.blksize = blksize;
1:db9a013:         drs.maxblkext = maxblkext;
1:db9a013:         drs.outovropt = outovropt;
1:db9a013:         drs.rslsetflg = rslsetflg;
1:4f996a4:         drs.scrollType = scrollType;
1:4f996a4:         drs.concurType = concurType;
1:4f996a4:         drs.setQryprctyp(qryprctyp);
2:4f996a4:         drs.qryrowset = qryrowset;
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Get the extData Objects
1:4f996a4:      *
1:4f996a4:      *  @return ArrayList with extdta
1:4f996a4:      */
1:27fbf33:     protected ArrayList<Object> getExtDtaObjects()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getExtDtaObjects();
1:4f996a4:     }
1:4383496: 
1:4f996a4:     public void setSplitQRYDTA(byte []data)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.setSplitQRYDTA(data);
1:4f996a4:     }
1:4f996a4:     public byte[]getSplitQRYDTA()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getSplitQRYDTA();
1:4f996a4:     }
1:4f996a4:     
1:db9a013:     /**
1:4f996a4:      * Add extDtaObject
1:4f996a4:      * @param o - object to  add
1:4f996a4:      * @param jdbcIndex - jdbc index for parameter
1:4f996a4:      */
1:4f996a4:     protected void  addExtDtaObject (Object o, int jdbcIndex )
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.addExtDtaObject(o,jdbcIndex);
1:4f996a4:     }
1:4f996a4: 
1:4383496:     
1:4f996a4:     /**
1:4f996a4:      * Clear externalized lob objects in current result set
1:4f996a4:      */
1:4f996a4:     protected void  clearExtDtaObjects ()
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.clearExtDtaObjects();
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /*
1:4f996a4:      * Is lob object nullable
1:4f996a4:      * @param index - offset starting with 0
1:4f996a4:      * @return true if object is nullable
1:4f996a4:      */
1:4f996a4:     protected boolean isExtDtaValueNullable(int index)
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.isExtDtaValueNullable(index);
1:4f996a4:     }
1:4f996a4:     
1:4383496: 
1:4f996a4:     /**
1:a10e456:      * Set query options sent on OPNQRY and pass options down to the
1:a10e456:      * current <code>DRDAResultSet</code> object.
1:a10e456:      *
1:a10e456:      * @param blksize QRYBLKSZ (Query Block Size)
1:a10e456:      * @param qryblkctl QRYPRCTYP (Query Protocol Type)
1:a10e456:      * @param maxblkext MAXBLKEXT (Maximum Number of Extra Blocks)
1:a10e456:      * @param outovropt OUTOVROPT (Output Override Option)
1:a10e456:      * @param qryrowset QRYROWSET (Query Rowset Size)
1:a10e456:      * @param qryclsimpl QRYCLSIMP (Query Close Implicit)
1:4f996a4:      * @see DRDAResultSet#setOPNQRYOptions(int, int, int, int, int, int)
4:4f996a4:      */
1:4f996a4:     protected void setOPNQRYOptions(int blksize, int qryblkctl,
1:4f996a4:                                   int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
1:4f996a4:     {
1:a10e456:         this.blksize = blksize;
1:a10e456:         this.qryprctyp = qryblkctl;
1:a10e456:         this.maxblkext = maxblkext;
1:a10e456:         this.outovropt = outovropt;
1:a10e456:         this.qryrowset = qryrowset;
1:4f996a4:         currentDrdaRs.setOPNQRYOptions( blksize, qryblkctl, maxblkext, 
1:4f996a4:                 outovropt, qryrowset, qryclsimpl);
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /*
1:4f996a4:      * Set query options sent on CNTQRY
1:4f996a4:      */
1:4f996a4:     protected void setQueryOptions(int blksize, boolean qryrelscr, 
1:4f996a4:                                     long qryrownbr,
1:4f996a4:                                     boolean qryfrtbl,int nbrrow,int maxblkext,
1:4f996a4:                                     int qryscrorn, boolean qryrowsns,
1:4f996a4:                                     boolean qryblkrst,
1:4f996a4:                                     boolean qryrtndta,int qryrowset,
1:4f996a4:                                     int rtnextdta)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.blksize = blksize;
1:4f996a4:         currentDrdaRs.qryrelscr = qryrelscr;
1:4f996a4:         currentDrdaRs.qryrownbr = qryrownbr;
1:4f996a4:         currentDrdaRs.qryrfrtbl = qryrfrtbl;
1:4f996a4:         currentDrdaRs.nbrrow = nbrrow;
1:4f996a4:         currentDrdaRs.maxblkext = maxblkext;
1:4f996a4:         currentDrdaRs.qryscrorn = qryscrorn;
1:4f996a4:         currentDrdaRs.qryrowsns = qryrowsns;
1:4f996a4:         currentDrdaRs.qryblkrst = qryblkrst;
1:4f996a4:         currentDrdaRs.qryrtndta = qryrtndta;
1:4f996a4:         currentDrdaRs.qryrowset = qryrowset;
1:4f996a4:         currentDrdaRs.rtnextdta = rtnextdta;
4:4f996a4:     }
1:4383496: 
1:4383496: 
1:4383496: 
1:4f996a4:     protected void setQryprctyp(int qryprctyp)
1:4f996a4:     {
1:4f996a4:         this.qryprctyp = qryprctyp;
1:4f996a4:         currentDrdaRs.setQryprctyp(qryprctyp);
1:4f996a4:     }
1:f9a0689: 
1:4f996a4:     protected int  getQryprctyp()
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getQryprctyp();
1:4f996a4:     }
1:f9a0689: 
1:4f996a4:     protected void setQryrownbr(long qryrownbr)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.qryrownbr = qryrownbr;
1:4f996a4:     }
1:fdfc981: 
1:4f996a4:     protected long  getQryrownbr()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.qryrownbr;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected int  getQryrowset()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.qryrowset;
1:4f996a4:     }
1:4f996a4: 
1:eac0369:     
1:4f996a4:     protected int getBlksize()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.blksize;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void setQryrtndta(boolean qryrtndta)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.qryrtndta = qryrtndta;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected boolean  getQryrtndta()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.qryrtndta;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected void setQryscrorn(int qryscrorn)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.qryscrorn = qryscrorn;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected int  getQryscrorn()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.qryscrorn;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void setScrollType(int scrollType)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.scrollType = scrollType;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected int  getScrollType()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.scrollType;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /** 
1:4f996a4:      * is this a scrollable cursor?
1:4f996a4:      * return true if this is not a forward only cursor
1:4f996a4:      */
1:4f996a4:     protected boolean isScrollable()
1:4f996a4:     {
1:4f996a4:         return (getScrollType() != ResultSet.TYPE_FORWARD_ONLY);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected void setConcurType(int scrollType)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.concurType = scrollType;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected int  getConcurType()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.concurType;
1:4f996a4:     }
1:eac0369: 
1:db9a013:     protected void  setOutovr_drdaType(int[] outovr_drdaType)
1:4f996a4:     {
1:4f996a4:        currentDrdaRs.outovr_drdaType = outovr_drdaType;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected int[]     getOutovr_drdaType() 
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.outovr_drdaType;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     protected boolean hasdata()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.hasdata;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     protected void  setHasdata(boolean hasdata)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.hasdata = hasdata;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * This method is used to initialize the default statement of the database
1:4f996a4:      * for re-use. It is different from reset() method since default statements
1:3c9599f:      * get initialized differently. e.g: stmt variable used in default statement
1:4f996a4:      * is created only once in Database.makeConnection. 
1:3c9599f:      * The default statement will be initialized to have the same byte order 
1:3c9599f:      * etc as the server. This may be changed when a TYPEDEFNAM is received 
1:3c9599f:      * from the client in DRDAConnThread.setStmtOrDbByteOrder()
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void initialize() 
1:4f996a4:     {
1:4f996a4:         setTypDefValues();
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected PreparedStatement explicitPrepare(String sqlStmt) throws SQLException
1:4f996a4:     {
1:4f996a4:         explicitlyPrepared = true;
1:4f996a4:         return prepare(sqlStmt);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected boolean wasExplicitlyPrepared()
1:4f996a4:     {
1:4f996a4:         return explicitlyPrepared;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Create a prepared statement
1:4f996a4:      *
1:4f996a4:      * @param sqlStmt - SQL statement
1:4f996a4:      *
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:4f996a4:     protected PreparedStatement prepare(String sqlStmt)   throws SQLException
1:4f996a4:     {
1:4f996a4:         // save current prepare iso level
1:4f996a4:         int saveIsolationLevel = -1;
1:4f996a4:         boolean isolationSet = false;
1:4f996a4:         if (pkgnamcsn !=null && 
1:4f996a4:             isolationLevel != Connection.TRANSACTION_NONE)
1:4f996a4:         {
1:4f996a4:             saveIsolationLevel = database.getPrepareIsolation();
1:4f996a4:             database.setPrepareIsolation(isolationLevel);
1:4f996a4:             isolationSet = true;
1:4f996a4:         }
1:4f996a4:         
1:ce68ae0:         parsePkgidToFindHoldability();
1:ce68ae0: 
1:4f996a4:         if (isCallableSQL(sqlStmt))
1:4f996a4:         {
1:4f996a4:             isCall = true;
1:f26c60c:             ps = (EnginePreparedStatement) database.getConnection().prepareCall(
1:ce68ae0:                 sqlStmt, scrollType, concurType, withHoldCursor);
1:4f996a4:             setupCallableStatementParams((CallableStatement)ps);
1:4f996a4:         }
1:ce68ae0:         else
1:ce68ae0:         {
1:f26c60c:             ps = (EnginePreparedStatement) database.getConnection().prepareStatement(
1:ce68ae0:                 sqlStmt, scrollType, concurType, withHoldCursor);
1:ce68ae0:         }
1:ce68ae0: 
1:4f996a4:         // beetle 3849  -  Need to change the cursor name to what
1:4f996a4:         // JCC thinks it will be, since there is no way in the 
1:4f996a4:         // protocol to communicate the actual cursor name.  JCC keeps 
1:4f996a4:         // a mapping from the client cursor names to the DB2 style cursor names
1:4f996a4:         if (cursorName != null)//cursorName not null means we are dealing with dynamic pacakges
1:4f996a4:             ps.setCursorName(cursorName);
1:4f996a4:         if (isolationSet)
1:4f996a4:             database.setPrepareIsolation(saveIsolationLevel);
1:f9a0689: 
1:f9a0689:         versionCounter = ((EnginePreparedStatement)ps).getVersionCounter();
1:f9a0689: 
1:2e4a36f:         return ps;
1:4f996a4:     }
1:4e3b1b6: 
1:4f996a4:     /**
1:4f996a4:      * Get prepared statement
1:4f996a4:      *
1:4f996a4:      * @return prepared statement
1:4f996a4:      */
1:f26c60c:     protected EnginePreparedStatement getPreparedStatement() throws SQLException
1:4f996a4:     {
1:4f996a4:         return ps;
1:4f996a4:     }
1:4e3b1b6: 
1:4e3b1b6: 
1:4f996a4:     /**
1:4f996a4:      * Executes the prepared statement and populates the resultSetTable.
1:4f996a4:      * Access to the various resultSets is then possible by using
1:4f996a4:      * setCurrentDrdaResultSet(String pkgnamcsn)  to set the current
1:4f996a4:      * resultSet and then calling getResultSet() or the other access 
1:4f996a4:      * methods to get resultset data.
1:4f996a4:      *
1:4f996a4:      * @return true if the execution has resultSets
1:4f996a4:      */
1:4f996a4:     protected boolean execute() throws SQLException
1:4f996a4:     {
1:4f996a4:         boolean hasResultSet = ps.execute();
1:4f996a4:         // DERBY-3085 - We need to make sure we drain the streamed parameter
1:4f996a4:         // if not used by the server, for example if an update statement does not 
1:4f996a4:         // update any rows, the parameter won't be used.  Network Server will
1:4f996a4:         // stream only the last parameter with an EXTDTA. This is stored when the
1:4f996a4:         // parameter is set and drained now after statement execution if needed.
1:4f996a4:         try {
1:4f996a4:             drdaParamState_.drainStreamedParameter();
1:4f996a4:         } catch (IOException e) { 
1:41e4ad8:             throw Util.javaException(e);
1:4f996a4:         }
1:4f996a4:         // java.sql.Statement says any result sets that are opened
1:4f996a4:         // when the statement is re-executed must be closed; this
1:4f996a4:         // is handled by the call to "ps.execute()" above--but we
1:4f996a4:         // also have to reset our 'numResultSets' counter, since
1:4f996a4:         // all previously opened result sets are now invalid.
1:4f996a4:         numResultSets = 0;
1:9ce79e7: 
1:4f996a4:         ResultSet rs = null;
1:4f996a4:         boolean isCallable = (ps instanceof java.sql.CallableStatement);
1:4f996a4:         if (isCallable)
1:4f996a4:             needsToSendParamData = true;
1:4e3b1b6: 
1:4f996a4:         do {
1:4f996a4:             rs = ps.getResultSet();
1:4f996a4:             if (rs !=null)
1:4f996a4:             {
1:4f996a4:                 //For callable statement, get holdability of statement generating the result set
1:4f996a4:                 if(isCallable)
1:8514aa2:                     addResultSet(rs, rs.getHoldability());
1:4f996a4:                 else
1:4f996a4:                     addResultSet(rs,withHoldCursor);
1:4f996a4:                 hasResultSet = true;
1:4f996a4:             }
1:4f996a4:             // For normal selects we are done, but procedures might
1:4f996a4:             // have more resultSets
1:4f996a4:         }while (isCallable && getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:eac0369: 
1:4f996a4:         return hasResultSet;
1:4f996a4: 
1:4f996a4:     }
1:eac0369:     
1:4f996a4:     /**
1:4f996a4:      * clear out type data for parameters.
1:4f996a4:      * Unfortunately we currently overload the resultSet type info
1:4f996a4:      * rsDRDATypes et al with parameter info.
1:4f996a4:      * RESOLVE: Need to separate this
1:4f996a4:      */
1:eac0369:    protected void finishParams()
1:4f996a4:     {
2:4f996a4:         needsToSendParamData = false;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Set the pkgid sec num for this statement and the 
1:4f996a4:      * consistency token that will be used for the first resultSet.
1:4f996a4:      * For dyamic packages The package name is encoded as follows
1:4f996a4:      * SYS(S/L)(H/N)xyy 
1:4f996a4:      * where 'S' represents Small package and 'L' large 
1:4f996a4:      *                      (ignored by Derby) 
1:4f996a4:      * Where 'H' represents WITH HOLD, and 'N' represents NO WITH HOLD. 
1:4f996a4:      *                      (May be overridden by SQLATTR for WITH
1:4f996a4:      *                       HOLD")
1:4f996a4:      *
1:4f996a4:      * Where 'www' is the package iteration (ignored by Derby)
1:4f996a4:      * Where 'x' is the isolation level: 0=NC, 1=UR, 2=CS, 3=RS, 4=RR 
1:4f996a4:      * Where 'yy' is the package iteration 00 through FF 
1:4f996a4:      * Where 'zz' is unique for each platform
1:4f996a4:      * Happilly, these values correspond precisely to the internal Derby
1:4f996a4:      * isolation levels  in ExecutionContext.java
1:4f996a4:      * x   Isolation Level                                           
1:4f996a4:      * --  ---------------------
1:4f996a4:      * 0   NC  (java.sql.Connection.TRANSACTION_NONE)
1:4f996a4:      * 1   UR  (java.sql.Connection.TRANACTION_READ_UNCOMMITTED)
1:4f996a4:      * 2   CS  (java.sql.Connection.TRANSACTION_READ_COMMITTED)
1:4f996a4:      * 3   RS  (java.sql.Connection.TRANSACTION_REPEATABLE_READ)
1:4f996a4:      * 4   RR  (java.sql.Connection.TRANSACTION_SERIALIZABLE)
1:4f996a4:      * 
1:4f996a4:      * static packages have preset isolation levels 
1:4f996a4:      * (see getStaticPackageIsolation)
1:4f996a4:      * @param pkgnamcsn  package id section number and token from the client
1:4f996a4:      */
1:4f996a4:     protected void setPkgnamcsn(Pkgnamcsn pkgnamcsn)
1:4f996a4:     {
1:4f996a4:         this.pkgnamcsn =  pkgnamcsn;
1:4f996a4:         // Store the consistency string for the first ResultSet.
1:4f996a4:         // this will be used to calculate consistency strings for the 
1:4f996a4:         // other result sets.
1:3c9599f:         String pkgid = pkgnamcsn.getPkgid();
1:eac0369: 
1:4f996a4:         if (isDynamicPkgid(pkgid))
1:4f996a4:         {
1:4f996a4:             isolationLevel = Integer.parseInt(pkgid.substring(5,6));
1:4f996a4:             
1:4f996a4:             
1:4f996a4:             /*
1:4f996a4:              *   generate DB2-style cursorname
1:4f996a4:              *   example value : SQL_CURSN200C1
1:4f996a4:              *   where 
1:4f996a4:              *      SQL_CUR is db2 cursor name prefix;
1:4f996a4:              *      S - Small package , L -Large package
1:4f996a4:              *      N - normal cursor, H - hold cursor 
1:4f996a4:              *      200 - package id as sent by jcc 
1:4f996a4:              *      C - tack-on code for cursors
1:db9a013:              *      1 - section number sent by jcc
1:4f996a4:              */
1:4f996a4:             
1:4f996a4:             
1:eac0369: 
1:4f996a4:             // cursor name
1:4f996a4:             // trim the SYS off the pkgid so it wont' be in the cursor name
1:4f996a4:             String shortPkgid = pkgid.substring(pkgid.length() -5 , pkgid.length());
1:3c9599f:             int pkgsn = pkgnamcsn.getPkgsn();
1:4f996a4:             this.cursorName = "SQL_CUR" +  shortPkgid + "C" + pkgsn ;
1:4f996a4:         }
1:4f996a4:         else // static package
1:4f996a4:         {
1:4f996a4:             isolationLevel = getStaticPackageIsolation(pkgid);
1:4f996a4:         }
1:eac0369: 
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * get the isolation level for a static package.
1:4f996a4:      * @param pkgid - Package identifier string (e.g. SYSSTAT)
1:4f996a4:      * @return isolation
1:4f996a4:      */
1:4f996a4:     private int getStaticPackageIsolation(String pkgid)
1:4f996a4:     {
1:4f996a4:         // SYSSTAT is used for metadata. and is the only static package used
1:4f996a4:         // for JCC. Other static packages will need to be supported for 
1:4f996a4:         // CCC. Maybe a static hash table would then be in order.
1:4f996a4:         if (pkgid.equals("SYSSTAT"))
1:38f02ec:             return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;
1:4f996a4:         else
1:38f02ec:             return TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Get pkgnamcsn
6:4f996a4:      *
1:4f996a4:      * @return pkgnamcsn
1:4f996a4:      */
1:4f996a4:     protected Pkgnamcsn getPkgnamcsn() 
1:4f996a4:     {
1:4f996a4:         return pkgnamcsn;
1:eac0369: 
1:4f996a4:     }
1:4f996a4:     /**
1:4f996a4:      * Get result set
1:4f996a4:      *
1:4f996a4:      * @return result set
1:4f996a4:      */
1:4f996a4:     protected ResultSet getResultSet() 
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getResultSet();
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Gets the current DRDA ResultSet
1:4f996a4:      * 
1:4f996a4:      * @return DRDAResultSet
1:4f996a4:      */
1:4f996a4:     protected DRDAResultSet getCurrentDrdaResultSet()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs ;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:db9a013:      * Set currentDrdaResultSet
1:4f996a4:      *
1:4f996a4:      * @param rsNum   The result set number starting with 0
1:4f996a4:      *                 
1:4f996a4:      */
1:4f996a4:     protected void setCurrentDrdaResultSet(int rsNum)
1:4f996a4:     {
1:4f996a4:         ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
1:4f996a4:         if (currentDrdaRs.pkgcnstkn == consistToken)
1:4f996a4:             return;
1:4f996a4:         currentDrdaRs = getDrdaResultSet(consistToken);
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:db9a013:      * Set currentDrdaResultSet
1:4f996a4:      *
1:4f996a4:      * @param pkgnamcsn  The pkgid section number and unique resultset
1:4f996a4:      *                    consistency token
1:4f996a4:      *                 
1:4f996a4:      */
1:4f996a4:     protected void setCurrentDrdaResultSet(Pkgnamcsn pkgnamcsn)
1:4f996a4:     {
1:3c9599f:         this.pkgnamcsn = pkgnamcsn;
1:4f996a4:         ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
1:4f996a4:         DRDAResultSet newDrdaRs = getDrdaResultSet(consistToken);
1:4f996a4:         if (newDrdaRs != null)
1:4f996a4:             currentDrdaRs = newDrdaRs;
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /*
1:4f996a4:      * get DRDAResultSet by consistency token
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     private DRDAResultSet getDrdaResultSet(ConsistencyToken consistToken)
1:4f996a4:     {
1:4f996a4:         if ( resultSetTable   == null || 
1:4f996a4:              (currentDrdaRs != null &&
1:4f996a4:               currentDrdaRs.pkgcnstkn == consistToken ))
1:4f996a4:         {
1:4f996a4:             return currentDrdaRs;
1:4f996a4:         }
1:4f996a4:         else
1:4f996a4:         {
1:4f996a4:             return (DRDAResultSet) (resultSetTable.get(consistToken));
1:4f996a4:         }
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /*
1:4f996a4:      * get DRDAResultSet by result set number
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     private DRDAResultSet getDrdaResultSet(int rsNum)
1:4f996a4:     {
1:4f996a4:         ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
1:4f996a4:         return getDrdaResultSet(consistToken);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /** Add a new resultSet to this statement.
1:4f996a4:      * Set as the current result set if  there is not an 
1:4f996a4:      * existing current resultset.
1:4f996a4:      * @param value - ResultSet to add
1:4f996a4:      * @param holdValue - Holdability of the ResultSet 
1:4f996a4:      * @return    Consistency token  for this resultSet
1:4f996a4:      *            For a single resultSet that is the same as the statement's 
1:4f996a4:      *            For multiple resultSets just the consistency token is changed 
1:4f996a4:      */
1:4f996a4:     protected ConsistencyToken addResultSet(ResultSet value, int holdValue) throws SQLException
1:4f996a4:     {
1:eac0369: 
1:4f996a4:         DRDAResultSet newDrdaRs = null;
1:eac0369: 
1:4f996a4:         int rsNum = numResultSets;
1:4f996a4:         ConsistencyToken newRsPkgcnstkn = calculateResultSetPkgcnstkn(rsNum);
1:eac0369: 
1:4f996a4:         if (rsNum == 0)
1:4f996a4:             newDrdaRs = currentDrdaRs;
1:eac0369: 
1:4f996a4:         else
1:4f996a4:         {
1:4f996a4:             newDrdaRs = new DRDAResultSet();
1:eac0369: 
1:4f996a4:             // Multiple resultSets we neeed to setup the hash table
1:4f996a4:             if (resultSetTable == null)
1:4f996a4:             {
1:4f996a4:                 // If hashtable doesn't exist, create it and store resultSet 0
1:4f996a4:                 // before we store our new resultSet.
1:4f996a4:                 // For just a single resultSet we don't ever create the Hashtable.
1:27fbf33:                 resultSetTable =
1:27fbf33:                         new Hashtable<ConsistencyToken, DRDAResultSet>();
1:3c9599f:                 ConsistencyToken pkgcnstkn = pkgnamcsn.getPkgcnstkn();
1:4f996a4:                 resultSetTable.put(pkgcnstkn, currentDrdaRs);
1:27fbf33:                 resultSetKeyList = new ArrayList<ConsistencyToken>();
1:4f996a4:                 resultSetKeyList.add(0, pkgcnstkn);
1:4f996a4:             }
1:eac0369: 
1:4f996a4:             resultSetTable.put(newRsPkgcnstkn, newDrdaRs);
1:4f996a4:             resultSetKeyList.add(rsNum, newRsPkgcnstkn);
1:4f996a4:         }
1:eac0369: 
1:4f996a4:         newDrdaRs.setResultSet(value);
1:4f996a4:         newDrdaRs.setPkgcnstkn(newRsPkgcnstkn);
1:4f996a4:         newDrdaRs.withHoldCursor = holdValue;
1:4f996a4:         setRsDefaultOptions(newDrdaRs);
1:4f996a4:         newDrdaRs.suspend();
1:4f996a4:         numResultSets++;
1:4f996a4:         return newRsPkgcnstkn;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      *
1:db9a013:      * @return  number of result sets
1:4f996a4:      */
1:4f996a4:     protected int getNumResultSets()
1:4f996a4:     {
1:4f996a4:         return numResultSets;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * @param rsNum result set starting with 0
1:db9a013:      * @return  consistency token (key) for the result set
1:4f996a4:      */
1:4f996a4:     protected ConsistencyToken getResultSetPkgcnstkn(int rsNum)
1:4f996a4:     {
1:4f996a4:         if (rsNum == 0)
1:3c9599f:             return pkgnamcsn.getPkgcnstkn();
1:4f996a4:         else 
1:db9a013:             return (ConsistencyToken) resultSetKeyList.get(rsNum);
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      *@return ResultSet DRDA DataTypes
1:4f996a4:      **/
1:eac0369: 
1:4f996a4:     protected int[] getRsDRDATypes()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getRsDRDATypes();
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      *  Close the current resultSet
1:4f996a4:      */
1:4f996a4:     protected void rsClose() throws SQLException
1:4f996a4:     {
1:4f996a4:         if (currentDrdaRs.getResultSet() == null) 
1:4f996a4:             return;
1:eac0369: 
1:4f996a4:         currentDrdaRs.close();
1:db9a013:         needsToSendParamData = false;
1:4f996a4:         numResultSets--;
1:4f996a4:     }
1:f0dcf0b: 
1:4f996a4:     /**
1:4f996a4:      * Explicitly close the result set by CLSQRY
1:4f996a4:      * needed to check for double close.
1:4f996a4:      */
1:4f996a4:     protected void CLSQRY()
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.CLSQRY();
1:4f996a4:     }
1:f0dcf0b: 
1:4f996a4:     /* 
1:4f996a4:      * @return whether CLSQRY has been called on the
1:4f996a4:      *         current result set.
1:4f996a4:      */
1:4f996a4:     protected boolean wasExplicitlyClosed()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.wasExplicitlyClosed();
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * This method closes the JDBC objects and frees up all references held by
1:4f996a4:      * this object.
1:4f996a4:      * 
1:4f996a4:      * @throws SQLException
1:4f996a4:      */
1:4f996a4:     protected void close()  throws SQLException
1:4f996a4:     {
1:4f996a4:         if (ps != null)
1:4f996a4:             ps.close();
1:4f996a4:         if (stmt != null)
1:4f996a4:             stmt.close();
1:4f996a4:         currentDrdaRs.close();
1:4f996a4:         resultSetTable = null;
1:4f996a4:         resultSetKeyList = null;
1:4f996a4:         ps = null;
1:4f996a4:         stmtPmeta = null;
1:4f996a4:         stmt = null;
1:b850119:         truncationWarnings = null;
1:4f996a4:         rslsetflg = null;
1:4f996a4:         procName = null;
1:4f996a4:         outputTypes = null;
1:4f996a4:         outputPrecision = null;
1:4f996a4:         outputScale = null;
1:c050ed4:         // Clear parameters and release excess storage
1:c050ed4:         drdaParamState_.clear(true);
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * This method resets the state of this DRDAStatement object so that it can
1:4f996a4:      * be re-used. This method should reset all variables of this class except 
1:4f996a4:      * the following:
1:f0dcf0b:      * 1. database - This variable gets initialized in the constructor and by
1:f0dcf0b:      * call to setDatabase.
1:f0dcf0b:      * 2. members which get initialized in setPkgnamcsn (pkgnamcsn, pkgcnstkn, 
1:f0dcf0b:      * pkgid, pkgsn, isolationLevel, cursorName). pkgnamcsn is the key used to 
1:f0dcf0b:      * find if the DRDAStatement can be re-used. Hence its value will not change 
1:f0dcf0b:      * when the object is re-used.
1:4f996a4:      * 
1:4f996a4:      */
1:4f996a4:     protected void reset() 
1:4f996a4:     {
1:4f996a4:         setTypDefValues();
1:4f996a4:         
1:4f996a4:         withHoldCursor = -1;
1:db9a013:         scrollType = ResultSet.TYPE_FORWARD_ONLY;
1:4f996a4:         concurType = ResultSet.CONCUR_READ_ONLY;;
1:4f996a4:         rowCount = 0;
1:4f996a4:         rslsetflg = null;
1:4f996a4:         maxrslcnt = 0;
1:4f996a4:         ps = null;
1:4f996a4:         stmtPmeta = null;
1:4f996a4:         isCall = false;
1:4f996a4:         procName = null;
1:4f996a4:         outputTypes = null;
1:4f996a4:         outputExpected = false;
1:4f996a4:         stmt = null;
1:b850119:         truncationWarnings = null;
1:4f996a4:         
1:4f996a4:         currentDrdaRs.reset();
1:4f996a4:         resultSetTable = null;
1:4f996a4:         resultSetKeyList = null;
1:4f996a4:         numResultSets = 0;
1:4f996a4:         
1:c050ed4:         // Clear parameters without releasing storage
1:c050ed4:         drdaParamState_.clear(false);
1:4f996a4:         
1:4f996a4:         nbrrow = 0;
1:db9a013:         qryrowset = 0;
1:4f996a4:         blksize = 0;        
1:db9a013:         maxblkext = 0;
1:db9a013:         outovropt = 0;
1:4f996a4:         qryrfrtbl = false;
1:4f996a4:         qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;
1:f0dcf0b: 
1:4f996a4:         needsToSendParamData = false;
1:4f996a4:         explicitlyPrepared = false;
1:4f996a4:     }
1:f0dcf0b: 
1:4f996a4:     /**
1:4f996a4:      * is Statement closed
1:4f996a4:      * @return whether the statement is closed
1:4f996a4:      */
1:4f996a4:     protected boolean rsIsClosed()
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.isClosed();
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      * Set state to SUSPENDED (result set is opened)
1:4f996a4:      */
1:4f996a4:     protected void rsSuspend()
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.suspend();
1:4f996a4:     }
1:f0dcf0b: 
1:f0dcf0b: 
1:4f996a4:     /**
1:4f996a4:      * set resultset/out parameter precision
1:4f996a4:      *
2:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param precision
1:4f996a4:      */
1:4f996a4:     protected void setRsPrecision(int index, int precision)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.setRsPrecision(index,precision);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:c6892a1:      * get resultset /out parameter precision
1:4f996a4:      * @param index -starting with 1
1:4f996a4:      * @return precision of column
1:4f996a4:      */
1:4f996a4:     protected int getRsPrecision(int index)
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getRsPrecision(index);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * set resultset/out parameter scale
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param scale
1:4f996a4:      */
1:4f996a4:     protected void setRsScale(int index, int scale)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.setRsScale(index, scale);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:c6892a1:      * get resultset /out parameter scale
1:4f996a4:      * @param index -starting with 1
1:4f996a4:      * @return scale of column
1:4f996a4:      */
1:4f996a4:     protected int  getRsScale(int index)
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getRsScale(index);
1:4f996a4:     }
1:4f996a4:     
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * set result  DRDAType
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @param type
1:4f996a4:      */
1:4f996a4:     protected  void setRsDRDAType(int index, int type)
1:4f996a4:     {
1:4f996a4:         currentDrdaRs.setRsDRDAType(index,type);
1:4f996a4:         
1:4f996a4:     }
1:eac0369: 
1:c050ed4:     /** Clears the parameter state (type, length and ext information)
1:c050ed4:      * stored in this statement, but does not release any
1:c050ed4:      * storage. This reduces the cost of re-executing the statement
1:c050ed4:      * since no new storage needs to be allocated. */
1:c050ed4:     protected void clearDrdaParams() {
1:c050ed4:         drdaParamState_.clear(false);
1:c050ed4:     }
1:c050ed4: 
1:c050ed4:     /** Get the number of external parameters in this
1:c050ed4:      * statement. External means parameters that are transmitted in a
1:c050ed4:      * separate DSS in the DRDA protocol.
1:c050ed4:      * @return the number of external parameters
1:c050ed4:      */
1:c050ed4:     protected int getExtPositionCount() {
1:c050ed4:         return drdaParamState_.getExtPosCount();
1:c050ed4:     }
1:c050ed4: 
1:c050ed4:     /** Get the parameter position of the i'th external parameter
1:c050ed4:      * @param i - zero-based index into list of external parameters
1:c050ed4:      * @return the parameter position of the i'th external parameter
1:c050ed4:      */
1:c050ed4:     protected int getExtPosition(int i) {
1:c050ed4:         return drdaParamState_.getExtPos(i);
1:c050ed4:     }
1:c050ed4: 
1:c050ed4:     /** Mark the pos'th parameter as external
1:c050ed4:      * @param pos - zero-based index into list of external parameters
1:c050ed4:      */
1:c050ed4:     protected void addExtPosition(int pos) {
1:c050ed4:         drdaParamState_.addExtPos(pos);
1:c050ed4:     }
1:c050ed4: 
1:c050ed4:     /** Get the number of parameters, internal and external, that has
1:c050ed4:      * been added to this statement.
1:c050ed4:      * @return the number of parameters
1:c050ed4:      */
1:c050ed4:     protected int getDrdaParamCount() {
1:c050ed4:         return drdaParamState_.getDrdaParamCount();
1:c050ed4:     }
1:c050ed4: 
1:c050ed4:     /** Add another parameter to this statement.
1:c050ed4:      * @param t - type of the parameter
1:c050ed4:      * @param l - length in bytes of the parameter
1:c050ed4:      */
1:c050ed4:     protected void addDrdaParam(byte t, int l) {
1:c050ed4:         drdaParamState_.addDrdaParam(t, l);
1:c050ed4:     }
1:c050ed4: 
1:788599f:     protected void setStreamedParameter(EXTDTAReaderInputStream eis)
1:4f996a4:     {
1:788599f:         drdaParamState_.setStreamedParameter(eis);
1:c050ed4:     }
1:788599f:     
1:4f996a4:     /**
1:4f996a4:      * get parameter DRDAType
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @return  DRDA Type of column
1:4f996a4:      */
1:db9a013:     protected int getParamDRDAType(int index) {
1:c050ed4:         return drdaParamState_.getDrdaType(index-1);
1:db9a013:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * returns drda length of parameter as sent by client.
1:c050ed4:      * @param index - starting with 1
1:4f996a4:      * @return data length
1:eac0369: 
1:4f996a4:      */
1:4f996a4:     protected int getParamLen(int index)
1:4f996a4:     {
1:c050ed4:         return drdaParamState_.getDrdaLen(index-1);
1:4f996a4:     }
1:c050ed4: 
1:c050ed4: 
1:4f996a4:     /**
1:4f996a4:      *  get parameter precision or DB2 max (31)
1:4f996a4:      *
1:4f996a4:      *  @param index parameter index starting with 1
1:4f996a4:      *
1:4f996a4:      *  @return  precision
1:4f996a4:      */
1:4f996a4:     protected int getParamPrecision(int index) throws SQLException
1:4f996a4:     {
1:4f996a4:         if (ps != null && ps instanceof CallableStatement)
1:4f996a4:         {
1:3634d6e:             ParameterMetaData pmeta = getParameterMetaData();
1:4383496: 
1:4f996a4:             return Math.min(pmeta.getPrecision(index),
1:4f996a4:                             FdocaConstants.NUMERIC_MAX_PRECISION);
1:eac0369: 
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:             return -1;
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     /**
1:4f996a4:      *  get parameter scale or DB2 max (31)
1:4f996a4:      *
1:4f996a4:      *  @param index parameter index starting with 1
1:4f996a4:      *
1:4f996a4:      *  @return  scale
1:4f996a4:      */
1:4f996a4:     protected int getParamScale(int index) throws SQLException
1:4f996a4:     {
1:4f996a4:         if (ps != null && ps instanceof CallableStatement)
1:4f996a4:         {
1:3634d6e:             ParameterMetaData pmeta = getParameterMetaData();
1:4f996a4:             return Math.min(pmeta.getScale(index),FdocaConstants.NUMERIC_MAX_PRECISION);
1:4f996a4:         }
1:4f996a4:         else 
1:4f996a4:             return -1;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /** 
1:4f996a4:      * get the number of result set columns for the current resultSet
1:4f996a4:      * 
1:4f996a4:      * @return number of columns
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     protected int getNumRsCols()
1:4f996a4:     {
1:4f996a4:         int[] rsDrdaTypes = getRsDRDATypes();
1:4f996a4:         if (rsDrdaTypes != null)
1:4f996a4:             return rsDrdaTypes.length;
1:4f996a4:         else 
1:4f996a4:             return 0;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * get  resultset/out parameter DRDAType
1:4f996a4:      *
1:4f996a4:      * @param index - starting with 1
1:4f996a4:      * @return  DRDA Type of column
1:4f996a4:      */
1:4f996a4:     protected int getRsDRDAType(int index)
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getRsDRDAType(index);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * get resultset/out parameter DRDALen
1:4f996a4:      * @param index starting with 1
1:4f996a4:      * 
1:4f996a4:      * @return length of drda data
1:4f996a4:      */
1:4f996a4:      
1:4f996a4:     protected int getRsLen(int index)
1:4f996a4:     {
1:4f996a4:         return currentDrdaRs.getRsLen(index);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * @param rsNum  - result set # starting with 0 
1:4f996a4:      */
1:4f996a4:     public String getResultSetCursorName(int rsNum) throws SQLException
1:4f996a4:     {
1:4f996a4:         DRDAResultSet drdaRs = getDrdaResultSet(rsNum);
1:db9a013:         return drdaRs.getResultSetCursorName();
1:eac0369: 
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:4f996a4:     protected String toDebugString(String indent)
1:db9a013:     {
1:4f996a4:         String s ="";
1:4f996a4:         if (ps == null) 
1:4f996a4:             s += indent + ps;
1:4f996a4:         else
1:4f996a4:         {
1:3c9599f:             s += indent + pkgnamcsn.getPkgid() + pkgnamcsn.getPkgsn() ;
1:4f996a4:             s += "\t" + getSQLText();
1:4f996a4:         }
1:4f996a4:         return s;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**  For a single result set, just echo the consistency token that the client sent us.
1:4f996a4:      * For subsequent resultSets, just subtract the resultset number from
1:4f996a4:      * the consistency token and that will differentiate the result sets.
1:4f996a4:      * This seems to be what DB2 does
1:4f996a4:      * @param rsNum  - result set # starting with 0
1:4f996a4:      * 
1:4f996a4:      * @return  Consistency token for result set
1:4f996a4:      */
1:eac0369: 
1:4f996a4:     protected ConsistencyToken calculateResultSetPkgcnstkn(int rsNum)
1:db9a013:     {
1:3c9599f:         ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
1:eac0369: 
1:3c9599f:         if (rsNum == 0 || consistToken == null)
1:4f996a4:             return consistToken;
1:4f996a4:         else
1:4f996a4:         {
1:4f996a4:             BigInteger consistTokenBi =
1:4f996a4:                 new BigInteger(consistToken.getBytes());
1:4f996a4:             BigInteger rsNumBi = BigInteger.valueOf(rsNum);
1:4f996a4:             consistTokenBi = consistTokenBi.subtract(rsNumBi);
1:4f996a4:             consistToken = new ConsistencyToken(consistTokenBi.toByteArray());
1:4f996a4:         }
1:4f996a4:         return consistToken;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected boolean isCallableStatement()
1:4f996a4:     {
1:4f996a4:         return isCall;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     private boolean isCallableSQL(String sql)
1:4f996a4:     {
1:4f996a4:         java.util.StringTokenizer tokenizer = new java.util.StringTokenizer
1:4f996a4:             (sql, "\t\n\r\f=? (");
1:4bdaec2:         if (!tokenizer.hasMoreTokens()) {
1:4bdaec2:             return false;
1:4bdaec2:         }
1:4f996a4:          String firstToken = tokenizer.nextToken();
1:4f996a4:          if (StringUtil.SQLEqualsIgnoreCase(firstToken, 
1:4f996a4:                                             "call")) // captures CALL...and ?=CALL...
1:4f996a4:              return true;
1:4f996a4:          return false;
1:4f996a4:                  
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     private void setupCallableStatementParams(CallableStatement cs) throws SQLException
1:4f996a4:     {
1:3634d6e:         ParameterMetaData pmeta = getParameterMetaData();
1:4f996a4:         int numElems = pmeta.getParameterCount();
1:eac0369: 
1:4f996a4:         for ( int i = 0; i < numElems; i ++)
1:4f996a4:         {
1:4f996a4:             boolean outputFlag = false;
1:4f996a4:             
1:4f996a4:             int parameterMode = pmeta.getParameterMode(i + 1);
1:4f996a4:             int parameterType = pmeta.getParameterType(i + 1);
1:6eb5042:                         int parameterPrecision = pmeta.getPrecision(i + 1);
1:6eb5042:                         int parameterScale = pmeta.getScale(i + 1);
1:eac0369: 
1:4f996a4:             switch (parameterMode) {
1:e33b8d8:                 case (ParameterMetaData.parameterModeIn):
1:4f996a4:                     break;
1:e33b8d8:                 case (ParameterMetaData.parameterModeOut):
1:e33b8d8:                 case (ParameterMetaData.parameterModeInOut):
1:4f996a4:                     outputFlag = true;
1:4f996a4:                     break;
1:e33b8d8:                 case (ParameterMetaData.parameterModeUnknown):
1:4f996a4:                     // It's only unknown if array
1:4f996a4:                     String objectType = pmeta.getParameterClassName(i+1);
1:4f996a4:                     parameterType =
1:4f996a4:                         getOutputParameterTypeFromClassName(objectType);
1:4f996a4:                     if (parameterType  != NOT_OUTPUT_PARAM)
1:4f996a4:                         outputFlag = true;
1:4f996a4:             }
1:eac0369: 
1:4f996a4:             if (outputFlag)
1:4f996a4:             {
1:4f996a4:                 if (outputTypes == null) //not initialized yet, since previously none output
1:4f996a4:                 {
1:4f996a4:                     outputTypes = new int[numElems];
1:4f996a4:                     outputPrecision = new int [numElems];
1:4f996a4:                     outputScale = new int [numElems];
1:4f996a4:                     for (int j = 0; j < numElems; j++) {
1:4f996a4:                         outputTypes[j] = NOT_OUTPUT_PARAM;  //default init value
1:4f996a4:                         outputPrecision[j] = NOT_OUTPUT_PARAM;
1:4f996a4:                         outputScale[j] = NOT_OUTPUT_PARAM;
1:4f996a4:                     }
1:4f996a4:                 }
1:4f996a4:                 // save the output type so we can register when we parse
1:4f996a4:                 // the SQLDTA
1:4f996a4:                 outputTypes[i] = parameterType;
1:4f996a4:                 outputPrecision[i] = parameterPrecision;
1:4f996a4:                 outputScale[i] = parameterScale;                
1:4f996a4:             }
1:4f996a4:             
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:4f996a4:     /** 
1:4f996a4:         Given an object class  name get the paramameter type if the 
1:4f996a4:         parameter mode is unknown.
1:4f996a4:         
1:4f996a4:         Arrays except for byte arrrays are assumed to be output parameters
1:4f996a4:         TINYINT output parameters are going to be broken because there
1:4f996a4:         is no way to differentiate them from binary input parameters.
1:4f996a4:         @param objectName Class name of object being evaluated.
1:4f996a4:         indicating if this an output parameter
1:4f996a4:         @return type from java.sql.Types
1:4f996a4:     **/
1:4f996a4:     
1:4f996a4:     protected static int getOutputParameterTypeFromClassName(String
1:4f996a4:                                                                     objectName)
1:4f996a4:     {
1:4f996a4:         
1:4f996a4:         if (objectName.endsWith("[]"))
1:4f996a4:         {
1:4f996a4:                     // For byte[] we are going to assume it is input.
1:4f996a4:             // For TINYINT output params you gotta use 
1:db9a013:             //  object Integer[] or use a procedure
1:4f996a4:                     if (objectName.equals("byte[]"))
1:4f996a4:                     {
1:4f996a4:                         return NOT_OUTPUT_PARAM;
1:4f996a4:                             
2:4f996a4:                             //isOutParam[offset] = false;
1:4f996a4:                             //return java.sql.Types.VARBINARY;
1:4f996a4:                     }
1:4f996a4:                     
1:4f996a4:                     // Known arrays are output parameters
1:4f996a4:                     // otherwise we pass it's a JAVA_OBJECT
1:4f996a4:                     if (objectName.equals("java.lang.Byte[]"))
1:4f996a4:                         return java.sql.Types.TINYINT;
1:4f996a4:                     
1:4f996a4:                     if (objectName.equals("byte[][]"))
1:4f996a4:                         return java.sql.Types.VARBINARY;
1:4f996a4:                     if (objectName.equals("java.lang.String[]"))
1:4f996a4:                         return java.sql.Types.VARCHAR; 
1:4f996a4:                     if (objectName.equals("int[]") || 
1:4f996a4:                         objectName.equals("java.lang.Integer[]"))
1:4f996a4:                         return java.sql.Types.INTEGER;
1:4f996a4:                     else if (objectName.equals("long[]")
1:4f996a4:                              || objectName.equals("java.lang.Long[]"))
1:4f996a4:                         return java.sql.Types.BIGINT;
1:4f996a4:                     else if (objectName.equals("java.math.BigDecimal[]"))
1:4f996a4:                         return java.sql.Types.NUMERIC;
1:4f996a4:                     else if (objectName.equals("boolean[]")  || 
1:4f996a4:                              objectName.equals("java.lang.Boolean[]"))
1:4f996a4:                         return java.sql.Types.BIT;
1:4f996a4:                     else if (objectName.equals("short[]"))
1:4f996a4:                         return java.sql.Types.SMALLINT;
1:4f996a4:                     else if (objectName.equals("float[]") ||
1:4f996a4:                              objectName.equals("java.lang.Float[]"))
1:4f996a4:                         return java.sql.Types.REAL;
1:4f996a4:                     else if (objectName.equals("double[]") ||
1:4f996a4:                              objectName.equals("java.lang.Double[]"))
1:4f996a4:                         return java.sql.Types.DOUBLE;
1:4f996a4:                     else if (objectName.equals("java.sql.Date[]"))
1:4f996a4:                         return java.sql.Types.DATE;
1:4f996a4:                     else if (objectName.equals("java.sql.Time[]"))
1:4f996a4:                         return java.sql.Types.TIME;
1:4f996a4:                     else if (objectName.equals("java.sql.Timestamp[]"))
1:4f996a4:                         return java.sql.Types.TIMESTAMP;
1:4f996a4:         }
1:4f996a4:         // Not one of the ones we know. This must be a JAVA_OBJECT
1:4f996a4:         return NOT_OUTPUT_PARAM;
1:db9a013:         //isOutParam[offset] = false;
1:4f996a4:         //return java.sql.Types.JAVA_OBJECT;
1:4f996a4: 
1:4f996a4:     }
1:4f996a4:     
1:eac0369:     
1:4f996a4:     public void registerAllOutParams() throws SQLException
1:4f996a4:     {
1:4f996a4:         if (isCall && (outputTypes != null))
1:4f996a4:             for (int i = 1; i <= outputTypes.length; i ++)
1:4f996a4:                 registerOutParam(i);
1:4f996a4:         
1:4f996a4:     }
1:4f996a4:     
1:4f996a4:     public void registerOutParam(int paramNum) throws SQLException
1:4f996a4:     {
1:4f996a4:         CallableStatement cs;
1:4f996a4:         if (isOutputParam(paramNum))
1:4f996a4:         {
1:4f996a4:             cs = (CallableStatement) ps;
1:4f996a4:             cs.registerOutParameter(paramNum, getOutputParamType(paramNum));
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     protected boolean hasOutputParams()
1:4f996a4:     {
1:4f996a4:         return (outputTypes != null);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * is  parameter an ouput parameter
1:4f996a4:      * @param paramNum parameter number starting with 1.
1:4f996a4:      * return true if this is an output parameter.
1:4f996a4:      */
1:4f996a4:     boolean isOutputParam(int paramNum)
1:4f996a4:     {
1:4f996a4:         if (outputTypes != null)
1:4f996a4:             return (outputTypes[paramNum - 1] != NOT_OUTPUT_PARAM);
1:4f996a4:         return false;
1:4f996a4:         
1:4f996a4:     }
1:4f996a4:     /** 
1:4f996a4:      * get type for output parameter. 
1:4f996a4:      *
1:4f996a4:      * @param paramNum - parameter number starting with 1
1:4f996a4:      * @return jdbcType or NOT_OUTPUT_PARAM if this is not an output parameter
1:4f996a4:      */
1:4f996a4:     int getOutputParamType(int paramNum)
1:4f996a4:     {
1:4f996a4:         if (outputTypes != null)
1:4f996a4:             return (outputTypes[ paramNum - 1 ]);
1:4f996a4:         return NOT_OUTPUT_PARAM;
1:4f996a4:     }
1:eac0369: 
1:4f996a4:         /** 
1:6eb5042:          * get scale for output parameter. 
1:4f996a4:          *
1:6eb5042:          * @param paramNum - parameter number starting with 1
1:6eb5042:          * @return scale or NOT_OUTPUT_PARAM if this is not an output parameter
1:4f996a4:          */
1:6eb5042:         int getOutputParamScale(int paramNum){
1:6eb5042:             if (outputScale != null)
1:6eb5042:                 return (outputScale[paramNum -1]);
1:6eb5042:             return NOT_OUTPUT_PARAM;
1:4f996a4:         }
1:6eb5042: 
1:4f996a4:         /** 
1:6eb5042:          * get precision  for output parameter. 
1:4f996a4:          *
1:6eb5042:          * @param paramNum - parameter number starting with 1
1:6eb5042:          * @return precision or NOT_OUTPUT_PARAM if this is not an output parameter
1:4f996a4:          */
1:6eb5042:         int getOutputParamPrecision(int paramNum){
1:6eb5042:             if (outputPrecision != null)
1:6eb5042:                 return (outputPrecision[paramNum -1]);
1:6eb5042:             return NOT_OUTPUT_PARAM;
1:4f996a4:         }
1:6eb5042:         
1:4f996a4:     private boolean isDynamicPkgid(String pkgid)
1:4f996a4:     {
1:4f996a4:         char size = pkgid.charAt(3);
1:4f996a4:         
1:4f996a4:         //  separate attribute used for holdability in 5.1.60
1:4f996a4:         // this is just for checking that it is a dynamic package
1:4f996a4:         char holdability = pkgid.charAt(4);                                                 
1:4f996a4:         return (pkgid.substring(0,3).equals("SYS") && (size == 'S' ||
1:4f996a4:                                                        size == 'L')
1:4f996a4:                 && (holdability == 'H' || holdability == 'N'));
1:4f996a4:         
1:4f996a4:     }
1:eac0369: 
1:eac0369:    
1:4f996a4:     private  void parsePkgidToFindHoldability()
2:4f996a4:     {
1:4f996a4:         if (withHoldCursor != -1)
1:4f996a4:             return;
1:fdfc981:         
1:4f996a4:         //First, check if holdability was passed as a SQL attribute "WITH HOLD" for this prepare. If yes, then withHoldCursor
1:4f996a4:         //should not get overwritten by holdability from package name and that is why the check for -1
1:3c9599f:         String pkgid = pkgnamcsn.getPkgid();
1:4f996a4:         if (isDynamicPkgid(pkgid))
1:4f996a4:         {       
1:4f996a4:             if(pkgid.charAt(4) == 'N')
1:4f996a4:                 withHoldCursor = ResultSet.CLOSE_CURSORS_AT_COMMIT;
1:4f996a4:             else  
1:4f996a4:                 withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:4f996a4:         }
2:4f996a4:         else 
1:4f996a4:         {            
1:4f996a4:             withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:4f996a4:         
1:4f996a4:         }
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     /** 
1:4f996a4:      * Retrieve the ParameterMetaData for the prepared statement. 
1:3634d6e:      * @return ParameterMetaData for the prepared statement. 
1:4f996a4:      * Note: there is no separate BrokeredParameterSetMetaData.
1:4f996a4:      */
1:3634d6e:     protected ParameterMetaData getParameterMetaData() throws SQLException
1:4f996a4:     {
1:4f996a4:         if (stmtPmeta != null)
1:4f996a4:             return stmtPmeta;
1:4383496: 
1:3634d6e:         stmtPmeta = ps.getParameterMetaData();
1:4f996a4:         
2:4383496:         return stmtPmeta;
1:4f996a4:     }
1:eac0369:     
1:4f996a4:     /**
1:4f996a4:      * get more results using reflection.
1:4f996a4:      * @param current - flag to pass to Statement.getMoreResults(current)
1:4f996a4:      * @return true if there are more results.
1:4f996a4:      * @throws SQLException
1:4f996a4:      * @see java.sql.Statement#getMoreResults
1:4f996a4:      *
1:4f996a4:      */
1:4f996a4:     private boolean getMoreResults(int current) throws SQLException
1:4f996a4:     {       
1:3634d6e:         return getPreparedStatement().getMoreResults(current);
1:4f996a4:     }
1:4383496: 
1:4f996a4:     /**
1:4f996a4:      * Use reflection to retrieve SQL Text for EmbedPreparedStatement  
1:4f996a4:      * or BrokeredPreparedStatement.
1:4f996a4:      * @return SQL text
1:4f996a4:      */
1:4f996a4:     private String getSQLText() 
1:4f996a4:     {
1:4f996a4:        String retVal = null;
1:4f996a4:         Class[] emptyPARAM = {};
1:4f996a4:         Object[] args = null;
1:4f996a4:         try {
1:4f996a4:             Method sh = getPreparedStatement().getClass().getMethod("getSQLText",emptyPARAM);
1:4f996a4:             retVal = (String) sh.invoke(getPreparedStatement(),args);
1:4f996a4:         }
1:4f996a4:         catch (Exception e)
1:4f996a4:         {
1:4f996a4:             //  do nothing we will just return a null string
1:4f996a4:         }
1:4f996a4:         return retVal;
1:4f996a4: 
1:4f996a4:     }
1:4383496:     
1:4f996a4:     /**
1:4f996a4:      * Method to decide whether the ResultSet should be closed
1:4f996a4:      * implicitly based on the QRYCLSIMP value sent from the
1:4f996a4:      * client. Only forward-only result sets should be implicitly
1:4f996a4:      * closed. Some clients do not expect result sets to be closed
1:4f996a4:      * implicitly if the protocol is LMTBLKPRC.
1:4f996a4:      *
1:4f996a4:      * @param lmtblkprcOK <code>true</code> if the client expects
1:4f996a4:      * QRYCLSIMP to be respected for the LMTBLKPRC protocol
1:4f996a4:      * @return implicit close boolean
1:4f996a4:      * @exception SQLException
1:4f996a4:      */
1:4f996a4:     boolean isRSCloseImplicit(boolean lmtblkprcOK) throws SQLException {
1:4f996a4:         return
1:4f996a4:             (currentDrdaRs.qryclsimp == CodePoint.QRYCLSIMP_YES) &&
1:4f996a4:             !isScrollable() &&
1:4f996a4:             (lmtblkprcOK ||
1:4f996a4:              (currentDrdaRs.getQryprctyp() != CodePoint.LMTBLKPRC));
1:4f996a4:     }
1:4f996a4: }
1:4383496: 
1:4383496: 
1:4383496: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4bdaec2
/////////////////////////////////////////////////////////////////////////
1:         if (!tokenizer.hasMoreTokens()) {
1:             return false;
1:         }
commit:d6209a8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineResultSet;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					addResultSet(rs, ((EngineResultSet) rs).getHoldability());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     addResultSet(rs, rs.getHoldability());
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 case (ParameterMetaData.parameterModeIn):
1:                 case (ParameterMetaData.parameterModeOut):
1:                 case (ParameterMetaData.parameterModeInOut):
1:                 case (ParameterMetaData.parameterModeUnknown):
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1:      * get resultset /out parameter precision
/////////////////////////////////////////////////////////////////////////
1:      * get resultset /out parameter scale
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:     protected String typDefNam;     //TYPDEFNAM for this statement
1:     protected int ccsidSBC;         //CCSID for single byte characters
1:     protected int ccsidDBC;         //CCSID for double byte characters
1:     protected int ccsidMBC;         //CCSID for mixed byte characters
1:     protected String ccsidSBCEncoding;  //Java encoding for CCSIDSBC
1:     protected String ccsidDBCEncoding;  //Java encoding for CCSIDDBC
1:     protected String ccsidMBCEncoding;  //Java encoding for CCSIDMBC
1:     private   Pkgnamcsn pkgnamcsn;      // Package name/section # and  consistency token
1:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;         // Sensitive or Insensitive scroll attribute
1:     protected int concurType = ResultSet.CONCUR_READ_ONLY;;         // Concurency type
1:     protected String procName;          // callable statement's method name
1:     protected boolean outputExpected;   // expect output from a callable statement
0:     private Statement stmt;             // SQL statement
/////////////////////////////////////////////////////////////////////////
1:     protected int nbrrow;           // number of fetch or insert rows
1:     protected int blksize;              // Query block size
/////////////////////////////////////////////////////////////////////////
1:      * @param conn  Connection
/////////////////////////////////////////////////////////////////////////
1:         drs.qryrowset = qryrowset;
1:         drs.blksize = blksize;
1:         drs.maxblkext = maxblkext;
1:         drs.outovropt = outovropt;
1:         drs.rslsetflg = rslsetflg;
/////////////////////////////////////////////////////////////////////////
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     protected void  setOutovr_drdaType(int[] outovr_drdaType)
/////////////////////////////////////////////////////////////////////////
1:              *      1 - section number sent by jcc
/////////////////////////////////////////////////////////////////////////
1:      * Set currentDrdaResultSet
/////////////////////////////////////////////////////////////////////////
1:      * Set currentDrdaResultSet
/////////////////////////////////////////////////////////////////////////
1:      * @return  number of result sets
/////////////////////////////////////////////////////////////////////////
1:      * @return  consistency token (key) for the result set
1:             return (ConsistencyToken) resultSetKeyList.get(rsNum);
/////////////////////////////////////////////////////////////////////////
1:         needsToSendParamData = false;
/////////////////////////////////////////////////////////////////////////
1:         scrollType = ResultSet.TYPE_FORWARD_ONLY;
/////////////////////////////////////////////////////////////////////////
1:         qryrowset = 0;
1:         maxblkext = 0;
1:         outovropt = 0;
/////////////////////////////////////////////////////////////////////////
1:     protected int getParamDRDAType(int index) {
1:     }
/////////////////////////////////////////////////////////////////////////
1:         return drdaRs.getResultSetCursorName();
1:     {
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:             //  object Integer[] or use a procedure
/////////////////////////////////////////////////////////////////////////
1:         //isOutParam[offset] = false;
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Array;
1: import java.sql.DataTruncation;
/////////////////////////////////////////////////////////////////////////
commit:27fbf33
/////////////////////////////////////////////////////////////////////////
1:     /** Hashtable with resultsets. */
1:     private Hashtable<ConsistencyToken, DRDAResultSet> resultSetTable;
1:     /** Ordered list of hash keys. */
1:     private ArrayList<ConsistencyToken> resultSetKeyList;
/////////////////////////////////////////////////////////////////////////
1: 	protected ArrayList<Object> getExtDtaObjects()
/////////////////////////////////////////////////////////////////////////
1: 				resultSetTable =
1:                         new Hashtable<ConsistencyToken, DRDAResultSet>();
1: 				resultSetKeyList = new ArrayList<ConsistencyToken>();
commit:bc23e21
/////////////////////////////////////////////////////////////////////////
1:      * Saved value returned from {@link DRDAConnThread#parsePRPSQLSTT}.
1:      * Used to determine if the statement is such that we may
commit:b850119
/////////////////////////////////////////////////////////////////////////
0: import java.sql.DataTruncation;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * A chain of warnings indicating whether some of the data values returned
1:      * by this statement had to be truncated before being sent to the client.
1:      */
1:     private DataTruncation truncationWarnings;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add a warning about data having been truncated.
1:      * @param w the warning to add
1:      */
1:     protected void addTruncationWarning(DataTruncation w) {
1:         if (truncationWarnings == null) {
1:             truncationWarnings = w;
1:         } else {
1:             truncationWarnings.setNextWarning(w);
1:         }
1:     }
1: 
1:     /**
1:      * Get the chain of truncation warnings added to this statement.
1:      * @return chain of truncation warnings, possibly {@code null}
1:      */
1:     protected DataTruncation getTruncationWarnings() {
1:         return truncationWarnings;
1:     }
1: 
1:     /**
1:      * Clear the chain of truncation warnings for this statement.
1:      */
1:     protected void clearTruncationWarnings() {
1:         truncationWarnings = null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         truncationWarnings = null;
/////////////////////////////////////////////////////////////////////////
1:         truncationWarnings = null;
commit:41e4ad8
/////////////////////////////////////////////////////////////////////////
1: 			throw Util.javaException(e);
commit:ce68ae0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		parsePkgidToFindHoldability();
1: 
0: 			ps = database.getConnection().prepareCall(
1: 				sqlStmt, scrollType, concurType, withHoldCursor);
1: 		else
1: 		{
0: 			ps = database.getConnection().prepareStatement(
1: 				sqlStmt, scrollType, concurType, withHoldCursor);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
commit:3634d6e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	protected ParameterMetaData stmtPmeta; // param metadata
/////////////////////////////////////////////////////////////////////////
0: 		return getResultSetHoldability(getResultSet());
/////////////////////////////////////////////////////////////////////////
0:         return rsstmt.getResultSetHoldability();
/////////////////////////////////////////////////////////////////////////
1: 			ParameterMetaData pmeta = getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
1: 			ParameterMetaData pmeta = getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
1: 		ParameterMetaData pmeta = getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
1: 	 * @return ParameterMetaData for the prepared statement. 
1: 	protected ParameterMetaData getParameterMetaData() throws SQLException
1: 		stmtPmeta = ps.getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
1:         return getPreparedStatement().getMoreResults(current);
commit:c050ed4
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Array;
/////////////////////////////////////////////////////////////////////////
1: 	/** This class is used to keep track of the statement's parameters
1: 	 * as they are received from the client. It uses arrays to track
1: 	 * the DRDA type, the length in bytes and the externalness of each
1: 	 * parameter. Arrays of int/byte are used rather than ArrayLists
1: 	 * of Integer/Byte in order to re-use the same storage each time
1: 	 * the statement is executed. */
1: 	private static class DrdaParamState {
1: 		private int typeLstEnd_ = 0;
1: 		private byte[] typeLst_ = new byte[10];
1: 		private int[]  lenLst_ = new int[10];
1: 		private int extLstEnd_ = 0;
1: 		private int[]  extLst_ = new int[10];
1: 
1: 		private static Object growArray(Object array) {
1: 			final int oldLen = Array.getLength(array);
1: 			Object tmp =
1: 				Array.newInstance(array.getClass().getComponentType(),
1: 								  Math.max(oldLen,1)*2);
1: 			System.arraycopy(array, 0, tmp, 0, oldLen);
1: 			return tmp;
1: 		}
1: 
1: 		/**
1: 		 * <code>clear</code> resets the arrays so that new parameters
1: 		 * will be added at the beginning. No initialization or
1: 		 * releasing of storage takes place unless the trim argument
1: 		 * is true.
1: 		 *
1: 		 * @param trim - if true; release excess storage
1: 		 */
1: 		protected void clear(boolean trim) {
1: 			typeLstEnd_ = 0;
1: 			extLstEnd_ = 0;
1: 			if (trim && typeLst_.length > 10) {
1: 				typeLst_ = new byte[10];
1: 				lenLst_ = new int[10];
1: 				extLst_ = new int[10];
1: 			}
1: 		}
1: 
1: 		/**
1: 		 * <code>addDrdaParam</code> adds a new parameter with its
1: 		 * DRDA type and byte length. The arrays are automatically
1: 		 * grown if needed.
1: 		 *
1: 		 * @param t a <code>byte</code> value, the DRDA type of the
1: 		 * parameter being added
1: 		 * @param s an <code>int</code> value, the length in bytes of
1: 		 * the parameter being added
1: 		 */
1: 		protected void addDrdaParam(byte t, int s) {
1: 			if (typeLstEnd_ >= typeLst_.length) {
1: 				typeLst_ = (byte[])growArray(typeLst_);
1: 				lenLst_ = (int[])growArray(lenLst_);
1: 			}
1: 			typeLst_[typeLstEnd_] = t;
1: 			lenLst_[typeLstEnd_] = s;
1: 			++typeLstEnd_;
1: 		}
1: 
1: 		/**
1: 		 * <code>getDrdaParamCount</code> return the number of
1: 		 * parameters added so far (since last clear).
1: 		 *
1: 		 * @return an <code>int</code> value, the number of parameters
1: 		 */
1: 		protected int  getDrdaParamCount() { return typeLstEnd_; }
1: 
1: 		/**
1: 		 * <code>getDrdaType</code> returns a byte that represents the
1: 		 * DRDA type of the ith parameter.
1: 		 *
1: 		 * @param i an <code>int</code> value, a parameter position
1: 		 * (zero-based)
1: 		 * @return a <code>byte</code> value, the DRDA type
1: 		 */
1: 		protected byte getDrdaType(int i) { return typeLst_[i]; }
1: 
1: 		/**
1: 		 * <code>getDrdaLen</code> returns the length in bytes of the
1: 		 * ith parameter.
1: 		 *
1: 		 * @param i an <code>int</code> value, a parameter position
1: 		 * (zero-based)
1: 		 * @return an <code>int</code> value
1: 		 */
1: 		protected int getDrdaLen(int i) { return lenLst_[i]; }
1: 
1: 		/**
1: 		 * <code>addExtPos</code> marks parameter i as external. The
1: 		 * array is grown as needed.
1: 		 *
1: 		 * @param p an <code>int</code> value, a parameter position
1: 		 * (zero-based)
1: 		 */
1: 		protected void addExtPos(int p) {
1: 			if (extLstEnd_ >= extLst_.length) {
1: 				extLst_ = (int[])growArray(extLst_);
1: 			}
1: 			extLst_[extLstEnd_] = p;
1: 			++extLstEnd_;
1: 		}
1: 
1: 		/**
1: 		 * <code>getExtPosCount</code> returns the number of
1: 		 * parameters marked as external so far (since last clear).
1: 		 *
1: 		 * @return an <code>int</code> value, the number of external
1: 		 * parameters.
1: 		 */
1: 		protected int getExtPosCount() { return extLstEnd_; }
1: 
1: 		/**
1: 		 * <code>getExtPos</code> returns the actual parameter position
1: 		 * of the ith external parameter.
1: 		 *
1: 		 * @param i an <code>int</code> value, index into the list of
1: 		 * external parameters, zero-based
1: 		 * @return an <code>int</code> value, the parameter position
1: 		 * of the ith external parameter (zero-based)
1: 		 */
1: 		protected int getExtPos(int i) { return extLst_[i]; }
1: 	}
1: 	private DrdaParamState drdaParamState_ = new DrdaParamState();
/////////////////////////////////////////////////////////////////////////
1: 		// Clear parameters and release excess storage
1: 		drdaParamState_.clear(true);
/////////////////////////////////////////////////////////////////////////
1: 		// Clear parameters without releasing storage
1: 		drdaParamState_.clear(false);
/////////////////////////////////////////////////////////////////////////
1: 	/** Clears the parameter state (type, length and ext information)
1: 	 * stored in this statement, but does not release any
1: 	 * storage. This reduces the cost of re-executing the statement
1: 	 * since no new storage needs to be allocated. */
1: 	protected void clearDrdaParams() {
1: 		drdaParamState_.clear(false);
1: 	}
1: 
1: 	/** Get the number of external parameters in this
1: 	 * statement. External means parameters that are transmitted in a
1: 	 * separate DSS in the DRDA protocol.
1: 	 * @return the number of external parameters
1: 	 */
1: 	protected int getExtPositionCount() {
1: 		return drdaParamState_.getExtPosCount();
1: 	}
1: 
1: 	/** Get the parameter position of the i'th external parameter
1: 	 * @param i - zero-based index into list of external parameters
1: 	 * @return the parameter position of the i'th external parameter
1: 	 */
1: 	protected int getExtPosition(int i) {
1: 		return drdaParamState_.getExtPos(i);
1: 	}
1: 
1: 	/** Mark the pos'th parameter as external
1: 	 * @param pos - zero-based index into list of external parameters
1: 	 */
1: 	protected void addExtPosition(int pos) {
1: 		drdaParamState_.addExtPos(pos);
1: 	}
1: 
1: 	/** Get the number of parameters, internal and external, that has
1: 	 * been added to this statement.
1: 	 * @return the number of parameters
1: 	 */
1: 	protected int getDrdaParamCount() {
1: 		return drdaParamState_.getDrdaParamCount();
1: 	}
1: 
1: 	/** Add another parameter to this statement.
1: 	 * @param t - type of the parameter
1: 	 * @param l - length in bytes of the parameter
1: 	 */
1: 	protected void addDrdaParam(byte t, int l) {
1: 		drdaParamState_.addDrdaParam(t, l);
1: 	}
1: 
0:  	protected int getParamDRDAType(int index) {
1: 		return drdaParamState_.getDrdaType(index-1);
1:  	}
1: 	 * @param index - starting with 1
1: 		return drdaParamState_.getDrdaLen(index-1);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
commit:a10e456
/////////////////////////////////////////////////////////////////////////
1: 	 * Set query options sent on OPNQRY and pass options down to the
1: 	 * current <code>DRDAResultSet</code> object.
1: 	 *
1: 	 * @param blksize QRYBLKSZ (Query Block Size)
1: 	 * @param qryblkctl QRYPRCTYP (Query Protocol Type)
1: 	 * @param maxblkext MAXBLKEXT (Maximum Number of Extra Blocks)
1: 	 * @param outovropt OUTOVROPT (Output Override Option)
1: 	 * @param qryrowset QRYROWSET (Query Rowset Size)
1: 	 * @param qryclsimpl QRYCLSIMP (Query Close Implicit)
1: 		this.blksize = blksize;
1: 		this.qryprctyp = qryblkctl;
1: 		this.maxblkext = maxblkext;
1: 		this.outovropt = outovropt;
1: 		this.qryrowset = qryrowset;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.transaction.TransactionControl;
/////////////////////////////////////////////////////////////////////////
1:             return TransactionControl.READ_UNCOMMITTED_ISOLATION_LEVEL;
1:             return TransactionControl.UNSPECIFIED_ISOLATION_LEVEL;
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineStatement;
/////////////////////////////////////////////////////////////////////////
1:     protected EnginePreparedStatement ps;     // Prepared statement
/////////////////////////////////////////////////////////////////////////
1:     private EngineStatement stmt;             // SQL statement
/////////////////////////////////////////////////////////////////////////
1:         stmt = (EngineStatement) conn.createStatement();
/////////////////////////////////////////////////////////////////////////
1:     protected EngineStatement getStatement() 
/////////////////////////////////////////////////////////////////////////
1:             ps = (EnginePreparedStatement) database.getConnection().prepareCall(
1:             ps = (EnginePreparedStatement) database.getConnection().prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:     protected EnginePreparedStatement getPreparedStatement() throws SQLException
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:3c9599f
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:      * get initialized differently. e.g: stmt variable used in default statement
1:      * The default statement will be initialized to have the same byte order 
1:      * etc as the server. This may be changed when a TYPEDEFNAM is received 
1:      * from the client in DRDAConnThread.setStmtOrDbByteOrder()
/////////////////////////////////////////////////////////////////////////
1:         String pkgid = pkgnamcsn.getPkgid();
/////////////////////////////////////////////////////////////////////////
1:             int pkgsn = pkgnamcsn.getPkgsn();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         this.pkgnamcsn = pkgnamcsn;
/////////////////////////////////////////////////////////////////////////
1:                 ConsistencyToken pkgcnstkn = pkgnamcsn.getPkgcnstkn();
/////////////////////////////////////////////////////////////////////////
1:             return pkgnamcsn.getPkgcnstkn();
/////////////////////////////////////////////////////////////////////////
1:             s += indent + pkgnamcsn.getPkgid() + pkgnamcsn.getPkgsn() ;
/////////////////////////////////////////////////////////////////////////
1:         ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
1:         if (rsNum == 0 || consistToken == null)
/////////////////////////////////////////////////////////////////////////
1:         String pkgid = pkgnamcsn.getPkgid();
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     DRDAStatement stores information about the statement being executed
1:     //NOTE!
1:     //
1:     // Since DRDAStatements are reused, ALL variables (except those noted in 
1:     // the comments for reset method) should be set to their default values 
1:     // in reset().
1:     
0:     protected String typDefNam;        //TYPDEFNAM for this statement
1:     protected int byteOrder;        //deduced from typDefNam, save String comparisons
0:     protected int ccsidSBC;            //CCSID for single byte characters
0:     protected int ccsidDBC;            //CCSID for double byte characters
0:     protected int ccsidMBC;            //CCSID for mixed byte characters
0:     protected String ccsidSBCEncoding;    //Java encoding for CCSIDSBC
0:     protected String ccsidDBCEncoding;    //Java encoding for CCSIDDBC
0:     protected String ccsidMBCEncoding;    //Java encoding for CCSIDMBC
1:     protected Database database;        // Database this statement is created for
0:     private   Pkgnamcsn pkgnamcsn;        // Package name/section # and  consistency token
0:     protected ConsistencyToken pkgcnstkn;       // Consistency token for the first result set
0:      protected String pkgid;              // package id
0:      protected int pkgsn;        // section number
1:     int withHoldCursor = -1;     // hold cursor after commit attribute.
1:     protected int isolationLevel;         //JCC isolation level for Statement
1:     protected String cursorName;
0:     protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;            // Sensitive or Insensitive scroll attribute
0:     protected int concurType = ResultSet.CONCUR_READ_ONLY;;            // Concurency type
1:     protected long rowCount;            // Number of rows we have processed
1:     protected byte [] rslsetflg;        // Result Set Flags
1:     protected int maxrslcnt;            // Maximum Result set count
0:     protected PreparedStatement ps;     // Prepared statement
0:     protected ParameterMetaData stmtPmeta; // param metadata
1:     protected boolean isCall;
0:     protected String procName;            // callable statement's method name
1:     private   int[] outputTypes;        // jdbc type for output parameter or NOT_OUTPUT_PARAM
1:                                         // if not an output parameter.
1:     private int[] outputPrecision;
1:     private int[] outputScale;
1:     protected static int NOT_OUTPUT_PARAM = -100000;
0:     protected boolean outputExpected;    // expect output from a callable statement
0:     private Statement stmt;                // SQL statement
1:     private DRDAResultSet currentDrdaRs;  // Current ResultSet
1:     private int numResultSets = 0;  
/////////////////////////////////////////////////////////////////////////
0:     /** This class is used to keep track of the statement's parameters
0:      * as they are received from the client. It uses arrays to track
0:      * the DRDA type, the length in bytes and the externalness of each
0:      * parameter. Arrays of int/byte are used rather than ArrayLists
0:      * of Integer/Byte in order to re-use the same storage each time
0:      * the statement is executed. */
0:     private static class DrdaParamState {
1:         // The last parameter may be streamed. 
1:         // We need to keep a record of it so we can drain it if it is not 
1:         // used.
1:         // Only the last parameter with an EXTDTA will be streamed. 
1:         //(See DRDAConnThread.readAndSetAllExtParams()). 
1:         private EXTDTAReaderInputStream streamedParameter = null;
0:         private int typeLstEnd_ = 0;
0:         private byte[] typeLst_ = new byte[10];
0:         private int[]  lenLst_ = new int[10];
0:         private int extLstEnd_ = 0;
0:         private int[]  extLst_ = new int[10];
0:         private static Object growArray(Object array) {
0:             final int oldLen = Array.getLength(array);
0:             Object tmp =
0:                 Array.newInstance(array.getClass().getComponentType(),
0:                                   Math.max(oldLen,1)*2);
0:             System.arraycopy(array, 0, tmp, 0, oldLen);
0:             return tmp;
1:         }
1:         /**
0:          * <code>clear</code> resets the arrays so that new parameters
0:          * will be added at the beginning. No initialization or
0:          * releasing of storage takes place unless the trim argument
0:          * is true.
1:          *
0:          * @param trim - if true; release excess storage
1:          */
0:         protected void clear(boolean trim) {
1:             streamedParameter = null;
0:             typeLstEnd_ = 0;
0:             extLstEnd_ = 0;
0:             if (trim && typeLst_.length > 10) {
0:                 typeLst_ = new byte[10];
0:                 lenLst_ = new int[10];
0:                 extLst_ = new int[10];
1:             }
1:         }
1:         /**
0:          * <code>addDrdaParam</code> adds a new parameter with its
0:          * DRDA type and byte length. The arrays are automatically
0:          * grown if needed.
1:          *
0:          * @param t a <code>byte</code> value, the DRDA type of the
0:          * parameter being added
0:          * @param s an <code>int</code> value, the length in bytes of
0:          * the parameter being added
1:          */
0:         protected void addDrdaParam(byte t, int s) {
0:             if (typeLstEnd_ >= typeLst_.length) {
0:                 typeLst_ = (byte[])growArray(typeLst_);
0:                 lenLst_ = (int[])growArray(lenLst_);
1:             }
0:             typeLst_[typeLstEnd_] = t;
0:             lenLst_[typeLstEnd_] = s;
0:             ++typeLstEnd_;
1:         }
1:         /**
0:          * <code>getDrdaParamCount</code> return the number of
0:          * parameters added so far (since last clear).
1:          *
0:          * @return an <code>int</code> value, the number of parameters
1:          */
0:         protected int  getDrdaParamCount() { return typeLstEnd_; }
1:         /**
0:          * <code>getDrdaType</code> returns a byte that represents the
0:          * DRDA type of the ith parameter.
1:          *
0:          * @param i an <code>int</code> value, a parameter position
0:          * (zero-based)
0:          * @return a <code>byte</code> value, the DRDA type
1:          */
0:         protected byte getDrdaType(int i) { return typeLst_[i]; }
1:         /**
0:          * <code>getDrdaLen</code> returns the length in bytes of the
0:          * ith parameter.
1:          *
0:          * @param i an <code>int</code> value, a parameter position
0:          * (zero-based)
0:          * @return an <code>int</code> value
1:          */
0:         protected int getDrdaLen(int i) { return lenLst_[i]; }
1:         /**
0:          * <code>addExtPos</code> marks parameter i as external. The
0:          * array is grown as needed.
1:          *
0:          * @param p an <code>int</code> value, a parameter position
0:          * (zero-based)
1:          */
0:         protected void addExtPos(int p) {
0:             if (extLstEnd_ >= extLst_.length) {
0:                 extLst_ = (int[])growArray(extLst_);
1:             }
0:             extLst_[extLstEnd_] = p;
0:             ++extLstEnd_;
1:         }
1:         /**
0:          * <code>getExtPosCount</code> returns the number of
0:          * parameters marked as external so far (since last clear).
1:          *
0:          * @return an <code>int</code> value, the number of external
0:          * parameters.
1:          */
0:         protected int getExtPosCount() { return extLstEnd_; }
1:         /**
0:          * <code>getExtPos</code> returns the actual parameter position
0:          * of the ith external parameter.
1:          *
0:          * @param i an <code>int</code> value, index into the list of
0:          * external parameters, zero-based
0:          * @return an <code>int</code> value, the parameter position
0:          * of the ith external parameter (zero-based)
1:          */
0:         protected int getExtPos(int i) { return extLst_[i]; }
1:         /**
1:          * Read the rest of the streamed parameter if not consumed
1:          * by the executing statement.  DERBY-3085
1:          * @throws IOException
1:          */
1:         protected void drainStreamedParameter() throws IOException
1:         {
1:             if (streamedParameter != null)
1:             {   
1:                 // we drain the buffer 1000 bytes at a time.
1:                 // 1000 is just a random selection that doesn't take
1:                 // too much memory. Perhaps something else would be 
1:                 // more efficient?
1:                 byte[] buffer = new byte[1000];
1:                 int i;
1:                 do {
1:                     i= streamedParameter.read(buffer,0,1000);
1:                 }  while (i != -1);
1:             }
1:         }
1:         public void setStreamedParameter(EXTDTAReaderInputStream eis) {
1:             streamedParameter = eis;    
1:         }
1:         
1:     }
0:     private DrdaParamState drdaParamState_ = new DrdaParamState();
1:     // Query options  sent on EXCSQLSTT
1:     // These the default for ResultSets created for this statement.
1:     // These can be overriden by OPNQRY or CNTQRY,
0:     protected int nbrrow;            // number of fetch or insert rows
1:     protected int qryrowset;            // Query row set
0:     protected int blksize;                // Query block size
1:     protected int maxblkext;            // Maximum number of extra blocks
1:     protected int outovropt;            // Output Override option
1:     protected boolean qryrfrtbl;        // Query refresh answer set table
1:     private int qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;   // Protocol type
1:     
1:     
1:     boolean needsToSendParamData = false;
1:     boolean explicitlyPrepared = false;    //Prepared with PRPSQLSTT (reusable) 
/////////////////////////////////////////////////////////////////////////
1:     // constructor
1:     /**
1:      * DRDAStatement constructor
1:      *
1:      * @param database
1:      * 
1:      */
1:     DRDAStatement (Database database) 
1:     {
1:         this.database = database;
1:         setTypDefValues();
1:         this.currentDrdaRs = new DRDAResultSet();
1:     }
1:     /**
1:      * set TypDef values
1:      *
1:      */
1:     protected void setTypDefValues()
1:     {
1:         // initialize statement values to current database values
1:         this.typDefNam = database.typDefNam;
1:         this.byteOrder = database.byteOrder;
1:         this.ccsidSBC = database.ccsidSBC;
1:         this.ccsidDBC = database.ccsidDBC;
1:         this.ccsidMBC = database.ccsidMBC;
1:         this.ccsidSBCEncoding = database.ccsidSBCEncoding;
1:         this.ccsidDBCEncoding = database.ccsidDBCEncoding;
1:         this.ccsidMBCEncoding = database.ccsidMBCEncoding;
1:     }
1:     /**
1:      * Set database
1:      *
1:      * @param database
1:      */
1:     protected void setDatabase(Database database)
1:     {
1:         this.database = database;
1:         setTypDefValues();
1:     }
1:     /**
1:      * Set statement
1:      *
0:      * @param conn    Connection
1:      * @exception SQLException
1:      */
1:     protected void setStatement(Connection conn)
1:         throws SQLException
1:     {
0:         stmt = conn.createStatement();
1:         //beetle 3849 -  see  prepareStatement for details
1:         if (cursorName != null)
1:             stmt.setCursorName(cursorName);
1:     }
1:     /**
1:      * Get the statement
1:      *
1:      * @return statement
1:      * @exception SQLException
1:      */
0:     protected Statement getStatement() 
1:         throws SQLException
1:     {
1:         return stmt;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**Set resultSet defaults to match 
1:      * the statement defaults sent on EXCSQLSTT
1:      * This might be overridden on OPNQRY or CNTQRY
1:      **/
1:     protected void setRsDefaultOptions(DRDAResultSet drs)
1:     {
1:         drs.nbrrow = nbrrow;
1:          drs.qryrowset = qryrowset;
0:          drs.blksize = blksize;
0:          drs.maxblkext = maxblkext;
0:          drs.outovropt = outovropt;
0:          drs.rslsetflg = rslsetflg;
1:         drs.scrollType = scrollType;
1:         drs.concurType = concurType;
1:         drs.setQryprctyp(qryprctyp);
1:         drs.qryrowset = qryrowset;
1:     }
1:     /**
1:      * Get the extData Objects
1:      *
1:      *  @return ArrayList with extdta
1:      */
0:     protected ArrayList<Object> getExtDtaObjects()
1:     {
1:         return currentDrdaRs.getExtDtaObjects();
1:     }
1:     public void setSplitQRYDTA(byte []data)
1:     {
1:         currentDrdaRs.setSplitQRYDTA(data);
1:     }
1:     public byte[]getSplitQRYDTA()
1:     {
1:         return currentDrdaRs.getSplitQRYDTA();
1:     }
1:     
1:        /**
1:      * Add extDtaObject
1:      * @param o - object to  add
1:      * @param jdbcIndex - jdbc index for parameter
1:      */
1:     protected void  addExtDtaObject (Object o, int jdbcIndex )
1:     {
1:         currentDrdaRs.addExtDtaObject(o,jdbcIndex);
1:     }
1:     
1:     /**
1:      * Clear externalized lob objects in current result set
1:      */
1:     protected void  clearExtDtaObjects ()
1:     {
1:         currentDrdaRs.clearExtDtaObjects();
1:     }
1:     /*
1:      * Is lob object nullable
1:      * @param index - offset starting with 0
1:      * @return true if object is nullable
1:      */
1:     protected boolean isExtDtaValueNullable(int index)
1:     {
1:         return currentDrdaRs.isExtDtaValueNullable(index);
1:     }
1:     
1:     /**
0:      * Set query options sent on OPNQRY and pass options down to the
0:      * current <code>DRDAResultSet</code> object.
1:      *
0:      * @param blksize QRYBLKSZ (Query Block Size)
0:      * @param qryblkctl QRYPRCTYP (Query Protocol Type)
0:      * @param maxblkext MAXBLKEXT (Maximum Number of Extra Blocks)
0:      * @param outovropt OUTOVROPT (Output Override Option)
0:      * @param qryrowset QRYROWSET (Query Rowset Size)
0:      * @param qryclsimpl QRYCLSIMP (Query Close Implicit)
1:      * @see DRDAResultSet#setOPNQRYOptions(int, int, int, int, int, int)
1:      */
1:     protected void setOPNQRYOptions(int blksize, int qryblkctl,
1:                                   int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
1:     {
0:         this.blksize = blksize;
0:         this.qryprctyp = qryblkctl;
0:         this.maxblkext = maxblkext;
0:         this.outovropt = outovropt;
0:         this.qryrowset = qryrowset;
1:         currentDrdaRs.setOPNQRYOptions( blksize, qryblkctl, maxblkext, 
1:                 outovropt, qryrowset, qryclsimpl);
1:     }
1:     /*
1:      * Set query options sent on CNTQRY
1:      */
1:     protected void setQueryOptions(int blksize, boolean qryrelscr, 
1:                                     long qryrownbr,
1:                                     boolean qryfrtbl,int nbrrow,int maxblkext,
1:                                     int qryscrorn, boolean qryrowsns,
1:                                     boolean qryblkrst,
1:                                     boolean qryrtndta,int qryrowset,
1:                                     int rtnextdta)
1:     {
1:         currentDrdaRs.blksize = blksize;
1:         currentDrdaRs.qryrelscr = qryrelscr;
1:         currentDrdaRs.qryrownbr = qryrownbr;
1:         currentDrdaRs.qryrfrtbl = qryrfrtbl;
1:         currentDrdaRs.nbrrow = nbrrow;
1:         currentDrdaRs.maxblkext = maxblkext;
1:         currentDrdaRs.qryscrorn = qryscrorn;
1:         currentDrdaRs.qryrowsns = qryrowsns;
1:         currentDrdaRs.qryblkrst = qryblkrst;
1:         currentDrdaRs.qryrtndta = qryrtndta;
1:         currentDrdaRs.qryrowset = qryrowset;
1:         currentDrdaRs.rtnextdta = rtnextdta;
1:     }
1:     protected void setQryprctyp(int qryprctyp)
1:     {
1:         this.qryprctyp = qryprctyp;
1:         currentDrdaRs.setQryprctyp(qryprctyp);
1:     }
1:     protected int  getQryprctyp()
1:         throws SQLException
1:     {
1:         return currentDrdaRs.getQryprctyp();
1:     }
1:     protected void setQryrownbr(long qryrownbr)
1:     {
1:         currentDrdaRs.qryrownbr = qryrownbr;
1:     }
1:     protected long  getQryrownbr()
1:     {
1:         return currentDrdaRs.qryrownbr;
1:     }
1:     protected int  getQryrowset()
1:     {
1:         return currentDrdaRs.qryrowset;
1:     }
1:     
1:     protected int getBlksize()
1:     {
1:         return currentDrdaRs.blksize;
1:     }
1:     protected void setQryrtndta(boolean qryrtndta)
1:     {
1:         currentDrdaRs.qryrtndta = qryrtndta;
1:     }
1:     protected boolean  getQryrtndta()
1:     {
1:         return currentDrdaRs.qryrtndta;
1:     }
1:     protected void setQryscrorn(int qryscrorn)
1:     {
1:         currentDrdaRs.qryscrorn = qryscrorn;
1:     }
1:     protected int  getQryscrorn()
1:     {
1:         return currentDrdaRs.qryscrorn;
1:     }
1:     protected void setScrollType(int scrollType)
1:     {
1:         currentDrdaRs.scrollType = scrollType;
1:     }
1:     protected int  getScrollType()
1:     {
1:         return currentDrdaRs.scrollType;
1:     }
1:     /** 
1:      * is this a scrollable cursor?
1:      * return true if this is not a forward only cursor
1:      */
1:     protected boolean isScrollable()
1:     {
1:         return (getScrollType() != ResultSet.TYPE_FORWARD_ONLY);
1:     }
1:     protected void setConcurType(int scrollType)
1:     {
1:         currentDrdaRs.concurType = scrollType;
1:     }
1:     protected int  getConcurType()
1:     {
1:         return currentDrdaRs.concurType;
1:     }
0:     protected void     setOutovr_drdaType(int[] outovr_drdaType) 
1:     {
1:        currentDrdaRs.outovr_drdaType = outovr_drdaType;
1:     }
1:     protected int[]     getOutovr_drdaType() 
1:     {
1:         return currentDrdaRs.outovr_drdaType;
1:     }
1:     
1:     protected boolean hasdata()
1:     {
1:         return currentDrdaRs.hasdata;
1:     }
1:     
1:     protected void  setHasdata(boolean hasdata)
1:     {
1:         currentDrdaRs.hasdata = hasdata;
1:     }
1:     /**
1:      * This method is used to initialize the default statement of the database
1:      * for re-use. It is different from reset() method since default statements
0:      * get initiliazed differently. e.g: stmt variable used in default statement
1:      * is created only once in Database.makeConnection. 
0:      * TODO: Need to see what exactly it means to initialize the default 
0:      * statement. (DERBY-1002)
1:      * 
1:      */
1:     protected void initialize() 
1:     {
1:         setTypDefValues();
1:     }
1:     protected PreparedStatement explicitPrepare(String sqlStmt) throws SQLException
1:     {
1:         explicitlyPrepared = true;
1:         return prepare(sqlStmt);
1:     }
1:     protected boolean wasExplicitlyPrepared()
1:     {
1:         return explicitlyPrepared;
1:     }
1:     /**
1:      * Create a prepared statement
1:      *
1:      * @param sqlStmt - SQL statement
1:      *
1:      * @exception SQLException
1:      */
1:     protected PreparedStatement prepare(String sqlStmt)   throws SQLException
1:     {
1:         // save current prepare iso level
1:         int saveIsolationLevel = -1;
1:         boolean isolationSet = false;
1:         if (pkgnamcsn !=null && 
1:             isolationLevel != Connection.TRANSACTION_NONE)
1:         {
1:             saveIsolationLevel = database.getPrepareIsolation();
1:             database.setPrepareIsolation(isolationLevel);
1:             isolationSet = true;
1:         }
1:         
0:         parsePkgidToFindHoldability();
1:         if (isCallableSQL(sqlStmt))
1:         {
1:             isCall = true;
0:             ps = database.getConnection().prepareCall(
0:                 sqlStmt, scrollType, concurType, withHoldCursor);
1:             setupCallableStatementParams((CallableStatement)ps);
1:         }
1:         else
1:         {
0:             ps = database.getConnection().prepareStatement(
0:                 sqlStmt, scrollType, concurType, withHoldCursor);
1:         }
1:         // beetle 3849  -  Need to change the cursor name to what
1:         // JCC thinks it will be, since there is no way in the 
1:         // protocol to communicate the actual cursor name.  JCC keeps 
1:         // a mapping from the client cursor names to the DB2 style cursor names
1:         if (cursorName != null)//cursorName not null means we are dealing with dynamic pacakges
1:             ps.setCursorName(cursorName);
1:         if (isolationSet)
1:             database.setPrepareIsolation(saveIsolationLevel);
1:     }
1:     /**
1:      * Get prepared statement
1:      *
1:      * @return prepared statement
1:      */
0:     protected PreparedStatement getPreparedStatement() throws SQLException
1:     {
1:         return ps;
1:     }
1:     /**
1:      * Executes the prepared statement and populates the resultSetTable.
1:      * Access to the various resultSets is then possible by using
1:      * setCurrentDrdaResultSet(String pkgnamcsn)  to set the current
1:      * resultSet and then calling getResultSet() or the other access 
1:      * methods to get resultset data.
1:      *
1:      * @return true if the execution has resultSets
1:      */
1:     protected boolean execute() throws SQLException
1:     {
1:         boolean hasResultSet = ps.execute();
1:         // DERBY-3085 - We need to make sure we drain the streamed parameter
1:         // if not used by the server, for example if an update statement does not 
1:         // update any rows, the parameter won't be used.  Network Server will
1:         // stream only the last parameter with an EXTDTA. This is stored when the
1:         // parameter is set and drained now after statement execution if needed.
1:         try {
1:             drdaParamState_.drainStreamedParameter();
1:         } catch (IOException e) { 
0:             throw Util.javaException(e);
1:         }
1:         // java.sql.Statement says any result sets that are opened
1:         // when the statement is re-executed must be closed; this
1:         // is handled by the call to "ps.execute()" above--but we
1:         // also have to reset our 'numResultSets' counter, since
1:         // all previously opened result sets are now invalid.
1:         numResultSets = 0;
1:         ResultSet rs = null;
1:         boolean isCallable = (ps instanceof java.sql.CallableStatement);
1:         if (isCallable)
1:             needsToSendParamData = true;
1:         do {
1:             rs = ps.getResultSet();
1:             if (rs !=null)
1:             {
1:                 //For callable statement, get holdability of statement generating the result set
1:                 if(isCallable)
0:                     addResultSet(rs, ((EngineResultSet) rs).getHoldability());
1:                 else
1:                     addResultSet(rs,withHoldCursor);
1:                 hasResultSet = true;
1:             }
1:             // For normal selects we are done, but procedures might
1:             // have more resultSets
1:         }while (isCallable && getMoreResults(Statement.KEEP_CURRENT_RESULT));
1:         return hasResultSet;
1:     }
1:     
1:     /**
1:      * clear out type data for parameters.
1:      * Unfortunately we currently overload the resultSet type info
1:      * rsDRDATypes et al with parameter info.
1:      * RESOLVE: Need to separate this
1:      */
1:     {
1:         needsToSendParamData = false;
1:     }
1:     /**
1:      * Set the pkgid sec num for this statement and the 
1:      * consistency token that will be used for the first resultSet.
1:      * For dyamic packages The package name is encoded as follows
1:      * SYS(S/L)(H/N)xyy 
1:      * where 'S' represents Small package and 'L' large 
1:      *                      (ignored by Derby) 
1:      * Where 'H' represents WITH HOLD, and 'N' represents NO WITH HOLD. 
1:      *                      (May be overridden by SQLATTR for WITH
1:      *                       HOLD")
1:      *
1:      * Where 'www' is the package iteration (ignored by Derby)
1:      * Where 'x' is the isolation level: 0=NC, 1=UR, 2=CS, 3=RS, 4=RR 
1:      * Where 'yy' is the package iteration 00 through FF 
1:      * Where 'zz' is unique for each platform
1:      * Happilly, these values correspond precisely to the internal Derby
1:      * isolation levels  in ExecutionContext.java
1:      * x   Isolation Level                                           
1:      * --  ---------------------
1:      * 0   NC  (java.sql.Connection.TRANSACTION_NONE)
1:      * 1   UR  (java.sql.Connection.TRANACTION_READ_UNCOMMITTED)
1:      * 2   CS  (java.sql.Connection.TRANSACTION_READ_COMMITTED)
1:      * 3   RS  (java.sql.Connection.TRANSACTION_REPEATABLE_READ)
1:      * 4   RR  (java.sql.Connection.TRANSACTION_SERIALIZABLE)
1:      * 
1:      * static packages have preset isolation levels 
1:      * (see getStaticPackageIsolation)
1:      * @param pkgnamcsn  package id section number and token from the client
1:      */
1:     protected void setPkgnamcsn(Pkgnamcsn pkgnamcsn)
1:     {
1:         this.pkgnamcsn =  pkgnamcsn;
1:         // Store the consistency string for the first ResultSet.
1:         // this will be used to calculate consistency strings for the 
1:         // other result sets.
0:         pkgid = pkgnamcsn.getPkgid();
1:         if (isDynamicPkgid(pkgid))
1:         {
1:             isolationLevel = Integer.parseInt(pkgid.substring(5,6));
1:             
1:             
1:             /*
1:              *   generate DB2-style cursorname
1:              *   example value : SQL_CURSN200C1
1:              *   where 
1:              *      SQL_CUR is db2 cursor name prefix;
1:              *      S - Small package , L -Large package
1:              *      N - normal cursor, H - hold cursor 
1:              *      200 - package id as sent by jcc 
1:              *      C - tack-on code for cursors
0:              *      1 - section number sent by jcc         
1:              */
1:             
1:             
1:             // cursor name
1:             // trim the SYS off the pkgid so it wont' be in the cursor name
1:             String shortPkgid = pkgid.substring(pkgid.length() -5 , pkgid.length());
0:             pkgsn = pkgnamcsn.getPkgsn();
1:             this.cursorName = "SQL_CUR" +  shortPkgid + "C" + pkgsn ;
1:         }
1:         else // static package
1:         {
1:             isolationLevel = getStaticPackageIsolation(pkgid);
1:         }
0:         this.pkgcnstkn = pkgnamcsn.getPkgcnstkn();
1:     }
1:     /**
1:      * get the isolation level for a static package.
1:      * @param pkgid - Package identifier string (e.g. SYSSTAT)
1:      * @return isolation
1:      */
1:     private int getStaticPackageIsolation(String pkgid)
1:     {
1:         // SYSSTAT is used for metadata. and is the only static package used
1:         // for JCC. Other static packages will need to be supported for 
1:         // CCC. Maybe a static hash table would then be in order.
1:         if (pkgid.equals("SYSSTAT"))
0:             return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;
1:         else
0:             return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
1:     }
1:     /**
1:      * Get pkgnamcsn
1:      *
1:      * @return pkgnamcsn
1:      */
1:     protected Pkgnamcsn getPkgnamcsn() 
1:     {
1:         return pkgnamcsn;
1:     }
1:     /**
1:      * Get result set
1:      *
1:      * @return result set
1:      */
1:     protected ResultSet getResultSet() 
1:     {
1:         return currentDrdaRs.getResultSet();
1:     }
1:     
1:     /**
1:      * Gets the current DRDA ResultSet
1:      * 
1:      * @return DRDAResultSet
1:      */
1:     protected DRDAResultSet getCurrentDrdaResultSet()
1:     {
1:         return currentDrdaRs ;
1:     }
1:     /**
0:       * Set currentDrdaResultSet 
1:      *
1:      * @param rsNum   The result set number starting with 0
1:      *                 
1:      */
1:     protected void setCurrentDrdaResultSet(int rsNum)
1:     {
1:         ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
1:         if (currentDrdaRs.pkgcnstkn == consistToken)
1:             return;
1:         currentDrdaRs = getDrdaResultSet(consistToken);
1:     }
1:     /**
0:       * Set currentDrdaResultSet 
1:      *
1:      * @param pkgnamcsn  The pkgid section number and unique resultset
1:      *                    consistency token
1:      *                 
1:      */
1:     protected void setCurrentDrdaResultSet(Pkgnamcsn pkgnamcsn)
1:     {
0:         pkgid = pkgnamcsn.getPkgid();
0:         pkgsn = pkgnamcsn.getPkgsn();
1:         ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
1:         DRDAResultSet newDrdaRs = getDrdaResultSet(consistToken);
1:         if (newDrdaRs != null)
1:             currentDrdaRs = newDrdaRs;
1:     }
1:     /*
1:      * get DRDAResultSet by consistency token
1:      *
1:      */
1:     private DRDAResultSet getDrdaResultSet(ConsistencyToken consistToken)
1:     {
1:         if ( resultSetTable   == null || 
1:              (currentDrdaRs != null &&
1:               currentDrdaRs.pkgcnstkn == consistToken ))
1:         {
1:             return currentDrdaRs;
1:         }
1:         else
1:         {
1:             return (DRDAResultSet) (resultSetTable.get(consistToken));
1:         }
1:     }
1:     
1:     /*
1:      * get DRDAResultSet by result set number
1:      *
1:      */
1:     private DRDAResultSet getDrdaResultSet(int rsNum)
1:     {
1:         ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
1:         return getDrdaResultSet(consistToken);
1:     }
1:     /** Add a new resultSet to this statement.
1:      * Set as the current result set if  there is not an 
1:      * existing current resultset.
1:      * @param value - ResultSet to add
1:      * @param holdValue - Holdability of the ResultSet 
1:      * @return    Consistency token  for this resultSet
1:      *            For a single resultSet that is the same as the statement's 
1:      *            For multiple resultSets just the consistency token is changed 
1:      */
1:     protected ConsistencyToken addResultSet(ResultSet value, int holdValue) throws SQLException
1:     {
1:         DRDAResultSet newDrdaRs = null;
1:         int rsNum = numResultSets;
1:         ConsistencyToken newRsPkgcnstkn = calculateResultSetPkgcnstkn(rsNum);
1:         if (rsNum == 0)
1:             newDrdaRs = currentDrdaRs;
1:         else
1:         {
1:             newDrdaRs = new DRDAResultSet();
1:             // Multiple resultSets we neeed to setup the hash table
1:             if (resultSetTable == null)
1:             {
1:                 // If hashtable doesn't exist, create it and store resultSet 0
1:                 // before we store our new resultSet.
1:                 // For just a single resultSet we don't ever create the Hashtable.
0:                 resultSetTable =
1:                 resultSetTable.put(pkgcnstkn, currentDrdaRs);
0:                 resultSetKeyList = new ArrayList<ConsistencyToken>();
1:                 resultSetKeyList.add(0, pkgcnstkn);
1:             }
1:             resultSetTable.put(newRsPkgcnstkn, newDrdaRs);
1:             resultSetKeyList.add(rsNum, newRsPkgcnstkn);
1:         }
1:         newDrdaRs.setResultSet(value);
1:         newDrdaRs.setPkgcnstkn(newRsPkgcnstkn);
1:         newDrdaRs.withHoldCursor = holdValue;
1:         setRsDefaultOptions(newDrdaRs);
1:         newDrdaRs.suspend();
1:         numResultSets++;
1:         return newRsPkgcnstkn;
1:     }
1:     /**
1:      *
0:      * @return     number of result sets
1:      */
1:     protected int getNumResultSets()
1:     {
1:         return numResultSets;
1:     }
1:     
1:     
1:     /**
1:      * @param rsNum result set starting with 0
0:      * @return  consistency token (key) for the result set     
1:      */
1:     protected ConsistencyToken getResultSetPkgcnstkn(int rsNum)
1:     {
1:         if (rsNum == 0)
0:             return pkgcnstkn;
1:         else 
0:             return (ConsistencyToken) resultSetKeyList.get(rsNum);               
1:     }
1:     /**
1:      *@return ResultSet DRDA DataTypes
1:      **/
1:     protected int[] getRsDRDATypes()
1:     {
1:         return currentDrdaRs.getRsDRDATypes();
1:     }
1:     /**
1:      *  Close the current resultSet
1:      */
1:     protected void rsClose() throws SQLException
1:     {
1:         if (currentDrdaRs.getResultSet() == null) 
1:             return;
1:         currentDrdaRs.close();
1:         needsToSendParamData = false;        
1:         numResultSets--;
1:     }
1:     /**
1:      * Explicitly close the result set by CLSQRY
1:      * needed to check for double close.
1:      */
1:     protected void CLSQRY()
1:     {
1:         currentDrdaRs.CLSQRY();
1:     }
1:     /* 
1:      * @return whether CLSQRY has been called on the
1:      *         current result set.
1:      */
1:     protected boolean wasExplicitlyClosed()
1:     {
1:         return currentDrdaRs.wasExplicitlyClosed();
1:     }
1:     /**
1:      * This method closes the JDBC objects and frees up all references held by
1:      * this object.
1:      * 
1:      * @throws SQLException
1:      */
1:     protected void close()  throws SQLException
1:     {
1:         if (ps != null)
1:             ps.close();
1:         if (stmt != null)
1:             stmt.close();
1:         currentDrdaRs.close();
1:         resultSetTable = null;
1:         resultSetKeyList = null;
1:         ps = null;
1:         stmtPmeta = null;
1:         stmt = null;
1:         rslsetflg = null;
1:         procName = null;
1:         outputTypes = null;
1:         outputPrecision = null;
1:         outputScale = null;
0:         // Clear parameters and release excess storage
0:         drdaParamState_.clear(true);
1:     }
1:     
1:     /**
1:      * This method resets the state of this DRDAStatement object so that it can
1:      * be re-used. This method should reset all variables of this class except 
1:      * the following:
1:      * 
1:      */
1:     protected void reset() 
1:     {
1:         setTypDefValues();
1:         
1:         withHoldCursor = -1;
0:         scrollType = ResultSet.TYPE_FORWARD_ONLY;    
1:         concurType = ResultSet.CONCUR_READ_ONLY;;
1:         rowCount = 0;
1:         rslsetflg = null;
1:         maxrslcnt = 0;
1:         ps = null;
1:         stmtPmeta = null;
1:         isCall = false;
1:         procName = null;
1:         outputTypes = null;
1:         outputExpected = false;
1:         stmt = null;
1:         
1:         currentDrdaRs.reset();
1:         resultSetTable = null;
1:         resultSetKeyList = null;
1:         numResultSets = 0;
1:         
0:         // Clear parameters without releasing storage
0:         drdaParamState_.clear(false);
1:         
1:         nbrrow = 0;
0:         qryrowset = 0;    
1:         blksize = 0;        
0:         maxblkext = 0;    
0:         outovropt = 0;    
1:         qryrfrtbl = false;
1:         qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;
1:         needsToSendParamData = false;
1:         explicitlyPrepared = false;
1:     }
1:     /**
1:      * is Statement closed
1:      * @return whether the statement is closed
1:      */
1:     protected boolean rsIsClosed()
1:     {
1:         return currentDrdaRs.isClosed();
1:     }
1:     
1:     /**
1:      * Set state to SUSPENDED (result set is opened)
1:      */
1:     protected void rsSuspend()
1:     {
1:         currentDrdaRs.suspend();
1:     }
1:     /**
1:      * set resultset/out parameter precision
1:      *
1:      * @param index - starting with 1
1:      * @param precision
1:      */
1:     protected void setRsPrecision(int index, int precision)
1:     {
1:         currentDrdaRs.setRsPrecision(index,precision);
1:     }
1:     /**
0:      * get resultset /out paramter precision
1:      * @param index -starting with 1
1:      * @return precision of column
1:      */
1:     protected int getRsPrecision(int index)
1:     {
1:         return currentDrdaRs.getRsPrecision(index);
1:     }
1:     /**
1:      * set resultset/out parameter scale
1:      *
1:      * @param index - starting with 1
1:      * @param scale
1:      */
1:     protected void setRsScale(int index, int scale)
1:     {
1:         currentDrdaRs.setRsScale(index, scale);
1:     }
1:     /**
0:      * get resultset /out paramter scale
1:      * @param index -starting with 1
1:      * @return scale of column
1:      */
1:     protected int  getRsScale(int index)
1:     {
1:         return currentDrdaRs.getRsScale(index);
1:     }
1:     
1:     /**
1:      * set result  DRDAType
1:      *
1:      * @param index - starting with 1
1:      * @param type
1:      */
1:     protected  void setRsDRDAType(int index, int type)
1:     {
1:         currentDrdaRs.setRsDRDAType(index,type);
1:         
1:     }
0:     /** Clears the parameter state (type, length and ext information)
0:      * stored in this statement, but does not release any
0:      * storage. This reduces the cost of re-executing the statement
0:      * since no new storage needs to be allocated. */
0:     protected void clearDrdaParams() {
0:         drdaParamState_.clear(false);
1:     }
0:     /** Get the number of external parameters in this
0:      * statement. External means parameters that are transmitted in a
0:      * separate DSS in the DRDA protocol.
0:      * @return the number of external parameters
1:      */
0:     protected int getExtPositionCount() {
0:         return drdaParamState_.getExtPosCount();
1:     }
0:     /** Get the parameter position of the i'th external parameter
0:      * @param i - zero-based index into list of external parameters
0:      * @return the parameter position of the i'th external parameter
1:      */
0:     protected int getExtPosition(int i) {
0:         return drdaParamState_.getExtPos(i);
1:     }
0:     /** Mark the pos'th parameter as external
0:      * @param pos - zero-based index into list of external parameters
1:      */
0:     protected void addExtPosition(int pos) {
0:         drdaParamState_.addExtPos(pos);
1:     }
0:     /** Get the number of parameters, internal and external, that has
0:      * been added to this statement.
0:      * @return the number of parameters
1:      */
0:     protected int getDrdaParamCount() {
0:         return drdaParamState_.getDrdaParamCount();
1:     }
0:     /** Add another parameter to this statement.
0:      * @param t - type of the parameter
0:      * @param l - length in bytes of the parameter
1:      */
0:     protected void addDrdaParam(byte t, int l) {
0:         drdaParamState_.addDrdaParam(t, l);
1:     }
1:     /**
1:      * get parameter DRDAType
1:      *
1:      * @param index - starting with 1
1:      * @return  DRDA Type of column
1:      */
0:      protected int getParamDRDAType(int index) {
0:         return drdaParamState_.getDrdaType(index-1);
1:      }
1:     /**
1:      * returns drda length of parameter as sent by client.
1:      * @param index - starting with 1
1:      * @return data length
1:      */
1:     protected int getParamLen(int index)
1:     {
0:         return drdaParamState_.getDrdaLen(index-1);
1:     }
1:     /**
1:      *  get parameter precision or DB2 max (31)
1:      *
1:      *  @param index parameter index starting with 1
1:      *
1:      *  @return  precision
1:      */
1:     protected int getParamPrecision(int index) throws SQLException
1:     {
1:         if (ps != null && ps instanceof CallableStatement)
1:         {
0:             ParameterMetaData pmeta = getParameterMetaData();
1:             return Math.min(pmeta.getPrecision(index),
1:                             FdocaConstants.NUMERIC_MAX_PRECISION);
1:         }
1:         else 
1:             return -1;
1:     }
1:     
1:     /**
1:      *  get parameter scale or DB2 max (31)
1:      *
1:      *  @param index parameter index starting with 1
1:      *
1:      *  @return  scale
1:      */
1:     protected int getParamScale(int index) throws SQLException
1:     {
1:         if (ps != null && ps instanceof CallableStatement)
1:         {
0:             ParameterMetaData pmeta = getParameterMetaData();
1:             return Math.min(pmeta.getScale(index),FdocaConstants.NUMERIC_MAX_PRECISION);
1:         }
1:         else 
1:             return -1;
1:     }
1:     /** 
1:      * get the number of result set columns for the current resultSet
1:      * 
1:      * @return number of columns
1:      */
1:     protected int getNumRsCols()
1:     {
1:         int[] rsDrdaTypes = getRsDRDATypes();
1:         if (rsDrdaTypes != null)
1:             return rsDrdaTypes.length;
1:         else 
1:             return 0;
1:     }
1:     /**
1:      * get  resultset/out parameter DRDAType
1:      *
1:      * @param index - starting with 1
1:      * @return  DRDA Type of column
1:      */
1:     protected int getRsDRDAType(int index)
1:     {
1:         return currentDrdaRs.getRsDRDAType(index);
1:     }
1:     /**
1:      * get resultset/out parameter DRDALen
1:      * @param index starting with 1
1:      * 
1:      * @return length of drda data
1:      */
1:      
1:     protected int getRsLen(int index)
1:     {
1:         return currentDrdaRs.getRsLen(index);
1:     }
1:     /**
1:      * @param rsNum  - result set # starting with 0 
1:      */
1:     public String getResultSetCursorName(int rsNum) throws SQLException
1:     {
1:         DRDAResultSet drdaRs = getDrdaResultSet(rsNum);
0:         return drdaRs.getResultSetCursorName();            
1:     }
1:     protected String toDebugString(String indent)
1:     {        
1:         String s ="";
1:         if (ps == null) 
1:             s += indent + ps;
1:         else
1:         {
0:             s += indent + pkgid + pkgsn ;
1:             s += "\t" + getSQLText();
1:         }
1:         return s;
1:     }
1:     /**  For a single result set, just echo the consistency token that the client sent us.
1:      * For subsequent resultSets, just subtract the resultset number from
1:      * the consistency token and that will differentiate the result sets.
1:      * This seems to be what DB2 does
1:      * @param rsNum  - result set # starting with 0
1:      * 
1:      * @return  Consistency token for result set
1:      */
1:     protected ConsistencyToken calculateResultSetPkgcnstkn(int rsNum)
1:     {    
0:         ConsistencyToken consistToken = pkgcnstkn;
0:         if (rsNum == 0 || pkgcnstkn == null)
1:             return consistToken;
1:         else
1:         {
1:             BigInteger consistTokenBi =
1:                 new BigInteger(consistToken.getBytes());
1:             BigInteger rsNumBi = BigInteger.valueOf(rsNum);
1:             consistTokenBi = consistTokenBi.subtract(rsNumBi);
1:             consistToken = new ConsistencyToken(consistTokenBi.toByteArray());
1:         }
1:         return consistToken;
1:     }
1:     protected boolean isCallableStatement()
1:     {
1:         return isCall;
1:     }
1:     private boolean isCallableSQL(String sql)
1:     {
1:         java.util.StringTokenizer tokenizer = new java.util.StringTokenizer
1:             (sql, "\t\n\r\f=? (");
1:          String firstToken = tokenizer.nextToken();
1:          if (StringUtil.SQLEqualsIgnoreCase(firstToken, 
1:                                             "call")) // captures CALL...and ?=CALL...
1:              return true;
1:          return false;
1:                  
1:     }
1:     private void setupCallableStatementParams(CallableStatement cs) throws SQLException
1:     {
0:         ParameterMetaData pmeta = getParameterMetaData();
1:         int numElems = pmeta.getParameterCount();
1:         for ( int i = 0; i < numElems; i ++)
1:         {
1:             boolean outputFlag = false;
1:             
1:             int parameterMode = pmeta.getParameterMode(i + 1);
1:             int parameterType = pmeta.getParameterType(i + 1);
1:             switch (parameterMode) {
0:                 case JDBC30Translation.PARAMETER_MODE_IN:
1:                     break;
0:                 case JDBC30Translation.PARAMETER_MODE_OUT:
0:                 case JDBC30Translation.PARAMETER_MODE_IN_OUT:
1:                     outputFlag = true;
1:                     break;
0:                 case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
1:                     // It's only unknown if array
1:                     String objectType = pmeta.getParameterClassName(i+1);
1:                     parameterType =
1:                         getOutputParameterTypeFromClassName(objectType);
1:                     if (parameterType  != NOT_OUTPUT_PARAM)
1:                         outputFlag = true;
1:             }
1:             if (outputFlag)
1:             {
1:                 if (outputTypes == null) //not initialized yet, since previously none output
1:                 {
1:                     outputTypes = new int[numElems];
1:                     outputPrecision = new int [numElems];
1:                     outputScale = new int [numElems];
1:                     for (int j = 0; j < numElems; j++) {
1:                         outputTypes[j] = NOT_OUTPUT_PARAM;  //default init value
1:                         outputPrecision[j] = NOT_OUTPUT_PARAM;
1:                         outputScale[j] = NOT_OUTPUT_PARAM;
1:                     }
1:                 }
1:                 // save the output type so we can register when we parse
1:                 // the SQLDTA
1:                 outputTypes[i] = parameterType;
1:                 outputPrecision[i] = parameterPrecision;
1:                 outputScale[i] = parameterScale;                
1:             }
1:             
1:         }
1:     }
1:     /** 
1:         Given an object class  name get the paramameter type if the 
1:         parameter mode is unknown.
1:         
1:         Arrays except for byte arrrays are assumed to be output parameters
1:         TINYINT output parameters are going to be broken because there
1:         is no way to differentiate them from binary input parameters.
1:         @param objectName Class name of object being evaluated.
1:         indicating if this an output parameter
1:         @return type from java.sql.Types
1:     **/
1:     
1:     protected static int getOutputParameterTypeFromClassName(String
1:                                                                     objectName)
1:     {
1:         
1:         if (objectName.endsWith("[]"))
1:         {
1:                     // For byte[] we are going to assume it is input.
1:             // For TINYINT output params you gotta use 
0:             //  object Integer[] or use a procedure                   
1:                     if (objectName.equals("byte[]"))
1:                     {
1:                         return NOT_OUTPUT_PARAM;
1:                             
1:                             //isOutParam[offset] = false;
1:                             //return java.sql.Types.VARBINARY;
1:                     }
1:                     
1:                     // Known arrays are output parameters
1:                     // otherwise we pass it's a JAVA_OBJECT
1:                     if (objectName.equals("java.lang.Byte[]"))
1:                         return java.sql.Types.TINYINT;
1:                     
1:                     if (objectName.equals("byte[][]"))
1:                         return java.sql.Types.VARBINARY;
1:                     if (objectName.equals("java.lang.String[]"))
1:                         return java.sql.Types.VARCHAR; 
1:                     if (objectName.equals("int[]") || 
1:                         objectName.equals("java.lang.Integer[]"))
1:                         return java.sql.Types.INTEGER;
1:                     else if (objectName.equals("long[]")
1:                              || objectName.equals("java.lang.Long[]"))
1:                         return java.sql.Types.BIGINT;
1:                     else if (objectName.equals("java.math.BigDecimal[]"))
1:                         return java.sql.Types.NUMERIC;
1:                     else if (objectName.equals("boolean[]")  || 
1:                              objectName.equals("java.lang.Boolean[]"))
1:                         return java.sql.Types.BIT;
1:                     else if (objectName.equals("short[]"))
1:                         return java.sql.Types.SMALLINT;
1:                     else if (objectName.equals("float[]") ||
1:                              objectName.equals("java.lang.Float[]"))
1:                         return java.sql.Types.REAL;
1:                     else if (objectName.equals("double[]") ||
1:                              objectName.equals("java.lang.Double[]"))
1:                         return java.sql.Types.DOUBLE;
1:                     else if (objectName.equals("java.sql.Date[]"))
1:                         return java.sql.Types.DATE;
1:                     else if (objectName.equals("java.sql.Time[]"))
1:                         return java.sql.Types.TIME;
1:                     else if (objectName.equals("java.sql.Timestamp[]"))
1:                         return java.sql.Types.TIMESTAMP;
1:         }
1:         // Not one of the ones we know. This must be a JAVA_OBJECT
1:         return NOT_OUTPUT_PARAM;
1:         //isOutParam[offset] = false;                
1:         //return java.sql.Types.JAVA_OBJECT;
1:     }
1:     
1:     
1:     public void registerAllOutParams() throws SQLException
1:     {
1:         if (isCall && (outputTypes != null))
1:             for (int i = 1; i <= outputTypes.length; i ++)
1:                 registerOutParam(i);
1:         
1:     }
1:     
1:     public void registerOutParam(int paramNum) throws SQLException
1:     {
1:         CallableStatement cs;
1:         if (isOutputParam(paramNum))
1:         {
1:             cs = (CallableStatement) ps;
1:             cs.registerOutParameter(paramNum, getOutputParamType(paramNum));
1:         }
1:     }
1:     protected boolean hasOutputParams()
1:     {
1:         return (outputTypes != null);
1:     }
1:     /**
1:      * is  parameter an ouput parameter
1:      * @param paramNum parameter number starting with 1.
1:      * return true if this is an output parameter.
1:      */
1:     boolean isOutputParam(int paramNum)
1:     {
1:         if (outputTypes != null)
1:             return (outputTypes[paramNum - 1] != NOT_OUTPUT_PARAM);
1:         return false;
1:         
1:     }
1:     /** 
1:      * get type for output parameter. 
1:      *
1:      * @param paramNum - parameter number starting with 1
1:      * @return jdbcType or NOT_OUTPUT_PARAM if this is not an output parameter
1:      */
1:     int getOutputParamType(int paramNum)
1:     {
1:         if (outputTypes != null)
1:             return (outputTypes[ paramNum - 1 ]);
1:         return NOT_OUTPUT_PARAM;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     private boolean isDynamicPkgid(String pkgid)
1:     {
1:         char size = pkgid.charAt(3);
1:         
1:         //  separate attribute used for holdability in 5.1.60
1:         // this is just for checking that it is a dynamic package
1:         char holdability = pkgid.charAt(4);                                                 
1:         return (pkgid.substring(0,3).equals("SYS") && (size == 'S' ||
1:                                                        size == 'L')
1:                 && (holdability == 'H' || holdability == 'N'));
1:         
0:     }
1:     private  void parsePkgidToFindHoldability()
1:     {
1:         if (withHoldCursor != -1)
1:             return;
1:         //First, check if holdability was passed as a SQL attribute "WITH HOLD" for this prepare. If yes, then withHoldCursor
1:         //should not get overwritten by holdability from package name and that is why the check for -1
1:         if (isDynamicPkgid(pkgid))
1:         {       
1:             if(pkgid.charAt(4) == 'N')
1:                 withHoldCursor = ResultSet.CLOSE_CURSORS_AT_COMMIT;
1:             else  
1:                 withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
0:         }
1:         else 
1:         {            
1:             withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
1:         
0:         }
0:     }
0:     /** 
1:      * Retrieve the ParameterMetaData for the prepared statement. 
0:      * @return ParameterMetaData for the prepared statement. 
1:      * Note: there is no separate BrokeredParameterSetMetaData.
0:      */
0:     protected ParameterMetaData getParameterMetaData() throws SQLException
1:     {
1:         if (stmtPmeta != null)
1:             return stmtPmeta;
0:         stmtPmeta = ps.getParameterMetaData();
0:     }
1:     
0:     /**
1:      * get more results using reflection.
1:      * @param current - flag to pass to Statement.getMoreResults(current)
1:      * @return true if there are more results.
1:      * @throws SQLException
1:      * @see java.sql.Statement#getMoreResults
0:      *
0:      */
1:     private boolean getMoreResults(int current) throws SQLException
1:     {       
0:     }
0:     /**
1:      * Use reflection to retrieve SQL Text for EmbedPreparedStatement  
1:      * or BrokeredPreparedStatement.
1:      * @return SQL text
0:      */
1:     private String getSQLText() 
1:     {
1:        String retVal = null;
1:         Class[] emptyPARAM = {};
1:         Object[] args = null;
1:         try {
1:             Method sh = getPreparedStatement().getClass().getMethod("getSQLText",emptyPARAM);
1:             retVal = (String) sh.invoke(getPreparedStatement(),args);
0:         }
1:         catch (Exception e)
1:         {
1:             //  do nothing we will just return a null string
0:         }
1:         return retVal;
0:     }
1:     
0:     /**
1:      * Method to decide whether the ResultSet should be closed
1:      * implicitly based on the QRYCLSIMP value sent from the
1:      * client. Only forward-only result sets should be implicitly
1:      * closed. Some clients do not expect result sets to be closed
1:      * implicitly if the protocol is LMTBLKPRC.
0:      *
1:      * @param lmtblkprcOK <code>true</code> if the client expects
1:      * QRYCLSIMP to be respected for the LMTBLKPRC protocol
1:      * @return implicit close boolean
1:      * @exception SQLException
0:      */
1:     boolean isRSCloseImplicit(boolean lmtblkprcOK) throws SQLException {
1:         return
1:             (currentDrdaRs.qryclsimp == CodePoint.QRYCLSIMP_YES) &&
1:             !isScrollable() &&
1:             (lmtblkprcOK ||
1:              (currentDrdaRs.getQryprctyp() != CodePoint.LMTBLKPRC));
0:     }
commit:788599f
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0: 		// The last parameter may be streamed. 
0: 		// We need to keep a record of it so we can drain it if it is not 
0: 		// used.
0: 		// Only the last parameter with an EXTDTA will be streamed. 
0: 		//(See DRDAConnThread.readAndSetAllExtParams()). 
0: 		private EXTDTAReaderInputStream streamedParameter = null;
/////////////////////////////////////////////////////////////////////////
0: 			streamedParameter = null;
/////////////////////////////////////////////////////////////////////////
1:         
0: 		/**
0: 		 * Read the rest of the streamed parameter if not consumed
0: 		 * by the executing statement.  DERBY-3085
0: 		 * @throws IOException
0: 		 */
0: 		protected void drainStreamedParameter() throws IOException
0: 		{
0: 			if (streamedParameter != null)
0: 			{   
0: 				// we drain the buffer 1000 bytes at a time.
0: 				// 1000 is just a random selection that doesn't take
0: 				// too much memory. Perhaps something else would be 
0: 				// more efficient?
0: 				byte[] buffer = new byte[1000];
0: 				int i;
0: 				do {
0: 					i= streamedParameter.read(buffer,0,1000);
0: 				}  while (i != -1);
0: 			}
0: 		}
1:             
1: 
0: 		public void setStreamedParameter(EXTDTAReaderInputStream eis) {
0: 			streamedParameter = eis;    
0: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
0: 		// DERBY-3085 - We need to make sure we drain the streamed parameter
0: 		// if not used by the server, for example if an update statement does not 
0: 		// update any rows, the parameter won't be used.  Network Server will
0: 		// stream only the last parameter with an EXTDTA. This is stored when the
0: 		// parameter is set and drained now after statement execution if needed.
0: 		try {
0: 			drdaParamState_.drainStreamedParameter();
0: 		} catch (IOException e) { 
0: 			Util.javaException(e);
0: 		}
/////////////////////////////////////////////////////////////////////////
1:     protected void setStreamedParameter(EXTDTAReaderInputStream eis)
0:     {
1:         drdaParamState_.setStreamedParameter(eis);
0:     }
1:     
commit:6eb5042
/////////////////////////////////////////////////////////////////////////
0: 	private int[] outputPrecision;
0: 	private int[] outputScale;
1:         
/////////////////////////////////////////////////////////////////////////
0: 		outputPrecision = null;
0: 		outputScale = null;
/////////////////////////////////////////////////////////////////////////
1:                         int parameterPrecision = pmeta.getPrecision(i + 1);
1:                         int parameterScale = pmeta.getScale(i + 1);
/////////////////////////////////////////////////////////////////////////
0: 					outputPrecision = new int [numElems];
0: 					outputScale = new int [numElems];
0: 					for (int j = 0; j < numElems; j++) {
0: 						outputPrecision[j] = NOT_OUTPUT_PARAM;
0: 						outputScale[j] = NOT_OUTPUT_PARAM;
0: 					}
0: 				outputPrecision[i] = parameterPrecision;
0: 				outputScale[i] = parameterScale;                
/////////////////////////////////////////////////////////////////////////
0:         /** 
1:          * get scale for output parameter. 
0:          *
1:          * @param paramNum - parameter number starting with 1
1:          * @return scale or NOT_OUTPUT_PARAM if this is not an output parameter
0:          */
1:         int getOutputParamScale(int paramNum){
1:             if (outputScale != null)
1:                 return (outputScale[paramNum -1]);
1:             return NOT_OUTPUT_PARAM;
0:         }
1: 
0:         /** 
1:          * get precision  for output parameter. 
0:          *
1:          * @param paramNum - parameter number starting with 1
1:          * @return precision or NOT_OUTPUT_PARAM if this is not an output parameter
0:          */
1:         int getOutputParamPrecision(int paramNum){
1:             if (outputPrecision != null)
1:                 return (outputPrecision[paramNum -1]);
1:             return NOT_OUTPUT_PARAM;
0:         }
1:         
commit:f0dcf0b
/////////////////////////////////////////////////////////////////////////
0: 	//NOTE!
0: 	//
0: 	// Since DRDAStatements are reused, ALL variables (except those noted in 
0: 	// the comments for reset method) should be set to their default values 
0: 	// in reset().
1: 	
/////////////////////////////////////////////////////////////////////////
0: 	 * This method is used to initialize the default statement of the database
0: 	 * for re-use. It is different from reset() method since default statements
0: 	 * get initiliazed differently. e.g: stmt variable used in default statement
0: 	 * is created only once in Database.makeConnection. 
0: 	 * TODO: Need to see what exactly it means to initialize the default 
0: 	 * statement. (DERBY-1002)
0: 	 * 
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * This method closes the JDBC objects and frees up all references held by
0: 	 * this object.
0: 	 * @throws SQLException
/////////////////////////////////////////////////////////////////////////
0: 		currentDrdaRs.close();
0: 	}
1: 	
0: 	/**
0: 	 * This method resets the state of this DRDAStatement object so that it can
0: 	 * be re-used. This method should reset all variables of this class except 
0: 	 * the following:
1:      * 1. database - This variable gets initialized in the constructor and by
1:      * call to setDatabase.
1:      * 2. members which get initialized in setPkgnamcsn (pkgnamcsn, pkgcnstkn, 
1:      * pkgid, pkgsn, isolationLevel, cursorName). pkgnamcsn is the key used to 
1:      * find if the DRDAStatement can be re-used. Hence its value will not change 
1:      * when the object is re-used.
0: 	 * 
0: 	 */
0: 	protected void reset() 
0: 	{
0: 		setTypDefValues();
1: 		
0: 		withHoldCursor = -1;
0: 		scrollType = ResultSet.TYPE_FORWARD_ONLY;	
0: 		concurType = ResultSet.CONCUR_READ_ONLY;;
0: 		rowCount = 0;
0: 		rslsetflg = null;
0: 		maxrslcnt = 0;
0: 		ps = null;
0: 		stmtPmeta = null;
0: 		isCall = false;
0: 		procName = null;
0: 		outputTypes = null;
0: 		outputExpected = false;
0: 		stmt = null;
1: 		
0: 		currentDrdaRs.reset();
0: 		resultSetTable = null;
0: 		resultSetKeyList = null;
0: 		numResultSets = 0;
1: 		
0: 		cliParamDrdaTypes = new Vector();
0: 		cliParamLens = new Vector();
0: 		cliParamExtPositions = null;
1: 		
0: 		nbrrow = 0;
0: 		qryrowset = 0;	
0: 		blksize = 0;		
0: 		maxblkext = 0;	
0: 		outovropt = 0;	
0: 		qryrfrtbl = false;
0: 		qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;
1: 
0: 		needsToSendParamData = false;
0: 		explicitlyPrepared = false;
0: 	}
commit:2e4a44e
/////////////////////////////////////////////////////////////////////////
commit:41f1df9
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public void setSplitQRYDTA(byte []data)
0: 	{
0: 		currentDrdaRs.setSplitQRYDTA(data);
0: 	}
0: 	public byte[]getSplitQRYDTA()
0: 	{
0: 		return currentDrdaRs.getSplitQRYDTA();
0: 	}
commit:82c7dde
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		int[] rsDrdaTypes = getRsDRDATypes();
/////////////////////////////////////////////////////////////////////////
0: 		DRDAResultSet drdaRs = getDrdaResultSet(rsNum);
0: 		return drdaRs.getResultSetCursorName();			
commit:4b9c0f5
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	/**
0: 	 *
0: 	 *  get resultSetHoldability with reflection. 
0: 	 *  We need to use reflection so we can use hold cursors with 1.3.1. 
0: 	 *  And also since our statement might be a BrokeredStatement.
0: 	 * 
0: 	 * @param rs ResultSet 
0: 	 * @return the resultSet holdability for the prepared statement
0: 	 *
0: 	 */
0: 	protected int getResultSetHoldability(ResultSet rs) throws SQLException
0: 	{
0: 		Statement rsstmt = null;
0: 		int holdValue = -1;
1: 
0: 		if (rs  != null)
0: 			rsstmt = rs.getStatement();
0: 		else
0: 			rsstmt = getPreparedStatement();
1: 				
0: 		Class[] getResultSetHoldabilityParam  = {};
0: 		try {
0: 			Method sh =
0: 				rsstmt.getClass().getMethod("getResultSetHoldability", getResultSetHoldabilityParam);
0: 			holdValue =  ((Integer) sh.invoke(rsstmt,null)).intValue();
0: 		}
0: 		catch (Exception e) {
0: 			handleReflectionException(e);
0: 		}
0: 		return holdValue;
0: 	}	
/////////////////////////////////////////////////////////////////////////
0: 				//For callable statement, get holdability of statement generating the result set
0: 				if(isCallable)
0: 					addResultSet(rs,getResultSetHoldability(rs));
0: 				else
0: 					addResultSet(rs,withHoldCursor);
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	/**
0: 	 * Gets the current DRDA ResultSet
0: 	 * 
0: 	 * @return DRDAResultSet
0: 	 */
0: 	protected DRDAResultSet getCurrentDrdaResultSet()
0: 	{
0: 		return currentDrdaRs ;
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 	 * @param holdValue - Holdability of the ResultSet 
0: 	protected String  addResultSet(ResultSet value, int holdValue) throws SQLException
/////////////////////////////////////////////////////////////////////////
0: 		newDrdaRs.withHoldCursor = holdValue;
commit:9ce79e7
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
0: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.math.BigInteger;
1: import java.sql.CallableStatement;
1: import java.sql.Statement;
1: import java.util.Hashtable;
0: import org.apache.derby.iapi.jdbc.BrokeredConnection;
0: import org.apache.derby.iapi.jdbc.BrokeredPreparedStatement;
0: import org.apache.derby.impl.jdbc.EmbedParameterSetMetaData;
1: import org.apache.derby.impl.jdbc.Util;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * Delegation method to call DRDAResultSet to set query 
0: 	 * options sent on OPNQRY.
0: 	 * @see DRDAResultSet#setOPNQRYOptions(int, int, int, int, int, int)
0: 		currentDrdaRs.setOPNQRYOptions( blksize, qryblkctl, maxblkext, 
0: 				outovropt, qryrowset, qryclsimpl);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	/**
0: 	 * Delegation method to call DRDAResultSet.isRSCloseImplicit()
0: 	 * 
0: 	 * @see DRDAResultSet#isRSCloseImplicit()
0: 	 * @return implicit close boolean
0: 	 * @throws SQLException
0: 	 */
0: 	boolean isRSCloseImplicit() throws SQLException {
0: 		return currentDrdaRs.isRSCloseImplicit();
0: 	}
commit:9085abb
/////////////////////////////////////////////////////////////////////////
0: 					new BigInteger(consistToken.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING));
0: 				consistToken = new String(consistTokenBi.toByteArray(),NetworkServerControlImpl.DEFAULT_ENCODING);
commit:f98efa1
/////////////////////////////////////////////////////////////////////////
0: 		if (pkgnamcsn !=null && 
0: 			isolationLevel != Connection.TRANSACTION_NONE)
commit:181c127
/////////////////////////////////////////////////////////////////////////
0: 		Connection conn = database.getConnection();
0: 		if (conn instanceof BrokeredConnection)
0: 			ps = conn.prepareStatement(sqlStmt, scrollType, concurType);
0: 		else
0: 			ps = prepareStatementJDBC3(sqlStmt, scrollType, concurType, 
0: 									   withHoldCursor);
/////////////////////////////////////////////////////////////////////////
0: 				t.printStackTrace();
commit:2e4a36f
/////////////////////////////////////////////////////////////////////////
0: import  org.apache.derby.iapi.jdbc.BrokeredPreparedStatement;
/////////////////////////////////////////////////////////////////////////
0: 			holdValue =  ((Integer) sh.invoke(rsstmt,null)).intValue();
/////////////////////////////////////////////////////////////////////////
0: 	protected PreparedStatement getPreparedStatement() throws SQLException
0: 		if (ps instanceof BrokeredPreparedStatement)
0: 			return (PreparedStatement)(
0: 						   ((BrokeredPreparedStatement) ps).getStatement());
0: 		else
1: 			return ps;
commit:fd8a779
/////////////////////////////////////////////////////////////////////////
0: 				getPreparedStatement().getClass().getMethod("getEmbedParameterSetMetaData", getParameterMetaDataParam);
/////////////////////////////////////////////////////////////////////////
1: 			
/////////////////////////////////////////////////////////////////////////
0: 			{
0: 			}
commit:4383496
/////////////////////////////////////////////////////////////////////////
0: import  org.apache.derby.iapi.jdbc.BrokeredConnection;
/////////////////////////////////////////////////////////////////////////
0: 	protected int scrollType = ResultSet.TYPE_FORWARD_ONLY;			// Sensitive or Insensitive scroll attribute
0: 	protected int concurType = ResultSet.CONCUR_READ_ONLY;;			// Concurency type
0: 	protected EmbedParameterSetMetaData stmtPmeta; // param metadata
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 *
0: 	 *  get resultSetHoldability with reflection. 
0: 	 *  We need to use reflection so we can use hold cursors with 1.3.1. 
0: 	 *  And also since our statement might be a BrokeredStatement.
0: 	 * 
0: 	 * @return the resultSet holdability for the prepared statement
0: 	 *
0: 	 */
0: 	protected int getResultSetHoldability() throws SQLException
0: 	{
0: 		Statement rsstmt = null;
0: 		ResultSet rs = getResultSet();
0: 		int holdValue = -1;
1: 
0: 		if (rs  != null)
0: 			rsstmt = rs.getStatement();
0: 		else
0: 			rsstmt = getPreparedStatement();
1: 				
0: 		Class[] getResultSetHoldabilityParam  = {};
0: 		try {
0: 			Method sh =
0: 				rsstmt.getClass().getMethod("getResultSetHoldability", getResultSetHoldabilityParam);
0: 			holdValue =  ((Integer) sh.invoke(ps,null)).intValue();
0: 		}
0: 		catch (Exception e) {
0: 			handleReflectionException(e);
0: 		}
0: 		return holdValue;
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 	/** 
0: 	 * is this a scrollable cursor?
0: 	 * return true if this is not a forward only cursor
0: 	 */
0: 	protected boolean isScrollable()
0: 	{
0: 		return (getScrollType() != ResultSet.TYPE_FORWARD_ONLY);
0: 	}
/////////////////////////////////////////////////////////////////////////
0: 		ps = prepareStatementJDBC3(sqlStmt, scrollType, concurType, 
0: 								   withHoldCursor);
/////////////////////////////////////////////////////////////////////////
0: 		}while (isCallable && getMoreResults(JDBC30Translation.KEEP_CURRENT_RESULT));
/////////////////////////////////////////////////////////////////////////
0: 	/** 
0: 	 * Clean up statements and resultSet
/////////////////////////////////////////////////////////////////////////
0: 		stmtPmeta = null;
0: 		scrollType = ResultSet.TYPE_FORWARD_ONLY;	
0: 		concurType = ResultSet.CONCUR_READ_ONLY;;
/////////////////////////////////////////////////////////////////////////
0: 			EmbedParameterSetMetaData pmeta = 	getParameterMetaData();
1: 
/////////////////////////////////////////////////////////////////////////
0: 			EmbedParameterSetMetaData pmeta = 	getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
0: 			s += "\t" + getSQLText();
/////////////////////////////////////////////////////////////////////////
0: 		EmbedParameterSetMetaData pmeta = 	getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0: 	/**
0: 	 *  prepare a statement using reflection so that server can run on jdk131
0: 	 *  and still pass holdability.  
0: 	 *  parameters are passed on to either the EmbedConnection or 
0: 	 *  BrokeredConnection prepareStatement() method.
0: 	 *  @param sqlStmt - SQL statement text
0: 	 *  @param scrollType - scroll type
0: 	 *  @param concurtype - concurrency type
0: 	 *  @param withHoldCursor - holdability
0: 	 * 
0: 	 *  @throws SQLException
0: 	 *  @return Prepared Statement
0: 	 *  @see java.sql.Connection#prepareStatement
0: 	 */
0: 	private PreparedStatement prepareStatementJDBC3(String sqlStmt, int
0: 													scrollType, int concurType,
0: 													int withHoldCursor) throws SQLException
0: 	{
0: 		PreparedStatement lps = null;
1: 
0: 		// If holdability is still uninitialized, default is HOLD_CURSORS_OVER_COMMIT
0: 		int resultSetHoldability = (withHoldCursor == -1) ? 
0: 			resultSetHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT :
0: 			withHoldCursor;
1: 
0: 		//prepareStatement takes 4 parameters
0: 		Class[] PREP_STMT_PARAM = { String.class, Integer.TYPE, Integer.TYPE, Integer.TYPE };
0: 		Object[] PREP_STMT_ARG = { sqlStmt, new Integer(scrollType),
0: 								   new Integer(concurType), new Integer(resultSetHoldability)};
0: 		try {
0: 			//create a prepared statement with hold cursor over commit using reflection.
0: 			Method sh = database.getConnection().getClass().getMethod("prepareStatement", PREP_STMT_PARAM);
0: 			lps = (PreparedStatement) (sh.invoke(database.getConnection(), PREP_STMT_ARG));
0: 		} catch (Exception e) {
0: 			handleReflectionException(e);
0: 		} 
1: 
0: 		return lps;
0: 	}
1: 
1: 	
0: 	/** 
0: 	 * Get parameter metadata from EmbedPreparedStatement or 
0: 	 * BrokeredPreparedStatement. We use reflection because we don't know which
0: 	 * we have.
0: 	 * 
0: 	 * @return EmbedParameterSetMetaData for the prepared statement. 
0: 	 * Note: there is no separate BrokeredParameterSetMetaData.
0: 	 */
0: 	protected EmbedParameterSetMetaData getParameterMetaData() throws SQLException
0: 	{
0: 		if (stmtPmeta != null)
1: 			return stmtPmeta;
1: 
0: 		EmbedParameterSetMetaData pmeta = null;
0: 		Class[] getParameterMetaDataParam = {};
0: 		try {
0: 			Method sh =
0: 				getPreparedStatement().getClass().getMethod("getParameterMetaData", getParameterMetaDataParam);
0: 			pmeta = (EmbedParameterSetMetaData)
0: 				sh.invoke(getPreparedStatement(),null);
0: 			stmtPmeta = pmeta;
0: 		}
0: 		catch (Exception e) {
0: 			handleReflectionException(e);
0: 		}
1: 		return stmtPmeta;
0: 	}
1: 	
0: 	/**
0: 	 * get more results using reflection.
0: 	 * @param current - flag to pass to Statement.getMoreResults(current)
0: 	 * @return true if there are more results.
0: 	 * @throws SQLException
0: 	 * @see java.sql.Statemen#getMoreResults
0: 	 *
0: 	 */
0: 	protected boolean getMoreResults(int current) throws SQLException
0: 	{
0: 		boolean retVal = false;
0: 		Class[] intPARAM = {Integer.TYPE};
0: 		Object[] args = {new Integer(current)};
0: 		try {
0: 			Method sh = getPreparedStatement().getClass().getMethod("getMoreResults",intPARAM);
0: 			Boolean retObj = (Boolean) sh.invoke(getPreparedStatement(),args);
0: 			retVal = retObj.booleanValue();
0: 		}
0: 		catch (Exception e)
0: 		{
0: 			handleReflectionException(e);
0: 		}
0: 		return retVal;
0: 	}
1: 
0: 	/**
0: 	 * Use reflection to retrieve SQL Text for EmbedPreparedStatement  
0: 	 * or BrokeredPreparedStatement.
0: 	 * @return SQL text
0: 	 */
0: 	private String getSQLText() 
0: 	{
0: 	   String retVal = null;
0: 		Class[] emptyPARAM = {};
0: 		Object[] args = null;
0: 		try {
0: 			Method sh = getPreparedStatement().getClass().getMethod("getSQLText",emptyPARAM);
0: 			retVal = (String) sh.invoke(getPreparedStatement(),args);
0: 		}
0: 		catch (Exception e)
0: 		{
0: 			//  do nothing we will just return a null string
0: 		}
0: 		return retVal;
1: 
0: 	}
1: 
0: 	/** helper method to handle exceptions generated by methods invoked 
0: 	 * through  reflection.
0: 	 * @param e - exception thrown
0: 	 * @throws SQLException - actual exception that occurred
0: 	 */
0: 	private void handleReflectionException(Exception e) throws SQLException
0: 	{
0: 		if  (e instanceof InvocationTargetException) 
0: 		{
0: 			Throwable t = ((InvocationTargetException) e).getTargetException();
1: 			
0: 			if (t  instanceof SQLException)
0: 			{
0: 				throw (SQLException) t;
0: 			}
0: 			else
0: 				throw Util.javaException(t);
0: 		}
0: 		else
0: 			// invoke can throw IllegalAccessException or 
0: 			// IllegalArgumentException, but these should not 
0: 			// occur from this code. Just in case we will throw it
0: 			throw Util.javaException(e);
1: 		
0: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f9a0689
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * If this changes, we need to re-send result set metadata to client, since
1:      * a change indicates the engine has recompiled the prepared statement.
0:      */
1:     long versionCounter;
1: 
0:     /**
0:      * Saved value returned from {@link DRDAConnThread#from
0:      * parsePRPSQLSTT}. Used to determine if the statment is such that we may
1:      * need to re-send metadata at execute time, see {@link #versionCounter}.
0:      */
1:     int sqldaType;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         versionCounter = ((EnginePreparedStatement)ps).getVersionCounter();
1: 
0:         return ps;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
0: 				withHoldCursor = ResultSet.CLOSE_CURSORS_AT_COMMIT;
0: 				withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
0: 			withHoldCursor = ResultSet.HOLD_CURSORS_OVER_COMMIT;
commit:a0118e1
/////////////////////////////////////////////////////////////////////////
0: 		}while (isCallable && getMoreResults(Statement.KEEP_CURRENT_RESULT));
commit:efb1bd2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	{		
/////////////////////////////////////////////////////////////////////////
0: 	 *  prepare a statement using Connection.prepareStatement.
0:      *  
/////////////////////////////////////////////////////////////////////////
commit:4e3b1b6
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineStatement;
/////////////////////////////////////////////////////////////////////////
0: 	 *  get resultSetHoldability.
0: 		Statement rsstmt;
1:         
0:         int holdValue = 
0:             ((EngineStatement) rsstmt).getResultSetHoldability();
1: 
0: 	 *  get resultSetHoldability.
0: 	int getResultSetHoldability(ResultSet rs) throws SQLException
0: 		Statement rsstmt;
1:         
0:         int holdValue = 
0:             ((EngineStatement) rsstmt).getResultSetHoldability();
1: 
/////////////////////////////////////////////////////////////////////////
0: 	private boolean getMoreResults(int current) throws SQLException
0: 	{       
0:         return
0:             ((EngineStatement) getPreparedStatement()).getMoreResults(current);
commit:fdfc981
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineConnection;
/////////////////////////////////////////////////////////////////////////
0: 	int withHoldCursor = -1;	 // hold cursor after commit attribute.
/////////////////////////////////////////////////////////////////////////
0: 		ps = prepareStatementJDBC3(sqlStmt, scrollType, concurType, 
/////////////////////////////////////////////////////////////////////////
1:         
0: 		{       
0: 		{            
/////////////////////////////////////////////////////////////////////////
0: 	 *  prepare a statement using EngineConnection.prepareStatement
0:      *  so that server can run on jdk131 and still pass holdability.  
/////////////////////////////////////////////////////////////////////////
0:         EngineConnection conn = database.getConnection();
0:         if (withHoldCursor == -1) {
0:             // Holdability not explictly set, let the
0:             // connection provide the default.
0:             return conn.prepareStatement(sqlStmt,
0:                     scrollType, concurType);
0:         }
1:         
0:         // Holdability explictly set. 
0:         return conn.prepareStatement(sqlStmt,
0:                 scrollType, concurType, withHoldCursor);
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
0: 	DRDAStatement (Database database) 
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.DRDAStatement
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.lang.reflect.*;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
0: import java.sql.CallableStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.SQLException;
1: 
1: import java.util.ArrayList;
0: import java.util.StringTokenizer;
0: import java.util.Vector;
0: import java.util.Enumeration;
1: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.EmbedResultSet;
0: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
0: import org.apache.derby.impl.jdbc.EmbedCallableStatement;
0: import org.apache.derby.impl.jdbc.EmbedParameterSetMetaData;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import java.math.BigInteger;
0: import java.io.UnsupportedEncodingException;
0: import java.util.Hashtable;
1: 
0: /**
0: 	DRDAStatement stores information about the statement being executed
0: */
1: class DRDAStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
1: 
1: 
0: 	protected String typDefNam;		//TYPDEFNAM for this statement
0: 	protected int byteOrder;		//deduced from typDefNam, save String comparisons
0: 	protected int ccsidSBC;			//CCSID for single byte characters
0: 	protected int ccsidDBC;			//CCSID for double byte characters
0: 	protected int ccsidMBC;			//CCSID for mixed byte characters
0: 	protected String ccsidSBCEncoding;	//Java encoding for CCSIDSBC
0: 	protected String ccsidDBCEncoding;	//Java encoding for CCSIDDBC
0: 	protected String ccsidMBCEncoding;	//Java encoding for CCSIDMBC
1: 
0: 	protected Database database;		// Database this statement is created for
0: 	private   String pkgnamcsn;         // Package name/section # and  consistency token
0: 	protected String pkgcnstknStr;       // Consistency token for the first result set
0:  	protected String pkgid;              // package id
0:  	protected String sectionNumber;      // section number
0: 	protected int withHoldCursor = -1;	 // hold cursor after commit attribute.
0: 	protected int isolationLevel;         //JCC isolation level for Statement
0: 	protected String cursorName;
0: 	protected int scrollType;			// Sensitive or Insensitive scroll attribute
0: 	protected int concurType;			// Concurency type
0: 	protected long rowCount;			// Number of rows we have processed
0: 	protected byte [] rslsetflg;		// Result Set Flags
0: 	protected int maxrslcnt;			// Maximum Result set count
0: 	protected PreparedStatement ps;     // Prepared statement
0: 	protected boolean isCall;
0: 	protected String procName;			// callable statement's method name
0: 	private   int[] outputTypes;		// jdbc type for output parameter or NOT_OUTPUT_PARAM
0: 	                                    // if not an output parameter.
0: 	protected static int NOT_OUTPUT_PARAM = -100000;
0: 	protected boolean outputExpected;	// expect output from a callable statement
0: 	private Statement stmt;				// SQL statement
1: 
1: 
0: 	private DRDAResultSet currentDrdaRs;  // Current ResultSet
0: 	private Hashtable resultSetTable;     // Hashtable with resultsets            
0: 	private ArrayList resultSetKeyList;  // ordered list of hash keys
0: 	private int numResultSets = 0;  
1: 
0: 	// State for parameter data
0: 	protected  Vector cliParamDrdaTypes = new Vector();
0: 	protected Vector cliParamLens = new Vector();
0: 	protected ArrayList cliParamExtPositions = null;
1: 
0: 	// Query options  sent on EXCSQLSTT
0: 	// These the default for ResultSets created for this statement.
0: 	// These can be overriden by OPNQRY or CNTQRY,
0: 	protected int nbrrow;			// number of fetch or insert rows
0: 	protected int qryrowset;			// Query row set
0: 	protected int blksize;				// Query block size
0: 	protected int maxblkext;			// Maximum number of extra blocks
0: 	protected int outovropt;			// Output Override option
0: 	protected int qryclsimp;            // Implicit Query Close Setting
0: 	protected boolean qryrfrtbl;		// Query refresh answer set table
0: 	private int qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;   // Protocol type
1: 	
1: 	
1: 
0: 	boolean needsToSendParamData = false;
0: 	boolean explicitlyPrepared = false;    //Prepared with PRPSQLSTT (reusable) 
1: 
0: 	// constructor
0: 	/**
0: 	 * DRDAStatement constructor
0: 	 *
0: 	 * @param database
0: 	 * 
0: 	 */
0: 	protected DRDAStatement (Database database) 
0: 	{
0: 		this.database = database;
0: 		setTypDefValues();
0: 		this.currentDrdaRs = new DRDAResultSet();
0: 	}
1: 
0: 	/**
0: 	 * set TypDef values
0: 	 *
0: 	 */
0: 	protected void setTypDefValues()
0: 	{
0: 		// initialize statement values to current database values
0: 		this.typDefNam = database.typDefNam;
0: 		this.byteOrder = database.byteOrder;
0: 		this.ccsidSBC = database.ccsidSBC;
0: 		this.ccsidDBC = database.ccsidDBC;
0: 		this.ccsidMBC = database.ccsidMBC;
0: 		this.ccsidSBCEncoding = database.ccsidSBCEncoding;
0: 		this.ccsidDBCEncoding = database.ccsidDBCEncoding;
0: 		this.ccsidMBCEncoding = database.ccsidMBCEncoding;
0: 	}
0: 	/**
0: 	 * Set database
0: 	 *
0: 	 * @param database
0: 	 */
0: 	protected void setDatabase(Database database)
0: 	{
0: 		this.database = database;
0: 		setTypDefValues();
0: 	}
0: 	/**
0: 	 * Set statement
0: 	 *
0: 	 * @param conn	Connection
0: 	 * @exception SQLException
0: 	 */
0: 	protected void setStatement(Connection conn)
0: 		throws SQLException
0: 	{
0: 		stmt = conn.createStatement();
0: 		//beetle 3849 -  see  prepareStatement for details
0: 		if (cursorName != null)
0: 			stmt.setCursorName(cursorName);
0: 	}
0: 	/**
0: 	 * Get the statement
0: 	 *
0: 	 * @return statement
0: 	 * @exception SQLException
0: 	 */
0: 	protected Statement getStatement() 
0: 		throws SQLException
0: 	{
0: 		return stmt;
0: 	}
1: 
0: 	/**Set resultSet defaults to match 
0: 	 * the statement defaults sent on EXCSQLSTT
0: 	 * This might be overridden on OPNQRY or CNTQRY
0: 	 **/
1: 
0: 	protected void setRsDefaultOptions(DRDAResultSet drs)
0: 	{
0: 		drs.nbrrow = nbrrow;
0:  		drs.qryrowset = qryrowset;
0:  		drs.blksize = blksize;
0:  		drs.maxblkext = maxblkext;
0:  		drs.outovropt = outovropt;
0:  		drs.rslsetflg = rslsetflg;
0: 		drs.scrollType = scrollType;
0: 		drs.concurType = concurType;
0: 		drs.setQryprctyp(qryprctyp);
0: 		drs.qryrowset = qryrowset;
0: 	}
1: 
0: 	/**
0: 	 * Set result set options to default for statement
0: 	 */
0: 	protected void setRsDefaultOptions()
0: 	{
0: 		setRsDefaultOptions(currentDrdaRs);
0: 	}
1: 
0: 	/**
0: 	 * Get the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected ArrayList getExtDtaObjects()
0: 	{
0: 		return currentDrdaRs.getExtDtaObjects();
0: 	}
1: 
0: 	/**
0: 	 * Set the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected void  setExtDtaObjects(ArrayList a)
0: 	{
0: 		currentDrdaRs.setExtDtaObjects(a);
0: 	}
1: 	
0:    	/**
0: 	 * Add extDtaObject
0: 	 * @param o - object to  add
0: 	 * @param jdbcIndex - jdbc index for parameter
0: 	 */
0: 	protected void  addExtDtaObject (Object o, int jdbcIndex )
0: 	{
0: 		currentDrdaRs.addExtDtaObject(o,jdbcIndex);
0: 	}
1: 
1: 	
0: 	/**
0: 	 * Clear externalized lob objects in current result set
0: 	 */
0: 	protected void  clearExtDtaObjects ()
0: 	{
0: 		currentDrdaRs.clearExtDtaObjects();
0: 	}
1: 
1: 
1: 	/*
0: 	 * Is lob object nullable
0: 	 * @param index - offset starting with 0
0: 	 * @return true if object is nullable
0: 	 */
0: 	protected boolean isExtDtaValueNullable(int index)
0: 	{
0: 		return currentDrdaRs.isExtDtaValueNullable(index);
0: 	}
1: 	
1: 
0: 	/**
0: 	 * Set query options sent on OPNQRY
0: 	 */
0: 	protected void setOPNQRYOptions(int blksize, int qryblkctl,
0: 								  int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
0: 	{
0: 		currentDrdaRs.blksize = blksize;
0: 		currentDrdaRs.setQryprctyp(qryblkctl);
0: 		currentDrdaRs.maxblkext = maxblkext;
0: 		currentDrdaRs.outovropt = outovropt;
0: 		currentDrdaRs.qryrowset = qryrowset;
0: 		currentDrdaRs.qryclsimp = qryclsimp;
0: 	}
1: 
1: 	/*
0: 	 * Set query options sent on CNTQRY
0: 	 */
0: 	protected void setQueryOptions(int blksize, boolean qryrelscr, 
0: 									long qryrownbr,
0: 									boolean qryfrtbl,int nbrrow,int maxblkext,
0: 									int qryscrorn, boolean qryrowsns,
0: 									boolean qryblkrst,
0: 									boolean qryrtndta,int qryrowset,
0: 									int rtnextdta)
0: 	{
0: 		currentDrdaRs.blksize = blksize;
0: 		currentDrdaRs.qryrelscr = qryrelscr;
0: 		currentDrdaRs.qryrownbr = qryrownbr;
0: 		currentDrdaRs.qryrfrtbl = qryrfrtbl;
0: 		currentDrdaRs.nbrrow = nbrrow;
0: 		currentDrdaRs.maxblkext = maxblkext;
0: 		currentDrdaRs.qryscrorn = qryscrorn;
0: 		currentDrdaRs.qryrowsns = qryrowsns;
0: 		currentDrdaRs.qryblkrst = qryblkrst;
0: 		currentDrdaRs.qryrtndta = qryrtndta;
0: 		currentDrdaRs.qryrowset = qryrowset;
0: 		currentDrdaRs.rtnextdta = rtnextdta;
0: 	}
1: 
1: 
1: 
0: 	protected void setQryprctyp(int qryprctyp)
0: 	{
0: 		this.qryprctyp = qryprctyp;
0: 		currentDrdaRs.setQryprctyp(qryprctyp);
0: 	}
1: 
0: 	protected int  getQryprctyp()
0: 		throws SQLException
0: 	{
0: 		return currentDrdaRs.getQryprctyp();
0: 	}
1: 
0: 	protected void setQryrownbr(long qryrownbr)
0: 	{
0: 		currentDrdaRs.qryrownbr = qryrownbr;
0: 	}
1: 
0: 	protected long  getQryrownbr()
0: 	{
0: 		return currentDrdaRs.qryrownbr;
0: 	}
1: 
1: 
0: 	protected int  getQryrowset()
0: 	{
0: 		return currentDrdaRs.qryrowset;
0: 	}
1: 
1: 	
0: 	protected int getBlksize()
0: 	{
0: 		return currentDrdaRs.blksize;
0: 	}
1: 
0: 	protected void setQryrtndta(boolean qryrtndta)
0: 	{
0: 		currentDrdaRs.qryrtndta = qryrtndta;
0: 	}
1: 
0: 	protected boolean  getQryrtndta()
0: 	{
0: 		return currentDrdaRs.qryrtndta;
0: 	}
1: 
1: 
0: 	protected void setQryscrorn(int qryscrorn)
0: 	{
0: 		currentDrdaRs.qryscrorn = qryscrorn;
0: 	}
1: 
0: 	protected int  getQryscrorn()
0: 	{
0: 		return currentDrdaRs.qryscrorn;
0: 	}
1: 
0: 	protected void getQryclsimp(int value)
0: 	{
0: 		currentDrdaRs.qryclsimp = value;
0: 	}
1: 
0: 	protected int  getQryclsimp()
0: 	{
0: 		return currentDrdaRs.qryclsimp;
0: 	}
1: 
0: 	protected void setScrollType(int scrollType)
0: 	{
0: 		currentDrdaRs.scrollType = scrollType;
0: 	}
1: 
0: 	protected int  getScrollType()
0: 	{
0: 		return currentDrdaRs.scrollType;
0: 	}
1: 
1: 
0: 	protected void setConcurType(int scrollType)
0: 	{
0: 		currentDrdaRs.concurType = scrollType;
0: 	}
1: 
0: 	protected int  getConcurType()
0: 	{
0: 		return currentDrdaRs.concurType;
0: 	}
1: 
0: 	protected void 	setOutovr_drdaType(int[] outovr_drdaType) 
0: 	{
0: 	   currentDrdaRs.outovr_drdaType = outovr_drdaType;
0: 	}
1: 
1: 
0: 	protected int[] 	getOutovr_drdaType() 
0: 	{
0: 		return currentDrdaRs.outovr_drdaType;
0: 	}
1: 	
0: 	protected boolean hasdata()
0: 	{
0: 		return currentDrdaRs.hasdata;
0: 	}
1: 	
0: 	protected void  setHasdata(boolean hasdata)
0: 	{
0: 		currentDrdaRs.hasdata = hasdata;
0: 	}
1: 
0: 	/**
0: 	 * Initialize for reuse
0: 	 */
0: 	protected void initialize() 
0: 	{
0: 		setTypDefValues();
0: 	}
1: 
1: 
0: 	protected PreparedStatement explicitPrepare(String sqlStmt) throws SQLException
0: 	{
0: 		explicitlyPrepared = true;
0: 		return prepare(sqlStmt);
0: 	}
1: 
0: 	protected boolean wasExplicitlyPrepared()
0: 	{
0: 		return explicitlyPrepared;
0: 	}
1: 
0: 	/**
0: 	 * Create a prepared statement
0: 	 *
0: 	 * @param sqlStmt - SQL statement
0: 	 *
0: 	 * @exception SQLException
0: 	 */
0: 	protected PreparedStatement prepare(String sqlStmt)   throws SQLException
0: 	{
0: 		// save current prepare iso level
0: 		int saveIsolationLevel = -1;
0: 		boolean isolationSet = false;
0: 		if (pkgnamcsn !=null)
0: 		{
0: 			saveIsolationLevel = database.getPrepareIsolation();
0: 			database.setPrepareIsolation(isolationLevel);
0: 			isolationSet = true;
0: 		}
1: 		
0: 		if (isCallableSQL(sqlStmt))
0: 		{
0: 			isCall = true;
0: 			ps = database.getConnection().prepareCall(sqlStmt);
0: 			setupCallableStatementParams((CallableStatement)ps);
0: 			if (isolationSet)
0: 				database.setPrepareIsolation(saveIsolationLevel);
0: 			return ps;
0: 		}
0: 		parsePkgidToFindHoldability();
0: 		if (withHoldCursor == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT) {
0: 			if (JVMInfo.JDK_ID == 2) {//need to use reflection for holdability for jdk 1.3
0: 				//prepareStatement takes 4 parameters
0: 				Class[] PREP_STMT_PARAM = { String.class, Integer.TYPE, Integer.TYPE, Integer.TYPE };
0: 				Object[] PREP_STMT_ARG = { sqlStmt, new Integer(scrollType),
0: 				new Integer(concurType), new Integer(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)};
0: 				try {
0: 					//create a prepared statement with close cursor at commit using reflection.
0: 					Method sh = database.getConnection().getClass().getMethod("prepareStatement", PREP_STMT_PARAM);
0: 					ps = (PreparedStatement) (sh.invoke(database.getConnection(), PREP_STMT_ARG));
0: 				} catch (InvocationTargetException itex) {
0: 					Throwable e = itex.getTargetException();
0: 					//prepareStatement can only throw SQLExcepton
0: 					if (e instanceof SQLException)
0: 					{
0: 						throw (SQLException) e;
0: 					}
0: 					else
0: 						throw Util.javaException(e);
0: 				}
0: 				catch (Exception e) {
0: 					// invoke can throw IllegalAccessException or 
0: 					// IllegalArgumentException, but these should not 
0: 					// occur from this code. Just in case we will throw it
0: 					throw Util.javaException(e);
0: 				}
0: 			} else if (JVMInfo.JDK_ID >= 4) 
0: 				ps = ((EmbedConnection)(database.getConnection())).prepareStatement(sqlStmt, scrollType, concurType, withHoldCursor);
0: 			else //no holdability change support for jdk 12 and less
0: 				ps = database.getConnection().prepareStatement(sqlStmt);
0: 		} else if (scrollType != 0)
0: 			ps = database.getConnection().prepareStatement(sqlStmt, scrollType, concurType);
0: 		else
0: 			ps = database.getConnection().prepareStatement(sqlStmt);
1:       
0: 		// beetle 3849  -  Need to change the cursor name to what
0: 		// JCC thinks it will be, since there is no way in the 
0: 		// protocol to communicate the actual cursor name.  JCC keeps 
0: 		// a mapping from the client cursor names to the DB2 style cursor names
0: 		if (cursorName != null)//cursorName not null means we are dealing with dynamic pacakges
0: 			ps.setCursorName(cursorName);
0: 		if (isolationSet)
0: 			database.setPrepareIsolation(saveIsolationLevel);
0: 				return ps;
0: 	}
1: 
0: 	/**
0: 	 * Get prepared statement
0: 	 *
0: 	 * @return prepared statement
0: 	 */
0: 	protected PreparedStatement getPreparedStatement() 
0: 	{
0: 		return ps;
0: 	}
1: 
1: 
0: 	/**
0: 	 * Executes the prepared statement and populates the resultSetTable.
0: 	 * Access to the various resultSets is then possible by using
0: 	 * setCurrentDrdaResultSet(String pkgnamcsn)  to set the current
0: 	 * resultSet and then calling getResultSet() or the other access 
0: 	 * methods to get resultset data.
0: 	 *
0: 	 * @ return true if the execution has resultSets
0: 	 */
0: 	protected boolean execute() throws SQLException
0: 	{
0: 		boolean hasResultSet = ps.execute();
1: 
0: 		// java.sql.Statement says any result sets that are opened
0: 		// when the statement is re-executed must be closed; this
0: 		// is handled by the call to "ps.execute()" above--but we
0: 		// also have to reset our 'numResultSets' counter, since
0: 		// all previously opened result sets are now invalid.
0: 		numResultSets = 0;
1: 
0: 		ResultSet rs = null;
0: 		boolean isCallable = (ps instanceof java.sql.CallableStatement);
0: 		if (isCallable)
0: 			needsToSendParamData = true;
1: 
0: 		do {
0: 			rs = ps.getResultSet();
0: 			if (rs !=null)
0: 			{
0: 				addResultSet(rs);
0: 				hasResultSet = true;
0: 			}
0: 			// For normal selects we are done, but procedures might
0: 			// have more resultSets
0: 		}while (isCallable && ((EmbedPreparedStatement) ps).getMoreResults(JDBC30Translation.KEEP_CURRENT_RESULT));
1: 
0: 		return hasResultSet;
1: 
0: 	}
1: 	
0: 	/**
0: 	 * clear out type data for parameters.
0: 	 * Unfortunately we currently overload the resultSet type info
0: 	 * rsDRDATypes et al with parameter info.
0: 	 * RESOLVE: Need to separate this
0: 	 */
1:    protected void finishParams()
0: 	{
0: 		needsToSendParamData = false;
0: 	}
1: 
0: 	/**
0: 	 * Set the pkgid sec num for this statement and the 
0: 	 * consistency token that will be used for the first resultSet.
0: 	 * For dyamic packages The package name is encoded as follows
0: 	 * SYS(S/L)(H/N)xyy 
0: 	 * where 'S' represents Small package and 'L' large 
0: 	 *                      (ignored by cloudscape) 
0: 	 * Where 'H' represents WITH HOLD, and 'N' represents NO WITH HOLD. 
0: 	 *                      (May be overridden by SQLATTR for WITH
0: 	 *                       HOLD")
0: 	 *
0: 	 * Where 'www' is the package iteration (ignored by cloudcape)
0: 	 * Where 'x' is the isolation level: 0=NC, 1=UR, 2=CS, 3=RS, 4=RR 
0: 	 * Where 'yy' is the package iteration 00 through FF 
0: 	 * Where 'zz' is unique for each platform
0: 	 * Happilly, these values correspond precisely to the internal cloudscape
0: 	 * isolation levels  in ExecutionContext.java
0: 	 * x   Isolation Level                                           
0: 	 * --  ---------------------
0: 	 * 0   NC  (java.sql.Connection.TRANSACTION_NONE)
0: 	 * 1   UR  (java.sql.Connection.TRANACTION_READ_UNCOMMITTED)
0: 	 * 2   CS  (java.sql.Connection.TRANSACTION_READ_COMMITTED)
0: 	 * 3   RS  (java.sql.Connection.TRANSACTION_REPEATABLE_READ)
0: 	 * 4   RR  (java.sql.Connection.TRANSACTION_SERIALIZABLE)
0: 	 * 
0: 	 * static packages have preset isolation levels 
0: 	 * (see getStaticPackageIsolation)
0: 	 * @param pkgnamcsn  package id section number and token from the client
0: 	 */
0: 	protected void setPkgnamcsn(String pkgnamcsn)
0: 	{
0: 		this.pkgnamcsn =  pkgnamcsn;
0: 		// Store the consistency string for the first ResultSet.
0: 		// this will be used to calculate consistency strings for the 
0: 		// other result sets.
0: 		StringTokenizer st = new StringTokenizer(pkgnamcsn);
0: 		st.nextToken();   // rdbnam (disregard)
0: 		st.nextToken();   // rdbcolid (disregard)
0: 		pkgid = st.nextToken();   // pkgid
1: 
0: 		if (isDynamicPkgid(pkgid))
0: 		{
0: 			isolationLevel = Integer.parseInt(pkgid.substring(5,6));
1: 			
1: 			
1: 			/*
0: 			 *   generate DB2-style cursorname
0: 			 *   example value : SQL_CURSN200C1
0: 			 *   where 
0: 			 *      SQL_CUR is db2 cursor name prefix;
0: 			 *      S - Small package , L -Large package
0: 			 *      N - normal cursor, H - hold cursor 
0: 			 *      200 - package id as sent by jcc 
0: 			 *      C - tack-on code for cursors
0: 			 *      1 - section number sent by jcc		 
0: 			 */
1: 			
1: 			
1: 
0: 			// cursor name
0: 			// trim the SYS off the pkgid so it wont' be in the cursor name
0: 			String shortPkgid = pkgid.substring(pkgid.length() -5 , pkgid.length());
0: 			sectionNumber = st.nextToken() ;
0: 			this.cursorName = "SQL_CUR" +  shortPkgid + "C" + sectionNumber ;
0: 		}
0: 		else // static package
0: 		{
0: 			isolationLevel = getStaticPackageIsolation(pkgid);
0: 		}
1: 
0: 		this.pkgcnstknStr = st.nextToken();
1: 
0: 	}
1: 
1: 
0: 	/**
0: 	 * get the isolation level for a static package.
0: 	 * @param pkgid - Package identifier string (e.g. SYSSTAT)
0: 	 * @return isolation
0: 	 */
0: 	private int getStaticPackageIsolation(String pkgid)
0: 	{
0: 		// SYSSTAT is used for metadata. and is the only static package used
0: 		// for JCC. Other static packages will need to be supported for 
0: 		// CCC. Maybe a static hash table would then be in order.
0: 		if (pkgid.equals("SYSSTAT"))
0: 			return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;
0: 		else
0: 			return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
0: 	}
1: 
0: 	/**
0: 	 * Get pkgnamcsn
0: 	 *
0: 	 * @return pkgnamcsn
0: 	 */
0: 	protected String getPkgnamcsn() 
0: 	{
0: 		return pkgnamcsn;
1: 
0: 	}
0: 	/**
0: 	 * Get result set
0: 	 *
0: 	 * @return result set
0: 	 */
0: 	protected ResultSet getResultSet() 
0: 	{
0: 		return currentDrdaRs.getResultSet();
0: 	}
1: 
1: 	
0: 	/** 
0: 	 * Just get the resultset. Don't set it to current
0: 	 * Assumes resultSet rsnum exists.
0: 	 *
0: 	 * @param rsnum - resultSetNumber starting with 0
0: 	 * @return  The result set in the order it was retrieved
0: 	 *         
0: 	 *          with getMoreResults()
0: 	 **/
0: 	private  ResultSet getResultSet(int rsNum)  
0: 	{
0: 		if (rsNum == 0)
0: 			return currentDrdaRs.getResultSet();
0: 		else
0: 		{
0: 			String key = (String) resultSetKeyList.get(rsNum);
0: 			return ((DRDAResultSet) (resultSetTable.get( key))).getResultSet();
0: 		}
0: 	}
1: 
0: 	/**
0:  	 * Set result set
0: 	 *
0: 	 * @param value
0: 	 */
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		if (currentDrdaRs.getResultSet() == null)
0: 			numResultSets = 1;
0: 		currentDrdaRs.setResultSet(value);
0: 		setRsDefaultOptions(currentDrdaRs);
0: 	}
1: 
0: 	/**
0:  	 * Set currentDrdaResultSet 
0: 	 *
0: 	 * @param rsNum   The result set number starting with 0
0: 	 *                 
0: 	 */
0: 	protected void setCurrentDrdaResultSet(int rsNum)
0: 	{
0: 		String consistToken = getResultSetPkgcnstknStr(rsNum);
0: 		if (currentDrdaRs.pkgcnstknStr == consistToken)
0: 			return;
0: 		currentDrdaRs = getDrdaResultSet(consistToken);
1: 
0: 	}
1: 
0: 	/**
0:  	 * Set currentDrdaResultSet 
0: 	 *
0: 	 * @String pkgnamcsn  The pkgid section number and unique resultset
0: 	 *                    consistency token
0: 	 *                 
0: 	 */
0: 	protected void setCurrentDrdaResultSet(String pkgnamcsn)
0: 	{
0: 		String consistToken = extractPkgcnstknStr(pkgnamcsn);
0: 		DRDAResultSet newDrdaRs = getDrdaResultSet(consistToken);
0: 		if (newDrdaRs != null)
0: 			currentDrdaRs = newDrdaRs;
0: 	}
1: 
1: 
1: 	/*
0: 	 * get DRDAResultSet by consistency token
0: 	 *
0: 	 */
0: 	private DRDAResultSet getDrdaResultSet(String consistToken)
0: 	{
0: 		if ( resultSetTable   == null || 
0: 			 (currentDrdaRs != null &&
0: 			  currentDrdaRs.pkgcnstknStr == consistToken ))
0: 		{
0: 			return currentDrdaRs;
0: 		}
0: 		else
0: 		{
0: 			return (DRDAResultSet) (resultSetTable.get(consistToken));
0: 		}
0: 	}
1: 	
1: 
1: 	/*
0: 	 * get DRDAResultSet by result set number
0: 	 *
0: 	 */
0: 	private DRDAResultSet getDrdaResultSet(int rsNum)
0: 	{
0: 		String consistToken = getResultSetPkgcnstknStr(rsNum);
0: 		return getDrdaResultSet(consistToken);
0: 	}
1: 
1: 
1: 	/*
0: 	 *  get consistency token from pkgnamcsn
0: 	 */
0: 	private String extractPkgcnstknStr(String pkgnamcsn)
0: 	{
0: 		StringTokenizer st = new StringTokenizer(pkgnamcsn);
0: 		st.nextToken();   // rdbnam (disregard)
0: 		st.nextToken();   // rdbcolid (disregard)
0: 		pkgid = st.nextToken();           // pkgid
0: 		sectionNumber = st.nextToken() ;  // secno
0: 		return st.nextToken();
0: 	}
1: 
0: 	/** Add a new resultSet to this statement.
0: 	 * Set as the current result set if  there is not an 
0: 	 * existing current resultset.
0: 	 * @param value - ResultSet to add
0: 	 * @return    Consistency token  for this resultSet
0: 	 *            For a single resultSet that is the same as the statement's 
0: 	 *            For multiple resultSets just the consistency token is changed 
0: 	 */
0: 	protected String  addResultSet(ResultSet value) throws SQLException
0: 	{
1: 
0: 		DRDAResultSet newDrdaRs = null;
1: 
0: 		int rsNum = numResultSets;
0: 		String newRsPkgcnstknStr = calculateResultSetPkgcnstknStr(rsNum);
1: 
0: 		if (rsNum == 0)
0: 			newDrdaRs = currentDrdaRs;
1: 
0: 		else
0: 		{
0: 			newDrdaRs = new DRDAResultSet();
1: 
0: 			// Multiple resultSets we neeed to setup the hash table
0: 			if (resultSetTable == null)
0: 			{
0: 				// If hashtable doesn't exist, create it and store resultSet 0
0: 				// before we store our new resultSet.
0: 				// For just a single resultSet we don't ever create the Hashtable.
0: 				resultSetTable = new Hashtable();
0: 				resultSetTable.put(pkgcnstknStr,currentDrdaRs);
0: 				resultSetKeyList = new ArrayList();
0: 				resultSetKeyList.add(0,pkgcnstknStr);
0: 			}
1: 
0: 			resultSetTable.put(newRsPkgcnstknStr,newDrdaRs);
0: 			resultSetKeyList.add(rsNum, newRsPkgcnstknStr);
0: 		}
1: 
0: 		newDrdaRs.setResultSet(value);
0: 		newDrdaRs.setPkgcnstknStr(newRsPkgcnstknStr);
0: 		setRsDefaultOptions(newDrdaRs);
0: 		newDrdaRs.suspend();
0: 		numResultSets++;
0: 		return newRsPkgcnstknStr;
0: 	}
1: 
0: 	/**
0: 	 *
0: 	 * @return 	number of result sets
0: 	 */
0: 	protected int getNumResultSets()
0: 	{
0: 		return numResultSets;
0: 	}
1: 	
1: 	
0: 	/**
0: 	 * @param rsNum result set starting with 0
0: 	 * @return  consistency token (key) for the result set	 
0: 	 */
0: 	protected String getResultSetPkgcnstknStr(int rsNum)
0: 	{
0: 		if (rsNum == 0)
0: 			return pkgcnstknStr;
0: 		else 
0: 			return (String) resultSetKeyList.get(rsNum);			   
0: 	}
1: 
1: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsDRDATypes(int [] value)
0: 	{
0: 		currentDrdaRs.setRsDRDATypes(value);
0: 	}
1: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes
0: 	 **/
1: 
0: 	protected int[] getRsDRDATypes()
0: 	{
0: 		return currentDrdaRs.getRsDRDATypes();
1: 
0: 	}
1: 
1: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes Lengths
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsLens(int [] value)
0: 	{
0: 		currentDrdaRs.rsLens = value;
1: 
0: 	}
1: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes Lengths
0: 	 **/
1: 
0: 	protected int[] getRsLens()
0: 	{
0: 		return currentDrdaRs.rsLens;
0: 	}
1: 
0: 	/**
0: 	 *  Close the current resultSet
0: 	 */
0: 	protected void rsClose() throws SQLException
0: 	{
0: 		if (currentDrdaRs.getResultSet() == null) 
0: 			return;
1: 
0: 		currentDrdaRs.close();
0: 		needsToSendParamData = false;		
0: 		numResultSets--;
0: 	}
1: 
0: 	/**
0: 	 * Explicitly close the result set by CLSQRY
0: 	 * needed to check for double close.
0: 	 */
0: 	protected void CLSQRY()
0: 	{
0: 		currentDrdaRs.CLSQRY();
0: 	}
1: 
1: 	/* 
0: 	 * @return whether CLSQRY has been called on the
0: 	 *         current result set.
0: 	 */
0: 	protected boolean wasExplicitlyClosed()
0: 	{
0: 		return currentDrdaRs.wasExplicitlyClosed();
0: 	}
1: 
0: 	/** Clean up statements and resultSet
0: 	 * 
0: 	 */
0: 	protected void close()  throws SQLException
0: 	{
1: 		
0: 		if (ps != null)
0: 			ps.close();
0: 		if (stmt != null)
0: 			stmt.close();
0: 		rsClose();
0: 		resultSetTable = null;
0: 		resultSetKeyList = null;
0: 		numResultSets = 0;
0: 		ps = null;
0: 		stmt = null;
0: 		scrollType = 0;
0: 		concurType = 0;
0: 		withHoldCursor = -1;
0: 		rowCount = 0;
0: 		rslsetflg = null;
0: 		maxrslcnt = 0;
0: 		procName = null;
0: 		outputTypes = null;
0: 		outputExpected = false;
0: 		isCall = false;
0: 		explicitlyPrepared = false;
0: 		cliParamDrdaTypes = null;
0: 		cliParamLens = null;
0: 		cliParamExtPositions = null;
1: 
0: 	}	
1: 
0: 	/**
0: 	 * is Statement closed
0: 	 * @return whether the statement is closed
0: 	 */
0: 	protected boolean rsIsClosed()
0: 	{
0: 		return currentDrdaRs.isClosed();
0: 	}
1: 	
0: 	/**
0: 	 * Set state to SUSPENDED (result set is opened)
0: 	 */
0: 	protected void rsSuspend()
0: 	{
0: 		currentDrdaRs.suspend();
0: 	}
1: 
1: 
0: 	/**
0: 	 * set resultset/out parameter precision
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param precision
0: 	 */
0: 	protected void setRsPrecision(int index, int precision)
0: 	{
0: 		currentDrdaRs.setRsPrecision(index,precision);
0: 	}
1: 
0: 	/**
0: 	 * get resultset /out paramter precision
0: 	 * @param index -starting with 1
0: 	 * @return precision of column
0: 	 */
0: 	protected int getRsPrecision(int index)
0: 	{
0: 		return currentDrdaRs.getRsPrecision(index);
0: 	}
1: 
0: 	/**
0: 	 * set resultset/out parameter scale
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param scale
0: 	 */
0: 	protected void setRsScale(int index, int scale)
0: 	{
0: 		currentDrdaRs.setRsScale(index, scale);
0: 	}
1: 
0: 	/**
0: 	 * get resultset /out paramter scale
0: 	 * @param index -starting with 1
0: 	 * @return scale of column
0: 	 */
0: 	protected int  getRsScale(int index)
0: 	{
0: 		return currentDrdaRs.getRsScale(index);
0: 	}
1: 	
1: 
0: 	/**
0: 	 * set result  DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setRsDRDAType(int index, int type)
0: 	{
0: 		currentDrdaRs.setRsDRDAType(index,type);
1: 		
0: 	}
1: 
1: 	
0: 	/**
0: 	 * get parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getParamDRDAType(int index)
0: 	{
1: 		
0: 		return ((Byte)cliParamDrdaTypes.get(index -1)).intValue();
0: 	}
1: 
1: 
0: 	/**
0: 	 * set param  DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setParamDRDAType(int index, byte type)
0: 	{
0: 		cliParamDrdaTypes.addElement(new Byte(type));
1: 		
0: 	}
0: 	/**
0: 	 * returns drda length of parameter as sent by client.
0: 	 * @param index
0: 	 * @return data length
1: 
0: 	 */
1: 
0: 	protected int getParamLen(int index)
0: 	{
0: 		return ((Integer) cliParamLens.elementAt(index -1)).intValue();
0: 	}
0: 	/**
0: 	 *  get parameter precision or DB2 max (31)
0: 	 *
0: 	 *  @param index parameter index starting with 1
0: 	 *
0: 	 *  @return  precision
0: 	 */
0: 	protected int getParamPrecision(int index) throws SQLException
0: 	{
0: 		if (ps != null && ps instanceof CallableStatement)
0: 		{
0: 			EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement)
0: 											 ps).getEmbedParameterSetMetaData();
0: 			return Math.min(pmeta.getPrecision(index),
0: 							FdocaConstants.NUMERIC_MAX_PRECISION);
1: 
0: 		}
0: 		else 
0: 			return -1;
0: 	}
1: 	
0: 	/**
0: 	 *  get parameter scale or DB2 max (31)
0: 	 *
0: 	 *  @param index parameter index starting with 1
0: 	 *
0: 	 *  @return  scale
0: 	 */
0: 	protected int getParamScale(int index) throws SQLException
0: 	{
0: 		if (ps != null && ps instanceof CallableStatement)
0: 		{
0: 			EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement)
0: 											 ps).getEmbedParameterSetMetaData();
0: 			return Math.min(pmeta.getScale(index),FdocaConstants.NUMERIC_MAX_PRECISION);
0: 		}
0: 		else 
0: 			return -1;
0: 	}
1: 
0: 	/**
0: 	 * save parameter len sent by client
0: 	 * @param index parameter index starting with 1
0: 	 * @param value  length of data value
0: 	 *
0: 	 */
0: 	protected void  setParamLen(int index, int value)
0: 	{
0: 		cliParamLens.add(index -1, new Integer(value));
0: 	}
1: 
0: 	/**
0: 	 * get the number of parameters for this statement
0: 	 * 
0: 	 * @return number of parameters
0: 	 */
0: 	protected int getNumParams()
0: 	{
0: 		if (cliParamDrdaTypes != null)
0: 			return cliParamDrdaTypes.size();
0: 		else
0: 			return 0;
0: 	}
1: 	   
0: 	/** 
0: 	 * get the number of result set columns for the current resultSet
0: 	 * 
0: 	 * @return number of columns
0: 	 */
1: 
0: 	protected int getNumRsCols()
0: 	{
0: 		int[] rsDrdaTypes = currentDrdaRs.getRsDRDATypes();
0: 		if (rsDrdaTypes != null)
0: 			return rsDrdaTypes.length;
0: 		else 
0: 			return 0;
0: 	}
1: 
0: 	/**
0: 	 * get  resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getRsDRDAType(int index)
0: 	{
0: 		return currentDrdaRs.getRsDRDAType(index);
0: 	}
1: 
0: 	/**
0: 	 * get resultset/out parameter DRDALen
0: 	 * @param index starting with 1
0: 	 * 
0: 	 * @return length of drda data
0: 	 */
1: 	 
0: 	protected int getRsLen(int index)
0: 	{
0: 		return currentDrdaRs.getRsLen(index);
0: 	}
1: 
0: 	/**
0: 	 * set resultset column data length
0: 	 * @param index starting with 1
0: 	 * @value length
0: 	 */
0: 	protected void  setRsLen(int index, int value)
0: 	{
0: 		currentDrdaRs.setRsLen(index,value);
0: 	}
1: 
0: 	/**
0: 	 * return whether this is a procedure
0: 	 * 
0: 	 * @return true if procName is not null 
0: 	 * RESOLVE: (should we check for isCall or is this good enough)
0: 	 */ 
0: 	public  boolean isProcedure()
0: 	{
0: 		return (procName != null);
0: 	}
1: 
1: 
0: 	/**
0: 	 * @param rsNum  - result set # starting with 0 
0: 	 */
0: 	public String getResultSetCursorName(int rsNum) throws SQLException
0: 	{
0: 		ResultSet rs = getResultSet(rsNum);
0: 		return rs.getCursorName();			
1: 
0: 	}
1: 
1: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		ResultSet rs = currentDrdaRs.getResultSet();
1: 		
0: 		String s ="";
0: 		if (ps == null) 
0: 			s += indent + ps;
0: 		else
0: 		{
0: 			s += indent + pkgid + sectionNumber ;
0: 			s += "\t" + ((EmbedPreparedStatement) ps).getSQLText();
0: 		}
0: 		return s;
0: 	}
1: 
0: 	/**  For a single result set, just echo the consistency token that the client sent us.
0: 	 * For subsequent resultSets, just subtract the resultset number from
0: 	 * the consistency token and that will differentiate the result sets.
0: 	 * This seems to be what DB2 does
0: 	 * @param rsNum  - result set # starting with 0
0: 	 * 
0: 	 * @return  Consistency token for result set
0: 	 */
1: 
0: 	protected String calculateResultSetPkgcnstknStr(int rsNum)
0: 	{	
0: 		String consistToken = pkgcnstknStr;
1: 
0: 		if (rsNum == 0 || pkgcnstknStr == null)
0: 			return consistToken;
0: 		else
0: 		{
0: 			try {
0: 				BigInteger  consistTokenBi = 
0: 					new BigInteger(consistToken.getBytes(DB2jServerImpl.DEFAULT_ENCODING));
0: 				BigInteger rsNumBi = BigInteger.valueOf(rsNum);
0: 				consistTokenBi = consistTokenBi.subtract(rsNumBi);
0: 				consistToken = new String(consistTokenBi.toByteArray(),DB2jServerImpl.DEFAULT_ENCODING);
0: 			}
0: 			catch (UnsupportedEncodingException e)
0: 			{// Default encoding always supported
0: 			}
0: 		}
0: 		return consistToken;
0: 	}
1: 
0: 	protected boolean isCallableStatement()
0: 	{
0: 		return isCall;
0: 	}
1: 
0: 	private boolean isCallableSQL(String sql)
0: 	{
0: 		java.util.StringTokenizer tokenizer = new java.util.StringTokenizer
0: 			(sql, "\t\n\r\f=? (");
0: 		 String firstToken = tokenizer.nextToken();
0: 		 if (StringUtil.SQLEqualsIgnoreCase(firstToken, 
0: 											"call")) // captures CALL...and ?=CALL...
0: 			 return true;
0: 		 return false;
1: 				 
0: 	}
1: 
0: 	private void setupCallableStatementParams(CallableStatement cs) throws SQLException
0: 	{
0: 		EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement) cs).getEmbedParameterSetMetaData();
0: 		int numElems = pmeta.getParameterCount();
1: 
0: 		for ( int i = 0; i < numElems; i ++)
0: 		{
0: 			boolean outputFlag = false;
1: 			
0: 			int parameterMode = pmeta.getParameterMode(i + 1);
0: 			int parameterType = pmeta.getParameterType(i + 1);
1: 
0: 			switch (parameterMode) {
0: 				case JDBC30Translation.PARAMETER_MODE_IN:
0: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_OUT:
0: 				case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 					outputFlag = true;
0: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 					// It's only unknown if array
0: 					String objectType = pmeta.getParameterClassName(i+1);
0: 					parameterType =
0: 						getOutputParameterTypeFromClassName(objectType);
0: 					if (parameterType  != NOT_OUTPUT_PARAM)
0: 						outputFlag = true;
0: 			}
1: 
0: 			if (outputFlag)
0: 			{
0: 				if (outputTypes == null) //not initialized yet, since previously none output
0: 				{
0: 					outputTypes = new int[numElems];
0: 					for (int j = 0; j < numElems; j++)
0: 						outputTypes[j] = NOT_OUTPUT_PARAM;  //default init value
0: 				}
0: 				// save the output type so we can register when we parse
0: 				// the SQLDTA
0: 				outputTypes[i] = parameterType;
0: 			}
1: 			
0: 		}
0: 	}
1: 
1: 
1: 
0: 	/** 
0: 		Given an object class  name get the paramameter type if the 
0: 		parameter mode is unknown.
1: 		
0: 		Arrays except for byte arrrays are assumed to be output parameters
0: 		TINYINT output parameters are going to be broken because there
0: 		is no way to differentiate them from binary input parameters.
0: 		@param objectName Class name of object being evaluated.
0: 		indicating if this an output parameter
0: 		@return type from java.sql.Types
0: 	**/
1: 	
0: 	protected static int getOutputParameterTypeFromClassName(String
0: 																	objectName)
0: 	{
1: 		
0: 		if (objectName.endsWith("[]"))
0: 		{
0: 					// For byte[] we are going to assume it is input.
0: 			// For TINYINT output params you gotta use 
0: 			//  object Integer[] or use a procedure				   
0: 					if (objectName.equals("byte[]"))
0: 					{
0: 						return NOT_OUTPUT_PARAM;
1: 							
0: 							//isOutParam[offset] = false;
0: 							//return java.sql.Types.VARBINARY;
0: 					}
1: 					
0: 					// Known arrays are output parameters
0: 					// otherwise we pass it's a JAVA_OBJECT
0: 					if (objectName.equals("java.lang.Byte[]"))
0: 						return java.sql.Types.TINYINT;
1: 					
0: 					if (objectName.equals("byte[][]"))
0: 						return java.sql.Types.VARBINARY;
0: 					if (objectName.equals("java.lang.String[]"))
0: 						return java.sql.Types.VARCHAR; 
0: 					if (objectName.equals("int[]") || 
0: 						objectName.equals("java.lang.Integer[]"))
0: 						return java.sql.Types.INTEGER;
0: 					else if (objectName.equals("long[]")
0: 							 || objectName.equals("java.lang.Long[]"))
0: 						return java.sql.Types.BIGINT;
0: 					else if (objectName.equals("java.math.BigDecimal[]"))
0: 						return java.sql.Types.NUMERIC;
0: 					else if (objectName.equals("boolean[]")  || 
0: 							 objectName.equals("java.lang.Boolean[]"))
0: 						return java.sql.Types.BIT;
0: 					else if (objectName.equals("short[]"))
0: 						return java.sql.Types.SMALLINT;
0: 					else if (objectName.equals("float[]") ||
0: 							 objectName.equals("java.lang.Float[]"))
0: 						return java.sql.Types.REAL;
0: 					else if (objectName.equals("double[]") ||
0: 							 objectName.equals("java.lang.Double[]"))
0: 						return java.sql.Types.DOUBLE;
0: 					else if (objectName.equals("java.sql.Date[]"))
0: 						return java.sql.Types.DATE;
0: 					else if (objectName.equals("java.sql.Time[]"))
0: 						return java.sql.Types.TIME;
0: 					else if (objectName.equals("java.sql.Timestamp[]"))
0: 						return java.sql.Types.TIMESTAMP;
0: 		}
0: 		// Not one of the ones we know. This must be a JAVA_OBJECT
0: 		return NOT_OUTPUT_PARAM;
0: 		//isOutParam[offset] = false;				
0: 		//return java.sql.Types.JAVA_OBJECT;
1: 
0: 	}
1: 	
1: 	
0: 	public void registerAllOutParams() throws SQLException
0: 	{
0: 		if (isCall && (outputTypes != null))
0: 			for (int i = 1; i <= outputTypes.length; i ++)
0: 				registerOutParam(i);
1: 		
0: 	}
1: 	
0: 	public void registerOutParam(int paramNum) throws SQLException
0: 	{
0: 		CallableStatement cs;
0: 		if (isOutputParam(paramNum))
0: 		{
0: 			cs = (CallableStatement) ps;
0: 			cs.registerOutParameter(paramNum, getOutputParamType(paramNum));
0: 		}
0: 	}
1: 
0: 	protected boolean hasOutputParams()
0: 	{
0: 		return (outputTypes != null);
0: 	}
1: 
0: 	/**
0: 	 * is  parameter an ouput parameter
0: 	 * @param paramNum parameter number starting with 1.
0: 	 * return true if this is an output parameter.
0: 	 */
0: 	boolean isOutputParam(int paramNum)
0: 	{
0: 		if (outputTypes != null)
0: 			return (outputTypes[paramNum - 1] != NOT_OUTPUT_PARAM);
0: 		return false;
1: 		
0: 	}
0: 	/** 
0: 	 * get type for output parameter. 
0: 	 *
0: 	 * @param paramNum - parameter number starting with 1
0: 	 * @return jdbcType or NOT_OUTPUT_PARAM if this is not an output parameter
0: 	 */
0: 	int getOutputParamType(int paramNum)
0: 	{
0: 		if (outputTypes != null)
0: 			return (outputTypes[ paramNum - 1 ]);
0: 		return NOT_OUTPUT_PARAM;
0: 	}
1: 
0: 	private boolean isDynamicPkgid(String pkgid)
0: 	{
0: 		char size = pkgid.charAt(3);
1: 		
0: 		//  separate attribute used for holdability in 5.1.60
0: 		// this is just for checking that it is a dynamic package
0: 		char holdability = pkgid.charAt(4); 			                                    
0: 		return (pkgid.substring(0,3).equals("SYS") && (size == 'S' ||
0: 													   size == 'L')
0: 				&& (holdability == 'H' || holdability == 'N'));
1: 		
0: 	}
1: 
1:    
0: 	private  void parsePkgidToFindHoldability()
0: 	{
0: 		if (withHoldCursor != -1)
0: 			return;
0: 		//First, check if holdability was passed as a SQL attribute "WITH HOLD" for this prepare. If yes, then withHoldCursor
0: 		//should not get overwritten by holdability from package name and that is why the check for -1
0: 		if (isDynamicPkgid(pkgid))
0: 		{
0: 			if(pkgid.charAt(4) == 'N')
0: 				withHoldCursor = JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
0: 			else  
0: 				withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0: 		}
0: 		else 
0: 		{
0: 			withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
1: 		
0: 		}
0: 	}
0: }
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:27ff169
/////////////////////////////////////////////////////////////////////////
0: 	 *                      (ignored by Derby) 
0: 	 * Where 'www' is the package iteration (ignored by Derby)
0: 	 * Happilly, these values correspond precisely to the internal Derby
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:f0b0870
/////////////////////////////////////////////////////////////////////////
0: 	 * @return true if the execution has resultSets
/////////////////////////////////////////////////////////////////////////
0: 	 * @param rsNum resultSetNumber starting with 0
/////////////////////////////////////////////////////////////////////////
0: 	 * @param pkgnamcsn  The pkgid section number and unique resultset
/////////////////////////////////////////////////////////////////////////
0: 	 * @param value drdaTypes for columns.
/////////////////////////////////////////////////////////////////////////
0: 	 * @param value drdaTypes for columns.
/////////////////////////////////////////////////////////////////////////
0: 	 * @param value length
/////////////////////////////////////////////////////////////////////////
0: 	 *  @param concurType - concurrency type
/////////////////////////////////////////////////////////////////////////
0: 	 * @see java.sql.Statement#getMoreResults
author:David Van Couvering
-------------------------------------------------------------------------------
commit:aadfd42
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EnginePreparedStatement;
0: import org.apache.derby.iapi.jdbc.EngineParameterMetaData;
/////////////////////////////////////////////////////////////////////////
0: 	protected EngineParameterMetaData stmtPmeta; // param metadata
/////////////////////////////////////////////////////////////////////////
0: 		return ps;
/////////////////////////////////////////////////////////////////////////
0: 			EngineParameterMetaData pmeta = 	getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
0: 			EngineParameterMetaData pmeta = 	getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
0: 		EngineParameterMetaData pmeta = 	getParameterMetaData();
/////////////////////////////////////////////////////////////////////////
0: 	 * Retrieve the ParameterMetaData for the prepared statement. 
0:      * To do so, use the engine defined interfaces:
0:      * @see org.apache.derby.iapi.jdbc.EnginePreparedStatement
0:      * @see org.apache.derby.iapi.jdbc.EngineParameterMetaData 
0: 	 * @return EngineParameterMetaData for the prepared statement. 
0: 	protected EngineParameterMetaData getParameterMetaData() throws SQLException
0: 		stmtPmeta = ((EnginePreparedStatement)ps).getEmbedParameterSetMetaData();
0:         
0:         return stmtPmeta;
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5e88312
/////////////////////////////////////////////////////////////////////////
0: 	 * Method to decide whether the ResultSet should be closed
0: 	 * implicitly based on the QRYCLSIMP value sent from the
0: 	 * client. Only forward-only result sets should be implicitly
0: 	 * closed. Some clients do not expect result sets to be closed
0: 	 * implicitly if the protocol is LMTBLKPRC.
0: 	 *
0: 	 * @param lmtblkprcOK <code>true</code> if the client expects
0: 	 * QRYCLSIMP to be respected for the LMTBLKPRC protocol
0: 	 * @exception SQLException
0: 	boolean isRSCloseImplicit(boolean lmtblkprcOK) throws SQLException {
0: 		return
0: 			(currentDrdaRs.qryclsimp == CodePoint.QRYCLSIMP_YES) &&
0: 			!isScrollable() &&
0: 			(lmtblkprcOK ||
0: 			 (currentDrdaRs.getQryprctyp() != CodePoint.LMTBLKPRC));
commit:803c7d0
/////////////////////////////////////////////////////////////////////////
0: 	protected  Vector cliParamDrdaTypes = new Vector();
0: 	protected Vector cliParamLens = new Vector();
0: 	protected ArrayList cliParamExtPositions = null;
/////////////////////////////////////////////////////////////////////////
0: 		cliParamDrdaTypes = null;
0: 		cliParamLens = null;
0: 		cliParamExtPositions = null;
0: 
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
0: 		
0: 		return ((Byte)cliParamDrdaTypes.get(index -1)).intValue();
0: 	 * set param  DRDAType
0: 	protected  void setParamDRDAType(int index, byte type)
0: 	{
0: 		cliParamDrdaTypes.addElement(new Byte(type));
0: 		
0: 	}
0: 	 * @param index
0: 		return ((Integer) cliParamLens.elementAt(index -1)).intValue();
/////////////////////////////////////////////////////////////////////////
0: 		cliParamLens.add(index -1, new Integer(value));
/////////////////////////////////////////////////////////////////////////
0: 	protected int getNumParams()
0: 	{
0: 		if (cliParamDrdaTypes != null)
0: 			return cliParamDrdaTypes.size();
0: 		else
0: 			return 0;
0: 	}
0: 	   
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
commit:375d4a0
/////////////////////////////////////////////////////////////////////////
0:     protected static final class CliParam {
0:         public CliParam(byte drdaType, int drdaLength) { 
0:             this.drdaType = drdaType; 
0:             this.drdaLength = drdaLength; 
0:         }
0:         public byte drdaType;
0:         public int  drdaLength;
0:         public boolean isExt = false;
0:     }
0:     private ArrayList cliParams_ = new ArrayList();
0:     protected final CliParam getCliParam(int i) { 
0:         return (CliParam) cliParams_.get(i); 
0:     }
/////////////////////////////////////////////////////////////////////////
0:         cliParams_.clear();
/////////////////////////////////////////////////////////////////////////
0:      * Add a parameter. 
0:      *
0:      * @param drdaType - parameter type
0:      * @param drdaLength - parameter length
0:      */
0:     protected void addParam(byte drdaType, int drdaLength)
0:     {
0:         cliParams_.add(new CliParam(drdaType, drdaLength));
0:     }
0: 
0:     /**
0:      * Reset the cliParams ArrayList.
0:      *
0:      */
0:     protected void resetParams() { 
0:         cliParams_.clear();
0:     }
0:         
0:     /**
/////////////////////////////////////////////////////////////////////////
0:         return getCliParam(index-1).drdaType;
0:      * set param DRDAType. Assumes that index is a valid index.
0:      protected  void setParamDRDAType(int index, byte type)
0:      {
0:         getCliParam(index-1).drdaType = type;
0:      }
0: 
0:      * @param index - starting with 1
0:         return getCliParam(index-1).drdaLength;
0: 
/////////////////////////////////////////////////////////////////////////
0:         getCliParam(index-1).drdaLength = value;
/////////////////////////////////////////////////////////////////////////
0:      protected int getNumParams()
0:     {
0:         return cliParams_.size();
0:     }
0:     
/////////////////////////////////////////////////////////////////////////
commit:ee2a860
/////////////////////////////////////////////////////////////////////////
0: 	private   Pkgnamcsn pkgnamcsn;		// Package name/section # and  consistency token
0: 	protected ConsistencyToken pkgcnstkn;       // Consistency token for the first result set
0:  	protected int pkgsn;		// section number
/////////////////////////////////////////////////////////////////////////
0: 	protected void setPkgnamcsn(Pkgnamcsn pkgnamcsn)
0: 		pkgid = pkgnamcsn.getPkgid();
/////////////////////////////////////////////////////////////////////////
0: 			pkgsn = pkgnamcsn.getPkgsn();
0: 			this.cursorName = "SQL_CUR" +  shortPkgid + "C" + pkgsn ;
0: 		this.pkgcnstkn = pkgnamcsn.getPkgcnstkn();
/////////////////////////////////////////////////////////////////////////
0: 	protected Pkgnamcsn getPkgnamcsn() 
/////////////////////////////////////////////////////////////////////////
0: 			ConsistencyToken key = (ConsistencyToken) resultSetKeyList.get(rsNum);
/////////////////////////////////////////////////////////////////////////
0: 		ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
0: 		if (currentDrdaRs.pkgcnstkn == consistToken)
/////////////////////////////////////////////////////////////////////////
0: 	protected void setCurrentDrdaResultSet(Pkgnamcsn pkgnamcsn)
0: 		pkgid = pkgnamcsn.getPkgid();
0: 		pkgsn = pkgnamcsn.getPkgsn();
0: 		ConsistencyToken consistToken = pkgnamcsn.getPkgcnstkn();
/////////////////////////////////////////////////////////////////////////
0: 	private DRDAResultSet getDrdaResultSet(ConsistencyToken consistToken)
0: 			  currentDrdaRs.pkgcnstkn == consistToken ))
/////////////////////////////////////////////////////////////////////////
0: 		ConsistencyToken consistToken = getResultSetPkgcnstkn(rsNum);
/////////////////////////////////////////////////////////////////////////
0: 	protected ConsistencyToken addResultSet(ResultSet value, int holdValue) throws SQLException
0: 		ConsistencyToken newRsPkgcnstkn = calculateResultSetPkgcnstkn(rsNum);
/////////////////////////////////////////////////////////////////////////
0: 				resultSetTable.put(pkgcnstkn, currentDrdaRs);
0: 				resultSetKeyList.add(0, pkgcnstkn);
0: 			resultSetTable.put(newRsPkgcnstkn, newDrdaRs);
0: 			resultSetKeyList.add(rsNum, newRsPkgcnstkn);
0: 		newDrdaRs.setPkgcnstkn(newRsPkgcnstkn);
0: 		return newRsPkgcnstkn;
/////////////////////////////////////////////////////////////////////////
0: 	protected ConsistencyToken getResultSetPkgcnstkn(int rsNum)
0: 			return pkgcnstkn;
0: 			return (ConsistencyToken) resultSetKeyList.get(rsNum);			   
/////////////////////////////////////////////////////////////////////////
0: 			s += indent + pkgid + pkgsn ;
/////////////////////////////////////////////////////////////////////////
0: 	protected ConsistencyToken calculateResultSetPkgcnstkn(int rsNum)
0: 		ConsistencyToken consistToken = pkgcnstkn;
0: 		if (rsNum == 0 || pkgcnstkn == null)
0: 			BigInteger consistTokenBi =
0: 				new BigInteger(consistToken.getBytes());
0: 			BigInteger rsNumBi = BigInteger.valueOf(rsNum);
0: 			consistTokenBi = consistTokenBi.subtract(rsNumBi);
0: 			consistToken = new ConsistencyToken(consistTokenBi.toByteArray());
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.lang.reflect.*;
0: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.CallableStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.SQLException;
0: 
0: import java.util.ArrayList;
0: import java.util.StringTokenizer;
0: import java.util.Vector;
0: import java.util.Enumeration;
0: 
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.EmbedResultSet;
0: import org.apache.derby.impl.jdbc.EmbedPreparedStatement;
0: import org.apache.derby.impl.jdbc.EmbedCallableStatement;
0: import org.apache.derby.impl.jdbc.EmbedParameterSetMetaData;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.math.BigInteger;
0: import java.io.UnsupportedEncodingException;
0: import java.util.Hashtable;
0: 
0: /**
0: 	DRDAStatement stores information about the statement being executed
0: */
0: class DRDAStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0: 
0: 
0: 	protected String typDefNam;		//TYPDEFNAM for this statement
0: 	protected int byteOrder;		//deduced from typDefNam, save String comparisons
0: 	protected int ccsidSBC;			//CCSID for single byte characters
0: 	protected int ccsidDBC;			//CCSID for double byte characters
0: 	protected int ccsidMBC;			//CCSID for mixed byte characters
0: 	protected String ccsidSBCEncoding;	//Java encoding for CCSIDSBC
0: 	protected String ccsidDBCEncoding;	//Java encoding for CCSIDDBC
0: 	protected String ccsidMBCEncoding;	//Java encoding for CCSIDMBC
0: 
0: 	protected Database database;		// Database this statement is created for
0: 	private   String pkgnamcsn;         // Package name/section # and  consistency token
0: 	protected String pkgcnstknStr;       // Consistency token for the first result set
0:  	protected String pkgid;              // package id
0:  	protected String sectionNumber;      // section number
0: 	protected int withHoldCursor = -1;	 // hold cursor after commit attribute.
0: 	protected int isolationLevel;         //JCC isolation level for Statement
0: 	protected String cursorName;
0: 	protected int scrollType;			// Sensitive or Insensitive scroll attribute
0: 	protected int concurType;			// Concurency type
0: 	protected long rowCount;			// Number of rows we have processed
0: 	protected byte [] rslsetflg;		// Result Set Flags
0: 	protected int maxrslcnt;			// Maximum Result set count
0: 	protected PreparedStatement ps;     // Prepared statement
0: 	protected boolean isCall;
0: 	protected String procName;			// callable statement's method name
0: 	private   int[] outputTypes;		// jdbc type for output parameter or NOT_OUTPUT_PARAM
0: 	                                    // if not an output parameter.
0: 	protected static int NOT_OUTPUT_PARAM = -100000;
0: 	protected boolean outputExpected;	// expect output from a callable statement
0: 	private Statement stmt;				// SQL statement
0: 
0: 
0: 	private DRDAResultSet currentDrdaRs;  // Current ResultSet
0: 	private Hashtable resultSetTable;     // Hashtable with resultsets            
0: 	private ArrayList resultSetKeyList;  // ordered list of hash keys
0: 	private int numResultSets = 0;  
0: 
0: 	// State for parameter data
0: 	protected  Vector cliParamDrdaTypes = new Vector();
0: 	protected Vector cliParamLens = new Vector();
0: 	protected ArrayList cliParamExtPositions = null;
0: 
0: 	// Query options  sent on EXCSQLSTT
0: 	// These the default for ResultSets created for this statement.
0: 	// These can be overriden by OPNQRY or CNTQRY,
0: 	protected int nbrrow;			// number of fetch or insert rows
0: 	protected int qryrowset;			// Query row set
0: 	protected int blksize;				// Query block size
0: 	protected int maxblkext;			// Maximum number of extra blocks
0: 	protected int outovropt;			// Output Override option
0: 	protected int qryclsimp;            // Implicit Query Close Setting
0: 	protected boolean qryrfrtbl;		// Query refresh answer set table
0: 	private int qryprctyp = CodePoint.QRYBLKCTL_DEFAULT;   // Protocol type
0: 	
0: 	
0: 
0: 	boolean needsToSendParamData = false;
0: 	boolean explicitlyPrepared = false;    //Prepared with PRPSQLSTT (reusable) 
0: 
0: 	// constructor
0: 	/**
0: 	 * DRDAStatement constructor
0: 	 *
0: 	 * @param database
0: 	 * 
0: 	 */
0: 	protected DRDAStatement (Database database) 
0: 	{
0: 		this.database = database;
0: 		setTypDefValues();
0: 		this.currentDrdaRs = new DRDAResultSet();
0: 	}
0: 
0: 	/**
0: 	 * set TypDef values
0: 	 *
0: 	 */
0: 	protected void setTypDefValues()
0: 	{
0: 		// initialize statement values to current database values
0: 		this.typDefNam = database.typDefNam;
0: 		this.byteOrder = database.byteOrder;
0: 		this.ccsidSBC = database.ccsidSBC;
0: 		this.ccsidDBC = database.ccsidDBC;
0: 		this.ccsidMBC = database.ccsidMBC;
0: 		this.ccsidSBCEncoding = database.ccsidSBCEncoding;
0: 		this.ccsidDBCEncoding = database.ccsidDBCEncoding;
0: 		this.ccsidMBCEncoding = database.ccsidMBCEncoding;
0: 	}
0: 	/**
0: 	 * Set database
0: 	 *
0: 	 * @param database
0: 	 */
0: 	protected void setDatabase(Database database)
0: 	{
0: 		this.database = database;
0: 		setTypDefValues();
0: 	}
0: 	/**
0: 	 * Set statement
0: 	 *
0: 	 * @param conn	Connection
0: 	 * @exception SQLException
0: 	 */
0: 	protected void setStatement(Connection conn)
0: 		throws SQLException
0: 	{
0: 		stmt = conn.createStatement();
0: 		//beetle 3849 -  see  prepareStatement for details
0: 		if (cursorName != null)
0: 			stmt.setCursorName(cursorName);
0: 	}
0: 	/**
0: 	 * Get the statement
0: 	 *
0: 	 * @return statement
0: 	 * @exception SQLException
0: 	 */
0: 	protected Statement getStatement() 
0: 		throws SQLException
0: 	{
0: 		return stmt;
0: 	}
0: 
0: 	/**Set resultSet defaults to match 
0: 	 * the statement defaults sent on EXCSQLSTT
0: 	 * This might be overridden on OPNQRY or CNTQRY
0: 	 **/
0: 
0: 	protected void setRsDefaultOptions(DRDAResultSet drs)
0: 	{
0: 		drs.nbrrow = nbrrow;
0:  		drs.qryrowset = qryrowset;
0:  		drs.blksize = blksize;
0:  		drs.maxblkext = maxblkext;
0:  		drs.outovropt = outovropt;
0:  		drs.rslsetflg = rslsetflg;
0: 		drs.scrollType = scrollType;
0: 		drs.concurType = concurType;
0: 		drs.setQryprctyp(qryprctyp);
0: 		drs.qryrowset = qryrowset;
0: 	}
0: 
0: 	/**
0: 	 * Set result set options to default for statement
0: 	 */
0: 	protected void setRsDefaultOptions()
0: 	{
0: 		setRsDefaultOptions(currentDrdaRs);
0: 	}
0: 
0: 	/**
0: 	 * Get the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected ArrayList getExtDtaObjects()
0: 	{
0: 		return currentDrdaRs.getExtDtaObjects();
0: 	}
0: 
0: 	/**
0: 	 * Set the extData Objects
0: 	 *
0: 	 *  @return ArrayList with extdta
0: 	 */
0: 	protected void  setExtDtaObjects(ArrayList a)
0: 	{
0: 		currentDrdaRs.setExtDtaObjects(a);
0: 	}
0: 	
0:    	/**
0: 	 * Add extDtaObject
0: 	 * @param o - object to  add
0: 	 * @param jdbcIndex - jdbc index for parameter
0: 	 */
0: 	protected void  addExtDtaObject (Object o, int jdbcIndex )
0: 	{
0: 		currentDrdaRs.addExtDtaObject(o,jdbcIndex);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Clear externalized lob objects in current result set
0: 	 */
0: 	protected void  clearExtDtaObjects ()
0: 	{
0: 		currentDrdaRs.clearExtDtaObjects();
0: 	}
0: 
0: 
0: 	/*
0: 	 * Is lob object nullable
0: 	 * @param index - offset starting with 0
0: 	 * @return true if object is nullable
0: 	 */
0: 	protected boolean isExtDtaValueNullable(int index)
0: 	{
0: 		return currentDrdaRs.isExtDtaValueNullable(index);
0: 	}
0: 	
0: 
0: 	/**
0: 	 * Set query options sent on OPNQRY
0: 	 */
0: 	protected void setOPNQRYOptions(int blksize, int qryblkctl,
0: 								  int maxblkext, int outovropt,int qryrowset,int qryclsimpl)
0: 	{
0: 		currentDrdaRs.blksize = blksize;
0: 		currentDrdaRs.setQryprctyp(qryblkctl);
0: 		currentDrdaRs.maxblkext = maxblkext;
0: 		currentDrdaRs.outovropt = outovropt;
0: 		currentDrdaRs.qryrowset = qryrowset;
0: 		currentDrdaRs.qryclsimp = qryclsimp;
0: 	}
0: 
0: 	/*
0: 	 * Set query options sent on CNTQRY
0: 	 */
0: 	protected void setQueryOptions(int blksize, boolean qryrelscr, 
0: 									long qryrownbr,
0: 									boolean qryfrtbl,int nbrrow,int maxblkext,
0: 									int qryscrorn, boolean qryrowsns,
0: 									boolean qryblkrst,
0: 									boolean qryrtndta,int qryrowset,
0: 									int rtnextdta)
0: 	{
0: 		currentDrdaRs.blksize = blksize;
0: 		currentDrdaRs.qryrelscr = qryrelscr;
0: 		currentDrdaRs.qryrownbr = qryrownbr;
0: 		currentDrdaRs.qryrfrtbl = qryrfrtbl;
0: 		currentDrdaRs.nbrrow = nbrrow;
0: 		currentDrdaRs.maxblkext = maxblkext;
0: 		currentDrdaRs.qryscrorn = qryscrorn;
0: 		currentDrdaRs.qryrowsns = qryrowsns;
0: 		currentDrdaRs.qryblkrst = qryblkrst;
0: 		currentDrdaRs.qryrtndta = qryrtndta;
0: 		currentDrdaRs.qryrowset = qryrowset;
0: 		currentDrdaRs.rtnextdta = rtnextdta;
0: 	}
0: 
0: 
0: 
0: 	protected void setQryprctyp(int qryprctyp)
0: 	{
0: 		this.qryprctyp = qryprctyp;
0: 		currentDrdaRs.setQryprctyp(qryprctyp);
0: 	}
0: 
0: 	protected int  getQryprctyp()
0: 		throws SQLException
0: 	{
0: 		return currentDrdaRs.getQryprctyp();
0: 	}
0: 
0: 	protected void setQryrownbr(long qryrownbr)
0: 	{
0: 		currentDrdaRs.qryrownbr = qryrownbr;
0: 	}
0: 
0: 	protected long  getQryrownbr()
0: 	{
0: 		return currentDrdaRs.qryrownbr;
0: 	}
0: 
0: 
0: 	protected int  getQryrowset()
0: 	{
0: 		return currentDrdaRs.qryrowset;
0: 	}
0: 
0: 	
0: 	protected int getBlksize()
0: 	{
0: 		return currentDrdaRs.blksize;
0: 	}
0: 
0: 	protected void setQryrtndta(boolean qryrtndta)
0: 	{
0: 		currentDrdaRs.qryrtndta = qryrtndta;
0: 	}
0: 
0: 	protected boolean  getQryrtndta()
0: 	{
0: 		return currentDrdaRs.qryrtndta;
0: 	}
0: 
0: 
0: 	protected void setQryscrorn(int qryscrorn)
0: 	{
0: 		currentDrdaRs.qryscrorn = qryscrorn;
0: 	}
0: 
0: 	protected int  getQryscrorn()
0: 	{
0: 		return currentDrdaRs.qryscrorn;
0: 	}
0: 
0: 	protected void getQryclsimp(int value)
0: 	{
0: 		currentDrdaRs.qryclsimp = value;
0: 	}
0: 
0: 	protected int  getQryclsimp()
0: 	{
0: 		return currentDrdaRs.qryclsimp;
0: 	}
0: 
0: 	protected void setScrollType(int scrollType)
0: 	{
0: 		currentDrdaRs.scrollType = scrollType;
0: 	}
0: 
0: 	protected int  getScrollType()
0: 	{
0: 		return currentDrdaRs.scrollType;
0: 	}
0: 
0: 
0: 	protected void setConcurType(int scrollType)
0: 	{
0: 		currentDrdaRs.concurType = scrollType;
0: 	}
0: 
0: 	protected int  getConcurType()
0: 	{
0: 		return currentDrdaRs.concurType;
0: 	}
0: 
0: 	protected void 	setOutovr_drdaType(int[] outovr_drdaType) 
0: 	{
0: 	   currentDrdaRs.outovr_drdaType = outovr_drdaType;
0: 	}
0: 
0: 
0: 	protected int[] 	getOutovr_drdaType() 
0: 	{
0: 		return currentDrdaRs.outovr_drdaType;
0: 	}
0: 	
0: 	protected boolean hasdata()
0: 	{
0: 		return currentDrdaRs.hasdata;
0: 	}
0: 	
0: 	protected void  setHasdata(boolean hasdata)
0: 	{
0: 		currentDrdaRs.hasdata = hasdata;
0: 	}
0: 
0: 	/**
0: 	 * Initialize for reuse
0: 	 */
0: 	protected void initialize() 
0: 	{
0: 		setTypDefValues();
0: 	}
0: 
0: 
0: 	protected PreparedStatement explicitPrepare(String sqlStmt) throws SQLException
0: 	{
0: 		explicitlyPrepared = true;
0: 		return prepare(sqlStmt);
0: 	}
0: 
0: 	protected boolean wasExplicitlyPrepared()
0: 	{
0: 		return explicitlyPrepared;
0: 	}
0: 
0: 	/**
0: 	 * Create a prepared statement
0: 	 *
0: 	 * @param sqlStmt - SQL statement
0: 	 *
0: 	 * @exception SQLException
0: 	 */
0: 	protected PreparedStatement prepare(String sqlStmt)   throws SQLException
0: 	{
0: 		// save current prepare iso level
0: 		int saveIsolationLevel = -1;
0: 		boolean isolationSet = false;
0: 		if (pkgnamcsn !=null)
0: 		{
0: 			saveIsolationLevel = database.getPrepareIsolation();
0: 			database.setPrepareIsolation(isolationLevel);
0: 			isolationSet = true;
0: 		}
0: 		
0: 		if (isCallableSQL(sqlStmt))
0: 		{
0: 			isCall = true;
0: 			ps = database.getConnection().prepareCall(sqlStmt);
0: 			setupCallableStatementParams((CallableStatement)ps);
0: 			if (isolationSet)
0: 				database.setPrepareIsolation(saveIsolationLevel);
0: 			return ps;
0: 		}
0: 		parsePkgidToFindHoldability();
0: 		if (withHoldCursor == JDBC30Translation.CLOSE_CURSORS_AT_COMMIT) {
0: 			if (JVMInfo.JDK_ID == 2) {//need to use reflection for holdability for jdk 1.3
0: 				//prepareStatement takes 4 parameters
0: 				Class[] PREP_STMT_PARAM = { String.class, Integer.TYPE, Integer.TYPE, Integer.TYPE };
0: 				Object[] PREP_STMT_ARG = { sqlStmt, new Integer(scrollType),
0: 				new Integer(concurType), new Integer(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)};
0: 				try {
0: 					//create a prepared statement with close cursor at commit using reflection.
0: 					Method sh = database.getConnection().getClass().getMethod("prepareStatement", PREP_STMT_PARAM);
0: 					ps = (PreparedStatement) (sh.invoke(database.getConnection(), PREP_STMT_ARG));
0: 				} catch (InvocationTargetException itex) {
0: 					Throwable e = itex.getTargetException();
0: 					//prepareStatement can only throw SQLExcepton
0: 					if (e instanceof SQLException)
0: 					{
0: 						throw (SQLException) e;
0: 					}
0: 					else
0: 						throw Util.javaException(e);
0: 				}
0: 				catch (Exception e) {
0: 					// invoke can throw IllegalAccessException or 
0: 					// IllegalArgumentException, but these should not 
0: 					// occur from this code. Just in case we will throw it
0: 					throw Util.javaException(e);
0: 				}
0: 			} else if (JVMInfo.JDK_ID >= 4) 
0: 				ps = ((EmbedConnection)(database.getConnection())).prepareStatement(sqlStmt, scrollType, concurType, withHoldCursor);
0: 			else //no holdability change support for jdk 12 and less
0: 				ps = database.getConnection().prepareStatement(sqlStmt);
0: 		} else if (scrollType != 0)
0: 			ps = database.getConnection().prepareStatement(sqlStmt, scrollType, concurType);
0: 		else
0: 			ps = database.getConnection().prepareStatement(sqlStmt);
0:       
0: 		// beetle 3849  -  Need to change the cursor name to what
0: 		// JCC thinks it will be, since there is no way in the 
0: 		// protocol to communicate the actual cursor name.  JCC keeps 
0: 		// a mapping from the client cursor names to the DB2 style cursor names
0: 		if (cursorName != null)//cursorName not null means we are dealing with dynamic pacakges
0: 			ps.setCursorName(cursorName);
0: 		if (isolationSet)
0: 			database.setPrepareIsolation(saveIsolationLevel);
0: 				return ps;
0: 	}
0: 
0: 	/**
0: 	 * Get prepared statement
0: 	 *
0: 	 * @return prepared statement
0: 	 */
0: 	protected PreparedStatement getPreparedStatement() 
0: 	{
0: 		return ps;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Executes the prepared statement and populates the resultSetTable.
0: 	 * Access to the various resultSets is then possible by using
0: 	 * setCurrentDrdaResultSet(String pkgnamcsn)  to set the current
0: 	 * resultSet and then calling getResultSet() or the other access 
0: 	 * methods to get resultset data.
0: 	 *
0: 	 * @ return true if the execution has resultSets
0: 	 */
0: 	protected boolean execute() throws SQLException
0: 	{
0: 		boolean hasResultSet = ps.execute();
0: 
0: 		// java.sql.Statement says any result sets that are opened
0: 		// when the statement is re-executed must be closed; this
0: 		// is handled by the call to "ps.execute()" above--but we
0: 		// also have to reset our 'numResultSets' counter, since
0: 		// all previously opened result sets are now invalid.
0: 		numResultSets = 0;
0: 
0: 		ResultSet rs = null;
0: 		boolean isCallable = (ps instanceof java.sql.CallableStatement);
0: 		if (isCallable)
0: 			needsToSendParamData = true;
0: 
0: 		do {
0: 			rs = ps.getResultSet();
0: 			if (rs !=null)
0: 			{
0: 				addResultSet(rs);
0: 				hasResultSet = true;
0: 			}
0: 			// For normal selects we are done, but procedures might
0: 			// have more resultSets
0: 		}while (isCallable && ((EmbedPreparedStatement) ps).getMoreResults(JDBC30Translation.KEEP_CURRENT_RESULT));
0: 
0: 		return hasResultSet;
0: 
0: 	}
0: 	
0: 	/**
0: 	 * clear out type data for parameters.
0: 	 * Unfortunately we currently overload the resultSet type info
0: 	 * rsDRDATypes et al with parameter info.
0: 	 * RESOLVE: Need to separate this
0: 	 */
0:    protected void finishParams()
0: 	{
0: 		needsToSendParamData = false;
0: 	}
0: 
0: 	/**
0: 	 * Set the pkgid sec num for this statement and the 
0: 	 * consistency token that will be used for the first resultSet.
0: 	 * For dyamic packages The package name is encoded as follows
0: 	 * SYS(S/L)(H/N)xyy 
0: 	 * where 'S' represents Small package and 'L' large 
0: 	 *                      (ignored by cloudscape) 
0: 	 * Where 'H' represents WITH HOLD, and 'N' represents NO WITH HOLD. 
0: 	 *                      (May be overridden by SQLATTR for WITH
0: 	 *                       HOLD")
0: 	 *
0: 	 * Where 'www' is the package iteration (ignored by cloudcape)
0: 	 * Where 'x' is the isolation level: 0=NC, 1=UR, 2=CS, 3=RS, 4=RR 
0: 	 * Where 'yy' is the package iteration 00 through FF 
0: 	 * Where 'zz' is unique for each platform
0: 	 * Happilly, these values correspond precisely to the internal cloudscape
0: 	 * isolation levels  in ExecutionContext.java
0: 	 * x   Isolation Level                                           
0: 	 * --  ---------------------
0: 	 * 0   NC  (java.sql.Connection.TRANSACTION_NONE)
0: 	 * 1   UR  (java.sql.Connection.TRANACTION_READ_UNCOMMITTED)
0: 	 * 2   CS  (java.sql.Connection.TRANSACTION_READ_COMMITTED)
0: 	 * 3   RS  (java.sql.Connection.TRANSACTION_REPEATABLE_READ)
0: 	 * 4   RR  (java.sql.Connection.TRANSACTION_SERIALIZABLE)
0: 	 * 
0: 	 * static packages have preset isolation levels 
0: 	 * (see getStaticPackageIsolation)
0: 	 * @param pkgnamcsn  package id section number and token from the client
0: 	 */
0: 	protected void setPkgnamcsn(String pkgnamcsn)
0: 	{
0: 		this.pkgnamcsn =  pkgnamcsn;
0: 		// Store the consistency string for the first ResultSet.
0: 		// this will be used to calculate consistency strings for the 
0: 		// other result sets.
0: 		StringTokenizer st = new StringTokenizer(pkgnamcsn);
0: 		st.nextToken();   // rdbnam (disregard)
0: 		st.nextToken();   // rdbcolid (disregard)
0: 		pkgid = st.nextToken();   // pkgid
0: 
0: 		if (isDynamicPkgid(pkgid))
0: 		{
0: 			isolationLevel = Integer.parseInt(pkgid.substring(5,6));
0: 			
0: 			
0: 			/*
0: 			 *   generate DB2-style cursorname
0: 			 *   example value : SQL_CURSN200C1
0: 			 *   where 
0: 			 *      SQL_CUR is db2 cursor name prefix;
0: 			 *      S - Small package , L -Large package
0: 			 *      N - normal cursor, H - hold cursor 
0: 			 *      200 - package id as sent by jcc 
0: 			 *      C - tack-on code for cursors
0: 			 *      1 - section number sent by jcc		 
0: 			 */
0: 			
0: 			
0: 
0: 			// cursor name
0: 			// trim the SYS off the pkgid so it wont' be in the cursor name
0: 			String shortPkgid = pkgid.substring(pkgid.length() -5 , pkgid.length());
0: 			sectionNumber = st.nextToken() ;
0: 			this.cursorName = "SQL_CUR" +  shortPkgid + "C" + sectionNumber ;
0: 		}
0: 		else // static package
0: 		{
0: 			isolationLevel = getStaticPackageIsolation(pkgid);
0: 		}
0: 
0: 		this.pkgcnstknStr = st.nextToken();
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * get the isolation level for a static package.
0: 	 * @param pkgid - Package identifier string (e.g. SYSSTAT)
0: 	 * @return isolation
0: 	 */
0: 	private int getStaticPackageIsolation(String pkgid)
0: 	{
0: 		// SYSSTAT is used for metadata. and is the only static package used
0: 		// for JCC. Other static packages will need to be supported for 
0: 		// CCC. Maybe a static hash table would then be in order.
0: 		if (pkgid.equals("SYSSTAT"))
0: 			return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;
0: 		else
0: 			return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
0: 	}
0: 
0: 	/**
0: 	 * Get pkgnamcsn
0: 	 *
0: 	 * @return pkgnamcsn
0: 	 */
0: 	protected String getPkgnamcsn() 
0: 	{
0: 		return pkgnamcsn;
0: 
0: 	}
0: 	/**
0: 	 * Get result set
0: 	 *
0: 	 * @return result set
0: 	 */
0: 	protected ResultSet getResultSet() 
0: 	{
0: 		return currentDrdaRs.getResultSet();
0: 	}
0: 
0: 	
0: 	/** 
0: 	 * Just get the resultset. Don't set it to current
0: 	 * Assumes resultSet rsnum exists.
0: 	 *
0: 	 * @param rsnum - resultSetNumber starting with 0
0: 	 * @return  The result set in the order it was retrieved
0: 	 *         
0: 	 *          with getMoreResults()
0: 	 **/
0: 	private  ResultSet getResultSet(int rsNum)  
0: 	{
0: 		if (rsNum == 0)
0: 			return currentDrdaRs.getResultSet();
0: 		else
0: 		{
0: 			String key = (String) resultSetKeyList.get(rsNum);
0: 			return ((DRDAResultSet) (resultSetTable.get( key))).getResultSet();
0: 		}
0: 	}
0: 
0: 	/**
0:  	 * Set result set
0: 	 *
0: 	 * @param value
0: 	 */
0: 	protected void setResultSet(ResultSet value) throws SQLException
0: 	{
0: 		if (currentDrdaRs.getResultSet() == null)
0: 			numResultSets = 1;
0: 		currentDrdaRs.setResultSet(value);
0: 		setRsDefaultOptions(currentDrdaRs);
0: 	}
0: 
0: 	/**
0:  	 * Set currentDrdaResultSet 
0: 	 *
0: 	 * @param rsNum   The result set number starting with 0
0: 	 *                 
0: 	 */
0: 	protected void setCurrentDrdaResultSet(int rsNum)
0: 	{
0: 		String consistToken = getResultSetPkgcnstknStr(rsNum);
0: 		if (currentDrdaRs.pkgcnstknStr == consistToken)
0: 			return;
0: 		currentDrdaRs = getDrdaResultSet(consistToken);
0: 
0: 	}
0: 
0: 	/**
0:  	 * Set currentDrdaResultSet 
0: 	 *
0: 	 * @String pkgnamcsn  The pkgid section number and unique resultset
0: 	 *                    consistency token
0: 	 *                 
0: 	 */
0: 	protected void setCurrentDrdaResultSet(String pkgnamcsn)
0: 	{
0: 		String consistToken = extractPkgcnstknStr(pkgnamcsn);
0: 		DRDAResultSet newDrdaRs = getDrdaResultSet(consistToken);
0: 		if (newDrdaRs != null)
0: 			currentDrdaRs = newDrdaRs;
0: 	}
0: 
0: 
0: 	/*
0: 	 * get DRDAResultSet by consistency token
0: 	 *
0: 	 */
0: 	private DRDAResultSet getDrdaResultSet(String consistToken)
0: 	{
0: 		if ( resultSetTable   == null || 
0: 			 (currentDrdaRs != null &&
0: 			  currentDrdaRs.pkgcnstknStr == consistToken ))
0: 		{
0: 			return currentDrdaRs;
0: 		}
0: 		else
0: 		{
0: 			return (DRDAResultSet) (resultSetTable.get(consistToken));
0: 		}
0: 	}
0: 	
0: 
0: 	/*
0: 	 * get DRDAResultSet by result set number
0: 	 *
0: 	 */
0: 	private DRDAResultSet getDrdaResultSet(int rsNum)
0: 	{
0: 		String consistToken = getResultSetPkgcnstknStr(rsNum);
0: 		return getDrdaResultSet(consistToken);
0: 	}
0: 
0: 
0: 	/*
0: 	 *  get consistency token from pkgnamcsn
0: 	 */
0: 	private String extractPkgcnstknStr(String pkgnamcsn)
0: 	{
0: 		StringTokenizer st = new StringTokenizer(pkgnamcsn);
0: 		st.nextToken();   // rdbnam (disregard)
0: 		st.nextToken();   // rdbcolid (disregard)
0: 		pkgid = st.nextToken();           // pkgid
0: 		sectionNumber = st.nextToken() ;  // secno
0: 		return st.nextToken();
0: 	}
0: 
0: 	/** Add a new resultSet to this statement.
0: 	 * Set as the current result set if  there is not an 
0: 	 * existing current resultset.
0: 	 * @param value - ResultSet to add
0: 	 * @return    Consistency token  for this resultSet
0: 	 *            For a single resultSet that is the same as the statement's 
0: 	 *            For multiple resultSets just the consistency token is changed 
0: 	 */
0: 	protected String  addResultSet(ResultSet value) throws SQLException
0: 	{
0: 
0: 		DRDAResultSet newDrdaRs = null;
0: 
0: 		int rsNum = numResultSets;
0: 		String newRsPkgcnstknStr = calculateResultSetPkgcnstknStr(rsNum);
0: 
0: 		if (rsNum == 0)
0: 			newDrdaRs = currentDrdaRs;
0: 
0: 		else
0: 		{
0: 			newDrdaRs = new DRDAResultSet();
0: 
0: 			// Multiple resultSets we neeed to setup the hash table
0: 			if (resultSetTable == null)
0: 			{
0: 				// If hashtable doesn't exist, create it and store resultSet 0
0: 				// before we store our new resultSet.
0: 				// For just a single resultSet we don't ever create the Hashtable.
0: 				resultSetTable = new Hashtable();
0: 				resultSetTable.put(pkgcnstknStr,currentDrdaRs);
0: 				resultSetKeyList = new ArrayList();
0: 				resultSetKeyList.add(0,pkgcnstknStr);
0: 			}
0: 
0: 			resultSetTable.put(newRsPkgcnstknStr,newDrdaRs);
0: 			resultSetKeyList.add(rsNum, newRsPkgcnstknStr);
0: 		}
0: 
0: 		newDrdaRs.setResultSet(value);
0: 		newDrdaRs.setPkgcnstknStr(newRsPkgcnstknStr);
0: 		setRsDefaultOptions(newDrdaRs);
0: 		newDrdaRs.suspend();
0: 		numResultSets++;
0: 		return newRsPkgcnstknStr;
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 * @return 	number of result sets
0: 	 */
0: 	protected int getNumResultSets()
0: 	{
0: 		return numResultSets;
0: 	}
0: 	
0: 	
0: 	/**
0: 	 * @param rsNum result set starting with 0
0: 	 * @return  consistency token (key) for the result set	 
0: 	 */
0: 	protected String getResultSetPkgcnstknStr(int rsNum)
0: 	{
0: 		if (rsNum == 0)
0: 			return pkgcnstknStr;
0: 		else 
0: 			return (String) resultSetKeyList.get(rsNum);			   
0: 	}
0: 
0: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsDRDATypes(int [] value)
0: 	{
0: 		currentDrdaRs.setRsDRDATypes(value);
0: 	}
0: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes
0: 	 **/
0: 
0: 	protected int[] getRsDRDATypes()
0: 	{
0: 		return currentDrdaRs.getRsDRDATypes();
0: 
0: 	}
0: 
0: 
0: 	/** 
0: 	 * Set ResultSet DRDA DataTypes Lengths
0: 	 * @param drddaTypes for columns.
0: 	 **/
0: 	protected void setRsLens(int [] value)
0: 	{
0: 		currentDrdaRs.rsLens = value;
0: 
0: 	}
0: 
0: 	/**
0: 	 *@return ResultSet DRDA DataTypes Lengths
0: 	 **/
0: 
0: 	protected int[] getRsLens()
0: 	{
0: 		return currentDrdaRs.rsLens;
0: 	}
0: 
0: 	/**
0: 	 *  Close the current resultSet
0: 	 */
0: 	protected void rsClose() throws SQLException
0: 	{
0: 		if (currentDrdaRs.getResultSet() == null) 
0: 			return;
0: 
0: 		currentDrdaRs.close();
0: 		needsToSendParamData = false;		
0: 		numResultSets--;
0: 	}
0: 
0: 	/**
0: 	 * Explicitly close the result set by CLSQRY
0: 	 * needed to check for double close.
0: 	 */
0: 	protected void CLSQRY()
0: 	{
0: 		currentDrdaRs.CLSQRY();
0: 	}
0: 
0: 	/* 
0: 	 * @return whether CLSQRY has been called on the
0: 	 *         current result set.
0: 	 */
0: 	protected boolean wasExplicitlyClosed()
0: 	{
0: 		return currentDrdaRs.wasExplicitlyClosed();
0: 	}
0: 
0: 	/** Clean up statements and resultSet
0: 	 * 
0: 	 */
0: 	protected void close()  throws SQLException
0: 	{
0: 		
0: 		if (ps != null)
0: 			ps.close();
0: 		if (stmt != null)
0: 			stmt.close();
0: 		rsClose();
0: 		resultSetTable = null;
0: 		resultSetKeyList = null;
0: 		numResultSets = 0;
0: 		ps = null;
0: 		stmt = null;
0: 		scrollType = 0;
0: 		concurType = 0;
0: 		withHoldCursor = -1;
0: 		rowCount = 0;
0: 		rslsetflg = null;
0: 		maxrslcnt = 0;
0: 		procName = null;
0: 		outputTypes = null;
0: 		outputExpected = false;
0: 		isCall = false;
0: 		explicitlyPrepared = false;
0: 		cliParamDrdaTypes = null;
0: 		cliParamLens = null;
0: 		cliParamExtPositions = null;
0: 
0: 	}	
0: 
0: 	/**
0: 	 * is Statement closed
0: 	 * @return whether the statement is closed
0: 	 */
0: 	protected boolean rsIsClosed()
0: 	{
0: 		return currentDrdaRs.isClosed();
0: 	}
0: 	
0: 	/**
0: 	 * Set state to SUSPENDED (result set is opened)
0: 	 */
0: 	protected void rsSuspend()
0: 	{
0: 		currentDrdaRs.suspend();
0: 	}
0: 
0: 
0: 	/**
0: 	 * set resultset/out parameter precision
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param precision
0: 	 */
0: 	protected void setRsPrecision(int index, int precision)
0: 	{
0: 		currentDrdaRs.setRsPrecision(index,precision);
0: 	}
0: 
0: 	/**
0: 	 * get resultset /out paramter precision
0: 	 * @param index -starting with 1
0: 	 * @return precision of column
0: 	 */
0: 	protected int getRsPrecision(int index)
0: 	{
0: 		return currentDrdaRs.getRsPrecision(index);
0: 	}
0: 
0: 	/**
0: 	 * set resultset/out parameter scale
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param scale
0: 	 */
0: 	protected void setRsScale(int index, int scale)
0: 	{
0: 		currentDrdaRs.setRsScale(index, scale);
0: 	}
0: 
0: 	/**
0: 	 * get resultset /out paramter scale
0: 	 * @param index -starting with 1
0: 	 * @return scale of column
0: 	 */
0: 	protected int  getRsScale(int index)
0: 	{
0: 		return currentDrdaRs.getRsScale(index);
0: 	}
0: 	
0: 
0: 	/**
0: 	 * set result  DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setRsDRDAType(int index, int type)
0: 	{
0: 		currentDrdaRs.setRsDRDAType(index,type);
0: 		
0: 	}
0: 
0: 	
0: 	/**
0: 	 * get parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getParamDRDAType(int index)
0: 	{
0: 		
0: 		return ((Byte)cliParamDrdaTypes.get(index -1)).intValue();
0: 	}
0: 
0: 
0: 	/**
0: 	 * set param  DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @param type
0: 	 */
0: 	protected  void setParamDRDAType(int index, byte type)
0: 	{
0: 		cliParamDrdaTypes.addElement(new Byte(type));
0: 		
0: 	}
0: 	/**
0: 	 * returns drda length of parameter as sent by client.
0: 	 * @param index
0: 	 * @return data length
0: 
0: 	 */
0: 
0: 	protected int getParamLen(int index)
0: 	{
0: 		return ((Integer) cliParamLens.elementAt(index -1)).intValue();
0: 	}
0: 	/**
0: 	 *  get parameter precision or DB2 max (31)
0: 	 *
0: 	 *  @param index parameter index starting with 1
0: 	 *
0: 	 *  @return  precision
0: 	 */
0: 	protected int getParamPrecision(int index) throws SQLException
0: 	{
0: 		if (ps != null && ps instanceof CallableStatement)
0: 		{
0: 			EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement)
0: 											 ps).getEmbedParameterSetMetaData();
0: 			return Math.min(pmeta.getPrecision(index),
0: 							FdocaConstants.NUMERIC_MAX_PRECISION);
0: 
0: 		}
0: 		else 
0: 			return -1;
0: 	}
0: 	
0: 	/**
0: 	 *  get parameter scale or DB2 max (31)
0: 	 *
0: 	 *  @param index parameter index starting with 1
0: 	 *
0: 	 *  @return  scale
0: 	 */
0: 	protected int getParamScale(int index) throws SQLException
0: 	{
0: 		if (ps != null && ps instanceof CallableStatement)
0: 		{
0: 			EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement)
0: 											 ps).getEmbedParameterSetMetaData();
0: 			return Math.min(pmeta.getScale(index),FdocaConstants.NUMERIC_MAX_PRECISION);
0: 		}
0: 		else 
0: 			return -1;
0: 	}
0: 
0: 	/**
0: 	 * save parameter len sent by client
0: 	 * @param index parameter index starting with 1
0: 	 * @param value  length of data value
0: 	 *
0: 	 */
0: 	protected void  setParamLen(int index, int value)
0: 	{
0: 		cliParamLens.add(index -1, new Integer(value));
0: 	}
0: 
0: 	/**
0: 	 * get the number of parameters for this statement
0: 	 * 
0: 	 * @return number of parameters
0: 	 */
0: 	protected int getNumParams()
0: 	{
0: 		if (cliParamDrdaTypes != null)
0: 			return cliParamDrdaTypes.size();
0: 		else
0: 			return 0;
0: 	}
0: 	   
0: 	/** 
0: 	 * get the number of result set columns for the current resultSet
0: 	 * 
0: 	 * @return number of columns
0: 	 */
0: 
0: 	protected int getNumRsCols()
0: 	{
0: 		int[] rsDrdaTypes = currentDrdaRs.getRsDRDATypes();
0: 		if (rsDrdaTypes != null)
0: 			return rsDrdaTypes.length;
0: 		else 
0: 			return 0;
0: 	}
0: 
0: 	/**
0: 	 * get  resultset/out parameter DRDAType
0: 	 *
0: 	 * @param index - starting with 1
0: 	 * @return  DRDA Type of column
0: 	 */
0: 	protected int getRsDRDAType(int index)
0: 	{
0: 		return currentDrdaRs.getRsDRDAType(index);
0: 	}
0: 
0: 	/**
0: 	 * get resultset/out parameter DRDALen
0: 	 * @param index starting with 1
0: 	 * 
0: 	 * @return length of drda data
0: 	 */
0: 	 
0: 	protected int getRsLen(int index)
0: 	{
0: 		return currentDrdaRs.getRsLen(index);
0: 	}
0: 
0: 	/**
0: 	 * set resultset column data length
0: 	 * @param index starting with 1
0: 	 * @value length
0: 	 */
0: 	protected void  setRsLen(int index, int value)
0: 	{
0: 		currentDrdaRs.setRsLen(index,value);
0: 	}
0: 
0: 	/**
0: 	 * return whether this is a procedure
0: 	 * 
0: 	 * @return true if procName is not null 
0: 	 * RESOLVE: (should we check for isCall or is this good enough)
0: 	 */ 
0: 	public  boolean isProcedure()
0: 	{
0: 		return (procName != null);
0: 	}
0: 
0: 
0: 	/**
0: 	 * @param rsNum  - result set # starting with 0 
0: 	 */
0: 	public String getResultSetCursorName(int rsNum) throws SQLException
0: 	{
0: 		ResultSet rs = getResultSet(rsNum);
0: 		return rs.getCursorName();			
0: 
0: 	}
0: 
0: 
0: 	protected String toDebugString(String indent)
0: 	{
0: 		ResultSet rs = currentDrdaRs.getResultSet();
0: 		
0: 		String s ="";
0: 		if (ps == null) 
0: 			s += indent + ps;
0: 		else
0: 		{
0: 			s += indent + pkgid + sectionNumber ;
0: 			s += "\t" + ((EmbedPreparedStatement) ps).getSQLText();
0: 		}
0: 		return s;
0: 	}
0: 
0: 	/**  For a single result set, just echo the consistency token that the client sent us.
0: 	 * For subsequent resultSets, just subtract the resultset number from
0: 	 * the consistency token and that will differentiate the result sets.
0: 	 * This seems to be what DB2 does
0: 	 * @param rsNum  - result set # starting with 0
0: 	 * 
0: 	 * @return  Consistency token for result set
0: 	 */
0: 
0: 	protected String calculateResultSetPkgcnstknStr(int rsNum)
0: 	{	
0: 		String consistToken = pkgcnstknStr;
0: 
0: 		if (rsNum == 0 || pkgcnstknStr == null)
0: 			return consistToken;
0: 		else
0: 		{
0: 			try {
0: 				BigInteger  consistTokenBi = 
0: 					new BigInteger(consistToken.getBytes(DB2jServerImpl.DEFAULT_ENCODING));
0: 				BigInteger rsNumBi = BigInteger.valueOf(rsNum);
0: 				consistTokenBi = consistTokenBi.subtract(rsNumBi);
0: 				consistToken = new String(consistTokenBi.toByteArray(),DB2jServerImpl.DEFAULT_ENCODING);
0: 			}
0: 			catch (UnsupportedEncodingException e)
0: 			{// Default encoding always supported
0: 			}
0: 		}
0: 		return consistToken;
0: 	}
0: 
0: 	protected boolean isCallableStatement()
0: 	{
0: 		return isCall;
0: 	}
0: 
0: 	private boolean isCallableSQL(String sql)
0: 	{
0: 		java.util.StringTokenizer tokenizer = new java.util.StringTokenizer
0: 			(sql, "\t\n\r\f=? (");
0: 		 String firstToken = tokenizer.nextToken();
0: 		 if (StringUtil.SQLEqualsIgnoreCase(firstToken, 
0: 											"call")) // captures CALL...and ?=CALL...
0: 			 return true;
0: 		 return false;
0: 				 
0: 	}
0: 
0: 	private void setupCallableStatementParams(CallableStatement cs) throws SQLException
0: 	{
0: 		EmbedParameterSetMetaData pmeta = 	((EmbedCallableStatement) cs).getEmbedParameterSetMetaData();
0: 		int numElems = pmeta.getParameterCount();
0: 
0: 		for ( int i = 0; i < numElems; i ++)
0: 		{
0: 			boolean outputFlag = false;
0: 			
0: 			int parameterMode = pmeta.getParameterMode(i + 1);
0: 			int parameterType = pmeta.getParameterType(i + 1);
0: 
0: 			switch (parameterMode) {
0: 				case JDBC30Translation.PARAMETER_MODE_IN:
0: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_OUT:
0: 				case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 					outputFlag = true;
0: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 					// It's only unknown if array
0: 					String objectType = pmeta.getParameterClassName(i+1);
0: 					parameterType =
0: 						getOutputParameterTypeFromClassName(objectType);
0: 					if (parameterType  != NOT_OUTPUT_PARAM)
0: 						outputFlag = true;
0: 			}
0: 
0: 			if (outputFlag)
0: 			{
0: 				if (outputTypes == null) //not initialized yet, since previously none output
0: 				{
0: 					outputTypes = new int[numElems];
0: 					for (int j = 0; j < numElems; j++)
0: 						outputTypes[j] = NOT_OUTPUT_PARAM;  //default init value
0: 				}
0: 				// save the output type so we can register when we parse
0: 				// the SQLDTA
0: 				outputTypes[i] = parameterType;
0: 			}
0: 			
0: 		}
0: 	}
0: 
0: 
0: 
0: 	/** 
0: 		Given an object class  name get the paramameter type if the 
0: 		parameter mode is unknown.
0: 		
0: 		Arrays except for byte arrrays are assumed to be output parameters
0: 		TINYINT output parameters are going to be broken because there
0: 		is no way to differentiate them from binary input parameters.
0: 		@param objectName Class name of object being evaluated.
0: 		indicating if this an output parameter
0: 		@return type from java.sql.Types
0: 	**/
0: 	
0: 	protected static int getOutputParameterTypeFromClassName(String
0: 																	objectName)
0: 	{
0: 		
0: 		if (objectName.endsWith("[]"))
0: 		{
0: 					// For byte[] we are going to assume it is input.
0: 			// For TINYINT output params you gotta use 
0: 			//  object Integer[] or use a procedure				   
0: 					if (objectName.equals("byte[]"))
0: 					{
0: 						return NOT_OUTPUT_PARAM;
0: 							
0: 							//isOutParam[offset] = false;
0: 							//return java.sql.Types.VARBINARY;
0: 					}
0: 					
0: 					// Known arrays are output parameters
0: 					// otherwise we pass it's a JAVA_OBJECT
0: 					if (objectName.equals("java.lang.Byte[]"))
0: 						return java.sql.Types.TINYINT;
0: 					
0: 					if (objectName.equals("byte[][]"))
0: 						return java.sql.Types.VARBINARY;
0: 					if (objectName.equals("java.lang.String[]"))
0: 						return java.sql.Types.VARCHAR; 
0: 					if (objectName.equals("int[]") || 
0: 						objectName.equals("java.lang.Integer[]"))
0: 						return java.sql.Types.INTEGER;
0: 					else if (objectName.equals("long[]")
0: 							 || objectName.equals("java.lang.Long[]"))
0: 						return java.sql.Types.BIGINT;
0: 					else if (objectName.equals("java.math.BigDecimal[]"))
0: 						return java.sql.Types.NUMERIC;
0: 					else if (objectName.equals("boolean[]")  || 
0: 							 objectName.equals("java.lang.Boolean[]"))
0: 						return java.sql.Types.BIT;
0: 					else if (objectName.equals("short[]"))
0: 						return java.sql.Types.SMALLINT;
0: 					else if (objectName.equals("float[]") ||
0: 							 objectName.equals("java.lang.Float[]"))
0: 						return java.sql.Types.REAL;
0: 					else if (objectName.equals("double[]") ||
0: 							 objectName.equals("java.lang.Double[]"))
0: 						return java.sql.Types.DOUBLE;
0: 					else if (objectName.equals("java.sql.Date[]"))
0: 						return java.sql.Types.DATE;
0: 					else if (objectName.equals("java.sql.Time[]"))
0: 						return java.sql.Types.TIME;
0: 					else if (objectName.equals("java.sql.Timestamp[]"))
0: 						return java.sql.Types.TIMESTAMP;
0: 		}
0: 		// Not one of the ones we know. This must be a JAVA_OBJECT
0: 		return NOT_OUTPUT_PARAM;
0: 		//isOutParam[offset] = false;				
0: 		//return java.sql.Types.JAVA_OBJECT;
0: 
0: 	}
0: 	
0: 	
0: 	public void registerAllOutParams() throws SQLException
0: 	{
0: 		if (isCall && (outputTypes != null))
0: 			for (int i = 1; i <= outputTypes.length; i ++)
0: 				registerOutParam(i);
0: 		
0: 	}
0: 	
0: 	public void registerOutParam(int paramNum) throws SQLException
0: 	{
0: 		CallableStatement cs;
0: 		if (isOutputParam(paramNum))
0: 		{
0: 			cs = (CallableStatement) ps;
0: 			cs.registerOutParameter(paramNum, getOutputParamType(paramNum));
0: 		}
0: 	}
0: 
0: 	protected boolean hasOutputParams()
0: 	{
0: 		return (outputTypes != null);
0: 	}
0: 
0: 	/**
0: 	 * is  parameter an ouput parameter
0: 	 * @param paramNum parameter number starting with 1.
0: 	 * return true if this is an output parameter.
0: 	 */
0: 	boolean isOutputParam(int paramNum)
0: 	{
0: 		if (outputTypes != null)
0: 			return (outputTypes[paramNum - 1] != NOT_OUTPUT_PARAM);
0: 		return false;
0: 		
0: 	}
0: 	/** 
0: 	 * get type for output parameter. 
0: 	 *
0: 	 * @param paramNum - parameter number starting with 1
0: 	 * @return jdbcType or NOT_OUTPUT_PARAM if this is not an output parameter
0: 	 */
0: 	int getOutputParamType(int paramNum)
0: 	{
0: 		if (outputTypes != null)
0: 			return (outputTypes[ paramNum - 1 ]);
0: 		return NOT_OUTPUT_PARAM;
0: 	}
0: 
0: 	private boolean isDynamicPkgid(String pkgid)
0: 	{
0: 		char size = pkgid.charAt(3);
0: 		
0: 		//  separate attribute used for holdability in 5.1.60
0: 		// this is just for checking that it is a dynamic package
0: 		char holdability = pkgid.charAt(4); 			                                    
0: 		return (pkgid.substring(0,3).equals("SYS") && (size == 'S' ||
0: 													   size == 'L')
0: 				&& (holdability == 'H' || holdability == 'N'));
0: 		
0: 	}
0: 
0:    
0: 	private  void parsePkgidToFindHoldability()
0: 	{
0: 		if (withHoldCursor != -1)
0: 			return;
0: 		//First, check if holdability was passed as a SQL attribute "WITH HOLD" for this prepare. If yes, then withHoldCursor
0: 		//should not get overwritten by holdability from package name and that is why the check for -1
0: 		if (isDynamicPkgid(pkgid))
0: 		{
0: 			if(pkgid.charAt(4) == 'N')
0: 				withHoldCursor = JDBC30Translation.CLOSE_CURSORS_AT_COMMIT;
0: 			else  
0: 				withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0: 		}
0: 		else 
0: 		{
0: 			withHoldCursor = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0: 		
0: 		}
0: 	}
0: }
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
============================================================================