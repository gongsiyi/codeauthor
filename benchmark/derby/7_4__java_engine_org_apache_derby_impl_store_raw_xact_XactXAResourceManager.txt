1:eac0369: /*
6:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.xact.XactXAResourceManager
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.xact;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1:eac0369: import org.apache.derby.iapi.store.access.xa.XAXactId;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:3c48dd9: import java.util.ArrayList;
1:eac0369: 
1:eac0369: import javax.transaction.xa.Xid;
1:eac0369: import javax.transaction.xa.XAResource;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: The XactXAResourceManager implements the Access XAResource interface, which
1:eac0369: provides offline control over two phase commit transactions.  It is expected
1:eac0369: to be used by TM's (transaction manager's), to recover if systems fail while
1:eac0369: transactions are still in-doubt (prepared).
1:eac0369: <P>
1:eac0369: This interface allows access to commit,prepare,abort global transactions
1:eac0369: as part of a two phase commit protocol.  These interfaces have been chosen
1:eac0369: to be exact implementations required to implement the XAResource interfaces
1:eac0369: as part of the JTA standard extension.
1:eac0369: <P>
1:eac0369: It is expected that the following interfaces are only used during the 
1:eac0369: recovery portion of 2 phase commit, when the transaction manager is
1:eac0369: cleaning up after a runtime crash - it is expected that no current context
1:eac0369: managers exist for the Xid's being operated on.  The "online" two phase commit
1:eac0369: protocol will be implemented by calls directly on a TransactionController.
1:eac0369: <P>
1:eac0369: The XAResource interface is a Java mapping of the industry standard XA resource
1:eac0369: manager interface.  Please refer to: X/Open CAE Specification - Distributed 
1:eac0369: Transaction Processing: The XA Specification, X/Open Document No. XO/CAE/91/300
1:eac0369: or ISBN 1 872630 24 3.
1:eac0369: 
1:eac0369: @see org.apache.derby.iapi.store.access.xa.XAResourceManager
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class XactXAResourceManager implements XAResourceManager
5:eac0369: {
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     private TransactionTable    transaction_table;
1:eac0369:     private RawStoreFactory     rsf;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     public XactXAResourceManager(
1:eac0369:     RawStoreFactory     rsf,
1:eac0369:     TransactionTable    tt)
1:eac0369:     {
1:eac0369:         this.rsf               = rsf;
1:eac0369:         this.transaction_table = tt;
4:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing XAResourceManager interface
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is called to commit the global transaction specified by xid.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - how do we map to the "right" XAExceptions.
1:eac0369:      * <p>
2:eac0369:      *
1:eac0369:      * @param cm       The ContextManager returned from the find() call.
1:eac0369:      * @param xid      A global transaction identifier.
1:eac0369:      * @param onePhase If true, the resource manager should use a one-phase
1:eac0369:      *                 commit protocol to commit the work done on behalf of 
1:eac0369:      *                 xid.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void commit(
1:eac0369:     ContextManager  cm,
1:eac0369:     Xid             xid,
1:eac0369:     boolean         onePhase)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Transaction rawtran = 
1:eac0369:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369: 
1:eac0369:         // This may happen if somehow the transaction was committed between
1:eac0369:         // the find() call and now.
1:eac0369:         if (rawtran == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:eac0369:         }
1:eac0369: 
2:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(rawtran != null);
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 (new GlobalXactId(
1:eac0369:                     xid.getFormatId(),
1:eac0369:                     xid.getGlobalTransactionId(),
1:eac0369:                     xid.getBranchQualifier())).equals(rawtran.getGlobalId()));
1:eac0369:         }
1:eac0369: 
1:eac0369:         rawtran.xa_commit(onePhase);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Find the given Xid in the transaction table.
1:eac0369:      * <p>
1:eac0369:      * This routine is used to find a in-doubt transaction from the list
1:eac0369:      * of Xid's returned from the recover() routine.  
1:eac0369:      * <p>
1:eac0369:      * In the current implementation it is up to the calling routine
1:eac0369:      * to make the returned ContextManager the "current" ContextManager
1:eac0369:      * before calls to commit,abort, or forget.  The caller is responsible
1:eac0369:      * for error handling, ie. calling cleanupOnError() on the correct
1:eac0369:      * ContextManager.
1:eac0369:      * <p>
1:eac0369:      * If the Xid is not in the system, "null" is returned.
1:eac0369:      * RESOLVE - find out from sku if she wants a exception instead?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param xid      A global transaction identifier.
1:eac0369:      *
1:eac0369:      **/
1:eac0369:     public ContextManager find(
1:eac0369:     Xid     xid)
1:eac0369:     {
1:eac0369:         return(
1:eac0369:             transaction_table.findTransactionContextByGlobalId(
1:eac0369:                 new GlobalXactId(
1:eac0369:                     xid.getFormatId(),
1:eac0369:                     xid.getGlobalTransactionId(),
1:eac0369:                     xid.getBranchQualifier())));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is called to remove the given transaction 
1:eac0369:      * from the transaction table/log.
1:eac0369:      * <p>
1:eac0369:      * Used to let the store remove all record from log and transaction
1:eac0369:      * table of the given transaction.  This should only be used to 
1:eac0369:      * clean up heuristically completed transactions, otherwise commit or
1:eac0369:      * abort should be used to act on other transactions.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param cm       The ContextManager returned from the find() call.
1:eac0369:      * @param xid      A global transaction identifier.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void forget(
1:eac0369:     ContextManager  cm,
1:eac0369:     Xid             xid)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Transaction rawtran = 
1:eac0369:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 new GlobalXactId(
1:eac0369:                     xid.getFormatId(),
1:eac0369:                     xid.getGlobalTransactionId(),
1:eac0369:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
1:eac0369:         }
1:eac0369: 
1:eac0369:         // forget should only be called on heuristically completed xacts, which
1:eac0369:         // should not exist in our system.
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is called to obtain a list of prepared transactions.
1:eac0369:      * <p>
1:eac0369:      * This call returns a complete list of global transactions which are 
1:eac0369:      * either prepared or heuristically complete.
1:eac0369:      * <p>
1:eac0369:      * The XAResource interface expects a scan type interface, but our
1:eac0369:      * implementation only returns a complete list of transactions.  So to
1:eac0369:      * simulate the scan the following state is maintained.  If TMSTARTSCAN
1:eac0369:      * is specified the complete list is returned.  If recover is called with
1:eac0369:      * TMNOFLAGS is ever called a 0 length array is returned.  
1:eac0369:      *
1:eac0369: 	 * @return Return a array with 0 or more Xid's which are currently in
1:eac0369:      *         prepared or heuristically completed state.  If an error occurs
1:eac0369:      *         during the operation, an appropriate error is thrown.
1:eac0369:      *
1:eac0369:      * @param flags    combination of the following flags 
1:eac0369:      *                 XAResource.{TMSTARTRSCAN,TMENDRSCAN,TMNOFLAGS}.  
1:eac0369:      *                 TMNOFLAGS must be used when no other flags are used.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public Xid[] recover(int flags)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         XAXactId[] ret_xid_list;
1:eac0369: 
1:eac0369:         if ((flags & XAResource.TMSTARTRSCAN) != 0)
1:eac0369:         {
1:7e7a589:             final ArrayList<XAXactId> xid_list = new ArrayList<XAXactId>();
1:eac0369: 
1:3c48dd9:             // Create a visitor that adds each of the prepared transactions
1:3c48dd9:             // to xid_list.
1:3c48dd9:             final TransactionTable.EntryVisitor visitor =
1:3c48dd9:                     new TransactionTable.EntryVisitor() {
1:e21c3de:                 public boolean visit(TransactionTableEntry entry) {
1:3c48dd9:                     Xact xact = entry.getXact();
1:eac0369:                     if (xact.isPrepared())
1:eac0369:                     {
1:0fad4e6:                         GlobalXactId xa_id = (GlobalXactId) xact.getGlobalId();
1:eac0369: 
1:3c48dd9:                         xid_list.add(
1:eac0369:                             new XAXactId(
1:eac0369:                                 xa_id.getFormat_Id(), 
1:eac0369:                                 xa_id.getGlobalTransactionId(), 
1:3c48dd9:                                 xa_id.getBranchQualifier()));
1:eac0369:                     }
1:e21c3de:                     return true; // scan the entire transaction table
1:eac0369:                 }
1:3c48dd9:             };
1:eac0369: 
1:3c48dd9:             // Collect the prepared transactions.
1:3c48dd9:             transaction_table.visitEntries(visitor);
1:eac0369: 
1:3c48dd9:             // Convert the list to an array suitable for being returned.
1:3c48dd9:             ret_xid_list = new XAXactId[xid_list.size()];
1:3c48dd9:             ret_xid_list = (XAXactId[]) xid_list.toArray(ret_xid_list);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             ret_xid_list = new XAXactId[0];
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_xid_list);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * rollback the transaction identified by Xid.
1:eac0369:      * <p>
1:eac0369:      * The given transaction is roll'ed back and it's history is not
1:eac0369:      * maintained in the transaction table or long term log.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param cm       The ContextManager returned from the find() call.
1:eac0369:      * @param xid      A global transaction identifier.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void rollback(
1:eac0369:     ContextManager  cm,
1:eac0369:     Xid             xid)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         Transaction rawtran = 
1:eac0369:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1:eac0369: 
1:eac0369:         // This may happen if somehow the transaction was committed between
1:eac0369:         // the find() call and now.
1:eac0369:         if (rawtran == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 new GlobalXactId(
1:eac0369:                     xid.getFormatId(),
1:eac0369:                     xid.getGlobalTransactionId(),
1:eac0369:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
1:eac0369:         }
1:eac0369: 
1:eac0369:         rawtran.xa_rollback();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of XXXX class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1:             final ArrayList<XAXactId> xid_list = new ArrayList<XAXactId>();
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0fad4e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         GlobalXactId xa_id = (GlobalXactId) xact.getGlobalId();
commit:e21c3de
/////////////////////////////////////////////////////////////////////////
1:                 public boolean visit(TransactionTableEntry entry) {
/////////////////////////////////////////////////////////////////////////
1:                     return true; // scan the entire transaction table
commit:3c48dd9
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0:             final ArrayList xid_list = new ArrayList();
1:             // Create a visitor that adds each of the prepared transactions
1:             // to xid_list.
1:             final TransactionTable.EntryVisitor visitor =
1:                     new TransactionTable.EntryVisitor() {
0:                 public void visit(TransactionTableEntry entry) {
1:                     Xact xact = entry.getXact();
1:                         xid_list.add(
1:                                 xa_id.getBranchQualifier()));
1:             };
1:             // Collect the prepared transactions.
1:             transaction_table.visitEntries(visitor);
1:             // Convert the list to an array suitable for being returned.
1:             ret_xid_list = new XAXactId[xid_list.size()];
1:             ret_xid_list = (XAXactId[]) xid_list.toArray(ret_xid_list);
commit:0fc1787
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
0:             Map         trans_hashtable = transaction_table.getTableForXA();
/////////////////////////////////////////////////////////////////////////
0:                 for (Iterator it = trans_hashtable.values().iterator();
0:                      it.hasNext(); i++)
0:                         ((TransactionTableEntry) it.next()).getXact();
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.xact.XactXAResourceManager
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.xact;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
1: import org.apache.derby.iapi.store.access.xa.XAXactId;
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: 
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: 
0: import org.apache.derby.impl.store.raw.xact.GlobalXactId;
0: import org.apache.derby.impl.store.raw.xact.TransactionTable;
0: import org.apache.derby.impl.store.raw.xact.TransactionTableEntry;
0: import org.apache.derby.impl.store.raw.xact.Xact;
1: 
0: import java.util.Enumeration;
0: import java.util.Hashtable;
1: 
1: import javax.transaction.xa.Xid;
1: import javax.transaction.xa.XAResource;
1: 
1: /**
1: 
1: The XactXAResourceManager implements the Access XAResource interface, which
1: provides offline control over two phase commit transactions.  It is expected
1: to be used by TM's (transaction manager's), to recover if systems fail while
1: transactions are still in-doubt (prepared).
1: <P>
1: This interface allows access to commit,prepare,abort global transactions
1: as part of a two phase commit protocol.  These interfaces have been chosen
1: to be exact implementations required to implement the XAResource interfaces
1: as part of the JTA standard extension.
1: <P>
1: It is expected that the following interfaces are only used during the 
1: recovery portion of 2 phase commit, when the transaction manager is
1: cleaning up after a runtime crash - it is expected that no current context
1: managers exist for the Xid's being operated on.  The "online" two phase commit
1: protocol will be implemented by calls directly on a TransactionController.
1: <P>
1: The XAResource interface is a Java mapping of the industry standard XA resource
1: manager interface.  Please refer to: X/Open CAE Specification - Distributed 
1: Transaction Processing: The XA Specification, X/Open Document No. XO/CAE/91/300
1: or ISBN 1 872630 24 3.
1: 
1: @see org.apache.derby.iapi.store.access.xa.XAResourceManager
1: 
1: **/
1: 
1: public class XactXAResourceManager implements XAResourceManager
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1:     private TransactionTable    transaction_table;
1:     private RawStoreFactory     rsf;
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1:     public XactXAResourceManager(
1:     RawStoreFactory     rsf,
1:     TransactionTable    tt)
1:     {
1:         this.rsf               = rsf;
1:         this.transaction_table = tt;
1:     }
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods implementing XAResourceManager interface
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * This method is called to commit the global transaction specified by xid.
1:      * <p>
1:      * RESOLVE - how do we map to the "right" XAExceptions.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param cm       The ContextManager returned from the find() call.
1:      * @param xid      A global transaction identifier.
1:      * @param onePhase If true, the resource manager should use a one-phase
1:      *                 commit protocol to commit the work done on behalf of 
1:      *                 xid.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void commit(
1:     ContextManager  cm,
1:     Xid             xid,
1:     boolean         onePhase)
1: 		throws StandardException
1:     {
1:         Transaction rawtran = 
1:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:         // This may happen if somehow the transaction was committed between
1:         // the find() call and now.
1:         if (rawtran == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(rawtran != null);
1: 
1:             SanityManager.ASSERT(
1:                 (new GlobalXactId(
1:                     xid.getFormatId(),
1:                     xid.getGlobalTransactionId(),
1:                     xid.getBranchQualifier())).equals(rawtran.getGlobalId()));
1:         }
1: 
1:         rawtran.xa_commit(onePhase);
1:     }
1: 
1:     /**
1:      * Find the given Xid in the transaction table.
1:      * <p>
1:      * This routine is used to find a in-doubt transaction from the list
1:      * of Xid's returned from the recover() routine.  
1:      * <p>
1:      * In the current implementation it is up to the calling routine
1:      * to make the returned ContextManager the "current" ContextManager
1:      * before calls to commit,abort, or forget.  The caller is responsible
1:      * for error handling, ie. calling cleanupOnError() on the correct
1:      * ContextManager.
1:      * <p>
1:      * If the Xid is not in the system, "null" is returned.
1:      * RESOLVE - find out from sku if she wants a exception instead?
1:      * <p>
1:      *
1:      * @param xid      A global transaction identifier.
1:      *
1:      **/
1:     public ContextManager find(
1:     Xid     xid)
1:     {
1:         return(
1:             transaction_table.findTransactionContextByGlobalId(
1:                 new GlobalXactId(
1:                     xid.getFormatId(),
1:                     xid.getGlobalTransactionId(),
1:                     xid.getBranchQualifier())));
1:     }
1: 
1:     /**
1:      * This method is called to remove the given transaction 
1:      * from the transaction table/log.
1:      * <p>
1:      * Used to let the store remove all record from log and transaction
1:      * table of the given transaction.  This should only be used to 
1:      * clean up heuristically completed transactions, otherwise commit or
1:      * abort should be used to act on other transactions.
1:      * <p>
1:      *
1:      * @param cm       The ContextManager returned from the find() call.
1:      * @param xid      A global transaction identifier.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void forget(
1:     ContextManager  cm,
1:     Xid             xid)
1: 		throws StandardException
1:     {
1:         Transaction rawtran = 
1:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 new GlobalXactId(
1:                     xid.getFormatId(),
1:                     xid.getGlobalTransactionId(),
1:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
1:         }
1: 
1:         // forget should only be called on heuristically completed xacts, which
1:         // should not exist in our system.
1:         throw StandardException.newException(
1:                 SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:     }
1: 
1: 
1:     /**
1:      * This method is called to obtain a list of prepared transactions.
1:      * <p>
1:      * This call returns a complete list of global transactions which are 
1:      * either prepared or heuristically complete.
1:      * <p>
1:      * The XAResource interface expects a scan type interface, but our
1:      * implementation only returns a complete list of transactions.  So to
1:      * simulate the scan the following state is maintained.  If TMSTARTSCAN
1:      * is specified the complete list is returned.  If recover is called with
1:      * TMNOFLAGS is ever called a 0 length array is returned.  
1:      *
1: 	 * @return Return a array with 0 or more Xid's which are currently in
1:      *         prepared or heuristically completed state.  If an error occurs
1:      *         during the operation, an appropriate error is thrown.
1:      *
1:      * @param flags    combination of the following flags 
1:      *                 XAResource.{TMSTARTRSCAN,TMENDRSCAN,TMNOFLAGS}.  
1:      *                 TMNOFLAGS must be used when no other flags are used.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public Xid[] recover(int flags)
1:         throws StandardException
1:     {
1:         XAXactId[] ret_xid_list;
1: 
1:         if ((flags & XAResource.TMSTARTRSCAN) != 0)
1:         {
0:             Hashtable   trans_hashtable = transaction_table.getTableForXA();
0:             XAXactId[]  xid_list        = new XAXactId[trans_hashtable.size()];
0:             int         num_prepared    = 0;
1: 
0:             // Need to hold sync while linear searching the hash table.
0:             synchronized (trans_hashtable)
1:             {
0:                 int i = 0;
1: 
0:                 for (Enumeration e = trans_hashtable.elements(); 
0:                      e.hasMoreElements(); i++) 
1:                 {
0:                     Xact xact = 
0:                         ((TransactionTableEntry) e.nextElement()).getXact();
1: 
1:                     if (xact.isPrepared())
1:                     {
0:                         GlobalTransactionId xa_id = xact.getGlobalId();
1: 
0:                         xid_list[i] = 
1:                             new XAXactId(
1:                                 xa_id.getFormat_Id(), 
1:                                 xa_id.getGlobalTransactionId(), 
0:                                 xa_id.getBranchQualifier());
0:                         num_prepared++;
1:                     }
1:                 }
1:             }
1: 
0:             // now need to squish the nulls out of the array to return. 
0:             ret_xid_list = new XAXactId[num_prepared];
0:             int ret_index = 0;
0:             for (int i = xid_list.length; i-- > 0; )
1:             {
0:                 if (xid_list[i] != null)
0:                     ret_xid_list[ret_index++] = xid_list[i];
1:             }
1: 
1:             if (SanityManager.DEBUG)
1:             {
0:                 SanityManager.ASSERT(ret_index == num_prepared);
1:             }
1:         }
1:         else
1:         {
1:             ret_xid_list = new XAXactId[0];
1:         }
1: 
1:         return(ret_xid_list);
1:     }
1: 
1:     /**
1:      * rollback the transaction identified by Xid.
1:      * <p>
1:      * The given transaction is roll'ed back and it's history is not
1:      * maintained in the transaction table or long term log.
1:      * <p>
1:      *
1:      * @param cm       The ContextManager returned from the find() call.
1:      * @param xid      A global transaction identifier.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void rollback(
1:     ContextManager  cm,
1:     Xid             xid)
1:         throws StandardException
1:     {
1:         Transaction rawtran = 
1:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1:         // This may happen if somehow the transaction was committed between
1:         // the find() call and now.
1:         if (rawtran == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1: 
1:             SanityManager.ASSERT(
1:                 new GlobalXactId(
1:                     xid.getFormatId(),
1:                     xid.getGlobalTransactionId(),
1:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
1:         }
1: 
1:         rawtran.xa_rollback();
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of XXXX class:
1:      **************************************************************************
1:      */
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.xact
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.xact;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.xa.XAResourceManager;
0: import org.apache.derby.iapi.store.access.xa.XAXactId;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: 
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: 
0: import org.apache.derby.impl.store.raw.xact.GlobalXactId;
0: import org.apache.derby.impl.store.raw.xact.TransactionTable;
0: import org.apache.derby.impl.store.raw.xact.TransactionTableEntry;
0: import org.apache.derby.impl.store.raw.xact.Xact;
0: 
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: 
0: import javax.transaction.xa.Xid;
0: import javax.transaction.xa.XAResource;
0: 
0: /**
0: 
0: The XactXAResourceManager implements the Access XAResource interface, which
0: provides offline control over two phase commit transactions.  It is expected
0: to be used by TM's (transaction manager's), to recover if systems fail while
0: transactions are still in-doubt (prepared).
0: <P>
0: This interface allows access to commit,prepare,abort global transactions
0: as part of a two phase commit protocol.  These interfaces have been chosen
0: to be exact implementations required to implement the XAResource interfaces
0: as part of the JTA standard extension.
0: <P>
0: It is expected that the following interfaces are only used during the 
0: recovery portion of 2 phase commit, when the transaction manager is
0: cleaning up after a runtime crash - it is expected that no current context
0: managers exist for the Xid's being operated on.  The "online" two phase commit
0: protocol will be implemented by calls directly on a TransactionController.
0: <P>
0: The XAResource interface is a Java mapping of the industry standard XA resource
0: manager interface.  Please refer to: X/Open CAE Specification - Distributed 
0: Transaction Processing: The XA Specification, X/Open Document No. XO/CAE/91/300
0: or ISBN 1 872630 24 3.
0: 
0: @see org.apache.derby.iapi.store.access.xa.XAResourceManager
0: 
0: **/
0: 
0: public class XactXAResourceManager implements XAResourceManager
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0:     private TransactionTable    transaction_table;
0:     private RawStoreFactory     rsf;
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0:     public XactXAResourceManager(
0:     RawStoreFactory     rsf,
0:     TransactionTable    tt)
0:     {
0:         this.rsf               = rsf;
0:         this.transaction_table = tt;
0:     }
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods implementing XAResourceManager interface
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * This method is called to commit the global transaction specified by xid.
0:      * <p>
0:      * RESOLVE - how do we map to the "right" XAExceptions.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      * @param cm       The ContextManager returned from the find() call.
0:      * @param xid      A global transaction identifier.
0:      * @param onePhase If true, the resource manager should use a one-phase
0:      *                 commit protocol to commit the work done on behalf of 
0:      *                 xid.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void commit(
0:     ContextManager  cm,
0:     Xid             xid,
0:     boolean         onePhase)
0: 		throws StandardException
0:     {
0:         Transaction rawtran = 
0:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0:         // This may happen if somehow the transaction was committed between
0:         // the find() call and now.
0:         if (rawtran == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(rawtran != null);
0: 
0:             SanityManager.ASSERT(
0:                 (new GlobalXactId(
0:                     xid.getFormatId(),
0:                     xid.getGlobalTransactionId(),
0:                     xid.getBranchQualifier())).equals(rawtran.getGlobalId()));
0:         }
0: 
0:         rawtran.xa_commit(onePhase);
0:     }
0: 
0:     /**
0:      * Find the given Xid in the transaction table.
0:      * <p>
0:      * This routine is used to find a in-doubt transaction from the list
0:      * of Xid's returned from the recover() routine.  
0:      * <p>
0:      * In the current implementation it is up to the calling routine
0:      * to make the returned ContextManager the "current" ContextManager
0:      * before calls to commit,abort, or forget.  The caller is responsible
0:      * for error handling, ie. calling cleanupOnError() on the correct
0:      * ContextManager.
0:      * <p>
0:      * If the Xid is not in the system, "null" is returned.
0:      * RESOLVE - find out from sku if she wants a exception instead?
0:      * <p>
0:      *
0:      * @param xid      A global transaction identifier.
0:      *
0:      **/
0:     public ContextManager find(
0:     Xid     xid)
0:     {
0:         return(
0:             transaction_table.findTransactionContextByGlobalId(
0:                 new GlobalXactId(
0:                     xid.getFormatId(),
0:                     xid.getGlobalTransactionId(),
0:                     xid.getBranchQualifier())));
0:     }
0: 
0:     /**
0:      * This method is called to remove the given transaction 
0:      * from the transaction table/log.
0:      * <p>
0:      * Used to let the store remove all record from log and transaction
0:      * table of the given transaction.  This should only be used to 
0:      * clean up heuristically completed transactions, otherwise commit or
0:      * abort should be used to act on other transactions.
0:      * <p>
0:      *
0:      * @param cm       The ContextManager returned from the find() call.
0:      * @param xid      A global transaction identifier.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void forget(
0:     ContextManager  cm,
0:     Xid             xid)
0: 		throws StandardException
0:     {
0:         Transaction rawtran = 
0:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 new GlobalXactId(
0:                     xid.getFormatId(),
0:                     xid.getGlobalTransactionId(),
0:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
0:         }
0: 
0:         // forget should only be called on heuristically completed xacts, which
0:         // should not exist in our system.
0:         throw StandardException.newException(
0:                 SQLState.STORE_XA_PROTOCOL_VIOLATION);
0:     }
0: 
0: 
0:     /**
0:      * This method is called to obtain a list of prepared transactions.
0:      * <p>
0:      * This call returns a complete list of global transactions which are 
0:      * either prepared or heuristically complete.
0:      * <p>
0:      * The XAResource interface expects a scan type interface, but our
0:      * implementation only returns a complete list of transactions.  So to
0:      * simulate the scan the following state is maintained.  If TMSTARTSCAN
0:      * is specified the complete list is returned.  If recover is called with
0:      * TMNOFLAGS is ever called a 0 length array is returned.  
0:      *
0: 	 * @return Return a array with 0 or more Xid's which are currently in
0:      *         prepared or heuristically completed state.  If an error occurs
0:      *         during the operation, an appropriate error is thrown.
0:      *
0:      * @param flags    combination of the following flags 
0:      *                 XAResource.{TMSTARTRSCAN,TMENDRSCAN,TMNOFLAGS}.  
0:      *                 TMNOFLAGS must be used when no other flags are used.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public Xid[] recover(int flags)
0:         throws StandardException
0:     {
0:         XAXactId[] ret_xid_list;
0: 
0:         if ((flags & XAResource.TMSTARTRSCAN) != 0)
0:         {
0:             Hashtable   trans_hashtable = transaction_table.getTableForXA();
0:             XAXactId[]  xid_list        = new XAXactId[trans_hashtable.size()];
0:             int         num_prepared    = 0;
0: 
0:             // Need to hold sync while linear searching the hash table.
0:             synchronized (trans_hashtable)
0:             {
0:                 int i = 0;
0: 
0:                 for (Enumeration e = trans_hashtable.elements(); 
0:                      e.hasMoreElements(); i++) 
0:                 {
0:                     Xact xact = 
0:                         ((TransactionTableEntry) e.nextElement()).getXact();
0: 
0:                     if (xact.isPrepared())
0:                     {
0:                         GlobalTransactionId xa_id = xact.getGlobalId();
0: 
0:                         xid_list[i] = 
0:                             new XAXactId(
0:                                 xa_id.getFormat_Id(), 
0:                                 xa_id.getGlobalTransactionId(), 
0:                                 xa_id.getBranchQualifier());
0:                         num_prepared++;
0:                     }
0:                 }
0:             }
0: 
0:             // now need to squish the nulls out of the array to return. 
0:             ret_xid_list = new XAXactId[num_prepared];
0:             int ret_index = 0;
0:             for (int i = xid_list.length; i-- > 0; )
0:             {
0:                 if (xid_list[i] != null)
0:                     ret_xid_list[ret_index++] = xid_list[i];
0:             }
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(ret_index == num_prepared);
0:             }
0:         }
0:         else
0:         {
0:             ret_xid_list = new XAXactId[0];
0:         }
0: 
0:         return(ret_xid_list);
0:     }
0: 
0:     /**
0:      * rollback the transaction identified by Xid.
0:      * <p>
0:      * The given transaction is roll'ed back and it's history is not
0:      * maintained in the transaction table or long term log.
0:      * <p>
0:      *
0:      * @param cm       The ContextManager returned from the find() call.
0:      * @param xid      A global transaction identifier.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void rollback(
0:     ContextManager  cm,
0:     Xid             xid)
0:         throws StandardException
0:     {
0:         Transaction rawtran = 
0:             rsf.findUserTransaction(cm, AccessFactoryGlobals.USER_TRANS_NAME);
0: 
0:         // This may happen if somehow the transaction was committed between
0:         // the find() call and now.
0:         if (rawtran == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.STORE_XA_PROTOCOL_VIOLATION);
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0: 
0:             SanityManager.ASSERT(
0:                 new GlobalXactId(
0:                     xid.getFormatId(),
0:                     xid.getGlobalTransactionId(),
0:                     xid.getBranchQualifier()).equals(rawtran.getGlobalId()));
0:         }
0: 
0:         rawtran.xa_rollback();
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of XXXX class:
0:      **************************************************************************
0:      */
0: }
============================================================================