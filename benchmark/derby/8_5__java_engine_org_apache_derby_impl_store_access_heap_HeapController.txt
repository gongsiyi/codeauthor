1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.HeapController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:af1c18c: import java.util.List;
1:af1c18c: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:af1c18c: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class HeapController 
1:eac0369:     extends GenericConglomerateController 
1:eac0369:     implements ConglomerateController
1:eac0369: {
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected concrete impl of abstract methods of 
1:bbc927c:      *     GenericConglomerateController class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     protected final void getRowPositionFromRowLocation(
1:eac0369:     RowLocation row_loc,
1:eac0369:     RowPosition pos)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(row_loc instanceof HeapRowLocation);
1:eac0369:         }
1:eac0369:         pos.current_rh = 
1:eac0369:             ((HeapRowLocation) row_loc).getRecordHandle(
1:eac0369:                 open_conglom.getContainer());
1:eac0369:         pos.current_rh_qualified = true;
1:eac0369:     }
1:eac0369: 
1:eac0369:     protected void queueDeletePostCommitWork(
1:eac0369:     RowPosition pos)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         TransactionManager xact_mgr = open_conglom.getXactMgr();
1:eac0369: 
1:eac0369:         xact_mgr.addPostCommitWork(
1:eac0369:             new HeapPostCommit(
1:eac0369:                 xact_mgr.getAccessManager(), 
1:888d12e:                 pos.current_page.getPageKey()));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:bbc927c:      * Check and purge committed deleted rows on a page.
1:bbc927c:      * <p>
1:bbc927c:      * 
1:bbc927c: 	 * @return true, if no purging has been done on page, and thus latch
1:bbc927c:      *         can be released before end transaction.  Otherwise the latch
1:bbc927c:      *         on the page can not be released before commit.
1:bbc927c:      *
1:bbc927c:      * @param page   A non-null, latched page must be passed in.  If all
1:bbc927c:      *               rows on page are purged, then page will be removed and
1:bbc927c:      *               latch released.
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c:     protected final boolean purgeCommittedDeletes(
1:bbc927c:     Page                page)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         boolean purgingDone = false;
1:bbc927c: 
1:bbc927c:         // The number records that can be reclaimed is:
1:bbc927c:         // total recs - recs_not_deleted
1:bbc927c:         int num_possible_commit_delete = 
1:bbc927c:             page.recordCount() - page.nonDeletedRecordCount();
1:bbc927c: 
1:bbc927c:         if (num_possible_commit_delete > 0)
1:bbc927c:         {
1:bbc927c:             // loop backward so that purges which affect the slot table 
1:bbc927c:             // don't affect the loop (ie. they only move records we 
1:bbc927c:             // have already looked at).
1:bbc927c:             for (int slot_no = page.recordCount() - 1; 
1:bbc927c:                  slot_no >= 0; 
1:bbc927c:                  slot_no--) 
1:bbc927c:             {
1:bbc927c:                 boolean row_is_committed_delete = 
1:bbc927c:                     page.isDeletedAtSlot(slot_no);
1:bbc927c: 
1:bbc927c:                 if (row_is_committed_delete)
1:bbc927c:                 {
1:bbc927c:                     // At this point we only know that the row is
1:bbc927c:                     // deleted, not whether it is committed.
1:bbc927c: 
1:bbc927c:                     // see if we can purge the row, by getting an
1:bbc927c:                     // exclusive lock on the row.  If it is marked
1:bbc927c:                     // deleted and we can get this lock, then it
1:bbc927c:                     // must be a committed delete and we can purge 
1:bbc927c:                     // it.
1:bbc927c: 
1:bbc927c:                     RecordHandle rh =
1:bbc927c:                         page.fetchFromSlot(
1:bbc927c:                             (RecordHandle) null,
1:bbc927c:                             slot_no,
1:bbc927c:                             RowUtil.EMPTY_ROW,
1:bbc927c:                             RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,
1:bbc927c:                             true);
1:bbc927c: 
1:bbc927c:                     row_is_committed_delete =
1:bbc927c:                         this.lockRowAtSlotNoWaitExclusive(rh);
1:bbc927c: 
1:bbc927c:                     if (row_is_committed_delete)
1:bbc927c:                     {
1:bbc927c:                         purgingDone = true;
1:bbc927c: 
1:bbc927c:                         page.purgeAtSlot(slot_no, 1, false);
1:bbc927c:                     }
1:bbc927c:                 }
1:bbc927c:             }
1:bbc927c:         }
1:bbc927c:         if (page.recordCount() == 0)
1:bbc927c:         {
1:bbc927c: 
1:bbc927c:             // Deallocate the current page with 0 rows on it.
1:bbc927c:             this.removePage(page);
1:bbc927c: 
1:bbc927c:             // removePage guarantees to unlatch the page even if an
1:bbc927c:             // exception is thrown. The page is protected against reuse
1:bbc927c:             // because removePage locks it with a dealloc lock, so it
1:bbc927c:             // is OK to release the latch even after a purgeAtSlot is
1:bbc927c:             // called.
1:bbc927c:             // @see ContainerHandle#removePage
1:bbc927c: 
1:bbc927c:             purgingDone = true;
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         return(purgingDone);
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:eac0369:      * Insert a new row into the heap.
1:eac0369:      * <p>
1:eac0369:      * Overflow policy:
1:eac0369:      * The current heap access method implements an algorithm that optimizes
1:eac0369:      * for fetch efficiency vs. space efficiency.  A row will not be over
1:eac0369:      * flowed unless it is bigger than a page.  If it is bigger than a page
1:eac0369:      * then it's initial part will be placed on a page and then subsequent
1:eac0369:      * parts will be overflowed to other pages.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The record handle of the inserted row.
1:eac0369:      *
1:eac0369:      * @param row           The row to insert.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	private RecordHandle doInsert(DataValueDescriptor[] row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		Page page = null;
1:eac0369:         byte  insert_mode;
1:eac0369: 		
1:eac0369:         RecordHandle rh;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             Heap heap = (Heap) open_conglom.getConglomerate();
1:eac0369:             // Make sure valid columns are in the list.  The RowUtil
1:eac0369:             // call is too expensive to make in a released system for
1:eac0369:             // every insert.
1:eac0369: 
1:eac0369:             int invalidColumn = 
1:eac0369:                 RowUtil.columnOutOfRange(
1:eac0369:                     row, null, heap.format_ids.length);
1:eac0369: 
1:eac0369:             if (invalidColumn >= 0)
1:eac0369:             {
1:eac0369:                 throw(StandardException.newException(
1:eac0369:                         SQLState.HEAP_TEMPLATE_MISMATCH,
1:ce40a31:                         invalidColumn, 
1:ce40a31:                         heap.format_ids.length));
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Get the last page that was returned for insert or the last page
1:eac0369:         // that was allocated.
1:eac0369:         page = open_conglom.getContainer().getPageForInsert(0);
1:eac0369: 
1:eac0369:         if (page != null) {
1:eac0369: 
1:eac0369:             // if there are 0 rows on the page allow the insert to overflow.
1:eac0369:             insert_mode = 
1:eac0369:                 (page.recordCount() == 0) ? 
1:eac0369:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
1:eac0369: 
1:eac0369:             // Check to see if there is enough space on the page
1:eac0369:             // for the row.
1:eac0369:             rh = page.insert(row, null, insert_mode,
1:eac0369: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:eac0369:             page.unlatch();
1:eac0369:             page = null;
1:eac0369: 
1:eac0369:             // If we have found a page with enough space for the row,
1:eac0369:             // insert it and release exclusive access to the page.
1:eac0369:             if (rh != null)
1:eac0369:             {
1:eac0369:                 return rh;
1:eac0369: 
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // If the last inserted page is now full, or RawStore have
1:eac0369:         // forgotten what it was, or the row cannot fit on the last
1:eac0369:         // inserted page, try to have rawStore get a relatively unfilled
1:eac0369:         // page.
1:eac0369: 
1:eac0369:         page = 
1:eac0369:             open_conglom.getContainer().getPageForInsert(
1:eac0369:                 ContainerHandle.GET_PAGE_UNFILLED);
1:eac0369: 
1:eac0369:         if (page != null)
1:eac0369:         {
1:eac0369:             // Do the insert all over again hoping that it will fit into
1:eac0369:             // this page, and if not, allocate a new page.
1:eac0369: 
1:eac0369:             // if there are 0 rows on the page allow the insert to overflow.
1:eac0369:             insert_mode = 
1:eac0369:                 (page.recordCount() == 0) ? 
1:eac0369:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
1:eac0369:             
1:eac0369:             rh = page.insert(row, null, insert_mode,
1:eac0369: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:eac0369: 
1:eac0369:             page.unlatch();
1:eac0369:             page = null;
1:eac0369: 
1:eac0369:             // If we have found a page with enough space for the row,
1:eac0369:             // insert it and release exclusive access to the page.
1:eac0369:             if (rh != null)
1:eac0369:             {
1:eac0369:                 return rh;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         page = open_conglom.getContainer().addPage();
1:eac0369: 
1:eac0369:         // At this point with long rows the raw store will guarantee
1:eac0369:         // that any size row will fit on an empty page.
1:eac0369: 
1:eac0369:         rh = page.insert(row, null, Page.INSERT_OVERFLOW,
1:eac0369: 			AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:eac0369:         page.unlatch();
1:eac0369:         page = null;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             // a null will only be returned if this page is not empty
1:eac0369:             SanityManager.ASSERT(rh != null);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return rh;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected long load(
1:eac0369:     TransactionManager      xact_manager,
1:eac0369:     Heap                    heap,
1:eac0369:     boolean                 createConglom,
1:eac0369:     RowLocationRetRowSource rowSource)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         long    num_rows_loaded = 0;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			SanityManager.ASSERT(open_conglom == null,
1:eac0369: 				"load expects container handle to be closed on entry.");
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// The individual rows that are inserted are not logged.  To use a
1:eac0369: 		// logged interface, use insert.  RESOLVE: do we want to allow client
1:eac0369: 		// to use the load interface even for logged insert?
1:eac0369: 		int mode = 
1:eac0369:             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_UNLOGGED); 
1:eac0369: 
1:eac0369: 		// If the container is being created in the same operation, don't log
1:eac0369: 		// page allocation.  
1:eac0369: 		if (createConglom)
1:eac0369: 			mode |= ContainerHandle.MODE_CREATE_UNLOGGED;
1:eac0369: 
1:eac0369:         OpenConglomerate open_conglom = new OpenHeap();
1:eac0369: 
1:eac0369:         if (open_conglom.init(
1:eac0369:                 (ContainerHandle) null,
1:eac0369:                 heap,
1:eac0369:                 heap.format_ids,
1:722a889:                 heap.collation_ids,
1:eac0369:                 xact_manager,
1:eac0369:                 xact_manager.getRawStoreXact(),
1:eac0369:                 false,
1:eac0369:                 mode,
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:eac0369:                     LockingPolicy.MODE_CONTAINER,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:eac0369:                 (DynamicCompiledOpenConglomInfo) null) == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     heap.getId().getContainerId());
1:eac0369:         }
1:eac0369: 
1:eac0369:         this.init(open_conglom);
1:eac0369: 
1:eac0369: 		// For bulk loading, we always use only brand new page because the row
1:eac0369: 		// insertion itself is not logged.  We cannot pollute pages with
1:eac0369: 		// pre-existing data with unlogged rows because nobody is going to wipe
1:eac0369: 		// out these rows if the transaction rolls back.  We are counting on
1:eac0369: 		// the allocation page rollback to obliterate these rows if the
1:eac0369: 		// transaction fails, or, in the CREAT_UNLOGGED case, the whole
1:eac0369: 		// container to be removed.
1:eac0369: 
1:eac0369: 		Page page = open_conglom.getContainer().addPage();
1:eac0369: 
1:eac0369: 		boolean callbackWithRowLocation = rowSource.needsRowLocation();
1:eac0369: 		RecordHandle rh;
1:eac0369: 		HeapRowLocation rowlocation;
1:eac0369: 
1:af1c18c:         if (callbackWithRowLocation ||
1:af1c18c:             rowSource.needsRowLocationForDeferredCheckConstraints())
1:eac0369: 			rowlocation = new HeapRowLocation();
1:eac0369: 		else
1:eac0369: 			rowlocation = null;
1:eac0369: 
1:eac0369:         FormatableBitSet validColumns = rowSource.getValidColumns();
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369:  			// get the next row and its valid columns from the rowSource
1:eac0369: 			DataValueDescriptor[] row;
1:eac0369:             while ((row = rowSource.getNextRowFromRowSource()) != null)
1:eac0369:             {
1:eac0369:                 num_rows_loaded++;
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     // Make sure valid columns are in the list.  The RowUtil
1:eac0369:                     // call is too expensive to make in a released system for 
1:eac0369:                     // every insert.
1:eac0369:                     int invalidColumn = 
1:eac0369:                         RowUtil.columnOutOfRange(
1:eac0369:                             row, validColumns, heap.format_ids.length);
1:eac0369: 
1:eac0369:                     if (invalidColumn >= 0)
1:eac0369:                     {
1:eac0369:                         throw(StandardException.newException(
1:eac0369:                                 SQLState.HEAP_TEMPLATE_MISMATCH,
1:ce40a31:                                 invalidColumn, 
1:ce40a31:                                 heap.format_ids.length));
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 
1:eac0369: 				// Insert it onto this page as long as it can fit more rows.
1:eac0369: 				if ((rh = page.insert(
1:eac0369:                         row, validColumns, Page.INSERT_DEFAULT,
1:eac0369: 						AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD)) 
1:eac0369:                                 == null)
1:eac0369: 				{
1:eac0369: 					// Insert faied, row did not fit.  Get a new page.  
1:eac0369: 
1:eac0369: 					page.unlatch();
1:eac0369: 					page = null;
1:eac0369: 
1:eac0369: 					page = open_conglom.getContainer().addPage();
1:eac0369: 
1:eac0369: 					// RESOLVE (mikem) - no long rows yet so the following code
1:eac0369: 					// will get an exception from the raw store for a row that
1:eac0369: 					// does not fit on a page.
1:eac0369: 					//
1:eac0369: 					// Multi-thread considerations aside, the raw store will 
1:eac0369:                     // guarantee that any size row will fit on an empty page.
1:eac0369: 					rh = page.insert(
1:eac0369:                             row, validColumns, Page.INSERT_OVERFLOW,
1:eac0369: 							AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:eac0369: 
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// Else, the row fit.  If we are expected to call back with the
1:eac0369: 				// row location, do so.  All the while keep the page latched
1:eac0369: 				// and go for the next row.
2:eac0369: 				if (callbackWithRowLocation)
1:eac0369: 				{
1:eac0369: 					rowlocation.setFrom(rh);
1:eac0369: 					rowSource.rowLocation(rowlocation);
1:eac0369: 				}
1:af1c18c: 
1:af1c18c:                 if (rowSource.needsRowLocationForDeferredCheckConstraints()) {
1:af1c18c:                     rowlocation.setFrom(rh);
1:af1c18c:                     rowSource.offendingRowLocation(rowlocation,
1:af1c18c:                                                    heap.getContainerid());
1:af1c18c:                 }
1:eac0369: 			}
1:eac0369: 			page.unlatch();
1:eac0369: 			page = null;
1:eac0369: 
1:eac0369: 			// Done with the container, now we need to flush it to disk since
1:eac0369: 			// it is unlogged.
1:eac0369:             if (!heap.isTemporary())
1:eac0369:                 open_conglom.getContainer().flushContainer();
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369:             // If an error happened here, don't bother flushing the
1:eac0369:             // container since the changes should be rolled back anyhow.
1:eac0369:             close();
1:eac0369: 		}
1:eac0369:         return(num_rows_loaded);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     protected boolean lockRow(
1:eac0369:     RecordHandle    rh,
1:eac0369:     int             lock_oper,
1:eac0369:     boolean         wait,
1:eac0369:     int             lock_duration)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean ret_val;
1:eac0369:         boolean forUpdate = 
1:eac0369:             ((ConglomerateController.LOCK_UPD & lock_oper) != 0);
1:eac0369:         boolean forUpdateLock = 
1:eac0369:             ((ConglomerateController.LOCK_UPDATE_LOCKS & lock_oper) != 0);
1:eac0369: 
1:eac0369:         if (forUpdate && !forUpdateLock)
1:eac0369:         {
1:eac0369:             boolean forInsert = 
1:eac0369:                 ((ConglomerateController.LOCK_INS & lock_oper) != 0);
1:eac0369:             boolean forInsertPrevKey = 
1:eac0369:                 ((ConglomerateController.LOCK_INS_PREVKEY & lock_oper) != 0);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(!(forInsertPrevKey && forInsert));
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (lock_duration == TransactionManager.LOCK_INSTANT_DURATION)
1:eac0369:             {
1:eac0369:                 ret_val = 
2:eac0369:                     open_conglom.getContainer().getLockingPolicy().
1:eac0369:                         zeroDurationLockRecordForWrite(
1:eac0369:                             open_conglom.getRawTran(), rh, forInsertPrevKey, wait);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 ret_val = 
1:eac0369:                     open_conglom.getContainer().getLockingPolicy().
2:eac0369:                         lockRecordForWrite(
1:eac0369:                             open_conglom.getRawTran(), rh, forInsert, wait);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     (ConglomerateController.LOCK_INS & lock_oper) == 0);
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     (ConglomerateController.LOCK_INS_PREVKEY & lock_oper) == 0);
1:eac0369:             }
1:eac0369: 
1:eac0369:             ret_val = 
1:eac0369:                 open_conglom.getContainer().getLockingPolicy().lockRecordForRead(
1:eac0369:                     open_conglom.getRawTran(), 
1:eac0369:                     open_conglom.getContainer(), rh, wait, forUpdate);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: 
1:eac0369:     protected Page getUserPageNoWait(long pageno)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(open_conglom.getContainer().getUserPageNoWait(pageno));
1:eac0369:     }
1:eac0369:     protected Page getUserPageWait(long pageno)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(open_conglom.getContainer().getUserPageWait(pageno));
1:eac0369:     }
1:eac0369:     protected boolean lockRowAtSlotNoWaitExclusive(RecordHandle rh)
1:eac0369:         throws StandardException
1:eac0369:     {
1:9819cf8:         try {
1:9819cf8:             return(
1:9819cf8:                    open_conglom.getContainer().getLockingPolicy().
1:9819cf8:                    lockRecordForWrite
1:9819cf8:                    ( open_conglom.getRawTran(), rh, false, false) );
1:9819cf8:         }
1:9819cf8:         catch (StandardException se)
1:9819cf8:         {
1:9819cf8:             if ( se.isSelfDeadlock() ) { return false; }
1:9819cf8:             else { throw se; }
1:9819cf8:         }
1:eac0369:     }
1:eac0369:     protected void removePage(Page page)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         open_conglom.getContainer().removePage(page);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     public int insert(DataValueDescriptor[] row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (open_conglom.isClosed())
1:eac0369:         {
1:eac0369:             if (open_conglom.getHold())
1:eac0369:             {
1:eac0369:                 open_conglom.reopen();
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw(StandardException.newException(
1:eac0369:                         SQLState.HEAP_IS_CLOSED, 
1:eac0369:                         open_conglom.getConglomerate().getId()));
1:eac0369:             } 
1:eac0369:         }
1:eac0369: 
1:eac0369: 		doInsert(row);
1:eac0369: 
1:eac0369:         return(0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void insertAndFetchLocation(
1:eac0369:     DataValueDescriptor[] row, 
1:eac0369:     RowLocation           templateRowLocation)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (open_conglom.isClosed())
1:eac0369:         {
1:eac0369:             if (open_conglom.getHold())
1:eac0369:             {
1:eac0369:                 open_conglom.reopen();
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw(StandardException.newException(
1:eac0369:                         SQLState.HEAP_IS_CLOSED, 
1:eac0369:                         open_conglom.getConglomerate().getId()));
1:eac0369:             } 
1:eac0369:         }
1:eac0369: 
1:eac0369: 		RecordHandle rh = doInsert(row);
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 templateRowLocation instanceof HeapRowLocation);
1:eac0369:         }
1:eac0369: 		HeapRowLocation hrl = (HeapRowLocation) templateRowLocation;
1:eac0369: 		hrl.setFrom(rh);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the given row location.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @return true if lock was granted, only can be false if wait was false.
1:eac0369:      *
2:eac0369: 	 * @param loc       The "RowLocation" which describes the exact row to lock.
2:eac0369:      * @param wait      Should the lock call wait to be granted?
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean lockRow(
1:eac0369:     RowLocation     loc,
1:eac0369:     int             lock_operation,
1:eac0369:     boolean         wait,
1:eac0369:     int             lock_duration)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         RecordHandle rh = 
1:eac0369:             ((HeapRowLocation) loc).getRecordHandle(
1:eac0369:                 open_conglom.getContainer());
1:eac0369: 
1:eac0369:         return(lockRow(rh, lock_operation, wait, lock_duration));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * UnLock the given row location.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @param loc       The "RowLocation" which describes the row to unlock.
1:eac0369:      * @param forUpdate Row was previously Locked the record for read or update.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void unlockRowAfterRead(
1:eac0369:     RowLocation     loc,
1:eac0369:     boolean         forUpdate,
1:eac0369:     boolean         row_qualified)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 
1:eac0369:         RecordHandle rh = 
1:eac0369:             ((HeapRowLocation) loc).getRecordHandle(
1:eac0369:                 open_conglom.getContainer());
1:eac0369: 
1:eac0369:         open_conglom.getContainer().getLockingPolicy().
1:eac0369:             unlockRecordAfterRead(
1:eac0369:                 open_conglom.getRawTran(), 
1:eac0369:                 open_conglom.getContainer(),
1:eac0369:                 rh, 
1:eac0369:                 open_conglom.isForUpdate(),
1:eac0369:                 row_qualified);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the given record id/page num pair.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access, to lock "special" locks formed from
1:eac0369:      * the Recordhandle.* reserved constants for page specific locks.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @return true if lock was granted, only can be false if wait was false.
1:eac0369:      *
1:75b112d:      * @param page_num          Page number of row to lock.
1:75b112d:      * @param record_id         Record id of row on page_num to lock.
1:75b112d:      * @param lock_operation    Desc of what to lock for, ie. update, insert ...
1:75b112d:      * @param wait              Should the lock call wait to be granted?
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean lockRow(
1:eac0369:     long            page_num,
1:eac0369:     int             record_id,
1:eac0369:     int             lock_operation,
1:eac0369:     boolean         wait,
1:eac0369:     int             lock_duration)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean ret_val;
1:eac0369: 
1:eac0369:         RecordHandle rh = 
1:eac0369:             open_conglom.getContainer().makeRecordHandle(page_num, record_id);
1:eac0369: 
1:eac0369:         return(lockRow(rh, lock_operation, wait, lock_duration));
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (open_conglom.isClosed())
1:eac0369:         {
1:eac0369:             if (open_conglom.getHold())
1:eac0369:             {
1:eac0369:                 open_conglom.reopen();
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw(StandardException.newException(
1:eac0369:                         SQLState.HEAP_IS_CLOSED, 
1:eac0369:                         open_conglom.getConglomerate().getId()));
1:eac0369:             } 
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return new HeapRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of XXXX class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:040d5c5:     public OpenConglomerate getOpenConglomerate() {
1:040d5c5:         return open_conglom;
1:040d5c5:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         invalidColumn, 
1:                         heap.format_ids.length));
/////////////////////////////////////////////////////////////////////////
1:                     heap.getId().getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                                 invalidColumn, 
1:                                 heap.format_ids.length));
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             return(
1:                    open_conglom.getContainer().getLockingPolicy().
1:                    lockRecordForWrite
1:                    ( open_conglom.getRawTran(), rh, false, false) );
1:         }
1:         catch (StandardException se)
1:         {
1:             if ( se.isSelfDeadlock() ) { return false; }
1:             else { throw se; }
1:         }
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:                 pos.current_page.getPageKey()));
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:                 heap.collation_ids,
commit:75b112d
/////////////////////////////////////////////////////////////////////////
1:      * @param page_num          Page number of row to lock.
1:      * @param record_id         Record id of row on page_num to lock.
1:      * @param lock_operation    Desc of what to lock for, ie. update, insert ...
1:      * @param wait              Should the lock call wait to be granted?
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1:      *     GenericConglomerateController class:
/////////////////////////////////////////////////////////////////////////
1:      * Check and purge committed deleted rows on a page.
1:      * <p>
1:      * 
1: 	 * @return true, if no purging has been done on page, and thus latch
1:      *         can be released before end transaction.  Otherwise the latch
1:      *         on the page can not be released before commit.
1:      *
1:      * @param page   A non-null, latched page must be passed in.  If all
1:      *               rows on page are purged, then page will be removed and
1:      *               latch released.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected final boolean purgeCommittedDeletes(
1:     Page                page)
1:         throws StandardException
1:     {
1:         boolean purgingDone = false;
1: 
1:         // The number records that can be reclaimed is:
1:         // total recs - recs_not_deleted
1:         int num_possible_commit_delete = 
1:             page.recordCount() - page.nonDeletedRecordCount();
1: 
1:         if (num_possible_commit_delete > 0)
1:         {
1:             // loop backward so that purges which affect the slot table 
1:             // don't affect the loop (ie. they only move records we 
1:             // have already looked at).
1:             for (int slot_no = page.recordCount() - 1; 
1:                  slot_no >= 0; 
1:                  slot_no--) 
1:             {
1:                 boolean row_is_committed_delete = 
1:                     page.isDeletedAtSlot(slot_no);
1: 
1:                 if (row_is_committed_delete)
1:                 {
1:                     // At this point we only know that the row is
1:                     // deleted, not whether it is committed.
1: 
1:                     // see if we can purge the row, by getting an
1:                     // exclusive lock on the row.  If it is marked
1:                     // deleted and we can get this lock, then it
1:                     // must be a committed delete and we can purge 
1:                     // it.
1: 
1:                     RecordHandle rh =
1:                         page.fetchFromSlot(
1:                             (RecordHandle) null,
1:                             slot_no,
1:                             RowUtil.EMPTY_ROW,
1:                             RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,
1:                             true);
1: 
1:                     row_is_committed_delete =
1:                         this.lockRowAtSlotNoWaitExclusive(rh);
1: 
1:                     if (row_is_committed_delete)
1:                     {
1:                         purgingDone = true;
1: 
1:                         page.purgeAtSlot(slot_no, 1, false);
1:                     }
1:                 }
1:             }
1:         }
1:         if (page.recordCount() == 0)
1:         {
1: 
1:             // Deallocate the current page with 0 rows on it.
1:             this.removePage(page);
1: 
1:             // removePage guarantees to unlatch the page even if an
1:             // exception is thrown. The page is protected against reuse
1:             // because removePage locks it with a dealloc lock, so it
1:             // is OK to release the latch even after a purgeAtSlot is
1:             // called.
1:             // @see ContainerHandle#removePage
1: 
1:             purgingDone = true;
1:         }
1: 
1:         return(purgingDone);
1:     }
1: 
1:     /**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory;
/////////////////////////////////////////////////////////////////////////
1:         if (callbackWithRowLocation ||
1:             rowSource.needsRowLocationForDeferredCheckConstraints())
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (rowSource.needsRowLocationForDeferredCheckConstraints()) {
1:                     rowlocation.setFrom(rh);
1:                     rowSource.offendingRowLocation(rowlocation,
1:                                                    heap.getContainerid());
1:                 }
commit:040d5c5
/////////////////////////////////////////////////////////////////////////
1:     public OpenConglomerate getOpenConglomerate() {
1:         return open_conglom;
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:18176ce
/////////////////////////////////////////////////////////////////////////
0:                     new Long(heap.getId().getContainerId()));
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapController
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController;
1: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1: 
1: **/
1: 
1: public class HeapController 
1:     extends GenericConglomerateController 
1:     implements ConglomerateController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Protected concrete impl of abstract methods of 
0:      *     GenericCongloemrateController class:
1:      **************************************************************************
1:      */
1:     protected final void getRowPositionFromRowLocation(
1:     RowLocation row_loc,
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(row_loc instanceof HeapRowLocation);
1:         }
1:         pos.current_rh = 
1:             ((HeapRowLocation) row_loc).getRecordHandle(
1:                 open_conglom.getContainer());
1:         pos.current_rh_qualified = true;
1:     }
1: 
1:     protected void queueDeletePostCommitWork(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         TransactionManager xact_mgr = open_conglom.getXactMgr();
1: 
1:         xact_mgr.addPostCommitWork(
1:             new HeapPostCommit(
1:                 xact_mgr.getAccessManager(), 
0:                 (Heap) open_conglom.getConglomerate(),
0:                 pos.current_page.getPageNumber()));
1:     }
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Insert a new row into the heap.
1:      * <p>
1:      * Overflow policy:
1:      * The current heap access method implements an algorithm that optimizes
1:      * for fetch efficiency vs. space efficiency.  A row will not be over
1:      * flowed unless it is bigger than a page.  If it is bigger than a page
1:      * then it's initial part will be placed on a page and then subsequent
1:      * parts will be overflowed to other pages.
1:      * <p>
1:      *
1: 	 * @return The record handle of the inserted row.
1:      *
1:      * @param row           The row to insert.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	private RecordHandle doInsert(DataValueDescriptor[] row)
1: 		throws StandardException
1: 	{
1: 		Page page = null;
1:         byte  insert_mode;
1: 		
1:         RecordHandle rh;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             Heap heap = (Heap) open_conglom.getConglomerate();
1:             // Make sure valid columns are in the list.  The RowUtil
1:             // call is too expensive to make in a released system for
1:             // every insert.
1: 
1:             int invalidColumn = 
1:                 RowUtil.columnOutOfRange(
1:                     row, null, heap.format_ids.length);
1: 
1:             if (invalidColumn >= 0)
1:             {
1:                 throw(StandardException.newException(
1:                         SQLState.HEAP_TEMPLATE_MISMATCH,
0:                         new Long(invalidColumn), 
0:                         new Long(heap.format_ids.length)));
1:             }
1:         }
1: 
1:         // Get the last page that was returned for insert or the last page
1:         // that was allocated.
1:         page = open_conglom.getContainer().getPageForInsert(0);
1: 
1:         if (page != null) {
1: 
1:             // if there are 0 rows on the page allow the insert to overflow.
1:             insert_mode = 
1:                 (page.recordCount() == 0) ? 
1:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
1: 
1:             // Check to see if there is enough space on the page
1:             // for the row.
1:             rh = page.insert(row, null, insert_mode,
1: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:             page.unlatch();
1:             page = null;
1: 
1:             // If we have found a page with enough space for the row,
1:             // insert it and release exclusive access to the page.
1:             if (rh != null)
1:             {
1:                 return rh;
1: 
1:             }
1:         }
1: 
1:         // If the last inserted page is now full, or RawStore have
1:         // forgotten what it was, or the row cannot fit on the last
1:         // inserted page, try to have rawStore get a relatively unfilled
1:         // page.
1: 
1:         page = 
1:             open_conglom.getContainer().getPageForInsert(
1:                 ContainerHandle.GET_PAGE_UNFILLED);
1: 
1:         if (page != null)
1:         {
1:             // Do the insert all over again hoping that it will fit into
1:             // this page, and if not, allocate a new page.
1: 
1:             // if there are 0 rows on the page allow the insert to overflow.
1:             insert_mode = 
1:                 (page.recordCount() == 0) ? 
1:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
1:             
1:             rh = page.insert(row, null, insert_mode,
1: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1: 
1:             page.unlatch();
1:             page = null;
1: 
1:             // If we have found a page with enough space for the row,
1:             // insert it and release exclusive access to the page.
1:             if (rh != null)
1:             {
1:                 return rh;
1:             }
1:         }
1: 
1:         page = open_conglom.getContainer().addPage();
1: 
1:         // At this point with long rows the raw store will guarantee
1:         // that any size row will fit on an empty page.
1: 
1:         rh = page.insert(row, null, Page.INSERT_OVERFLOW,
1: 			AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:         page.unlatch();
1:         page = null;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             // a null will only be returned if this page is not empty
1:             SanityManager.ASSERT(rh != null);
1:         }
1: 
1:         return rh;
1: 	}
1: 
1: 	protected long load(
1:     TransactionManager      xact_manager,
1:     Heap                    heap,
1:     boolean                 createConglom,
1:     RowLocationRetRowSource rowSource)
1: 		 throws StandardException
1: 	{
1:         long    num_rows_loaded = 0;
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1: 			SanityManager.ASSERT(open_conglom == null,
1: 				"load expects container handle to be closed on entry.");
1:         }
1: 
1: 		// The individual rows that are inserted are not logged.  To use a
1: 		// logged interface, use insert.  RESOLVE: do we want to allow client
1: 		// to use the load interface even for logged insert?
1: 		int mode = 
1:             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_UNLOGGED); 
1: 
1: 		// If the container is being created in the same operation, don't log
1: 		// page allocation.  
1: 		if (createConglom)
1: 			mode |= ContainerHandle.MODE_CREATE_UNLOGGED;
1: 
1:         OpenConglomerate open_conglom = new OpenHeap();
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 heap,
1:                 heap.format_ids,
1:                 xact_manager,
1:                 xact_manager.getRawStoreXact(),
1:                 false,
1:                 mode,
1:                 TransactionController.MODE_TABLE,
1:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:                     LockingPolicy.MODE_CONTAINER,
1:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:                 (DynamicCompiledOpenConglomInfo) null) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(heap.id.getContainerId()));
1:         }
1: 
1:         this.init(open_conglom);
1: 
1: 		// For bulk loading, we always use only brand new page because the row
1: 		// insertion itself is not logged.  We cannot pollute pages with
1: 		// pre-existing data with unlogged rows because nobody is going to wipe
1: 		// out these rows if the transaction rolls back.  We are counting on
1: 		// the allocation page rollback to obliterate these rows if the
1: 		// transaction fails, or, in the CREAT_UNLOGGED case, the whole
1: 		// container to be removed.
1: 
1: 		Page page = open_conglom.getContainer().addPage();
1: 
1: 		boolean callbackWithRowLocation = rowSource.needsRowLocation();
1: 		RecordHandle rh;
1: 		HeapRowLocation rowlocation;
1: 
1: 		if (callbackWithRowLocation)
1: 			rowlocation = new HeapRowLocation();
1: 		else
1: 			rowlocation = null;
1: 
1:         FormatableBitSet validColumns = rowSource.getValidColumns();
1: 
1: 		try
1: 		{
1:  			// get the next row and its valid columns from the rowSource
1: 			DataValueDescriptor[] row;
1:             while ((row = rowSource.getNextRowFromRowSource()) != null)
1:             {
1:                 num_rows_loaded++;
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     // Make sure valid columns are in the list.  The RowUtil
1:                     // call is too expensive to make in a released system for 
1:                     // every insert.
1:                     int invalidColumn = 
1:                         RowUtil.columnOutOfRange(
1:                             row, validColumns, heap.format_ids.length);
1: 
1:                     if (invalidColumn >= 0)
1:                     {
1:                         throw(StandardException.newException(
1:                                 SQLState.HEAP_TEMPLATE_MISMATCH,
0:                                 new Long(invalidColumn), 
0:                                 new Long(heap.format_ids.length)));
1:                     }
1:                 }
1: 
1: 
1: 				// Insert it onto this page as long as it can fit more rows.
1: 				if ((rh = page.insert(
1:                         row, validColumns, Page.INSERT_DEFAULT,
1: 						AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD)) 
1:                                 == null)
1: 				{
1: 					// Insert faied, row did not fit.  Get a new page.  
1: 
1: 					page.unlatch();
1: 					page = null;
1: 
1: 					page = open_conglom.getContainer().addPage();
1: 
1: 					// RESOLVE (mikem) - no long rows yet so the following code
1: 					// will get an exception from the raw store for a row that
1: 					// does not fit on a page.
1: 					//
1: 					// Multi-thread considerations aside, the raw store will 
1:                     // guarantee that any size row will fit on an empty page.
1: 					rh = page.insert(
1:                             row, validColumns, Page.INSERT_OVERFLOW,
1: 							AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1: 
1: 				}
1: 
1: 				// Else, the row fit.  If we are expected to call back with the
1: 				// row location, do so.  All the while keep the page latched
1: 				// and go for the next row.
1: 				if (callbackWithRowLocation)
1: 				{
1: 					rowlocation.setFrom(rh);
1: 					rowSource.rowLocation(rowlocation);
1: 				}
1: 			}
1: 			page.unlatch();
1: 			page = null;
1: 
1: 			// Done with the container, now we need to flush it to disk since
1: 			// it is unlogged.
1:             if (!heap.isTemporary())
1:                 open_conglom.getContainer().flushContainer();
1: 		}
1: 		finally
1: 		{
1:             // If an error happened here, don't bother flushing the
1:             // container since the changes should be rolled back anyhow.
1:             close();
1: 		}
1:         return(num_rows_loaded);
1: 	}
1: 
1:     protected boolean lockRow(
1:     RecordHandle    rh,
1:     int             lock_oper,
1:     boolean         wait,
1:     int             lock_duration)
1:         throws StandardException
1:     {
1:         boolean ret_val;
1:         boolean forUpdate = 
1:             ((ConglomerateController.LOCK_UPD & lock_oper) != 0);
1:         boolean forUpdateLock = 
1:             ((ConglomerateController.LOCK_UPDATE_LOCKS & lock_oper) != 0);
1: 
1:         if (forUpdate && !forUpdateLock)
1:         {
1:             boolean forInsert = 
1:                 ((ConglomerateController.LOCK_INS & lock_oper) != 0);
1:             boolean forInsertPrevKey = 
1:                 ((ConglomerateController.LOCK_INS_PREVKEY & lock_oper) != 0);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(!(forInsertPrevKey && forInsert));
1:             }
1: 
1:             if (lock_duration == TransactionManager.LOCK_INSTANT_DURATION)
1:             {
1:                 ret_val = 
1:                     open_conglom.getContainer().getLockingPolicy().
1:                         zeroDurationLockRecordForWrite(
1:                             open_conglom.getRawTran(), rh, forInsertPrevKey, wait);
1:             }
1:             else
1:             {
1:                 ret_val = 
1:                     open_conglom.getContainer().getLockingPolicy().
1:                         lockRecordForWrite(
1:                             open_conglom.getRawTran(), rh, forInsert, wait);
1:             }
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     (ConglomerateController.LOCK_INS & lock_oper) == 0);
1:                 SanityManager.ASSERT(
1:                     (ConglomerateController.LOCK_INS_PREVKEY & lock_oper) == 0);
1:             }
1: 
1:             ret_val = 
1:                 open_conglom.getContainer().getLockingPolicy().lockRecordForRead(
1:                     open_conglom.getRawTran(), 
1:                     open_conglom.getContainer(), rh, wait, forUpdate);
1:         }
1: 
1:         return(ret_val);
1:     }
1: 
1:     protected Page getUserPageNoWait(long pageno)
1:         throws StandardException
1:     {
1:         return(open_conglom.getContainer().getUserPageNoWait(pageno));
1:     }
1:     protected Page getUserPageWait(long pageno)
1:         throws StandardException
1:     {
1:         return(open_conglom.getContainer().getUserPageWait(pageno));
1:     }
1:     protected boolean lockRowAtSlotNoWaitExclusive(RecordHandle rh)
1:         throws StandardException
1:     {
0:         return(
1:             open_conglom.getContainer().getLockingPolicy().
1:                 lockRecordForWrite(
0:                     open_conglom.getRawTran(), rh, false, false));
1:     }
1:     protected void removePage(Page page)
1:         throws StandardException
1:     {
1:         open_conglom.getContainer().removePage(page);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     public int insert(DataValueDescriptor[] row)
1: 		throws StandardException
1: 	{
1: 		if (open_conglom.isClosed())
1:         {
1:             if (open_conglom.getHold())
1:             {
1:                 open_conglom.reopen();
1:             }
1:             else
1:             {
1:                 throw(StandardException.newException(
1:                         SQLState.HEAP_IS_CLOSED, 
1:                         open_conglom.getConglomerate().getId()));
1:             } 
1:         }
1: 
1: 		doInsert(row);
1: 
1:         return(0);
1: 	}
1: 
1: 	public void insertAndFetchLocation(
1:     DataValueDescriptor[] row, 
1:     RowLocation           templateRowLocation)
1: 		throws StandardException
1: 	{
1: 		if (open_conglom.isClosed())
1:         {
1:             if (open_conglom.getHold())
1:             {
1:                 open_conglom.reopen();
1:             }
1:             else
1:             {
1:                 throw(StandardException.newException(
1:                         SQLState.HEAP_IS_CLOSED, 
1:                         open_conglom.getConglomerate().getId()));
1:             } 
1:         }
1: 
1: 		RecordHandle rh = doInsert(row);
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 templateRowLocation instanceof HeapRowLocation);
1:         }
1: 		HeapRowLocation hrl = (HeapRowLocation) templateRowLocation;
1: 		hrl.setFrom(rh);
1: 	}
1: 
1:     /**
1:      * Lock the given row location.
1:      * <p>
1:      * Should only be called by access.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @return true if lock was granted, only can be false if wait was false.
1:      *
1: 	 * @param loc       The "RowLocation" which describes the exact row to lock.
1:      * @param wait      Should the lock call wait to be granted?
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean lockRow(
1:     RowLocation     loc,
1:     int             lock_operation,
1:     boolean         wait,
1:     int             lock_duration)
1:         throws StandardException
1:     {
1:         RecordHandle rh = 
1:             ((HeapRowLocation) loc).getRecordHandle(
1:                 open_conglom.getContainer());
1: 
1:         return(lockRow(rh, lock_operation, wait, lock_duration));
1:     }
1: 
1:     /**
1:      * UnLock the given row location.
1:      * <p>
1:      * Should only be called by access.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @param loc       The "RowLocation" which describes the row to unlock.
1:      * @param forUpdate Row was previously Locked the record for read or update.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void unlockRowAfterRead(
1:     RowLocation     loc,
1:     boolean         forUpdate,
1:     boolean         row_qualified)
1:         throws StandardException
1:     {
1: 
1:         RecordHandle rh = 
1:             ((HeapRowLocation) loc).getRecordHandle(
1:                 open_conglom.getContainer());
1: 
1:         open_conglom.getContainer().getLockingPolicy().
1:             unlockRecordAfterRead(
1:                 open_conglom.getRawTran(), 
1:                 open_conglom.getContainer(),
1:                 rh, 
1:                 open_conglom.isForUpdate(),
1:                 row_qualified);
1:     }
1: 
1: 
1:     /**
1:      * Lock the given record id/page num pair.
1:      * <p>
1:      * Should only be called by access, to lock "special" locks formed from
1:      * the Recordhandle.* reserved constants for page specific locks.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @return true if lock was granted, only can be false if wait was false.
1:      *
1: 	 * @param loc       The "RowLocation" which describes the exact row to lock.
0:      * @param forUpdate Lock the record for read or write.
0:      * @param forInsert is row Lock for insert?
1:      * @param wait      Should the lock call wait to be granted?
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean lockRow(
1:     long            page_num,
1:     int             record_id,
1:     int             lock_operation,
1:     boolean         wait,
1:     int             lock_duration)
1:         throws StandardException
1:     {
1:         boolean ret_val;
1: 
1:         RecordHandle rh = 
1:             open_conglom.getContainer().makeRecordHandle(page_num, record_id);
1: 
1:         return(lockRow(rh, lock_operation, wait, lock_duration));
1:     }
1: 
1: 	public RowLocation newRowLocationTemplate()
1: 		throws StandardException
1: 	{
1: 		if (open_conglom.isClosed())
1:         {
1:             if (open_conglom.getHold())
1:             {
1:                 open_conglom.reopen();
1:             }
1:             else
1:             {
1:                 throw(StandardException.newException(
1:                         SQLState.HEAP_IS_CLOSED, 
1:                         open_conglom.getConglomerate().getId()));
1:             } 
1:         }
1: 
1: 		return new HeapRowLocation();
1: 	}
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods of XXXX class:
1:      **************************************************************************
1:      */
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
0: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerateController;
0: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0: 
0: **/
0: 
0: public class HeapController 
0:     extends GenericConglomerateController 
0:     implements ConglomerateController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Protected concrete impl of abstract methods of 
0:      *     GenericCongloemrateController class:
0:      **************************************************************************
0:      */
0:     protected final void getRowPositionFromRowLocation(
0:     RowLocation row_loc,
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(row_loc instanceof HeapRowLocation);
0:         }
0:         pos.current_rh = 
0:             ((HeapRowLocation) row_loc).getRecordHandle(
0:                 open_conglom.getContainer());
0:         pos.current_rh_qualified = true;
0:     }
0: 
0:     protected void queueDeletePostCommitWork(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         TransactionManager xact_mgr = open_conglom.getXactMgr();
0: 
0:         xact_mgr.addPostCommitWork(
0:             new HeapPostCommit(
0:                 xact_mgr.getAccessManager(), 
0:                 (Heap) open_conglom.getConglomerate(),
0:                 pos.current_page.getPageNumber()));
0:     }
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Insert a new row into the heap.
0:      * <p>
0:      * Overflow policy:
0:      * The current heap access method implements an algorithm that optimizes
0:      * for fetch efficiency vs. space efficiency.  A row will not be over
0:      * flowed unless it is bigger than a page.  If it is bigger than a page
0:      * then it's initial part will be placed on a page and then subsequent
0:      * parts will be overflowed to other pages.
0:      * <p>
0:      *
0: 	 * @return The record handle of the inserted row.
0:      *
0:      * @param row           The row to insert.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	private RecordHandle doInsert(DataValueDescriptor[] row)
0: 		throws StandardException
0: 	{
0: 		Page page = null;
0:         byte  insert_mode;
0: 		
0:         RecordHandle rh;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             Heap heap = (Heap) open_conglom.getConglomerate();
0:             // Make sure valid columns are in the list.  The RowUtil
0:             // call is too expensive to make in a released system for
0:             // every insert.
0: 
0:             int invalidColumn = 
0:                 RowUtil.columnOutOfRange(
0:                     row, null, heap.format_ids.length);
0: 
0:             if (invalidColumn >= 0)
0:             {
0:                 throw(StandardException.newException(
0:                         SQLState.HEAP_TEMPLATE_MISMATCH,
0:                         new Long(invalidColumn), 
0:                         new Long(heap.format_ids.length)));
0:             }
0:         }
0: 
0:         // Get the last page that was returned for insert or the last page
0:         // that was allocated.
0:         page = open_conglom.getContainer().getPageForInsert(0);
0: 
0:         if (page != null) {
0: 
0:             // if there are 0 rows on the page allow the insert to overflow.
0:             insert_mode = 
0:                 (page.recordCount() == 0) ? 
0:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
0: 
0:             // Check to see if there is enough space on the page
0:             // for the row.
0:             rh = page.insert(row, null, insert_mode,
0: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
0:             page.unlatch();
0:             page = null;
0: 
0:             // If we have found a page with enough space for the row,
0:             // insert it and release exclusive access to the page.
0:             if (rh != null)
0:             {
0:                 return rh;
0: 
0:             }
0:         }
0: 
0:         // If the last inserted page is now full, or RawStore have
0:         // forgotten what it was, or the row cannot fit on the last
0:         // inserted page, try to have rawStore get a relatively unfilled
0:         // page.
0: 
0:         page = 
0:             open_conglom.getContainer().getPageForInsert(
0:                 ContainerHandle.GET_PAGE_UNFILLED);
0: 
0:         if (page != null)
0:         {
0:             // Do the insert all over again hoping that it will fit into
0:             // this page, and if not, allocate a new page.
0: 
0:             // if there are 0 rows on the page allow the insert to overflow.
0:             insert_mode = 
0:                 (page.recordCount() == 0) ? 
0:                     Page.INSERT_OVERFLOW : Page.INSERT_DEFAULT;
0:             
0:             rh = page.insert(row, null, insert_mode,
0: 				AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
0: 
0:             page.unlatch();
0:             page = null;
0: 
0:             // If we have found a page with enough space for the row,
0:             // insert it and release exclusive access to the page.
0:             if (rh != null)
0:             {
0:                 return rh;
0:             }
0:         }
0: 
0:         page = open_conglom.getContainer().addPage();
0: 
0:         // At this point with long rows the raw store will guarantee
0:         // that any size row will fit on an empty page.
0: 
0:         rh = page.insert(row, null, Page.INSERT_OVERFLOW,
0: 			AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
0:         page.unlatch();
0:         page = null;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             // a null will only be returned if this page is not empty
0:             SanityManager.ASSERT(rh != null);
0:         }
0: 
0:         return rh;
0: 	}
0: 
0: 	protected long load(
0:     TransactionManager      xact_manager,
0:     Heap                    heap,
0:     boolean                 createConglom,
0:     RowLocationRetRowSource rowSource)
0: 		 throws StandardException
0: 	{
0:         long    num_rows_loaded = 0;
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0: 			SanityManager.ASSERT(open_conglom == null,
0: 				"load expects container handle to be closed on entry.");
0:         }
0: 
0: 		// The individual rows that are inserted are not logged.  To use a
0: 		// logged interface, use insert.  RESOLVE: do we want to allow client
0: 		// to use the load interface even for logged insert?
0: 		int mode = 
0:             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_UNLOGGED); 
0: 
0: 		// If the container is being created in the same operation, don't log
0: 		// page allocation.  
0: 		if (createConglom)
0: 			mode |= ContainerHandle.MODE_CREATE_UNLOGGED;
0: 
0:         OpenConglomerate open_conglom = new OpenHeap();
0: 
0:         if (open_conglom.init(
0:                 (ContainerHandle) null,
0:                 heap,
0:                 heap.format_ids,
0:                 xact_manager,
0:                 xact_manager.getRawStoreXact(),
0:                 false,
0:                 mode,
0:                 TransactionController.MODE_TABLE,
0:                 xact_manager.getRawStoreXact().newLockingPolicy(
0:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_SERIALIZABLE, true),
0:                 (DynamicCompiledOpenConglomInfo) null) == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(heap.id.getContainerId()));
0:         }
0: 
0:         this.init(open_conglom);
0: 
0: 		// For bulk loading, we always use only brand new page because the row
0: 		// insertion itself is not logged.  We cannot pollute pages with
0: 		// pre-existing data with unlogged rows because nobody is going to wipe
0: 		// out these rows if the transaction rolls back.  We are counting on
0: 		// the allocation page rollback to obliterate these rows if the
0: 		// transaction fails, or, in the CREAT_UNLOGGED case, the whole
0: 		// container to be removed.
0: 
0: 		Page page = open_conglom.getContainer().addPage();
0: 
0: 		boolean callbackWithRowLocation = rowSource.needsRowLocation();
0: 		RecordHandle rh;
0: 		HeapRowLocation rowlocation;
0: 
0: 		if (callbackWithRowLocation)
0: 			rowlocation = new HeapRowLocation();
0: 		else
0: 			rowlocation = null;
0: 
0:         FormatableBitSet validColumns = rowSource.getValidColumns();
0: 
0: 		try
0: 		{
0:  			// get the next row and its valid columns from the rowSource
0: 			DataValueDescriptor[] row;
0:             while ((row = rowSource.getNextRowFromRowSource()) != null)
0:             {
0:                 num_rows_loaded++;
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     // Make sure valid columns are in the list.  The RowUtil
0:                     // call is too expensive to make in a released system for 
0:                     // every insert.
0:                     int invalidColumn = 
0:                         RowUtil.columnOutOfRange(
0:                             row, validColumns, heap.format_ids.length);
0: 
0:                     if (invalidColumn >= 0)
0:                     {
0:                         throw(StandardException.newException(
0:                                 SQLState.HEAP_TEMPLATE_MISMATCH,
0:                                 new Long(invalidColumn), 
0:                                 new Long(heap.format_ids.length)));
0:                     }
0:                 }
0: 
0: 
0: 				// Insert it onto this page as long as it can fit more rows.
0: 				if ((rh = page.insert(
0:                         row, validColumns, Page.INSERT_DEFAULT,
0: 						AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD)) 
0:                                 == null)
0: 				{
0: 					// Insert faied, row did not fit.  Get a new page.  
0: 
0: 					page.unlatch();
0: 					page = null;
0: 
0: 					page = open_conglom.getContainer().addPage();
0: 
0: 					// RESOLVE (mikem) - no long rows yet so the following code
0: 					// will get an exception from the raw store for a row that
0: 					// does not fit on a page.
0: 					//
0: 					// Multi-thread considerations aside, the raw store will 
0:                     // guarantee that any size row will fit on an empty page.
0: 					rh = page.insert(
0:                             row, validColumns, Page.INSERT_OVERFLOW,
0: 							AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
0: 
0: 				}
0: 
0: 				// Else, the row fit.  If we are expected to call back with the
0: 				// row location, do so.  All the while keep the page latched
0: 				// and go for the next row.
0: 				if (callbackWithRowLocation)
0: 				{
0: 					rowlocation.setFrom(rh);
0: 					rowSource.rowLocation(rowlocation);
0: 				}
0: 			}
0: 			page.unlatch();
0: 			page = null;
0: 
0: 			// Done with the container, now we need to flush it to disk since
0: 			// it is unlogged.
0:             if (!heap.isTemporary())
0:                 open_conglom.getContainer().flushContainer();
0: 		}
0: 		finally
0: 		{
0:             // If an error happened here, don't bother flushing the
0:             // container since the changes should be rolled back anyhow.
0:             close();
0: 		}
0:         return(num_rows_loaded);
0: 	}
0: 
0:     protected boolean lockRow(
0:     RecordHandle    rh,
0:     int             lock_oper,
0:     boolean         wait,
0:     int             lock_duration)
0:         throws StandardException
0:     {
0:         boolean ret_val;
0:         boolean forUpdate = 
0:             ((ConglomerateController.LOCK_UPD & lock_oper) != 0);
0:         boolean forUpdateLock = 
0:             ((ConglomerateController.LOCK_UPDATE_LOCKS & lock_oper) != 0);
0: 
0:         if (forUpdate && !forUpdateLock)
0:         {
0:             boolean forInsert = 
0:                 ((ConglomerateController.LOCK_INS & lock_oper) != 0);
0:             boolean forInsertPrevKey = 
0:                 ((ConglomerateController.LOCK_INS_PREVKEY & lock_oper) != 0);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(!(forInsertPrevKey && forInsert));
0:             }
0: 
0:             if (lock_duration == TransactionManager.LOCK_INSTANT_DURATION)
0:             {
0:                 ret_val = 
0:                     open_conglom.getContainer().getLockingPolicy().
0:                         zeroDurationLockRecordForWrite(
0:                             open_conglom.getRawTran(), rh, forInsertPrevKey, wait);
0:             }
0:             else
0:             {
0:                 ret_val = 
0:                     open_conglom.getContainer().getLockingPolicy().
0:                         lockRecordForWrite(
0:                             open_conglom.getRawTran(), rh, forInsert, wait);
0:             }
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     (ConglomerateController.LOCK_INS & lock_oper) == 0);
0:                 SanityManager.ASSERT(
0:                     (ConglomerateController.LOCK_INS_PREVKEY & lock_oper) == 0);
0:             }
0: 
0:             ret_val = 
0:                 open_conglom.getContainer().getLockingPolicy().lockRecordForRead(
0:                     open_conglom.getRawTran(), 
0:                     open_conglom.getContainer(), rh, wait, forUpdate);
0:         }
0: 
0:         return(ret_val);
0:     }
0: 
0:     protected Page getUserPageNoWait(long pageno)
0:         throws StandardException
0:     {
0:         return(open_conglom.getContainer().getUserPageNoWait(pageno));
0:     }
0:     protected Page getUserPageWait(long pageno)
0:         throws StandardException
0:     {
0:         return(open_conglom.getContainer().getUserPageWait(pageno));
0:     }
0:     protected boolean lockRowAtSlotNoWaitExclusive(RecordHandle rh)
0:         throws StandardException
0:     {
0:         return(
0:             open_conglom.getContainer().getLockingPolicy().
0:                 lockRecordForWrite(
0:                     open_conglom.getRawTran(), rh, false, false));
0:     }
0:     protected void removePage(Page page)
0:         throws StandardException
0:     {
0:         open_conglom.getContainer().removePage(page);
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     public int insert(DataValueDescriptor[] row)
0: 		throws StandardException
0: 	{
0: 		if (open_conglom.isClosed())
0:         {
0:             if (open_conglom.getHold())
0:             {
0:                 open_conglom.reopen();
0:             }
0:             else
0:             {
0:                 throw(StandardException.newException(
0:                         SQLState.HEAP_IS_CLOSED, 
0:                         open_conglom.getConglomerate().getId()));
0:             } 
0:         }
0: 
0: 		doInsert(row);
0: 
0:         return(0);
0: 	}
0: 
0: 	public void insertAndFetchLocation(
0:     DataValueDescriptor[] row, 
0:     RowLocation           templateRowLocation)
0: 		throws StandardException
0: 	{
0: 		if (open_conglom.isClosed())
0:         {
0:             if (open_conglom.getHold())
0:             {
0:                 open_conglom.reopen();
0:             }
0:             else
0:             {
0:                 throw(StandardException.newException(
0:                         SQLState.HEAP_IS_CLOSED, 
0:                         open_conglom.getConglomerate().getId()));
0:             } 
0:         }
0: 
0: 		RecordHandle rh = doInsert(row);
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 templateRowLocation instanceof HeapRowLocation);
0:         }
0: 		HeapRowLocation hrl = (HeapRowLocation) templateRowLocation;
0: 		hrl.setFrom(rh);
0: 	}
0: 
0:     /**
0:      * Lock the given row location.
0:      * <p>
0:      * Should only be called by access.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @return true if lock was granted, only can be false if wait was false.
0:      *
0: 	 * @param loc       The "RowLocation" which describes the exact row to lock.
0:      * @param wait      Should the lock call wait to be granted?
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean lockRow(
0:     RowLocation     loc,
0:     int             lock_operation,
0:     boolean         wait,
0:     int             lock_duration)
0:         throws StandardException
0:     {
0:         RecordHandle rh = 
0:             ((HeapRowLocation) loc).getRecordHandle(
0:                 open_conglom.getContainer());
0: 
0:         return(lockRow(rh, lock_operation, wait, lock_duration));
0:     }
0: 
0:     /**
0:      * UnLock the given row location.
0:      * <p>
0:      * Should only be called by access.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @param loc       The "RowLocation" which describes the row to unlock.
0:      * @param forUpdate Row was previously Locked the record for read or update.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void unlockRowAfterRead(
0:     RowLocation     loc,
0:     boolean         forUpdate,
0:     boolean         row_qualified)
0:         throws StandardException
0:     {
0: 
0:         RecordHandle rh = 
0:             ((HeapRowLocation) loc).getRecordHandle(
0:                 open_conglom.getContainer());
0: 
0:         open_conglom.getContainer().getLockingPolicy().
0:             unlockRecordAfterRead(
0:                 open_conglom.getRawTran(), 
0:                 open_conglom.getContainer(),
0:                 rh, 
0:                 open_conglom.isForUpdate(),
0:                 row_qualified);
0:     }
0: 
0: 
0:     /**
0:      * Lock the given record id/page num pair.
0:      * <p>
0:      * Should only be called by access, to lock "special" locks formed from
0:      * the Recordhandle.* reserved constants for page specific locks.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @return true if lock was granted, only can be false if wait was false.
0:      *
0: 	 * @param loc       The "RowLocation" which describes the exact row to lock.
0:      * @param forUpdate Lock the record for read or write.
0:      * @param forInsert is row Lock for insert?
0:      * @param wait      Should the lock call wait to be granted?
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean lockRow(
0:     long            page_num,
0:     int             record_id,
0:     int             lock_operation,
0:     boolean         wait,
0:     int             lock_duration)
0:         throws StandardException
0:     {
0:         boolean ret_val;
0: 
0:         RecordHandle rh = 
0:             open_conglom.getContainer().makeRecordHandle(page_num, record_id);
0: 
0:         return(lockRow(rh, lock_operation, wait, lock_duration));
0:     }
0: 
0: 	public RowLocation newRowLocationTemplate()
0: 		throws StandardException
0: 	{
0: 		if (open_conglom.isClosed())
0:         {
0:             if (open_conglom.getHold())
0:             {
0:                 open_conglom.reopen();
0:             }
0:             else
0:             {
0:                 throw(StandardException.newException(
0:                         SQLState.HEAP_IS_CLOSED, 
0:                         open_conglom.getConglomerate().getId()));
0:             } 
0:         }
0: 
0: 		return new HeapRowLocation();
0: 	}
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods of XXXX class:
0:      **************************************************************************
0:      */
0: }
============================================================================