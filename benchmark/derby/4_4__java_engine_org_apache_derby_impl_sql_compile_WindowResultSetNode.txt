1:7a9ce7e: /*
1:7a9ce7e:    Derby - Class org.apache.derby.impl.sql.compile.WindowResultSetNode
6:7a9ce7e: 
1:7a9ce7e:    Licensed to the Apache Software Foundation (ASF) under one or more
1:7a9ce7e:    contributor license agreements.  See the NOTICE file distributed with
1:7a9ce7e:    this work for additional information regarding copyright ownership.
1:7a9ce7e:    The ASF licenses this file to you under the Apache License, Version 2.0
1:7a9ce7e:    (the "License"); you may not use this file except in compliance with
1:7a9ce7e:    the License.  You may obtain a copy of the License at
1:7a9ce7e: 
1:7a9ce7e:       http://www.apache.org/licenses/LICENSE-2.0
1:7a9ce7e: 
1:7a9ce7e:    Unless required by applicable law or agreed to in writing, software
1:7a9ce7e:    distributed under the License is distributed on an "AS IS" BASIS,
1:7a9ce7e:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7a9ce7e:    See the License for the specific language governing permissions and
1:7a9ce7e:    limitations under the License.
1:7a9ce7e: 
2:7a9ce7e:  */
1:7a9ce7e: 
1:7a9ce7e: package org.apache.derby.impl.sql.compile;
1:7a9ce7e: 
1:7a9ce7e: import java.util.ArrayList;
1:591ff9f: import java.util.Iterator;
1:c0a807c: import java.util.List;
1:7a9ce7e: import org.apache.derby.iapi.error.StandardException;
1:7a9ce7e: import org.apache.derby.iapi.reference.ClassName;
1:7a9ce7e: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:7a9ce7e: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7a9ce7e: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:7a9ce7e: 
1:7a9ce7e: 
2:7a9ce7e: /**
1:7a9ce7e:  * A WindowResultSetNode represents a result set for a window partitioning on a
1:3bb140c:  * select. Modeled on the code in GroupByNode.
1:7a9ce7e:  */
1:3bb140c: class WindowResultSetNode extends SingleChildResultSetNode
1:7a9ce7e: {
1:7a9ce7e:     /**
1:7a9ce7e:      * The parent to the WindowResultSetNode.  We generate a ProjectRestrict
1:7a9ce7e:      * over the windowing node and parent is set to that node.
1:7a9ce7e:      */
1:7a9ce7e:     FromTable   parent;
1:3bb140c:     List<WindowFunctionNode> windowFuncCalls;
1:7a9ce7e:     WindowDefinitionNode wdn;
1:7a9ce7e: 
1:7a9ce7e:     /**
1:3bb140c:      * Constructor for a WindowResultSetNode.
1:3bb140c:      *
1:3bb140c:      * @param bottomPR     The project restrict result set we want to wrap
1:3bb140c:      * @param windowDef    The window definition
1:3bb140c:      * @param windowFuncCalls
1:3bb140c:      *                     All window function calls in SELECT's select list
1:3bb140c:      *                     and order by list.
1:7a9ce7e:      * @param nestingLevel Nesting level
1:3bb140c:      * @param cm           The context manager
1:7a9ce7e:      *
1:7a9ce7e:      * @exception StandardException     Thrown on error
1:7a9ce7e:      */
1:591ff9f:     @SuppressWarnings("LeakingThisInConstructor")
1:3bb140c:     WindowResultSetNode(ResultSetNode            bottomPR,
1:3bb140c:                         WindowDefinitionNode     windowDef,
1:3bb140c:                         List<WindowFunctionNode> windowFuncCalls,
1:3bb140c:                         int                      nestingLevel,
1:3bb140c:                         ContextManager           cm) throws StandardException
1:7a9ce7e:     {
1:3bb140c:         super(bottomPR, null, cm);
1:3bb140c:         this.wdn = windowDef;
1:3bb140c:         this.windowFuncCalls = windowFuncCalls;
1:3bb140c:         setLevel(nestingLevel);
1:7a9ce7e: 
1:7a9ce7e:         ResultColumnList newBottomRCL;
1:7a9ce7e: 
1:7a9ce7e:         this.parent = this;
1:7a9ce7e: 
1:7a9ce7e:         /*
1:7a9ce7e:         ** The first thing we do is put ourselves on top of the SELECT.  The
1:7a9ce7e:         ** select becomes the childResult.  So our RCL becomes its RCL (so
1:7a9ce7e:         ** nodes above it now point to us).  Map our RCL to its columns.
1:7a9ce7e:         */
1:7a9ce7e:         newBottomRCL = childResult.getResultColumns().copyListAndObjects();
1:11f7ee3:         setResultColumns( childResult.getResultColumns() );
1:7a9ce7e:         childResult.setResultColumns(newBottomRCL);
1:7a9ce7e: 
1:591ff9f:         // Wrap ourselves in a project/restrict as per convention.
1:7a9ce7e:         addNewPRNode();
1:7a9ce7e: 
1:7a9ce7e:         // Add the extra result columns required
1:7a9ce7e:         addNewColumns();
2:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e:     /**
1:7a9ce7e:      * Add a new PR node.  Put the new PR under any sort.
1:7a9ce7e:      *
1:591ff9f:      * @throws StandardException standard error policy
1:7a9ce7e:      */
1:7a9ce7e:     private void addNewPRNode()
1:7a9ce7e:         throws StandardException
1:7a9ce7e:     {
1:7a9ce7e:         /*
1:7a9ce7e:         ** Get the new PR, put above the WindowResultSetNode.
1:7a9ce7e:         */
1:3bb140c:         ResultColumnList rclNew = new ResultColumnList(getContextManager());
1:7a9ce7e: 
1:11f7ee3:         for (ResultColumn rc : getResultColumns())
1:7a9ce7e:         {
1:7a9ce7e:             if (!rc.isGenerated()) {
1:7a9ce7e:                 rclNew.addElement(rc);
1:7a9ce7e:             }
1:7a9ce7e:         }
1:7a9ce7e: 
1:7a9ce7e:         // if any columns in the source RCL were generated for an order by
1:7a9ce7e:         // remember it in the new RCL as well. After the sort is done it will
1:7a9ce7e:         // have to be projected out upstream.
1:11f7ee3:         rclNew.copyOrderBySelect(getResultColumns());
1:7a9ce7e: 
1:3bb140c:         parent = new ProjectRestrictNode(this, // child
1:3bb140c:                                          rclNew,
1:3bb140c:                                          null, // havingClause,
1:3bb140c:                                          null, // restriction list
1:3bb140c:                                          null, // project subqueries
1:3bb140c:                                          null, // havingSubquerys,
1:3bb140c:                                          null, // tableProperties,
1:3bb140c:                                          getContextManager());
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         /*
1:7a9ce7e:          * Reset the bottom RCL to be empty.
1:7a9ce7e:          */
1:3bb140c:         childResult.setResultColumns(new ResultColumnList(getContextManager()));
1:7a9ce7e: 
1:7a9ce7e:         /*
1:7a9ce7e:          * Set the Windowing RCL to be empty
1:7a9ce7e:          */
1:11f7ee3:         setResultColumns( new ResultColumnList(getContextManager()) );
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         // Add all referenced columns in select list to windowing node's RCL
1:7a9ce7e:         // and substitute references in original node to point to the Windowing
1:7a9ce7e:         // result set. (modelled on GroupByNode's action for addUnAggColumns)
1:a6d25cd:         CollectNodesVisitor<ColumnReference> getCRVisitor =
1:a6d25cd:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:7a9ce7e: 
1:7a9ce7e:         parent.getResultColumns().accept(getCRVisitor);
1:7a9ce7e: 
1:7a9ce7e:         // Find all unique columns referenced and add those to windowing result
1:7a9ce7e:         // set.
1:71c8e86:         ArrayList<ValueNode> uniqueCols = new ArrayList<ValueNode>();
1:a6d25cd:         for (ColumnReference cr : getCRVisitor.getList()) {
1:7a9ce7e:             if (!colRefAlreadySeen(uniqueCols, cr)) {
1:7a9ce7e:                 uniqueCols.add(cr);
1:7a9ce7e:             }
1:7a9ce7e:         }
1:7a9ce7e: 
1:7a9ce7e:         // Add all virtual column select list to windowing node's RCL and
1:7a9ce7e:         // substitute references in original node to point to the Windowing
1:7a9ce7e:         // result set. Happens for example when we have a window over a group
1:7a9ce7e:         // by.
1:71c8e86:         CollectNodesVisitor<VirtualColumnNode> getVCVisitor =
1:71c8e86:             new CollectNodesVisitor<VirtualColumnNode>(VirtualColumnNode.class);
1:7a9ce7e: 
1:7a9ce7e:         parent.getResultColumns().accept(getVCVisitor);
1:7a9ce7e: 
1:7a9ce7e:         // Add any virtual columns to windowing result.
1:a6d25cd:         uniqueCols.addAll(getVCVisitor.getList());
1:7a9ce7e: 
1:7a9ce7e:         ResultColumnList bottomRCL  = childResult.getResultColumns();
1:11f7ee3:         ResultColumnList windowingRCL = getResultColumns();
1:7a9ce7e: 
1:591ff9f:         for (ValueNode crOrVcn : uniqueCols) {
1:3bb140c:             ResultColumn newRC = new ResultColumn(
1:7a9ce7e:                     "##UnWindowingColumn",
1:7a9ce7e:                     crOrVcn,
5:7a9ce7e:                     getContextManager());
1:7a9ce7e: 
1:7a9ce7e:             // add this result column to the bottom rcl
1:7a9ce7e:             bottomRCL.addElement(newRC);
1:7a9ce7e:             newRC.markGenerated();
1:7a9ce7e:             newRC.bindResultColumnToExpression();
1:7a9ce7e:             newRC.setVirtualColumnId(bottomRCL.size());
1:7a9ce7e: 
1:7a9ce7e:             // now add this column to the windowing result column list
1:3bb140c:             ResultColumn wRC = new ResultColumn(
1:7a9ce7e:                     "##UnWindowingColumn",
1:7a9ce7e:                     crOrVcn,
1:7a9ce7e:                     getContextManager());
1:7a9ce7e:             windowingRCL.addElement(wRC);
1:7a9ce7e:             wRC.markGenerated();
1:7a9ce7e:             wRC.bindResultColumnToExpression();
1:7a9ce7e:             wRC.setVirtualColumnId(windowingRCL.size());
1:7a9ce7e: 
1:7a9ce7e:             /*
1:7a9ce7e:              ** Reset the original node to point to the
1:7a9ce7e:              ** Windowing result set.
1:7a9ce7e:              */
1:3bb140c:             VirtualColumnNode vc = new VirtualColumnNode(
1:7a9ce7e:                     this, // source result set.
1:7a9ce7e:                     wRC,
1:3bb140c:                     windowingRCL.size(),
1:7a9ce7e:                     getContextManager());
1:7a9ce7e: 
1:7a9ce7e:             SubstituteExpressionVisitor seVis =
1:7a9ce7e:                 new SubstituteExpressionVisitor(crOrVcn, vc, null);
1:7a9ce7e:             parent.getResultColumns().accept(seVis);
1:7a9ce7e:         }
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:     /**
1:591ff9f:      * @param uniqueColRefs list of unique column references
1:591ff9f:      * @param cand the candidate to check is present in list
1:3bb140c:      * @return {@code true} if an equivalent column reference to {@code cand}
1:3bb140c:      *         is already present in {@code uniqueColRefs}
1:591ff9f:      * @throws StandardException standard error policy
1:7a9ce7e:      */
1:3bb140c:     private boolean colRefAlreadySeen(List<ValueNode> uniqueColRefs,
1:7a9ce7e:                                       ColumnReference cand)
1:7a9ce7e:             throws StandardException {
1:7a9ce7e: 
1:591ff9f:         for (ValueNode uniqueColRef : uniqueColRefs) {
1:591ff9f:             ColumnReference cr = (ColumnReference) uniqueColRef;
1:7a9ce7e: 
1:7a9ce7e:             if (cr.isEquivalent(cand)) {
1:7a9ce7e:                 return true;
1:7a9ce7e:             }
1:7a9ce7e:         }
1:7a9ce7e:         return false;
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e:     /**
1:7a9ce7e:      * Substitute new result columns for window function calls and add the
1:7a9ce7e:      * result columns to childResult's list of columns.
1:591ff9f:      *
1:591ff9f:      * @throws StandardException standard error policy
1:7a9ce7e:      */
1:7a9ce7e:     private void addNewColumns() throws StandardException {
1:7a9ce7e:         /*
1:7a9ce7e:          * Now process all of the window function calls.  Replace every
1:7a9ce7e:          * call with an RC.  We toss out the list of RCs, we need to get
1:7a9ce7e:          * each RC as we process its corresponding window function.
1:7a9ce7e:          */
1:7a9ce7e:         ResultColumnList bottomRCL  = childResult.getResultColumns();
1:11f7ee3:         ResultColumnList windowingRCL = getResultColumns();
1:7a9ce7e: 
1:7a9ce7e:         ReplaceWindowFuncCallsWithCRVisitor replaceCallsVisitor =
1:7a9ce7e:             new ReplaceWindowFuncCallsWithCRVisitor(
1:3bb140c:                 new ResultColumnList(getContextManager()),
1:7a9ce7e:                 ((FromTable) childResult).getTableNumber(),
1:7a9ce7e:                 ResultSetNode.class);
1:7a9ce7e:         parent.getResultColumns().accept(replaceCallsVisitor);
1:7a9ce7e: 
1:591ff9f:         for (WindowFunctionNode winFunc : windowFuncCalls) {
1:7a9ce7e: 
1:7a9ce7e:             if (SanityManager.DEBUG) {
1:7a9ce7e:                 SanityManager.ASSERT(
1:7a9ce7e:                     !(winFunc.getWindow() instanceof WindowReferenceNode),
1:7a9ce7e:                     "unresolved window-reference: " +
1:7a9ce7e:                     winFunc.getWindow().getName());
1:7a9ce7e:             }
1:7a9ce7e: 
1:7a9ce7e:             WindowDefinitionNode funcWindow =
1:7a9ce7e:                 (WindowDefinitionNode)winFunc.getWindow();
1:7a9ce7e: 
1:7a9ce7e:             if (funcWindow == wdn) {
1:3bb140c:                 ResultColumn newRC = new ResultColumn(
1:7a9ce7e:                     "##winFuncResult",
1:7a9ce7e:                     winFunc.getNewNullResultExpression(),
1:7a9ce7e:                     getContextManager());
1:7a9ce7e: 
1:7a9ce7e:                 newRC.markGenerated();
1:7a9ce7e:                 newRC.bindResultColumnToExpression();
1:7a9ce7e:                 bottomRCL.addElement(newRC);
1:7a9ce7e:                 newRC.setVirtualColumnId(bottomRCL.size());
1:7a9ce7e: 
1:7a9ce7e:                 /*
1:7a9ce7e:                 ** Set the WindowResultSetNode result column to point to this.
1:7a9ce7e:                 ** The Windowing Node result was created when we called
1:7a9ce7e:                 ** ReplaceWindowFuncCallsWithCRVisitor.
1:7a9ce7e:                 */
1:3bb140c:                 ColumnReference newColumnRef = new ColumnReference(
1:3bb140c:                         newRC.getName(), null, getContextManager());
1:7a9ce7e: 
1:7a9ce7e:                 newColumnRef.setSource(newRC);
1:7a9ce7e:                 newColumnRef.setNestingLevel(this.getLevel());
1:7a9ce7e:                 newColumnRef.setSourceLevel(this.getLevel());
1:7a9ce7e:                 newColumnRef.markGeneratedToReplaceWindowFunctionCall();
1:7a9ce7e: 
1:3bb140c:                 ResultColumn tmpRC = new ResultColumn(
1:7a9ce7e:                     newRC.getColumnName(),
1:7a9ce7e:                     newColumnRef,
1:7a9ce7e:                     getContextManager());
1:7a9ce7e: 
1:7a9ce7e:                 tmpRC.markGenerated();
1:7a9ce7e:                 tmpRC.bindResultColumnToExpression();
1:7a9ce7e:                 windowingRCL.addElement(tmpRC);
1:7a9ce7e:                 tmpRC.setVirtualColumnId(windowingRCL.size());
1:7a9ce7e: 
1:7a9ce7e:                 /*
1:7a9ce7e:                 ** Set the column reference to point to
1:7a9ce7e:                 ** this.
1:7a9ce7e:                 */
1:7a9ce7e:                 newColumnRef = winFunc.getGeneratedRef();
1:7a9ce7e: 
1:7a9ce7e:                 if (newColumnRef != null) {
1:7a9ce7e:                     newColumnRef.setSource(tmpRC);
1:7a9ce7e:                 } // Not generated, meaning it's no longer in use
1:7a9ce7e:             }
1:7a9ce7e:         }
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:7a9ce7e:             throws StandardException
1:7a9ce7e:     {
1:7a9ce7e:         // Get the next ResultSet#, so we can number this ResultSetNode, its
1:7a9ce7e:         // ResultColumnList and ResultSet.
1:7a9ce7e: 
1:7a9ce7e:         assignResultSetNumber();
1:7a9ce7e: 
1:7a9ce7e:         // Get the final cost estimate from the child.
1:11f7ee3:         setCostEstimate( childResult.getFinalCostEstimate() );
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         acb.pushGetResultSetFactoryExpression(mb);
1:7a9ce7e: 
1:11f7ee3:         int rclSize = getResultColumns().size();
1:7a9ce7e:         FormatableBitSet referencedCols = new FormatableBitSet(rclSize);
1:7a9ce7e: 
1:7a9ce7e:         /*
1:7a9ce7e:          * Build a FormatableBitSet for columns to copy from source.
1:7a9ce7e:          */
1:7a9ce7e: 
1:7a9ce7e:         for (int index = rclSize-1; index >= 0; index--) {
1:11f7ee3:             ResultColumn rc = getResultColumns().elementAt(index);
1:7a9ce7e:             ValueNode expr = rc.getExpression();
1:7a9ce7e: 
1:7a9ce7e:             if (rc.isGenerated() &&
1:7a9ce7e:                     (expr instanceof ColumnReference) &&
1:7a9ce7e:                     ((ColumnReference)expr).
1:7a9ce7e:                         getGeneratedToReplaceWindowFunctionCall()) {
1:7a9ce7e: 
1:7a9ce7e:                 // meaningless to copy these, they arise in this rs.
1:7a9ce7e:             } else {
1:7a9ce7e:                 referencedCols.set(index);
1:7a9ce7e:             }
1:7a9ce7e:         }
1:7a9ce7e: 
1:7a9ce7e:         int erdNumber = acb.addItem(referencedCols);
1:7a9ce7e: 
1:7a9ce7e:         acb.pushThisAsActivation(mb); // arg 1
1:7a9ce7e: 
1:7a9ce7e:         childResult.generate(acb, mb);    // arg 2
1:7a9ce7e:         mb.upCast(ClassName.NoPutResultSet);
1:7a9ce7e: 
1:7a9ce7e:         /* row allocator */
1:11f7ee3:         mb.push(acb.addItem(getResultColumns().buildRowTemplate())); // arg 3
1:7a9ce7e: 
1:11f7ee3:         mb.push(getResultSetNumber()); //arg 4
1:7a9ce7e: 
1:7a9ce7e:         /* Pass in the erdNumber for the referenced column FormatableBitSet */
1:7a9ce7e:         mb.push(erdNumber); // arg 5
1:7a9ce7e: 
1:7a9ce7e:         /* There is no restriction at this level, we just want to pass null. */
1:7a9ce7e:         mb.pushNull(ClassName.GeneratedMethod); // arg 6
1:7a9ce7e: 
1:11f7ee3:         mb.push(getCostEstimate().rowCount()); //arg 7
1:11f7ee3:         mb.push(getCostEstimate().getEstimatedCost()); // arg 8
1:7a9ce7e: 
1:7a9ce7e:         mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:7a9ce7e:             "getWindowResultSet", ClassName.NoPutResultSet, 8);
1:7a9ce7e: 
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:     /**
1:7a9ce7e:      * @return parent of this node, a PRN, used by SelectNode to retrieve new
1:7a9ce7e:      * top result set node after window result set rewrite of result set tree.
1:7a9ce7e:      */
1:9f2ed7d:     final FromTable getParent() {
1:7a9ce7e:         return parent;
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:     /**
1:7a9ce7e:      * QueryTreeNode override
1:7a9ce7e:      * @see QueryTreeNode#printSubNodes
1:7a9ce7e:      */
1:3bb140c:     @Override
1:7a9ce7e:     public void printSubNodes(int depth) {
1:7a9ce7e:         if (SanityManager.DEBUG) {
1:7a9ce7e: 			super.printSubNodes(depth);
1:7a9ce7e: 
1:7a9ce7e:             printLabel(depth, "wdn: ");
1:7a9ce7e:             wdn.treePrint(depth + 1);
1:7a9ce7e:         }
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:591ff9f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("LeakingThisInConstructor")
/////////////////////////////////////////////////////////////////////////
1:         // Wrap ourselves in a project/restrict as per convention.
/////////////////////////////////////////////////////////////////////////
1:      * @throws StandardException standard error policy
/////////////////////////////////////////////////////////////////////////
1:         for (ValueNode crOrVcn : uniqueCols) {
/////////////////////////////////////////////////////////////////////////
1:      * @param uniqueColRefs list of unique column references
1:      * @param cand the candidate to check is present in list
1:      * @throws StandardException standard error policy
1:         for (ValueNode uniqueColRef : uniqueColRefs) {
1:             ColumnReference cr = (ColumnReference) uniqueColRef;
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @throws StandardException standard error policy
/////////////////////////////////////////////////////////////////////////
1:         for (WindowFunctionNode winFunc : windowFuncCalls) {
/////////////////////////////////////////////////////////////////////////
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:         for (ResultColumn rc : resultColumns)
/////////////////////////////////////////////////////////////////////////
0:             ResultColumn rc = resultColumns.elementAt(index);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
1:  * select. Modeled on the code in GroupByNode.
1: class WindowResultSetNode extends SingleChildResultSetNode
1:     List<WindowFunctionNode> windowFuncCalls;
1:      * Constructor for a WindowResultSetNode.
1:      *
1:      * @param bottomPR     The project restrict result set we want to wrap
1:      * @param windowDef    The window definition
1:      * @param windowFuncCalls
1:      *                     All window function calls in SELECT's select list
1:      *                     and order by list.
1:      * @param cm           The context manager
1:     WindowResultSetNode(ResultSetNode            bottomPR,
1:                         WindowDefinitionNode     windowDef,
1:                         List<WindowFunctionNode> windowFuncCalls,
1:                         int                      nestingLevel,
1:                         ContextManager           cm) throws StandardException
1:         super(bottomPR, null, cm);
0:         setNodeType(C_NodeTypes.WINDOW_RESULTSET_NODE);
1:         this.wdn = windowDef;
1:         this.windowFuncCalls = windowFuncCalls;
1:         setLevel(nestingLevel);
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList rclNew = new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         parent = new ProjectRestrictNode(this, // child
1:                                          rclNew,
1:                                          null, // havingClause,
1:                                          null, // restriction list
1:                                          null, // project subqueries
1:                                          null, // havingSubquerys,
1:                                          null, // tableProperties,
1:                                          getContextManager());
1:         childResult.setResultColumns(new ResultColumnList(getContextManager()));
0:         resultColumns = new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             ValueNode crOrVcn = uniqueCols.get(i);
1:             ResultColumn newRC = new ResultColumn(
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn wRC = new ResultColumn(
/////////////////////////////////////////////////////////////////////////
1:             VirtualColumnNode vc = new VirtualColumnNode(
1:                     windowingRCL.size(),
/////////////////////////////////////////////////////////////////////////
1:      * @return {@code true} if an equivalent column reference to {@code cand}
1:      *         is already present in {@code uniqueColRefs}
1:     private boolean colRefAlreadySeen(List<ValueNode> uniqueColRefs,
0:             ColumnReference cr = (ColumnReference)uniqueColRefs.get(i);
/////////////////////////////////////////////////////////////////////////
1:                 new ResultColumnList(getContextManager()),
0:             WindowFunctionNode winFunc = windowFuncCalls.get(i);
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn newRC = new ResultColumn(
/////////////////////////////////////////////////////////////////////////
1:                 ColumnReference newColumnRef = new ColumnReference(
1:                         newRC.getName(), null, getContextManager());
1:                 ResultColumn tmpRC = new ResultColumn(
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derby.impl.sql.compile.WindowResultSetNode
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import java.util.Iterator;
0: import java.util.Vector;
1: import java.util.ArrayList;
0: import java.util.Comparator;
0: import java.util.Collections;
1: 
0: import org.apache.derby.catalog.IndexDescriptor;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.impl.sql.execute.AggregatorInfo;
0: import org.apache.derby.impl.sql.execute.AggregatorInfoList;
1: 
1: 
1: /**
1:  * A WindowResultSetNode represents a result set for a window partitioning on a
0:  * select. Modelled on the code in GroupByNode.
1:  */
0: public class WindowResultSetNode extends SingleChildResultSetNode
1: {
1:     /**
1:      * The parent to the WindowResultSetNode.  We generate a ProjectRestrict
1:      * over the windowing node and parent is set to that node.
1:      */
1:     FromTable   parent;
0:     Vector windowFuncCalls;
1:     WindowDefinitionNode wdn;
1: 
1:     /**
0:      * Intializer for a WindowResultSetNode.
0:      * @param bottomPR The project restrict result set we want to wrap
0:      * @param windowDef The window definition
0:      * @param windowFuncCalls All window function calls in SELECT's select list
0:      * and order by list.
1:      * @param nestingLevel Nesting level
1:      *
1:      * @exception StandardException     Thrown on error
1:      */
0:     public void init(
0:         Object bottomPR,
0:         Object windowDef,
0:         Object windowFuncCalls,
0:         Object nestingLevel) throws StandardException
1:     {
0:         super.init(bottomPR, null);
0:         this.wdn = (WindowDefinitionNode)windowDef;
0:         this.windowFuncCalls = (Vector)windowFuncCalls;
0:         setLevel(((Integer)nestingLevel).intValue());
1: 
1:         ResultColumnList newBottomRCL;
1: 
1:         this.parent = this;
1: 
1:         /*
1:         ** The first thing we do is put ourselves on top of the SELECT.  The
1:         ** select becomes the childResult.  So our RCL becomes its RCL (so
1:         ** nodes above it now point to us).  Map our RCL to its columns.
1:         */
1:         newBottomRCL = childResult.getResultColumns().copyListAndObjects();
0:         resultColumns = childResult.getResultColumns();
1:         childResult.setResultColumns(newBottomRCL);
1: 
0:         // Wrao purselved int a project/restrict as per convention.
1:         addNewPRNode();
1: 
1:         // Add the extra result columns required
1:         addNewColumns();
1:     }
1: 
1:     /**
1:      * Add a new PR node.  Put the new PR under any sort.
1:      *
0:      * @exception standard exception
1:      */
1:     private void addNewPRNode()
1:         throws StandardException
1:     {
1:         /*
1:         ** Get the new PR, put above the WindowResultSetNode.
1:         */
0:         ResultColumnList rclNew = (ResultColumnList)getNodeFactory().
0:             getNode(C_NodeTypes.RESULT_COLUMN_LIST,
1:                     getContextManager());
1: 
0:         int sz = resultColumns.size();
0:         for (int i = 0; i < sz; i++)
1:         {
0:             ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
1:             if (!rc.isGenerated()) {
1:                 rclNew.addElement(rc);
1:             }
1:         }
1: 
1:         // if any columns in the source RCL were generated for an order by
1:         // remember it in the new RCL as well. After the sort is done it will
1:         // have to be projected out upstream.
0:         rclNew.copyOrderBySelect(resultColumns);
1: 
0:         parent = (FromTable) getNodeFactory().getNode(
0:                                         C_NodeTypes.PROJECT_RESTRICT_NODE,
0:                                         this, // child
0:                                         rclNew,
0:                                         null, // havingClause,
0:                                         null, // restriction list
0:                                         null, // project subqueries
0:                                         null, // havingSubquerys,
0:                                         null, // tableProperties,
1:                                         getContextManager());
1: 
1: 
1:         /*
1:          * Reset the bottom RCL to be empty.
1:          */
0:         childResult.setResultColumns((ResultColumnList)
0:                                             getNodeFactory().getNode(
0:                                                 C_NodeTypes.RESULT_COLUMN_LIST,
0:                                                 getContextManager()));
1: 
1:         /*
1:          * Set the Windowing RCL to be empty
1:          */
0:         resultColumns = (ResultColumnList) getNodeFactory().getNode(
0:                                             C_NodeTypes.RESULT_COLUMN_LIST,
1:                                             getContextManager());
1: 
1: 
1:         // Add all referenced columns in select list to windowing node's RCL
1:         // and substitute references in original node to point to the Windowing
1:         // result set. (modelled on GroupByNode's action for addUnAggColumns)
0:         CollectNodesVisitor getCRVisitor =
0:             new CollectNodesVisitor(ColumnReference.class);
1: 
0:         ResultColumnList prcl = parent.getResultColumns();
1: 
1:         parent.getResultColumns().accept(getCRVisitor);
1: 
0:         Vector colRefs = getCRVisitor.getList();
1: 
1:         // Find all unique columns referenced and add those to windowing result
1:         // set.
0:         Vector uniqueCols = new Vector();
0:         for (int i= 0; i< colRefs.size(); i++) {
0:             ColumnReference cr = (ColumnReference)colRefs.elementAt(i);
1:             if (!colRefAlreadySeen(uniqueCols, cr)) {
1:                 uniqueCols.add(cr);
1:             }
1:         }
1: 
1:         // Add all virtual column select list to windowing node's RCL and
1:         // substitute references in original node to point to the Windowing
1:         // result set. Happens for example when we have a window over a group
1:         // by.
0:         CollectNodesVisitor getVCVisitor =
0:             new CollectNodesVisitor(VirtualColumnNode.class);
1: 
1:         parent.getResultColumns().accept(getVCVisitor);
0:         Vector vcs = getVCVisitor.getList();
1: 
1:         // Add any virtual columns to windowing result.
0:         for (int i= 0; i< vcs.size(); i++) {
0:             uniqueCols.add(vcs.elementAt(i));
1:         }
1: 
1:         ResultColumnList bottomRCL  = childResult.getResultColumns();
0:         ResultColumnList windowingRCL = resultColumns;
1: 
0:         for (int i= 0; i< uniqueCols.size(); i++) {
0:             ValueNode crOrVcn = (ValueNode)uniqueCols.elementAt(i);
1: 
0:             ResultColumn newRC = (ResultColumn) getNodeFactory().getNode(
0:                     C_NodeTypes.RESULT_COLUMN,
1:                     "##UnWindowingColumn",
1:                     crOrVcn,
1:                     getContextManager());
1: 
1:             // add this result column to the bottom rcl
1:             bottomRCL.addElement(newRC);
1:             newRC.markGenerated();
1:             newRC.bindResultColumnToExpression();
1:             newRC.setVirtualColumnId(bottomRCL.size());
1: 
1:             // now add this column to the windowing result column list
0:             ResultColumn wRC = (ResultColumn) getNodeFactory().getNode(
0:                     C_NodeTypes.RESULT_COLUMN,
1:                     "##UnWindowingColumn",
1:                     crOrVcn,
1:                     getContextManager());
1:             windowingRCL.addElement(wRC);
1:             wRC.markGenerated();
1:             wRC.bindResultColumnToExpression();
1:             wRC.setVirtualColumnId(windowingRCL.size());
1: 
1:             /*
1:              ** Reset the original node to point to the
1:              ** Windowing result set.
1:              */
0:             VirtualColumnNode vc = (VirtualColumnNode) getNodeFactory().getNode(
0:                     C_NodeTypes.VIRTUAL_COLUMN_NODE,
1:                     this, // source result set.
1:                     wRC,
0:                     new Integer(windowingRCL.size()),
1:                     getContextManager());
1: 
1:             SubstituteExpressionVisitor seVis =
1:                 new SubstituteExpressionVisitor(crOrVcn, vc, null);
1:             parent.getResultColumns().accept(seVis);
1:         }
1:     }
1: 
1: 
1:     /**
0:      * @return true if an equivalent column reference to cand is already
0:      * present in uniqueColRefs
1:      */
0:     private boolean colRefAlreadySeen(Vector uniqueColRefs,
1:                                       ColumnReference cand)
1:             throws StandardException {
1: 
0:         for (int i= 0; i< uniqueColRefs.size(); i++) {
0:             ColumnReference cr = (ColumnReference)uniqueColRefs.elementAt(i);
1: 
1:             if (cr.isEquivalent(cand)) {
1:                 return true;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     /**
1:      * Substitute new result columns for window function calls and add the
1:      * result columns to childResult's list of columns.
1:      */
1:     private void addNewColumns() throws StandardException {
1:         /*
1:          * Now process all of the window function calls.  Replace every
1:          * call with an RC.  We toss out the list of RCs, we need to get
1:          * each RC as we process its corresponding window function.
1:          */
0:         LanguageFactory lf =
0:             getLanguageConnectionContext().getLanguageFactory();
1: 
1:         ResultColumnList bottomRCL  = childResult.getResultColumns();
0:         ResultColumnList windowingRCL = resultColumns;
1: 
1:         ReplaceWindowFuncCallsWithCRVisitor replaceCallsVisitor =
1:             new ReplaceWindowFuncCallsWithCRVisitor(
0:                 (ResultColumnList) getNodeFactory().getNode(
0:                     C_NodeTypes.RESULT_COLUMN_LIST,
0:                     getContextManager()),
1:                 ((FromTable) childResult).getTableNumber(),
1:                 ResultSetNode.class);
1:         parent.getResultColumns().accept(replaceCallsVisitor);
1: 
0:         for (int i=0; i < windowFuncCalls.size(); i++) {
0:             WindowFunctionNode winFunc =
0:                 (WindowFunctionNode)windowFuncCalls.elementAt(i);
1: 
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(
1:                     !(winFunc.getWindow() instanceof WindowReferenceNode),
1:                     "unresolved window-reference: " +
1:                     winFunc.getWindow().getName());
1:             }
1: 
1:             WindowDefinitionNode funcWindow =
1:                 (WindowDefinitionNode)winFunc.getWindow();
1: 
1:             if (funcWindow == wdn) {
0:                 ResultColumn newRC = (ResultColumn) getNodeFactory().getNode(
0:                     C_NodeTypes.RESULT_COLUMN,
1:                     "##winFuncResult",
1:                     winFunc.getNewNullResultExpression(),
1:                     getContextManager());
1: 
1:                 newRC.markGenerated();
1:                 newRC.bindResultColumnToExpression();
1:                 bottomRCL.addElement(newRC);
1:                 newRC.setVirtualColumnId(bottomRCL.size());
0:                 int winFuncResultVColId = newRC.getVirtualColumnId();
1: 
1:                 /*
1:                 ** Set the WindowResultSetNode result column to point to this.
1:                 ** The Windowing Node result was created when we called
1:                 ** ReplaceWindowFuncCallsWithCRVisitor.
1:                 */
0:                 ColumnReference newColumnRef =
0:                     (ColumnReference) getNodeFactory().getNode(
0:                         C_NodeTypes.COLUMN_REFERENCE,
0:                         newRC.getName(),
0:                         null,
1:                         getContextManager());
1: 
1:                 newColumnRef.setSource(newRC);
1:                 newColumnRef.setNestingLevel(this.getLevel());
1:                 newColumnRef.setSourceLevel(this.getLevel());
1:                 newColumnRef.markGeneratedToReplaceWindowFunctionCall();
1: 
0:                 ResultColumn tmpRC = (ResultColumn) getNodeFactory().getNode(
0:                     C_NodeTypes.RESULT_COLUMN,
1:                     newRC.getColumnName(),
1:                     newColumnRef,
1:                     getContextManager());
1: 
1:                 tmpRC.markGenerated();
1:                 tmpRC.bindResultColumnToExpression();
1:                 windowingRCL.addElement(tmpRC);
1:                 tmpRC.setVirtualColumnId(windowingRCL.size());
1: 
1:                 /*
1:                 ** Set the column reference to point to
1:                 ** this.
1:                 */
1:                 newColumnRef = winFunc.getGeneratedRef();
1: 
1:                 if (newColumnRef != null) {
1:                     newColumnRef.setSource(tmpRC);
1:                 } // Not generated, meaning it's no longer in use
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
0:      * override
0:      * @see QueryTreeNode#generate
1:      */
0:     public void generate(ActivationClassBuilder acb,
0:                          MethodBuilder mb)
1:             throws StandardException
1:     {
1:         // Get the next ResultSet#, so we can number this ResultSetNode, its
1:         // ResultColumnList and ResultSet.
1: 
1:         assignResultSetNumber();
1: 
1:         // Get the final cost estimate from the child.
0:         costEstimate = childResult.getFinalCostEstimate();
1: 
1: 
1:         acb.pushGetResultSetFactoryExpression(mb);
1: 
0:         int rclSize = resultColumns.size();
1:         FormatableBitSet referencedCols = new FormatableBitSet(rclSize);
1: 
1:         /*
1:          * Build a FormatableBitSet for columns to copy from source.
1:          */
1: 
1:         for (int index = rclSize-1; index >= 0; index--) {
0:             ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);
1:             ValueNode expr = rc.getExpression();
1: 
1:             if (rc.isGenerated() &&
1:                     (expr instanceof ColumnReference) &&
1:                     ((ColumnReference)expr).
1:                         getGeneratedToReplaceWindowFunctionCall()) {
1: 
1:                 // meaningless to copy these, they arise in this rs.
1:             } else {
1:                 referencedCols.set(index);
1:             }
1:         }
1: 
1:         int erdNumber = acb.addItem(referencedCols);
1: 
1:         acb.pushThisAsActivation(mb); // arg 1
1: 
1:         childResult.generate(acb, mb);    // arg 2
1:         mb.upCast(ClassName.NoPutResultSet);
1: 
1:         /* row allocator */
0:         resultColumns.generateHolder(acb, mb); // arg 3
1: 
0:         mb.push(resultSetNumber); //arg 4
1: 
1:         /* Pass in the erdNumber for the referenced column FormatableBitSet */
1:         mb.push(erdNumber); // arg 5
1: 
1:         /* There is no restriction at this level, we just want to pass null. */
1:         mb.pushNull(ClassName.GeneratedMethod); // arg 6
1: 
0:         mb.push(costEstimate.rowCount()); //arg 7
0:         mb.push(costEstimate.getEstimatedCost()); // arg 8
1: 
1:         mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:             "getWindowResultSet", ClassName.NoPutResultSet, 8);
1: 
1:     }
1: 
1: 
1: 
1:     /**
1:      * @return parent of this node, a PRN, used by SelectNode to retrieve new
1:      * top result set node after window result set rewrite of result set tree.
1:      */
0:     public FromTable getParent() {
1:         return parent;
1:     }
1: 
1: 
1:     /**
1:      * QueryTreeNode override
1:      * @see QueryTreeNode#printSubNodes
1:      */
1:     public void printSubNodes(int depth) {
1:         if (SanityManager.DEBUG) {
1: 			super.printSubNodes(depth);
1: 
1:             printLabel(depth, "wdn: ");
1:             wdn.treePrint(depth + 1);
1:         }
1:     }
1: 
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( childResult.getResultColumns() );
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn rc : getResultColumns())
/////////////////////////////////////////////////////////////////////////
1:         rclNew.copyOrderBySelect(getResultColumns());
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( new ResultColumnList(getContextManager()) );
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList windowingRCL = getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList windowingRCL = getResultColumns();
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( childResult.getFinalCostEstimate() );
1:         int rclSize = getResultColumns().size();
/////////////////////////////////////////////////////////////////////////
1:             ResultColumn rc = getResultColumns().elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:         mb.push(acb.addItem(getResultColumns().buildRowTemplate())); // arg 3
1:         mb.push(getResultSetNumber()); //arg 4
/////////////////////////////////////////////////////////////////////////
1:         mb.push(getCostEstimate().rowCount()); //arg 7
1:         mb.push(getCostEstimate().getEstimatedCost()); // arg 8
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ValueNode> uniqueCols = new ArrayList<ValueNode>();
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<VirtualColumnNode> getVCVisitor =
1:             new CollectNodesVisitor<VirtualColumnNode>(VirtualColumnNode.class);
0:         List<VirtualColumnNode> vcs = getVCVisitor.getList();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<ColumnReference> getCRVisitor =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:         for (ColumnReference cr : getCRVisitor.getList()) {
/////////////////////////////////////////////////////////////////////////
1:         uniqueCols.addAll(getVCVisitor.getList());
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     final FromTable getParent() {
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0:     List windowFuncCalls;
/////////////////////////////////////////////////////////////////////////
0:         this.windowFuncCalls = (List) windowFuncCalls;
/////////////////////////////////////////////////////////////////////////
0:         List colRefs = getCRVisitor.getList();
0:         ArrayList uniqueCols = new ArrayList();
0:             ColumnReference cr = (ColumnReference) colRefs.get(i);
/////////////////////////////////////////////////////////////////////////
0:         List vcs = getVCVisitor.getList();
0:             uniqueCols.add(vcs.get(i));
0:             ValueNode crOrVcn = (ValueNode) uniqueCols.get(i);
/////////////////////////////////////////////////////////////////////////
0:     private boolean colRefAlreadySeen(List uniqueColRefs,
0:             ColumnReference cr = (ColumnReference) uniqueColRefs.get(i);
/////////////////////////////////////////////////////////////////////////
0:                 (WindowFunctionNode) windowFuncCalls.get(i);
commit:bda7291
/////////////////////////////////////////////////////////////////////////
0:         mb.push(acb.addItem(resultColumns.buildRowTemplate())); // arg 3
commit:d868eed
/////////////////////////////////////////////////////////////////////////
0:         mb.push(acb.addItem(resultColumns.buildRowTemplate(null))); // arg 3
============================================================================