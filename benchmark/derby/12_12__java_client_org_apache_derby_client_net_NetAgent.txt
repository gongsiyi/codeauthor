1:33776ff: /*
11:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetAgent
1:6384512: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:69e3d06: import java.io.IOException;
1:69e3d06: import java.io.InputStream;
1:69e3d06: import java.io.OutputStream;
1:69e3d06: import java.net.Socket;
1:592457a: import java.net.SocketException;
1:69e3d06: import java.security.AccessController;
1:69e3d06: import java.security.PrivilegedActionException;
1:592457a: 
1:33776ff: import org.apache.derby.client.am.Agent;
1:33776ff: import org.apache.derby.client.am.DisconnectException;
1:33776ff: import org.apache.derby.client.am.SqlException;
1:1b39163: import org.apache.derby.client.am.ClientMessageId;
1:69e3d06: import org.apache.derby.client.am.ClientStatement;
1:b13b17c: import org.apache.derby.client.am.LogWriter;
1:33776ff: import org.apache.derby.client.am.Utils;
1:592457a: import org.apache.derby.shared.common.sanity.SanityManager;
1:33776ff: 
1:1b39163: import org.apache.derby.shared.common.reference.SQLState;
1:1b39163: 
1:70f7692: public class NetAgent extends Agent {
1:33776ff:     //---------------------navigational members-----------------------------------
1:33776ff: 
1:33776ff:     // All these request objects point to the same physical request object.
1:0326967:     ConnectionRequestInterface connectionRequest_;
1:0326967:     StatementRequestInterface statementRequest_;
1:0326967:     ResultSetRequestInterface resultSetRequest_;
1:33776ff: 
1:33776ff:     // All these reply objects point to the same physical reply object.
1:0326967:     ConnectionReply connectionReply_;
1:0326967:     private ConnectionReply packageReply_;
1:0326967:     StatementReply statementReply_;
1:0326967:     ResultSetReply resultSetReply_;
1:33776ff: 
1:33776ff:     //---------------------navigational cheat-links-------------------------------
1:33776ff:     // Cheat-links are for convenience only, and are not part of the conceptual model.
1:33776ff:     // Warning:
1:33776ff:     //   Cheat-links should only be defined for invariant state data.
1:33776ff:     //   That is, the state data is set by the constructor and never changes.
1:33776ff: 
1:33776ff:     // Alias for (NetConnection) super.connection
1:33776ff:     NetConnection netConnection_;
1:33776ff: 
1:33776ff:     // Alias for (Request) super.*Request, all in one
1:33776ff:     // In the case of the NET implementation, these all point to the same physical request object.
1:0326967:     private Request request_;
1:0326967:     NetConnectionRequest netConnectionRequest_;
1:0326967:     private NetPackageRequest netPackageRequest_;
1:0326967:     private NetStatementRequest netStatementRequest_;
1:0326967:     private NetResultSetRequest netResultSetRequest_;
1:33776ff: 
1:33776ff:     // Alias for (Reply) super.*Reply, all in one.
1:33776ff:     // In the case of the NET implementation, these all point to the same physical reply object.
1:0326967:     private Reply reply_;
1:0326967:     NetConnectionReply netConnectionReply_;
1:0326967:     private NetPackageReply netPackageReply_;
1:0326967:     private NetStatementReply netStatementReply_;
1:0326967:     private NetResultSetReply netResultSetReply_;
1:33776ff: 
1:33776ff:     //-----------------------------state------------------------------------------
1:33776ff: 
1:69e3d06:     Socket socket_;
1:0326967:     private InputStream rawSocketInputStream_;
1:0326967:     private OutputStream rawSocketOutputStream_;
1:33776ff: 
1:33776ff:     String server_;
1:33776ff:     int port_;
1:0326967:     private int clientSSLMode_;
1:6bc2e25: 
1:b9687fb:     private EbcdicCcsidManager ebcdicCcsidManager_;
1:b9687fb:     private Utf8CcsidManager utf8CcsidManager_;
1:b9687fb:     private CcsidManager currentCcsidManager_;
1:b9687fb:     
1:b9687fb:     // TODO: Remove target? Keep just one CcsidManager?
1:b9687fb:     //public CcsidManager targetCcsidManager_;
1:0326967:     Typdef typdef_;
1:0326967:     Typdef targetTypdef_;
1:0326967:     Typdef originalTargetTypdef_; // added to support typdef overrides
1:33776ff: 
1:0326967:     private int svrcod_;
1:33776ff: 
1:0326967:     int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;
1:0326967:     int targetSqlam_ = orignalTargetSqlam_;
1:33776ff: 
1:0326967:     SqlException exceptionOpeningSocket_ = null;
1:0326967:     SqlException exceptionConvertingRdbnam = null;
1:33776ff:     
1:b862050:     /**
1:b862050:      * Flag which indicates that a writeChain has been started and data sent to
1:b862050:      * the server.
1:b862050:      * If true, starting a new write chain will throw a DisconnectException. 
1:b862050:      * It is cleared when the write chain is ended.
1:b862050:      */
1:b862050:     private boolean writeChainIsDirty_ = false;
1:33776ff:     //---------------------constructors/finalizer---------------------------------
1:0326967: 
1:0326967:     // Only used for testing
1:33776ff:     public NetAgent(NetConnection netConnection,
1:b13b17c:                     LogWriter logWriter) throws SqlException {
1:70f7692:         super(netConnection, logWriter);
1:33776ff:         this.netConnection_ = netConnection;
7:33776ff:     }
1:33776ff: 
1:70f7692:     NetAgent(NetConnection netConnection,
1:b13b17c:              LogWriter netLogWriter,
1:33776ff:              int loginTimeout,
1:33776ff:              String server,
1:6bc2e25:              int port,
1:37ce91b:              int clientSSLMode) throws SqlException {
1:70f7692:         super(netConnection, netLogWriter);
1:33776ff: 
1:33776ff:         server_ = server;
1:33776ff:         port_ = port;
1:33776ff:         netConnection_ = netConnection;
1:37ce91b:         clientSSLMode_ = clientSSLMode;
1:6bc2e25: 
1:70f7692:         if (server_ == null) {
1:1b39163:             throw new DisconnectException(this, 
1:1b39163:                 new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET),
1:1b39163:                 "serverName");
1:33776ff:         }
1:33776ff: 
1:33776ff:         try {
1:69e3d06:             socket_ = (Socket)AccessController.doPrivileged(
1:69e3d06:                 new OpenSocketAction(server, port, clientSSLMode_));
1:69e3d06:         } catch (PrivilegedActionException e) {
1:679d226:             throw new DisconnectException(this,
1:1b39163:                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER),
1:e1a79c3:                 e.getException(),
1:e1a79c3:                 e.getException().getClass().getName(), server, port,
1:e1a79c3:                 e.getException().getMessage());
1:33776ff:         }
1:33776ff: 
1:33776ff:         // Set TCP/IP Socket Properties
1:33776ff:         try {
1:33776ff:             if (exceptionOpeningSocket_ == null) {
1:70f7692:                 socket_.setTcpNoDelay(true); // disables nagles algorithm
1:70f7692:                 socket_.setKeepAlive(true); // PROTOCOL Manual: TCP/IP connection allocation rule #2
1:70f7692:                 socket_.setSoTimeout(loginTimeout * 1000);
1:33776ff:             }
1:69e3d06:         } catch (SocketException e) {
1:33776ff:             try {
2:70f7692:                 socket_.close();
1:69e3d06:             } catch (IOException doNothing) {
1:33776ff:             }
1:1b39163:             exceptionOpeningSocket_ = new DisconnectException(this,
1:1b39163:                 new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION),
1:e1a79c3:                 e, e.getMessage());
1:33776ff:         }
1:33776ff: 
11:70f7692:         try {
1:33776ff:             if (exceptionOpeningSocket_ == null) {
1:33776ff:                 rawSocketOutputStream_ = socket_.getOutputStream();
1:33776ff:                 rawSocketInputStream_ = socket_.getInputStream();
1:33776ff:             }
1:69e3d06:         } catch (IOException e) {
1:70f7692:             try {
1:70f7692:                 socket_.close();
1:69e3d06:             } catch (IOException doNothing) {
1:33776ff:             }
1:679d226:             exceptionOpeningSocket_ = new DisconnectException(this, 
1:1b39163:                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM),
1:e1a79c3:                 e, e.getMessage());
1:33776ff:         }
1:33776ff: 
1:b9687fb:         ebcdicCcsidManager_ = new EbcdicCcsidManager();
1:b9687fb:         utf8CcsidManager_ = new Utf8CcsidManager();
1:33776ff:         
1:b005ffa:         currentCcsidManager_ = ebcdicCcsidManager_;
1:b9687fb: 
1:33776ff:         if (netConnection_.isXAConnection()) {
1:70f7692:             NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);
1:33776ff:             netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;
1:33776ff:             netStatementReply_ = (NetStatementReply) netResultSetReply_;
1:33776ff:             netPackageReply_ = (NetPackageReply) netStatementReply_;
1:33776ff:             netConnectionReply_ = (NetConnectionReply) netPackageReply_;
1:33776ff:             reply_ = (Reply) netConnectionReply_;
1:33776ff: 
1:70f7692:             resultSetReply_ = new ResultSetReply(this,
1:33776ff:                     netResultSetReply_,
1:33776ff:                     netStatementReply_,
1:33776ff:                     netConnectionReply_);
1:33776ff:             statementReply_ = (StatementReply) resultSetReply_;
1:33776ff:             packageReply_ = (ConnectionReply) statementReply_;
1:33776ff:             connectionReply_ = (ConnectionReply) packageReply_;
1:1451af7:             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);
1:33776ff:             netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;
1:33776ff:             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
1:33776ff:             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
1:33776ff:             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
1:33776ff:             request_ = (Request) netConnectionRequest_;
1:33776ff: 
1:33776ff:             resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
1:33776ff:             statementRequest_ = (StatementRequestInterface) netStatementRequest_;
1:33776ff:             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
1:70f7692:         } else {
1:70f7692:             netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);
1:33776ff:             netStatementReply_ = (NetStatementReply) netResultSetReply_;
1:33776ff:             netPackageReply_ = (NetPackageReply) netStatementReply_;
1:33776ff:             netConnectionReply_ = (NetConnectionReply) netPackageReply_;
1:33776ff:             reply_ = (Reply) netConnectionReply_;
1:33776ff: 
1:70f7692:             resultSetReply_ = new ResultSetReply(this,
1:33776ff:                     netResultSetReply_,
1:33776ff:                     netStatementReply_,
1:33776ff:                     netConnectionReply_);
1:33776ff:             statementReply_ = (StatementReply) resultSetReply_;
1:33776ff:             packageReply_ = (ConnectionReply) statementReply_;
1:33776ff:             connectionReply_ = (ConnectionReply) packageReply_;
1:1451af7:             netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);
1:33776ff:             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
1:33776ff:             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
1:33776ff:             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
1:33776ff:             request_ = (Request) netConnectionRequest_;
1:33776ff: 
1:33776ff:             resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
1:33776ff:             statementRequest_ = (StatementRequestInterface) netStatementRequest_;
1:33776ff:             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:b13b17c:     protected void resetAgent_(LogWriter netLogWriter,
1:33776ff:                                //CcsidManager sourceCcsidManager,
1:33776ff:                                //CcsidManager targetCcsidManager,
1:33776ff:                                int loginTimeout,
1:33776ff:                                String server,
2:70f7692:                                int port) throws SqlException {
1:6384512:         
1:6384512:         exceptionConvertingRdbnam = null;
1:33776ff:         // most properties will remain unchanged on connect reset.
1:33776ff:         targetTypdef_ = originalTargetTypdef_;
1:33776ff:         svrcod_ = 0;
1:33776ff: 
1:33776ff:         // Set TCP/IP Socket Properties
1:33776ff:         try {
1:70f7692:             socket_.setSoTimeout(loginTimeout * 1000);
1:69e3d06:         } catch (SocketException e) {
1:70f7692:             try {
1:70f7692:                 socket_.close();
1:69e3d06:             } catch (IOException doNothing) {
1:33776ff:             }
1:1b39163:             throw new SqlException(logWriter_, 
1:1b39163:                 new ClientMessageId(SQLState.SOCKET_EXCEPTION),
1:e1a79c3:                 e, e.getMessage());
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     void setSvrcod(int svrcod) {
1:70f7692:         if (svrcod > svrcod_) {
1:70f7692:             svrcod_ = svrcod;
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     void clearSvrcod() {
1:33776ff:         svrcod_ = CodePoint.SVRCOD_INFO;
1:33776ff:     }
1:33776ff: 
1:0326967:     private int getSvrcod() {
1:33776ff:         return svrcod_;
1:33776ff:     }
1:33776ff: 
1:70f7692:     public void flush_() throws DisconnectException {
1:70f7692:         sendRequest();
1:70f7692:         reply_.initialize();
1:33776ff:     }
1:33776ff: 
1:33776ff:     // Close socket and its streams.
1:70f7692:     public void close_() throws SqlException {
1:33776ff:         // can we just close the socket here, do we need to close streams individually
1:33776ff:         SqlException accumulatedExceptions = null;
1:33776ff:         if (rawSocketInputStream_ != null) {
1:33776ff:             try {
1:33776ff:                 rawSocketInputStream_.close();
1:69e3d06:             } catch (IOException e) {
1:33776ff:                 // note when {6} = 0 it indicates the socket was closed.
1:33776ff:                 // this should be ok since we are going to go an close the socket
1:33776ff:                 // immediately following this call.
1:33776ff:                 // changing {4} to e.getMessage() may require pub changes
1:1b39163:                 accumulatedExceptions = new SqlException(logWriter_,
1:1b39163:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
1:e1a79c3:                     e, e.getMessage());
1:70f7692:             } finally {
1:33776ff:                 rawSocketInputStream_ = null;
1:33776ff:             }
1:33776ff:         }
1:33776ff: 
1:33776ff:         if (rawSocketOutputStream_ != null) {
1:33776ff:             try {
1:33776ff:                 rawSocketOutputStream_.close();
1:69e3d06:             } catch (IOException e) {
1:33776ff:                 // note when {6} = 0 it indicates the socket was closed.
1:33776ff:                 // this should be ok since we are going to go an close the socket
1:33776ff:                 // immediately following this call.
1:33776ff:                 // changing {4} to e.getMessage() may require pub changes
1:70f7692:                 SqlException latestException = new SqlException(logWriter_,
1:1b39163:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
1:e1a79c3:                     e, e.getMessage());
1:70f7692:                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
1:70f7692:             } finally {
1:33776ff:                 rawSocketOutputStream_ = null;
1:33776ff:             }
1:33776ff:         }
1:33776ff: 
1:33776ff:         if (socket_ != null) {
1:33776ff:             try {
1:33776ff:                 socket_.close();
1:69e3d06:             } catch (IOException e) {
1:33776ff:                 // again {6} = 0, indicates the socket was closed.
1:33776ff:                 // maybe set {4} to e.getMessage().
1:33776ff:                 // do this for now and but may need to modify or
1:33776ff:                 // add this to the message pubs.
1:70f7692:                 SqlException latestException = new SqlException(logWriter_,
1:1b39163:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
1:e1a79c3:                         e, e.getMessage());
1:70f7692:                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
1:70f7692:             } finally {
1:33776ff:                 socket_ = null;
1:33776ff:             }
1:33776ff:         }
1:33776ff: 
1:70f7692:         if (accumulatedExceptions != null) {
1:33776ff:             throw accumulatedExceptions;
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:b005ffa:     /**
1:592457a:      * Specifies the maximum blocking time that should be used when sending
1:592457a:      * and receiving messages. The timeout is implemented by using the the 
1:592457a:      * underlying socket implementation's timeout support. 
1:592457a:      * 
1:592457a:      * Note that the support for timeout on sockets is dependent on the OS 
1:592457a:      * implementation. For the same reason we ignore any exceptions thrown
1:592457a:      * by the call to the socket layer.
1:592457a:      * 
1:592457a:      * @param timeout The timeout value in seconds. A value of 0 corresponds to 
1:592457a:      * infinite timeout.
1:592457a:      */
1:592457a:     protected void setTimeout(int timeout) {
1:592457a:         try {
1:592457a:             // Sets a timeout on the socket
1:592457a:             socket_.setSoTimeout(timeout * 1000); // convert to milliseconds
1:592457a:         } catch (SocketException se) {
1:592457a:             // Silently ignore any exceptions from the socket layer
1:592457a:             if (SanityManager.DEBUG) {
1:592457a:                 System.out.println("NetAgent.setTimeout: ignoring exception: " + 
1:592457a:                                    se);
1:592457a:             }
1:592457a:         }
1:592457a:     }
1:592457a: 
1:592457a:     /**
1:592457a:      * Returns the current timeout value that is set on the socket.
1:592457a:      * 
1:592457a:      * Note that the support for timeout on sockets is dependent on the OS 
1:592457a:      * implementation. For the same reason we ignore any exceptions thrown
1:592457a:      * by the call to the socket layer.
1:592457a:      * 
1:592457a:      * @return The timeout value in seconds. A value of 0 corresponds to
1:592457a:      * that no timeout is specified on the socket.
1:592457a:      */
1:592457a:     protected int getTimeout() {
1:592457a:         int timeout = 0; // 0 is default timeout for sockets
1:592457a: 
1:592457a:         // Read the timeout currently set on the socket
1:592457a:         try {
1:592457a:             timeout = socket_.getSoTimeout();
1:592457a:         } catch (SocketException se) {
1:592457a:             // Silently ignore any exceptions from the socket layer
1:592457a:             if (SanityManager.DEBUG) {
1:592457a:                 System.out.println("NetAgent.getTimeout: ignoring exception: " + 
1:592457a:                                    se);
1:592457a:             }
1:592457a:         }
1:592457a: 
1:592457a:         // Convert from milliseconds to seconds (note that this truncates
1:592457a:         // the results towards zero but that should not be a problem).
1:592457a:         timeout = timeout / 1000;
1:592457a:         return timeout;
1:592457a:     }
1:33776ff: 
1:0326967:     private void sendRequest() throws DisconnectException {
1:33776ff:         try {
1:70f7692:             request_.flush(rawSocketOutputStream_);
1:69e3d06:         } catch (IOException e) {
1:1b39163:             throwCommunicationsFailure(e);
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     public InputStream getInputStream() {
1:70f7692:         return rawSocketInputStream_;
1:33776ff:     }
1:33776ff: 
1:b9687fb:     public CcsidManager getCurrentCcsidManager() {
1:b9687fb:         return currentCcsidManager_;
1:b9687fb:     }
1:b9687fb:     
1:69e3d06:     public OutputStream getOutputStream() {
1:70f7692:         return rawSocketOutputStream_;
1:33776ff:     }
1:33776ff: 
1:69e3d06:     void setInputStream(InputStream inputStream) {
1:70f7692:         rawSocketInputStream_ = inputStream;
1:33776ff:     }
1:33776ff: 
1:69e3d06:     void setOutputStream(OutputStream outputStream) {
1:70f7692:         rawSocketOutputStream_ = outputStream;
1:33776ff:     }
1:33776ff: 
1:0326967:     void throwCommunicationsFailure(Throwable cause)
1:69e3d06:         throws DisconnectException {
1:69e3d06:         //DisconnectException
1:33776ff:         //accumulateReadExceptionAndDisconnect
1:33776ff:         // note when {6} = 0 it indicates the socket was closed.
1:33776ff:         // need to still validate any token values against message publications.
1:1b39163:         accumulateChainBreakingReadExceptionAndThrow(
1:b13b17c:             new DisconnectException(this,
1:1b39163:                 new ClientMessageId(SQLState.COMMUNICATION_ERROR),
1:e1a79c3:                 cause, cause.getMessage()));
1:33776ff:     }
1:1b39163:         
1:33776ff:     // ----------------------- call-down methods ---------------------------------
1:33776ff: 
1:70f7692:     protected void markChainBreakingException_() {
1:70f7692:         setSvrcod(CodePoint.SVRCOD_ERROR);
1:33776ff:     }
1:33776ff: 
1:70f7692:     public void checkForChainBreakingException_() throws SqlException {
1:33776ff:         int svrcod = getSvrcod();
1:33776ff:         clearSvrcod();
1:33776ff:         if (svrcod > CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod > WARNING, then its a chain breaker
24:33776ff:         {
1:33776ff:             super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void writeDeferredResetConnection() throws SqlException {
1:70f7692:         if (!netConnection_.resetConnectionAtFirstSql_) {
1:70f7692:             return;
1:33776ff:         }
1:33776ff:         try {
1:33776ff:             netConnection_.writeDeferredReset();
1:70f7692:         } catch (SqlException sqle) {
1:1b39163:             DisconnectException de = new DisconnectException(this, 
1:1b39163:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
1:33776ff:             de.setNextException(sqle);
1:33776ff:             throw de;
1:33776ff:         }
1:33776ff:     }
1:b862050:     /**
1:b862050:      * Marks the agent's write chain as dirty. A write chain is dirty when data
1:b862050:      * from it has been sent to the server. A dirty write chain cannot be reset 
1:b862050:      * and reused for another request until the remaining data has been sent to
1:b862050:      * the server and the write chain properly ended. 
1:b862050:      * 
1:b862050:      * Resetting a dirty chain will cause the new request to be appended to the 
1:b862050:      * unfinished request already at the server, which will likely lead to 
1:b862050:      * cryptic syntax errors.
1:b862050:      */
1:b862050:     void markWriteChainAsDirty() {    
1:b862050:         writeChainIsDirty_ = true;
1:b862050:     }
1:b862050:     
1:b862050:     private void verifyWriteChainIsClean() throws DisconnectException {
1:b862050:         if (writeChainIsDirty_) { 
1:b862050:             throw new DisconnectException(this, 
1:b862050:                 new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));
1:b862050:         }
1:b862050:     }
1:70f7692:     public void beginWriteChainOutsideUOW() throws SqlException {
1:b862050:         verifyWriteChainIsClean();
1:33776ff:         request_.initialize();
1:33776ff:         writeDeferredResetConnection();
1:33776ff:     }
1:33776ff: 
1:69e3d06:     public void beginWriteChain(ClientStatement statement) throws SqlException {
1:b862050:         verifyWriteChainIsClean();
1:33776ff:         request_.initialize();
1:33776ff:         writeDeferredResetConnection();
1:70f7692:         super.beginWriteChain(statement);
1:33776ff:     }
1:33776ff: 
1:b862050:     protected void endWriteChain() {}
1:b862050:     
1:70f7692:     private void readDeferredResetConnection() throws SqlException {
1:70f7692:         if (!netConnection_.resetConnectionAtFirstSql_) {
1:70f7692:             return;
1:33776ff:         }
1:33776ff:         try {
1:33776ff:             netConnection_.readDeferredReset();
1:33776ff:             checkForExceptions();
1:70f7692:         } catch (SqlException sqle) {
1:1b39163:             DisconnectException de = new DisconnectException(this, 
1:1b39163:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
1:33776ff:             de.setNextException(sqle);
1:33776ff:             throw de;
1:33776ff:         }
1:33776ff:     }
1:33776ff: 
1:69e3d06:     protected void beginReadChain(ClientStatement statement)
1:69e3d06:             throws SqlException {
1:b862050:         // Clear here as endWriteChain may not always be called
1:b862050:         writeChainIsDirty_ = false;
1:33776ff:         readDeferredResetConnection();
1:70f7692:         super.beginReadChain(statement);
1:33776ff:     }
1:33776ff: 
1:70f7692:     protected void beginReadChainOutsideUOW() throws SqlException {
1:b862050:         // Clear here as endWriteChain may not always be called
1:b862050:         writeChainIsDirty_ = false;
1:33776ff:         readDeferredResetConnection();
1:33776ff:         super.beginReadChainOutsideUOW();
1:33776ff:     }
1:33776ff: 
1:592457a:     /**
1:b005ffa:      * Switches the current CCSID manager to UTF-8
1:b005ffa:      */
1:0326967:     void switchToUtf8CcsidMgr() {
1:b005ffa:         currentCcsidManager_ = utf8CcsidManager_;
1:b005ffa:     }
1:b005ffa:     
1:b005ffa:     /**
1:b005ffa:      * Switches the current CCSID manager to EBCDIC
1:b005ffa:      */
1:b565f41:     void switchToEbcdicMgr() {
1:b005ffa:         currentCcsidManager_ = ebcdicCcsidManager_;
1:b005ffa:     }
1:33776ff: }
1:33776ff: 
1:33776ff: 
============================================================================
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:b862050
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Flag which indicates that a writeChain has been started and data sent to
1:      * the server.
1:      * If true, starting a new write chain will throw a DisconnectException. 
1:      * It is cleared when the write chain is ended.
1:      */
1:     private boolean writeChainIsDirty_ = false;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Marks the agent's write chain as dirty. A write chain is dirty when data
1:      * from it has been sent to the server. A dirty write chain cannot be reset 
1:      * and reused for another request until the remaining data has been sent to
1:      * the server and the write chain properly ended. 
1:      * 
1:      * Resetting a dirty chain will cause the new request to be appended to the 
1:      * unfinished request already at the server, which will likely lead to 
1:      * cryptic syntax errors.
1:      */
1:     void markWriteChainAsDirty() {    
1:         writeChainIsDirty_ = true;
1:     }
1:     
1:     private void verifyWriteChainIsClean() throws DisconnectException {
1:         if (writeChainIsDirty_) { 
1:             throw new DisconnectException(this, 
1:                 new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));
1:         }
1:     }
1:         verifyWriteChainIsClean();
1:         verifyWriteChainIsClean();
1:     protected void endWriteChain() {}
1:     
/////////////////////////////////////////////////////////////////////////
1:         // Clear here as endWriteChain may not always be called
1:         writeChainIsDirty_ = false;
1:         // Clear here as endWriteChain may not always be called
1:         writeChainIsDirty_ = false;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6372907
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                 e.getException(),
1:                 e.getException().getClass().getName(), server, port,
1:                 e.getException().getMessage());
/////////////////////////////////////////////////////////////////////////
1:                 e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                 e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                 e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                     e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                     e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                         e, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                 cause, cause.getMessage()));
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     void switchToEbcdicMgr() {
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     ConnectionRequestInterface connectionRequest_;
1:     StatementRequestInterface statementRequest_;
1:     ResultSetRequestInterface resultSetRequest_;
1:     ConnectionReply connectionReply_;
1:     private ConnectionReply packageReply_;
1:     StatementReply statementReply_;
1:     ResultSetReply resultSetReply_;
/////////////////////////////////////////////////////////////////////////
1:     private Request request_;
1:     NetConnectionRequest netConnectionRequest_;
1:     private NetPackageRequest netPackageRequest_;
1:     private NetStatementRequest netStatementRequest_;
1:     private NetResultSetRequest netResultSetRequest_;
1:     private Reply reply_;
1:     NetConnectionReply netConnectionReply_;
1:     private NetPackageReply netPackageReply_;
1:     private NetStatementReply netStatementReply_;
1:     private NetResultSetReply netResultSetReply_;
1:     private InputStream rawSocketInputStream_;
1:     private OutputStream rawSocketOutputStream_;
1:     private int clientSSLMode_;
/////////////////////////////////////////////////////////////////////////
1:     Typdef typdef_;
1:     Typdef targetTypdef_;
1:     Typdef originalTargetTypdef_; // added to support typdef overrides
1:     private int svrcod_;
1:     int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;
1:     int targetSqlam_ = orignalTargetSqlam_;
1:     SqlException exceptionOpeningSocket_ = null;
1:     SqlException exceptionConvertingRdbnam = null;
1: 
1:     // Only used for testing
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private int getSvrcod() {
/////////////////////////////////////////////////////////////////////////
1:     private void sendRequest() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     void throwCommunicationsFailure(Throwable cause)
/////////////////////////////////////////////////////////////////////////
1:     void switchToUtf8CcsidMgr() {
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
0: import java.io.PrintWriter;
1: import java.net.Socket;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import org.apache.derby.client.am.ClientStatement;
/////////////////////////////////////////////////////////////////////////
1:     Socket socket_;
0:     InputStream rawSocketInputStream_;
0:     OutputStream rawSocketOutputStream_;
/////////////////////////////////////////////////////////////////////////
1:             socket_ = (Socket)AccessController.doPrivileged(
1:                 new OpenSocketAction(server, port, clientSSLMode_));
1:         } catch (PrivilegedActionException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (SocketException e) {
1:             } catch (IOException doNothing) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
1:             } catch (IOException doNothing) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (SocketException e) {
1:             } catch (IOException doNothing) {
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
1:     public InputStream getInputStream() {
/////////////////////////////////////////////////////////////////////////
1:     public OutputStream getOutputStream() {
1:     void setInputStream(InputStream inputStream) {
1:     void setOutputStream(OutputStream outputStream) {
1:         throws DisconnectException {
1:         //DisconnectException
/////////////////////////////////////////////////////////////////////////
0:     public LogWriter newLogWriter_(PrintWriter printWriter,
/////////////////////////////////////////////////////////////////////////
1:     public void beginWriteChain(ClientStatement statement) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     protected void beginReadChain(ClientStatement statement)
1:             throws SqlException {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.LogWriter;
0: import org.apache.derby.client.am.Statement;
/////////////////////////////////////////////////////////////////////////
1:                     LogWriter logWriter) throws SqlException {
1:              LogWriter netLogWriter,
/////////////////////////////////////////////////////////////////////////
1:     protected void resetAgent_(LogWriter netLogWriter,
/////////////////////////////////////////////////////////////////////////
0:             throws DisconnectException {
1:             new DisconnectException(this,
0:     public LogWriter newLogWriter_(java.io.PrintWriter printWriter,
/////////////////////////////////////////////////////////////////////////
0:     public void beginWriteChain(Statement statement) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     protected void beginReadChain(Statement statement) throws SqlException {
author:Tiago Aur¨¦lio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:b005ffa
/////////////////////////////////////////////////////////////////////////
1:         currentCcsidManager_ = ebcdicCcsidManager_;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Switches the current CCSID manager to UTF-8
1:      */
0:     public void switchToUtf8CcsidMgr() {
1:         currentCcsidManager_ = utf8CcsidManager_;
1:     }
1:     
1:     /**
1:      * Switches the current CCSID manager to EBCDIC
1:      */
0:     public void switchToEbcdicMgr() {
1:         currentCcsidManager_ = ebcdicCcsidManager_;
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1451af7
/////////////////////////////////////////////////////////////////////////
1:             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);
/////////////////////////////////////////////////////////////////////////
1:             netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);
commit:6384512
/////////////////////////////////////////////////////////////////////////
0:     public SqlException exceptionConvertingRdbnam = null;
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         exceptionConvertingRdbnam = null;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b9687fb
/////////////////////////////////////////////////////////////////////////
1:     private EbcdicCcsidManager ebcdicCcsidManager_;
1:     private Utf8CcsidManager utf8CcsidManager_;
1:     private CcsidManager currentCcsidManager_;
1:     
1:     // TODO: Remove target? Keep just one CcsidManager?
1:     //public CcsidManager targetCcsidManager_;
/////////////////////////////////////////////////////////////////////////
1:         ebcdicCcsidManager_ = new EbcdicCcsidManager();
1:         utf8CcsidManager_ = new Utf8CcsidManager();
0:         currentCcsidManager_ = ebcdicCcsidManager_;
1:         
0:         // TODO: Remove target? Keep just one ccsidManager?
0:         //targetCcsidManager_ = sourceCcsidManager_; // delete these
/////////////////////////////////////////////////////////////////////////
0:             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, currentCcsidManager_, netConnection_.commBufferSize_);
/////////////////////////////////////////////////////////////////////////
0:             netResultSetRequest_ = new NetResultSetRequest(this, currentCcsidManager_, netConnection_.commBufferSize_);
/////////////////////////////////////////////////////////////////////////
1:     public CcsidManager getCurrentCcsidManager() {
1:         return currentCcsidManager_;
1:     }
1:     
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:37ce91b
/////////////////////////////////////////////////////////////////////////
0:     int clientSSLMode_;
/////////////////////////////////////////////////////////////////////////
1:              int clientSSLMode) throws SqlException {
1:         clientSSLMode_ = clientSSLMode;
/////////////////////////////////////////////////////////////////////////
0:             socket_ = (java.net.Socket) java.security.AccessController.doPrivileged(new OpenSocketAction(server, port, clientSSLMode_));
commit:6bc2e25
/////////////////////////////////////////////////////////////////////////
0:     boolean useSSL_;
1: 
/////////////////////////////////////////////////////////////////////////
1:              int port,
0:              boolean useSSL) throws SqlException {
0:         useSSL_ = useSSL;
1: 
/////////////////////////////////////////////////////////////////////////
0:             socket_ = (java.net.Socket) java.security.AccessController.doPrivileged(new OpenSocketAction(server, port, useSSL_));
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:20a22b0
/////////////////////////////////////////////////////////////////////////
0:                 new Object[] { e.getException().getClass().getName(), server, 
0:                     Integer.toString(port), e.getException().getMessage() },
commit:1b39163
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derby.shared.common.reference.MessageId;
0: import org.apache.derby.shared.common.i18n.MessageUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new DisconnectException(this, 
1:                 new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET),
1:                 "serverName");
1:                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER),
0:                 new Object[] { e.getClass().getName(), server, new Integer(port), 
0:                     e.getException().getMessage() },
0:                 e.getException());
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION),
0:                 e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:             exceptionOpeningSocket_ = new DisconnectException(this, 
1:                 new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM),
0:                 e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(logWriter_, 
1:                 new ClientMessageId(SQLState.SOCKET_EXCEPTION),
0:                 e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                 accumulatedExceptions = new SqlException(logWriter_,
1:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
0:                     e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
0:                     e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.COMMUNICATION_ERROR),
0:                         e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:             throwCommunicationsFailure(e);
/////////////////////////////////////////////////////////////////////////
0:     public void throwCommunicationsFailure(Throwable cause) 
0:         throws org.apache.derby.client.am.DisconnectException {
1:         accumulateChainBreakingReadExceptionAndThrow(
0:             new org.apache.derby.client.am.DisconnectException(this,
1:                 new ClientMessageId(SQLState.COMMUNICATION_ERROR),
0:                 cause.getMessage(), cause));
1:         
/////////////////////////////////////////////////////////////////////////
1:             DisconnectException de = new DisconnectException(this, 
1:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
/////////////////////////////////////////////////////////////////////////
1:             DisconnectException de = new DisconnectException(this, 
1:                 new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:592457a
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketException;
1: 
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Specifies the maximum blocking time that should be used when sending
1:      * and receiving messages. The timeout is implemented by using the the 
1:      * underlying socket implementation's timeout support. 
1:      * 
1:      * Note that the support for timeout on sockets is dependent on the OS 
1:      * implementation. For the same reason we ignore any exceptions thrown
1:      * by the call to the socket layer.
1:      * 
1:      * @param timeout The timeout value in seconds. A value of 0 corresponds to 
1:      * infinite timeout.
1:      */
1:     protected void setTimeout(int timeout) {
1:         try {
1:             // Sets a timeout on the socket
1:             socket_.setSoTimeout(timeout * 1000); // convert to milliseconds
1:         } catch (SocketException se) {
1:             // Silently ignore any exceptions from the socket layer
1:             if (SanityManager.DEBUG) {
1:                 System.out.println("NetAgent.setTimeout: ignoring exception: " + 
1:                                    se);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Returns the current timeout value that is set on the socket.
1:      * 
1:      * Note that the support for timeout on sockets is dependent on the OS 
1:      * implementation. For the same reason we ignore any exceptions thrown
1:      * by the call to the socket layer.
1:      * 
1:      * @return The timeout value in seconds. A value of 0 corresponds to
1:      * that no timeout is specified on the socket.
1:      */
1:     protected int getTimeout() {
1:         int timeout = 0; // 0 is default timeout for sockets
1: 
1:         // Read the timeout currently set on the socket
1:         try {
1:             timeout = socket_.getSoTimeout();
1:         } catch (SocketException se) {
1:             // Silently ignore any exceptions from the socket layer
1:             if (SanityManager.DEBUG) {
1:                 System.out.println("NetAgent.getTimeout: ignoring exception: " + 
1:                                    se);
1:             }
1:         }
1: 
1:         // Convert from milliseconds to seconds (note that this truncates
1:         // the results towards zero but that should not be a problem).
1:         timeout = timeout / 1000;
1:         return timeout;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0ea00b3
/////////////////////////////////////////////////////////////////////////
0:                     e.getClass().getName() + " : Error opening socket to server " + server + " on port " + port + " with message : " + e.getException().getMessage());
commit:679d226
/////////////////////////////////////////////////////////////////////////
0:             throw new DisconnectException(this, "Required property \"serverName\" not set");
1:             throw new DisconnectException(this,
/////////////////////////////////////////////////////////////////////////
1:             exceptionOpeningSocket_ = new DisconnectException(this,
/////////////////////////////////////////////////////////////////////////
0:             exceptionOpeningSocket_ = new DisconnectException(this, "unable to open stream on socket '"+e.getMessage() + "'");
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetAgent
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.net;
1: 
1: import org.apache.derby.client.am.Agent;
1: import org.apache.derby.client.am.Utils;
1: import org.apache.derby.client.am.SqlException;
1: import org.apache.derby.client.am.DisconnectException;
1: 
0: public class NetAgent extends Agent
1: {
1:   //---------------------navigational members-----------------------------------
1: 
1:   // All these request objects point to the same physical request object.
0:   public ConnectionRequestInterface connectionRequest_;
0:   public NetConnectionRequest packageRequest_;
0:   public StatementRequestInterface statementRequest_;
0:   public ResultSetRequestInterface resultSetRequest_;
1: 
1:   // All these reply objects point to the same physical reply object.
0:   public ConnectionReply connectionReply_;
0:   public ConnectionReply packageReply_;
0:   public StatementReply statementReply_;
0:   public ResultSetReply resultSetReply_;
1: 
1:   //---------------------navigational cheat-links-------------------------------
1:   // Cheat-links are for convenience only, and are not part of the conceptual model.
1:   // Warning:
1:   //   Cheat-links should only be defined for invariant state data.
1:   //   That is, the state data is set by the constructor and never changes.
1: 
1:   // Alias for (NetConnection) super.connection
1:   NetConnection netConnection_;
1: 
1:   // Alias for (Request) super.*Request, all in one
1:   // In the case of the NET implementation, these all point to the same physical request object.
0:   protected Request request_;
0:   public NetConnectionRequest netConnectionRequest_;
0:   public NetPackageRequest netPackageRequest_;
0:   public NetStatementRequest netStatementRequest_;
0:   public NetResultSetRequest netResultSetRequest_;
1: 
1:   // Alias for (Reply) super.*Reply, all in one.
1:   // In the case of the NET implementation, these all point to the same physical reply object.
0:   protected Reply reply_;
0:   public NetConnectionReply netConnectionReply_;
0:   public NetPackageReply netPackageReply_;
0:   public NetStatementReply netStatementReply_;
0:   public NetResultSetReply netResultSetReply_;
1: 
1:   //-----------------------------state------------------------------------------
1: 
0:   java.net.Socket socket_; 
0:   java.io.InputStream rawSocketInputStream_;
0:   java.io.OutputStream rawSocketOutputStream_;
1: 
1:   String server_;
1:   int port_;
0:   public CcsidManager sourceCcsidManager_;
0:   public CcsidManager targetCcsidManager_;
0:   public Typdef typdef_;
0:   public Typdef targetTypdef_;
0:   public Typdef originalTargetTypdef_; // added to support typdef overrides
1: 
0:   protected int svrcod_;
1: 
0:   public int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7; 
0:   public int targetSqlam_ = orignalTargetSqlam_;
1: 
0:   public SqlException exceptionOpeningSocket_ = null;
1:   //---------------------constructors/finalizer---------------------------------
1:   public NetAgent(NetConnection netConnection,
0:                  org.apache.derby.client.am.LogWriter logWriter) throws SqlException
1:   {
0:     super (netConnection, logWriter);
1:     this.netConnection_ = netConnection;
1:   }
1: 
0:   NetAgent (NetConnection netConnection,
0:            org.apache.derby.client.am.LogWriter netLogWriter,
1:            int loginTimeout,
1:            String server,
0:            int port) throws SqlException
1:   {
0:     super (netConnection, netLogWriter);
1: 
1:     server_ = server;
1:     port_ = port;
1:     netConnection_ = netConnection;
0:     if (server_ == null) throw new SqlException (logWriter_, "Required property \"serverName\" not set");
1: 
1:     try {
0:       socket_ = (java.net.Socket) java.security.AccessController.doPrivileged (new OpenSocketAction(server, port));
1:     }
0:     catch (java.security.PrivilegedActionException e) {
0:       throw new SqlException(
0:             logWriter_,
0:             e.getException(),
0:             e.getClass().getName() + " : Error opening socket to server " + server + " on port " + port + " with message : " + e.getMessage());
1:     }
1: 
1:     // Set TCP/IP Socket Properties
1:     try {
1:       if (exceptionOpeningSocket_ == null) {
0:       socket_.setTcpNoDelay (true); // disables nagles algorithm
0:       socket_.setKeepAlive (true); // PROTOCOL Manual: TCP/IP connection allocation rule #2
0:       socket_.setSoTimeout (loginTimeout*1000);
1:     }
1:     }
0:     catch (java.net.SocketException e) {
0:       try { socket_.close(); } catch (java.io.IOException doNothing) {}
0:       exceptionOpeningSocket_ = new SqlException (logWriter_, e,
0:                                    "SocketException '" + e.getMessage() + "'");
1:     }
1: 
1:     try {
1:       if (exceptionOpeningSocket_ == null) {
1:       rawSocketOutputStream_ = socket_.getOutputStream();
1:       rawSocketInputStream_ = socket_.getInputStream();
1:     }
1:     }
0:     catch (java.io.IOException e) {
0:       try { socket_.close(); } catch (java.io.IOException doNothing) {}
0:       exceptionOpeningSocket_ = new SqlException (logWriter_, e, "unable to open stream on socket");
1:     }
1: 
0:     sourceCcsidManager_ = new EbcdicCcsidManager(); // delete these 
0:     targetCcsidManager_ = sourceCcsidManager_; // delete these 
1: 
1:     if (netConnection_.isXAConnection()) {
0:       NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply (this, netConnection_.commBufferSize_);
1:       netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;
1:       netStatementReply_ = (NetStatementReply) netResultSetReply_;
1:       netPackageReply_ = (NetPackageReply) netStatementReply_;
1:       netConnectionReply_ = (NetConnectionReply) netPackageReply_;
1:       reply_ = (Reply) netConnectionReply_;
1: 
0:       resultSetReply_ = new ResultSetReply (this,
1:                                             netResultSetReply_,
1:                                             netStatementReply_,
1:                                             netConnectionReply_);
1:       statementReply_ = (StatementReply) resultSetReply_;
1:       packageReply_ = (ConnectionReply) statementReply_;
1:       connectionReply_ = (ConnectionReply) packageReply_;
0:       NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest (this, sourceCcsidManager_, netConnection_.commBufferSize_);
1:       netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;
1:       netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
1:       netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
1:       netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
1:       request_ = (Request) netConnectionRequest_;
1: 
1:       resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
1:       statementRequest_ = (StatementRequestInterface) netStatementRequest_;
0:       packageRequest_ = (NetConnectionRequest) netPackageRequest_;
1:       connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
1:     }
0:     else {
0:     netResultSetReply_ = new NetResultSetReply (this, netConnection_.commBufferSize_);
1:     netStatementReply_ = (NetStatementReply) netResultSetReply_;
1:     netPackageReply_ = (NetPackageReply) netStatementReply_;
1:     netConnectionReply_ = (NetConnectionReply) netPackageReply_;
1:     reply_ = (Reply) netConnectionReply_;
1: 
0:     resultSetReply_ = new ResultSetReply (this,
1:                                           netResultSetReply_,
1:                                           netStatementReply_,
1:                                           netConnectionReply_);
1:     statementReply_ = (StatementReply) resultSetReply_;
1:     packageReply_ = (ConnectionReply) statementReply_;
1:     connectionReply_ = (ConnectionReply) packageReply_;
0:     netResultSetRequest_ = new NetResultSetRequest (this, sourceCcsidManager_, netConnection_.commBufferSize_);
1:     netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
1:     netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
1:     netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
1:     request_ = (Request) netConnectionRequest_;
1: 
1:     resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
1:     statementRequest_ = (StatementRequestInterface) netStatementRequest_;
0:     packageRequest_ = (NetConnectionRequest) netPackageRequest_;
1:     connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
1:   }
1:   }
1: 
0:   protected void resetAgent_ (
0:                      org.apache.derby.client.am.LogWriter netLogWriter,
1:                      //CcsidManager sourceCcsidManager,
1:                      //CcsidManager targetCcsidManager,
1:                      int loginTimeout,
1:                      String server,
0:                      int port) throws SqlException
1:   {
1: 
1:     // most properties will remain unchanged on connect reset.
1:     targetTypdef_ = originalTargetTypdef_;
1:     svrcod_ = 0;
1: 
1:     // Set TCP/IP Socket Properties
1:     try {
0:       socket_.setSoTimeout (loginTimeout*1000);
1:     }
0:     catch (java.net.SocketException e) {
0:       try { socket_.close(); } catch (java.io.IOException doNothing) {}
0:       throw new SqlException (logWriter_, e, "SocketException '" + e.getMessage() + "'");
1:     }
1:   }
1: 
1: 
0:   void setSvrcod (int svrcod)
1:   {
0:     if (svrcod > svrcod_) svrcod_ = svrcod;
1:   }
1: 
0:   void clearSvrcod ()
1:   {
1:     svrcod_ = CodePoint.SVRCOD_INFO;
1:   }
1: 
0:   int getSvrcod()
1:   {
1:     return svrcod_;
1:   }
1: 
0:   public void flush_ () throws DisconnectException
1:   {
0:     sendRequest ();
0:     reply_.initialize ();
1:   }
1: 
1:   // Close socket and its streams.
0:   public void close_() throws SqlException
1:   {
1:     // can we just close the socket here, do we need to close streams individually 
1:     SqlException accumulatedExceptions = null;
1:     if (rawSocketInputStream_ != null) {
1:       try {
1:         rawSocketInputStream_.close();
1:       }
0:       catch (java.io.IOException e) {
1:         // note when {6} = 0 it indicates the socket was closed.
1:         // this should be ok since we are going to go an close the socket
1:         // immediately following this call.
1:         // changing {4} to e.getMessage() may require pub changes
0:         accumulatedExceptions =
0:           new SqlException (logWriter_, e, "A communication error has been detected. " +
0:                                    "Communication protocol being used: {0}. " +
0:                                    "Communication API being used: {1}. " +
0:                                    "Location where the error was detected: {2}. " +
0:                                    "Communication function detecting the error: {3}. " +
0:                                    "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:                                    "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:                                    "InputStream.close() " + e.getMessage() +" " + "* " +"0");
0:                                    //"08001",
0:                                    //-30081);
1:       }
0:       finally {
1:         rawSocketInputStream_ = null;
1:       }
1:     }
1: 
1:     if (rawSocketOutputStream_ != null) {
1:       try {
1:         rawSocketOutputStream_.close();
1:       }
0:       catch (java.io.IOException e) {
1:         // note when {6} = 0 it indicates the socket was closed.
1:         // this should be ok since we are going to go an close the socket
1:         // immediately following this call.
1:         // changing {4} to e.getMessage() may require pub changes
0:         SqlException latestException = new SqlException (
0:           logWriter_,
0:           e,
0:           "A communication error has been detected. " +
0:           "Communication protocol being used: {0}. " +
0:           "Communication API being used: {1}. " +
0:           "Location where the error was detected: {2}. " +
0:           "Communication function detecting the error: {3}. " +
0:           "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:           "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:           "OutputStream.close() " + e.getMessage() +" " + "* " +"0");
0:         accumulatedExceptions = Utils.accumulateSQLException (latestException, accumulatedExceptions);
1:       }
0:       finally {
1:         rawSocketOutputStream_ = null;
1:       }
1:     }
1: 
1:     if (socket_ != null) {
1:       try {
1:         socket_.close();
1:       }
0:       catch (java.io.IOException e) {
1:         // again {6} = 0, indicates the socket was closed.
1:         // maybe set {4} to e.getMessage().
1:         // do this for now and but may need to modify or
1:         // add this to the message pubs.
0:         SqlException latestException = new SqlException (
0:           logWriter_,
0:           e,
0:           "A communication error has been detected. " +
0:           "Communication protocol being used: {0}. " +
0:           "Communication API being used: {1}. " +
0:           "Location where the error was detected: {2}. " +
0:           "Communication function detecting the error: {3}. " +
0:           "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:           "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:           "Socket.close() " + e.getMessage() + " " + "* " +"0");
0:         accumulatedExceptions = Utils.accumulateSQLException (latestException, accumulatedExceptions);
1:       }
0:       finally {
1:         socket_ = null;
1:       }
1:     }
1: 
0:     if (accumulatedExceptions != null)
1:       throw accumulatedExceptions;
1:   }
1: 
1: 
0:   protected void sendRequest () throws DisconnectException
1:   {
1:     try {
0:       request_.flush (rawSocketOutputStream_);
1:     }
0:     catch (java.io.IOException e) {
0:       throwCommunicationsFailure ( 
0:                                         "NetAgent.sendRequest()",
0:                                         "OutputStream.flush()",
0:                                         e.getMessage(),
0:                                         "*");
1:     }
1:   }
1: 
0:   public java.io.InputStream getInputStream () { return rawSocketInputStream_; }
0:   public java.io.OutputStream getOutputStream () { return rawSocketOutputStream_; }
1: 
0:   void setInputStream (java.io.InputStream inputStream)
0:   { rawSocketInputStream_ = inputStream; }
1: 
0:   void setOutputStream (java.io.OutputStream outputStream)
0:   { rawSocketOutputStream_ = outputStream; }
1: 
0:   public void throwCommunicationsFailure (String location,
0:                                   String function,
0:                                   String rc1,
0:                                   String rc2) throws org.apache.derby.client.am.DisconnectException
1:   {
0:     //org.apache.derby.client.am.DisconnectException
1:     //accumulateReadExceptionAndDisconnect
1:     // note when {6} = 0 it indicates the socket was closed.
1:     // need to still validate any token values against message publications.
0:     accumulateChainBreakingReadExceptionAndThrow (
0:       new org.apache.derby.client.am.DisconnectException (
0:         this,
0:         "A communication error has been detected. " +
0:         "Communication protocol being used: " + location + ". " +
0:         "Communication API being used: " + function + ". " +
0:         "Location where the error was detected: " + rc1 + ". " +
0:         "Communication function detecting the error: " + rc2 + ". " +
0:         "Protocol specific error codes(s) " +
0:         "TCP/IP SOCKETS "));  // hardcode tokens 0 and 1
0:         //"08001"));  //derby code -30081, don't send 08001 now either
1:   }
1: 
1:   // ----------------------- call-down methods ---------------------------------
1: 
0:   public org.apache.derby.client.am.LogWriter newLogWriter_ (java.io.PrintWriter printWriter,
0:                                                         int traceLevel)
1:   {
0:     return new NetLogWriter (printWriter, traceLevel);
1:   }
1: 
0:   protected void markChainBreakingException_ ()
1:   {
0:     setSvrcod (CodePoint.SVRCOD_ERROR);
1:   }
1: 
0:   public void checkForChainBreakingException_ () throws SqlException
1:   {
1:     int svrcod = getSvrcod();
1:     clearSvrcod();
1:     if (svrcod > CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod > WARNING, then its a chain breaker
1:       super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.
1:   }
1: 
0:   private void writeDeferredResetConnection() throws SqlException
1:   {
0:     if (!netConnection_.resetConnectionAtFirstSql_) return;
1:     try {
1:       netConnection_.writeDeferredReset();
1:     }
0:     catch (SqlException sqle) {
0:       DisconnectException de = new DisconnectException (
0:         this,"An error occurred during a deferred connect reset and the connection has been terminated.  See chained exceptions for details.");
1:       de.setNextException(sqle);
1:       throw de;
1:     }
1:   }
1: 
0:   public void beginWriteChainOutsideUOW () throws SqlException
1:   {
1:     request_.initialize();
1:     writeDeferredResetConnection();
0:     super.beginWriteChainOutsideUOW ();
1:   }
1: 
0:   public void beginWriteChain (org.apache.derby.client.am.Statement statement) throws SqlException
1:   {
1:     request_.initialize();
1:     writeDeferredResetConnection();
0:     super.beginWriteChain (statement);
1:   }
1: 
0:   protected void endWriteChain ()
1:   {
0:     super.endWriteChain();
1:   }
1: 
0:   private void readDeferredResetConnection() throws SqlException
1:   {
0:     if (!netConnection_.resetConnectionAtFirstSql_) return;
1:     try {
1:       netConnection_.readDeferredReset();
1:       checkForExceptions();
1:     }
0:     catch (SqlException sqle) {
0:       DisconnectException de = new DisconnectException (
0:         this,"An error occurred during a deferred connect reset and the connection has been terminated.  See chained exceptions for details.");
1:       de.setNextException(sqle);
1:       throw de;
1:     }
1:   }
1: 
0:   protected void beginReadChain (org.apache.derby.client.am.Statement statement) throws SqlException
1:   {
1:     readDeferredResetConnection();
0:     super.beginReadChain (statement);
1:   }
1: 
0:   protected void beginReadChainOutsideUOW () throws SqlException
1:   {
1:     readDeferredResetConnection();
1:     super.beginReadChainOutsideUOW();
1:   }
1: 
0:   public void endReadChain () throws SqlException
1:   {
0:     super.endReadChain();
1:   }
1: 
1: 
0:   public String convertToStringTcpIpAddress (int tcpIpAddress)
1:   {
0:    StringBuffer ipAddrBytes = new StringBuffer();
0:    ipAddrBytes.append ((tcpIpAddress >> 24) &  0xff);
0:    ipAddrBytes.append (".");
0:    ipAddrBytes.append ((tcpIpAddress >> 16) & 0xff);
0:    ipAddrBytes.append (".");
0:    ipAddrBytes.append ((tcpIpAddress >> 8) & 0xff);
0:    ipAddrBytes.append (".");
0:    ipAddrBytes.append ((tcpIpAddress) & 0xff);
1: 
0:    return ipAddrBytes.toString();
1:  }
1: 
0:  protected int getPort()
1:  {
0:    return port_;
1:  }
1: 
1: }
1: 
1: 
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.Utils;
1: public class NetAgent extends Agent {
0:     //---------------------navigational members-----------------------------------
0:     // All these request objects point to the same physical request object.
0:     public ConnectionRequestInterface connectionRequest_;
0:     public NetConnectionRequest packageRequest_;
0:     public StatementRequestInterface statementRequest_;
0:     public ResultSetRequestInterface resultSetRequest_;
0:     // All these reply objects point to the same physical reply object.
0:     public ConnectionReply connectionReply_;
0:     public ConnectionReply packageReply_;
0:     public StatementReply statementReply_;
0:     public ResultSetReply resultSetReply_;
0:     //---------------------navigational cheat-links-------------------------------
0:     // Cheat-links are for convenience only, and are not part of the conceptual model.
0:     // Warning:
0:     //   Cheat-links should only be defined for invariant state data.
0:     //   That is, the state data is set by the constructor and never changes.
0:     // Alias for (NetConnection) super.connection
0:     NetConnection netConnection_;
0:     // Alias for (Request) super.*Request, all in one
0:     // In the case of the NET implementation, these all point to the same physical request object.
0:     protected Request request_;
0:     public NetConnectionRequest netConnectionRequest_;
0:     public NetPackageRequest netPackageRequest_;
0:     public NetStatementRequest netStatementRequest_;
0:     public NetResultSetRequest netResultSetRequest_;
0:     // Alias for (Reply) super.*Reply, all in one.
0:     // In the case of the NET implementation, these all point to the same physical reply object.
0:     protected Reply reply_;
0:     public NetConnectionReply netConnectionReply_;
0:     public NetPackageReply netPackageReply_;
0:     public NetStatementReply netStatementReply_;
0:     public NetResultSetReply netResultSetReply_;
0:     //-----------------------------state------------------------------------------
0:     java.net.Socket socket_;
0:     java.io.InputStream rawSocketInputStream_;
0:     java.io.OutputStream rawSocketOutputStream_;
0:     String server_;
0:     int port_;
0:     public CcsidManager sourceCcsidManager_;
0:     public CcsidManager targetCcsidManager_;
0:     public Typdef typdef_;
0:     public Typdef targetTypdef_;
0:     public Typdef originalTargetTypdef_; // added to support typdef overrides
0:     protected int svrcod_;
0:     public int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;
0:     public int targetSqlam_ = orignalTargetSqlam_;
0:     public SqlException exceptionOpeningSocket_ = null;
0:     //---------------------constructors/finalizer---------------------------------
0:     public NetAgent(NetConnection netConnection,
0:                     org.apache.derby.client.am.LogWriter logWriter) throws SqlException {
1:         super(netConnection, logWriter);
0:         this.netConnection_ = netConnection;
1:     NetAgent(NetConnection netConnection,
0:              org.apache.derby.client.am.LogWriter netLogWriter,
0:              int loginTimeout,
0:              String server,
1:              int port) throws SqlException {
1:         super(netConnection, netLogWriter);
0: 
0:         server_ = server;
0:         port_ = port;
0:         netConnection_ = netConnection;
1:         if (server_ == null) {
0:             throw new SqlException(logWriter_, "Required property \"serverName\" not set");
0:         }
0: 
1:         try {
0:             socket_ = (java.net.Socket) java.security.AccessController.doPrivileged(new OpenSocketAction(server, port));
0:         } catch (java.security.PrivilegedActionException e) {
0:             throw new SqlException(logWriter_,
0:                     e.getException(),
0:                     e.getClass().getName() + " : Error opening socket to server " + server + " on port " + port + " with message : " + e.getMessage());
0:         }
0: 
0:         // Set TCP/IP Socket Properties
1:         try {
0:             if (exceptionOpeningSocket_ == null) {
1:                 socket_.setTcpNoDelay(true); // disables nagles algorithm
1:                 socket_.setKeepAlive(true); // PROTOCOL Manual: TCP/IP connection allocation rule #2
1:                 socket_.setSoTimeout(loginTimeout * 1000);
0:             }
0:         } catch (java.net.SocketException e) {
1:             try {
1:                 socket_.close();
0:             } catch (java.io.IOException doNothing) {
0:             }
0:             exceptionOpeningSocket_ = new SqlException(logWriter_, e,
0:                     "SocketException '" + e.getMessage() + "'");
0:         }
0: 
1:         try {
0:             if (exceptionOpeningSocket_ == null) {
0:                 rawSocketOutputStream_ = socket_.getOutputStream();
0:                 rawSocketInputStream_ = socket_.getInputStream();
0:             }
0:         } catch (java.io.IOException e) {
1:             try {
1:                 socket_.close();
0:             } catch (java.io.IOException doNothing) {
0:             }
0:             exceptionOpeningSocket_ = new SqlException(logWriter_, e, "unable to open stream on socket");
0:         }
0: 
0:         sourceCcsidManager_ = new EbcdicCcsidManager(); // delete these
0:         targetCcsidManager_ = sourceCcsidManager_; // delete these
0: 
0:         if (netConnection_.isXAConnection()) {
1:             NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);
0:             netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;
0:             netStatementReply_ = (NetStatementReply) netResultSetReply_;
0:             netPackageReply_ = (NetPackageReply) netStatementReply_;
0:             netConnectionReply_ = (NetConnectionReply) netPackageReply_;
0:             reply_ = (Reply) netConnectionReply_;
0: 
1:             resultSetReply_ = new ResultSetReply(this,
0:                     netResultSetReply_,
0:                     netStatementReply_,
0:                     netConnectionReply_);
0:             statementReply_ = (StatementReply) resultSetReply_;
0:             packageReply_ = (ConnectionReply) statementReply_;
0:             connectionReply_ = (ConnectionReply) packageReply_;
0:             NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, sourceCcsidManager_, netConnection_.commBufferSize_);
0:             netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;
0:             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
0:             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
0:             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
0:             request_ = (Request) netConnectionRequest_;
0: 
0:             resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
0:             statementRequest_ = (StatementRequestInterface) netStatementRequest_;
0:             packageRequest_ = (NetConnectionRequest) netPackageRequest_;
0:             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
1:         } else {
1:             netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);
0:             netStatementReply_ = (NetStatementReply) netResultSetReply_;
0:             netPackageReply_ = (NetPackageReply) netStatementReply_;
0:             netConnectionReply_ = (NetConnectionReply) netPackageReply_;
0:             reply_ = (Reply) netConnectionReply_;
0: 
1:             resultSetReply_ = new ResultSetReply(this,
0:                     netResultSetReply_,
0:                     netStatementReply_,
0:                     netConnectionReply_);
0:             statementReply_ = (StatementReply) resultSetReply_;
0:             packageReply_ = (ConnectionReply) statementReply_;
0:             connectionReply_ = (ConnectionReply) packageReply_;
0:             netResultSetRequest_ = new NetResultSetRequest(this, sourceCcsidManager_, netConnection_.commBufferSize_);
0:             netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
0:             netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
0:             netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
0:             request_ = (Request) netConnectionRequest_;
0: 
0:             resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
0:             statementRequest_ = (StatementRequestInterface) netStatementRequest_;
0:             packageRequest_ = (NetConnectionRequest) netPackageRequest_;
0:             connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
0:         }
0:     protected void resetAgent_(org.apache.derby.client.am.LogWriter netLogWriter,
0:                                //CcsidManager sourceCcsidManager,
0:                                //CcsidManager targetCcsidManager,
0:                                int loginTimeout,
0:                                String server,
1:                                int port) throws SqlException {
0: 
0:         // most properties will remain unchanged on connect reset.
0:         targetTypdef_ = originalTargetTypdef_;
0:         svrcod_ = 0;
0: 
0:         // Set TCP/IP Socket Properties
1:         try {
1:             socket_.setSoTimeout(loginTimeout * 1000);
0:         } catch (java.net.SocketException e) {
1:             try {
1:                 socket_.close();
0:             } catch (java.io.IOException doNothing) {
0:             }
0:             throw new SqlException(logWriter_, e, "SocketException '" + e.getMessage() + "'");
0:         }
1:     void setSvrcod(int svrcod) {
1:         if (svrcod > svrcod_) {
1:             svrcod_ = svrcod;
0:         }
1:     void clearSvrcod() {
0:         svrcod_ = CodePoint.SVRCOD_INFO;
0: 
0:     int getSvrcod() {
0:         return svrcod_;
0: 
1:     public void flush_() throws DisconnectException {
1:         sendRequest();
1:         reply_.initialize();
0:     }
0: 
0:     // Close socket and its streams.
1:     public void close_() throws SqlException {
0:         // can we just close the socket here, do we need to close streams individually
0:         SqlException accumulatedExceptions = null;
0:         if (rawSocketInputStream_ != null) {
1:             try {
0:                 rawSocketInputStream_.close();
0:             } catch (java.io.IOException e) {
0:                 // note when {6} = 0 it indicates the socket was closed.
0:                 // this should be ok since we are going to go an close the socket
0:                 // immediately following this call.
0:                 // changing {4} to e.getMessage() may require pub changes
0:                 accumulatedExceptions =
0:                         new SqlException(logWriter_, e, "A communication error has been detected. " +
0:                         "Communication protocol being used: {0}. " +
0:                         "Communication API being used: {1}. " +
0:                         "Location where the error was detected: {2}. " +
0:                         "Communication function detecting the error: {3}. " +
0:                         "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:                         "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:                         "InputStream.close() " + e.getMessage() + " " + "* " + "0");
0:                 //"08001",
0:                 //-30081);
1:             } finally {
0:                 rawSocketInputStream_ = null;
0:             }
0:         }
0: 
0:         if (rawSocketOutputStream_ != null) {
1:             try {
0:                 rawSocketOutputStream_.close();
0:             } catch (java.io.IOException e) {
0:                 // note when {6} = 0 it indicates the socket was closed.
0:                 // this should be ok since we are going to go an close the socket
0:                 // immediately following this call.
0:                 // changing {4} to e.getMessage() may require pub changes
1:                 SqlException latestException = new SqlException(logWriter_,
0:                         e,
0:                         "A communication error has been detected. " +
0:                         "Communication protocol being used: {0}. " +
0:                         "Communication API being used: {1}. " +
0:                         "Location where the error was detected: {2}. " +
0:                         "Communication function detecting the error: {3}. " +
0:                         "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:                         "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:                         "OutputStream.close() " + e.getMessage() + " " + "* " + "0");
1:                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
1:             } finally {
0:                 rawSocketOutputStream_ = null;
0:             }
0:         }
0: 
0:         if (socket_ != null) {
1:             try {
1:                 socket_.close();
0:             } catch (java.io.IOException e) {
0:                 // again {6} = 0, indicates the socket was closed.
0:                 // maybe set {4} to e.getMessage().
0:                 // do this for now and but may need to modify or
0:                 // add this to the message pubs.
1:                 SqlException latestException = new SqlException(logWriter_,
0:                         e,
0:                         "A communication error has been detected. " +
0:                         "Communication protocol being used: {0}. " +
0:                         "Communication API being used: {1}. " +
0:                         "Location where the error was detected: {2}. " +
0:                         "Communication function detecting the error: {3}. " +
0:                         "Protocol specific error codes(s) {4}, {5}, {6}. " +
0:                         "TCP/IP " + "SOCKETS " + "Agent.close() " +
0:                         "Socket.close() " + e.getMessage() + " " + "* " + "0");
1:                 accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
1:             } finally {
0:                 socket_ = null;
0:             }
0:         }
0: 
1:         if (accumulatedExceptions != null) {
0:             throw accumulatedExceptions;
0:         }
0:     }
0:     protected void sendRequest() throws DisconnectException {
1:         try {
1:             request_.flush(rawSocketOutputStream_);
0:         } catch (java.io.IOException e) {
0:             throwCommunicationsFailure("NetAgent.sendRequest()",
0:                     "OutputStream.flush()",
0:                     e.getMessage(),
0:                     "*");
0:         }
0:     }
0:     public java.io.InputStream getInputStream() {
1:         return rawSocketInputStream_;
0:     }
0:     public java.io.OutputStream getOutputStream() {
1:         return rawSocketOutputStream_;
0:     }
0:     void setInputStream(java.io.InputStream inputStream) {
1:         rawSocketInputStream_ = inputStream;
0:     }
0:     void setOutputStream(java.io.OutputStream outputStream) {
1:         rawSocketOutputStream_ = outputStream;
0:     }
0: 
0:     public void throwCommunicationsFailure(String location,
0:                                            String function,
0:                                            String rc1,
0:                                            String rc2) throws org.apache.derby.client.am.DisconnectException {
0:         //org.apache.derby.client.am.DisconnectException
0:         //accumulateReadExceptionAndDisconnect
0:         // need to still validate any token values against message publications.
0:         accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(this,
0:                 "A communication error has been detected. " +
0:                 "Communication protocol being used: " + location + ". " +
0:                 "Communication API being used: " + function + ". " +
0:                 "Location where the error was detected: " + rc1 + ". " +
0:                 "Communication function detecting the error: " + rc2 + ". " +
0:                 "Protocol specific error codes(s) " +
0:                 "TCP/IP SOCKETS "));  // hardcode tokens 0 and 1
0: 
0:     // ----------------------- call-down methods ---------------------------------
0: 
0:     public org.apache.derby.client.am.LogWriter newLogWriter_(java.io.PrintWriter printWriter,
0:                                                               int traceLevel) {
0:         return new NetLogWriter(printWriter, traceLevel);
1:     protected void markChainBreakingException_() {
1:         setSvrcod(CodePoint.SVRCOD_ERROR);
0: 
1:     public void checkForChainBreakingException_() throws SqlException {
0:         int svrcod = getSvrcod();
0:         clearSvrcod();
0:         if (svrcod > CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod > WARNING, then its a chain breaker
0:         {
0:             super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.
0:         }
1:     private void writeDeferredResetConnection() throws SqlException {
1:         if (!netConnection_.resetConnectionAtFirstSql_) {
1:             return;
0:         }
1:         try {
0:             netConnection_.writeDeferredReset();
1:         } catch (SqlException sqle) {
0:             DisconnectException de = new DisconnectException(this, "An error occurred during a deferred connect reset and the connection has been terminated.  See chained exceptions for details.");
0:             de.setNextException(sqle);
0:             throw de;
0:         }
0:     }
1:     public void beginWriteChainOutsideUOW() throws SqlException {
0:         request_.initialize();
0:         writeDeferredResetConnection();
0:         super.beginWriteChainOutsideUOW();
0:     }
0:     public void beginWriteChain(org.apache.derby.client.am.Statement statement) throws SqlException {
0:         request_.initialize();
0:         writeDeferredResetConnection();
1:         super.beginWriteChain(statement);
0:     }
0: 
0:     protected void endWriteChain() {
0:         super.endWriteChain();
0:     }
0: 
1:     private void readDeferredResetConnection() throws SqlException {
1:         if (!netConnection_.resetConnectionAtFirstSql_) {
1:             return;
0:         }
1:         try {
0:             netConnection_.readDeferredReset();
0:             checkForExceptions();
1:         } catch (SqlException sqle) {
0:             DisconnectException de = new DisconnectException(this, "An error occurred during a deferred connect reset and the connection has been terminated.  See chained exceptions for details.");
0:             de.setNextException(sqle);
0:             throw de;
0:         }
0:     }
0: 
0:     protected void beginReadChain(org.apache.derby.client.am.Statement statement) throws SqlException {
0:         readDeferredResetConnection();
1:         super.beginReadChain(statement);
0:     }
0: 
1:     protected void beginReadChainOutsideUOW() throws SqlException {
0:         readDeferredResetConnection();
0:         super.beginReadChainOutsideUOW();
0:     }
0: 
0:     public void endReadChain() throws SqlException {
0:         super.endReadChain();
0:     }
0:     public String convertToStringTcpIpAddress(int tcpIpAddress) {
0:         StringBuffer ipAddrBytes = new StringBuffer();
0:         ipAddrBytes.append((tcpIpAddress >> 24) & 0xff);
0:         ipAddrBytes.append(".");
0:         ipAddrBytes.append((tcpIpAddress >> 16) & 0xff);
0:         ipAddrBytes.append(".");
0:         ipAddrBytes.append((tcpIpAddress >> 8) & 0xff);
0:         ipAddrBytes.append(".");
0:         ipAddrBytes.append((tcpIpAddress) & 0xff);
0:         return ipAddrBytes.toString();
0:     }
0:     protected int getPort() {
0:         return port_;
0:     }
============================================================================