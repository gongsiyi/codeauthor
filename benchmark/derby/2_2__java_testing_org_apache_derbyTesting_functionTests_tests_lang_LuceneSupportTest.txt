1:d847ced: /**
1:d847ced:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportTest
1:d847ced:  *  
1:d847ced:  * Licensed to the Apache Software Foundation (ASF) under one
1:d847ced:  * or more contributor license agreements.  See the NOTICE file
1:d847ced:  * distributed with this work for additional information
1:d847ced:  * regarding copyright ownership.  The ASF licenses this file
1:d847ced:  * to you under the Apache License, Version 2.0 (the
1:d847ced:  * "License"); you may not use this file except in compliance
1:d847ced:  * with the License.  You may obtain a copy of the License at
1:d847ced:  *
1:d847ced:  *   http://www.apache.org/licenses/LICENSE-2.0
1:d847ced:  *
1:d847ced:  * Unless required by applicable law or agreed to in writing,
1:d847ced:  * software distributed under the License is distributed on an
1:d847ced:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:d847ced:  * KIND, either express or implied.  See the License for the
1:d847ced:  * specific language governing permissions and limitations
1:d847ced:  * under the License.
1:d847ced:  */
1:d847ced: package org.apache.derbyTesting.functionTests.tests.lang;
1:a4e6298: 
1:a4e6298: import java.io.IOException;
1:a4e6298: import java.io.Reader;
1:d847ced: import java.sql.CallableStatement;
1:a4e6298: import java.sql.PreparedStatement;
1:d847ced: import java.sql.SQLException;
1:d847ced: import java.sql.Statement;
1:a4e6298: import java.util.ArrayList;
1:a4e6298: import java.util.Arrays;
1:a4e6298: import java.util.Iterator;
1:a4e6298: import java.util.List;
1:561e69f: import java.util.Locale;
1:a4e6298: import javax.xml.parsers.DocumentBuilderFactory;
1:d847ced: import junit.framework.Test;
1:1ae02c9: import org.apache.derby.optional.api.LuceneIndexDescriptor;
1:1ae02c9: import org.apache.derby.optional.api.LuceneUtils;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.LocaleTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:a4e6298: import org.apache.lucene.analysis.Analyzer;
1:a4e6298: import org.apache.lucene.analysis.Tokenizer;
1:1ae02c9: import org.apache.lucene.analysis.standard.StandardAnalyzer;
1:a4e6298: import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
1:a4e6298: import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
1:a4e6298: import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
1:a4e6298: import org.apache.lucene.queryparser.classic.QueryParser;
1:a4e6298: import org.apache.lucene.util.Version;
1:1ae02c9: import org.w3c.dom.Document;
1:1ae02c9: import org.w3c.dom.Node;
1:1ae02c9: import org.w3c.dom.NodeList;
1:1ae02c9: import org.xml.sax.InputSource;
1:a4e6298: 
1:d847ced: /**
1:d847ced:  * <p>
1:d847ced:  * Basic test of the optional tool which provides Lucene indexing of
1:d847ced:  * columns in Derby tables.
1:d847ced:  * </p>
1:d847ced:  */
1:d847ced: public class LuceneSupportTest extends BaseJDBCTestCase {
1:a4e6298: 
1:d847ced:     private static  final   String  ILLEGAL_CHARACTER = "42XBD";
6:d847ced:     
1:d847ced: 	public LuceneSupportTest(String name) {
1:d847ced: 		super(name);
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("LuceneSupportTest");
1:561e69f: 
1:561e69f:         Test    baseTest = TestConfiguration.embeddedSuite(LuceneSupportTest.class);
1:435459e:         Test        singleUseTest = TestConfiguration.singleUseDatabaseDecorator( baseTest );
1:435459e:         Test        localizedTest = new LocaleTestSetup( singleUseTest, new Locale( "en", "US" ) );
1:d847ced: 		
1:561e69f: 		suite.addTest(SecurityManagerSetup.noSecurityManager(localizedTest));
1:d847ced:  
1:d847ced: 		return suite;
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	public void testCreateAndQueryIndex() throws Exception {
1:d847ced: 		CallableStatement cSt;
1:d847ced: 		Statement s = createStatement();
1:561e69f: 
1:561e69f:         // verify that we are in an en Locale
1:561e69f:         getConnection().prepareStatement
1:561e69f:             (
1:561e69f:              "create function getDatabaseLocale() returns varchar( 20 )\n" +
1:561e69f:              "language java parameter style java reads sql data\n" +
1:561e69f:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.getDatabaseLocale()'\n"
1:561e69f:              ).executeUpdate();
1:561e69f: 	    JDBC.assertFullResultSet
1:561e69f:             (
1:561e69f:              s.executeQuery
1:561e69f:              (
1:561e69f:               "values ( substr( getDatabaseLocale(), 1, 2 ) )"
1:561e69f:               ),
1:561e69f:              new String[][]
1:561e69f:              {
1:561e69f:                  { "en" }
1:561e69f:              }
1:561e69f:              );
1:561e69f:         getConnection().prepareStatement( "drop function getDatabaseLocale" ).executeUpdate();
1:d847ced: 	    
1:d847ced: 		cSt = prepareCall
1:2277df2:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null )" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 	    
1:d847ced: 	    String[][] expectedRows = new String[][]
1:d847ced:             {
1:d847ced:                 { "1","0","0.8048013" },
1:d847ced: 	    		{ "3","2","0.643841" }
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:a4e6298:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, null ) ) luceneResults"
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 
1:d847ced: 	    expectedRows = new String[][]
1:d847ced:             {
1:d847ced: 	    		{ "3","2","0.643841" }
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:a4e6298:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, .75 ) ) luceneResults"
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 
1:d847ced: 	    JDBC.assertEmpty
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:a4e6298:               "select * from table ( lucenetest.titles__title( 'grapes',  1000, 0.5) ) luceneResults"
1:d847ced:               )
1:d847ced:              );
1:d847ced: 
1:d847ced: 	    expectedRows = new String[][]
1:d847ced:             {
1:d847ced:                 { "The Grapes Of Wrath", "John Steinbeck", "The Viking Press", "0"},
1:d847ced: 	    		{"Vines, Grapes, and Wines", "Jancis Robinson", "Alfred A. Knopf", "2"}
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:d847ced:               "select title, author, publisher, documentID\n" +
1:a4e6298:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', 1000, null ) ) l\n" +
1:d847ced:               "where t.id = l.id\n" 
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 	   
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	public void testUpdateIndex() throws Exception {
1:d847ced: 		CallableStatement cSt;
1:d847ced: 		Statement s = createStatement();
1:d847ced: 		
1:d847ced: 		cSt = prepareCall
1:2277df2:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	    JDBC.assertEmpty
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:d847ced:               "select *\n" +
1:a4e6298:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
1:d847ced:               )
1:d847ced:              );
1:d847ced: 	    
1:d847ced: 	    cSt = prepareCall( "update TITLES SET TITLE='Of Mice and Men' WHERE ID=1" );
1:d847ced: 	    assertUpdateCount(cSt, 1);
1:d847ced: 	    
1:d847ced: 	    JDBC.assertEmpty
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:d847ced:               "select *\n" +
1:a4e6298:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
1:d847ced:               )
1:d847ced:              );
1:d847ced: 	    
1:d847ced: 		cSt = prepareCall
1:2277df2:             ( "call LuceneSupport.updateIndex('lucenetest','titles','title', null)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	    String[][] expectedRows = new String[][]
1:d847ced:             {
1:d847ced:                 { "1","0","1.058217" }
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:d847ced:               "select *\n" +
1:a4e6298:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	public void testListIndex() throws Exception {
1:d847ced: 		CallableStatement cSt;
1:d847ced: 		Statement s = createStatement();
1:d847ced: 
1:d847ced: 	    cSt = prepareCall
1:2277df2:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 	    
1:d847ced: 		cSt = prepareCall
1:2277df2:             ( "call LuceneSupport.createIndex('lucenetest','titles','author', null)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 	    
1:d847ced: 	    // leave out lastmodified as the date will change
1:d847ced: 	    String[][] expectedRows = new String[][]
1:d847ced:             {
1:cb62199:                 { "LUCENETEST", "TITLES", "AUTHOR" },
1:cb62199: 	    		{ "LUCENETEST", "TITLES", "TITLE" }
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:cb62199:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes order by schemaname, tablename, columnname"
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	    expectedRows = new String[][]
1:d847ced:             {
1:cb62199:                 { "LUCENETEST", "TITLES", "AUTHOR" },
1:d847ced:             };
1:d847ced: 	    JDBC.assertFullResultSet
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:cb62199:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes order by schemaname, tablename, columnname"
1:d847ced:               ),
1:d847ced:              expectedRows
1:d847ced:              );
1:d847ced: 
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call LuceneSupport.dropIndex('lucenetest','titles','author')" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 	    
1:d847ced: 	    JDBC.assertEmpty
1:d847ced:             (
1:d847ced:              s.executeQuery
1:d847ced:              (
1:cb62199:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes"
1:d847ced:               )
1:d847ced:              );
1:d847ced: 
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	public void testDropIndexBadCharacters() throws Exception {
1:d847ced: 		CallableStatement st;
1:d847ced: 	    
1:d847ced: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('../','','')");
1:d847ced: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('','../','')");
1:d847ced: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('','','../')");
1:a4e6298: 		
1:d847ced: 	}
1:d847ced: 
1:a4e6298:     //////////////////////////////////////////////////////////////
1:a4e6298:     //
1:a4e6298:     //  BEGIN TEST FOR MULTIPLE FIELDS
1:a4e6298:     //
1:a4e6298:     //////////////////////////////////////////////////////////////
1:a4e6298: 	
1:a4e6298:     public void testMultipleFields() throws SQLException
1:a4e6298:     {
1:a4e6298:         println( "Running multi-field test." );
1:a4e6298:         
1:a4e6298:         Statement s = createStatement();
1:a4e6298: 
1:a4e6298:         s.execute("create table multifield(id int primary key, c clob)");
1:a4e6298:         s.execute("insert into multifield values "
1:a4e6298:                 + "(1, '<document><secret/>No one must know!</document>'), "
1:a4e6298:                 + "(2, '<document>No secret here!</document>')");
1:a4e6298: 
1:a4e6298:         s.execute("call lucenesupport.createindex('lucenetest', 'multifield', "
1:a4e6298:                   + "'c', '" + getClass().getName() + ".makeMultiFieldIndexDescriptor')");
1:a4e6298: 
1:a4e6298:         PreparedStatement ps = prepareStatement(
1:a4e6298:                 "select id from table(multifield__c(?, 100, null)) t");
1:a4e6298: 
1:a4e6298:         String[][] bothRows = { {"1"}, {"2"} };
1:a4e6298: 
1:a4e6298:         ps.setString(1, "text:secret");
1:a4e6298:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:a4e6298:         ps.setString(1, "tags:secret");
1:a4e6298:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:a4e6298:         ps.setString(1, "secret");
1:a4e6298:         JDBC.assertUnorderedResultSet(ps.executeQuery(), bothRows);
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /** Create the custom index descriptor for the multi-field test */
1:a4e6298:     public  static  LuceneIndexDescriptor   makeMultiFieldIndexDescriptor()
1:a4e6298:     {
1:a4e6298:         return new MultiFieldIndexDescriptor();
1:a4e6298:     }
1:a4e6298:     /**
1:a4e6298:      * Create a simple query parser for multiple fields, which uses
1:a4e6298:      * StandardAnalyzer instead of the XMLAnalyzer that was used to create
1:a4e6298:      * the index.
1:a4e6298:      */
1:a4e6298:     public static QueryParser createXMLQueryParser(
1:a4e6298:             Version version, String[] fields, Analyzer analyzer) {
1:a4e6298:         return new MultiFieldQueryParser(
1:a4e6298:                 version, fields, new StandardAnalyzer(version));
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /**
1:a4e6298:      * Custom analyzer for XML files. It indexes the tags and the text
1:a4e6298:      * separately.
1:a4e6298:      */
1:a4e6298:     public static class XMLAnalyzer extends Analyzer {
1:a4e6298: 
1:a4e6298:         public XMLAnalyzer() {
1:a4e6298:             // We want different tokenizers for different fields. Set reuse
1:a4e6298:             // policy to per-field to achieve that.
1:a4e6298:             super(PER_FIELD_REUSE_STRATEGY);
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         @Override
1:a4e6298:         protected TokenStreamComponents createComponents(
1:a4e6298:                 String fieldName, Reader reader) {
1:a4e6298: 
1:a4e6298:             if (fieldName.equals("text")) {
1:a4e6298:                 return new TokenStreamComponents(new XMLTextTokenizer(reader));
1:a4e6298:             }
1:a4e6298: 
1:a4e6298:             if (fieldName.equals("tags")) {
1:a4e6298:                 return new TokenStreamComponents(new XMLTagsTokenizer(reader));
1:a4e6298:             }
1:a4e6298: 
1:a4e6298:             fail("unknown field name: " + fieldName);
1:a4e6298:             return null;
1:a4e6298:         }
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /** Common logic for XMLTextTokenizer and XMLTagsTokenizer. */
1:a4e6298:     private abstract static class AbstractTokenizer extends Tokenizer {
1:a4e6298:         Iterator<String> tokens;
1:a4e6298:         final CharTermAttribute charTermAttr =
1:a4e6298:                 addAttribute(CharTermAttribute.class);
1:a4e6298:         final PositionIncrementAttribute posIncrAttr
1:a4e6298:                 = addAttribute(PositionIncrementAttribute.class);
1:a4e6298: 
1:a4e6298:         AbstractTokenizer(Reader reader) {
1:a4e6298:             super(reader);
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         @Override
1:a4e6298:         public boolean incrementToken() throws IOException {
1:a4e6298:             if (tokens == null) {
1:a4e6298:                 tokens = getTokens().iterator();
1:a4e6298:             }
1:a4e6298: 
1:a4e6298:             if (tokens.hasNext()) {
1:a4e6298:                 charTermAttr.setEmpty();
1:a4e6298:                 charTermAttr.append(tokens.next());
1:a4e6298:                 posIncrAttr.setPositionIncrement(1);
1:a4e6298:                 return true;
1:a4e6298:             } else {
1:a4e6298:                 return false;
1:a4e6298:             }
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         @Override
1:a4e6298:         public void reset() throws IOException {
1:a4e6298:             tokens = null;
1:a4e6298:             super.reset();
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         abstract Iterable<String> getTokens();
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     private static class XMLTextTokenizer extends AbstractTokenizer {
1:a4e6298: 
1:a4e6298:         XMLTextTokenizer(Reader in) {
1:a4e6298:             super(in);
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         @Override
1:a4e6298:         Iterable<String> getTokens() {
1:a4e6298:             StringBuilder text = new StringBuilder();
1:a4e6298:             getAllText(parseXMLDocument(input), text);
1:a4e6298:             return Arrays.asList(text.toString().split("[ \r\n\t]"));
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     private static class XMLTagsTokenizer extends AbstractTokenizer {
1:a4e6298: 
1:a4e6298:         XMLTagsTokenizer(Reader in) {
1:a4e6298:             super(in);
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         @Override
1:a4e6298:         Iterable<String> getTokens() {
1:a4e6298:             return getAllXMLTags(parseXMLDocument(input));
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /** Parse an XML document from a Reader. */
1:a4e6298:     private static Document parseXMLDocument(Reader reader) {
1:a4e6298:         Document doc = null;
1:a4e6298: 
1:a4e6298:         try {
1:a4e6298:             doc = DocumentBuilderFactory.newInstance()
1:a4e6298:                     .newDocumentBuilder().parse(new InputSource(reader));
1:a4e6298:             reader.close();
1:a4e6298:         } catch (Exception e) {
1:a4e6298:             fail("Failed to parse XML document", e);
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:         return doc;
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /** Get a list of all the XML tags in a node. */
1:a4e6298:     private static List<String> getAllXMLTags(Node node) {
1:a4e6298:         ArrayList<String> list = new ArrayList<String>();
1:a4e6298:         NodeList nl = node.getChildNodes();
1:a4e6298:         for (int i = 0; i < nl.getLength(); i++) {
1:a4e6298:             Node n = nl.item(i);
1:a4e6298:             if (n.getNodeType() == Node.ELEMENT_NODE) {
1:a4e6298:                 list.add(n.getNodeName());
1:a4e6298:                 list.addAll(getAllXMLTags(n));
1:a4e6298:             }
1:a4e6298:         }
1:a4e6298:         return list;
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     /** Strip out all tags from an XML node, so that only the text is left. */
1:a4e6298:     private static void getAllText(Node node, StringBuilder sb) {
1:a4e6298:         if (node.getNodeType() == Node.TEXT_NODE) {
1:a4e6298:             sb.append(node.getNodeValue());
1:a4e6298:         } else {
1:a4e6298:             NodeList nl = node.getChildNodes();
1:a4e6298:             for (int i = 0; i < nl.getLength(); i++) {
1:a4e6298:                 getAllText(nl.item(i), sb);
1:a4e6298:             }
1:a4e6298:         }
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     public static class MultiFieldIndexDescriptor implements LuceneIndexDescriptor
1:a4e6298:     {
1:a4e6298:         public  String[]    getFieldNames() { return new String[] { "tags", "text" }; }
1:a4e6298:     
1:a4e6298:         public Analyzer getAnalyzer()   { return new XMLAnalyzer(); }
1:a4e6298: 
1:a4e6298:         public  QueryParser getQueryParser()
1:a4e6298:         {
1:a4e6298:             Version version = LuceneUtils.currentVersion();
1:a4e6298:             
1:a4e6298:             return new MultiFieldQueryParser
1:a4e6298:                 (
1:a4e6298:                  version,
1:a4e6298:                  getFieldNames(),
1:a4e6298:                  new StandardAnalyzer( version )
1:a4e6298:                  );
1:a4e6298:         }
1:a4e6298: 
1:a4e6298:     }
1:a4e6298: 
1:a4e6298:     //////////////////////////////////////////////////////////////
1:a4e6298:     //
1:a4e6298:     //  END TEST FOR MULTIPLE FIELDS
1:a4e6298:     //
1:a4e6298:     //////////////////////////////////////////////////////////////
1:d847ced: 	
1:d847ced: 	protected void setUp() throws SQLException {
1:d847ced: 		CallableStatement cSt;			    
1:d847ced: 		Statement st = createStatement();
1:d847ced: 		
1:d847ced: 		try {
1:d847ced: 			st.executeUpdate("create schema lucenetest");
1:d847ced: 		} catch (Exception e) {
1:d847ced: 		}
1:d847ced: 		st.executeUpdate("set schema lucenetest");	
1:d847ced: 		st.executeUpdate("create table titles (ID int generated always as identity primary key, ISBN varchar(16), PRINTISBN varchar(16), title varchar(1024), subtitle varchar(1024), author varchar(1024), series varchar(1024), publisher varchar(1024), collections varchar(128), collections2 varchar(128))");
1:d847ced: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('9765087650324','9765087650324','The Grapes Of Wrath','The Great Depression in Oklahoma','John Steinbeck','Noble Winners','The Viking Press','National Book Award','Pulitzer Prize')");
1:d847ced: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('6754278542987','6754278542987','Identical: Portraits of Twins','Best Photo Book 2012 by American Photo Magazine','Martin Schoeller','Portraits','teNeues','Photography','')");
1:d847ced: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('2747583475882','2747583475882','Vines, Grapes, and Wines','The wine drinker''s guide to grape varieties','Jancis Robinson','Reference','Alfred A. Knopf','Wine','')");	
1:d847ced: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('4356123483483','4356123483483','A Tale of Two Cities','A fictional account of events leading up to the French revolution','Charles Dickens','Classics','Chapman & Hall','Fiction','Social Criticism')");	
1:d847ced: 
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call syscs_util.syscs_register_tool('luceneSupport',true)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 
1:d847ced: 	}
1:d847ced: 	
1:d847ced: 	protected void tearDown() throws Exception {
1:d847ced: 		CallableStatement cSt;
1:d847ced: 		Statement st = createStatement();
1:d847ced: 		
1:d847ced: 		st.executeUpdate("drop table titles");
1:d847ced: 		
1:d847ced: 		cSt = prepareCall
1:d847ced:             ( "call syscs_util.syscs_register_tool('luceneSupport',false)" );
1:d847ced: 	    assertUpdateCount(cSt, 0);
1:d847ced: 	    super.tearDown();
1:d847ced: 	}
1:d847ced: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.optional.api.LuceneIndexDescriptor;
1: import org.apache.derby.optional.api.LuceneUtils;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.LocaleTestSetup;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.lucene.analysis.standard.StandardAnalyzer;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Node;
1: import org.w3c.dom.NodeList;
1: import org.xml.sax.InputSource;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("LuceneSupportTest");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a4e6298
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.Reader;
1: import java.sql.PreparedStatement;
1: import java.util.ArrayList;
1: import java.util.Arrays;
1: import java.util.Iterator;
1: import java.util.List;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: 
0: import org.w3c.dom.Document;
0: import org.w3c.dom.Node;
0: import org.w3c.dom.NodeList;
0: import org.xml.sax.InputSource;
1: import org.apache.lucene.analysis.Analyzer;
0: import org.apache.lucene.analysis.standard.StandardAnalyzer;
1: import org.apache.lucene.analysis.Tokenizer;
1: import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
1: import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
1: import org.apache.lucene.queryparser.classic.MultiFieldQueryParser;
1: import org.apache.lucene.queryparser.classic.QueryParser;
1: import org.apache.lucene.util.Version;
1: 
0: import org.apache.derby.optional.api.LuceneIndexDescriptor;
0: import org.apache.derby.optional.api.LuceneUtils;
1: 
/////////////////////////////////////////////////////////////////////////
1:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, null ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
1:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, .75 ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
1:               "select * from table ( lucenetest.titles__title( 'grapes',  1000, 0.5) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
1:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', 1000, null ) ) l\n" +
/////////////////////////////////////////////////////////////////////////
1:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
1:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
1:               "from table ( lucenetest.titles__title( 'mice', 1000, null ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
1: 
1:     //////////////////////////////////////////////////////////////
1:     //
1:     //  BEGIN TEST FOR MULTIPLE FIELDS
1:     //
1:     //////////////////////////////////////////////////////////////
1: 	
1:     public void testMultipleFields() throws SQLException
1:     {
1:         println( "Running multi-field test." );
1:         
1:         Statement s = createStatement();
1: 
1:         s.execute("create table multifield(id int primary key, c clob)");
1:         s.execute("insert into multifield values "
1:                 + "(1, '<document><secret/>No one must know!</document>'), "
1:                 + "(2, '<document>No secret here!</document>')");
1: 
1:         s.execute("call lucenesupport.createindex('lucenetest', 'multifield', "
1:                   + "'c', '" + getClass().getName() + ".makeMultiFieldIndexDescriptor')");
1: 
1:         PreparedStatement ps = prepareStatement(
1:                 "select id from table(multifield__c(?, 100, null)) t");
1: 
1:         String[][] bothRows = { {"1"}, {"2"} };
1: 
1:         ps.setString(1, "text:secret");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:         ps.setString(1, "tags:secret");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         ps.setString(1, "secret");
1:         JDBC.assertUnorderedResultSet(ps.executeQuery(), bothRows);
1:     }
1: 
1:     /** Create the custom index descriptor for the multi-field test */
1:     public  static  LuceneIndexDescriptor   makeMultiFieldIndexDescriptor()
1:     {
1:         return new MultiFieldIndexDescriptor();
1:     }
1:     /**
1:      * Create a simple query parser for multiple fields, which uses
1:      * StandardAnalyzer instead of the XMLAnalyzer that was used to create
1:      * the index.
1:      */
1:     public static QueryParser createXMLQueryParser(
1:             Version version, String[] fields, Analyzer analyzer) {
1:         return new MultiFieldQueryParser(
1:                 version, fields, new StandardAnalyzer(version));
1:     }
1: 
1:     /**
1:      * Custom analyzer for XML files. It indexes the tags and the text
1:      * separately.
1:      */
1:     public static class XMLAnalyzer extends Analyzer {
1: 
1:         public XMLAnalyzer() {
1:             // We want different tokenizers for different fields. Set reuse
1:             // policy to per-field to achieve that.
1:             super(PER_FIELD_REUSE_STRATEGY);
1:         }
1: 
1:         @Override
1:         protected TokenStreamComponents createComponents(
1:                 String fieldName, Reader reader) {
1: 
1:             if (fieldName.equals("text")) {
1:                 return new TokenStreamComponents(new XMLTextTokenizer(reader));
1:             }
1: 
1:             if (fieldName.equals("tags")) {
1:                 return new TokenStreamComponents(new XMLTagsTokenizer(reader));
1:             }
1: 
1:             fail("unknown field name: " + fieldName);
1:             return null;
1:         }
1:     }
1: 
1:     /** Common logic for XMLTextTokenizer and XMLTagsTokenizer. */
1:     private abstract static class AbstractTokenizer extends Tokenizer {
1:         Iterator<String> tokens;
1:         final CharTermAttribute charTermAttr =
1:                 addAttribute(CharTermAttribute.class);
1:         final PositionIncrementAttribute posIncrAttr
1:                 = addAttribute(PositionIncrementAttribute.class);
1: 
1:         AbstractTokenizer(Reader reader) {
1:             super(reader);
1:         }
1: 
1:         @Override
1:         public boolean incrementToken() throws IOException {
1:             if (tokens == null) {
1:                 tokens = getTokens().iterator();
1:             }
1: 
1:             if (tokens.hasNext()) {
1:                 charTermAttr.setEmpty();
1:                 charTermAttr.append(tokens.next());
1:                 posIncrAttr.setPositionIncrement(1);
1:                 return true;
1:             } else {
1:                 return false;
1:             }
1:         }
1: 
1:         @Override
1:         public void reset() throws IOException {
1:             tokens = null;
1:             super.reset();
1:         }
1: 
1:         abstract Iterable<String> getTokens();
1:     }
1: 
1:     private static class XMLTextTokenizer extends AbstractTokenizer {
1: 
1:         XMLTextTokenizer(Reader in) {
1:             super(in);
1:         }
1: 
1:         @Override
1:         Iterable<String> getTokens() {
1:             StringBuilder text = new StringBuilder();
1:             getAllText(parseXMLDocument(input), text);
1:             return Arrays.asList(text.toString().split("[ \r\n\t]"));
1:         }
1: 
1:     }
1: 
1:     private static class XMLTagsTokenizer extends AbstractTokenizer {
1: 
1:         XMLTagsTokenizer(Reader in) {
1:             super(in);
1:         }
1: 
1:         @Override
1:         Iterable<String> getTokens() {
1:             return getAllXMLTags(parseXMLDocument(input));
1:         }
1: 
1:     }
1: 
1:     /** Parse an XML document from a Reader. */
1:     private static Document parseXMLDocument(Reader reader) {
1:         Document doc = null;
1: 
1:         try {
1:             doc = DocumentBuilderFactory.newInstance()
1:                     .newDocumentBuilder().parse(new InputSource(reader));
1:             reader.close();
1:         } catch (Exception e) {
1:             fail("Failed to parse XML document", e);
1:         }
1: 
1:         return doc;
1:     }
1: 
1:     /** Get a list of all the XML tags in a node. */
1:     private static List<String> getAllXMLTags(Node node) {
1:         ArrayList<String> list = new ArrayList<String>();
1:         NodeList nl = node.getChildNodes();
1:         for (int i = 0; i < nl.getLength(); i++) {
1:             Node n = nl.item(i);
1:             if (n.getNodeType() == Node.ELEMENT_NODE) {
1:                 list.add(n.getNodeName());
1:                 list.addAll(getAllXMLTags(n));
1:             }
1:         }
1:         return list;
1:     }
1: 
1:     /** Strip out all tags from an XML node, so that only the text is left. */
1:     private static void getAllText(Node node, StringBuilder sb) {
1:         if (node.getNodeType() == Node.TEXT_NODE) {
1:             sb.append(node.getNodeValue());
1:         } else {
1:             NodeList nl = node.getChildNodes();
1:             for (int i = 0; i < nl.getLength(); i++) {
1:                 getAllText(nl.item(i), sb);
1:             }
1:         }
1:     }
1: 
1:     public static class MultiFieldIndexDescriptor implements LuceneIndexDescriptor
1:     {
1:         public  String[]    getFieldNames() { return new String[] { "tags", "text" }; }
1:     
1:         public Analyzer getAnalyzer()   { return new XMLAnalyzer(); }
1: 
1:         public  QueryParser getQueryParser()
1:         {
1:             Version version = LuceneUtils.currentVersion();
1:             
1:             return new MultiFieldQueryParser
1:                 (
1:                  version,
1:                  getFieldNames(),
1:                  new StandardAnalyzer( version )
1:                  );
1:         }
1: 
1:     }
1: 
1:     //////////////////////////////////////////////////////////////
1:     //
1:     //  END TEST FOR MULTIPLE FIELDS
1:     //
1:     //////////////////////////////////////////////////////////////
commit:4cedf31
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes', null, 1000, null ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', null, 1000, null ) ) l\n" +
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, null ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, null ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, null ) ) luceneResults\n"
commit:435459e
/////////////////////////////////////////////////////////////////////////
1:         Test        singleUseTest = TestConfiguration.singleUseDatabaseDecorator( baseTest );
1:         Test        localizedTest = new LocaleTestSetup( singleUseTest, new Locale( "en", "US" ) );
commit:561e69f
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.LocaleTestSetup;
/////////////////////////////////////////////////////////////////////////
1: 
1:         Test    baseTest = TestConfiguration.embeddedSuite(LuceneSupportTest.class);
0:         Test        localizedTest = new LocaleTestSetup( baseTest, new Locale( "en", "US" ) );
1: 		suite.addTest(SecurityManagerSetup.noSecurityManager(localizedTest));
/////////////////////////////////////////////////////////////////////////
1: 
1:         // verify that we are in an en Locale
1:         getConnection().prepareStatement
1:             (
1:              "create function getDatabaseLocale() returns varchar( 20 )\n" +
1:              "language java parameter style java reads sql data\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportPermsTest.getDatabaseLocale()'\n"
1:              ).executeUpdate();
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
1:               "values ( substr( getDatabaseLocale(), 1, 2 ) )"
1:               ),
1:              new String[][]
1:              {
1:                  { "en" }
1:              }
1:              );
1:         getConnection().prepareStatement( "drop function getDatabaseLocale" ).executeUpdate();
commit:0b71ff5
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes', null, 1000, 0 ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes', null, 1000, .75 ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes',  null, 1000, 0.5) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', null, 1000, 0 ) ) l\n" +
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, 0 ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, 0 ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', null, 1000, 0 ) ) luceneResults\n"
commit:9cc25e2
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, 0 ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes', 1000, .75 ) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "select * from table ( lucenetest.titles__title( 'grapes',  1000, 0.5) ) luceneResults"
/////////////////////////////////////////////////////////////////////////
0:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', 1000, 0 ) ) l\n" +
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', 1000, 0 ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', 1000, 0 ) ) luceneResults\n"
/////////////////////////////////////////////////////////////////////////
0:               "from table ( lucenetest.titles__title( 'mice', 1000, 0 ) ) luceneResults\n"
commit:2277df2
/////////////////////////////////////////////////////////////////////////
1:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null )" );
/////////////////////////////////////////////////////////////////////////
1:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null)" );
/////////////////////////////////////////////////////////////////////////
1:             ( "call LuceneSupport.updateIndex('lucenetest','titles','title', null)" );
/////////////////////////////////////////////////////////////////////////
1:             ( "call LuceneSupport.createIndex('lucenetest','titles','title', null)" );
1:             ( "call LuceneSupport.createIndex('lucenetest','titles','author', null)" );
commit:cb62199
/////////////////////////////////////////////////////////////////////////
1:                 { "LUCENETEST", "TITLES", "AUTHOR" },
1: 	    		{ "LUCENETEST", "TITLES", "TITLE" }
1:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes order by schemaname, tablename, columnname"
/////////////////////////////////////////////////////////////////////////
1:                 { "LUCENETEST", "TITLES", "AUTHOR" },
1:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes order by schemaname, tablename, columnname"
/////////////////////////////////////////////////////////////////////////
1:               "select schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes"
commit:d847ced
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.LuceneSupportTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.shared.common.reference.SQLState;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * <p>
1:  * Basic test of the optional tool which provides Lucene indexing of
1:  * columns in Derby tables.
1:  * </p>
1:  */
1: public class LuceneSupportTest extends BaseJDBCTestCase {
1: 
1:     private static  final   String  ILLEGAL_CHARACTER = "42XBD";
1:     
1: 	public LuceneSupportTest(String name) {
1: 		super(name);
1: 	}
1: 	
1: 	public static Test suite() {
0: 		TestSuite suite = new TestSuite("LuceneSupportTest");
1: 		
0: 		suite.addTest(SecurityManagerSetup.noSecurityManager(TestConfiguration.embeddedSuite(LuceneSupportTest.class)));
1:  
1: 		return suite;
1: 	}
1: 	
1: 	public void testCreateAndQueryIndex() throws Exception {
1: 		CallableStatement cSt;
1: 		Statement s = createStatement();
1: 	    
1: 		cSt = prepareCall
0:             ( "call LuceneSupport.createIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 	    
1: 	    String[][] expectedRows = new String[][]
1:             {
1:                 { "1","0","0.8048013" },
1: 	    		{ "3","2","0.643841" }
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
0:               "select * from table ( lucenetest.titles__title( 'grapes', 0 ) ) luceneResults"
1:               ),
1:              expectedRows
1:              );
1: 
1: 	    expectedRows = new String[][]
1:             {
1: 	    		{ "3","2","0.643841" }
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
0:               "select * from table ( lucenetest.titles__title( 'grapes', .75 ) ) luceneResults"
1:               ),
1:              expectedRows
1:              );
1: 
1: 	    JDBC.assertEmpty
1:             (
1:              s.executeQuery
1:              (
0:               "select * from table ( lucenetest.titles__title( 'grapes',  0.5) ) luceneResults"
1:               )
1:              );
1: 
1: 	    expectedRows = new String[][]
1:             {
1:                 { "The Grapes Of Wrath", "John Steinbeck", "The Viking Press", "0"},
1: 	    		{"Vines, Grapes, and Wines", "Jancis Robinson", "Alfred A. Knopf", "2"}
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
1:               "select title, author, publisher, documentID\n" +
0:               "from lucenetest.titles t, table ( lucenetest.titles__title( 'grapes', 0 ) ) l\n" +
1:               "where t.id = l.id\n" 
1:               ),
1:              expectedRows
1:              );
1: 	   
1: 		cSt = prepareCall
1:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	}
1: 	
1: 	public void testUpdateIndex() throws Exception {
1: 		CallableStatement cSt;
1: 		Statement s = createStatement();
1: 		
1: 		cSt = prepareCall
0:             ( "call LuceneSupport.createIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	    JDBC.assertEmpty
1:             (
1:              s.executeQuery
1:              (
1:               "select *\n" +
0:               "from table ( lucenetest.titles__title( 'mice', 0 ) ) luceneResults\n"
1:               )
1:              );
1: 	    
1: 	    cSt = prepareCall( "update TITLES SET TITLE='Of Mice and Men' WHERE ID=1" );
1: 	    assertUpdateCount(cSt, 1);
1: 	    
1: 	    JDBC.assertEmpty
1:             (
1:              s.executeQuery
1:              (
1:               "select *\n" +
0:               "from table ( lucenetest.titles__title( 'mice', 0 ) ) luceneResults\n"
1:               )
1:              );
1: 	    
1: 		cSt = prepareCall
0:             ( "call LuceneSupport.updateIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	    String[][] expectedRows = new String[][]
1:             {
1:                 { "1","0","1.058217" }
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
1:               "select *\n" +
0:               "from table ( lucenetest.titles__title( 'mice', 0 ) ) luceneResults\n"
1:               ),
1:              expectedRows
1:              );
1: 
1: 		cSt = prepareCall
1:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	}
1: 	
1: 	public void testListIndex() throws Exception {
1: 		CallableStatement cSt;
1: 		Statement s = createStatement();
1: 
1: 	    cSt = prepareCall
0:             ( "call LuceneSupport.createIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 	    
1: 		cSt = prepareCall
0:             ( "call LuceneSupport.createIndex('lucenetest','titles','author')" );
1: 	    assertUpdateCount(cSt, 0);
1: 	    
1: 	    // leave out lastmodified as the date will change
1: 	    String[][] expectedRows = new String[][]
1:             {
0:                 { "1", "LUCENETEST", "TITLES", "AUTHOR" },
0: 	    		{ "2", "LUCENETEST", "TITLES", "TITLE" }
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
0:               "select id, schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes"
1:               ),
1:              expectedRows
1:              );
1: 
1: 		cSt = prepareCall
1:             ( "call LuceneSupport.dropIndex('lucenetest','titles','title')" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	    expectedRows = new String[][]
1:             {
0:                 { "1", "LUCENETEST", "TITLES", "AUTHOR" },
1:             };
1: 	    JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
0:               "select id, schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes"
1:               ),
1:              expectedRows
1:              );
1: 
1: 		cSt = prepareCall
1:             ( "call LuceneSupport.dropIndex('lucenetest','titles','author')" );
1: 	    assertUpdateCount(cSt, 0);
1: 	    
1: 	    JDBC.assertEmpty
1:             (
1:              s.executeQuery
1:              (
0:               "select id, schemaname, tablename, columnname from table ( LuceneSupport.listIndexes() ) listindexes"
1:               )
1:              );
1: 
1: 	}
1: 	
1: 	public void testDropIndexBadCharacters() throws Exception {
1: 		CallableStatement st;
1: 	    
1: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('../','','')");
1: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('','../','')");
1: 		assertCallError( ILLEGAL_CHARACTER, "call LuceneSupport.dropIndex('','','../')");
1: 		
1: 	}
1: 	
1: 	protected void setUp() throws SQLException {
1: 		CallableStatement cSt;			    
1: 		Statement st = createStatement();
1: 		
1: 		try {
1: 			st.executeUpdate("create schema lucenetest");
1: 		} catch (Exception e) {
1: 		}
1: 		st.executeUpdate("set schema lucenetest");	
1: 		st.executeUpdate("create table titles (ID int generated always as identity primary key, ISBN varchar(16), PRINTISBN varchar(16), title varchar(1024), subtitle varchar(1024), author varchar(1024), series varchar(1024), publisher varchar(1024), collections varchar(128), collections2 varchar(128))");
1: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('9765087650324','9765087650324','The Grapes Of Wrath','The Great Depression in Oklahoma','John Steinbeck','Noble Winners','The Viking Press','National Book Award','Pulitzer Prize')");
1: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('6754278542987','6754278542987','Identical: Portraits of Twins','Best Photo Book 2012 by American Photo Magazine','Martin Schoeller','Portraits','teNeues','Photography','')");
1: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('2747583475882','2747583475882','Vines, Grapes, and Wines','The wine drinker''s guide to grape varieties','Jancis Robinson','Reference','Alfred A. Knopf','Wine','')");	
1: 		st.executeUpdate("insert into titles (ISBN, PRINTISBN, TITLE, SUBTITLE, AUTHOR, SERIES, PUBLISHER, COLLECTIONS, COLLECTIONS2) values ('4356123483483','4356123483483','A Tale of Two Cities','A fictional account of events leading up to the French revolution','Charles Dickens','Classics','Chapman & Hall','Fiction','Social Criticism')");	
1: 
1: 		cSt = prepareCall
1:             ( "call syscs_util.syscs_register_tool('luceneSupport',true)" );
1: 	    assertUpdateCount(cSt, 0);
1: 
1: 	}
1: 	
1: 	protected void tearDown() throws Exception {
1: 		CallableStatement cSt;
1: 		Statement st = createStatement();
1: 		
1: 		st.executeUpdate("drop table titles");
1: 		
1: 		cSt = prepareCall
1:             ( "call syscs_util.syscs_register_tool('luceneSupport',false)" );
1: 	    assertUpdateCount(cSt, 0);
1: 	    super.tearDown();
1: 	}
1: }
============================================================================