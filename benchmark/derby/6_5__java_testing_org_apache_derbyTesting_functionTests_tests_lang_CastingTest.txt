1:6d94ad6: /**
1:6d94ad6:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CastingTest
1:6d94ad6:  *  
1:6d94ad6:  * Licensed to the Apache Software Foundation (ASF) under one
1:6d94ad6:  * or more contributor license agreements.  See the NOTICE file
1:6d94ad6:  * distributed with this work for additional information
1:6d94ad6:  * regarding copyright ownership.  The ASF licenses this file
1:6d94ad6:  * to you under the Apache License, Version 2.0 (the
1:6d94ad6:  * "License"); you may not use this file except in compliance
1:6d94ad6:  * with the License.  You may obtain a copy of the License at
1:6d94ad6:  *
1:6d94ad6:  *   http://www.apache.org/licenses/LICENSE-2.0
1:6d94ad6:  *
1:6d94ad6:  * Unless required by applicable law or agreed to in writing,
1:6d94ad6:  * software distributed under the License is distributed on an
1:6d94ad6:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:6d94ad6:  * KIND, either express or implied.  See the License for the
1:6d94ad6:  * specific language governing permissions and limitations
1:6d94ad6:  * under the License.
1:6d94ad6:  */
1:6d94ad6: 
1:fffce91: package org.apache.derbyTesting.functionTests.tests.lang;
21:fffce91: 
1:07d1108: import java.sql.Connection;
1:75ec275: import java.sql.DataTruncation;
1:07d1108: import java.sql.DatabaseMetaData;
1:c1a0ff2: import java.sql.Date;
1:07d1108: import java.sql.PreparedStatement;
1:fffce91: import java.sql.ResultSet;
1:9230159: import java.sql.ResultSetMetaData;
1:fffce91: import java.sql.SQLException;
1:75ec275: import java.sql.SQLWarning;
1:fffce91: import java.sql.Statement;
1:07d1108: import java.sql.Types;
1:c1a0ff2: import java.util.Arrays;
1:c1a0ff2: import java.util.HashSet;
1:fffce91: 
1:fffce91: import junit.framework.Test;
1:fffce91: 
1:fffce91: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:fffce91: import org.apache.derbyTesting.junit.JDBC;
1:1cf00e6: import org.apache.derbyTesting.junit.SQLUtilities;
1:fffce91: import org.apache.derbyTesting.junit.TestConfiguration;
1:fffce91: 
1:0bcd16d: /**
1:0bcd16d:  *
1:0bcd16d:  */
1:fffce91: public class CastingTest extends BaseJDBCTestCase {
1:fffce91: 
1:07d1108:     public static final class TypedColumn
1:07d1108:     {
1:07d1108:         public String columnName;
1:07d1108:         public String typeName;
1:07d1108:         public boolean comparable; // true except for long, non-indexable data types
1:07d1108: 
1:07d1108:             public TypedColumn( String columnName, String typeName, boolean comparable )
1:07d1108:         {
1:07d1108:             this.columnName = columnName;
1:07d1108:             this.typeName = typeName;
1:07d1108:             this.comparable = comparable;
1:07d1108:         }
1:07d1108:     }
1:07d1108: 
1:fffce91:     public CastingTest(String name) {
1:fffce91:         super(name);
1:07d1108: 
4:fffce91:     }
1:fffce91:     public static String VALID_DATE_STRING = "'2000-01-01'";
1:fffce91:     public static String VALID_TIME_STRING = "'15:30:20'";
1:fffce91:     public static String VALID_TIMESTAMP_STRING = "'2000-01-01 15:30:20'";
1:fffce91:     public static String NULL_VALUE="NULL";
1:fffce91: 
1:fffce91:     public static String ILLEGAL_CAST_EXCEPTION_SQLSTATE = "42846";
1:fffce91:     public static String LANG_NOT_STORABLE_SQLSTATE  = "42821";
1:fffce91:     public static String LANG_NOT_COMPARABLE_SQLSTATE = "42818";
1:fffce91:     public static String METHOD_NOT_FOUND_SQLSTATE = "42884";
1:fffce91:     public static String LANG_FORMAT_EXCEPTION_SQLSTATE = "22018";
1:fffce91: 
1:fffce91:     public static int SQLTYPE_ARRAY_SIZE = 17 ;
1:fffce91:     public static int SMALLINT_OFFSET = 0;
1:fffce91:     public static int INTEGER_OFFSET = 1;
1:fffce91:     public static int BIGINT_OFFSET = 2;
1:fffce91:     public static int DECIMAL_OFFSET = 3;
1:fffce91:     public static int REAL_OFFSET = 4;
1:fffce91:     public static int DOUBLE_OFFSET = 5;
1:fffce91:     public static int CHAR_OFFSET = 6;
1:fffce91:     public static int VARCHAR_OFFSET = 7;
1:fffce91:     public static int LONGVARCHAR_OFFSET = 8;
1:fffce91:     public static int CHAR_FOR_BIT_OFFSET = 9;
1:fffce91:     public static int VARCHAR_FOR_BIT_OFFSET = 10;
1:fffce91:     public static int LONGVARCHAR_FOR_BIT_OFFSET = 11;
1:fffce91:     public static int CLOB_OFFSET = 12;
1:fffce91:     public static int DATE_OFFSET = 13;
1:fffce91:     public static int TIME_OFFSET = 14;
1:fffce91:     public static int TIMESTAMP_OFFSET = 15;
1:fffce91:     public static int BLOB_OFFSET = 16;
1:fffce91: 
1:9230159:     public static int[] jdbcTypes = {
1:9230159:         java.sql.Types.SMALLINT,
1:9230159:         java.sql.Types.INTEGER,
1:9230159:         java.sql.Types.BIGINT,
1:9230159:         java.sql.Types.DECIMAL,
1:9230159:         java.sql.Types.REAL,
1:9230159:         java.sql.Types.DOUBLE,
1:9230159:         java.sql.Types.CHAR,
1:9230159:         java.sql.Types.VARCHAR,
1:9230159:         java.sql.Types.LONGVARCHAR,
1:9230159:         java.sql.Types.BINARY,
1:9230159:         java.sql.Types.VARBINARY,
1:9230159:         java.sql.Types.LONGVARBINARY,
1:9230159:         java.sql.Types.CLOB,
1:9230159:         java.sql.Types.DATE,
1:9230159:         java.sql.Types.TIME,
1:9230159:         java.sql.Types.TIMESTAMP,
1:9230159:         java.sql.Types.BLOB
1:9230159:     };
1:9230159:     
1:fffce91:     public static int NULL_DATA_OFFSET = 0;  // offset of NULL value
1:fffce91:     public static int VALID_DATA_OFFSET = 1;  // offset of NULL value
1:fffce91: 
1:fffce91:     // rows are data types.
1:fffce91:     // data is NULL_VALUE, VALID_VALUE
1:fffce91:     // Should add Minimum, Maximum and out of range.
1:fffce91: public static String[][]SQLData =
1:07d1108:     {
1:fffce91:             {NULL_VALUE, "0"},       // SMALLINT
1:fffce91:             {NULL_VALUE,"11"},       // INTEGER
1:fffce91:             {NULL_VALUE,"22"},       // BIGINT
1:fffce91:             {NULL_VALUE,"3.3"},      // DECIMAL(10,5)
1:fffce91:             {NULL_VALUE,"4.4"},      // REAL,
1:fffce91:             {NULL_VALUE,"5.5"},      // DOUBLE
1:fffce91:             {NULL_VALUE,"'7'"},      // CHAR(60)
1:fffce91:             {NULL_VALUE,"'8'"},      //VARCHAR(60)",
1:fffce91:             {NULL_VALUE,"'9'"},      // LONG VARCHAR
1:fffce91:             {NULL_VALUE,"X'10aa'"},  // CHAR(60)  FOR BIT DATA
1:fffce91:             {NULL_VALUE,"X'10bb'"},  // VARCHAR(60) FOR BIT DATA
1:fffce91:             {NULL_VALUE,"X'10cc'"},  //LONG VARCHAR FOR BIT DATA
1:fffce91:             {NULL_VALUE,"'13'"},     //CLOB(1k)
1:fffce91:             {NULL_VALUE,VALID_DATE_STRING},        // DATE
1:fffce91:             {NULL_VALUE,VALID_TIME_STRING},        // TIME
1:fffce91:             {NULL_VALUE,VALID_TIMESTAMP_STRING},   // TIMESTAMP
1:fffce91:             {NULL_VALUE,"X'01dd'"}                 // BLOB
2:fffce91:     };
1:fffce91: 
1:fffce91: 
1:fffce91: 
1:fffce91: 
1:ca48ab4:     public static final boolean n = false;
1:fffce91:     public static final boolean X = true;
1:fffce91: 
1:75ec275:     /**
1:fffce91:        Table 146 - Supported explicit casts between Built-in DataTypes
1:fffce91: 
1:fffce91:        This table has THE FOR BIT DATA TYPES broken out into separate columns
1:fffce91:        for clarity and testing
1:fffce91:     **/
1:fffce91: 
1:fffce91: 
1:fffce91:     public static final boolean[][]  T_146 = {
1:fffce91:             
1:c1a0ff2: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1:c1a0ff2: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1:c1a0ff2: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1:c1a0ff2: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1:c1a0ff2: //                        L  G  N  M     L     H  V  .  H  V           S
1:c1a0ff2: //                        I  E  T  A     E     A  A  B  .  A           T
1:c1a0ff2: //                        N  R     L           R  R  I  B  R           A
1:c1a0ff2: //                        T                       C  T  I  .           M
1:c1a0ff2: //                                                H     T  B           P
1:c1a0ff2: //                                                A        I
1:c1a0ff2: //                                                R        T
1:ca48ab4: /* 0 SMALLINT */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 1 INTEGER  */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 2 BIGINT   */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 3 DECIMAL  */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 6 CHAR     */        { X, X, X, X, n, n, X, X, X, n, n, n, X, X, X, X, n },
1:ca48ab4: /* 7 VARCHAR  */        { X, X, X, X, n, n, X, X, X, n, n, n, X, X, X, X, n },
1:ca48ab4: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1:ca48ab4: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1:ca48ab4: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1:ca48ab4: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1:ca48ab4: /* 12 CLOB         */   { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1:c1a0ff2: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, X, n },
1:c1a0ff2: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, X, n },
1:ca48ab4: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1:ca48ab4: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, X },
1:fffce91: 
1:fffce91:     };
1:fffce91: 
1:07d1108:     /**
1:fffce91:      * Table 147 describes  Data Type Compatibility for Assignments 
1:fffce91:      *
1:fffce91:      * The table 147a covers the assignments as they do differ somewhat 
1:fffce91:      *  from comparisons which can be found in 147b
1:fffce91:      *
1:fffce91:      **/
1:fffce91: 
1:fffce91:     public static final boolean[][]  T_147a = {
1:fffce91:             
1:c1a0ff2: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1:c1a0ff2: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1:c1a0ff2: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1:c1a0ff2: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1:c1a0ff2: //                        L  G  N  M     L     H  V  .  H  V           S
1:c1a0ff2: //                        I  E  T  A     E     A  A  B  .  A           T
1:c1a0ff2: //                        N  R     L           R  R  I  B  R           A
1:c1a0ff2: //                        T                       C  T  I  .           M
1:c1a0ff2: //                                                H     T  B           P
1:c1a0ff2: //                                                A        I
1:c1a0ff2: //                                                R        T
1:ca48ab4: /* 0 SMALLINT */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 1 INTEGER  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 2 BIGINT   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 3 DECIMAL  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 6 CHAR     */        { n, n, n, n, n, n, X, X, X, n, n, n, X, X, X, X, n },
1:ca48ab4: /* 7 VARCHAR  */        { n, n, n, n, n, n, X, X, X, n, n, n, X, X, X, X, n },
1:ca48ab4: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1:ca48ab4: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1:ca48ab4: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1:ca48ab4: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1:ca48ab4: /* 12 CLOB         */   { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1:ca48ab4: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, n, n },
1:ca48ab4: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, n, n },
1:ca48ab4: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, n, X, n },
1:ca48ab4: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, X },
1:fffce91: 
1:fffce91:     };
1:fffce91: 
1:fffce91: 
1:fffce91:     // Comparisons table
1:fffce91:     // Comparison's are different than assignments because
1:fffce91:     // Long types cannot be compared.
1:aa53134:     // Note: This table is referenced in NullIfTest.java
1:fffce91:     public static final boolean[][]  T_147b = {
1:fffce91:             
1:c1a0ff2: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1:c1a0ff2: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1:c1a0ff2: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1:c1a0ff2: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1:c1a0ff2: //                        L  G  N  M     L     H  V  .  H  V           S
1:c1a0ff2: //                        I  E  T  A     E     A  A  B  .  A           T
1:c1a0ff2: //                        N  R     L           R  R  I  B  R           A
1:c1a0ff2: //                        T                       C  T  I  .           M
1:c1a0ff2: //                                                H     T  B           P
1:c1a0ff2: //                                                A        I
1:c1a0ff2: //                                                R        T
1:ca48ab4: /* 0 SMALLINT */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 1 INTEGER  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 2 BIGINT   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 3 DECIMAL  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 6 CHAR     */        { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1:ca48ab4: /* 7 VARCHAR  */        { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1:ca48ab4: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, n, n, n, n, n, n },
1:ca48ab4: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, n, n, n, n, n, n },
1:ca48ab4: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 12 CLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1:ca48ab4: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, n, n },
1:ca48ab4: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, n, n },
1:ca48ab4: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, n, X, n },
1:ca48ab4: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1:fffce91: 
1:fffce91: 
1:fffce91: };
1:0bcd16d:    /*
1:0bcd16d:     * explicitCastValues is a table of expected values for the testExplicitCasts fixture
1:0bcd16d:     * System.out.print statements in testExplicitCast were used to generate this table
1:0bcd16d:     * and  remain in comments in testExplicitCasts in case it needs to be regenerated.
1:0bcd16d:     */ 
1:0bcd16d:     private static final String[][] explicitCastValues = {
1:0bcd16d:     /*SMALLINT*/ {"0","0","0","0.00000","0.0","0.0","0                                                           ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*INTEGER*/ {"11","11","11","11.00000","11.0","11.0","11                                                          ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*BIGINT*/ {"22","22","22","22.00000","22.0","22.0","22                                                          ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*DECIMAL(10,5)*/ {"3","3","3","3.30000","3.3","3.3","3.30000                                                     ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*REAL*/ {"4","4","4","4.40000","4.4","4.400000095367432","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*DOUBLE*/ {"5","5","5","5.50000","5.5","5.5","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*CHAR(60)*/ {"0","11","22","3.30000","Exception","Exception","7                                                           ","8                                                           ","9                                                           ","Exception","Exception","Exception","13                                                          ","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:0bcd16d:     /*VARCHAR(60)*/ {"0","11","22","3.30000","Exception","Exception","7                                                           ","8","9","Exception","Exception","Exception","13","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:0bcd16d:     /*LONG VARCHAR*/ {"Exception","Exception","Exception","Exception","Exception","Exception","7                                                           ","8","9","Exception","Exception","Exception","13","Exception","Exception","Exception","Exception"},
1:0bcd16d:     /*CHAR(60) FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10cc20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","Exception","Exception","Exception","Exception","01dd20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020"},
1:0bcd16d:     /*VARCHAR(60) FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb","10cc","Exception","Exception","Exception","Exception","01dd"},
1:0bcd16d:     /*LONG VARCHAR FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb","10cc","Exception","Exception","Exception","Exception","01dd"},
1:0bcd16d:     /*CLOB(1k)*/ {"Exception","Exception","Exception","Exception","Exception","Exception","13                                                          ","13","13","Exception","Exception","Exception","13","Exception","Exception","Exception","Exception"},
1:c1a0ff2:     /*DATE*/ {"Exception","Exception","Exception","Exception","Exception","Exception","2000-01-01                                                  ","2000-01-01","Exception","Exception","Exception","Exception","Exception","2000-01-01","Exception","2000-01-01 00:00:00.0","Exception"},
1:c1a0ff2:     /*TIME*/ {"Exception","Exception","Exception","Exception","Exception","Exception","15:30:20                                                    ","15:30:20","Exception","Exception","Exception","Exception","Exception","Exception","15:30:20","TODAY 15:30:20.0","Exception"},
1:0bcd16d:     /*TIMESTAMP*/ {"Exception","Exception","Exception","Exception","Exception","Exception","2000-01-01 15:30:20.0                                       ","2000-01-01 15:30:20.0","Exception","Exception","Exception","Exception","Exception","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:0bcd16d:     /*BLOB(1k)*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","01dd"}
1:0bcd16d:     };
1:07d1108: 
1:07d1108:     private static final TypedColumn[] LEGAL_BOOLEAN_CASTS = new TypedColumn[]
1:07d1108:     {
1:07d1108:         new TypedColumn( "charCol", "char( 5 )", true ),
1:07d1108:         new TypedColumn( "varcharCol", "varchar( 5 )", true ),
1:07d1108:         new TypedColumn( "longVarcharCol", "long varchar", false ),
1:07d1108:         new TypedColumn( "clobCol", "clob", false ),
1:1292a7f:         new TypedColumn( "booleanCol", "boolean", true ),
1:07d1108:     };
1:07d1108:     
1:07d1108:     private static final TypedColumn[] ILLEGAL_BOOLEAN_CASTS = new TypedColumn[]
1:07d1108:     {
1:07d1108:         new TypedColumn( "bigintCol", "bigint", true ),
1:07d1108:         new TypedColumn( "blobCol", "blob", false ),
1:07d1108:         new TypedColumn( "charForBitDataCol", "char( 5 ) for bit data", true ),
1:07d1108:         new TypedColumn( "dateCol", "date", true ),
1:07d1108:         new TypedColumn( "decimalCol", "decimal", true ),
1:07d1108:         new TypedColumn( "doubleCol", "double", true ),
1:07d1108:         new TypedColumn( "floatCol", "float", true ),
1:07d1108:         new TypedColumn( "integerCol", "integer", true ),
1:07d1108:         new TypedColumn( "longVarcharForBitDataCol", "long varchar for bit data", false ),
1:07d1108:         new TypedColumn( "numericCol", "numeric", true ),
1:07d1108:         new TypedColumn( "realCol", "real", true ),
1:07d1108:         new TypedColumn( "smallintCol", "smallint", true ),
1:07d1108:         new TypedColumn( "timeCol", "time", true ),
1:07d1108:         new TypedColumn( "timestampCol", "timestamp", true ),
1:07d1108:         new TypedColumn( "varcharForBitDataCol", "varchar( 5 ) for bit data", true ),
1:07d1108:         new TypedColumn( "xmlCol", "xml", false ),
1:07d1108:     };
1:0bcd16d:     
1:fffce91:     protected void setUp() throws SQLException {
1:a2567fa:         Statement scb = createStatement();
1:fffce91: 
1:1cf00e6:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:1cf00e6:             String typeName = SQLUtilities.SQLTypes[type];
1:fffce91:             String tableName = getTableName(type);
1:fffce91: 
1:fffce91:             String createSQL = "create table " + tableName + " (c " + typeName
1:fffce91:                     + " )";
1:fffce91: 
1:fffce91:             scb.executeUpdate(createSQL);
1:0bcd16d:             
1:fffce91:         }
1:fffce91:         // * testing literal inserts
1:fffce91: 
1:fffce91:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
1:1cf00e6:             for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:fffce91:                 try {
1:fffce91:                     String tableName = getTableName(type);
1:fffce91: 
1:fffce91:                     String insertSQL = "insert into " + tableName + " values( "
1:fffce91:                             + SQLData[type][dataOffset] + ")";
1:fffce91:                     scb.executeUpdate(insertSQL);
1:fffce91:                 } catch (SQLException se) {
1:fffce91:                     // literal inserts are ok for everything but BLOB
1:fffce91:                     if (type != BLOB_OFFSET)
1:fffce91:                         throw se;
1:fffce91:                     
1:fffce91:                 }
1:fffce91:             }
1:0bcd16d:         scb.close();
1:a2567fa:         commit();
1:0bcd16d:     }
1:0bcd16d: 
1:0bcd16d:     public void testAssignments() throws SQLException {
1:0bcd16d: 
1:a2567fa:         Statement scb = createStatement();
1:0bcd16d: 
1:fffce91:         // Try to insert each sourceType into the targetType table
1:fffce91:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
1:1cf00e6:             for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:1cf00e6:                 String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:1cf00e6:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
1:fffce91:                     try {
1:fffce91:                         String targetTableName = getTableName(targetType);
1:0bcd16d: 
1:fffce91:                         // For assignments Character types use strings that can
1:fffce91:                         // be converted to the targetType.
1:a2567fa:                         String convertString = getCompatibleString(sourceType,
1:fffce91:                                 targetType, dataOffset);
1:0bcd16d: 
1:fffce91:                         String insertValuesString = " VALUES CAST("
1:fffce91:                                 + convertString + " AS " + sourceTypeName + ")";
1:fffce91: 
1:fffce91:                         String insertSQL = "INSERT INTO " + targetTableName
1:fffce91:                                 + insertValuesString;
1:fffce91:                         // System.out.println(insertSQL);
1:fffce91:                         scb.executeUpdate(insertSQL);
1:fffce91:                         checkSupportedAssignment(sourceType, targetType);
1:fffce91: 
1:fffce91:                     } catch (SQLException se) {
1:fffce91:                         String sqlState = se.getSQLState();
1:fffce91:                         assertTrue(!isSupportedAssignment(sourceType, targetType)
1:fffce91:                                 && isNotStorableException(se)
1:fffce91:                                 || isCastException(se));
1:fffce91:                     }
1:fffce91:                 }
1:fffce91:             }
1:fffce91: 
2:fffce91:         scb.close();
1:a2567fa:         commit();
1:fffce91:     }
1:fffce91: 
1:fffce91:     public void testExplicitCasts() throws SQLException {
1:fffce91: 
1:a2567fa:         Statement s = createStatement();
1:fffce91: 
1:fffce91:         // Try Casts from each type to the
1:1cf00e6:         for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:fffce91: 
1:1cf00e6:             String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:0bcd16d:             //System.out.print("/*" + sourceTypeName + "*/ {");
1:fffce91:             for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
1:1cf00e6:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
1:fffce91:                     try {
1:c1a0ff2:                         // Record the start time so that we can calculate
1:c1a0ff2:                         // the current date when checking TIME -> TIMESTAMP
1:c1a0ff2:                         // conversion.
1:c1a0ff2:                         final long startTime = System.currentTimeMillis();
1:c1a0ff2: 
1:1cf00e6:                         String targetTypeName = SQLUtilities.SQLTypes[targetType];
1:fffce91:                         // For casts from Character types use strings that can
1:fffce91:                         // be converted to the targetType.
1:fffce91: 
1:a2567fa:                         String convertString = getCompatibleString(sourceType,
1:fffce91:                                 targetType, dataOffset);
1:fffce91: 
1:a2567fa:                         String query =
1:a2567fa:                             "VALUES CAST (CAST (" + convertString + " AS "
1:1cf00e6:                                 + SQLUtilities.SQLTypes[sourceType] + ") AS "
1:1cf00e6:                                 + SQLUtilities.SQLTypes[targetType] + " )";
1:a2567fa:                         ResultSet rs = s.executeQuery(query);
1:0bcd16d:                         rs.next();
1:0bcd16d:                         String val = rs.getString(1);
1:9230159:                         ResultSetMetaData rsmd = rs.getMetaData();
1:9230159:                         assertEquals(rsmd.getColumnType(1), jdbcTypes[targetType]);
1:a2567fa:                         rs.close();
1:c1a0ff2: 
1:c1a0ff2:                         // Record the time after finishing the data retrieval.
1:c1a0ff2:                         // Used for calculating the current date when checking
1:c1a0ff2:                         // TIME -> TIMESTAMP conversion.
1:c1a0ff2:                         final long finishTime = System.currentTimeMillis();
1:c1a0ff2: 
1:0bcd16d:                         if (dataOffset == 0)
1:0bcd16d:                             assertNull(val);
1:0bcd16d:                         else
1:07d1108:                         {
1:0bcd16d:                             //System.out.print("\"" + val + "\"");
1:c1a0ff2:                             String expected =
1:c1a0ff2:                                 explicitCastValues[sourceType][targetType];
1:c1a0ff2: 
1:c1a0ff2:                             if (isTime(sourceType) && isTimestamp(targetType)) {
1:c1a0ff2:                                 // The expected value for a cast from TIME to
1:c1a0ff2:                                 // TIMESTAMP includes the current date, so
1:c1a0ff2:                                 // construct the expected value at run-time.
1:c1a0ff2:                                 // We may have crossed midnight during query
1:c1a0ff2:                                 // execution, in which case we cannot tell
1:c1a0ff2:                                 // whether today or yesterday was used. Accept
1:c1a0ff2:                                 // both.
1:c1a0ff2:                                 String[] expectedValues = {
1:c1a0ff2:                                     expected.replace(
1:c1a0ff2:                                       "TODAY", new Date(startTime).toString()),
1:c1a0ff2:                                     expected.replace(
1:c1a0ff2:                                       "TODAY", new Date(finishTime).toString()),
1:c1a0ff2:                                 };
1:c1a0ff2:                                 HashSet<String> valid = new HashSet<String>(
1:c1a0ff2:                                         Arrays.asList(expectedValues));
1:c1a0ff2:                                 if (!valid.contains(val)) {
1:c1a0ff2:                                     fail("Got " + val + ", expected one of "
1:c1a0ff2:                                          + valid);
1:c1a0ff2:                                 }
1:c1a0ff2:                             } else {
1:c1a0ff2:                                 // For all other types...
1:c1a0ff2:                                 assertEquals(expected, val);
1:c1a0ff2:                             }
1:0bcd16d:                         }
1:fffce91:                         checkSupportedCast(sourceType, targetType);
1:fffce91:                     } catch (SQLException se) {
1:0bcd16d:                         if (dataOffset != 0)
2:0bcd16d:                         {
1:0bcd16d:                             //System.out.print("\"Exception\"");
1:0bcd16d:                         }
1:fffce91:                         String sqlState = se.getSQLState();
1:fffce91:                         if (!isSupportedCast(sourceType, targetType)) {
1:fffce91:                             assertTrue(isCastException(se));
1:fffce91:                         } else
1:fffce91:                             throw se;
1:fffce91:                     }
1:0bcd16d:                     /*
1:0bcd16d:                     if (dataOffset > 0)
1:0bcd16d:                         if (targetType == SQLTypes.length -1)
1:0bcd16d:                             System.out.println("},");
1:0bcd16d:                         else 
1:0bcd16d:                             System.out.print(",");
1:0bcd16d:                      */
1:0bcd16d: 
1:fffce91:                 }
1:fffce91:         }
1:fffce91: 
1:a2567fa:         commit();
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     public void testComparisons() throws SQLException {
1:fffce91: 
1:a2567fa:         Statement scb = createStatement();
1:fffce91: 
1:fffce91:         // Comparison's using literals
1:fffce91: 
1:1cf00e6:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:fffce91:             try {
1:fffce91:                 int dataOffset = 1; // don't use null values
1:fffce91:                 String tableName = getTableName(type);
1:fffce91: 
1:fffce91:                 String compareSQL = "SELECT distinct c FROM " + tableName
1:fffce91:                         + " WHERE c = " + SQLData[type][dataOffset];
1:fffce91: 
1:a2567fa:                 ResultSet rs = scb.executeQuery(compareSQL);
1:0bcd16d:                 //JDBC.assertDrainResults(rs);
1:0bcd16d:                 // should return 1 row
1:0bcd16d:                 assertTrue(rs.next());
1:a2567fa:                 rs.close();
1:fffce91:             } catch (SQLException se) {
1:fffce91:                 // literal comparisons are ok for everything but Lob and long
1:fffce91:                 assertTrue(isLongType(type));
1:fffce91:             }
1:fffce91:         }
1:fffce91: 
1:fffce91:         // Try to compare each sourceType with the targetType
1:fffce91:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
1:1cf00e6:             for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:1cf00e6:                 String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:1cf00e6:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
1:fffce91:                     try {
1:fffce91:                         String targetTableName = getTableName(targetType);
1:fffce91: 
1:fffce91:                         // For assignments Character types use strings that can
1:fffce91:                         // be converted to the targetType.
1:a2567fa:                         String convertString = getCompatibleString(sourceType,
1:fffce91:                                 targetType, dataOffset);
1:fffce91: 
1:fffce91:                         // Make sure table has just compatible data
1:fffce91:                         scb.executeUpdate("DELETE FROM " + targetTableName);
1:fffce91:                         String insertValuesString = " VALUES CAST("
1:fffce91:                                 + convertString + " AS " + sourceTypeName + ")";
1:fffce91: 
1:fffce91:                         String insertSQL = "INSERT INTO " + targetTableName
1:fffce91:                                 + insertValuesString;
1:fffce91: 
1:fffce91:                         String compareSQL = "select c from " + targetTableName
1:fffce91:                                 + " WHERE c = CAST(" + convertString + " AS "
1:fffce91:                                 + sourceTypeName + ")";
1:0bcd16d: 
1:fffce91:                     
1:a2567fa:                         ResultSet rs = scb.executeQuery(compareSQL);
3:fffce91:                         JDBC.assertDrainResults(rs);
1:0bcd16d:                         
1:fffce91:                         checkSupportedComparison(sourceType, targetType);
1:fffce91: 
1:fffce91:                     } catch (SQLException se) {
1:fffce91:                         String sqlState = se.getSQLState();
1:fffce91:                         assertTrue(!isSupportedComparison(sourceType, targetType)
1:fffce91:                                 && isNotComparableException(se)
1:fffce91:                                 || isCastException(se));
1:fffce91:                        
1:fffce91:                     }
1:fffce91:                 }
1:fffce91:             }
1:fffce91:         scb.close();
1:a2567fa:         commit();
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     /**
1:07d1108:      * Verify that DERBY-887 is fixed.
1:07d1108:      */
1:07d1108:     public void test_derby887() throws Exception
1:07d1108:     {
1:07d1108:         goodStatement
1:07d1108:             (
1:07d1108:              "create table t_887 (a int)\n"
1:07d1108:              );
1:07d1108: 
1:07d1108:         expectError
1:07d1108:             (
1:07d1108:              LANG_NOT_COMPARABLE_SQLSTATE,
1:07d1108:              "select * from t_887 where a=0<3\n"
1:07d1108:              );
1:07d1108:     }
1:07d1108: 
1:07d1108:     /**
1:07d1108:      * <p>
1:07d1108:      * Verify that the legal boolean casts work as expected. This
1:07d1108:      * test helps verify that DERBY-887 is fixed. Verifies the following:
1:07d1108:      * </p>
1:07d1108:      *
1:07d1108:      * <ul>
1:07d1108:      * <li>Implicit casts of BOOLEAN to legal types.</li>
1:07d1108:      * <li>Implicit casts of legal types to BOOLEAN.</li>
1:07d1108:      * <li>Explicit casts of BOOLEAN to legal types.</li>
1:07d1108:      * </ul>
1:07d1108:      *
1:07d1108:      * <p>
1:07d1108:      * The following can't be tested until the BOOLEAN type is re-enabled:
1:07d1108:      * </p>
1:07d1108:      *
1:07d1108:      * <ul>
1:07d1108:      * <li>Explicit casts of legal types to BOOLEAN.</li>
1:07d1108:      * </ul>
1:07d1108:      */
1:07d1108:     public void test_legalBooleanCasts() throws Exception
1:07d1108:     {
5:07d1108:         //
1:07d1108:         // This assertion will fail if a new Derby data type is added. To
1:07d1108:         // silence this assertion, you must add the new data type
1:07d1108:         // to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS.
1:07d1108:         //
1:07d1108:         assertAllTypesCovered();
1:07d1108: 
1:07d1108:         int  legalTypeCount = LEGAL_BOOLEAN_CASTS.length;
1:07d1108:         String  tableName = "t_legal_boolean_casts";
1:07d1108:         // create a table whose columns are all the legal datatypes
1:07d1108:         makeTableForCasts( tableName, LEGAL_BOOLEAN_CASTS );
1:07d1108: 
1:07d1108:         // now test the implicit casting of boolean to all of the legal
1:07d1108:         // types by inserting a boolean value into all of the columns
1:07d1108:         // of the table
1:07d1108:         goodStatement
1:07d1108:             (
1:07d1108:              "insert into " + tableName + "\n" +
1:07d1108:              "( " + makeColumnList( LEGAL_BOOLEAN_CASTS ) + " )\n" +
1:07d1108:              "select " + makeRepeatedColumnList( "c.isIndex", LEGAL_BOOLEAN_CASTS.length ) + "\n" +
1:07d1108:              "from\n" +
1:07d1108:              "  sys.sysconglomerates c,\n" +
1:07d1108:              "  sys.systables t\n" +
1:07d1108:              "where t.tablename='SYSTABLES'\n" +
1:07d1108:              "and t.tableid = c.tableid\n" +
1:07d1108:              "and not c.isIndex\n"
1:07d1108:              );
1:07d1108:         // test that all of the inserted values are false
1:07d1108:         assertBooleanResults
1:07d1108:             (
1:07d1108:              "select * from " + tableName + "\n",
1:07d1108:              false,
1:07d1108:              1
1:07d1108:              );
1:07d1108: 
1:07d1108:         // now try implicitly casting the legal types to boolean by
1:07d1108:         // trying to compare the values in the table to a boolean value.
1:07d1108:         // we only expect this to succeed for short, indexable data types.
1:07d1108:         // the long data types cannot be compared
1:07d1108:         for ( int i = 0; i < legalTypeCount; i++ )
1:07d1108:         {
1:07d1108:             TypedColumn tc = LEGAL_BOOLEAN_CASTS[ i ];
1:07d1108: 
1:07d1108:             String queryText =
1:07d1108:                 "select count(*)\n" +
1:07d1108:                 "from\n" +
1:07d1108:                 "  sys.sysconglomerates c,\n" +
1:07d1108:                 "  sys.systables t,\n" +
1:07d1108:                 "  " + tableName + " tt\n" +
1:07d1108:                 "where t.tablename='SYSTABLES'\n" +
1:07d1108:                 "and t.tableid = c.tableid\n" +
1:07d1108:                 "and not c.isIndex\n" +
1:07d1108:                 "and tt." + tc.columnName + " = c.isIndex\n";
1:07d1108: 
1:07d1108:             if ( tc.comparable ) { assertScalarResult( queryText, 1 ); }
1:07d1108:             else { expectError( LANG_NOT_COMPARABLE_SQLSTATE, queryText ); }
1:07d1108:         }
1:07d1108: 
1:07d1108:         // now try explicitly casting a boolean value to all of the legal types
1:07d1108:         assertBooleanResults
1:07d1108:             (
1:07d1108:              "select\n" +
1:07d1108:              makeCastedColumnList( "c.isIndex", LEGAL_BOOLEAN_CASTS ) +
1:07d1108:              "\nfrom\n" +
1:07d1108:              "  sys.sysconglomerates c,\n" +
1:07d1108:              "  sys.systables t\n" +
1:07d1108:              "where t.tablename='SYSTABLES'\n" +
1:07d1108:              "and t.tableid = c.tableid\n" +
1:07d1108:              "and not c.isIndex\n",
1:07d1108:              false,
1:07d1108:              1
1:07d1108:              );
1:07d1108:     }
1:07d1108:     private void makeTableForCasts( String tableName, TypedColumn[] columns )
1:07d1108:         throws Exception
1:07d1108:     {
1:07d1108:         StringBuffer buffer = new StringBuffer();
1:07d1108:         int  count = columns.length;
1:07d1108: 
1:07d1108:         buffer.append( "create table " + tableName + "\n(\n" );
1:07d1108:         for ( int i = 0; i < count; i++ )
1:07d1108:         {
1:07d1108:             buffer.append( "\t" );
1:07d1108:             if ( i > 0 ) { buffer.append( ", " ); }
1:07d1108: 
1:07d1108:             TypedColumn tc = columns[ i ];
1:07d1108: 
1:07d1108:             buffer.append( tc.columnName + "\t" + tc.typeName + "\n"  );
1:07d1108:         }
1:07d1108:         buffer.append( ")\n" );
1:07d1108:         
1:07d1108:         goodStatement( buffer.toString() );
1:07d1108:     }
1:07d1108:     // make a comma-separated list of column names
1:07d1108:     private String makeColumnList( TypedColumn[] columns )
1:07d1108:     {
1:07d1108:         StringBuffer buffer = new StringBuffer();
1:07d1108:         int  count = columns.length;
1:07d1108: 
1:07d1108:         for ( int i = 0; i < count; i++ )
1:07d1108:         {
1:07d1108:             if ( i > 0 ) { buffer.append( ", " ); }
1:07d1108:             buffer.append( columns[ i ].columnName  );
1:07d1108:         }
1:07d1108: 
1:07d1108:         return buffer.toString();
1:07d1108:     }
1:07d1108:     // make a comma-separated list of a column casted to various target types
1:07d1108:     private String makeCastedColumnList( String columnName, TypedColumn[] targetTypes )
1:07d1108:     {
1:07d1108:         StringBuffer buffer = new StringBuffer();
1:07d1108:         int  count = targetTypes.length;
1:07d1108: 
1:07d1108:         for ( int i = 0; i < count; i++ )
1:07d1108:         {
1:07d1108:             if ( i > 0 ) { buffer.append( ", " ); }
1:07d1108:             buffer.append( "cast ( " + columnName + " as " + targetTypes[ i ].typeName + " )" );
1:07d1108:         }
1:07d1108: 
1:07d1108:         return buffer.toString();
1:07d1108:     }
1:07d1108:     // make a comma-separated list of N copies of a column
1:07d1108:     private String makeRepeatedColumnList( String columnName, int N )
1:07d1108:     {
1:07d1108:         StringBuffer buffer = new StringBuffer();
1:07d1108: 
1:07d1108:         for ( int i = 0; i < N; i++ )
1:07d1108:         {
1:07d1108:             if ( i > 0 ) { buffer.append( ", " ); }
1:07d1108:             buffer.append( columnName  );
1:07d1108:         }
1:07d1108: 
1:07d1108:         return buffer.toString();
1:07d1108:     }
1:07d1108:     // assert that all result columns have the given boolean value
1:07d1108:     private void assertBooleanResults( String queryText, boolean expectedValue, int expectedRowCount )
1:07d1108:         throws Exception
1:07d1108:     {
1:07d1108:         PreparedStatement ps = chattyPrepare( queryText );
1:07d1108:         ResultSet rs = ps.executeQuery();
1:07d1108:         int actualRowCount = 0;
1:07d1108:         int columnCount = rs.getMetaData().getColumnCount();
1:07d1108:         String expectedStringValue = Boolean.toString( expectedValue );
1:07d1108: 
2:07d1108:         while ( rs.next() )
1:07d1108:         {
1:07d1108:             actualRowCount++;
1:07d1108: 
1:07d1108:             for ( int i = 0; i < columnCount; i++ )
1:07d1108:             {
1:07d1108:                 assertEquals( "Column " + i, expectedStringValue, rs.getString( i + 1 ).trim() );
1:07d1108:             }
1:07d1108:         }
1:07d1108: 
2:07d1108:         rs.close();
1:07d1108:         ps.close();
1:07d1108: 
1:07d1108:         assertEquals( expectedRowCount, actualRowCount );
1:07d1108:     }
1:07d1108:     // assert a scalar result
1:07d1108:     private void assertScalarResult( String queryText, int expectedValue ) throws Exception
1:07d1108:     {
1:07d1108:         PreparedStatement ps = chattyPrepare( queryText );
1:07d1108:         ResultSet rs = ps.executeQuery();
1:07d1108: 
1:07d1108:         rs.next();
1:07d1108:         assertEquals( expectedValue, rs.getInt( 1 ) );
1:07d1108: 
1:07d1108:         rs.close();
1:07d1108:         ps.close();
1:07d1108:     }
1:07d1108:     // assert that we are testing the casting behavior of BOOLEANs to and from
1:07d1108:     // all Derby data types
1:07d1108:     private void assertAllTypesCovered() throws Exception
1:07d1108:     {
1:07d1108:         println( "Verify that we are testing the casting behavior of BOOLEAN to/from all Derby data types." );
1:07d1108:         
2:07d1108:         Connection conn = getConnection();
2:07d1108:         DatabaseMetaData dbmd = conn.getMetaData();
2:07d1108:         ResultSet rs = dbmd.getTypeInfo();
1:07d1108:         int count = 0;
1:07d1108: 
1:3210ebc:         int expectedDataTypeCount = LEGAL_BOOLEAN_CASTS.length + ILLEGAL_BOOLEAN_CASTS.length;
1:3210ebc:         // getTypeInfo() also returns a row for the generic OBJECT data type
1:3210ebc:         expectedDataTypeCount++;
1:3210ebc: 
1:07d1108:         while ( rs.next() ) { count++; }
1:07d1108: 
1:07d1108:         assertEquals( "You must add your new data type to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS",
1:3210ebc:                       expectedDataTypeCount,
1:07d1108:                       count );
1:07d1108:         
1:07d1108:         rs.close();
1:07d1108:     }
1:07d1108:     
1:07d1108:     /**
1:07d1108:      * <p>
1:07d1108:      * Verify that the illegal boolean casts work as expected. This
1:07d1108:      * test helps verify that DERBY-887 is fixed. Verifies the
1:07d1108:      * following:
1:07d1108:      * </p>
1:07d1108:      *
1:07d1108:      * <ul>
1:07d1108:      * <li>Implicit casts of BOOLEAN to illegal types.</li>
1:07d1108:      * <li>Implicit casts of illegal types to BOOLEAN.</li>
1:07d1108:      * <li>Explicit casts of BOOLEAN to illegal types.</li>
1:07d1108:      * </ul>
1:07d1108:      *
1:07d1108:      * <p>
1:07d1108:      * The following can't be tested until the BOOLEAN type is re-enabled:
1:07d1108:      * </p>
1:07d1108:      *
1:07d1108:      * <ul>
1:07d1108:      * <li>Explicit casts of illegal types to BOOLEAN.</li>
1:07d1108:      * </ul>
1:07d1108:      */
1:07d1108:     public void test_illegalBooleanCasts() throws Exception
1:07d1108:     {
1:07d1108:         //
1:07d1108:         // This assertion will fail if a new Derby data type is added. To
1:07d1108:         // silence this assertion, you must add the new data type
1:07d1108:         // to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS.
1:07d1108:         //
1:07d1108:         assertAllTypesCovered();
1:07d1108:         
1:07d1108:         int  illegalTypeCount = ILLEGAL_BOOLEAN_CASTS.length;
1:07d1108:         String  tableName = "t_illegal_boolean_casts";
1:07d1108:         // create a table whose columns are all the illegal datatypes
1:07d1108:         makeTableForCasts( tableName, ILLEGAL_BOOLEAN_CASTS );
1:07d1108: 
1:07d1108:         // use inserts to test implicit casts of boolean to the illegal types
1:07d1108:         for ( int i = 0; i < illegalTypeCount; i++ )
1:07d1108:         {
1:07d1108:             TypedColumn tc = ILLEGAL_BOOLEAN_CASTS[ i ];
1:07d1108:             expectError
1:07d1108:                 (
1:07d1108:                  LANG_NOT_STORABLE_SQLSTATE,
1:07d1108:                  "insert into " + tableName + "( " + tc.columnName + " ) select c.isIndex from sys.sysconglomerates c\n"
1:07d1108:                  );
1:07d1108:         }
1:07d1108: 
1:07d1108:         // test implicit casts of illegal types to boolean
1:07d1108:         for ( int i = 0; i < illegalTypeCount; i++ )
1:07d1108:         {
1:07d1108:             TypedColumn tc = ILLEGAL_BOOLEAN_CASTS[ i ];
1:07d1108:             expectError
1:07d1108:                 (
1:07d1108:                  LANG_NOT_COMPARABLE_SQLSTATE,
1:07d1108:                  "select * from " + tableName + " t, sys.sysconglomerates c where t." + tc.columnName + " = c.isIndex\n"
1:07d1108:                  );
1:07d1108:         }
1:07d1108:         
1:07d1108:         // test explicit casts of boolean to illegal types
1:07d1108:         for ( int i = 0; i < illegalTypeCount; i++ )
1:07d1108:         {
1:07d1108:             TypedColumn[] castedColumnList = new TypedColumn[] { ILLEGAL_BOOLEAN_CASTS[ i ] };
1:07d1108:             expectError
1:07d1108:                 (
1:07d1108:                  ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:07d1108:                  "select " + makeCastedColumnList( "c.isIndex", castedColumnList ) + " from sys.sysconglomerates c\n"
1:07d1108:                  );
1:07d1108:         }
1:07d1108:     }
1:07d1108: 
1:fffce91:     /**
1:75ec275:      * Test that a java.sql.DataTruncation warning is created when a cast
1:75ec275:      * results in truncation. DERBY-129.
1:75ec275:      */
1:75ec275:     public void testDataTruncationWarning() throws SQLException {
1:75ec275:         Statement s = createStatement();
1:75ec275: 
1:75ec275:         // Test truncation of character data
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values (cast('abc' as char(2)), cast('de'   as char(2)))," +
1:75ec275:             "       (cast('fg'  as char(2)), cast('hi'   as char(2)))," +
1:75ec275:             "       (cast('jkl' as char(2)), cast('mnop' as char(2)))");
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values (cast('abc' as varchar(2)), cast('de'   as varchar(2)))," +
1:75ec275:             "       (cast('fg'  as varchar(2)), cast('hi'   as varchar(2)))," +
1:75ec275:             "       (cast('jkl' as varchar(2)), cast('mnop' as varchar(2)))");
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values (cast('abc' as clob(2)), cast('de'   as clob(2)))," +
1:75ec275:             "       (cast('fg'  as clob(2)), cast('hi'   as clob(2)))," +
1:75ec275:             "       (cast('jkl' as clob(2)), cast('mnop' as clob(2)))");
1:75ec275: 
1:75ec275:         // Exact same test as above for binary data
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values (cast(x'abcdef' as char(2) for bit data),"+
1:75ec275:             "        cast(x'abcd' as char(2) for bit data))," +
1:75ec275:             "       (cast(x'abcd' as char(2) for bit data)," +
1:75ec275:             "        cast(x'cdef' as char(2) for bit data))," +
1:75ec275:             "       (cast(x'012345' as char(2) for bit data)," +
1:75ec275:             "        cast(x'6789ABCD' as char(2) for bit data))");
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values (cast(x'abcdef' as varchar(2) for bit data),"+
1:75ec275:             "        cast(x'abcd' as varchar(2) for bit data))," +
1:75ec275:             "       (cast(x'abcd' as varchar(2) for bit data)," +
1:75ec275:             "        cast(x'cdef' as varchar(2) for bit data))," +
1:75ec275:             "       (cast(x'012345' as varchar(2) for bit data)," +
1:75ec275:             "        cast(x'6789ABCD' as varchar(2) for bit data))");
1:75ec275:         checkDataTruncationResult(s,
1:75ec275:             "values" +
1:75ec275:             "    (cast(x'abcdef' as blob(2)), cast(x'abcd' as blob(2))), " +
1:75ec275:             "    (cast(x'abcd' as blob(2)),   cast(x'cdef' as blob(2))), " +
1:75ec275:             "    (cast(x'012345' as blob(2)), cast(x'6789ABCD' as blob(2)))");
1:75ec275: 
1:75ec275:         // DataTruncation's javadoc says that getDataSize() and
1:75ec275:         // getTransferSize() should return number of bytes. Derby uses
1:75ec275:         // UTF-8. Test with some characters outside the US-ASCII range to
1:75ec275:         // verify that the returned values are in bytes and not in chars.
1:75ec275:         ResultSet rs = s.executeQuery(
1:75ec275:                 "values cast('abc\u00E6\u00F8\u00E5' as varchar(4))");
1:75ec275:         assertTrue(rs.next());
1:75ec275:         assertEquals("abc\u00E6", rs.getString(1));
1:75ec275:         // The warning should say the string is truncated from 9 bytes to
1:75ec275:         // 5 bytes, not from 6 characters to 4 characters.
1:75ec275:         assertDataTruncation(rs.getWarnings(), -1, true, false, 9, 5);
1:75ec275:         assertFalse(rs.next());
1:75ec275:         rs.close();
1:75ec275: 
1:75ec275:         // Test that there's a warning on the statement if truncation happens
1:75ec275:         // in an operation that doesn't return a ResultSet.
1:75ec275:         setAutoCommit(false);
1:75ec275:         s.execute("create table t1_d129 (x8 char(8) for bit data)");
1:75ec275:         s.execute("create table t2_d129 (x4 char(4) for bit data)");
1:75ec275:         s.execute("insert into t1_d129(x8) values x'0123456789ABCDEF'");
1:75ec275:         assertNull(s.getWarnings());
1:75ec275:         s.execute("insert into t2_d129(x4) " +
1:75ec275:                   "select cast(x8 as char(4) for bit data) from t1_d129");
1:75ec275:         assertDataTruncation(s.getWarnings(), -1, true, false, 8, 4);
1:75ec275:         rollback();
1:75ec275:     }
1:75ec275: 
1:75ec275:     /**
1:75ec275:      * <p>
1:75ec275:      * Check the results for the queries in testDataTruncation().
1:75ec275:      * </p>
1:75ec275:      *
1:75ec275:      * <p>
1:75ec275:      * The method expects a query that returns three rows with columns of a
1:75ec275:      * character string or binary string data type, where some of the values
1:75ec275:      * are cast to a narrower data type.
1:75ec275:      * </p>
1:75ec275:      *
1:75ec275:      * <p>
1:75ec275:      * Expect the following truncations to have taken place:
1:75ec275:      * </p>
1:75ec275:      *
1:75ec275:      * <ol>
1:75ec275:      * <li>Row 1, column 1: truncated from 3 to 2 bytes</li>
1:75ec275:      * <li>Row 3, column 1: truncated from 3 to 2 bytes</li>
1:75ec275:      * <li>Row 3, column 2: truncated from 4 to 2 bytes</li>
1:75ec275:      * </ol>
1:75ec275:      */
1:75ec275:     private void checkDataTruncationResult(Statement s, String sql)
1:75ec275:             throws SQLException {
1:75ec275:         ResultSet rs = s.executeQuery(sql);
1:75ec275: 
1:75ec275:         // First row should have one warning (column 1)
1:75ec275:         assertTrue(rs.next());
1:75ec275:         SQLWarning w = rs.getWarnings();
1:75ec275:         assertDataTruncation(w, -1, true, false, 3, 2);
1:75ec275:         w = w.getNextWarning();
1:75ec275:         assertNull(w);
1:75ec275:         rs.clearWarnings(); // workaround for DERBY-5765
1:75ec275: 
1:75ec275:         // Second row should have no warnings
1:75ec275:         assertTrue(rs.next());
1:75ec275:         assertNull(rs.getWarnings());
1:75ec275: 
1:75ec275:         // Third row should have two warnings (column 1 and 2)
1:75ec275:         assertTrue(rs.next());
1:75ec275:         w = rs.getWarnings();
1:75ec275:         assertDataTruncation(w, -1, true, false, 3, 2);
1:75ec275:         // Client driver doesn't support nested warnings
1:75ec275:         if (usingEmbedded()) {
1:75ec275:             w = w.getNextWarning();
1:75ec275:             assertDataTruncation(w, -1, true, false, 4, 2);
1:75ec275:         }
1:75ec275:         w = w.getNextWarning();
1:75ec275:         assertNull(w);
1:75ec275:         rs.clearWarnings(); // workaround for DERBY-5765
1:75ec275: 
1:75ec275:         // No more rows
1:75ec275:         assertFalse(rs.next());
1:75ec275:         rs.close();
1:75ec275: 
1:75ec275:         // There should be no warnings on the statement or the connection
1:75ec275:         assertNull(s.getWarnings());
1:75ec275:         assertNull(getConnection().getWarnings());
1:75ec275:     }
1:75ec275: 
1:75ec275:     private void assertDataTruncation(
1:75ec275:             SQLWarning w, int index, boolean read, boolean parameter,
1:75ec275:             int dataSize, int transferSize) throws SQLException {
1:75ec275:         assertNotNull("No warning", w);
1:75ec275:         if (!(w instanceof DataTruncation)) {
1:75ec275:             fail("Not a DataTruncation warning", w);
1:75ec275:         }
1:75ec275: 
1:75ec275:         DataTruncation dt = (DataTruncation) w;
1:75ec275:         assertEquals("Column index", index, dt.getIndex());
1:75ec275:         assertEquals("Read", read, dt.getRead());
1:75ec275:         assertEquals("Parameter", parameter, dt.getParameter());
1:75ec275:         assertEquals("Data size", dataSize, dt.getDataSize());
1:75ec275:         assertEquals("Transfer size", transferSize, dt.getTransferSize());
1:75ec275:     }
1:75ec275: 
1:c1a0ff2:     /**
1:c1a0ff2:      * DERBY-896: Verify that casts from DATE and TIME to TIMESTAMP work.
1:c1a0ff2:      */
1:c1a0ff2:     public void testDateTimeToTimestamp() throws SQLException {
1:c1a0ff2:         Statement s = createStatement();
1:c1a0ff2: 
1:c1a0ff2:         ResultSet rs = s.executeQuery(
1:c1a0ff2:                 "values (cast (current date as timestamp), "
1:c1a0ff2:                       + "current date, "
1:c1a0ff2:                       + "cast (current time as timestamp), "
1:c1a0ff2:                       + "current time)");
1:c1a0ff2: 
1:c1a0ff2:         // Verify correct types of casts.
1:c1a0ff2:         ResultSetMetaData rsmd = rs.getMetaData();
1:c1a0ff2:         assertEquals(Types.TIMESTAMP, rsmd.getColumnType(1));
1:c1a0ff2:         assertEquals(Types.TIMESTAMP, rsmd.getColumnType(3));
1:c1a0ff2: 
1:c1a0ff2:         rs.next();
1:c1a0ff2: 
1:c1a0ff2:         // CAST (CURRENT DATE AS TIMESTAMP) should match midnight of
1:c1a0ff2:         // current date.
1:c1a0ff2:         assertEquals(rs.getString(2) + " 00:00:00.0", rs.getString(1));
1:c1a0ff2: 
1:c1a0ff2:         // CAST (CURRENT TIME AS TIMESTAMP) should match current time of
1:c1a0ff2:         // current date.
1:c1a0ff2:         assertEquals(rs.getString(2) + ' ' + rs.getString(4) + ".0",
1:c1a0ff2:                      rs.getString(3));
1:c1a0ff2: 
1:c1a0ff2:         rs.close();
1:c1a0ff2: 
1:c1a0ff2:         // Don't allow casts between DATE and TIME.
1:c1a0ff2:         assertCompileError(ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:c1a0ff2:                            "values cast(current time as date)");
1:c1a0ff2:         assertCompileError(ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:c1a0ff2:                            "values cast(current date as time)");
1:c1a0ff2: 
1:c1a0ff2:         s.execute("create table derby896(id int generated always as identity, "
1:c1a0ff2:                 + "d date, t time, ts timestamp)");
1:c1a0ff2: 
1:c1a0ff2:         // Only explicit casts are allowed.
1:c1a0ff2:         assertCompileError(LANG_NOT_STORABLE_SQLSTATE,
1:c1a0ff2:                            "insert into derby896(ts) values current time");
1:c1a0ff2:         assertCompileError(LANG_NOT_STORABLE_SQLSTATE,
1:c1a0ff2:                            "insert into derby896(ts) values current date");
1:c1a0ff2:         s.execute("insert into derby896(d,t,ts) values "
1:c1a0ff2:             + "(current date, current time, cast(current date as timestamp)), "
1:c1a0ff2:             + "(current date, current time, cast(current time as timestamp))");
1:c1a0ff2: 
1:c1a0ff2:         // Verify that the correct values were inserted.
1:c1a0ff2:         rs = s.executeQuery("select d, t, ts from derby896 order by id");
1:c1a0ff2:         rs.next();
1:c1a0ff2:         assertEquals(rs.getString(1) + " 00:00:00.0", rs.getString(3));
1:c1a0ff2:         rs.next();
1:c1a0ff2:         assertEquals(rs.getString(1) + ' ' + rs.getString(2) + ".0",
1:c1a0ff2:                      rs.getString(3));
1:c1a0ff2:         rs.close();
1:c1a0ff2: 
1:c1a0ff2:         // Insert some more values that we can use in casts later.
1:c1a0ff2:         s.execute("insert into derby896(d, t) values "
1:c1a0ff2:                 + "({d'1999-12-31'}, {t'23:59:59'}), "
1:c1a0ff2:                 + "({d'2000-01-01'}, {t'00:00:00'}), "
1:c1a0ff2:                 + "({d'1970-01-01'}, {t'00:00:01'}), "
1:c1a0ff2:                 + "({d'1969-12-31'}, {t'12:00:00'})");
1:c1a0ff2: 
1:c1a0ff2:         // Verify correct casts from DATE to TIMESTAMP in SELECT list.
1:c1a0ff2:         rs = s.executeQuery("select d, cast(d as timestamp) from derby896");
1:c1a0ff2:         while (rs.next()) {
1:c1a0ff2:             assertEquals(rs.getString(1) + " 00:00:00.0", rs.getString(2));
1:c1a0ff2:         }
1:c1a0ff2:         rs.close();
1:c1a0ff2: 
1:c1a0ff2:         // Verify correct casts from TIME to TIMESTAMP in SELECT list.
1:c1a0ff2:         rs = s.executeQuery("select t, cast(t as timestamp), current date "
1:c1a0ff2:                             + "from derby896");
1:c1a0ff2:         while (rs.next()) {
1:c1a0ff2:             assertEquals(rs.getString(3) + ' ' + rs.getString(1) + ".0",
1:c1a0ff2:                          rs.getString(2));
1:c1a0ff2:         }
1:c1a0ff2:         rs.close();
1:c1a0ff2:     }
1:c1a0ff2: 
1:fffce91:     protected void tearDown() throws SQLException, Exception {
1:a2567fa:         Statement scb = createStatement();
1:07d1108: 
1:1cf00e6:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:1cf00e6:             String typeName = SQLUtilities.SQLTypes[type];
1:fffce91:             String tableName = getTableName(type);
1:07d1108: 
1:fffce91:             String dropSQL = "drop table " + tableName;
1:07d1108: 
1:fffce91:             scb.executeUpdate(dropSQL);
1:07d1108:         }
1:07d1108: 
1:fffce91:         scb.close();
1:a2567fa:         commit();
1:a2567fa:         super.tearDown();
1:07d1108:     }
1:fffce91: 
1:fffce91:     /**
1:fffce91:      * Build a unique table name from the type
1:fffce91:      * 
1:fffce91:      * @param type
1:fffce91:      *            table offset
1:fffce91:      * @return Table name in format <TYPE>_TAB. Replaces ' ' _;
1:fffce91:      */
1:fffce91:     private static String getTableName(int type) {
1:fffce91:         return getShortTypeName(type).replace(' ', '_') + "_TAB";
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     /**
1:fffce91:      * Truncates (*) from typename
1:fffce91:      * 
1:fffce91:      * @param type -
1:fffce91:      *            Type offset
1:fffce91:      * 
1:fffce91:      * @return short name of type (e.g DECIMAL instead of DECIMAL(10,5)
1:fffce91:      */
1:fffce91: 
1:fffce91:     private static String getShortTypeName(int type) {
1:1cf00e6:         String typeName = SQLUtilities.SQLTypes[type];
1:fffce91:         String shortName = typeName;
1:fffce91:         int parenIndex = typeName.indexOf('(');
1:fffce91:         if (parenIndex >= 0) {
1:fffce91:             shortName = typeName.substring(0, parenIndex);
1:fffce91:             int endParenIndex = typeName.indexOf(')');
1:fffce91:             shortName = shortName
1:fffce91:                     + typeName.substring(endParenIndex + 1, typeName.length());
1:fffce91:         }
1:fffce91:         return shortName;
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static String getCompatibleString(int sourceType, int targetType,
1:fffce91:             int dataOffset) {
4:fffce91:         String convertString = null;
1:fffce91:         // for string and binary types use the target data string
1:fffce91:         // so that the cast will work
1:fffce91:         if ((isCharacterType(sourceType) || isBinaryType(sourceType))
1:fffce91:                 && !isLob(sourceType))
1:fffce91:             convertString = formatString(SQLData[targetType][dataOffset]);
1:fffce91:         else
1:fffce91:             convertString = SQLData[sourceType][dataOffset];
1:fffce91: 
1:fffce91:         return convertString;
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isSupportedCast(int sourceType, int targetType) {
1:fffce91:         return T_146[sourceType][targetType];
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isSupportedAssignment(int sourceType, int targetType) {
1:fffce91:         return T_147a[sourceType][targetType];
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isSupportedComparison(int sourceType, int targetType) {
1:fffce91:         return T_147b[sourceType][targetType];
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isCastException(SQLException se) {
1:fffce91:         return sqlStateMatches(se, ILLEGAL_CAST_EXCEPTION_SQLSTATE);
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isMethodNotFoundException(SQLException se) {
1:fffce91:         return sqlStateMatches(se, METHOD_NOT_FOUND_SQLSTATE);
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean sqlStateMatches(SQLException se, String expectedValue) {
1:fffce91:         String sqlState = se.getSQLState();
1:fffce91:         if ((sqlState != null) && (sqlState.equals(expectedValue)))
1:fffce91:             return true;
1:fffce91:         return false;
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isNotStorableException(SQLException se) {
1:fffce91:         String sqlState = se.getSQLState();
1:fffce91:         if ((sqlState != null) && (sqlState.equals(LANG_NOT_STORABLE_SQLSTATE)))
1:fffce91:             return true;
1:fffce91:         return false;
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isNotComparableException(SQLException se) {
1:fffce91:         String sqlState = se.getSQLState();
1:fffce91:         if ((sqlState != null)
1:fffce91:                 && (sqlState.equals(LANG_NOT_COMPARABLE_SQLSTATE)))
1:fffce91:             return true;
1:fffce91:         return false;
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static void checkSupportedCast(int sourceType, int targetType) {
1:1cf00e6:         String description = " Cast from " + SQLUtilities.SQLTypes[sourceType] + " to "
1:1cf00e6:                 + SQLUtilities.SQLTypes[targetType];
1:fffce91: 
1:fffce91:         if (!isSupportedCast(sourceType, targetType))
1:fffce91:             fail(description + "should not succeed");
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static void checkSupportedAssignment(int sourceType, int targetType) {
1:1cf00e6:         String description = " Assignment from " + SQLUtilities.SQLTypes[sourceType]
1:1cf00e6:                 + " to " + SQLUtilities.SQLTypes[targetType];
1:fffce91: 
1:fffce91:         if (!isSupportedAssignment(sourceType, targetType))
1:fffce91:             fail(description + "should not succeed");
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static void checkSupportedComparison(int sourceType, int targetType) {
1:1cf00e6:         String description = " Comparison of " + SQLUtilities.SQLTypes[sourceType] + " to "
1:1cf00e6:                 + SQLUtilities.SQLTypes[targetType];
1:fffce91: 
1:fffce91:         if (!isSupportedComparison(sourceType, targetType))
1:fffce91:             fail("FAIL: unsupported comparison:" + description);
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isLongType(int typeOffset) {
1:fffce91:         return ((typeOffset == LONGVARCHAR_OFFSET)
1:fffce91:                 || (typeOffset == LONGVARCHAR_FOR_BIT_OFFSET)
1:fffce91:                 || (typeOffset == CLOB_OFFSET) || (typeOffset == BLOB_OFFSET));
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isCharacterType(int typeOffset) {
1:fffce91:         return ((typeOffset == CHAR_OFFSET) || (typeOffset == VARCHAR_OFFSET)
1:fffce91:                 || (typeOffset == LONGVARCHAR_OFFSET) || (typeOffset == CLOB_OFFSET));
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isBinaryType(int typeOffset) {
1:fffce91:         return ((typeOffset == CHAR_FOR_BIT_OFFSET)
1:fffce91:                 || (typeOffset == VARCHAR_FOR_BIT_OFFSET)
1:fffce91:                 || (typeOffset == LONGVARCHAR_FOR_BIT_OFFSET) || (typeOffset == BLOB_OFFSET));
1:fffce91:     }
1:fffce91: 
1:c1a0ff2:     private static boolean isTime(int typeOffset) {
1:c1a0ff2:         return (typeOffset == TIME_OFFSET);
1:fffce91:     }
1:fffce91: 
1:c1a0ff2:     private static boolean isTimestamp(int typeOffset) {
1:c1a0ff2:         return (typeOffset == TIMESTAMP_OFFSET);
1:fffce91:     }
1:fffce91: 
1:fffce91:     private static boolean isLob(int typeOffset) {
1:fffce91:         return ((typeOffset == CLOB_OFFSET) || (typeOffset == BLOB_OFFSET));
1:fffce91: 
1:fffce91:     }
1:fffce91: 
1:fffce91:     // Data is already a string (starts with X, or a character string,
1:fffce91:     // just return, otherwise bracket with ''s
1:fffce91:     private static String formatString(String str) {
1:fffce91:         if ((str != null)
1:fffce91:                 && (str.startsWith("X") || str.startsWith("'") || (str == NULL_VALUE)))
1:fffce91:             return str;
1:fffce91:         else
1:fffce91:             return "'" + str + "'";
1:fffce91:     }
1:fffce91: 
1:c7f3642:     /**
1:07d1108:      * Run good DDL.
1:07d1108:      * @throws SQLException 
1:07d1108:      */
1:07d1108:     private void    goodStatement( String ddl ) throws SQLException
1:07d1108:     {
1:07d1108:             PreparedStatement    ps = chattyPrepare( ddl );
1:07d1108: 
1:07d1108:             ps.execute();
1:07d1108:             ps.close();
1:07d1108:     }
1:07d1108:     
1:07d1108:     /**
1:07d1108:      * Assert that the statement text, when compiled, raises an exception
1:07d1108:      */
1:07d1108:     private void    expectError( String sqlState, String query )
1:07d1108:     {
1:07d1108:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1:07d1108: 
1:07d1108:         assertCompileError( sqlState, query );
1:07d1108:     }
1:07d1108:     
1:07d1108:     /**
1:07d1108:      * Prepare a statement and report its sql text.
1:07d1108:      */
1:07d1108:     private PreparedStatement   chattyPrepare( String text )
1:07d1108:         throws SQLException
1:07d1108:     {
1:07d1108:         println( "Preparing statement:\n\t" + text );
1:07d1108:         
1:07d1108:         return prepareStatement( text );
1:07d1108:     }
1:07d1108: 
1:07d1108:     /**
1:75ec275:      * Create a test suite with all the tests in this class. Although we're
1:75ec275:      * testing embedded functionality, also run the test in client/server
1:75ec275:      * mode to ensure that warnings and errors travel across the wire.
1:c7f3642:      */
1:5e9a335:     public static Test suite() {
1:75ec275:         return TestConfiguration.defaultSuite(CastingTest.class);
1:fffce91:     }
1:fffce91: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c1a0ff2
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1: //                        L  G  N  M     L     H  V  .  H  V           S
1: //                        I  E  T  A     E     A  A  B  .  A           T
1: //                        N  R     L           R  R  I  B  R           A
1: //                        T                       C  T  I  .           M
1: //                                                H     T  B           P
1: //                                                A        I
1: //                                                R        T
/////////////////////////////////////////////////////////////////////////
1: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, X, n },
1: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, X, n },
/////////////////////////////////////////////////////////////////////////
1: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1: //                        L  G  N  M     L     H  V  .  H  V           S
1: //                        I  E  T  A     E     A  A  B  .  A           T
1: //                        N  R     L           R  R  I  B  R           A
1: //                        T                       C  T  I  .           M
1: //                                                H     T  B           P
1: //                                                A        I
1: //                                                R        T
/////////////////////////////////////////////////////////////////////////
1: //Types.                  S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1: //                        M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1: //                        A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1: //                        L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1: //                        L  G  N  M     L     H  V  .  H  V           S
1: //                        I  E  T  A     E     A  A  B  .  A           T
1: //                        N  R     L           R  R  I  B  R           A
1: //                        T                       C  T  I  .           M
1: //                                                H     T  B           P
1: //                                                A        I
1: //                                                R        T
/////////////////////////////////////////////////////////////////////////
1:     /*DATE*/ {"Exception","Exception","Exception","Exception","Exception","Exception","2000-01-01                                                  ","2000-01-01","Exception","Exception","Exception","Exception","Exception","2000-01-01","Exception","2000-01-01 00:00:00.0","Exception"},
1:     /*TIME*/ {"Exception","Exception","Exception","Exception","Exception","Exception","15:30:20                                                    ","15:30:20","Exception","Exception","Exception","Exception","Exception","Exception","15:30:20","TODAY 15:30:20.0","Exception"},
/////////////////////////////////////////////////////////////////////////
1:                         // Record the start time so that we can calculate
1:                         // the current date when checking TIME -> TIMESTAMP
1:                         // conversion.
1:                         final long startTime = System.currentTimeMillis();
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                         // Record the time after finishing the data retrieval.
1:                         // Used for calculating the current date when checking
1:                         // TIME -> TIMESTAMP conversion.
1:                         final long finishTime = System.currentTimeMillis();
1: 
1:                             String expected =
1:                                 explicitCastValues[sourceType][targetType];
1: 
1:                             if (isTime(sourceType) && isTimestamp(targetType)) {
1:                                 // The expected value for a cast from TIME to
1:                                 // TIMESTAMP includes the current date, so
1:                                 // construct the expected value at run-time.
1:                                 // We may have crossed midnight during query
1:                                 // execution, in which case we cannot tell
1:                                 // whether today or yesterday was used. Accept
1:                                 // both.
1:                                 String[] expectedValues = {
1:                                     expected.replace(
1:                                       "TODAY", new Date(startTime).toString()),
1:                                     expected.replace(
1:                                       "TODAY", new Date(finishTime).toString()),
1:                                 };
1:                                 HashSet<String> valid = new HashSet<String>(
1:                                         Arrays.asList(expectedValues));
1:                                 if (!valid.contains(val)) {
1:                                     fail("Got " + val + ", expected one of "
1:                                          + valid);
1:                                 }
1:                             } else {
1:                                 // For all other types...
1:                                 assertEquals(expected, val);
1:                             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-896: Verify that casts from DATE and TIME to TIMESTAMP work.
1:      */
1:     public void testDateTimeToTimestamp() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         ResultSet rs = s.executeQuery(
1:                 "values (cast (current date as timestamp), "
1:                       + "current date, "
1:                       + "cast (current time as timestamp), "
1:                       + "current time)");
1: 
1:         // Verify correct types of casts.
1:         ResultSetMetaData rsmd = rs.getMetaData();
1:         assertEquals(Types.TIMESTAMP, rsmd.getColumnType(1));
1:         assertEquals(Types.TIMESTAMP, rsmd.getColumnType(3));
1: 
1:         rs.next();
1: 
1:         // CAST (CURRENT DATE AS TIMESTAMP) should match midnight of
1:         // current date.
1:         assertEquals(rs.getString(2) + " 00:00:00.0", rs.getString(1));
1: 
1:         // CAST (CURRENT TIME AS TIMESTAMP) should match current time of
1:         // current date.
1:         assertEquals(rs.getString(2) + ' ' + rs.getString(4) + ".0",
1:                      rs.getString(3));
1: 
1:         rs.close();
1: 
1:         // Don't allow casts between DATE and TIME.
1:         assertCompileError(ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:                            "values cast(current time as date)");
1:         assertCompileError(ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:                            "values cast(current date as time)");
1: 
1:         s.execute("create table derby896(id int generated always as identity, "
1:                 + "d date, t time, ts timestamp)");
1: 
1:         // Only explicit casts are allowed.
1:         assertCompileError(LANG_NOT_STORABLE_SQLSTATE,
1:                            "insert into derby896(ts) values current time");
1:         assertCompileError(LANG_NOT_STORABLE_SQLSTATE,
1:                            "insert into derby896(ts) values current date");
1:         s.execute("insert into derby896(d,t,ts) values "
1:             + "(current date, current time, cast(current date as timestamp)), "
1:             + "(current date, current time, cast(current time as timestamp))");
1: 
1:         // Verify that the correct values were inserted.
1:         rs = s.executeQuery("select d, t, ts from derby896 order by id");
1:         rs.next();
1:         assertEquals(rs.getString(1) + " 00:00:00.0", rs.getString(3));
1:         rs.next();
1:         assertEquals(rs.getString(1) + ' ' + rs.getString(2) + ".0",
1:                      rs.getString(3));
1:         rs.close();
1: 
1:         // Insert some more values that we can use in casts later.
1:         s.execute("insert into derby896(d, t) values "
1:                 + "({d'1999-12-31'}, {t'23:59:59'}), "
1:                 + "({d'2000-01-01'}, {t'00:00:00'}), "
1:                 + "({d'1970-01-01'}, {t'00:00:01'}), "
1:                 + "({d'1969-12-31'}, {t'12:00:00'})");
1: 
1:         // Verify correct casts from DATE to TIMESTAMP in SELECT list.
1:         rs = s.executeQuery("select d, cast(d as timestamp) from derby896");
1:         while (rs.next()) {
1:             assertEquals(rs.getString(1) + " 00:00:00.0", rs.getString(2));
1:         }
1:         rs.close();
1: 
1:         // Verify correct casts from TIME to TIMESTAMP in SELECT list.
1:         rs = s.executeQuery("select t, cast(t as timestamp), current date "
1:                             + "from derby896");
1:         while (rs.next()) {
1:             assertEquals(rs.getString(3) + ' ' + rs.getString(1) + ".0",
1:                          rs.getString(2));
1:         }
1:         rs.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static boolean isTime(int typeOffset) {
1:         return (typeOffset == TIME_OFFSET);
1:     private static boolean isTimestamp(int typeOffset) {
1:         return (typeOffset == TIMESTAMP_OFFSET);
commit:75ec275
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DataTruncation;
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that a java.sql.DataTruncation warning is created when a cast
1:      * results in truncation. DERBY-129.
1:      */
1:     public void testDataTruncationWarning() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Test truncation of character data
1:         checkDataTruncationResult(s,
1:             "values (cast('abc' as char(2)), cast('de'   as char(2)))," +
1:             "       (cast('fg'  as char(2)), cast('hi'   as char(2)))," +
1:             "       (cast('jkl' as char(2)), cast('mnop' as char(2)))");
1:         checkDataTruncationResult(s,
1:             "values (cast('abc' as varchar(2)), cast('de'   as varchar(2)))," +
1:             "       (cast('fg'  as varchar(2)), cast('hi'   as varchar(2)))," +
1:             "       (cast('jkl' as varchar(2)), cast('mnop' as varchar(2)))");
1:         checkDataTruncationResult(s,
1:             "values (cast('abc' as clob(2)), cast('de'   as clob(2)))," +
1:             "       (cast('fg'  as clob(2)), cast('hi'   as clob(2)))," +
1:             "       (cast('jkl' as clob(2)), cast('mnop' as clob(2)))");
1: 
1:         // Exact same test as above for binary data
1:         checkDataTruncationResult(s,
1:             "values (cast(x'abcdef' as char(2) for bit data),"+
1:             "        cast(x'abcd' as char(2) for bit data))," +
1:             "       (cast(x'abcd' as char(2) for bit data)," +
1:             "        cast(x'cdef' as char(2) for bit data))," +
1:             "       (cast(x'012345' as char(2) for bit data)," +
1:             "        cast(x'6789ABCD' as char(2) for bit data))");
1:         checkDataTruncationResult(s,
1:             "values (cast(x'abcdef' as varchar(2) for bit data),"+
1:             "        cast(x'abcd' as varchar(2) for bit data))," +
1:             "       (cast(x'abcd' as varchar(2) for bit data)," +
1:             "        cast(x'cdef' as varchar(2) for bit data))," +
1:             "       (cast(x'012345' as varchar(2) for bit data)," +
1:             "        cast(x'6789ABCD' as varchar(2) for bit data))");
1:         checkDataTruncationResult(s,
1:             "values" +
1:             "    (cast(x'abcdef' as blob(2)), cast(x'abcd' as blob(2))), " +
1:             "    (cast(x'abcd' as blob(2)),   cast(x'cdef' as blob(2))), " +
1:             "    (cast(x'012345' as blob(2)), cast(x'6789ABCD' as blob(2)))");
1: 
1:         // DataTruncation's javadoc says that getDataSize() and
1:         // getTransferSize() should return number of bytes. Derby uses
1:         // UTF-8. Test with some characters outside the US-ASCII range to
1:         // verify that the returned values are in bytes and not in chars.
1:         ResultSet rs = s.executeQuery(
1:                 "values cast('abc\u00E6\u00F8\u00E5' as varchar(4))");
1:         assertTrue(rs.next());
1:         assertEquals("abc\u00E6", rs.getString(1));
1:         // The warning should say the string is truncated from 9 bytes to
1:         // 5 bytes, not from 6 characters to 4 characters.
1:         assertDataTruncation(rs.getWarnings(), -1, true, false, 9, 5);
1:         assertFalse(rs.next());
1:         rs.close();
1: 
1:         // Test that there's a warning on the statement if truncation happens
1:         // in an operation that doesn't return a ResultSet.
1:         setAutoCommit(false);
1:         s.execute("create table t1_d129 (x8 char(8) for bit data)");
1:         s.execute("create table t2_d129 (x4 char(4) for bit data)");
1:         s.execute("insert into t1_d129(x8) values x'0123456789ABCDEF'");
1:         assertNull(s.getWarnings());
1:         s.execute("insert into t2_d129(x4) " +
1:                   "select cast(x8 as char(4) for bit data) from t1_d129");
1:         assertDataTruncation(s.getWarnings(), -1, true, false, 8, 4);
1:         rollback();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Check the results for the queries in testDataTruncation().
1:      * </p>
1:      *
1:      * <p>
1:      * The method expects a query that returns three rows with columns of a
1:      * character string or binary string data type, where some of the values
1:      * are cast to a narrower data type.
1:      * </p>
1:      *
1:      * <p>
1:      * Expect the following truncations to have taken place:
1:      * </p>
1:      *
1:      * <ol>
1:      * <li>Row 1, column 1: truncated from 3 to 2 bytes</li>
1:      * <li>Row 3, column 1: truncated from 3 to 2 bytes</li>
1:      * <li>Row 3, column 2: truncated from 4 to 2 bytes</li>
1:      * </ol>
1:      */
1:     private void checkDataTruncationResult(Statement s, String sql)
1:             throws SQLException {
1:         ResultSet rs = s.executeQuery(sql);
1: 
1:         // First row should have one warning (column 1)
1:         assertTrue(rs.next());
1:         SQLWarning w = rs.getWarnings();
1:         assertDataTruncation(w, -1, true, false, 3, 2);
1:         w = w.getNextWarning();
1:         assertNull(w);
1:         rs.clearWarnings(); // workaround for DERBY-5765
1: 
1:         // Second row should have no warnings
1:         assertTrue(rs.next());
1:         assertNull(rs.getWarnings());
1: 
1:         // Third row should have two warnings (column 1 and 2)
1:         assertTrue(rs.next());
1:         w = rs.getWarnings();
1:         assertDataTruncation(w, -1, true, false, 3, 2);
1:         // Client driver doesn't support nested warnings
1:         if (usingEmbedded()) {
1:             w = w.getNextWarning();
1:             assertDataTruncation(w, -1, true, false, 4, 2);
1:         }
1:         w = w.getNextWarning();
1:         assertNull(w);
1:         rs.clearWarnings(); // workaround for DERBY-5765
1: 
1:         // No more rows
1:         assertFalse(rs.next());
1:         rs.close();
1: 
1:         // There should be no warnings on the statement or the connection
1:         assertNull(s.getWarnings());
1:         assertNull(getConnection().getWarnings());
1:     }
1: 
1:     private void assertDataTruncation(
1:             SQLWarning w, int index, boolean read, boolean parameter,
1:             int dataSize, int transferSize) throws SQLException {
1:         assertNotNull("No warning", w);
1:         if (!(w instanceof DataTruncation)) {
1:             fail("Not a DataTruncation warning", w);
1:         }
1: 
1:         DataTruncation dt = (DataTruncation) w;
1:         assertEquals("Column index", index, dt.getIndex());
1:         assertEquals("Read", read, dt.getRead());
1:         assertEquals("Parameter", parameter, dt.getParameter());
1:         assertEquals("Data size", dataSize, dt.getDataSize());
1:         assertEquals("Transfer size", transferSize, dt.getTransferSize());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Create a test suite with all the tests in this class. Although we're
1:      * testing embedded functionality, also run the test in client/server
1:      * mode to ensure that warnings and errors travel across the wire.
1:         return TestConfiguration.defaultSuite(CastingTest.class);
commit:a2567fa
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Statement scb = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement scb = createStatement();
1:                         String convertString = getCompatibleString(sourceType,
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                         String convertString = getCompatibleString(sourceType,
1:                         String query =
1:                             "VALUES CAST (CAST (" + convertString + " AS "
1:                         ResultSet rs = s.executeQuery(query);
1:                         rs.close();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement scb = createStatement();
/////////////////////////////////////////////////////////////////////////
1:                 ResultSet rs = scb.executeQuery(compareSQL);
1:                 rs.close();
/////////////////////////////////////////////////////////////////////////
1:                         String convertString = getCompatibleString(sourceType,
/////////////////////////////////////////////////////////////////////////
1:                         ResultSet rs = scb.executeQuery(compareSQL);
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement scb = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         super.tearDown();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ca48ab4
/////////////////////////////////////////////////////////////////////////
1:     public static final boolean n = false;
/////////////////////////////////////////////////////////////////////////
1: /* 0 SMALLINT */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1: /* 1 INTEGER  */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1: /* 2 BIGINT   */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1: /* 3 DECIMAL  */        { X, X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n },
1: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 6 CHAR     */        { X, X, X, X, n, n, X, X, X, n, n, n, X, X, X, X, n },
1: /* 7 VARCHAR  */        { X, X, X, X, n, n, X, X, X, n, n, n, X, X, X, X, n },
1: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, X },
1: /* 12 CLOB         */   { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, n, n },
1: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, n, n },
1: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, X },
/////////////////////////////////////////////////////////////////////////
1: /* 0 SMALLINT */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 1 INTEGER  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 2 BIGINT   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 3 DECIMAL  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 6 CHAR     */        { n, n, n, n, n, n, X, X, X, n, n, n, X, X, X, X, n },
1: /* 7 VARCHAR  */        { n, n, n, n, n, n, X, X, X, n, n, n, X, X, X, X, n },
1: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, X, X, X, n, n, n, n, n },
1: /* 12 CLOB         */   { n, n, n, n, n, n, X, X, X, n, n, n, X, n, n, n, n },
1: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, n, n },
1: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, n, n },
1: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, n, X, n },
1: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, X },
/////////////////////////////////////////////////////////////////////////
1: /* 0 SMALLINT */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 1 INTEGER  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 2 BIGINT   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 3 DECIMAL  */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 4 REAL     */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 5 DOUBLE   */        { X, X, X, X, X, X, n, n, n, n, n, n, n, n, n, n, n },
1: /* 6 CHAR     */        { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1: /* 7 VARCHAR  */        { n, n, n, n, n, n, X, X, n, n, n, n, n, X, X, X, n },
1: /* 8 LONGVARCHAR */     { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1: /* 9 CHAR FOR BIT */    { n, n, n, n, n, n, n, n, n, X, X, n, n, n, n, n, n },
1: /* 10 VARCH. BIT   */   { n, n, n, n, n, n, n, n, n, X, X, n, n, n, n, n, n },
1: /* 11 LONGVAR. BIT */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
1: /* 12 CLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
0: /* 13 DATE         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, X, n, n, n },
0: /* 14 TIME         */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, X, n, n },
1: /* 15 TIMESTAMP    */   { n, n, n, n, n, n, X, X, n, n, n, n, n, n, n, X, n },
1: /* 16 BLOB         */   { n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n, n },
commit:1292a7f
/////////////////////////////////////////////////////////////////////////
1:         new TypedColumn( "booleanCol", "boolean", true ),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3210ebc
/////////////////////////////////////////////////////////////////////////
1:         int expectedDataTypeCount = LEGAL_BOOLEAN_CASTS.length + ILLEGAL_BOOLEAN_CASTS.length;
1:         // getTypeInfo() also returns a row for the generic OBJECT data type
1:         expectedDataTypeCount++;
1: 
1:                       expectedDataTypeCount,
commit:07d1108
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     public static final class TypedColumn
1:     {
1:         public String columnName;
1:         public String typeName;
1:         public boolean comparable; // true except for long, non-indexable data types
1: 
1:             public TypedColumn( String columnName, String typeName, boolean comparable )
1:         {
1:             this.columnName = columnName;
1:             this.typeName = typeName;
1:             this.comparable = comparable;
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     private static final TypedColumn[] LEGAL_BOOLEAN_CASTS = new TypedColumn[]
1:     {
1:         new TypedColumn( "charCol", "char( 5 )", true ),
1:         new TypedColumn( "varcharCol", "varchar( 5 )", true ),
1:         new TypedColumn( "longVarcharCol", "long varchar", false ),
1:         new TypedColumn( "clobCol", "clob", false ),
1:     };
1:     
1:     private static final TypedColumn[] ILLEGAL_BOOLEAN_CASTS = new TypedColumn[]
1:     {
1:         new TypedColumn( "bigintCol", "bigint", true ),
1:         new TypedColumn( "blobCol", "blob", false ),
1:         new TypedColumn( "charForBitDataCol", "char( 5 ) for bit data", true ),
1:         new TypedColumn( "dateCol", "date", true ),
1:         new TypedColumn( "decimalCol", "decimal", true ),
1:         new TypedColumn( "doubleCol", "double", true ),
1:         new TypedColumn( "floatCol", "float", true ),
1:         new TypedColumn( "integerCol", "integer", true ),
1:         new TypedColumn( "longVarcharForBitDataCol", "long varchar for bit data", false ),
1:         new TypedColumn( "numericCol", "numeric", true ),
1:         new TypedColumn( "realCol", "real", true ),
1:         new TypedColumn( "smallintCol", "smallint", true ),
1:         new TypedColumn( "timeCol", "time", true ),
1:         new TypedColumn( "timestampCol", "timestamp", true ),
1:         new TypedColumn( "varcharForBitDataCol", "varchar( 5 ) for bit data", true ),
1:         new TypedColumn( "xmlCol", "xml", false ),
1:     };
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that DERBY-887 is fixed.
1:      */
1:     public void test_derby887() throws Exception
1:     {
1:         goodStatement
1:             (
1:              "create table t_887 (a int)\n"
1:              );
1: 
1:         expectError
1:             (
1:              LANG_NOT_COMPARABLE_SQLSTATE,
1:              "select * from t_887 where a=0<3\n"
1:              );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Verify that the legal boolean casts work as expected. This
1:      * test helps verify that DERBY-887 is fixed. Verifies the following:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Implicit casts of BOOLEAN to legal types.</li>
1:      * <li>Implicit casts of legal types to BOOLEAN.</li>
1:      * <li>Explicit casts of BOOLEAN to legal types.</li>
1:      * </ul>
1:      *
1:      * <p>
1:      * The following can't be tested until the BOOLEAN type is re-enabled:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Explicit casts of legal types to BOOLEAN.</li>
1:      * </ul>
1:      */
1:     public void test_legalBooleanCasts() throws Exception
1:     {
1:         //
1:         // This assertion will fail if a new Derby data type is added. To
1:         // silence this assertion, you must add the new data type
1:         // to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS.
1:         //
1:         assertAllTypesCovered();
1: 
1:         int  legalTypeCount = LEGAL_BOOLEAN_CASTS.length;
1:         String  tableName = "t_legal_boolean_casts";
1:         // create a table whose columns are all the legal datatypes
1:         makeTableForCasts( tableName, LEGAL_BOOLEAN_CASTS );
1: 
1:         // now test the implicit casting of boolean to all of the legal
1:         // types by inserting a boolean value into all of the columns
1:         // of the table
1:         goodStatement
1:             (
1:              "insert into " + tableName + "\n" +
1:              "( " + makeColumnList( LEGAL_BOOLEAN_CASTS ) + " )\n" +
1:              "select " + makeRepeatedColumnList( "c.isIndex", LEGAL_BOOLEAN_CASTS.length ) + "\n" +
1:              "from\n" +
1:              "  sys.sysconglomerates c,\n" +
1:              "  sys.systables t\n" +
1:              "where t.tablename='SYSTABLES'\n" +
1:              "and t.tableid = c.tableid\n" +
1:              "and not c.isIndex\n"
1:              );
1:         // test that all of the inserted values are false
1:         assertBooleanResults
1:             (
1:              "select * from " + tableName + "\n",
1:              false,
1:              1
1:              );
1: 
1:         // now try implicitly casting the legal types to boolean by
1:         // trying to compare the values in the table to a boolean value.
1:         // we only expect this to succeed for short, indexable data types.
1:         // the long data types cannot be compared
1:         for ( int i = 0; i < legalTypeCount; i++ )
1:         {
1:             TypedColumn tc = LEGAL_BOOLEAN_CASTS[ i ];
1: 
1:             String queryText =
1:                 "select count(*)\n" +
1:                 "from\n" +
1:                 "  sys.sysconglomerates c,\n" +
1:                 "  sys.systables t,\n" +
1:                 "  " + tableName + " tt\n" +
1:                 "where t.tablename='SYSTABLES'\n" +
1:                 "and t.tableid = c.tableid\n" +
1:                 "and not c.isIndex\n" +
1:                 "and tt." + tc.columnName + " = c.isIndex\n";
1: 
1:             if ( tc.comparable ) { assertScalarResult( queryText, 1 ); }
1:             else { expectError( LANG_NOT_COMPARABLE_SQLSTATE, queryText ); }
1:         }
1: 
1:         // now try explicitly casting a boolean value to all of the legal types
1:         assertBooleanResults
1:             (
1:              "select\n" +
1:              makeCastedColumnList( "c.isIndex", LEGAL_BOOLEAN_CASTS ) +
1:              "\nfrom\n" +
1:              "  sys.sysconglomerates c,\n" +
1:              "  sys.systables t\n" +
1:              "where t.tablename='SYSTABLES'\n" +
1:              "and t.tableid = c.tableid\n" +
1:              "and not c.isIndex\n",
1:              false,
1:              1
1:              );
1: 
1:         //
0:         // The following assertion will fail after the BOOLEAN data type is
0:         // re-enabled. At that time, the assertion should be removed and
0:         // replaced with tests to verify the explicit casting of legal types to BOOLEAN.
1:         //
0:         assertNoBoolean();
1:     }
1:     private void makeTableForCasts( String tableName, TypedColumn[] columns )
1:         throws Exception
1:     {
1:         StringBuffer buffer = new StringBuffer();
1:         int  count = columns.length;
1: 
1:         buffer.append( "create table " + tableName + "\n(\n" );
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             buffer.append( "\t" );
1:             if ( i > 0 ) { buffer.append( ", " ); }
1: 
1:             TypedColumn tc = columns[ i ];
1: 
1:             buffer.append( tc.columnName + "\t" + tc.typeName + "\n"  );
1:         }
1:         buffer.append( ")\n" );
1:         
1:         goodStatement( buffer.toString() );
1:     }
1:     // make a comma-separated list of column names
1:     private String makeColumnList( TypedColumn[] columns )
1:     {
1:         StringBuffer buffer = new StringBuffer();
1:         int  count = columns.length;
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
1:             buffer.append( columns[ i ].columnName  );
1:         }
1: 
1:         return buffer.toString();
1:     }
1:     // make a comma-separated list of a column casted to various target types
1:     private String makeCastedColumnList( String columnName, TypedColumn[] targetTypes )
1:     {
1:         StringBuffer buffer = new StringBuffer();
1:         int  count = targetTypes.length;
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
1:             buffer.append( "cast ( " + columnName + " as " + targetTypes[ i ].typeName + " )" );
1:         }
1: 
1:         return buffer.toString();
1:     }
1:     // make a comma-separated list of N copies of a column
1:     private String makeRepeatedColumnList( String columnName, int N )
1:     {
1:         StringBuffer buffer = new StringBuffer();
1: 
1:         for ( int i = 0; i < N; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
1:             buffer.append( columnName  );
1:         }
1: 
1:         return buffer.toString();
1:     }
1:     // assert that all result columns have the given boolean value
1:     private void assertBooleanResults( String queryText, boolean expectedValue, int expectedRowCount )
1:         throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( queryText );
1:         ResultSet rs = ps.executeQuery();
1:         int actualRowCount = 0;
1:         int columnCount = rs.getMetaData().getColumnCount();
1:         String expectedStringValue = Boolean.toString( expectedValue );
1: 
1:         while ( rs.next() )
1:         {
1:             actualRowCount++;
1: 
1:             for ( int i = 0; i < columnCount; i++ )
1:             {
1:                 assertEquals( "Column " + i, expectedStringValue, rs.getString( i + 1 ).trim() );
1:             }
1:         }
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         assertEquals( expectedRowCount, actualRowCount );
1:     }
1:     // assert a scalar result
1:     private void assertScalarResult( String queryText, int expectedValue ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( queryText );
1:         ResultSet rs = ps.executeQuery();
1: 
1:         rs.next();
1:         assertEquals( expectedValue, rs.getInt( 1 ) );
1: 
1:         rs.close();
1:         ps.close();
1:     }
0:     // assert that the BOOLEAN type has not been re-enabled
0:     private void assertNoBoolean() throws Exception
1:     {
0:         println( "Testing whether the BOOLEAN data type has been re-enabled." );
1:         
1:         Connection conn = getConnection();
1:         DatabaseMetaData dbmd = conn.getMetaData();
1:         ResultSet rs = dbmd.getTypeInfo();
1: 
1:         while ( rs.next() )
1:         {
0:             assertFalse( rs.getString( 1 ), java.sql.Types.BOOLEAN == rs.getInt( 2 ) );
1:         }
1: 
1:         rs.close();
1:     }
1:     // assert that we are testing the casting behavior of BOOLEANs to and from
1:     // all Derby data types
1:     private void assertAllTypesCovered() throws Exception
1:     {
1:         println( "Verify that we are testing the casting behavior of BOOLEAN to/from all Derby data types." );
1:         
1:         Connection conn = getConnection();
1:         DatabaseMetaData dbmd = conn.getMetaData();
1:         ResultSet rs = dbmd.getTypeInfo();
1:         int count = 0;
1: 
1:         while ( rs.next() ) { count++; }
1: 
1:         assertEquals( "You must add your new data type to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS",
0:                       LEGAL_BOOLEAN_CASTS.length + ILLEGAL_BOOLEAN_CASTS.length,
1:                       count );
1:         
1:         rs.close();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Verify that the illegal boolean casts work as expected. This
1:      * test helps verify that DERBY-887 is fixed. Verifies the
1:      * following:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Implicit casts of BOOLEAN to illegal types.</li>
1:      * <li>Implicit casts of illegal types to BOOLEAN.</li>
1:      * <li>Explicit casts of BOOLEAN to illegal types.</li>
1:      * </ul>
1:      *
1:      * <p>
1:      * The following can't be tested until the BOOLEAN type is re-enabled:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>Explicit casts of illegal types to BOOLEAN.</li>
1:      * </ul>
1:      */
1:     public void test_illegalBooleanCasts() throws Exception
1:     {
1:         //
1:         // This assertion will fail if a new Derby data type is added. To
1:         // silence this assertion, you must add the new data type
1:         // to LEGAL_BOOLEAN_CASTS or ILLEGAL_BOOLEAN_CASTS.
1:         //
1:         assertAllTypesCovered();
1:         
1:         int  illegalTypeCount = ILLEGAL_BOOLEAN_CASTS.length;
1:         String  tableName = "t_illegal_boolean_casts";
1:         // create a table whose columns are all the illegal datatypes
1:         makeTableForCasts( tableName, ILLEGAL_BOOLEAN_CASTS );
1: 
1:         // use inserts to test implicit casts of boolean to the illegal types
1:         for ( int i = 0; i < illegalTypeCount; i++ )
1:         {
1:             TypedColumn tc = ILLEGAL_BOOLEAN_CASTS[ i ];
1:             expectError
1:                 (
1:                  LANG_NOT_STORABLE_SQLSTATE,
1:                  "insert into " + tableName + "( " + tc.columnName + " ) select c.isIndex from sys.sysconglomerates c\n"
1:                  );
1:         }
1: 
1:         // test implicit casts of illegal types to boolean
1:         for ( int i = 0; i < illegalTypeCount; i++ )
1:         {
1:             TypedColumn tc = ILLEGAL_BOOLEAN_CASTS[ i ];
1:             expectError
1:                 (
1:                  LANG_NOT_COMPARABLE_SQLSTATE,
1:                  "select * from " + tableName + " t, sys.sysconglomerates c where t." + tc.columnName + " = c.isIndex\n"
1:                  );
1:         }
1:         
1:         // test explicit casts of boolean to illegal types
1:         for ( int i = 0; i < illegalTypeCount; i++ )
1:         {
1:             TypedColumn[] castedColumnList = new TypedColumn[] { ILLEGAL_BOOLEAN_CASTS[ i ] };
1:             expectError
1:                 (
1:                  ILLEGAL_CAST_EXCEPTION_SQLSTATE,
1:                  "select " + makeCastedColumnList( "c.isIndex", castedColumnList ) + " from sys.sysconglomerates c\n"
1:                  );
1:         }
1:         
1:         //
0:         // The following assertion will fail after the BOOLEAN data type is
0:         // re-enabled. At that time, the assertion should be removed and
0:         // replaced with tests to verify the explicit casting of illegal types to BOOLEAN.
1:         //
0:         assertNoBoolean();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Run good DDL.
1:      * @throws SQLException 
1:      */
1:     private void    goodStatement( String ddl ) throws SQLException
1:     {
1:             PreparedStatement    ps = chattyPrepare( ddl );
1: 
1:             ps.execute();
1:             ps.close();
1:     }
1:     
1:     /**
1:      * Assert that the statement text, when compiled, raises an exception
1:      */
1:     private void    expectError( String sqlState, String query )
1:     {
1:         println( "\nExpecting " + sqlState + " when preparing:\n\t" + query );
1: 
1:         assertCompileError( sqlState, query );
1:     }
1:     
1:     /**
1:      * Prepare a statement and report its sql text.
1:      */
1:     private PreparedStatement   chattyPrepare( String text )
1:         throws SQLException
1:     {
1:         println( "Preparing statement:\n\t" + text );
1:         
1:         return prepareStatement( text );
1:     }
1: 
1:     /**
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1cf00e6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SQLUtilities;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:             String typeName = SQLUtilities.SQLTypes[type];
/////////////////////////////////////////////////////////////////////////
1:             for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
/////////////////////////////////////////////////////////////////////////
1:             for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:                 String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:             String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
1:                         String targetTypeName = SQLUtilities.SQLTypes[targetType];
/////////////////////////////////////////////////////////////////////////
1:                                 + SQLUtilities.SQLTypes[sourceType] + ") AS "
1:                                 + SQLUtilities.SQLTypes[targetType] + " )";
/////////////////////////////////////////////////////////////////////////
1:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
/////////////////////////////////////////////////////////////////////////
1:             for (int sourceType = 0; sourceType < SQLUtilities.SQLTypes.length; sourceType++) {
1:                 String sourceTypeName = SQLUtilities.SQLTypes[sourceType];
1:                 for (int targetType = 0; targetType < SQLUtilities.SQLTypes.length; targetType++) {
/////////////////////////////////////////////////////////////////////////
1:         for (int type = 0; type < SQLUtilities.SQLTypes.length; type++) {
1:             String typeName = SQLUtilities.SQLTypes[type];
/////////////////////////////////////////////////////////////////////////
1:         String typeName = SQLUtilities.SQLTypes[type];
/////////////////////////////////////////////////////////////////////////
1:         String description = " Cast from " + SQLUtilities.SQLTypes[sourceType] + " to "
1:                 + SQLUtilities.SQLTypes[targetType];
1:         String description = " Assignment from " + SQLUtilities.SQLTypes[sourceType]
1:                 + " to " + SQLUtilities.SQLTypes[targetType];
/////////////////////////////////////////////////////////////////////////
1:         String description = " Comparison of " + SQLUtilities.SQLTypes[sourceType] + " to "
1:                 + SQLUtilities.SQLTypes[targetType];
commit:9230159
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
1:     public static int[] jdbcTypes = {
1:         java.sql.Types.SMALLINT,
1:         java.sql.Types.INTEGER,
1:         java.sql.Types.BIGINT,
1:         java.sql.Types.DECIMAL,
1:         java.sql.Types.REAL,
1:         java.sql.Types.DOUBLE,
1:         java.sql.Types.CHAR,
1:         java.sql.Types.VARCHAR,
1:         java.sql.Types.LONGVARCHAR,
1:         java.sql.Types.BINARY,
1:         java.sql.Types.VARBINARY,
1:         java.sql.Types.LONGVARBINARY,
1:         java.sql.Types.CLOB,
1:         java.sql.Types.DATE,
1:         java.sql.Types.TIME,
1:         java.sql.Types.TIMESTAMP,
1:         java.sql.Types.BLOB
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
1:                         ResultSetMetaData rsmd = rs.getMetaData();
1:                         assertEquals(rsmd.getColumnType(1), jdbcTypes[targetType]);
commit:aa53134
/////////////////////////////////////////////////////////////////////////
0:     // Note: This array is accessed in lang.NullIfTest
/////////////////////////////////////////////////////////////////////////
1:     // Note: This table is referenced in NullIfTest.java
commit:6d94ad6
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CastingTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
commit:0bcd16d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.tools.JDBCDisplayUtil;
1: /**
0:  * @author kmarsden
1:  *
1:  */
/////////////////////////////////////////////////////////////////////////
1:    /*
1:     * explicitCastValues is a table of expected values for the testExplicitCasts fixture
1:     * System.out.print statements in testExplicitCast were used to generate this table
1:     * and  remain in comments in testExplicitCasts in case it needs to be regenerated.
1:     */ 
1:     private static final String[][] explicitCastValues = {
1:     /*SMALLINT*/ {"0","0","0","0.00000","0.0","0.0","0                                                           ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*INTEGER*/ {"11","11","11","11.00000","11.0","11.0","11                                                          ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*BIGINT*/ {"22","22","22","22.00000","22.0","22.0","22                                                          ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*DECIMAL(10,5)*/ {"3","3","3","3.30000","3.3","3.3","3.30000                                                     ","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*REAL*/ {"4","4","4","4.40000","4.4","4.400000095367432","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*DOUBLE*/ {"5","5","5","5.50000","5.5","5.5","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception"},
1:     /*CHAR(60)*/ {"0","11","22","3.30000","Exception","Exception","7                                                           ","8                                                           ","9                                                           ","Exception","Exception","Exception","13                                                          ","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:     /*VARCHAR(60)*/ {"0","11","22","3.30000","Exception","Exception","7                                                           ","8","9","Exception","Exception","Exception","13","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:     /*LONG VARCHAR*/ {"Exception","Exception","Exception","Exception","Exception","Exception","7                                                           ","8","9","Exception","Exception","Exception","13","Exception","Exception","Exception","Exception"},
1:     /*CHAR(60) FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10cc20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","Exception","Exception","Exception","Exception","01dd20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020"},
1:     /*VARCHAR(60) FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb","10cc","Exception","Exception","Exception","Exception","01dd"},
1:     /*LONG VARCHAR FOR BIT DATA*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","10aa20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020","10bb","10cc","Exception","Exception","Exception","Exception","01dd"},
1:     /*CLOB(1k)*/ {"Exception","Exception","Exception","Exception","Exception","Exception","13                                                          ","13","13","Exception","Exception","Exception","13","Exception","Exception","Exception","Exception"},
0:     /*DATE*/ {"Exception","Exception","Exception","Exception","Exception","Exception","2000-01-01                                                  ","2000-01-01","Exception","Exception","Exception","Exception","Exception","2000-01-01","Exception","Exception","Exception"},
0:     /*TIME*/ {"Exception","Exception","Exception","Exception","Exception","Exception","15:30:20                                                    ","15:30:20","Exception","Exception","Exception","Exception","Exception","Exception","15:30:20","Exception","Exception"},
1:     /*TIMESTAMP*/ {"Exception","Exception","Exception","Exception","Exception","Exception","2000-01-01 15:30:20.0                                       ","2000-01-01 15:30:20.0","Exception","Exception","Exception","Exception","Exception","2000-01-01","15:30:20","2000-01-01 15:30:20.0","Exception"},
1:     /*BLOB(1k)*/ {"Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","Exception","01dd"}
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:         scb.close();
0:         conn.commit();
1:     }
1: 
1:     public void testAssignments() throws SQLException {
1: 
0:         Connection conn = getConnection();
1: 
0:         Statement scb = conn.createStatement();
0:         ResultSet rs = null;
1: 
1:      
/////////////////////////////////////////////////////////////////////////
1:             //System.out.print("/*" + sourceTypeName + "*/ {");
/////////////////////////////////////////////////////////////////////////
1:                         rs.next();
1:                         String val = rs.getString(1);
1:                         if (dataOffset == 0)
1:                             assertNull(val);
1:                         else
1:                         {
1:                             //System.out.print("\"" + val + "\"");
0:                             assertEquals(val,explicitCastValues[sourceType][targetType]);
1:                         }
1:                         if (dataOffset != 0)
1:                         {
1:                             //System.out.print("\"Exception\"");
1:                         }
1:                     /*
1:                     if (dataOffset > 0)
1:                         if (targetType == SQLTypes.length -1)
1:                             System.out.println("},");
1:                         else 
1:                             System.out.print(",");
1:                      */
1: 
/////////////////////////////////////////////////////////////////////////
1:                 //JDBC.assertDrainResults(rs);
1:                 // should return 1 row
1:                 assertTrue(rs.next());
/////////////////////////////////////////////////////////////////////////
1:                     
1:                         
commit:fffce91
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: public class CastingTest extends BaseJDBCTestCase {
1: 
1:     public CastingTest(String name) {
1:         super(name);
1: 
1:     }
1:     public static String VALID_DATE_STRING = "'2000-01-01'";
1:     public static String VALID_TIME_STRING = "'15:30:20'";
1:     public static String VALID_TIMESTAMP_STRING = "'2000-01-01 15:30:20'";
1:     public static String NULL_VALUE="NULL";
1: 
1:     public static String ILLEGAL_CAST_EXCEPTION_SQLSTATE = "42846";
1:     public static String LANG_NOT_STORABLE_SQLSTATE  = "42821";
1:     public static String LANG_NOT_COMPARABLE_SQLSTATE = "42818";
1:     public static String METHOD_NOT_FOUND_SQLSTATE = "42884";
1:     public static String LANG_FORMAT_EXCEPTION_SQLSTATE = "22018";
1: 
1:     public static int SQLTYPE_ARRAY_SIZE = 17 ;
1:     public static int SMALLINT_OFFSET = 0;
1:     public static int INTEGER_OFFSET = 1;
1:     public static int BIGINT_OFFSET = 2;
1:     public static int DECIMAL_OFFSET = 3;
1:     public static int REAL_OFFSET = 4;
1:     public static int DOUBLE_OFFSET = 5;
1:     public static int CHAR_OFFSET = 6;
1:     public static int VARCHAR_OFFSET = 7;
1:     public static int LONGVARCHAR_OFFSET = 8;
1:     public static int CHAR_FOR_BIT_OFFSET = 9;
1:     public static int VARCHAR_FOR_BIT_OFFSET = 10;
1:     public static int LONGVARCHAR_FOR_BIT_OFFSET = 11;
1:     public static int CLOB_OFFSET = 12;
1:     public static int DATE_OFFSET = 13;
1:     public static int TIME_OFFSET = 14;
1:     public static int TIMESTAMP_OFFSET = 15;
1:     public static int BLOB_OFFSET = 16;
1: 
1: 
0:     public static String[] SQLTypes =
0:     {
0:             "SMALLINT",
0:             "INTEGER",
0:             "BIGINT",
0:             "DECIMAL(10,5)",
0:             "REAL",
0:             "DOUBLE",
0:             "CHAR(60)",
0:             "VARCHAR(60)",
0:             "LONG VARCHAR",
0:             "CHAR(60) FOR BIT DATA",
0:             "VARCHAR(60) FOR BIT DATA",
0:             "LONG VARCHAR FOR BIT DATA",
0:             "CLOB(1k)",
0:             "DATE",
0:             "TIME",
0:             "TIMESTAMP",
0:             "BLOB(1k)",
1:     };
1: 
1: 
1:     public static int NULL_DATA_OFFSET = 0;  // offset of NULL value
1:     public static int VALID_DATA_OFFSET = 1;  // offset of NULL value
1: 
1:     // rows are data types.
1:     // data is NULL_VALUE, VALID_VALUE
1:     // Should add Minimum, Maximum and out of range.
1: public static String[][]SQLData =
0:     {
1:             {NULL_VALUE, "0"},       // SMALLINT
1:             {NULL_VALUE,"11"},       // INTEGER
1:             {NULL_VALUE,"22"},       // BIGINT
1:             {NULL_VALUE,"3.3"},      // DECIMAL(10,5)
1:             {NULL_VALUE,"4.4"},      // REAL,
1:             {NULL_VALUE,"5.5"},      // DOUBLE
1:             {NULL_VALUE,"'7'"},      // CHAR(60)
1:             {NULL_VALUE,"'8'"},      //VARCHAR(60)",
1:             {NULL_VALUE,"'9'"},      // LONG VARCHAR
1:             {NULL_VALUE,"X'10aa'"},  // CHAR(60)  FOR BIT DATA
1:             {NULL_VALUE,"X'10bb'"},  // VARCHAR(60) FOR BIT DATA
1:             {NULL_VALUE,"X'10cc'"},  //LONG VARCHAR FOR BIT DATA
1:             {NULL_VALUE,"'13'"},     //CLOB(1k)
1:             {NULL_VALUE,VALID_DATE_STRING},        // DATE
1:             {NULL_VALUE,VALID_TIME_STRING},        // TIME
1:             {NULL_VALUE,VALID_TIMESTAMP_STRING},   // TIMESTAMP
1:             {NULL_VALUE,"X'01dd'"}                 // BLOB
1:     };
1: 
1: 
1: 
1: 
0:     public static final boolean _ = false;
1:     public static final boolean X = true;
1: 
1:     /**
1:        Table 146 - Supported explicit casts between Built-in DataTypes
1: 
1:        This table has THE FOR BIT DATA TYPES broken out into separate columns
1:        for clarity and testing
1:     **/
1: 
1: 
1:     public static final boolean[][]  T_146 = {
1:             
0: //Types.                 S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
0: //                    M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
0: //                    A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
0: //                    L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
0: //                    L  G  N  M     L     H  V  .  H  V           S
0: //                    I  E  T  A     E     A  A  B  .  A           T
0: //                    N  R     L           R  R  I  B  R           A
0: //                    T                       C  T  I  .           M
0: //                                            H     T  B           P
0: //                                            A        I
0: //                                            R        T
0: /* 0 SMALLINT */        { X, X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _ },
0: /* 1 INTEGER  */        { X, X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _ },
0: /* 2 BIGINT   */        { X, X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _ },
0: /* 3 DECIMAL  */        { X, X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _ },
0: /* 4 REAL     */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 5 DOUBLE   */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 6 CHAR     */        { X, X, X, X, _, _, X, X, X, _, _, _, X, X, X, X, _ },
0: /* 7 VARCHAR  */        { X, X, X, X, _, _, X, X, X, _, _, _, X, X, X, X, _ },
0: /* 8 LONGVARCHAR */     { _, _, _, _, _, _, X, X, X, _, _, _, X, _, _, _, _ },
0: /* 9 CHAR FOR BIT */    { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, X },
0: /* 10 VARCH. BIT   */   { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, X },
0: /* 11 LONGVAR. BIT */   { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, X },
0: /* 12 CLOB         */   { _, _, _, _, _, _, X, X, X, _, _, _, X, _, _, _, _ },
0: /* 13 DATE         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, X, _, _, _ },
0: /* 14 TIME         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, _, X, _, _ },
0: /* 15 TIMESTAMP    */   { _, _, _, _, _, _, X, X, _, _, _, _, _, X, X, X, _ },
0: /* 16 BLOB         */   { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, X },
1: 
1:     };
1: 
1:     /**
1:      * Table 147 describes  Data Type Compatibility for Assignments 
1:      *
1:      * The table 147a covers the assignments as they do differ somewhat 
1:      *  from comparisons which can be found in 147b
1:      *
1:      **/
1: 
1:     public static final boolean[][]  T_147a = {
1:             
0: //Types.                S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
0: //                   M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
0: //                   A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
0: //                   L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
0: //                   L  G  N  M     L     H  V  .  H  V           S
0: //                   I  E  T  A     E     A  A  B  .  A           T
0: //                   N  R     L           R  R  I  B  R           A
0: //                   T                       C  T  I  .           M
0: //                                           H     T  B           P
0: //                                           A        I
0: //                                              R        T
0: /* 0 SMALLINT */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 1 INTEGER  */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 2 BIGINT   */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 3 DECIMAL  */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 4 REAL     */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 5 DOUBLE   */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 6 CHAR     */        { _, _, _, _, _, _, X, X, X, _, _, _, X, X, X, X, _ },
0: /* 7 VARCHAR  */        { _, _, _, _, _, _, X, X, X, _, _, _, X, X, X, X, _ },
0: /* 8 LONGVARCHAR */     { _, _, _, _, _, _, X, X, X, _, _, _, X, _, _, _, _ },
0: /* 9 CHAR FOR BIT */    { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, _ },
0: /* 10 VARCH. BIT   */   { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, _ },
0: /* 11 LONGVAR. BIT */   { _, _, _, _, _, _, _, _, _, X, X, X, _, _, _, _, _ },
0: /* 12 CLOB         */   { _, _, _, _, _, _, X, X, X, _, _, _, X, _, _, _, _ },
0: /* 13 DATE         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, X, _, _, _ },
0: /* 14 TIME         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, _, X, _, _ },
0: /* 15 TIMESTAMP    */   { _, _, _, _, _, _, X, X, _, _, _, _, _, _, _, X, _ },
0: /* 16 BLOB         */   { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, X },
1: 
1:     };
1: 
1: 
1:     // Comparisons table
1:     // Comparison's are different than assignments because
1:     // Long types cannot be compared.
1:     public static final boolean[][]  T_147b = {
1:             
0: //Types.                 S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
0: //                    M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
0: //                    A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
0: //                    L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
0: //                    L  G  N  M     L     H  V  .  H  V           S
0: //                    I  E  T  A     E     A  A  B  .  A           T
0: //                    N  R     L           R  R  I  B  R           A
0: //                    T                       C  T  I  .           M
0: //                                            H     T  B           P
0: //                                            A        I
0: //                                            R        T
0: /* 0 SMALLINT */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 1 INTEGER  */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 2 BIGINT   */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 3 DECIMAL  */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 4 REAL     */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 5 DOUBLE   */        { X, X, X, X, X, X, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 6 CHAR     */        { _, _, _, _, _, _, X, X, _, _, _, _, _, X, X, X, _ },
0: /* 7 VARCHAR  */        { _, _, _, _, _, _, X, X, _, _, _, _, _, X, X, X, _ },
0: /* 8 LONGVARCHAR */     { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 9 CHAR FOR BIT */    { _, _, _, _, _, _, _, _, _, X, X, _, _, _, _, _, _ },
0: /* 10 VARCH. BIT   */   { _, _, _, _, _, _, _, _, _, X, X, _, _, _, _, _, _ },
0: /* 11 LONGVAR. BIT */   { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 12 CLOB         */   { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ },
0: /* 13 DATE         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, X, _, _, _ },
0: /* 14 TIME         */   { _, _, _, _, _, _, X, X, _, _, _, _, _, _, X, _, _ },
0: /* 15 TIMESTAMP    */   { _, _, _, _, _, _, X, X, _, _, _, _, _, _, _, X, _ },
0: /* 16 BLOB         */   { _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _ },
1: 
1: 
1: };
1: 
1:     protected void setUp() throws SQLException {
0:         Connection conn = getConnection();
0:         Statement scb = conn.createStatement();
1: 
0:         for (int type = 0; type < SQLTypes.length; type++) {
0:             String typeName = SQLTypes[type];
1:             String tableName = getTableName(type);
1: 
1:             String createSQL = "create table " + tableName + " (c " + typeName
1:                     + " )";
1: 
1:             scb.executeUpdate(createSQL);
1:         }
1: 
1:         scb.close();
0:         conn.commit();
1:     }
1: 
0:     public void testAssignments() throws SQLException {
1: 
0:         Connection conn = getConnection();
1: 
0:         Statement scb = conn.createStatement();
0:         ResultSet rs = null;
1: 
1:         // * testing literal inserts
1: 
1:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
0:             for (int type = 0; type < SQLTypes.length; type++) {
1:                 try {
1:                     String tableName = getTableName(type);
1: 
1:                     String insertSQL = "insert into " + tableName + " values( "
1:                             + SQLData[type][dataOffset] + ")";
1:                     scb.executeUpdate(insertSQL);
1:                 } catch (SQLException se) {
1:                     // literal inserts are ok for everything but BLOB
1:                     if (type != BLOB_OFFSET)
1:                         throw se;
1:                     
1:                 }
1:             }
1:         // Try to insert each sourceType into the targetType table
1:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
0:             for (int sourceType = 0; sourceType < SQLTypes.length; sourceType++) {
0:                 String sourceTypeName = SQLTypes[sourceType];
0:                 for (int targetType = 0; targetType < SQLTypes.length; targetType++) {
1:                     try {
1:                         String convertString = null;
1:                         String targetTableName = getTableName(targetType);
1: 
1:                         // For assignments Character types use strings that can
1:                         // be converted to the targetType.
0:                         convertString = getCompatibleString(sourceType,
1:                                 targetType, dataOffset);
1: 
1:                         String insertValuesString = " VALUES CAST("
1:                                 + convertString + " AS " + sourceTypeName + ")";
1: 
1:                         String insertSQL = "INSERT INTO " + targetTableName
1:                                 + insertValuesString;
1:                         // System.out.println(insertSQL);
1:                         scb.executeUpdate(insertSQL);
1:                         checkSupportedAssignment(sourceType, targetType);
1: 
1:                     } catch (SQLException se) {
1:                         String sqlState = se.getSQLState();
1:                         assertTrue(!isSupportedAssignment(sourceType, targetType)
1:                                 && isNotStorableException(se)
1:                                 || isCastException(se));
1:                     }
1:                 }
1:             }
1: 
1:         scb.close();
0:         conn.commit();
0:         conn.close();
1: 
1:     }
1: 
1:     public void testExplicitCasts() throws SQLException {
1: 
0:         Connection conn = getConnection();
0:         Statement s = conn.createStatement();
0:         ResultSet rs = null;
1: 
1:         // Try Casts from each type to the
0:         for (int sourceType = 0; sourceType < SQLTypes.length; sourceType++) {
1: 
0:             String sourceTypeName = SQLTypes[sourceType];
1:             for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
0:                 for (int targetType = 0; targetType < SQLTypes.length; targetType++) {
0:                     String query = null;
1:                     try {
1:                         String convertString = null;
0:                         String targetTypeName = SQLTypes[targetType];
1:                         // For casts from Character types use strings that can
1:                         // be converted to the targetType.
1: 
0:                         convertString = getCompatibleString(sourceType,
1:                                 targetType, dataOffset);
1: 
0:                         query = "VALUES CAST (CAST (" + convertString + " AS "
0:                                 + SQLTypes[sourceType] + ") AS "
0:                                 + SQLTypes[targetType] + " )";
0:                         rs = s.executeQuery(query);
1:                         JDBC.assertDrainResults(rs);
1:                         checkSupportedCast(sourceType, targetType);
1:                     } catch (SQLException se) {
1:                         String sqlState = se.getSQLState();
1:                         if (!isSupportedCast(sourceType, targetType)) {
1:                             assertTrue(isCastException(se));
1:                         } else
1:                             throw se;
1:                     }
1:                 }
1:         }
1: 
0:         conn.commit();
1: 
1:     }
1: 
1:     public void testComparisons() throws SQLException {
1: 
0:         Connection conn = getConnection();
0:         Statement scb = conn.createStatement();
0:         ResultSet rs = null;
1: 
1:         // Comparison's using literals
1: 
0:         for (int type = 0; type < SQLTypes.length; type++) {
1:             try {
1:                 int dataOffset = 1; // don't use null values
1:                 String tableName = getTableName(type);
1: 
1:                 String compareSQL = "SELECT distinct c FROM " + tableName
1:                         + " WHERE c = " + SQLData[type][dataOffset];
1: 
0:                 rs = scb.executeQuery(compareSQL);
1:                 JDBC.assertDrainResults(rs);
1:             } catch (SQLException se) {
1:                 // literal comparisons are ok for everything but Lob and long
1:                 assertTrue(isLongType(type));
1:             }
1:         }
1: 
1:         // Try to compare each sourceType with the targetType
1:         for (int dataOffset = 0; dataOffset < SQLData[0].length; dataOffset++)
0:             for (int sourceType = 0; sourceType < SQLTypes.length; sourceType++) {
0:                 String sourceTypeName = SQLTypes[sourceType];
0:                 for (int targetType = 0; targetType < SQLTypes.length; targetType++) {
1:                     try {
1:                         String convertString = null;
1:                         String targetTableName = getTableName(targetType);
1: 
1:                         // For assignments Character types use strings that can
1:                         // be converted to the targetType.
0:                         convertString = getCompatibleString(sourceType,
1:                                 targetType, dataOffset);
1: 
1:                         // Make sure table has just compatible data
1:                         scb.executeUpdate("DELETE FROM " + targetTableName);
1:                         String insertValuesString = " VALUES CAST("
1:                                 + convertString + " AS " + sourceTypeName + ")";
1: 
1:                         String insertSQL = "INSERT INTO " + targetTableName
1:                                 + insertValuesString;
1: 
1:                         String compareSQL = "select c from " + targetTableName
1:                                 + " WHERE c = CAST(" + convertString + " AS "
1:                                 + sourceTypeName + ")";
1: 
0:                         // System.out.println(compareSQL);
0:                         rs = scb.executeQuery(compareSQL);
1:                         JDBC.assertDrainResults(rs);
0:                         // JDBCDisplayUtil.DisplayResults(System.out,rs,conn);
1:                         checkSupportedComparison(sourceType, targetType);
1: 
1:                     } catch (SQLException se) {
1:                         String sqlState = se.getSQLState();
1:                         assertTrue(!isSupportedComparison(sourceType, targetType)
1:                                 && isNotComparableException(se)
1:                                 || isCastException(se));
1:                        
1:                     }
1:                 }
1:             }
1:         scb.close();
0:         conn.commit();
1: 
1:     }
1: 
1:     protected void tearDown() throws SQLException, Exception {
0:         super.tearDown();
0:         Connection conn = getConnection();
0:         Statement scb = conn.createStatement();
1: 
0:         for (int type = 0; type < SQLTypes.length; type++) {
0:             String typeName = SQLTypes[type];
1:             String tableName = getTableName(type);
1: 
1:             String dropSQL = "drop table " + tableName;
1: 
1:             scb.executeUpdate(dropSQL);
1:         }
1: 
1:         scb.close();
0:         conn.commit();
0:         conn.close();
1:     }
1: 
1:     /**
1:      * Build a unique table name from the type
1:      * 
1:      * @param type
1:      *            table offset
1:      * @return Table name in format <TYPE>_TAB. Replaces ' ' _;
1:      */
1:     private static String getTableName(int type) {
1:         return getShortTypeName(type).replace(' ', '_') + "_TAB";
1: 
1:     }
1: 
1:     /**
1:      * Truncates (*) from typename
1:      * 
1:      * @param type -
1:      *            Type offset
1:      * 
1:      * @return short name of type (e.g DECIMAL instead of DECIMAL(10,5)
1:      */
1: 
1:     private static String getShortTypeName(int type) {
0:         String typeName = SQLTypes[type];
1:         String shortName = typeName;
1:         int parenIndex = typeName.indexOf('(');
1:         if (parenIndex >= 0) {
1:             shortName = typeName.substring(0, parenIndex);
1:             int endParenIndex = typeName.indexOf(')');
1:             shortName = shortName
1:                     + typeName.substring(endParenIndex + 1, typeName.length());
1:         }
1:         return shortName;
1: 
1:     }
1: 
1:     private static String getCompatibleString(int sourceType, int targetType,
1:             int dataOffset) {
1:         String convertString = null;
1:         // for string and binary types use the target data string
1:         // so that the cast will work
1:         if ((isCharacterType(sourceType) || isBinaryType(sourceType))
1:                 && !isLob(sourceType))
1:             convertString = formatString(SQLData[targetType][dataOffset]);
1:         else
1:             convertString = SQLData[sourceType][dataOffset];
1: 
1:         return convertString;
1:     }
1: 
1:     private static boolean isSupportedCast(int sourceType, int targetType) {
1:         return T_146[sourceType][targetType];
1:     }
1: 
1:     private static boolean isSupportedAssignment(int sourceType, int targetType) {
1:         return T_147a[sourceType][targetType];
1:     }
1: 
1:     private static boolean isSupportedComparison(int sourceType, int targetType) {
1:         return T_147b[sourceType][targetType];
1:     }
1: 
1:     private static boolean isCastException(SQLException se) {
1:         return sqlStateMatches(se, ILLEGAL_CAST_EXCEPTION_SQLSTATE);
1:     }
1: 
1:     private static boolean isMethodNotFoundException(SQLException se) {
1:         return sqlStateMatches(se, METHOD_NOT_FOUND_SQLSTATE);
1:     }
1: 
1:     private static boolean sqlStateMatches(SQLException se, String expectedValue) {
1:         String sqlState = se.getSQLState();
1:         if ((sqlState != null) && (sqlState.equals(expectedValue)))
1:             return true;
1:         return false;
1:     }
1: 
1:     private static boolean isNotStorableException(SQLException se) {
1:         String sqlState = se.getSQLState();
1:         if ((sqlState != null) && (sqlState.equals(LANG_NOT_STORABLE_SQLSTATE)))
1:             return true;
1:         return false;
1: 
1:     }
1: 
1:     private static boolean isNotComparableException(SQLException se) {
1:         String sqlState = se.getSQLState();
1:         if ((sqlState != null)
1:                 && (sqlState.equals(LANG_NOT_COMPARABLE_SQLSTATE)))
1:             return true;
1:         return false;
1:     }
1: 
1:     private static void checkSupportedCast(int sourceType, int targetType) {
0:         String description = " Cast from " + SQLTypes[sourceType] + " to "
0:                 + SQLTypes[targetType];
1: 
1:         if (!isSupportedCast(sourceType, targetType))
1:             fail(description + "should not succeed");
1:     }
1: 
1:     private static void checkSupportedAssignment(int sourceType, int targetType) {
0:         String description = " Assignment from " + SQLTypes[sourceType]
0:                 + " to " + SQLTypes[targetType];
1: 
1:         if (!isSupportedAssignment(sourceType, targetType))
1:             fail(description + "should not succeed");
1: 
1:     }
1: 
1:     private static void checkSupportedComparison(int sourceType, int targetType) {
0:         String description = " Comparison of " + SQLTypes[sourceType] + " to "
0:                 + SQLTypes[targetType];
1: 
1:         if (!isSupportedComparison(sourceType, targetType))
1:             fail("FAIL: unsupported comparison:" + description);
1:     }
1: 
1:     private static boolean isLongType(int typeOffset) {
1:         return ((typeOffset == LONGVARCHAR_OFFSET)
1:                 || (typeOffset == LONGVARCHAR_FOR_BIT_OFFSET)
1:                 || (typeOffset == CLOB_OFFSET) || (typeOffset == BLOB_OFFSET));
1:     }
1: 
1:     private static boolean isCharacterType(int typeOffset) {
1:         return ((typeOffset == CHAR_OFFSET) || (typeOffset == VARCHAR_OFFSET)
1:                 || (typeOffset == LONGVARCHAR_OFFSET) || (typeOffset == CLOB_OFFSET));
1:     }
1: 
1:     private static boolean isBinaryType(int typeOffset) {
1:         return ((typeOffset == CHAR_FOR_BIT_OFFSET)
1:                 || (typeOffset == VARCHAR_FOR_BIT_OFFSET)
1:                 || (typeOffset == LONGVARCHAR_FOR_BIT_OFFSET) || (typeOffset == BLOB_OFFSET));
1:     }
1: 
0:     private static boolean isDateTimeTimestamp(int typeOffset) {
0:         return ((typeOffset == DATE_OFFSET) || (typeOffset == TIME_OFFSET) || (typeOffset == TIMESTAMP_OFFSET));
1: 
1:     }
1: 
0:     private static boolean isClob(int typeOffset) {
0:         return (typeOffset == CLOB_OFFSET);
1:     }
1: 
1:     private static boolean isLob(int typeOffset) {
1:         return ((typeOffset == CLOB_OFFSET) || (typeOffset == BLOB_OFFSET));
1: 
1:     }
1: 
1:     // Data is already a string (starts with X, or a character string,
1:     // just return, otherwise bracket with ''s
1:     private static String formatString(String str) {
1:         if ((str != null)
1:                 && (str.startsWith("X") || str.startsWith("'") || (str == NULL_VALUE)))
1:             return str;
1:         else
1:             return "'" + str + "'";
1:     }
1: 
0:     private static Test suite() {
1: 
0:         return TestConfiguration.defaultSuite(CastingTest.class);
1: 
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c7f3642
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Testing server-side behaviour so run in embedded only.
1:      */
0:         return TestConfiguration.embeddedSuite(CastingTest.class);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Army
-------------------------------------------------------------------------------
commit:5e9a335
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite() {
============================================================================