1:eac0369: /*
1:d7258ed: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.FdocaConstants
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
11:eac0369: 
2:eac0369:  */
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:db4c995: import java.sql.SQLException;
1:eac0369: import java.sql.Types;
1:90731d5: import org.apache.derby.iapi.reference.DRDAConstants;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:eac0369: 
1:eac0369: class FdocaConstants
2:90731d5: {
1:90731d5:   //
1:90731d5:   // This is where DRDA FD:OCA constants used to live. They were removed
1:90731d5:   // because they were not referenced anywhere.
1:90731d5:   //
1:eac0369: 
1:eac0369:   static final int CPT_TRIPLET_TYPE = 0x7F;      // CPT triplet type
1:eac0369:   static final int MDD_TRIPLET_TYPE = 0x78;      // MDD triplet type
1:eac0369:   static final int NGDA_TRIPLET_TYPE = 0x76;     // N-GDA triplet type
1:eac0369:   static final int RLO_TRIPLET_TYPE = 0x71;      // RLO triplet type
1:eac0369:   static final int SDA_TRIPLET_TYPE = 0x70;      // SDA triplet type
1:eac0369: 
1:eac0369:   static final int SDA_MD_TYPE = 1;              // SDA MD type
1:eac0369:   static final int GDA_MD_TYPE = 2;              // GDA MD type
1:eac0369:   static final int ROW_MD_TYPE = 3;              // Row MD type
1:eac0369: 
1:eac0369:   static final int SQLCADTA_LID = 0xE0;
1:eac0369:   static final int SQLDTAGRP_LID = 0xD0;         // SQLDTAGRP LID
1:eac0369:   static final int NULL_LID = 0x00;
1:eac0369: 
1:eac0369:   static final int INDICATOR_NULLABLE = 0x00;
1:eac0369:   static final int NULL_DATA = 0xFF;
1:eac0369:   static final int TYP_NULLIND = 1;
1:eac0369:   static final int MAX_ENV_LID = 0x49;           // Largest possible N-GDA/CPT repeating
1:eac0369: 
1:eac0369:   static final int MAX_VARS_IN_NGDA = 84;        // Number of SQLVARs in full SQLDTAGRP
1:eac0369:                                                  // N-GDA or CPT
1:eac0369:   static final int FULL_NGDA_SIZE = 255;         // Size of full SQLDTAGRP N-GDA or CPT
1:eac0369:   static final int MDD_TRIPLET_SIZE = 7;         // Size of MDD triplet
1:eac0369:   static final int SDA_TRIPLET_SIZE = 12;        // Size of SDA triplet
1:eac0369:   static final int SQLDTA_RLO_SIZE = 6;          // Size of SQLDTA RLO triplet
1:eac0369:   static final int RLO_RPT_GRP_SIZE = 3;         // Size of RLO repeating group
1:eac0369:   static final int SQLDTAGRP_SIZE = 3;           // Size of SQLDTAGRP descriptor
1:eac0369:   static final int CPT_SIZE = 3;                 // Size of CPT descriptor
1:eac0369:   static final int FDODSC_FOOTER_SIZE = 6;       // Size of regular FDODSC "footer" (RLO)
1:eac0369:   static final int SQLDTAGRP_COL_DSC_SIZE = 3;   // Env. LID & len. bytes
1:eac0369:   static final int MAX_OVERRIDES = 250;          // Max nbr of overrides via pairs of MDD + SDA
1:eac0369:   static final int MDD_REST_SIZE = 5;            // Size of the MDD group minus length and type
1:eac0369: 
1:eac0369:   // Hard-coded SQLCADTA MDD
1:eac0369:   static final byte[] SQLCADTA_MDD = {
1:eac0369:     (byte)0x07, (byte)0x78, (byte)0x00,
1:eac0369:     (byte)0x05, (byte)0x03, (byte)0x01,
1:eac0369:     (byte)0xE0
1:eac0369:   };
1:eac0369: 
1:eac0369:   // Hard-coded SQLDTA MDD
1:eac0369:   static final byte[] SQLDTA_MDD = {
1:eac0369:     (byte)0x07, (byte)0x78, (byte)0x00,
1:eac0369:     (byte)0x05, (byte)0x04, (byte)0x01,
1:eac0369:     (byte)0xF0
1:eac0369:   };
1:eac0369: 
1:eac0369:   // Hard-coded SQLDTA MDD
1:eac0369:   static final byte[] SQLDTAGRP_MDD = {
1:eac0369:     (byte)0x07, (byte)0x78, (byte)0x00,
1:eac0369:     (byte)0x05, (byte)0x02, (byte)0x01,
1:eac0369:     (byte)0xD0
1:eac0369:   };
1:eac0369: 
1:eac0369:   // Hard-coded SQLCADTA+SQLDTARD footer bytes
1:eac0369:   static final byte[] SQLCADTA_SQLDTARD_RLO = {
1:eac0369:     (byte)0x09, (byte)0x71, (byte)0xE0,   // SQLCADTA
1:eac0369:     (byte)0x54, (byte)0x00, (byte)0x01,
1:eac0369:     (byte)0xD0, (byte)0x00, (byte)0x01,
1:eac0369:     (byte)0x06, (byte)0x71, (byte)0xF0,   // SQLDTARD
1:eac0369:     (byte)0xE0, (byte)0x00, (byte)0x00
1:eac0369:   };
1:eac0369: 
1:eac0369:   // Hard-coded SQLDTA RLO
1:eac0369:   static final byte[] SQLDTA_RLO = {
1:eac0369:     (byte)0x06, (byte)0x71, (byte)0xE4,
1:eac0369:     (byte)0xD0, (byte)0x00, (byte)0x01
1:eac0369:   };
1:eac0369: 
1:eac0369:   static final int SQLCADTA_SQLDTARD_RLO_SIZE = SQLCADTA_SQLDTARD_RLO.length;
1:eac0369: 
1:4f996a4:     protected static boolean isNullable(int fdocaType)
1:4f996a4:     {
1:4f996a4:         return ( (fdocaType & 1) == 1);
1:4f996a4:     }
1:eac0369: 
1:4f996a4:     // The maxumum length for LONG VARCHAR RETURN RESULTS IS
1:4f996a4:     // 64K, since we send an unsigned short.  We should be
1:4f996a4:     // able to send the number of bytes in which we encode the
1:4f996a4:     // length as 4 (or more) , but JCC does not support this yet.
1:4f996a4:     // JAVA_OBJECTS are returned as LONG VARCHAR values by calling
1:4f996a4:     // their toString() method and their limit is 64K as well.
1:4f996a4:     // BUT, that said, we ultimately have to match DB2's limit,
1:4f996a4:     // so just use that...
1:4f996a4:     protected static int LONGVARCHAR_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:4f996a4:     protected static int LONGVARBINARY_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:4f996a4:     protected static int LONGVARCHAR_LEN_NUMBYTES = 2;
1:eac0369: 
1:4f996a4:     // JCC  only supports a max precision of 31 like DB2
1:4f996a4:     protected static int NUMERIC_MAX_PRECISION=31;
1:4f996a4:     protected static int NUMERIC_DEFAULT_PRECISION=NUMERIC_MAX_PRECISION;
1:4f996a4:     protected static int NUMERIC_DEFAULT_SCALE=15;
1:eac0369: 
1:4f996a4:     /***
1:4f996a4:      * Map jdbctype to fdoca drda type
1:4f996a4:      * @param jdbcType - Jdbc type for mappingy
1:4f996a4:      * @param nullable - true if type is nullable
1:4f996a4:      * @param appRequester - state variable for the connection
1:4f996a4:      * @param outlen - output parameter with length of type.
1:4f996a4:      * @return standard drdaTypeLength. -1 if we don't know.
1:4f996a4:      **/
1:4f996a4:     protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable, AppRequester appRequester,
1:4f996a4:                                                int[] outlen)
1:4f996a4:         throws SQLException
1:4f996a4:     {
1:4f996a4:         int drdaType = 0;
1:4f996a4:         switch (jdbcType) {
1:4f996a4:             case Types.BOOLEAN:
1:eff3919:                 if ( appRequester.supportsBooleanValues() )
1:eff3919:                 {
1:eff3919:                     drdaType = DRDAConstants.DRDA_TYPE_NBOOLEAN;
1:eff3919:                     outlen[0] = 1;
1:eff3919:                 }
1:eff3919:                 else
1:eff3919:                 {
1:eff3919:                     drdaType = DRDAConstants.DRDA_TYPE_NSMALL;
1:eff3919:                     outlen[0] = 2;
1:eff3919:                 }
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.BIT:
1:4f996a4:             case java.sql.Types.TINYINT:
1:4f996a4:             case java.sql.Types.SMALLINT:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NSMALL;
1:4f996a4:                 outlen[0] = 2;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.INTEGER:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NINTEGER;
1:4f996a4:                 outlen[0] = 4;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.BIGINT:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NINTEGER8;
1:4f996a4:                 outlen[0] = 8;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.REAL:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NFLOAT4;
1:4f996a4:                 outlen[0] = 4;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.DOUBLE:
1:4f996a4:             case java.sql.Types.FLOAT:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NFLOAT8;
1:4f996a4:                 outlen[0] = 8;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.NUMERIC:
1:4f996a4:             case java.sql.Types.DECIMAL:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NDECIMAL;
1:4f996a4:                 //needs to be adjusted for actual value
1:4f996a4:                 outlen[0] = -1;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.DATE:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NDATE;
1:4f996a4:                 outlen[0] = 10;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.TIME:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NTIME;
1:4f996a4:                 outlen[0] = 8;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.TIMESTAMP:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NTIMESTAMP;
1:4f996a4:                 outlen[0] = appRequester.getTimestampLength();
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.CHAR:
1:db9a013: //              drdaType = DRDAConstants.DRDA_TYPE_NCHAR;
1:4f996a4:                 //making this NVARMIX for now to handle different byte length
1:4f996a4:                 //characters - checking with Paul to see if this is the
1:4f996a4:                 //correct way to handle it.
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NVARMIX;
1:4f996a4:                 outlen[0] = -1;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.VARCHAR:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NVARCHAR;
1:4f996a4:                 outlen[0] = -1;
1:4f996a4:                 break;
1:4f996a4:                 // we will just convert a java object to a string
1:4f996a4:                 // since jcc doesn't support it.
1:4f996a4:             case java.sql.Types.JAVA_OBJECT:
1:506f4c8:                 //boolean b = false;
1:506f4c8:                 //if ( b )
1:506f4c8:                 if ( appRequester.supportsUDTs() )
1:506f4c8:                 {
1:506f4c8:                     drdaType = DRDAConstants.DRDA_TYPE_NUDT;
1:506f4c8:                     outlen[0] = -1;
1:506f4c8:                 }
1:506f4c8:                 else
1:506f4c8:                 {
1:506f4c8:                     drdaType = DRDAConstants.DRDA_TYPE_NLONG;
1:506f4c8:                     outlen[0] = LONGVARCHAR_MAX_LEN;
1:506f4c8:                 }
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.LONGVARCHAR:
1:4f996a4:                     drdaType = DRDAConstants.DRDA_TYPE_NLONG;
1:4f996a4:                     outlen[0] = LONGVARCHAR_MAX_LEN;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.BINARY:
1:4f996a4:             case java.sql.Types.VARBINARY:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NVARBYTE;
1:4f996a4:                 outlen[0] = -1;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.LONGVARBINARY:
1:4f996a4:                     drdaType = DRDAConstants.DRDA_TYPE_NLONGVARBYTE;
1:4f996a4:                     outlen[0] = LONGVARBINARY_MAX_LEN;
1:4f996a4:                 break;
1:4f996a4:                 // blob begin
1:4f996a4:                 // merge BLOB and BLOB_LOCATOR ????
1:4f996a4:             case java.sql.Types.BLOB:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NLOBBYTES;
1:4f996a4:                 // indicates fdocadata is a place holder with 4 byte length
1:4f996a4:                 outlen[0] = 0x8004;
1:4f996a4:                 break;
1:4f996a4:             case java.sql.Types.CLOB:
1:4f996a4:                 drdaType = DRDAConstants.DRDA_TYPE_NLOBCMIXED;
1:4f996a4:                 outlen[0] = 0x8004;
1:4f996a4:                 break;
1:4f996a4:                 // blob end
1:4f996a4:             case java.sql.Types.ARRAY:
1:4f996a4:             case java.sql.Types.DISTINCT:
1:4f996a4:             case java.sql.Types.NULL:
1:4f996a4:             case java.sql.Types.OTHER:
1:4f996a4:             case java.sql.Types.REF:
1:4f996a4:             case java.sql.Types.STRUCT:
1:4f996a4:                 throw new SQLException("Jdbc type" + jdbcType + "not Supported yet");
1:4f996a4:             default:
1:4f996a4:                 throw new SQLException ("unrecognized sql type: " + jdbcType);
1:4f996a4:         }
1:90731d5: 
1:4f996a4:         if (!nullable)
1:4f996a4:             drdaType--;
1:4f996a4:         return drdaType;
1:4f996a4:     }
1:90731d5: 
1:90731d5: 
2:90731d5: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1: //              drdaType = DRDAConstants.DRDA_TYPE_NCHAR;
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     protected static boolean isNullable(int fdocaType)
1:     {
1:         return ( (fdocaType & 1) == 1);
1:     }
1:     // The maxumum length for LONG VARCHAR RETURN RESULTS IS
1:     // 64K, since we send an unsigned short.  We should be
1:     // able to send the number of bytes in which we encode the
1:     // length as 4 (or more) , but JCC does not support this yet.
1:     // JAVA_OBJECTS are returned as LONG VARCHAR values by calling
1:     // their toString() method and their limit is 64K as well.
1:     // BUT, that said, we ultimately have to match DB2's limit,
1:     // so just use that...
1:     protected static int LONGVARCHAR_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:     protected static int LONGVARBINARY_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
1:     protected static int LONGVARCHAR_LEN_NUMBYTES = 2;
1:     // JCC  only supports a max precision of 31 like DB2
1:     protected static int NUMERIC_MAX_PRECISION=31;
1:     protected static int NUMERIC_DEFAULT_PRECISION=NUMERIC_MAX_PRECISION;
1:     protected static int NUMERIC_DEFAULT_SCALE=15;
1:     /***
1:      * Map jdbctype to fdoca drda type
1:      * @param jdbcType - Jdbc type for mappingy
1:      * @param nullable - true if type is nullable
1:      * @param appRequester - state variable for the connection
1:      * @param outlen - output parameter with length of type.
1:      * @return standard drdaTypeLength. -1 if we don't know.
1:      **/
1:     protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable, AppRequester appRequester,
1:                                                int[] outlen)
1:         throws SQLException
1:     {
1:         int drdaType = 0;
1:         switch (jdbcType) {
1:             case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1:                 break;
1:             case java.sql.Types.BIT:
1:             case java.sql.Types.TINYINT:
1:             case java.sql.Types.SMALLINT:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NSMALL;
1:                 outlen[0] = 2;
1:                 break;
1:             case java.sql.Types.INTEGER:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NINTEGER;
1:                 outlen[0] = 4;
1:                 break;
1:             case java.sql.Types.BIGINT:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NINTEGER8;
1:                 outlen[0] = 8;
1:                 break;
1:             case java.sql.Types.REAL:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NFLOAT4;
1:                 outlen[0] = 4;
1:                 break;
1:             case java.sql.Types.DOUBLE:
1:             case java.sql.Types.FLOAT:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NFLOAT8;
1:                 outlen[0] = 8;
1:                 break;
1:             case java.sql.Types.NUMERIC:
1:             case java.sql.Types.DECIMAL:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NDECIMAL;
1:                 //needs to be adjusted for actual value
1:                 outlen[0] = -1;
1:                 break;
1:             case java.sql.Types.DATE:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NDATE;
1:                 outlen[0] = 10;
1:                 break;
1:             case java.sql.Types.TIME:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NTIME;
1:                 outlen[0] = 8;
1:                 break;
1:             case java.sql.Types.TIMESTAMP:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NTIMESTAMP;
1:                 outlen[0] = appRequester.getTimestampLength();
1:                 break;
1:             case java.sql.Types.CHAR:
0: //                drdaType = DRDAConstants.DRDA_TYPE_NCHAR;
1:                 //making this NVARMIX for now to handle different byte length
1:                 //characters - checking with Paul to see if this is the
1:                 //correct way to handle it.
1:                 drdaType = DRDAConstants.DRDA_TYPE_NVARMIX;
1:                 outlen[0] = -1;
1:                 break;
1:             case java.sql.Types.VARCHAR:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NVARCHAR;
1:                 outlen[0] = -1;
1:                 break;
1:                 // we will just convert a java object to a string
1:                 // since jcc doesn't support it.
1:             case java.sql.Types.JAVA_OBJECT:
/////////////////////////////////////////////////////////////////////////
1:                 break;
1:             case java.sql.Types.LONGVARCHAR:
1:                     drdaType = DRDAConstants.DRDA_TYPE_NLONG;
1:                     outlen[0] = LONGVARCHAR_MAX_LEN;
1:                 break;
1:             case java.sql.Types.BINARY:
1:             case java.sql.Types.VARBINARY:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NVARBYTE;
1:                 outlen[0] = -1;
1:                 break;
1:             case java.sql.Types.LONGVARBINARY:
1:                     drdaType = DRDAConstants.DRDA_TYPE_NLONGVARBYTE;
1:                     outlen[0] = LONGVARBINARY_MAX_LEN;
1:                 break;
1:                 // blob begin
1:                 // merge BLOB and BLOB_LOCATOR ????
1:             case java.sql.Types.BLOB:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NLOBBYTES;
1:                 // indicates fdocadata is a place holder with 4 byte length
1:                 outlen[0] = 0x8004;
1:                 break;
1:             case java.sql.Types.CLOB:
1:                 drdaType = DRDAConstants.DRDA_TYPE_NLOBCMIXED;
1:                 outlen[0] = 0x8004;
1:                 break;
1:                 // blob end
1:             case java.sql.Types.ARRAY:
1:             case java.sql.Types.DISTINCT:
1:             case java.sql.Types.NULL:
1:             case java.sql.Types.OTHER:
1:             case java.sql.Types.REF:
1:             case java.sql.Types.STRUCT:
1:                 throw new SQLException("Jdbc type" + jdbcType + "not Supported yet");
1:             default:
1:                 throw new SQLException ("unrecognized sql type: " + jdbcType);
1:         }
1:         if (!nullable)
1:             drdaType--;
1:         return drdaType;
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eff3919
/////////////////////////////////////////////////////////////////////////
1:                 if ( appRequester.supportsBooleanValues() )
1:                 {
1:                     drdaType = DRDAConstants.DRDA_TYPE_NBOOLEAN;
1:                     outlen[0] = 1;
1:                 }
1:                 else
1:                 {
1:                     drdaType = DRDAConstants.DRDA_TYPE_NSMALL;
1:                     outlen[0] = 2;
1:                 }
0: 				break;
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
0: 				outlen[0] = appRequester.getTimestampLength();
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
0: 	 * @param appRequester - state variable for the connection
0: 	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable, AppRequester appRequester,
/////////////////////////////////////////////////////////////////////////
1:                 //boolean b = false;
1:                 //if ( b )
1:                 if ( appRequester.supportsUDTs() )
1:                 {
1:                     drdaType = DRDAConstants.DRDA_TYPE_NUDT;
1:                     outlen[0] = -1;
1:                 }
1:                 else
1:                 {
1:                     drdaType = DRDAConstants.DRDA_TYPE_NLONG;
1:                     outlen[0] = LONGVARCHAR_MAX_LEN;
1:                 }
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
0: 	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable,
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			case Types.BOOLEAN:
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
1:   //
1:   // This is where DRDA FD:OCA constants used to live. They were removed
1:   // because they were not referenced anywhere.
1:   //
/////////////////////////////////////////////////////////////////////////
0: 	protected static int mapJdbcTypeToDrdaType(AppRequester appRequester, int jdbcType, boolean nullable,
0: 		jdbcType = clipJdbcType( appRequester, jdbcType );
0: 				drdaType = DRDAConstants.DRDA_TYPE_NBOOLEAN;
0: 				outlen[0] = 1;
0: 				break;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NSMALL;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NINTEGER;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NINTEGER8;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NFLOAT4;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NFLOAT8;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NDECIMAL;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NDATE;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NTIME;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NTIMESTAMP;
0: //				drdaType = DRDAConstants.DRDA_TYPE_NCHAR;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NVARMIX;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NVARCHAR;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NLONG;
0: 					drdaType = DRDAConstants.DRDA_TYPE_NLONG;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NVARBYTE;
0: 					drdaType = DRDAConstants.DRDA_TYPE_NLONGVARBYTE;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NLOBBYTES;
0: 				drdaType = DRDAConstants.DRDA_TYPE_NLOBCMIXED;
/////////////////////////////////////////////////////////////////////////
0: 	/***
0: 	 * Convert the jdbcType to one which we know how to exchange with
0: 	 * the client. This depends on the version of the client.
0: 	 **/
0: 	protected	static	int	clipJdbcType( AppRequester appRequester, int original )
1: 	{
0: 		switch ( original )
1: 		{
0: 			case JDBC30Translation.BOOLEAN:
1: 
0: 				if ( appRequester.supportsBoolean() ) { return original; }
0: 				else { return java.sql.Types.BIT; }
1: 
0: 		    default:	return original;
1: 		}
1: 
1: 	}
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.FdocaConstants
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: package org.apache.derby.impl.drda;
1: 
1: import java.sql.Types;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import java.sql.SQLException;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: 
1: class FdocaConstants
0: {
0: /**
0:    IBM Copyright &copy notice.
1: */
1: 
0: public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: // DRDA FD:OCA constants.
0:   static final int FDOCA_TYPE_FIXEDBYTES = 0x01;
0:   static final int FDOCA_TYPE_NFIXEDBYTES = 0x81;
0:   static final int FDOCA_TYPE_VARBYTES = 0x02;
0:   static final int FDOCA_TYPE_NVARBYTES = 0x82;
0:   static final int FDOCA_TYPE_NTBYTES = 0x03;
0:   static final int FDOCA_TYPE_NNTBYTES = 0x83;
0:   static final int FDOCA_TYPE_PSCLBYTE = 0x07;
0:   static final int FDOCA_TYPE_NPSCLBYTE = 0x87;
0:   static final int FDOCA_TYPE_FIXEDCHAR = 0x10;
0:   static final int FDOCA_TYPE_NFIXEDCHAR = 0x90;
0:   static final int FDOCA_TYPE_VARCHAR = 0x11;
0:   static final int FDOCA_TYPE_NVARCHAR = 0x91;
0:   static final int FDOCA_TYPE_NTCHAR = 0x14;
0:   static final int FDOCA_TYPE_NNTCHAR = 0x94;
0:   static final int FDOCA_TYPE_PSCLCHAR = 0x19;
0:   static final int FDOCA_TYPE_NPSCLCHAR = 0x99;
0:   static final int FDOCA_TYPE_INTEGER_BE = 0x23;
0:   static final int FDOCA_TYPE_NINTEGER_BE = 0xA3;
0:   static final int FDOCA_TYPE_INTEGER_LE = 0x24;
0:   static final int FDOCA_TYPE_NINTEGER_LE = 0xA4;
0:   static final int FDOCA_TYPE_DECIMAL = 0x30;
0:   static final int FDOCA_TYPE_NDECIMAL = 0xB0;
0:   static final int FDOCA_TYPE_NUMERIC_CHAR = 0x32;
0:   static final int FDOCA_TYPE_NNUMERIC_CHAR = 0xB2;
0:   static final int FDOCA_TYPE_ZDECIMAL_IBM = 0x33;   //370, 390, zOS and 400
0:   static final int FDOCA_TYPE_NZDECIMAL_IBM = 0xB3;  //370, 390, zOS and 400
0:   static final int FDOCA_TYPE_ZDECIMAL = 0x35;
0:   static final int FDOCA_TYPE_NZDECIMAL = 0xB5;
0:   static final int FDOCA_TYPE_FLOAT_370 = 0x40;
0:   static final int FDOCA_TYPE_NFLOAT_370 = 0xC0;
0:   static final int FDOCA_TYPE_FLOAT_X86 = 0x47;
0:   static final int FDOCA_TYPE_NFLOAT_X86 = 0xC7;
0:   static final int FDOCA_TYPE_FLOAT_IEEE = 0x48;   //including 400
0:   static final int FDOCA_TYPE_NFLOAT_IEEE = 0xC8;  //including 400
0:   static final int FDOCA_TYPE_FLOAT_VAX = 0x49;
0:   static final int FDOCA_TYPE_NFLOAT_VAX = 0xC9;
0:   static final int FDOCA_TYPE_LOBBYTES = 0x50;
0:   static final int FDOCA_TYPE_NLOBBYTES = 0xD0;
0:   static final int FDOCA_TYPE_LOBCHAR = 0x51;
0:   static final int FDOCA_TYPE_NLOBCHAR = 0xD1;
1: 
0:   // DRDA Type constants.
0:   static final int DRDA_TYPE_INTEGER = 0x02;
0:   static final int DRDA_TYPE_NINTEGER = 0x03;
0:   static final int DRDA_TYPE_SMALL = 0x04;
0:   static final int DRDA_TYPE_NSMALL = 0x05;
0:   static final int DRDA_TYPE_1BYTE_INT = 0x06;
0:   static final int DRDA_TYPE_N1BYTE_INT = 0x07;
0:   static final int DRDA_TYPE_FLOAT16 = 0x08;
0:   static final int DRDA_TYPE_NFLOAT16 = 0x09;
0:   static final int DRDA_TYPE_FLOAT8 = 0x0A;
0:   static final int DRDA_TYPE_NFLOAT8 = 0x0B;
0:   static final int DRDA_TYPE_FLOAT4 = 0x0C;
0:   static final int DRDA_TYPE_NFLOAT4 = 0x0D;
0:   static final int DRDA_TYPE_DECIMAL = 0x0E;
0:   static final int DRDA_TYPE_NDECIMAL = 0x0F;
0:   static final int DRDA_TYPE_ZDECIMAL = 0x10;
0:   static final int DRDA_TYPE_NZDECIMAL = 0x11;
0:   static final int DRDA_TYPE_NUMERIC_CHAR = 0x12;
0:   static final int DRDA_TYPE_NNUMERIC_CHAR = 0x13;
0:   static final int DRDA_TYPE_RSET_LOC = 0x14;
0:   static final int DRDA_TYPE_NRSET_LOC = 0x15;
0:   static final int DRDA_TYPE_INTEGER8 = 0x16;
0:   static final int DRDA_TYPE_NINTEGER8 = 0x17;
0:   static final int DRDA_TYPE_LOBLOC = 0x18;
0:   static final int DRDA_TYPE_NLOBLOC = 0x19;
0:   static final int DRDA_TYPE_CLOBLOC = 0x1A;
0:   static final int DRDA_TYPE_NCLOBLOC = 0x1B;
0:   static final int DRDA_TYPE_DBCSCLOBLOC = 0x1C;
0:   static final int DRDA_TYPE_NDBCSCLOBLOC = 0x1D;
0:   static final int DRDA_TYPE_ROWID = 0x1E;
0:   static final int DRDA_TYPE_NROWID = 0x1F;
0:   static final int DRDA_TYPE_DATE = 0x20;
0:   static final int DRDA_TYPE_NDATE = 0x21;
0:   static final int DRDA_TYPE_TIME = 0x22;
0:   static final int DRDA_TYPE_NTIME = 0x23;
0:   static final int DRDA_TYPE_TIMESTAMP = 0x24;
0:   static final int DRDA_TYPE_NTIMESTAMP = 0x25;
0:   static final int DRDA_TYPE_FIXBYTE = 0x26;
0:   static final int DRDA_TYPE_NFIXBYTE = 0x27;
0:   static final int DRDA_TYPE_VARBYTE = 0x28;
0:   static final int DRDA_TYPE_NVARBYTE = 0x29;
0:   static final int DRDA_TYPE_LONGVARBYTE = 0x2A;
0:   static final int DRDA_TYPE_NLONGVARBYTE = 0x2B;
0:   static final int DRDA_TYPE_NTERMBYTE = 0x2C;
0:   static final int DRDA_TYPE_NNTERMBYTE = 0x2D;
0:   static final int DRDA_TYPE_CSTR = 0x2E;
0:   static final int DRDA_TYPE_NCSTR = 0x2F;
0:   static final int DRDA_TYPE_CHAR = 0x30;
0:   static final int DRDA_TYPE_NCHAR = 0x31;
0:   static final int DRDA_TYPE_VARCHAR = 0x32;
0:   static final int DRDA_TYPE_NVARCHAR = 0x33;
0:   static final int DRDA_TYPE_LONG = 0x34;
0:   static final int DRDA_TYPE_NLONG = 0x35;
0:   static final int DRDA_TYPE_GRAPHIC = 0x36;
0:   static final int DRDA_TYPE_NGRAPHIC = 0x37;
0:   static final int DRDA_TYPE_VARGRAPH = 0x38;
0:   static final int DRDA_TYPE_NVARGRAPH = 0x39;
0:   static final int DRDA_TYPE_LONGRAPH = 0x3A;
0:   static final int DRDA_TYPE_NLONGRAPH = 0x3B;
0:   static final int DRDA_TYPE_MIX = 0x3C;
0:   static final int DRDA_TYPE_NMIX = 0x3D;
0:   static final int DRDA_TYPE_VARMIX = 0x3E;
0:   static final int DRDA_TYPE_NVARMIX = 0x3F;
0:   static final int DRDA_TYPE_LONGMIX = 0x40;
0:   static final int DRDA_TYPE_NLONGMIX = 0x41;
0:   static final int DRDA_TYPE_CSTRMIX = 0x42;
0:   static final int DRDA_TYPE_NCSTRMIX = 0x43;
0:   static final int DRDA_TYPE_PSCLBYTE = 0x44;
0:   static final int DRDA_TYPE_NPSCLBYTE = 0x45;
0:   static final int DRDA_TYPE_LSTR = 0x46;
0:   static final int DRDA_TYPE_NLSTR = 0x47;
0:   static final int DRDA_TYPE_LSTRMIX = 0x48;
0:   static final int DRDA_TYPE_NLSTRMIX = 0x49;
0:   static final int DRDA_TYPE_SDATALINK = 0x4C;
0:   static final int DRDA_TYPE_NSDATALINK = 0x4D;
0:   static final int DRDA_TYPE_MDATALINK = 0x4E;
0:   static final int DRDA_TYPE_NMDATALINK = 0x4F;
1: 
0:   // --- Override LIDs 0x50 - 0xAF
0:   static final int DRDA_TYPE_LOBBYTES = 0xC8;
0:   static final int DRDA_TYPE_NLOBBYTES = 0xC9;
0:   static final int DRDA_TYPE_LOBCSBCS = 0xCA;
0:   static final int DRDA_TYPE_NLOBCSBCS = 0xCB;
0:   static final int DRDA_TYPE_LOBCDBCS = 0xCC;
0:   static final int DRDA_TYPE_NLOBCDBCS = 0xCD;
0:   static final int DRDA_TYPE_LOBCMIXED = 0xCE;
0:   static final int DRDA_TYPE_NLOBCMIXED = 0xCF;
1: 
1:   static final int CPT_TRIPLET_TYPE = 0x7F;      // CPT triplet type
1:   static final int MDD_TRIPLET_TYPE = 0x78;      // MDD triplet type
1:   static final int NGDA_TRIPLET_TYPE = 0x76;     // N-GDA triplet type
1:   static final int RLO_TRIPLET_TYPE = 0x71;      // RLO triplet type
1:   static final int SDA_TRIPLET_TYPE = 0x70;      // SDA triplet type
1: 
1:   static final int SDA_MD_TYPE = 1;              // SDA MD type
1:   static final int GDA_MD_TYPE = 2;              // GDA MD type
1:   static final int ROW_MD_TYPE = 3;              // Row MD type
1: 
1:   static final int SQLCADTA_LID = 0xE0;
1:   static final int SQLDTAGRP_LID = 0xD0;         // SQLDTAGRP LID
1:   static final int NULL_LID = 0x00;
1: 
1:   static final int INDICATOR_NULLABLE = 0x00;
1:   static final int NULL_DATA = 0xFF;
1:   static final int TYP_NULLIND = 1;
1:   static final int MAX_ENV_LID = 0x49;           // Largest possible N-GDA/CPT repeating
1: 
1:   static final int MAX_VARS_IN_NGDA = 84;        // Number of SQLVARs in full SQLDTAGRP
1:                                                  // N-GDA or CPT
1:   static final int FULL_NGDA_SIZE = 255;         // Size of full SQLDTAGRP N-GDA or CPT
1:   static final int MDD_TRIPLET_SIZE = 7;         // Size of MDD triplet
1:   static final int SDA_TRIPLET_SIZE = 12;        // Size of SDA triplet
1:   static final int SQLDTA_RLO_SIZE = 6;          // Size of SQLDTA RLO triplet
1:   static final int RLO_RPT_GRP_SIZE = 3;         // Size of RLO repeating group
1:   static final int SQLDTAGRP_SIZE = 3;           // Size of SQLDTAGRP descriptor
1:   static final int CPT_SIZE = 3;                 // Size of CPT descriptor
1:   static final int FDODSC_FOOTER_SIZE = 6;       // Size of regular FDODSC "footer" (RLO)
1:   static final int SQLDTAGRP_COL_DSC_SIZE = 3;   // Env. LID & len. bytes
1:   static final int MAX_OVERRIDES = 250;          // Max nbr of overrides via pairs of MDD + SDA
1:   static final int MDD_REST_SIZE = 5;            // Size of the MDD group minus length and type
1: 
1:   // Hard-coded SQLCADTA MDD
1:   static final byte[] SQLCADTA_MDD = {
1:     (byte)0x07, (byte)0x78, (byte)0x00,
1:     (byte)0x05, (byte)0x03, (byte)0x01,
1:     (byte)0xE0
1:   };
1: 
1:   // Hard-coded SQLDTA MDD
1:   static final byte[] SQLDTA_MDD = {
1:     (byte)0x07, (byte)0x78, (byte)0x00,
1:     (byte)0x05, (byte)0x04, (byte)0x01,
1:     (byte)0xF0
1:   };
1: 
1:   // Hard-coded SQLDTA MDD
1:   static final byte[] SQLDTAGRP_MDD = {
1:     (byte)0x07, (byte)0x78, (byte)0x00,
1:     (byte)0x05, (byte)0x02, (byte)0x01,
1:     (byte)0xD0
1:   };
1: 
1:   // Hard-coded SQLCADTA+SQLDTARD footer bytes
1:   static final byte[] SQLCADTA_SQLDTARD_RLO = {
1:     (byte)0x09, (byte)0x71, (byte)0xE0,   // SQLCADTA
1:     (byte)0x54, (byte)0x00, (byte)0x01,
1:     (byte)0xD0, (byte)0x00, (byte)0x01,
1:     (byte)0x06, (byte)0x71, (byte)0xF0,   // SQLDTARD
1:     (byte)0xE0, (byte)0x00, (byte)0x00
1:   };
1: 
1:   // Hard-coded SQLDTA RLO
1:   static final byte[] SQLDTA_RLO = {
1:     (byte)0x06, (byte)0x71, (byte)0xE4,
1:     (byte)0xD0, (byte)0x00, (byte)0x01
1:   };
1: 
1:   static final int SQLCADTA_SQLDTARD_RLO_SIZE = SQLCADTA_SQLDTARD_RLO.length;
1: 
0: 	protected static boolean isNullable(int fdocaType)
0: 	{
0: 		return ( (fdocaType & 1) == 1);
0: 	}
1: 
0: 	// The maxumum length for LONG VARCHAR RETURN RESULTS IS
0: 	// 64K, since we send an unsigned short.  We should be
0: 	// able to send the number of bytes in which we encode the
0: 	// length as 4 (or more) , but JCC does not support this yet.
0: 	// JAVA_OBJECTS are returned as LONG VARCHAR values by calling
0: 	// their toString() method and their limit is 64K as well.
0: 	// BUT, that said, we ultimately have to match DB2's limit,
0: 	// so just use that...
0: 	protected static int LONGVARCHAR_MAX_LEN = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0: 	protected static int LONGVARBINARY_MAX_LEN = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0: 	protected static int LONGVARCHAR_LEN_NUMBYTES = 2;
1: 
0: 	// JCC  only supports a max precision of 31 like DB2
0: 	protected static int NUMERIC_MAX_PRECISION=31;
0: 	protected static int NUMERIC_DEFAULT_PRECISION=NUMERIC_MAX_PRECISION;
0: 	protected static int NUMERIC_DEFAULT_SCALE=15;
1: 
0: 	/***
0: 	 * Map jdbctype to fdoca drda type
0: 	 * @param jdbcType - Jdbc type for mappingy
0: 	 * @param nullable - true if type is nullable
0: 	 * @param outlen - output parameter with length of type.
0: 	 * @return standard drdaTypeLength. -1 if we don't know.
0: 	 **/
0: 	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable,
0: 											   int[] outlen)
0: 		throws SQLException
0: 	{
1: 
0: 		int drdaType = 0;
0: 		switch (jdbcType) {
0: 			case JDBC30Translation.BOOLEAN:
0: 			case java.sql.Types.BIT:
0: 			case java.sql.Types.TINYINT:
0: 			case java.sql.Types.SMALLINT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NSMALL;
0: 				outlen[0] = 2;
0: 				break;
0: 			case java.sql.Types.INTEGER:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NINTEGER;
0: 				outlen[0] = 4;
0: 				break;
0: 			case java.sql.Types.BIGINT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NINTEGER8;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.REAL:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NFLOAT4;
0: 				outlen[0] = 4;
0: 				break;
0: 			case java.sql.Types.DOUBLE:
0: 			case java.sql.Types.FLOAT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NFLOAT8;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.NUMERIC:
0: 			case java.sql.Types.DECIMAL:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NDECIMAL;
0: 				//needs to be adjusted for actual value
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.DATE:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NDATE;
0: 				outlen[0] = 10;
0: 				break;
0: 			case java.sql.Types.TIME:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NTIME;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.TIMESTAMP:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NTIMESTAMP;
0: 				outlen[0] = 26;
0: 				break;
0: 			case java.sql.Types.CHAR:
0: //				drdaType = FdocaConstants.DRDA_TYPE_NCHAR;
0: 				//making this NVARMIX for now to handle different byte length
0: 				//characters - checking with Paul to see if this is the
0: 				//correct way to handle it.
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARMIX;
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.VARCHAR:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARCHAR;
0: 				outlen[0] = -1;
0: 				break;
0: 				// we will just convert a java object to a string
0: 				// since jcc doesn't support it.
0: 			case java.sql.Types.JAVA_OBJECT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLONG;
0: 				outlen[0] = LONGVARCHAR_MAX_LEN;
0: 				break;
0: 			case java.sql.Types.LONGVARCHAR:
0: 					drdaType = DRDA_TYPE_NLONG;
0: 					outlen[0] = LONGVARCHAR_MAX_LEN;
0: 				break;
0: 			case java.sql.Types.BINARY:
0: 			case java.sql.Types.VARBINARY:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARBYTE;
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.LONGVARBINARY:
0: 					drdaType = FdocaConstants.DRDA_TYPE_NLONGVARBYTE;
0: 					outlen[0] = LONGVARBINARY_MAX_LEN;
0: 				break;
0: 				// blob begin
0: 				// merge BLOB and BLOB_LOCATOR ????
0: 			case java.sql.Types.BLOB:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLOBBYTES;
0: 				// indicates fdocadata is a place holder with 4 byte length
0: 				outlen[0] = 0x8004;
0: 				break;
0: 			case java.sql.Types.CLOB:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLOBCMIXED;
0: 				outlen[0] = 0x8004;
0: 				break;
0: 				// blob end
0: 			case java.sql.Types.ARRAY:
0: 			case java.sql.Types.DISTINCT:
0: 			case java.sql.Types.NULL:
0: 			case java.sql.Types.OTHER:
0: 			case java.sql.Types.REF:
0: 			case java.sql.Types.STRUCT:
0: 				throw new SQLException("Jdbc type" + jdbcType + "not Supported yet");
0: 			default:
0: 				throw new SQLException ("unrecognized sql type: " + jdbcType);
0: 		}
1: 
0: 		if (!nullable)
0: 			drdaType--;
0: 		return drdaType;
1: 
1: 
0: 	}
1: 
1: 
0: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 	protected static int LONGVARCHAR_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
0: 	protected static int LONGVARBINARY_MAX_LEN = Limits.DB2_LONGVARCHAR_MAXWIDTH;
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: package org.apache.derby.impl.drda;
0: 
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import java.sql.SQLException;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: 
0: class FdocaConstants
0: {
0: /**
0:    IBM Copyright &copy notice.
0: */
0: 
0: public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: // DRDA FD:OCA constants.
0:   static final int FDOCA_TYPE_FIXEDBYTES = 0x01;
0:   static final int FDOCA_TYPE_NFIXEDBYTES = 0x81;
0:   static final int FDOCA_TYPE_VARBYTES = 0x02;
0:   static final int FDOCA_TYPE_NVARBYTES = 0x82;
0:   static final int FDOCA_TYPE_NTBYTES = 0x03;
0:   static final int FDOCA_TYPE_NNTBYTES = 0x83;
0:   static final int FDOCA_TYPE_PSCLBYTE = 0x07;
0:   static final int FDOCA_TYPE_NPSCLBYTE = 0x87;
0:   static final int FDOCA_TYPE_FIXEDCHAR = 0x10;
0:   static final int FDOCA_TYPE_NFIXEDCHAR = 0x90;
0:   static final int FDOCA_TYPE_VARCHAR = 0x11;
0:   static final int FDOCA_TYPE_NVARCHAR = 0x91;
0:   static final int FDOCA_TYPE_NTCHAR = 0x14;
0:   static final int FDOCA_TYPE_NNTCHAR = 0x94;
0:   static final int FDOCA_TYPE_PSCLCHAR = 0x19;
0:   static final int FDOCA_TYPE_NPSCLCHAR = 0x99;
0:   static final int FDOCA_TYPE_INTEGER_BE = 0x23;
0:   static final int FDOCA_TYPE_NINTEGER_BE = 0xA3;
0:   static final int FDOCA_TYPE_INTEGER_LE = 0x24;
0:   static final int FDOCA_TYPE_NINTEGER_LE = 0xA4;
0:   static final int FDOCA_TYPE_DECIMAL = 0x30;
0:   static final int FDOCA_TYPE_NDECIMAL = 0xB0;
0:   static final int FDOCA_TYPE_NUMERIC_CHAR = 0x32;
0:   static final int FDOCA_TYPE_NNUMERIC_CHAR = 0xB2;
0:   static final int FDOCA_TYPE_ZDECIMAL_IBM = 0x33;   //370, 390, zOS and 400
0:   static final int FDOCA_TYPE_NZDECIMAL_IBM = 0xB3;  //370, 390, zOS and 400
0:   static final int FDOCA_TYPE_ZDECIMAL = 0x35;
0:   static final int FDOCA_TYPE_NZDECIMAL = 0xB5;
0:   static final int FDOCA_TYPE_FLOAT_370 = 0x40;
0:   static final int FDOCA_TYPE_NFLOAT_370 = 0xC0;
0:   static final int FDOCA_TYPE_FLOAT_X86 = 0x47;
0:   static final int FDOCA_TYPE_NFLOAT_X86 = 0xC7;
0:   static final int FDOCA_TYPE_FLOAT_IEEE = 0x48;   //including 400
0:   static final int FDOCA_TYPE_NFLOAT_IEEE = 0xC8;  //including 400
0:   static final int FDOCA_TYPE_FLOAT_VAX = 0x49;
0:   static final int FDOCA_TYPE_NFLOAT_VAX = 0xC9;
0:   static final int FDOCA_TYPE_LOBBYTES = 0x50;
0:   static final int FDOCA_TYPE_NLOBBYTES = 0xD0;
0:   static final int FDOCA_TYPE_LOBCHAR = 0x51;
0:   static final int FDOCA_TYPE_NLOBCHAR = 0xD1;
0: 
0:   // DRDA Type constants.
0:   static final int DRDA_TYPE_INTEGER = 0x02;
0:   static final int DRDA_TYPE_NINTEGER = 0x03;
0:   static final int DRDA_TYPE_SMALL = 0x04;
0:   static final int DRDA_TYPE_NSMALL = 0x05;
0:   static final int DRDA_TYPE_1BYTE_INT = 0x06;
0:   static final int DRDA_TYPE_N1BYTE_INT = 0x07;
0:   static final int DRDA_TYPE_FLOAT16 = 0x08;
0:   static final int DRDA_TYPE_NFLOAT16 = 0x09;
0:   static final int DRDA_TYPE_FLOAT8 = 0x0A;
0:   static final int DRDA_TYPE_NFLOAT8 = 0x0B;
0:   static final int DRDA_TYPE_FLOAT4 = 0x0C;
0:   static final int DRDA_TYPE_NFLOAT4 = 0x0D;
0:   static final int DRDA_TYPE_DECIMAL = 0x0E;
0:   static final int DRDA_TYPE_NDECIMAL = 0x0F;
0:   static final int DRDA_TYPE_ZDECIMAL = 0x10;
0:   static final int DRDA_TYPE_NZDECIMAL = 0x11;
0:   static final int DRDA_TYPE_NUMERIC_CHAR = 0x12;
0:   static final int DRDA_TYPE_NNUMERIC_CHAR = 0x13;
0:   static final int DRDA_TYPE_RSET_LOC = 0x14;
0:   static final int DRDA_TYPE_NRSET_LOC = 0x15;
0:   static final int DRDA_TYPE_INTEGER8 = 0x16;
0:   static final int DRDA_TYPE_NINTEGER8 = 0x17;
0:   static final int DRDA_TYPE_LOBLOC = 0x18;
0:   static final int DRDA_TYPE_NLOBLOC = 0x19;
0:   static final int DRDA_TYPE_CLOBLOC = 0x1A;
0:   static final int DRDA_TYPE_NCLOBLOC = 0x1B;
0:   static final int DRDA_TYPE_DBCSCLOBLOC = 0x1C;
0:   static final int DRDA_TYPE_NDBCSCLOBLOC = 0x1D;
0:   static final int DRDA_TYPE_ROWID = 0x1E;
0:   static final int DRDA_TYPE_NROWID = 0x1F;
0:   static final int DRDA_TYPE_DATE = 0x20;
0:   static final int DRDA_TYPE_NDATE = 0x21;
0:   static final int DRDA_TYPE_TIME = 0x22;
0:   static final int DRDA_TYPE_NTIME = 0x23;
0:   static final int DRDA_TYPE_TIMESTAMP = 0x24;
0:   static final int DRDA_TYPE_NTIMESTAMP = 0x25;
0:   static final int DRDA_TYPE_FIXBYTE = 0x26;
0:   static final int DRDA_TYPE_NFIXBYTE = 0x27;
0:   static final int DRDA_TYPE_VARBYTE = 0x28;
0:   static final int DRDA_TYPE_NVARBYTE = 0x29;
0:   static final int DRDA_TYPE_LONGVARBYTE = 0x2A;
0:   static final int DRDA_TYPE_NLONGVARBYTE = 0x2B;
0:   static final int DRDA_TYPE_NTERMBYTE = 0x2C;
0:   static final int DRDA_TYPE_NNTERMBYTE = 0x2D;
0:   static final int DRDA_TYPE_CSTR = 0x2E;
0:   static final int DRDA_TYPE_NCSTR = 0x2F;
0:   static final int DRDA_TYPE_CHAR = 0x30;
0:   static final int DRDA_TYPE_NCHAR = 0x31;
0:   static final int DRDA_TYPE_VARCHAR = 0x32;
0:   static final int DRDA_TYPE_NVARCHAR = 0x33;
0:   static final int DRDA_TYPE_LONG = 0x34;
0:   static final int DRDA_TYPE_NLONG = 0x35;
0:   static final int DRDA_TYPE_GRAPHIC = 0x36;
0:   static final int DRDA_TYPE_NGRAPHIC = 0x37;
0:   static final int DRDA_TYPE_VARGRAPH = 0x38;
0:   static final int DRDA_TYPE_NVARGRAPH = 0x39;
0:   static final int DRDA_TYPE_LONGRAPH = 0x3A;
0:   static final int DRDA_TYPE_NLONGRAPH = 0x3B;
0:   static final int DRDA_TYPE_MIX = 0x3C;
0:   static final int DRDA_TYPE_NMIX = 0x3D;
0:   static final int DRDA_TYPE_VARMIX = 0x3E;
0:   static final int DRDA_TYPE_NVARMIX = 0x3F;
0:   static final int DRDA_TYPE_LONGMIX = 0x40;
0:   static final int DRDA_TYPE_NLONGMIX = 0x41;
0:   static final int DRDA_TYPE_CSTRMIX = 0x42;
0:   static final int DRDA_TYPE_NCSTRMIX = 0x43;
0:   static final int DRDA_TYPE_PSCLBYTE = 0x44;
0:   static final int DRDA_TYPE_NPSCLBYTE = 0x45;
0:   static final int DRDA_TYPE_LSTR = 0x46;
0:   static final int DRDA_TYPE_NLSTR = 0x47;
0:   static final int DRDA_TYPE_LSTRMIX = 0x48;
0:   static final int DRDA_TYPE_NLSTRMIX = 0x49;
0:   static final int DRDA_TYPE_SDATALINK = 0x4C;
0:   static final int DRDA_TYPE_NSDATALINK = 0x4D;
0:   static final int DRDA_TYPE_MDATALINK = 0x4E;
0:   static final int DRDA_TYPE_NMDATALINK = 0x4F;
0: 
0:   // --- Override LIDs 0x50 - 0xAF
0:   static final int DRDA_TYPE_LOBBYTES = 0xC8;
0:   static final int DRDA_TYPE_NLOBBYTES = 0xC9;
0:   static final int DRDA_TYPE_LOBCSBCS = 0xCA;
0:   static final int DRDA_TYPE_NLOBCSBCS = 0xCB;
0:   static final int DRDA_TYPE_LOBCDBCS = 0xCC;
0:   static final int DRDA_TYPE_NLOBCDBCS = 0xCD;
0:   static final int DRDA_TYPE_LOBCMIXED = 0xCE;
0:   static final int DRDA_TYPE_NLOBCMIXED = 0xCF;
0: 
0:   static final int CPT_TRIPLET_TYPE = 0x7F;      // CPT triplet type
0:   static final int MDD_TRIPLET_TYPE = 0x78;      // MDD triplet type
0:   static final int NGDA_TRIPLET_TYPE = 0x76;     // N-GDA triplet type
0:   static final int RLO_TRIPLET_TYPE = 0x71;      // RLO triplet type
0:   static final int SDA_TRIPLET_TYPE = 0x70;      // SDA triplet type
0: 
0:   static final int SDA_MD_TYPE = 1;              // SDA MD type
0:   static final int GDA_MD_TYPE = 2;              // GDA MD type
0:   static final int ROW_MD_TYPE = 3;              // Row MD type
0: 
0:   static final int SQLCADTA_LID = 0xE0;
0:   static final int SQLDTAGRP_LID = 0xD0;         // SQLDTAGRP LID
0:   static final int NULL_LID = 0x00;
0: 
0:   static final int INDICATOR_NULLABLE = 0x00;
0:   static final int NULL_DATA = 0xFF;
0:   static final int TYP_NULLIND = 1;
0:   static final int MAX_ENV_LID = 0x49;           // Largest possible N-GDA/CPT repeating
0: 
0:   static final int MAX_VARS_IN_NGDA = 84;        // Number of SQLVARs in full SQLDTAGRP
0:                                                  // N-GDA or CPT
0:   static final int FULL_NGDA_SIZE = 255;         // Size of full SQLDTAGRP N-GDA or CPT
0:   static final int MDD_TRIPLET_SIZE = 7;         // Size of MDD triplet
0:   static final int SDA_TRIPLET_SIZE = 12;        // Size of SDA triplet
0:   static final int SQLDTA_RLO_SIZE = 6;          // Size of SQLDTA RLO triplet
0:   static final int RLO_RPT_GRP_SIZE = 3;         // Size of RLO repeating group
0:   static final int SQLDTAGRP_SIZE = 3;           // Size of SQLDTAGRP descriptor
0:   static final int CPT_SIZE = 3;                 // Size of CPT descriptor
0:   static final int FDODSC_FOOTER_SIZE = 6;       // Size of regular FDODSC "footer" (RLO)
0:   static final int SQLDTAGRP_COL_DSC_SIZE = 3;   // Env. LID & len. bytes
0:   static final int MAX_OVERRIDES = 250;          // Max nbr of overrides via pairs of MDD + SDA
0:   static final int MDD_REST_SIZE = 5;            // Size of the MDD group minus length and type
0: 
0:   // Hard-coded SQLCADTA MDD
0:   static final byte[] SQLCADTA_MDD = {
0:     (byte)0x07, (byte)0x78, (byte)0x00,
0:     (byte)0x05, (byte)0x03, (byte)0x01,
0:     (byte)0xE0
0:   };
0: 
0:   // Hard-coded SQLDTA MDD
0:   static final byte[] SQLDTA_MDD = {
0:     (byte)0x07, (byte)0x78, (byte)0x00,
0:     (byte)0x05, (byte)0x04, (byte)0x01,
0:     (byte)0xF0
0:   };
0: 
0:   // Hard-coded SQLDTA MDD
0:   static final byte[] SQLDTAGRP_MDD = {
0:     (byte)0x07, (byte)0x78, (byte)0x00,
0:     (byte)0x05, (byte)0x02, (byte)0x01,
0:     (byte)0xD0
0:   };
0: 
0:   // Hard-coded SQLCADTA+SQLDTARD footer bytes
0:   static final byte[] SQLCADTA_SQLDTARD_RLO = {
0:     (byte)0x09, (byte)0x71, (byte)0xE0,   // SQLCADTA
0:     (byte)0x54, (byte)0x00, (byte)0x01,
0:     (byte)0xD0, (byte)0x00, (byte)0x01,
0:     (byte)0x06, (byte)0x71, (byte)0xF0,   // SQLDTARD
0:     (byte)0xE0, (byte)0x00, (byte)0x00
0:   };
0: 
0:   // Hard-coded SQLDTA RLO
0:   static final byte[] SQLDTA_RLO = {
0:     (byte)0x06, (byte)0x71, (byte)0xE4,
0:     (byte)0xD0, (byte)0x00, (byte)0x01
0:   };
0: 
0:   static final int SQLCADTA_SQLDTARD_RLO_SIZE = SQLCADTA_SQLDTARD_RLO.length;
0: 
0: 	protected static boolean isNullable(int fdocaType)
0: 	{
0: 		return ( (fdocaType & 1) == 1);
0: 	}
0: 
0: 	// The maxumum length for LONG VARCHAR RETURN RESULTS IS
0: 	// 64K, since we send an unsigned short.  We should be
0: 	// able to send the number of bytes in which we encode the
0: 	// length as 4 (or more) , but JCC does not support this yet.
0: 	// JAVA_OBJECTS are returned as LONG VARCHAR values by calling
0: 	// their toString() method and their limit is 64K as well.
0: 	// BUT, that said, we ultimately have to match DB2's limit,
0: 	// so just use that...
0: 	protected static int LONGVARCHAR_MAX_LEN = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0: 	protected static int LONGVARBINARY_MAX_LEN = DB2Limit.DB2_LONGVARCHAR_MAXWIDTH;
0: 	protected static int LONGVARCHAR_LEN_NUMBYTES = 2;
0: 
0: 	// JCC  only supports a max precision of 31 like DB2
0: 	protected static int NUMERIC_MAX_PRECISION=31;
0: 	protected static int NUMERIC_DEFAULT_PRECISION=NUMERIC_MAX_PRECISION;
0: 	protected static int NUMERIC_DEFAULT_SCALE=15;
0: 
0: 	/***
0: 	 * Map jdbctype to fdoca drda type
0: 	 * @param jdbcType - Jdbc type for mappingy
0: 	 * @param nullable - true if type is nullable
0: 	 * @param outlen - output parameter with length of type.
0: 	 * @return standard drdaTypeLength. -1 if we don't know.
0: 	 **/
0: 	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable,
0: 											   int[] outlen)
0: 		throws SQLException
0: 	{
0: 
0: 		int drdaType = 0;
0: 		switch (jdbcType) {
0: 			case JDBC30Translation.BOOLEAN:
0: 			case java.sql.Types.BIT:
0: 			case java.sql.Types.TINYINT:
0: 			case java.sql.Types.SMALLINT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NSMALL;
0: 				outlen[0] = 2;
0: 				break;
0: 			case java.sql.Types.INTEGER:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NINTEGER;
0: 				outlen[0] = 4;
0: 				break;
0: 			case java.sql.Types.BIGINT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NINTEGER8;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.REAL:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NFLOAT4;
0: 				outlen[0] = 4;
0: 				break;
0: 			case java.sql.Types.DOUBLE:
0: 			case java.sql.Types.FLOAT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NFLOAT8;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.NUMERIC:
0: 			case java.sql.Types.DECIMAL:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NDECIMAL;
0: 				//needs to be adjusted for actual value
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.DATE:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NDATE;
0: 				outlen[0] = 10;
0: 				break;
0: 			case java.sql.Types.TIME:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NTIME;
0: 				outlen[0] = 8;
0: 				break;
0: 			case java.sql.Types.TIMESTAMP:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NTIMESTAMP;
0: 				outlen[0] = 26;
0: 				break;
0: 			case java.sql.Types.CHAR:
0: //				drdaType = FdocaConstants.DRDA_TYPE_NCHAR;
0: 				//making this NVARMIX for now to handle different byte length
0: 				//characters - checking with Paul to see if this is the
0: 				//correct way to handle it.
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARMIX;
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.VARCHAR:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARCHAR;
0: 				outlen[0] = -1;
0: 				break;
0: 				// we will just convert a java object to a string
0: 				// since jcc doesn't support it.
0: 			case java.sql.Types.JAVA_OBJECT:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLONG;
0: 				outlen[0] = LONGVARCHAR_MAX_LEN;
0: 				break;
0: 			case java.sql.Types.LONGVARCHAR:
0: 					drdaType = DRDA_TYPE_NLONG;
0: 					outlen[0] = LONGVARCHAR_MAX_LEN;
0: 				break;
0: 			case java.sql.Types.BINARY:
0: 			case java.sql.Types.VARBINARY:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NVARBYTE;
0: 				outlen[0] = -1;
0: 				break;
0: 			case java.sql.Types.LONGVARBINARY:
0: 					drdaType = FdocaConstants.DRDA_TYPE_NLONGVARBYTE;
0: 					outlen[0] = LONGVARBINARY_MAX_LEN;
0: 				break;
0: 				// blob begin
0: 				// merge BLOB and BLOB_LOCATOR ????
0: 			case java.sql.Types.BLOB:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLOBBYTES;
0: 				// indicates fdocadata is a place holder with 4 byte length
0: 				outlen[0] = 0x8004;
0: 				break;
0: 			case java.sql.Types.CLOB:
0: 				drdaType = FdocaConstants.DRDA_TYPE_NLOBCMIXED;
0: 				outlen[0] = 0x8004;
0: 				break;
0: 				// blob end
0: 			case java.sql.Types.ARRAY:
0: 			case java.sql.Types.DISTINCT:
0: 			case java.sql.Types.NULL:
0: 			case java.sql.Types.OTHER:
0: 			case java.sql.Types.REF:
0: 			case java.sql.Types.STRUCT:
0: 				throw new SQLException("Jdbc type" + jdbcType + "not Supported yet");
0: 			default:
0: 				throw new SQLException ("unrecognized sql type: " + jdbcType);
0: 		}
0: 
0: 		if (!nullable)
0: 			drdaType--;
0: 		return drdaType;
0: 
0: 
0: 	}
0: 
0: 
0: }
============================================================================