1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.NormalizeResultSetNode
1:860148c: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
12:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:c656441:  *
1:eac0369:  * A NormalizeResultSetNode represents a normalization result set for any 
1:c656441:  * child result set that needs one.  See non-javadoc comments for 
1:c656441:  * a walk-through of a couple sample code paths.
1:c656441:  */
1:c656441: 
1:c656441:  /*
1:c656441:  * Below are a couple of sample code paths for NormlizeResultSetNodes.
1:c656441:  * These samples were derived from Army Brown's write-ups attached to DERBY-3310
1:c656441:  * and DERBY-3494.  The text was changed to include the new code path now that 
1:c656441:  * all of the NormalizeResultSetNode  code has been moved into the init() method.
1:c656441:  * There are two sections of code in NormalizeResultSetNode.init() that are relevant:
1:c656441:  * First the code to generate the new node based on the child result set. 
1:c656441:  * We will call this "normalize node creation".
1:c656441:  * 
1:c656441:  *       ResultSetNode rsn  = (ResultSetNode) childResult;
1:c656441:  *       ResultColumnList rcl = rsn.getResultColumns();
1:c656441:  *       ResultColumnList targetRCL = (ResultColumnList) targetResultColumnList;
1:c656441:  *       ...
1:c656441:  *       ResultColumnList prRCList = rcl;
1:c656441:  *       rsn.setResultColumns(rcl.copyListAndObjects());
1:c656441:  *       ...
1:c656441:  *       this.resultColumns = prRCList;
1:c656441:  *
1:c656441:  * Next the code to adjust the types for the NormalizeResultSetNode.  
1:c656441:  * We will call this "type adjustment"
1:c656441:  * 
1:c656441:  *       if (targetResultColumnList != null) {
1:c656441:  *           int size = Math.min(targetRCL.size(), resultColumns.size());
1:c656441:  *           for (int index = 0; index < size; index++) {
1:c656441:  *           ResultColumn sourceRC = (ResultColumn) resultColumns.elementAt(index);
1:c656441:  *           ResultColumn resultColumn = (ResultColumn) targetRCL.elementAt(index);
1:c656441:  *           sourceRC.setType(resultColumn.getTypeServices());
1:c656441:  *           }    
1:c656441:  *           
1:c656441:  * --- Sample 1 : Type conversion from Decimal to BigInt on insert ---  
1:c656441:  * (DERBY-3310 write-up variation) 
1:c656441:  * The SQL statement on which this sample focuses is:
1:c656441:  * 
1:c656441:  * create table d3310 (x bigint);
1:c656441:  * insert into d3310 select distinct * from (values 2.0, 2.1, 2.2) v; 
1:c656441:  * 
1:c656441:  * There are three compilation points of interest for this discussion:
1:c656441:  * 1. Before the "normalize node creation"
1:c656441:  * 2. Before the "type adjustment"
1:c656441:  * 3. After the  "type adjustment"
1:c656441:  * 
1:c656441:  * Upon completion of the "type adjustment", the compilation query 
1:c656441:  * tree is then manipulated during optimization and code generation, the 
1:c656441:  * latter of which ultimately determines how the execution-time ResultSet 
1:c656441:  * tree is going to look.\u00a0 So for this discussion we walk through the query
1:c656441:  * tree as it exists at the various points of interest just described.
1:c656441:  * 
1:c656441:  * 1) To start, the (simplified) query tree that we have looks something like the following:
1:c656441:  * 
1:c656441:  *      InsertNode
1:c656441:  * (RCL_0:ResultColumn_0<BigInt>)
1:c656441:  *           |
1:c656441:  *        SelectNode
1:c656441:  * (RCL_1:ResultColumn_1<Decimal>)
1:c656441:  *           |
1:c656441:  *       FromSubquery
1:c656441:  * (RCL_2:ResultColumn_2<Decimal>)
1:c656441:  *           |
1:c656441:  *        UnionNode
1:c656441:  * (RCL_3:ResultColumn_3<Decimal>)
1:c656441:  * 
1:c656441:  * Notation: In the above tree, node names with "_x" trailing them are used to
1:c656441:  *  distinguish Java Objects from each other. So if ResultColumn_0 shows up 
1:c656441:  *  more than once, then it is the *same* Java object showing up in different 
1:c656441:  *  parts of the query tree.  Type names in angle brackets, such as "<BigInt>",
1:c656441:  *  describe the type of the entity immediately preceding the brackets.  
1:c656441:  *  So a line of the form:
1:c656441:  * 
1:c656441:  *   RCL_0:ResultColumn_0<BigInt>
1:c656441:  * 
1:c656441:  * describes a ResultColumnList object containing one ResultColumn object 
1:c656441:  * whose type is BIGINT. We can see from the above tree that, before 
1:c656441:  * normalize node creation, the top of the compile tree contains an 
1:c656441:  * InsertNode, a SelectNode, a FromSubquery, and a UnionNode, all of 
1:c656441:  * which have different ResultColumnList objects and different ResultColumn 
1:c656441:  * objects within those lists.
1:c656441:  * 
1:c656441:  * 2) After the normalize node creation
1:c656441:  * The childresult passed to the init method of NormalizeResultSetNode is 
1:c656441:  * the InsertNode's child, so it ends up creating a new NormalizeResultSetNode 
1:c656441:  * and putting that node on top of the InsertNode's child--that is, on top of 
1:c656441:  * the SelectNode.
1:c656441:  *
1:c656441:  * At this point it's worth noting that a NormalizeResultSetNode operates 
1:c656441:  * based on two ResultColumnLists: a) its own (call it NRSN_RCL), and b) 
1:c656441:  * the ResultColumnList of its child (call it NRSN_CHILD_RCL). More 
1:c656441:  * specifically, during execution a NormalizeResultSet will take a row 
1:c656441:  * whose column types match the types of NRSN_CHILD_RCL, and it will 
1:c656441:  * "normalize" the values from that row so that they agree with the 
1:c656441:  * types of NRSN_RCL. Thus is it possible--and in fact, it should generally 
1:c656441:  * be the case--that the types of the columns in the NormalizeResultSetNode's 
1:c656441:  * own ResultColumnList are *different* from the types of the columns in 
1:c656441:  * its child's ResultColumnList. That should not be the case for most 
1:c656441:  * (any?) other Derby result set.
1:c656441:  * 
1:c656441:  * So we now have:
1:c656441:  *
1:c656441:  *      InsertNode
1:c656441:  * (RCL_0:ResultColumn_0<BigInt>)
1:c656441:  *          |
1:c656441:  *  NormalizeResultSetNode
1:c656441:  * (RCL_1:ResultColumn_1<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:c656441:  *           |
1:c656441:  *        SelectNode
1:c656441:  * (RCL_4:ResultColumn_4<Decimal>)
1:c656441:  *          |
1:c656441:  *      FromSubquery
1:c656441:  * (RCL_2:ResultColumn_2<Decimal>)
1:c656441:  *          |
1:c656441:  *        UnionNode
1:c656441:  * (RCL_3:ResultColumn_3<Decimal>)
1:c656441:  *
1:c656441:  * Notice how, when we generate the NormalizeResultSetNode, three things happen:
1:c656441:  * 
1:c656441:  * a) The ResultColumList object for the SelectNode is "pulled up" into the 
1:c656441:  * NormalizeResultSetNode.
1:c656441:  * b) SelectNode is given a new ResultColumnList--namely, a clone of its old
1:c656441:  *  ResultColumnList, including clones of the ResultColumn objects.
1:c656441:  * c) VirtualColumnNodes are generated beneath NormalizeResultSetNode's 
1:c656441:  * ResultColumns, and those VCNs point to the *SAME RESULT COLUMN OBJECTS* 
1:c656441:  * that now sit in the SelectNode's new ResultColumnList.  
1:c656441:  * Also note how the generated VirtualColumnNode has no type of its own; 
1:c656441:  * since it is an instance of ValueNode it does have a dataTypeServices 
1:c656441:  * field, but that field was not set when the NormalizeResultSetNode was 
1:c656441:  * created.  Hence "<no_type>" in the above tree.
1:c656441:  * 
1:c656441:  * And finally, note that at this point, NormalizeResultSetNode's 
1:c656441:  * ResultColumnList has the same types as its child's ResultColumnList
1:c656441:  * --so the NormalizeResultSetNode doesn't actually do anything 
1:c656441:  * in its current form.
1:c656441:  * 
1:c656441:  * 3) Within the "type adjustment"
1:c656441:  * 
1:c656441:  * The purpose of the "type adjustment" is to take the types from 
1:c656441:  * the InsertNode's ResultColumnList and "push" them down to the 
1:c656441:  * NormalizeResultSetNode. It is this method which sets NRSN_RCL's types 
1:c656441:  * to match the target (INSERT) table's types--and in doing so, makes them 
1:c656441:  * different from NRSN_CHILD_RCL's types.  Thus this is important because 
1:c656441:  * without it, NormalizeResultSetNode would never change the types of the 
1:c656441:  * values it receives.
1:c656441:  * 
1:c656441:  * That said, after the call to sourceRC.setType(...) we have:
1:c656441:  *
1:c656441:  *      InsertNode
1:c656441:  * (RCL0:ResultColumn_0<BigInt>)
1:c656441:  *           |
1:c656441:  *   NormalizeResultSetNode
1:c656441:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode_0<no_type> -> ResultColumn_4<Decimal>)
1:c656441:  *           |
1:c656441:  *        SelectNode
1:c656441:  * (RCL4:ResultColumn_4<Decimal>)
1:c656441:  *           |
1:c656441:  *       FromSubquery
1:c656441:  * (RCL2:ResultColumn_2<Decimal>)
1:c656441:  *           |
1:c656441:  *        UnionNode
1:c656441:  * (RCL3:ResultColumn_3<Decimal>)
1:c656441:  *
1:c656441:  * The key change here is that ResultColumn_1 now has a type of BigInt 
1:c656441:  * intead of Decimal.  Since the SelectNode's ResultColumn, ResultColumn_4,
1:c656441:  *  still has a type of Decimal, the NormalizeResulSetNode will take as input
1:c656441:  *  a Decimal value (from SelectNode) and will output that value as a BigInt, 
1:c656441:  *  where output means pass the value further up the tree during execution 
1:c656441:  *  (see below).
1:c656441:  * 
1:c656441:  * Note before the fix for DERBY-3310, there was an additional type change 
1:c656441:  * that caused problems with this case.    
1:c656441:  * See the writeup attached to DERBY-3310 for details on why this was a problem.  
1:c656441:  *  
1:c656441:  * 4) After preprocessing and optimization:
1:c656441:  * 
1:c656441:  * After step 3 above, Derby will move on to the optimization phase, which 
1:c656441:  * begins with preprocessing.  During preprocessing the nodes in the tree 
1:c656441:  * may change shape/content to reflect the needs of the optimizer and/or to 
1:c656441:  * perform static optimizations/rewrites. In the case of our INSERT statement 
1:c656441:  * the preprocessing does not change much:
1:c656441:  *
1:c656441:  *     InsertNode
1:c656441:  * (RCL0:ResultColumn_0<BigInt>)
1:c656441:  *          |
1:c656441:  *  NormalizeResultSetNode
1:c656441:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:c656441:  *          |
1:c656441:  *       SelectNode
1:c656441:  * (RCL4:ResultColumn_4<Decimal>)
1:c656441:  *          |
1:c656441:  *   ProjectRestrictNode_0
1:c656441:  * (RCL2:ResultColumn_2<Decimal>)
1:c656441:  *          |
1:c656441:  *       UnionNode
1:c656441:  * (RCL3:ResultColumn_3<Decimal>)
1:c656441:  *
1:c656441:  * The only thing that has changed between this tree and the one shown in 
1:c656441:  * step 3 is that the FromSubquery has been replaced with a ProjectRestrictNode.
1:c656441:  * Note that the ProjectRestrictNode has the same ResultColumnList object as 
1:c656441:  * the FromSubquery, and the same ResultColumn object as well.  That's worth 
1:c656441:  * noting because it's another example of how Java objects can be "moved" 
1:c656441:  * from one node to another during Derby compilation.
1:c656441:  * 
1:c656441:  * 5) After modification of access paths:
1:c656441:  * As the final stage of optimization Derby will go through the modification 
1:c656441:  * of access paths phase, in which the query tree is modified to prepare for 
1:c656441:  * code generation.  When we are done modifying access paths, our tree looks 
1:c656441:  * something like this:
1:c656441: 
1:c656441:       InsertNode
1:c656441:  (RCL0:ResultColumn_0<BigInt>)
1:c656441:            |
1:c656441:    NormalizeResultSetNode
1:c656441:  (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:c656441:            |
1:c656441:       DistinctNode
1:c656441:  (RCL4:ResultColumn_4<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_5<Decimal>)
1:c656441:            |
1:c656441:      ProjectRestrictNode_1
1:c656441:  (RCL5:ResultColumn_5<Decimal>)
1:c656441:            |
1:c656441:     ProjectRestrictNode_0
1:c656441:  (RCL2:ResultColumn_2<Decimal>)
1:c656441:            |
1:c656441:         UnionNode
1:c656441:  (RCL3:ResultColumn_3<Decimal>)
1:c656441: 
1:c656441:  * The key thing to note here is that the SelectNode has been replaced with two 
1:c656441:  * new nodes: a ProjectRestrictNode whose ResultColumnList is a clone of the 
1:c656441:  * SelectNode's ResultColumnList, and a DistinctNode, whose ResultColumnList 
1:c656441:  * is the same object as the SelectNode's old ResultColumnList.  More 
1:c656441:  * specifically, all of the following occurred as part of modification of 
1:c656441:  * access paths:
1:c656441:  *  
1:c656441:  * a)    The SelectNode was replaced with ProjectRestrictNode_1, whose 
1:c656441:  * ResultColumnList was the same object as the SelectNode's ResultColumnList.
1:c656441:  *
1:c656441:  * b)    the ResultColumList object for ProjectRestrictNode_1 was pulled up 
1:c656441:  * into a new DistinctNode.
1:c656441:  *
1:c656441:  * c)    ProjectRestrictNode_1 was given a new ResultColumnList--namely, a 
1:c656441:  * clone of its old ResultColumnList, including clones of the ResultColumn 
1:c656441:  * objects.
1:c656441:  * 
1:c656441:  * d)    VirtualColumnNodes were generated beneath the DistinctNode's 
1:c656441:  * ResultColumns, and those VCNs point to the same result column objects 
1:c656441:  * that now sit in ProjectRestrictNode_1's new ResultColumnList.
1:c656441:  * 
1:c656441:  * 6) After code generation:
1:c656441:  *
1:c656441:  * During code generation we will walk the compile-time query tree one final 
1:c656441:  * time and, in doing so, we will generate code to build the execution-time 
1:c656441:  * ResultSet tree. As part of that process the two ProjectRestrictNodes will 
1:c656441:  * be skipped because they are both considered no-ops--i.e. they perform 
1:c656441:  * neither projections nor restrictions, and hence are not needed.  
1:c656441:  * (Note that, when checking to see if a ProjectRestrictNode is a no-op, 
1:c656441:  * column types do *NOT* come into play.)
1:c656441:  *
1:c656441:  * Thus the execution tree that we generate ends up looking something like:
1:c656441:  *
1:c656441:  *     InsertNode
1:c656441:  * (RCL0:ResultColumn_0<BigInt>)
1:c656441:  *           |
1:c656441:  *   NormalizeResultSetNode
1:c656441:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:c656441:  *           |
1:c656441:  *      DistinctNode
1:c656441:  * (RCL4:ResultColumn_4<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_5<Decimal>)
1:c656441:  *           |
1:c656441:  *     ProjectRestrictNode_1
1:c656441:  * (RCL5:ResultColumn_5<Decimal>)
1:c656441:  *          |
1:c656441:  *   ProjectRestrictNode_0
1:c656441:  * (RCL2:ResultColumn_2<Decimal>)
1:c656441:  *           |
1:c656441:  *       UnionNode
1:c656441:  * (RCL3:ResultColumn_3<Decimal>)
1:c656441:  *
1:c656441:  * At code generation the ProjectRestrictNodes will again be removed and the 
1:c656441:  * execution tree will end up looking like this:
1:c656441:  * 
1:c656441:  *    InsertResultSet
1:c656441:  *      (BigInt)
1:c656441:  *          |
1:c656441:  *  NormalizeResultSet
1:c656441:  *      (BigInt)
1:c656441:  *          |
1:c656441:  *   SortResultSet
1:c656441:  *      (Decimal)
1:c656441:  *          |
1:c656441:  *   UnionResultSet
1:c656441:  *      (Decimal)
1:c656441:  *
1:c656441:  * where SortResultSet is generated to enforce the DistinctNode, 
1:c656441:  * and thus expects the DistinctNode's column type--i.e. Decimal.
1:c656441:  * 
1:c656441:  * When it comes time to execute the INSERT statement, then, the UnionResultSet 
1:c656441:  * will create a row having a column whose type is DECIMAL, i.e. an SQLDecimal 
1:c656441:  * value.  The UnionResultSet will then pass that up to the SortResultSet, 
1:c656441:  * who is *also* expecting an SQLDecimal value.  So the SortResultSet is 
1:c656441:  * satisfied and can sort all of the rows from the UnionResultSet.  
1:c656441:  * Then those rows are passed up the tree to the NormalizeResultSet, 
1:c656441:  * which takes the DECIMAL value from its child (SortResultSet) and normalizes 
1:c656441:  * it to a value having its own type--i.e. to a BIGINT.  The BIGINT is then 
1:c656441:  * passed up to InsertResultSet, which inserts it into the BIGINT column 
1:c656441:  * of the target table.  And so the INSERT statement succeeds.
1:c656441:  * 
1:c656441:  * ---- Sample 2 -  NormalizeResultSetNode and  Union (DERBY-3494 write-up variation)
1:c656441:  * Query for discussion
1:c656441:  * 
1:c656441:  *
1:c656441:  * create table t1 (bi bigint, i int);
1:c656441:  *  insert into t1 values (100, 10), (288, 28), (4820, 2);
1:c656441:  *
1:c656441:  * select * from
1:c656441:  *   (select bi, i from t1 union select i, bi from t1) u(a,b) where a > 28;
1:c656441:  *
1:c656441:  *
1:c656441:  * Some things to notice about this query:
1:c656441:  * a) The UNION is part of a subquery.
1:c656441:  * b) This is *not* a UNION ALL; i.e. we need to eliminate duplicate rows.
1:c656441:  * c) The left side of the UNION and the right side of the UNION have 
1:c656441:  * different (but compatible) types: the left has (BIGINT, INT), while the 
1:c656441:  * right has (INT, BIGINT).
1:c656441:  * d) There is a predicate in the WHERE clause which references a column 
1:c656441:  * from the UNION subquery.
1:c656441:  * e) The table T1 has at least one row.
1:c656441:  * All of these factors plays a role in the handling of the query and are 
1:c656441:  * relevant to this discussion.
1:c656441:  * 
1:c656441:  * Building the NormalizeResultSetNode. 
1:c656441:  * When compiling a query, the final stage of optimization in Derby is the 
1:c656441:  * "modification of access paths" phase, in which each node in the query 
1:c656441:  * tree is given a chance to modify or otherwise perform maintenance in 
1:c656441:  * preparation for code generation.  In the case of a UnionNode, a call 
1:c656441:  * to modifyAccessPaths() will bring us to the addNewNodes() method, 
1:c656441:  * which is where the call is made to generate the NormalizeResultSetNode.
1:c656441:  * 
1:c656441:  *
1:c656441:  * if (! columnTypesAndLengthsMatch())
1:c656441:  *           {
1:c656441:  *               treeTop = 
1:c656441:  *               (NormalizeResultSetNode) getNodeFactory().getNode(
1:c656441:  *               C_NodeTypes.NORMALIZE_RESULT_SET_NODE,
1:c656441:  *               treeTop, null, null, Boolean.FALSE,
1:c656441:  *               getContextManager());   
1:c656441:  *            }
1:c656441:  *
1:c656441:  * The fact that the left and right children of the UnionNode have different 
1:c656441:  * types (observation c above) means that the if condition will return 
1:c656441:  * true and thus we will generate a NormalizeResultSetNode above the 
1:c656441:  * UnionNode. At this point (before the NormalizeResultSetNode has been 
1:c656441:  * generated) our (simplified) query tree looks something like the following.
1:c656441:  *  PRN stands for ProjectRestrictNode, RCL stands for ResultColumnList:
1:c656441:  *
1:c656441:  *                      PRN0
1:c656441:  *                     (RCL0)
1:c656441:  *             (restriction: a > 28 {RCL1})
1:c656441:  *                       |
1:c656441:  *                    UnionNode          // <-- Modifying access paths...
1:c656441:  *                     (RCL1)
1:c656441:  *                    /      \
1:c656441:  *                  PRN2     PRN3
1:c656441:  *                    |        |
1:c656441:  *                  PRN4     PRN5
1:c656441:  *                    |        |
1:c656441:  *                    T1       T1
1:c656441:  *
1:c656441:  *
1:c656441:  * where 'a > 28 {RCL1}' means that the column reference A in the predicate a > 28 points to a ResultColumn object in the ResultColumnList that corresponds to "RCL1".  I.e. at this point, the predicate's column reference is pointing to an object in the UnionNode's RCL.
1:c656441:  * "normalize node creation"  will execute:
1:c656441:  *
1:c656441:  *        ResultColumnList prRCList = rcl;
1:c656441:  *       rsn.setResultColumns(rcl.copyListAndObjects());
1:c656441:  *       // Remove any columns that were generated.
1:c656441:  *       prRCList.removeGeneratedGroupingColumns();
1:c656441:  *       ...
1:c656441:  *       prRCList.genVirtualColumnNodes(rsn, rsn.getResultColumns());
1:c656441:  *       
1:c656441:  *       this.resultColumns = prRCList;
1:c656441:  *       
1:c656441:  * to create a NormalizeResultSetNode whose result column list is prRCList.  
1:c656441:  * This gives us:
1:c656441:  *
1:c656441:  *                      PRN0
1:c656441:  *                     (RCL0)
1:c656441:  *             (restriction: a > 28 {RCL1})
1:c656441:  *                       |
1:c656441:  *             NormalizeResultSetNode
1:c656441:  *                     (RCL1)              // RCL1 "pulled up" to NRSN
1:c656441:  *                       |
1:c656441:  *                   UnionNode
1:c656441:  *                     (RCL2)              // RCL2 is a (modified) *copy* of RCL1
1:c656441:  *                    /      \
1:c656441:  *                  PRN2     PRN3
1:c656441:  *                    |        |
1:c656441:  *                  PRN4     PRN5
1:c656441:  *                    |        |
1:c656441:  *                    T1       T1
1:c656441:  *
1:c656441:  * Note how RCL1, the ResultColumnList object for the UnionNode, has now been 
1:c656441:  * *MOVED* so that it belongs to the NormalizeResultSetNode.  So the predicate 
1:c656441:  * a > 28, which (still) points to RCL1, is now pointing to the 
1:c656441:  * NormalizeResultSetNode instead of to the UnionNode.
1:c656441:  * 
1:c656441:  * After this, we go back to UnionNode.addNewNodes() where we see the following:
1:c656441:  * 
1:c656441:  *
1:c656441:  *  treeTop = (ResultSetNode) getNodeFactory().getNode(
1:c656441:  *                   C_NodeTypes.DISTINCT_NODE,
1:c656441:  *                   treeTop.genProjectRestrict(),
1:c656441:  *                   Boolean.FALSE,
1:c656441:  *                   tableProperties,
1:c656441:  *                   getContextManager());
1:c656441:  *
1:c656441:  *
1:c656441:  * I.e. we have to generate a DistinctNode to eliminate duplicates because the query 
1:c656441:  * specified UNION, not UNION ALL.
1:c656441:  * 
1:c656441:  * Note the call to treeTop.genProjectRestrict().  Since NormalizeResultSetNode 
1:c656441:  * now sits on top of the UnionNode, treeTop is a reference to the 
1:c656441:  * NormalizeResultSetNode.  That means we end up at the genProjectRestrict() 
1:c656441:  * method of NormalizeResultSetNode.  And guess what?  The method does 
1:c656441:  * something very similar to what we did in NormalizeResultSetNode.init(), 
1:c656441:  * namely:
1:c656441:  *
1:c656441:  *   ResultColumnList prRCList = resultColumns;
1:c656441:  *   resultColumns = resultColumns.copyListAndObjects();
1:c656441:  *
1:c656441:  * and then creates a ProjectRestrictNode whose result column list is prRCList.  This gives us:
1:c656441:  *
1:c656441:  *                     PRN0
1:c656441:  *                    (RCL0)
1:c656441:  *             (restriction: a > 28 {RCL1})
1:c656441:  *                       |
1:c656441:  *                     PRN6
1:c656441:  *                    (RCL1)              // RCL1 "pulled up" to new PRN.
1:c656441:  *                       |
1:c656441:  *             NormalizeResultSetNode
1:c656441:  *                    (RCL3)              // RCL3 is a (modified) copy of RCL1
1:c656441:  *                       |
1:c656441:  *                   UnionNode
1:c656441:  *                     (RCL2)             // RCL2 is a (modified) copy of RCL1
1:c656441:  *                    /      \
1:c656441:  *                  PRN2     PRN3
1:c656441:  *                    |        |
1:c656441:  *                  PRN4     PRN5
1:c656441:  *                    |        |
1:c656441:  *                    T1       T1
1:c656441:  *
1:c656441:  * On top of that we then put a DistinctNode.  And since the init() method 
1:c656441:  * of DistinctNode does the same kind of thing as the previously-discussed 
1:c656441:  * methods, we ultimatley end up with:
1:c656441:  *
1:c656441:  *                     PRN0
1:c656441:  *                     (RCL0)
1:c656441:  *             (restriction: a > 28 {RCL1})
1:c656441:  *                       |
1:c656441:  *                  DistinctNode
1:c656441:  *                    (RCL1)              // RCL1 pulled up to DistinctNode
1:c656441:  *                       |
1:c656441:  *                     PRN6
1:c656441:  *                    (RCL4)              // RCL4 is a (modified) copy of RCL1
1:c656441:  *                       |
1:c656441:  *             NormalizeResultSetNode
1:c656441:  *                    (RCL3)              // RCL3 is a (modified) copy of RCL1
1:c656441:  *                       |
1:c656441:  *                   UnionNode
1:c656441:  *                     (RCL2)             // RCL2 is a (modified) copy of RCL1
1:c656441:  *                    /      \
1:c656441:  *                  PRN2     PRN3
1:c656441:  *                    |        |
1:c656441:  *                  PRN4     PRN5
1:c656441:  *                    |        |
1:c656441:  *                    T1       T1
1:c656441:  *
1:c656441:  * And thus the predicate a > 28, which (still) points to RCL1, is now 
1:c656441:  * pointing to the DistinctNode instead of to the UnionNode. And this 
1:c656441:  * is what we want: i.e. we want the predicate a > 28 to be applied 
1:c656441:  * to the rows that we retrieve from the node at the *top* of the 
1:c656441:  * subtree generated for the UnionNode. It is the non-intuitive code 
1:c656441:  * in the normalize node creation that allows this to happen.
1:c656441:  *
2:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class NormalizeResultSetNode extends SingleChildResultSetNode
1:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * this indicates if the normalize is being performed for an Update
1:eac0369: 	 * statement or not. The row passed to update also has
1:eac0369: 	 * before values of the columns being updated-- we need not 
1:eac0369: 	 * normalize these values. 
1:eac0369: 	 */
1:eac0369: 	private boolean forUpdate;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor  for a NormalizeResultSetNode.
1:3bb140c:      * ColumnReferences must continue to point to the same ResultColumn, so
1:bfc59e5: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:bfc59e5: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:bfc59e5: 	 * which points to the FromTable and the ResultColumn that is the source for
1:bfc59e5: 	 * the ColumnReference.  
1:bfc59e5: 	 * (The new NRSN will have the original of the ResultColumnList and
1:bfc59e5: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:bfc59e5: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:bfc59e5: 	 * will remain at the FromTable, with the PRN getting a new 
1:bfc59e5: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:bfc59e5: 	 *
1:bfc59e5: 	 * This is useful for UNIONs, where we want to generate a DistinctNode above
1:bfc59e5: 	 * the UnionNode to eliminate the duplicates, because the type going into the
1:bfc59e5: 	 * sort has to agree with what the sort expects.
1:bfc59e5: 	 * (insert into t1 (smallintcol) values 1 union all values 2;
1:eac0369: 	 *
1:3bb140c:      * @param chldRes   The child ResultSetNode
1:860148c:      * @param targetResultColumnList The target resultColumnList from 
1:860148c:      *                          the InsertNode or UpdateNode. These will
1:860148c:      *                          be the types used for the NormalizeResultSetNode.
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:eac0369: 	 * @param forUpdate 	tells us if the normalize operation is being
1:eac0369: 	 * performed on behalf of an update statement. 
1:3bb140c:      * @param cm                The context manager
1:bfc59e5: 	 * @throws StandardException 
1:eac0369: 	 */
1:bfc59e5: 
1:3bb140c:     NormalizeResultSetNode(ResultSetNode chldRes,
1:3bb140c:                            ResultColumnList targetResultColumnList,
1:3bb140c:                            Properties tableProperties,
1:3bb140c:                            boolean forUpdate,
1:3bb140c:                            ContextManager cm) throws StandardException
1:eac0369: 	{
1:3bb140c:         super(chldRes, tableProperties, cm);
1:3bb140c:         this.forUpdate = forUpdate;
1:bfc59e5: 
1:3bb140c:         ResultColumnList rcl = chldRes.getResultColumns();
1:3bb140c:         ResultColumnList targetRCL = targetResultColumnList;
1:eac0369:         
1:bfc59e5: 		/* We get a shallow copy of the ResultColumnList and its 
1:bfc59e5: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1:bfc59e5: 		 * 
1:bfc59e5: 		 * Setting this.resultColumns to the modified child result column list,
1:bfc59e5: 		 * and making a new copy for the child result set node
1:bfc59e5: 		 * ensures that the ProjectRestrictNode restrictions still points to 
1:bfc59e5: 		 * the same list.  See d3494_npe_writeup-4.html in DERBY-3494 for a
1:bfc59e5: 		 * detailed explanation of how this works.
1:bfc59e5: 		 */
1:bfc59e5: 		ResultColumnList prRCList = rcl;
1:3bb140c:         chldRes.setResultColumns(rcl.copyListAndObjects());
1:bfc59e5: 		// Remove any columns that were generated.
1:bfc59e5: 		prRCList.removeGeneratedGroupingColumns();
1:576d3b7:         // And also columns that were added for ORDER BY (DERBY-6006).
1:576d3b7:         prRCList.removeOrderByColumns();
1:bfc59e5: 
1:bfc59e5: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1:bfc59e5: 		 * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1:bfc59e5: 		 * pointers to source ResultSetNode, rsn, and source ResultColumn.)
1:bfc59e5: 		 */
1:3bb140c:         prRCList.genVirtualColumnNodes(chldRes, chldRes.getResultColumns());
1:bfc59e5:         
1:11f7ee3: 		setResultColumns( prRCList );
1:bfc59e5: 		// Propagate the referenced table map if it's already been created
1:3bb140c:         if (chldRes.getReferencedTableMap() != null)
1:bfc59e5: 		    {
1:bfc59e5: 			setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
1:bfc59e5: 		    }
1:bfc59e5:         
1:bfc59e5:         
1:860148c: 		if (targetResultColumnList != null) {
1:11f7ee3: 		    int size = Math.min(targetRCL.size(), getResultColumns().size());
1:e1f49ca: 
1:e1f49ca:             for (int index = 0; index < size; index++) {
1:11f7ee3:                 ResultColumn sourceRC = getResultColumns().elementAt(index);
1:e1f49ca:                 ResultColumn resultColumn = targetRCL.elementAt(index);
1:e1f49ca:                 sourceRC.setType(resultColumn.getTypeServices());
1:860148c: 		    }
1:860148c: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		int				erdNumber;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:eac0369: 		// build up the tree.
1:eac0369: 
1:eac0369: 		// Generate the child ResultSet
1:eac0369: 
1:eac0369: 		// Get the cost estimate for the child
1:11f7ee3: 		setCostEstimate( childResult.getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		erdNumber = acb.addItem(makeResultDescription());
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 		childResult.generate(acb, mb);
1:11f7ee3: 		mb.push(getResultSetNumber());
1:eac0369: 		mb.push(erdNumber);
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:eac0369: 		mb.push(forUpdate);
1:9e6e461: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getNormalizeResultSet",
1:9e6e461: 					ClassName.NoPutResultSet, 6);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * set the Information gathered from the parent table that is 
1:28f9484:      * required to perform a referential action on dependent table.
1:eac0369: 	 */
1:3bb140c:     @Override
1:28f9484:     void setRefActionInfo(long fkIndexConglomId,
1:eac0369: 								 int[]fkColArray, 
1:eac0369: 								 String parentResultSetId,
1:eac0369: 								 boolean dependentScan)
1:eac0369: 	{
1:eac0369: 		childResult.setRefActionInfo(fkIndexConglomId,
1:eac0369: 								   fkColArray,
1:eac0369: 								   parentResultSetId,
1:eac0369: 								   dependentScan);
1:eac0369: 	}
1:eac0369: 
1:b4cda60:     @Override
1:b4cda60:     public void pushQueryExpressionSuffix() {
1:b4cda60:         childResult.pushQueryExpressionSuffix();
1:b4cda60:     }
1:b4cda60: 
1:b4cda60: 
1:2060c4a: 	/**
1:2060c4a: 	 * Push the order by list down from InsertNode into its child result set so
1:2060c4a: 	 * that the optimizer has all of the information that it needs to consider
1:2060c4a: 	 * sort avoidance.
1:2060c4a: 	 *
1:2060c4a: 	 * @param orderByList	The order by list
1:2060c4a: 	 */
1:3bb140c:     @Override
1:2060c4a: 	void pushOrderByList(OrderByList orderByList)
1:2060c4a: 	{
1:2060c4a: 		childResult.pushOrderByList(orderByList);
1:2060c4a: 	}
1:eac0369: 
1:108305b:     /**
1:108305b:      * Push through the offset and fetch first parameters, if any, to the child
1:108305b:      * result set.
1:108305b:      *
1:108305b:      * @param offset    the OFFSET, if any
1:108305b:      * @param fetchFirst the OFFSET FIRST, if any
1:57c1b5c:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:108305b:      */
1:3bb140c:     @Override
1:57c1b5c:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:108305b:     {
1:57c1b5c:         childResult.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
1:108305b:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setResultColumns( prRCList );
/////////////////////////////////////////////////////////////////////////
1: 		    int size = Math.min(targetRCL.size(), getResultColumns().size());
1:                 ResultColumn sourceRC = getResultColumns().elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( childResult.getFinalCostEstimate() );
1: 		mb.push(getResultSetNumber());
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:         childResult.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void pushQueryExpressionSuffix() {
1:         childResult.pushQueryExpressionSuffix();
1:     }
1: 
1: 
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (int index = 0; index < size; index++) {
0:                 ResultColumn sourceRC = resultColumns.elementAt(index);
1:                 ResultColumn resultColumn = targetRCL.elementAt(index);
1:                 sourceRC.setType(resultColumn.getTypeServices());
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1: class NormalizeResultSetNode extends SingleChildResultSetNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor  for a NormalizeResultSetNode.
1:      * ColumnReferences must continue to point to the same ResultColumn, so
/////////////////////////////////////////////////////////////////////////
1:      * @param chldRes   The child ResultSetNode
1:      * @param cm                The context manager
1:     NormalizeResultSetNode(ResultSetNode chldRes,
1:                            ResultColumnList targetResultColumnList,
1:                            Properties tableProperties,
1:                            boolean forUpdate,
1:                            ContextManager cm) throws StandardException
1:         super(chldRes, tableProperties, cm);
0:         setNodeType(C_NodeTypes.NORMALIZE_RESULT_SET_NODE);
1:         this.forUpdate = forUpdate;
1:         ResultColumnList rcl = chldRes.getResultColumns();
1:         ResultColumnList targetRCL = targetResultColumnList;
/////////////////////////////////////////////////////////////////////////
1:         chldRes.setResultColumns(rcl.copyListAndObjects());
/////////////////////////////////////////////////////////////////////////
1:         prRCList.genVirtualColumnNodes(chldRes, chldRes.getResultColumns());
1:         if (chldRes.getReferencedTableMap() != null)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push through the offset and fetch first parameters, if any, to the child
1:      * result set.
1:      *
1:      * @param offset    the OFFSET, if any
1:      * @param fetchFirst the OFFSET FIRST, if any
1:      */
0:     void pushOffsetFetchFirst(ValueNode offset, ValueNode fetchFirst)
1:     {
0:         childResult.pushOffsetFetchFirst(offset, fetchFirst);
1:     }
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Push the order by list down from InsertNode into its child result set so
1: 	 * that the optimizer has all of the information that it needs to consider
1: 	 * sort avoidance.
1: 	 *
1: 	 * @param orderByList	The order by list
1: 	 */
1: 	void pushOrderByList(OrderByList orderByList)
1: 	{
1: 		childResult.pushOrderByList(orderByList);
1: 	}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:28f9484
/////////////////////////////////////////////////////////////////////////
1:      * required to perform a referential action on dependent table.
1:     void setRefActionInfo(long fkIndexConglomId,
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:576d3b7
/////////////////////////////////////////////////////////////////////////
1:         // And also columns that were added for ORDER BY (DERBY-6006).
1:         prRCList.removeOrderByColumns();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c656441
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * child result set that needs one.  See non-javadoc comments for 
1:  * a walk-through of a couple sample code paths.
1:  */
1: 
1:  /*
1:  * Below are a couple of sample code paths for NormlizeResultSetNodes.
1:  * These samples were derived from Army Brown's write-ups attached to DERBY-3310
1:  * and DERBY-3494.  The text was changed to include the new code path now that 
1:  * all of the NormalizeResultSetNode  code has been moved into the init() method.
1:  * There are two sections of code in NormalizeResultSetNode.init() that are relevant:
1:  * First the code to generate the new node based on the child result set. 
1:  * We will call this "normalize node creation".
1:  * 
1:  *       ResultSetNode rsn  = (ResultSetNode) childResult;
1:  *       ResultColumnList rcl = rsn.getResultColumns();
1:  *       ResultColumnList targetRCL = (ResultColumnList) targetResultColumnList;
1:  *       ...
1:  *       ResultColumnList prRCList = rcl;
1:  *       rsn.setResultColumns(rcl.copyListAndObjects());
1:  *       ...
1:  *       this.resultColumns = prRCList;
1:  *
1:  * Next the code to adjust the types for the NormalizeResultSetNode.  
1:  * We will call this "type adjustment"
1:  * 
1:  *       if (targetResultColumnList != null) {
1:  *           int size = Math.min(targetRCL.size(), resultColumns.size());
1:  *           for (int index = 0; index < size; index++) {
1:  *           ResultColumn sourceRC = (ResultColumn) resultColumns.elementAt(index);
1:  *           ResultColumn resultColumn = (ResultColumn) targetRCL.elementAt(index);
1:  *           sourceRC.setType(resultColumn.getTypeServices());
1:  *           }    
1:  *           
1:  * --- Sample 1 : Type conversion from Decimal to BigInt on insert ---  
1:  * (DERBY-3310 write-up variation) 
1:  * The SQL statement on which this sample focuses is:
1:  * 
1:  * create table d3310 (x bigint);
1:  * insert into d3310 select distinct * from (values 2.0, 2.1, 2.2) v; 
1:  * 
1:  * There are three compilation points of interest for this discussion:
1:  * 1. Before the "normalize node creation"
1:  * 2. Before the "type adjustment"
1:  * 3. After the  "type adjustment"
1:  * 
1:  * Upon completion of the "type adjustment", the compilation query 
1:  * tree is then manipulated during optimization and code generation, the 
1:  * latter of which ultimately determines how the execution-time ResultSet 
1:  * tree is going to look.\u00a0 So for this discussion we walk through the query
1:  * tree as it exists at the various points of interest just described.
1:  * 
1:  * 1) To start, the (simplified) query tree that we have looks something like the following:
1:  * 
1:  *      InsertNode
1:  * (RCL_0:ResultColumn_0<BigInt>)
1:  *           |
1:  *        SelectNode
1:  * (RCL_1:ResultColumn_1<Decimal>)
1:  *           |
1:  *       FromSubquery
1:  * (RCL_2:ResultColumn_2<Decimal>)
1:  *           |
1:  *        UnionNode
1:  * (RCL_3:ResultColumn_3<Decimal>)
1:  * 
1:  * Notation: In the above tree, node names with "_x" trailing them are used to
1:  *  distinguish Java Objects from each other. So if ResultColumn_0 shows up 
1:  *  more than once, then it is the *same* Java object showing up in different 
1:  *  parts of the query tree.  Type names in angle brackets, such as "<BigInt>",
1:  *  describe the type of the entity immediately preceding the brackets.  
1:  *  So a line of the form:
1:  * 
1:  *   RCL_0:ResultColumn_0<BigInt>
1:  * 
1:  * describes a ResultColumnList object containing one ResultColumn object 
1:  * whose type is BIGINT. We can see from the above tree that, before 
1:  * normalize node creation, the top of the compile tree contains an 
1:  * InsertNode, a SelectNode, a FromSubquery, and a UnionNode, all of 
1:  * which have different ResultColumnList objects and different ResultColumn 
1:  * objects within those lists.
1:  * 
1:  * 2) After the normalize node creation
1:  * The childresult passed to the init method of NormalizeResultSetNode is 
1:  * the InsertNode's child, so it ends up creating a new NormalizeResultSetNode 
1:  * and putting that node on top of the InsertNode's child--that is, on top of 
1:  * the SelectNode.
1:  *
1:  * At this point it's worth noting that a NormalizeResultSetNode operates 
1:  * based on two ResultColumnLists: a) its own (call it NRSN_RCL), and b) 
1:  * the ResultColumnList of its child (call it NRSN_CHILD_RCL). More 
1:  * specifically, during execution a NormalizeResultSet will take a row 
1:  * whose column types match the types of NRSN_CHILD_RCL, and it will 
1:  * "normalize" the values from that row so that they agree with the 
1:  * types of NRSN_RCL. Thus is it possible--and in fact, it should generally 
1:  * be the case--that the types of the columns in the NormalizeResultSetNode's 
1:  * own ResultColumnList are *different* from the types of the columns in 
1:  * its child's ResultColumnList. That should not be the case for most 
1:  * (any?) other Derby result set.
1:  * 
1:  * So we now have:
1:  *
1:  *      InsertNode
1:  * (RCL_0:ResultColumn_0<BigInt>)
1:  *          |
1:  *  NormalizeResultSetNode
1:  * (RCL_1:ResultColumn_1<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:  *           |
1:  *        SelectNode
1:  * (RCL_4:ResultColumn_4<Decimal>)
1:  *          |
1:  *      FromSubquery
1:  * (RCL_2:ResultColumn_2<Decimal>)
1:  *          |
1:  *        UnionNode
1:  * (RCL_3:ResultColumn_3<Decimal>)
1:  *
1:  * Notice how, when we generate the NormalizeResultSetNode, three things happen:
1:  * 
1:  * a) The ResultColumList object for the SelectNode is "pulled up" into the 
1:  * NormalizeResultSetNode.
1:  * b) SelectNode is given a new ResultColumnList--namely, a clone of its old
1:  *  ResultColumnList, including clones of the ResultColumn objects.
1:  * c) VirtualColumnNodes are generated beneath NormalizeResultSetNode's 
1:  * ResultColumns, and those VCNs point to the *SAME RESULT COLUMN OBJECTS* 
1:  * that now sit in the SelectNode's new ResultColumnList.  
1:  * Also note how the generated VirtualColumnNode has no type of its own; 
1:  * since it is an instance of ValueNode it does have a dataTypeServices 
1:  * field, but that field was not set when the NormalizeResultSetNode was 
1:  * created.  Hence "<no_type>" in the above tree.
1:  * 
1:  * And finally, note that at this point, NormalizeResultSetNode's 
1:  * ResultColumnList has the same types as its child's ResultColumnList
1:  * --so the NormalizeResultSetNode doesn't actually do anything 
1:  * in its current form.
1:  * 
1:  * 3) Within the "type adjustment"
1:  * 
1:  * The purpose of the "type adjustment" is to take the types from 
1:  * the InsertNode's ResultColumnList and "push" them down to the 
1:  * NormalizeResultSetNode. It is this method which sets NRSN_RCL's types 
1:  * to match the target (INSERT) table's types--and in doing so, makes them 
1:  * different from NRSN_CHILD_RCL's types.  Thus this is important because 
1:  * without it, NormalizeResultSetNode would never change the types of the 
1:  * values it receives.
1:  * 
1:  * That said, after the call to sourceRC.setType(...) we have:
1:  *
1:  *      InsertNode
1:  * (RCL0:ResultColumn_0<BigInt>)
1:  *           |
1:  *   NormalizeResultSetNode
1:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode_0<no_type> -> ResultColumn_4<Decimal>)
1:  *           |
1:  *        SelectNode
1:  * (RCL4:ResultColumn_4<Decimal>)
1:  *           |
1:  *       FromSubquery
1:  * (RCL2:ResultColumn_2<Decimal>)
1:  *           |
1:  *        UnionNode
1:  * (RCL3:ResultColumn_3<Decimal>)
1:  *
1:  * The key change here is that ResultColumn_1 now has a type of BigInt 
1:  * intead of Decimal.  Since the SelectNode's ResultColumn, ResultColumn_4,
1:  *  still has a type of Decimal, the NormalizeResulSetNode will take as input
1:  *  a Decimal value (from SelectNode) and will output that value as a BigInt, 
1:  *  where output means pass the value further up the tree during execution 
1:  *  (see below).
1:  * 
1:  * Note before the fix for DERBY-3310, there was an additional type change 
1:  * that caused problems with this case.    
1:  * See the writeup attached to DERBY-3310 for details on why this was a problem.  
1:  *  
1:  * 4) After preprocessing and optimization:
1:  * 
1:  * After step 3 above, Derby will move on to the optimization phase, which 
1:  * begins with preprocessing.  During preprocessing the nodes in the tree 
1:  * may change shape/content to reflect the needs of the optimizer and/or to 
1:  * perform static optimizations/rewrites. In the case of our INSERT statement 
1:  * the preprocessing does not change much:
1:  *
1:  *     InsertNode
1:  * (RCL0:ResultColumn_0<BigInt>)
1:  *          |
1:  *  NormalizeResultSetNode
1:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:  *          |
1:  *       SelectNode
1:  * (RCL4:ResultColumn_4<Decimal>)
1:  *          |
1:  *   ProjectRestrictNode_0
1:  * (RCL2:ResultColumn_2<Decimal>)
1:  *          |
1:  *       UnionNode
1:  * (RCL3:ResultColumn_3<Decimal>)
1:  *
1:  * The only thing that has changed between this tree and the one shown in 
1:  * step 3 is that the FromSubquery has been replaced with a ProjectRestrictNode.
1:  * Note that the ProjectRestrictNode has the same ResultColumnList object as 
1:  * the FromSubquery, and the same ResultColumn object as well.  That's worth 
1:  * noting because it's another example of how Java objects can be "moved" 
1:  * from one node to another during Derby compilation.
1:  * 
1:  * 5) After modification of access paths:
1:  * As the final stage of optimization Derby will go through the modification 
1:  * of access paths phase, in which the query tree is modified to prepare for 
1:  * code generation.  When we are done modifying access paths, our tree looks 
1:  * something like this:
1: 
1:       InsertNode
1:  (RCL0:ResultColumn_0<BigInt>)
1:            |
1:    NormalizeResultSetNode
1:  (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:            |
1:       DistinctNode
1:  (RCL4:ResultColumn_4<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_5<Decimal>)
1:            |
1:      ProjectRestrictNode_1
1:  (RCL5:ResultColumn_5<Decimal>)
1:            |
1:     ProjectRestrictNode_0
1:  (RCL2:ResultColumn_2<Decimal>)
1:            |
1:         UnionNode
1:  (RCL3:ResultColumn_3<Decimal>)
1: 
1:  * The key thing to note here is that the SelectNode has been replaced with two 
1:  * new nodes: a ProjectRestrictNode whose ResultColumnList is a clone of the 
1:  * SelectNode's ResultColumnList, and a DistinctNode, whose ResultColumnList 
1:  * is the same object as the SelectNode's old ResultColumnList.  More 
1:  * specifically, all of the following occurred as part of modification of 
1:  * access paths:
1:  *  
1:  * a)    The SelectNode was replaced with ProjectRestrictNode_1, whose 
1:  * ResultColumnList was the same object as the SelectNode's ResultColumnList.
1:  *
1:  * b)    the ResultColumList object for ProjectRestrictNode_1 was pulled up 
1:  * into a new DistinctNode.
1:  *
1:  * c)    ProjectRestrictNode_1 was given a new ResultColumnList--namely, a 
1:  * clone of its old ResultColumnList, including clones of the ResultColumn 
1:  * objects.
1:  * 
1:  * d)    VirtualColumnNodes were generated beneath the DistinctNode's 
1:  * ResultColumns, and those VCNs point to the same result column objects 
1:  * that now sit in ProjectRestrictNode_1's new ResultColumnList.
1:  * 
1:  * 6) After code generation:
1:  *
1:  * During code generation we will walk the compile-time query tree one final 
1:  * time and, in doing so, we will generate code to build the execution-time 
1:  * ResultSet tree. As part of that process the two ProjectRestrictNodes will 
1:  * be skipped because they are both considered no-ops--i.e. they perform 
1:  * neither projections nor restrictions, and hence are not needed.  
1:  * (Note that, when checking to see if a ProjectRestrictNode is a no-op, 
1:  * column types do *NOT* come into play.)
1:  *
1:  * Thus the execution tree that we generate ends up looking something like:
1:  *
1:  *     InsertNode
1:  * (RCL0:ResultColumn_0<BigInt>)
1:  *           |
1:  *   NormalizeResultSetNode
1:  * (RCL1:ResultColumn_1<BigInt> -> VirtualColumnNode<no_type> -> ResultColumn_4<Decimal>)
1:  *           |
1:  *      DistinctNode
1:  * (RCL4:ResultColumn_4<Decimal> -> VirtualColumnNode<no_type> -> ResultColumn_5<Decimal>)
1:  *           |
1:  *     ProjectRestrictNode_1
1:  * (RCL5:ResultColumn_5<Decimal>)
1:  *          |
1:  *   ProjectRestrictNode_0
1:  * (RCL2:ResultColumn_2<Decimal>)
1:  *           |
1:  *       UnionNode
1:  * (RCL3:ResultColumn_3<Decimal>)
1:  *
1:  * At code generation the ProjectRestrictNodes will again be removed and the 
1:  * execution tree will end up looking like this:
1:  * 
1:  *    InsertResultSet
1:  *      (BigInt)
1:  *          |
1:  *  NormalizeResultSet
1:  *      (BigInt)
1:  *          |
1:  *   SortResultSet
1:  *      (Decimal)
1:  *          |
1:  *   UnionResultSet
1:  *      (Decimal)
1:  *
1:  * where SortResultSet is generated to enforce the DistinctNode, 
1:  * and thus expects the DistinctNode's column type--i.e. Decimal.
1:  * 
1:  * When it comes time to execute the INSERT statement, then, the UnionResultSet 
1:  * will create a row having a column whose type is DECIMAL, i.e. an SQLDecimal 
1:  * value.  The UnionResultSet will then pass that up to the SortResultSet, 
1:  * who is *also* expecting an SQLDecimal value.  So the SortResultSet is 
1:  * satisfied and can sort all of the rows from the UnionResultSet.  
1:  * Then those rows are passed up the tree to the NormalizeResultSet, 
1:  * which takes the DECIMAL value from its child (SortResultSet) and normalizes 
1:  * it to a value having its own type--i.e. to a BIGINT.  The BIGINT is then 
1:  * passed up to InsertResultSet, which inserts it into the BIGINT column 
1:  * of the target table.  And so the INSERT statement succeeds.
1:  * 
1:  * ---- Sample 2 -  NormalizeResultSetNode and  Union (DERBY-3494 write-up variation)
1:  * Query for discussion
1:  * 
1:  *
1:  * create table t1 (bi bigint, i int);
1:  *  insert into t1 values (100, 10), (288, 28), (4820, 2);
1:  *
1:  * select * from
1:  *   (select bi, i from t1 union select i, bi from t1) u(a,b) where a > 28;
1:  *
1:  *
1:  * Some things to notice about this query:
1:  * a) The UNION is part of a subquery.
1:  * b) This is *not* a UNION ALL; i.e. we need to eliminate duplicate rows.
1:  * c) The left side of the UNION and the right side of the UNION have 
1:  * different (but compatible) types: the left has (BIGINT, INT), while the 
1:  * right has (INT, BIGINT).
1:  * d) There is a predicate in the WHERE clause which references a column 
1:  * from the UNION subquery.
1:  * e) The table T1 has at least one row.
1:  * All of these factors plays a role in the handling of the query and are 
1:  * relevant to this discussion.
1:  * 
1:  * Building the NormalizeResultSetNode. 
1:  * When compiling a query, the final stage of optimization in Derby is the 
1:  * "modification of access paths" phase, in which each node in the query 
1:  * tree is given a chance to modify or otherwise perform maintenance in 
1:  * preparation for code generation.  In the case of a UnionNode, a call 
1:  * to modifyAccessPaths() will bring us to the addNewNodes() method, 
1:  * which is where the call is made to generate the NormalizeResultSetNode.
1:  * 
1:  *
1:  * if (! columnTypesAndLengthsMatch())
1:  *           {
1:  *               treeTop = 
1:  *               (NormalizeResultSetNode) getNodeFactory().getNode(
1:  *               C_NodeTypes.NORMALIZE_RESULT_SET_NODE,
1:  *               treeTop, null, null, Boolean.FALSE,
1:  *               getContextManager());   
1:  *            }
1:  *
1:  * The fact that the left and right children of the UnionNode have different 
1:  * types (observation c above) means that the if condition will return 
1:  * true and thus we will generate a NormalizeResultSetNode above the 
1:  * UnionNode. At this point (before the NormalizeResultSetNode has been 
1:  * generated) our (simplified) query tree looks something like the following.
1:  *  PRN stands for ProjectRestrictNode, RCL stands for ResultColumnList:
1:  *
1:  *                      PRN0
1:  *                     (RCL0)
1:  *             (restriction: a > 28 {RCL1})
1:  *                       |
1:  *                    UnionNode          // <-- Modifying access paths...
1:  *                     (RCL1)
1:  *                    /      \
1:  *                  PRN2     PRN3
1:  *                    |        |
1:  *                  PRN4     PRN5
1:  *                    |        |
1:  *                    T1       T1
1:  *
1:  *
1:  * where 'a > 28 {RCL1}' means that the column reference A in the predicate a > 28 points to a ResultColumn object in the ResultColumnList that corresponds to "RCL1".  I.e. at this point, the predicate's column reference is pointing to an object in the UnionNode's RCL.
1:  * "normalize node creation"  will execute:
1:  *
1:  *        ResultColumnList prRCList = rcl;
1:  *       rsn.setResultColumns(rcl.copyListAndObjects());
1:  *       // Remove any columns that were generated.
1:  *       prRCList.removeGeneratedGroupingColumns();
1:  *       ...
1:  *       prRCList.genVirtualColumnNodes(rsn, rsn.getResultColumns());
1:  *       
1:  *       this.resultColumns = prRCList;
1:  *       
1:  * to create a NormalizeResultSetNode whose result column list is prRCList.  
1:  * This gives us:
1:  *
1:  *                      PRN0
1:  *                     (RCL0)
1:  *             (restriction: a > 28 {RCL1})
1:  *                       |
1:  *             NormalizeResultSetNode
1:  *                     (RCL1)              // RCL1 "pulled up" to NRSN
1:  *                       |
1:  *                   UnionNode
1:  *                     (RCL2)              // RCL2 is a (modified) *copy* of RCL1
1:  *                    /      \
1:  *                  PRN2     PRN3
1:  *                    |        |
1:  *                  PRN4     PRN5
1:  *                    |        |
1:  *                    T1       T1
1:  *
1:  * Note how RCL1, the ResultColumnList object for the UnionNode, has now been 
1:  * *MOVED* so that it belongs to the NormalizeResultSetNode.  So the predicate 
1:  * a > 28, which (still) points to RCL1, is now pointing to the 
1:  * NormalizeResultSetNode instead of to the UnionNode.
1:  * 
1:  * After this, we go back to UnionNode.addNewNodes() where we see the following:
1:  * 
1:  *
1:  *  treeTop = (ResultSetNode) getNodeFactory().getNode(
1:  *                   C_NodeTypes.DISTINCT_NODE,
1:  *                   treeTop.genProjectRestrict(),
1:  *                   Boolean.FALSE,
1:  *                   tableProperties,
1:  *                   getContextManager());
1:  *
1:  *
1:  * I.e. we have to generate a DistinctNode to eliminate duplicates because the query 
1:  * specified UNION, not UNION ALL.
1:  * 
1:  * Note the call to treeTop.genProjectRestrict().  Since NormalizeResultSetNode 
1:  * now sits on top of the UnionNode, treeTop is a reference to the 
1:  * NormalizeResultSetNode.  That means we end up at the genProjectRestrict() 
1:  * method of NormalizeResultSetNode.  And guess what?  The method does 
1:  * something very similar to what we did in NormalizeResultSetNode.init(), 
1:  * namely:
1:  *
1:  *   ResultColumnList prRCList = resultColumns;
1:  *   resultColumns = resultColumns.copyListAndObjects();
1:  *
1:  * and then creates a ProjectRestrictNode whose result column list is prRCList.  This gives us:
1:  *
1:  *                     PRN0
1:  *                    (RCL0)
1:  *             (restriction: a > 28 {RCL1})
1:  *                       |
1:  *                     PRN6
1:  *                    (RCL1)              // RCL1 "pulled up" to new PRN.
1:  *                       |
1:  *             NormalizeResultSetNode
1:  *                    (RCL3)              // RCL3 is a (modified) copy of RCL1
1:  *                       |
1:  *                   UnionNode
1:  *                     (RCL2)             // RCL2 is a (modified) copy of RCL1
1:  *                    /      \
1:  *                  PRN2     PRN3
1:  *                    |        |
1:  *                  PRN4     PRN5
1:  *                    |        |
1:  *                    T1       T1
1:  *
1:  * On top of that we then put a DistinctNode.  And since the init() method 
1:  * of DistinctNode does the same kind of thing as the previously-discussed 
1:  * methods, we ultimatley end up with:
1:  *
1:  *                     PRN0
1:  *                     (RCL0)
1:  *             (restriction: a > 28 {RCL1})
1:  *                       |
1:  *                  DistinctNode
1:  *                    (RCL1)              // RCL1 pulled up to DistinctNode
1:  *                       |
1:  *                     PRN6
1:  *                    (RCL4)              // RCL4 is a (modified) copy of RCL1
1:  *                       |
1:  *             NormalizeResultSetNode
1:  *                    (RCL3)              // RCL3 is a (modified) copy of RCL1
1:  *                       |
1:  *                   UnionNode
1:  *                     (RCL2)             // RCL2 is a (modified) copy of RCL1
1:  *                    /      \
1:  *                  PRN2     PRN3
1:  *                    |        |
1:  *                  PRN4     PRN5
1:  *                    |        |
1:  *                    T1       T1
1:  *
1:  * And thus the predicate a > 28, which (still) points to RCL1, is now 
1:  * pointing to the DistinctNode instead of to the UnionNode. And this 
1:  * is what we want: i.e. we want the predicate a > 28 to be applied 
1:  * to the rows that we retrieve from the node at the *top* of the 
1:  * subtree generated for the UnionNode. It is the non-intuitive code 
1:  * in the normalize node creation that allows this to happen.
1:  *
commit:860148c
/////////////////////////////////////////////////////////////////////////
1:      * @param targetResultColumnList The target resultColumnList from 
1:      *                          the InsertNode or UpdateNode. These will
1:      *                          be the types used for the NormalizeResultSetNode.
/////////////////////////////////////////////////////////////////////////
0:                             Object targetResultColumnList,
/////////////////////////////////////////////////////////////////////////
0: 		ResultColumnList targetRCL = (ResultColumnList) targetResultColumnList;
1:         
/////////////////////////////////////////////////////////////////////////
1: 		if (targetResultColumnList != null) {
0: 		    int size = Math.min(targetRCL.size(), resultColumns.size());
0: 		    for (int index = 0; index < size; index++) {
0: 			ResultColumn sourceRC = (ResultColumn) resultColumns.elementAt(index);
0: 			ResultColumn resultColumn = (ResultColumn) targetRCL.elementAt(index);
0: 			sourceRC.setType(resultColumn.getTypeServices());
1: 		    }
1: 		}
commit:bfc59e5
/////////////////////////////////////////////////////////////////////////
0: 	 ** ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new NRSN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 *
1: 	 * This is useful for UNIONs, where we want to generate a DistinctNode above
1: 	 * the UnionNode to eliminate the duplicates, because the type going into the
1: 	 * sort has to agree with what the sort expects.
1: 	 * (insert into t1 (smallintcol) values 1 union all values 2;
1: 	 * @throws StandardException 
0: 							Object forUpdate) throws StandardException
1: 
0: 		ResultSetNode rsn  = (ResultSetNode) childResult;
0: 		ResultColumnList rcl = rsn.getResultColumns();
1: 
1: 		/* We get a shallow copy of the ResultColumnList and its 
1: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1: 		 * 
1: 		 * Setting this.resultColumns to the modified child result column list,
1: 		 * and making a new copy for the child result set node
1: 		 * ensures that the ProjectRestrictNode restrictions still points to 
1: 		 * the same list.  See d3494_npe_writeup-4.html in DERBY-3494 for a
1: 		 * detailed explanation of how this works.
1: 		 */
1: 		ResultColumnList prRCList = rcl;
0: 		rsn.setResultColumns(rcl.copyListAndObjects());
1: 		// Remove any columns that were generated.
1: 		prRCList.removeGeneratedGroupingColumns();
1: 
1: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1: 		 * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include
1: 		 * pointers to source ResultSetNode, rsn, and source ResultColumn.)
1: 		 */
0: 		prRCList.genVirtualColumnNodes(rsn, rsn.getResultColumns());
1:         
0: 		this.resultColumns = prRCList;
1: 		// Propagate the referenced table map if it's already been created
0: 		if (rsn.getReferencedTableMap() != null)
1: 		    {
1: 			setReferencedTableMap((JBitSet) getReferencedTableMap().clone());
1: 		    }
1:         
1:         
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 
1: 					ClassName.NoPutResultSet, 6);
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					ClassName.NoPutResultSet, 7);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.NormalizeResultSetNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A NormalizeResultSetNode represents a normalization result set for any 
0:  * child result set that needs one.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class NormalizeResultSetNode extends SingleChildResultSetNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 * this indicates if the normalize is being performed for an Update
1: 	 * statement or not. The row passed to update also has
1: 	 * before values of the columns being updated-- we need not 
1: 	 * normalize these values. 
1: 	 */
1: 	private boolean forUpdate;
1: 
1: 	/**
0: 	 * Initializer for a NormalizeResultSetNode.
1: 	 *
0: 	 * @param childResult	The child ResultSetNode
0: 	 * @param rcl			The RCL for the node
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 * @param forUpdate 	tells us if the normalize operation is being
1: 	 * performed on behalf of an update statement. 
1: 	 */
1: 
0: 	public void init(
0: 							Object childResult,
0: 							Object rcl,
0: 							Object tableProperties,
0: 							Object forUpdate)
1: 	{
0: 		super.init(childResult, tableProperties);
0: 		resultColumns = (ResultColumnList) rcl;
0: 		this.forUpdate = ((Boolean)forUpdate).booleanValue();
1: 	}
1: 
1: 
1:     /**
1:      *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		int				erdNumber;
1: 
1: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 		// build up the tree.
1: 
1: 		// Generate the child ResultSet
1: 
1: 		// Get the cost estimate for the child
0: 		costEstimate = childResult.getFinalCostEstimate();
1: 
1: 		erdNumber = acb.addItem(makeResultDescription());
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 		childResult.generate(acb, mb);
0: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
1: 		mb.push(erdNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
1: 		mb.push(forUpdate);
0: 		closeMethodArgument(acb, mb);
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getNormalizeResultSet",
0: 					ClassName.NoPutResultSet, 8);
1: 	}
1: 
1: 	/**
1: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
1: 								 int[]fkColArray, 
1: 								 String parentResultSetId,
1: 								 boolean dependentScan)
1: 	{
1: 		childResult.setRefActionInfo(fkIndexConglomId,
1: 								   fkColArray,
1: 								   parentResultSetId,
1: 								   dependentScan);
1: 	}
1: 
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A NormalizeResultSetNode represents a normalization result set for any 
0:  * child result set that needs one.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class NormalizeResultSetNode extends SingleChildResultSetNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * this indicates if the normalize is being performed for an Update
0: 	 * statement or not. The row passed to update also has
0: 	 * before values of the columns being updated-- we need not 
0: 	 * normalize these values. 
0: 	 */
0: 	private boolean forUpdate;
0: 
0: 	/**
0: 	 * Initializer for a NormalizeResultSetNode.
0: 	 *
0: 	 * @param childResult	The child ResultSetNode
0: 	 * @param rcl			The RCL for the node
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 * @param forUpdate 	tells us if the normalize operation is being
0: 	 * performed on behalf of an update statement. 
0: 	 */
0: 
0: 	public void init(
0: 							Object childResult,
0: 							Object rcl,
0: 							Object tableProperties,
0: 							Object forUpdate)
0: 	{
0: 		super.init(childResult, tableProperties);
0: 		resultColumns = (ResultColumnList) rcl;
0: 		this.forUpdate = ((Boolean)forUpdate).booleanValue();
0: 	}
0: 
0: 
0:     /**
0:      *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		int				erdNumber;
0: 
0: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		// build up the tree.
0: 
0: 		// Generate the child ResultSet
0: 
0: 		// Get the cost estimate for the child
0: 		costEstimate = childResult.getFinalCostEstimate();
0: 
0: 		erdNumber = acb.addItem(makeResultDescription());
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 		childResult.generate(acb, mb);
0: 		acb.pushThisAsActivation(mb);
0: 		mb.push(resultSetNumber);
0: 		mb.push(erdNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		mb.push(forUpdate);
0: 		closeMethodArgument(acb, mb);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getNormalizeResultSet",
0: 					ClassName.NoPutResultSet, 8);
0: 	}
0: 
0: 	/**
0: 	 * set the Information gathered from the parent table that is 
0: 	 * required to peform a referential action on dependent table.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setRefActionInfo(long fkIndexConglomId, 
0: 								 int[]fkColArray, 
0: 								 String parentResultSetId,
0: 								 boolean dependentScan)
0: 	{
0: 		childResult.setRefActionInfo(fkIndexConglomId,
0: 								   fkColArray,
0: 								   parentResultSetId,
0: 								   dependentScan);
0: 	}
0: 
0: 
0: }
============================================================================