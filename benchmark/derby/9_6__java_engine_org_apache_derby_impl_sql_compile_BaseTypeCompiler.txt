1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.BaseTypeCompiler
1:a57c280: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
6:eac0369:  */
28:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:afe6225: import org.apache.derby.iapi.reference.SQLState;
1:afe6225: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:afe6225: import org.apache.derby.iapi.services.loader.ClassFactory;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:afe6225: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:afe6225: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:afe6225: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
1:a57c280: /**
1:eac0369:  * This is the base implementation of TypeCompiler
1:869152f:  *
1:eac0369:  */
1:eac0369: 
1:509ccb9: abstract class BaseTypeCompiler implements TypeCompiler
7:eac0369: {
1:d7f7457: 	private TypeId correspondingTypeId;
1:44fad02: 
1:a57c280: 	/**
1:eac0369: 	 * Get the method name for getting out the corresponding primitive
1:eac0369: 	 * Java type.
1:a57c280: 	 *
1:eac0369: 	 * @return String		The method call name for getting the
1:eac0369: 	 *						corresponding primitive Java type.
1:eac0369: 	 */
1:eac0369: 	public String getPrimitiveMethodName()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("getPrimitiveMethodName not applicable for " +
1:eac0369: 									  getClass().toString());
1:44fad02: 		}
1:eac0369: 		return null;
1:44fad02: 	}
1:44fad02: 
1:ba7683c: 	/**
1:eac0369: 	 * @see TypeCompiler#resolveArithmeticOperation
1:ba7683c: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:ba7683c: 	 */
1:eac0369: 	public DataTypeDescriptor
1:eac0369: 	resolveArithmeticOperation(DataTypeDescriptor leftType,
1:eac0369: 								DataTypeDescriptor rightType,
1:eac0369: 								String operator)
1:eac0369: 							throws StandardException
1:44fad02: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
1:eac0369: 										operator,
1:eac0369: 										leftType.getTypeId().getSQLTypeName(),
1:eac0369: 										rightType.getTypeId().getSQLTypeName()
1:eac0369: 										);
9:eac0369: 	}
1:44fad02: 
1:44fad02:     /**
1:a57c280:      * The caller will have pushed a DataValueFactory and a null or a value
1:a57c280:      * of the correct type (interfaceName()). Thus upon entry the
1:a57c280:      * stack looks like on of:
1:a57c280:      * ...,dvf,ref
1:a57c280:      * ...,dvf,null
1:ba7683c:      * 
1:a57c280:      * This method then sets up to call the required method
1:a57c280:      * on DataValueFactory using the nullMethodName().
1:a57c280:      * The value left on the stack will be a DataValueDescriptor
1:a57c280:      * of the correct type:
1:ba7683c:      * 
1:a57c280:      * ...,dvd
1:a57c280:      * 
1:a1aaa63:      * @see TypeCompiler#generateNull(MethodBuilder, int)
1:a57c280:      */
1:a1aaa63: 	public void generateNull(MethodBuilder mb, int collationType)
1:44fad02: 	{
1:44fad02:         int argCount;
1:a1aaa63:         if (pushCollationForDataValue(collationType))
1:44fad02:         {
1:ba7683c:             mb.push(collationType);
1:44fad02:             argCount = 2;
1:ba7683c:         }
1:44fad02:         else
1:44fad02:             argCount = 1;
1:ba7683c:         
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:eac0369: 									nullMethodName(),
1:eac0369: 									interfaceName(),
1:44fad02:                                     argCount);
1:ba7683c: 	}
1:ba7683c: 
1:ba7683c:     
1:ba7683c:     /**
1:a57c280:      * The caller will have pushed a DataValueFactory and  value
1:a57c280:      * of that can be converted to the correct type, e.g. int
1:a57c280:      * for a SQL INTEGER.
1:ba7683c:      *  
1:a57c280:      * Thus upon entry the
1:a57c280:      * stack looks like:
1:a57c280:      * ...,dvf,value
1:a57c280:      * 
1:a57c280:      * If field is not null then it is used as the holder
1:a57c280:      * of the generated DataValueDescriptor to avoid object
1:a57c280:      * creations on multiple passes through this code.
1:a57c280:      * The field may contain null or a valid value.
1:a57c280:      * 
1:a57c280:      * This method then sets up to call the required method
1:a57c280:      * on DataValueFactory using the dataValueMethodName().
1:a57c280:      * The value left on the stack will be a DataValueDescriptor
1:a57c280:      * of the correct type:
1:a57c280:      * 
1:a57c280:      * If the field contained a valid value then generated
1:a57c280:      * code will return that value rather than a newly created
1:a57c280:      * object. If field was not-null then the generated code
1:a57c280:      * will set the value of field to be the return from
1:a57c280:      * the DataValueFactory method call. Thus if the field
1:a57c280:      * was empty (set to null) when this code is executed it
1:a57c280:      * will contain the newly generated value, otherwise it
1:a57c280:      * will be reset to the same value.
1:a57c280:      * 
1:a57c280:      * ...,dvd
1:a57c280:      * 
1:a1aaa63:      * @see TypeCompiler#generateDataValue(MethodBuilder, int, LocalField)
1:ba7683c:      */
1:ba7683c:     public void generateDataValue(MethodBuilder mb, int collationType,
1:a57c280: 			LocalField field)
1:ba7683c: 	{
1:ba7683c: 
1:44fad02:             
1:eac0369: 		String				interfaceName = interfaceName();
1:44fad02: 
1:eac0369: 		// push the second argument
1:eac0369: 
1:eac0369: 		/* If fieldName is null, then there is no
1:eac0369: 		 * reusable wrapper (null), else we
1:eac0369: 		 * reuse the field.
1:a57c280: 		 */
1:eac0369: 		if (field == null)
1:eac0369: 		{
1:eac0369: 			mb.pushNull(interfaceName);
1:ba7683c: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			mb.getField(field);
1:eac0369: 		}
1:44fad02:         
1:44fad02:         int argCount;
1:44fad02:         if (pushCollationForDataValue(collationType))
1:44fad02:         {
1:44fad02:             mb.push(collationType);
1:44fad02:             argCount = 3;
1:44fad02:         }
1:44fad02:         else
1:44fad02:             argCount = 2;
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:eac0369: 							dataValueMethodName(),
1:eac0369: 							interfaceName,
1:44fad02:                             argCount);
1:eac0369: 
1:eac0369: 		if (field != null)
1:eac0369: 		{
1:eac0369: 			/* Store the result of the method call in the field,
1:eac0369: 			 * so we can re-use the wrapper.
1:eac0369: 			 */
1:eac0369: 			mb.putField(field);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:cf58aec:     /**
1:44fad02:         Return the method name to get a Derby DataValueDescriptor
1:44fad02:         object of the correct type set to SQL NULL. The method named will
1:44fad02:         be called with one argument: a holder object if pushCollationForDataValue()
1:44fad02:         returns false, otherwise two arguments, the second being the
1:44fad02:         collationType.
1:44fad02:     */
1:44fad02:     abstract String nullMethodName();
1:eac0369: 
5:eac0369: 	/**
1:cf58aec: 		Return the method name to get a Derby DataValueDescriptor
1:44fad02: 		object of the correct type and set it to a specific value.
1:44fad02:         The method named will be called with two arguments, a value to set the
1:44fad02:         returned value to and a holder object if pushCollationForDataValue()
1:44fad02:         returns false. Otherwise three arguments, the third being the
1:44fad02:         collationType.
1:44fad02:         This implementation returns "getDataValue" to map
1:44fad02:         to the overloaded methods
1:44fad02:         DataValueFactory.getDataValue(type, dvd type)
1:cf58aec: 	*/
1:44fad02: 	String dataValueMethodName()
1:eac0369: 	{
1:eac0369: 		return "getDataValue";
1:eac0369: 	}
1:44fad02:     
1:44fad02:     /**
1:44fad02:      * Return true if the collationType is to be passed
1:44fad02:      * to the methods generated by generateNull and
1:44fad02:      * generateDataValue.
1:44fad02:      * 
1:44fad02:      * @param collationType Collation type of character values.
1:44fad02:      * @return true collationType will be pushed, false collationType will be ignored.
1:44fad02:      */
1:44fad02:     boolean pushCollationForDataValue(int collationType)
1:44fad02:     {
1:44fad02:         return false;
1:44fad02:     }
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Determine whether thisType is storable in otherType due to otherType
1:eac0369: 	 * being a user type.
1:a57c280: 	 *
1:eac0369: 	 * @param thisType	The TypeId of the value to be stored
1:eac0369: 	 * @param otherType	The TypeId of the value to be stored in
1:a57c280: 	 *
1:eac0369: 	 * @return	true if thisType is storable in otherType
1:eac0369: 	 */
1:eac0369: 	protected boolean userTypeStorable(TypeId thisType,
1:eac0369: 							TypeId otherType,
2:eac0369: 							ClassFactory cf)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** If the other type is user-defined, use the java types to determine
1:eac0369: 		** assignability.
1:eac0369: 		*/
1:08d6ce2: 		if (otherType.userType())
1:eac0369: 		{
1:eac0369: 			return cf.getClassInspector().assignableTo(
1:eac0369: 					thisType.getCorrespondingJavaTypeName(),
1:eac0369: 					otherType.getCorrespondingJavaTypeName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this numeric type can be converted to the given type.
7:eac0369: 	 *
2:eac0369: 	 * @param otherType	The TypeId of the other type.
1:eac0369: 	 * @param forDataTypeFunction  was this called from a scalarFunction like
1:eac0369: 	 *                             CHAR() or DOUBLE()
1:eac0369: 	 */
1:3bb140c:     boolean numberConvertible(TypeId otherType,
1:eac0369: 									 boolean forDataTypeFunction)
1:eac0369: 	{
1:30fa79b:         if ( otherType.getBaseTypeId().isAnsiUDT() ) { return false; }
1:30fa79b: 
1:eac0369: 		// Can't convert numbers to long types
1:eac0369: 		if (otherType.isLongConcatableTypeId())
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		// Numbers can only be converted to other numbers, 
1:eac0369: 		// and CHAR, (not VARCHARS or LONGVARCHAR). 
1:eac0369: 		// Only with the CHAR() or VARCHAR()function can they be converted.
1:eac0369: 		boolean retval =((otherType.isNumericTypeId()) ||
1:eac0369: 						 (otherType.userType()));
1:eac0369: 
1:eac0369: 		// For CHAR  Conversions, function can convert 
1:eac0369: 		// Floating types
1:eac0369: 		if (forDataTypeFunction)
1:eac0369: 			retval = retval || 
1:eac0369: 				(otherType.isFixedStringTypeId() &&
1:d7f7457: 				(getTypeId().isFloatingPointTypeId()));
1:eac0369: 	   
1:eac0369: 		retval = retval ||
1:eac0369: 			(otherType.isFixedStringTypeId() && 					  
1:d7f7457: 			 (!getTypeId().isFloatingPointTypeId()));
1:eac0369: 		
1:eac0369: 		return retval;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tell whether this numeric type can be stored into from the given type.
1:eac0369: 	 *
1:eac0369: 	 * @param thisType	The TypeId of this type
1:eac0369: 	 * @param otherType	The TypeId of the other type.
1:eac0369: 	 * @param cf		A ClassFactory
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     boolean numberStorable(TypeId thisType,
1:eac0369: 									TypeId otherType,
1:eac0369: 									ClassFactory cf)
1:eac0369: 	{
1:30fa79b:         if ( otherType.getBaseTypeId().isAnsiUDT() ) { return false; }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Numbers can be stored into from other number types.
1:eac0369: 		** Also, user types with compatible classes can be stored into numbers.
1:eac0369: 		*/
1:07d1108: 		if (otherType.isNumericTypeId()) { return true; }
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If the other type is user-defined, use the java types to determine
1:eac0369: 		** assignability.
1:eac0369: 		*/
1:eac0369: 		return userTypeStorable(thisType, otherType, cf);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeId that corresponds to this TypeCompiler.
1:eac0369: 	 */
1:eac0369: 	protected TypeId getTypeId()
1:eac0369: 	{
1:eac0369: 		return correspondingTypeId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeCompiler that corresponds to the given TypeId.
1:eac0369: 	 */
1:eac0369: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
1:eac0369: 	{
1:eac0369: 		return TypeCompilerFactoryImpl.staticGetTypeCompiler(typeId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the TypeCompiler that corresponds to the given TypeId.
1:eac0369: 	 */
1:eac0369: 	void setTypeId(TypeId typeId)
1:eac0369: 	{
1:eac0369: 		correspondingTypeId = typeId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the StoredFormatId from the corresponding
1:eac0369: 	 * TypeId.
1:eac0369: 	 *
1:eac0369: 	 * @return The StoredFormatId from the corresponding
1:eac0369: 	 * TypeId.
1:eac0369: 	 */
1:eac0369: 	protected int getStoredFormatIdFromTypeId()
1:eac0369: 	{
1:d7f7457: 		return getTypeId().getTypeFormatId();
1:44fad02: 	}
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1:     boolean numberConvertible(TypeId otherType,
/////////////////////////////////////////////////////////////////////////
1:     boolean numberStorable(TypeId thisType,
commit:afe6225
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:30fa79b
/////////////////////////////////////////////////////////////////////////
1:         if ( otherType.getBaseTypeId().isAnsiUDT() ) { return false; }
/////////////////////////////////////////////////////////////////////////
1:         if ( otherType.getBaseTypeId().isAnsiUDT() ) { return false; }
1: 
commit:07d1108
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (otherType.isNumericTypeId()) { return true; }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:111785f
/////////////////////////////////////////////////////////////////////////
commit:869152f
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeCompiler#generateNull(ExpressionClassBuilder, MethodBuilder, int, String)*/
0: 	public void generateNull(ExpressionClassBuilder e,
0: 			MethodBuilder mb, int collationType, 
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeCompiler#generateDataValue(ExpressionClassBuilder, MethodBuilder, int, String, LocalField) */
0: 	public void generateDataValue(ExpressionClassBuilder eb,
0: 			MethodBuilder mb, int collationType,
/////////////////////////////////////////////////////////////////////////
1: 	 *
0: 	 * @param eb The ExpressionClassBuilder for the class we're generating
/////////////////////////////////////////////////////////////////////////
0: 	protected void generateCollationSensitiveDataValue(
0: 			ExpressionClassBuilder eb,
0: 			MethodBuilder mb, 
/////////////////////////////////////////////////////////////////////////
0: 		eb.pushDataValueFactory(mb);
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeCompiler#generateNull(MethodBuilder, int, String) */
0: 	public void generateNull(MethodBuilder mb, int collationType, 
0: 			String className)
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeCompiler#generateDataValue(MethodBuilder, int, String, LocalField) */
1: 	public void generateDataValue(MethodBuilder mb, int collationType,
0: 			String className, LocalField field)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * If the collation type is UCS_BASIC, then we have already generated the
0: 	 * code for the correct DVD and hence simply return from this method. 
1: 	 * 
0: 	 * But if the collation type is territory based and we are generating DVDs
0: 	 * for character types, then we need to generate CollatorSQLxxx type of 
0: 	 * DVD. This CollatorSQLxxx DVD will be provided by generating following 
0: 	 * code which works on top of the DVD that has been generated with 
0: 	 * UCS_BASIC collation.
0: 	 * DVDwithUCS_BASIC.getValue(DVF.getCharacterCollator(collationType));
1: 	 * 
0: 	 * This method will be called only by CharTypeCompiler and ClobTypeCompiler 
0: 	 * because those are the only type compilers who generate DVDs which are 
0: 	 * impacted by the collation. Rest of the TypeCompilers generate DVDs which
0: 	 * are collation in-sensitive.
1: 	 * 
0: 	 * @param mb The method to put the expression in
0: 	 * @param collationType For character DVDs, this will be used to determine
0: 	 *   what Collator should be associated with the DVD which in turn will 
0: 	 *   decide whether to generate CollatorSQLcharDVDs or SQLcharDVDs. For 
0: 	 *   other types of DVDs, this parameter will be ignored.
0: 	 * @param className name of the base class of the activation's hierarchy
1: 	 */
0: 	protected void generateCollationSensitiveDataValue(MethodBuilder mb, 
0: 			int collationType, String className){		
0: 		if (collationType == StringDataValue.COLLATION_TYPE_UCS_BASIC)
0: 			return; 
0: 		//In case of character DVDs, for territory based collation, we need to 
0: 		//generate DVDs with territory based RuleBasedCollator and hence we 
0: 		//need to generate CollatorSQLChar/CollatorSQLVarchar/
0: 		//CollatorSQLLongvarchar/CollatorSQLClob 
0: 		pushDataValueFactory(mb, className);
1: 		mb.push(collationType);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getCharacterCollator",
0: 				"java.text.RuleBasedCollator", 1);
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, null, "getValue", interfaceName(), 1);
1: 	}
1: 	
0: 	private Object getDVF;
1: 	/**
0: 	 * This method will push a DVF on the stack. This DVF is required to get
0: 	 * the territory based collator using the collation type. In other words,
0: 	 * this DVF will be used to generate something like following
0: 	 * DVF.getCharacterCollator(collationType)
1: 	 * 
0: 	 * @param mb The method to put the expression in
0: 	 * @param className name of the base class of the activation's hierarchy
1: 	 */
0: 	private void pushDataValueFactory(MethodBuilder mb, String className)
1: 	{
0: 		// generates:
0: 		//	   getDataValueFactory()
0: 		//
1: 
0: 		if (getDVF == null) {
0: 			getDVF = mb.describeMethod(VMOpcode.INVOKEVIRTUAL,
0: 										className,
0: 										"getDataValueFactory",
0: 										ClassName.DataValueFactory);
1: 		}
1: 
0: 		mb.pushThis();
0: 		mb.callMethod(getDVF);
1: 	}
1: 
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a1aaa63
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @see TypeCompiler#generateNull(MethodBuilder, int)
1: 	public void generateNull(MethodBuilder mb, int collationType)
1:         if (pushCollationForDataValue(collationType))
/////////////////////////////////////////////////////////////////////////
1:      * @see TypeCompiler#generateDataValue(MethodBuilder, int, LocalField)
0:     public void generateDataValue(MethodBuilder mb, int collationType,
/////////////////////////////////////////////////////////////////////////
commit:44fad02
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.SQLInteger;
/////////////////////////////////////////////////////////////////////////
1:         int argCount;
0:         if (false & pushCollationForDataValue(collationType))
1:         {
1:             mb.push(collationType);
1:             argCount = 2;
1:         }
1:         else
1:             argCount = 1;
1:         
1:                                     argCount);
/////////////////////////////////////////////////////////////////////////
1: 
1:             
/////////////////////////////////////////////////////////////////////////
1:         
1:         int argCount;
1:         if (pushCollationForDataValue(collationType))
1:         {
0:             mb.push(collationType);
1:             argCount = 3;
1:         }
1:         else
1:             argCount = 2;
1:                             argCount);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:         Return the method name to get a Derby DataValueDescriptor
1:         object of the correct type set to SQL NULL. The method named will
1:         be called with one argument: a holder object if pushCollationForDataValue()
1:         returns false, otherwise two arguments, the second being the
1:         collationType.
1:     */
1:     abstract String nullMethodName();
1: 		object of the correct type and set it to a specific value.
1:         The method named will be called with two arguments, a value to set the
1:         returned value to and a holder object if pushCollationForDataValue()
1:         returns false. Otherwise three arguments, the third being the
1:         collationType.
1:         This implementation returns "getDataValue" to map
1:         to the overloaded methods
1:         DataValueFactory.getDataValue(type, dvd type)
1: 	String dataValueMethodName()
1:     
1:     /**
1:      * Return true if the collationType is to be passed
1:      * to the methods generated by generateNull and
1:      * generateDataValue.
1:      * 
1:      * @param collationType Collation type of character values.
1:      * @return true collationType will be pushed, false collationType will be ignored.
1:      */
1:     boolean pushCollationForDataValue(int collationType)
1:     {
1:         return false;
1:     }
/////////////////////////////////////////////////////////////////////////
0:     private static DataValueDescriptor gnn(DataValueFactory dvf)
1:     {
0:         return dvf.getNullInteger((NumberDataValue) null);
1:     }
1:     
0:     private static DataValueDescriptor gnn2(DataValueFactory dvf)
1:     {
0:         return new SQLInteger();
1:     }
1:     
commit:a57c280
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The caller will have pushed a DataValueFactory and a null or a value
1:      * of the correct type (interfaceName()). Thus upon entry the
1:      * stack looks like on of:
1:      * ...,dvf,ref
1:      * ...,dvf,null
1:      * 
1:      * This method then sets up to call the required method
1:      * on DataValueFactory using the nullMethodName().
1:      * The value left on the stack will be a DataValueDescriptor
1:      * of the correct type:
1:      * 
1:      * ...,dvd
1:      * 
0:      * @see TypeCompiler#generateNull(ExpressionClassBuilder, MethodBuilder, int)
1:      */
0: 			MethodBuilder mb, int collationType)
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * The caller will have pushed a DataValueFactory and  value
1:      * of that can be converted to the correct type, e.g. int
1:      * for a SQL INTEGER.
1:      *  
1:      * Thus upon entry the
1:      * stack looks like:
1:      * ...,dvf,value
1:      * 
1:      * If field is not null then it is used as the holder
1:      * of the generated DataValueDescriptor to avoid object
1:      * creations on multiple passes through this code.
1:      * The field may contain null or a valid value.
1:      * 
1:      * This method then sets up to call the required method
1:      * on DataValueFactory using the dataValueMethodName().
1:      * The value left on the stack will be a DataValueDescriptor
1:      * of the correct type:
1:      * 
1:      * If the field contained a valid value then generated
1:      * code will return that value rather than a newly created
1:      * object. If field was not-null then the generated code
1:      * will set the value of field to be the return from
1:      * the DataValueFactory method call. Thus if the field
1:      * was empty (set to null) when this code is executed it
1:      * will contain the newly generated value, otherwise it
1:      * will be reset to the same value.
1:      * 
1:      * ...,dvd
1:      * 
0:      * @see TypeCompiler#generateDataValue(ExpressionClassBuilder, MethodBuilder, int, LocalField)
1:      */
0:     public void generateDataValue(ExpressionClassBuilder eb,
1: 			LocalField field)
/////////////////////////////////////////////////////////////////////////
0: 	void generateCollationSensitiveDataValue(
0: 			int collationType){		
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (otherType.userType())
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
1: 	private TypeId correspondingTypeId;
/////////////////////////////////////////////////////////////////////////
0: 	public void generateDataValue(MethodBuilder mb,
/////////////////////////////////////////////////////////////////////////
1: 				(getTypeId().isFloatingPointTypeId()));
1: 			 (!getTypeId().isFloatingPointTypeId()));
/////////////////////////////////////////////////////////////////////////
1: 		return getTypeId().getTypeFormatId();
commit:cf58aec
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 		Return the method name to get a Derby DataValueDescriptor
0: 		object of the correct type. This implementation returns "getDataValue".
1: 	*/
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
1: abstract class BaseTypeCompiler implements TypeCompiler
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.BaseTypeCompiler
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.sql.Types;
1: 
1: /**
1:  * This is the base implementation of TypeCompiler
1:  *
0:  * @author Jeff
1:  */
1: 
0: public abstract class BaseTypeCompiler implements TypeCompiler
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	TypeId correspondingTypeId;
1: 
1: 	/**
1: 	 * Get the method name for getting out the corresponding primitive
1: 	 * Java type.
1: 	 *
1: 	 * @return String		The method call name for getting the
1: 	 *						corresponding primitive Java type.
1: 	 */
1: 	public String getPrimitiveMethodName()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("getPrimitiveMethodName not applicable for " +
1: 									  getClass().toString());
1: 		}
1: 		return null;
1: 	}
1: 
0: 	/** @see TypeCompiler#getMatchingNationalCharTypeName */
0: 	public String getMatchingNationalCharTypeName()
1: 	{
0: 		return TypeId.NATIONAL_CHAR_NAME;
1: 	}
1: 
1: 
1: 	/**
1: 	 * @see TypeCompiler#resolveArithmeticOperation
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataTypeDescriptor
1: 	resolveArithmeticOperation(DataTypeDescriptor leftType,
1: 								DataTypeDescriptor rightType,
1: 								String operator)
1: 							throws StandardException
1: 	{
1: 		throw StandardException.newException(SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
1: 										operator,
1: 										leftType.getTypeId().getSQLTypeName(),
1: 										rightType.getTypeId().getSQLTypeName()
1: 										);
1: 	}
1: 
0: 	/** @see TypeCompiler#generateNull */
1: 
0: 	public void generateNull(MethodBuilder mb)
1: 	{
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1: 									nullMethodName(),
1: 									interfaceName(),
0: 									1);
1: 	}
1: 
0: 	/** @see TypeCompiler#generateDataValue */
0: 	public final void generateDataValue(MethodBuilder mb,
0: 										LocalField field)
1: 	{
1: 		String				interfaceName = interfaceName();
1: 
0: 		if (this instanceof UserDefinedTypeCompiler)
1: 		{
0: 			// cast the value to an object for method resolution
0: 			mb.upCast("java.lang.Object");
1: 		}
1: 
1: 		// push the second argument
1: 
1: 		/* If fieldName is null, then there is no
1: 		 * reusable wrapper (null), else we
1: 		 * reuse the field.
1: 		 */
1: 		if (field == null)
1: 		{
1: 			mb.pushNull(interfaceName);
1: 		}
1: 		else
1: 		{
1: 			mb.getField(field);
1: 		}
1: 
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1: 							dataValueMethodName(),
1: 							interfaceName,
0: 							2);
1: 
1: 		if (field != null)
1: 		{
1: 			/* Store the result of the method call in the field,
1: 			 * so we can re-use the wrapper.
1: 			 */
1: 			mb.putField(field);
1: 		}
1: 	}
1: 
0: 	protected abstract String nullMethodName();
1: 
0: 	protected String dataValueMethodName()
1: 	{
1: 		return "getDataValue";
1: 	}
1: 
1: 	
1: 	/**
1: 	 * Determine whether thisType is storable in otherType due to otherType
1: 	 * being a user type.
1: 	 *
1: 	 * @param thisType	The TypeId of the value to be stored
1: 	 * @param otherType	The TypeId of the value to be stored in
0: 	 * @param cm		Current ContextManager
1: 	 *
1: 	 * @return	true if thisType is storable in otherType
1: 	 */
1: 	protected boolean userTypeStorable(TypeId thisType,
1: 							TypeId otherType,
1: 							ClassFactory cf)
1: 	{
1: 		/*
1: 		** If the other type is user-defined, use the java types to determine
1: 		** assignability.
1: 		*/
0: 		if ( ! otherType.builtIn())
1: 		{
1: 			return cf.getClassInspector().assignableTo(
1: 					thisType.getCorrespondingJavaTypeName(),
1: 					otherType.getCorrespondingJavaTypeName());
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	 * Tell whether this numeric type can be compared to the given type.
1: 	 *
1: 	 * @param otherType	The TypeId of the other type.
1: 	 */
1: 
0: 	public boolean numberComparable(TypeId otherType,
0: 									boolean forEquals,
1: 									ClassFactory cf)
1: 	{
0: 		TypeCompiler otherTC = getTypeCompiler(otherType);
1: 
0: 		/* Numbers can be compared to other numbers, 
0: 		 * boolean and objects
1: 		 */
0: 		return otherType.isNumericTypeId() ||
0: 				otherType.isBooleanTypeId() ||
0: 				(otherType.userType() && otherTC.comparable(otherType,
0: 															forEquals,
0: 															cf));
1: 	}
1: 
1: 	
1: 	/**
1: 	 * Tell whether this numeric type can be converted to the given type.
1: 	 *
1: 	 * @param otherType	The TypeId of the other type.
1: 	 * @param forDataTypeFunction  was this called from a scalarFunction like
1: 	 *                             CHAR() or DOUBLE()
1: 	 */
0: 	public boolean numberConvertible(TypeId otherType, 
1: 									 boolean forDataTypeFunction)
1: 	{
1: 
1: 		// Can't convert numbers to long types
1: 		if (otherType.isLongConcatableTypeId())
1: 			return false;
1: 
1: 		// Numbers can only be converted to other numbers, 
1: 		// and CHAR, (not VARCHARS or LONGVARCHAR). 
1: 		// Only with the CHAR() or VARCHAR()function can they be converted.
1: 		boolean retval =((otherType.isNumericTypeId()) ||
0: 						 (otherType.isBooleanTypeId()) ||
1: 						 (otherType.userType()));
1: 
1: 		// For CHAR  Conversions, function can convert 
1: 		// Floating types
1: 		if (forDataTypeFunction)
1: 			retval = retval || 
1: 				(otherType.isFixedStringTypeId() &&
0: 				(correspondingTypeId.isFloatingPointTypeId()));
1: 	   
1: 		retval = retval ||
1: 			(otherType.isFixedStringTypeId() && 					  
0: 			 (!correspondingTypeId.isFloatingPointTypeId()));
1: 		
1: 		return retval;
1: 
1: 	}
1: 
1: 	/**
1: 	 * Tell whether this numeric type can be stored into from the given type.
1: 	 *
1: 	 * @param thisType	The TypeId of this type
1: 	 * @param otherType	The TypeId of the other type.
1: 	 * @param cf		A ClassFactory
1: 	 */
1: 
0: 	public boolean numberStorable(TypeId thisType,
1: 									TypeId otherType,
1: 									ClassFactory cf)
1: 	{
1: 		/*
1: 		** Numbers can be stored into from other number types.
1: 		** Also, user types with compatible classes can be stored into numbers.
1: 		*/
0: 		if ((otherType.isNumericTypeId())	||
0: 			(otherType.isBooleanTypeId()))
0: 			return true;
1: 
1: 		/*
1: 		** If the other type is user-defined, use the java types to determine
1: 		** assignability.
1: 		*/
1: 		return userTypeStorable(thisType, otherType, cf);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the TypeId that corresponds to this TypeCompiler.
1: 	 */
1: 	protected TypeId getTypeId()
1: 	{
1: 		return correspondingTypeId;
1: 	}
1: 
1: 	/**
1: 	 * Get the TypeCompiler that corresponds to the given TypeId.
1: 	 */
1: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
1: 	{
1: 		return TypeCompilerFactoryImpl.staticGetTypeCompiler(typeId);
1: 	}
1: 
1: 	/**
1: 	 * Set the TypeCompiler that corresponds to the given TypeId.
1: 	 */
1: 	void setTypeId(TypeId typeId)
1: 	{
1: 		correspondingTypeId = typeId;
1: 	}
1: 
1: 	/**
1: 	 * Get the StoredFormatId from the corresponding
1: 	 * TypeId.
1: 	 *
1: 	 * @return The StoredFormatId from the corresponding
1: 	 * TypeId.
1: 	 */
1: 	protected int getStoredFormatIdFromTypeId()
1: 	{
0: 		return correspondingTypeId.getTypeFormatId();
1: 	}
1: 
1: 
1: }
1: 
1: 
1: 
1: 
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.types.BitDataValue;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.sql.Types;
0: 
0: /**
0:  * This is the base implementation of TypeCompiler
0:  *
0:  * @author Jeff
0:  */
0: 
0: public abstract class BaseTypeCompiler implements TypeCompiler
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	TypeId correspondingTypeId;
0: 
0: 	/**
0: 	 * Get the method name for getting out the corresponding primitive
0: 	 * Java type.
0: 	 *
0: 	 * @return String		The method call name for getting the
0: 	 *						corresponding primitive Java type.
0: 	 */
0: 	public String getPrimitiveMethodName()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("getPrimitiveMethodName not applicable for " +
0: 									  getClass().toString());
0: 		}
0: 		return null;
0: 	}
0: 
0: 	/** @see TypeCompiler#getMatchingNationalCharTypeName */
0: 	public String getMatchingNationalCharTypeName()
0: 	{
0: 		return TypeId.NATIONAL_CHAR_NAME;
0: 	}
0: 
0: 
0: 	/**
0: 	 * @see TypeCompiler#resolveArithmeticOperation
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataTypeDescriptor
0: 	resolveArithmeticOperation(DataTypeDescriptor leftType,
0: 								DataTypeDescriptor rightType,
0: 								String operator)
0: 							throws StandardException
0: 	{
0: 		throw StandardException.newException(SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
0: 										operator,
0: 										leftType.getTypeId().getSQLTypeName(),
0: 										rightType.getTypeId().getSQLTypeName()
0: 										);
0: 	}
0: 
0: 	/** @see TypeCompiler#generateNull */
0: 
0: 	public void generateNull(MethodBuilder mb)
0: 	{
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
0: 									nullMethodName(),
0: 									interfaceName(),
0: 									1);
0: 	}
0: 
0: 	/** @see TypeCompiler#generateDataValue */
0: 	public final void generateDataValue(MethodBuilder mb,
0: 										LocalField field)
0: 	{
0: 		String				interfaceName = interfaceName();
0: 
0: 		if (this instanceof UserDefinedTypeCompiler)
0: 		{
0: 			// cast the value to an object for method resolution
0: 			mb.upCast("java.lang.Object");
0: 		}
0: 
0: 		// push the second argument
0: 
0: 		/* If fieldName is null, then there is no
0: 		 * reusable wrapper (null), else we
0: 		 * reuse the field.
0: 		 */
0: 		if (field == null)
0: 		{
0: 			mb.pushNull(interfaceName);
0: 		}
0: 		else
0: 		{
0: 			mb.getField(field);
0: 		}
0: 
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
0: 							dataValueMethodName(),
0: 							interfaceName,
0: 							2);
0: 
0: 		if (field != null)
0: 		{
0: 			/* Store the result of the method call in the field,
0: 			 * so we can re-use the wrapper.
0: 			 */
0: 			mb.putField(field);
0: 		}
0: 	}
0: 
0: 	protected abstract String nullMethodName();
0: 
0: 	protected String dataValueMethodName()
0: 	{
0: 		return "getDataValue";
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Determine whether thisType is storable in otherType due to otherType
0: 	 * being a user type.
0: 	 *
0: 	 * @param thisType	The TypeId of the value to be stored
0: 	 * @param otherType	The TypeId of the value to be stored in
0: 	 * @param cm		Current ContextManager
0: 	 *
0: 	 * @return	true if thisType is storable in otherType
0: 	 */
0: 	protected boolean userTypeStorable(TypeId thisType,
0: 							TypeId otherType,
0: 							ClassFactory cf)
0: 	{
0: 		/*
0: 		** If the other type is user-defined, use the java types to determine
0: 		** assignability.
0: 		*/
0: 		if ( ! otherType.builtIn())
0: 		{
0: 			return cf.getClassInspector().assignableTo(
0: 					thisType.getCorrespondingJavaTypeName(),
0: 					otherType.getCorrespondingJavaTypeName());
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Tell whether this numeric type can be compared to the given type.
0: 	 *
0: 	 * @param otherType	The TypeId of the other type.
0: 	 */
0: 
0: 	public boolean numberComparable(TypeId otherType,
0: 									boolean forEquals,
0: 									ClassFactory cf)
0: 	{
0: 		TypeCompiler otherTC = getTypeCompiler(otherType);
0: 
0: 		/* Numbers can be compared to other numbers, 
0: 		 * boolean and objects
0: 		 */
0: 		return otherType.isNumericTypeId() ||
0: 				otherType.isBooleanTypeId() ||
0: 				(otherType.userType() && otherTC.comparable(otherType,
0: 															forEquals,
0: 															cf));
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Tell whether this numeric type can be converted to the given type.
0: 	 *
0: 	 * @param otherType	The TypeId of the other type.
0: 	 * @param forDataTypeFunction  was this called from a scalarFunction like
0: 	 *                             CHAR() or DOUBLE()
0: 	 */
0: 	public boolean numberConvertible(TypeId otherType, 
0: 									 boolean forDataTypeFunction)
0: 	{
0: 
0: 		// Can't convert numbers to long types
0: 		if (otherType.isLongConcatableTypeId())
0: 			return false;
0: 
0: 		// Numbers can only be converted to other numbers, 
0: 		// and CHAR, (not VARCHARS or LONGVARCHAR). 
0: 		// Only with the CHAR() or VARCHAR()function can they be converted.
0: 		boolean retval =((otherType.isNumericTypeId()) ||
0: 						 (otherType.isBooleanTypeId()) ||
0: 						 (otherType.userType()));
0: 
0: 		// For CHAR  Conversions, function can convert 
0: 		// Floating types
0: 		if (forDataTypeFunction)
0: 			retval = retval || 
0: 				(otherType.isFixedStringTypeId() &&
0: 				(correspondingTypeId.isFloatingPointTypeId()));
0: 	   
0: 		retval = retval ||
0: 			(otherType.isFixedStringTypeId() && 					  
0: 			 (!correspondingTypeId.isFloatingPointTypeId()));
0: 		
0: 		return retval;
0: 
0: 	}
0: 
0: 	/**
0: 	 * Tell whether this numeric type can be stored into from the given type.
0: 	 *
0: 	 * @param thisType	The TypeId of this type
0: 	 * @param otherType	The TypeId of the other type.
0: 	 * @param cf		A ClassFactory
0: 	 */
0: 
0: 	public boolean numberStorable(TypeId thisType,
0: 									TypeId otherType,
0: 									ClassFactory cf)
0: 	{
0: 		/*
0: 		** Numbers can be stored into from other number types.
0: 		** Also, user types with compatible classes can be stored into numbers.
0: 		*/
0: 		if ((otherType.isNumericTypeId())	||
0: 			(otherType.isBooleanTypeId()))
0: 			return true;
0: 
0: 		/*
0: 		** If the other type is user-defined, use the java types to determine
0: 		** assignability.
0: 		*/
0: 		return userTypeStorable(thisType, otherType, cf);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the TypeId that corresponds to this TypeCompiler.
0: 	 */
0: 	protected TypeId getTypeId()
0: 	{
0: 		return correspondingTypeId;
0: 	}
0: 
0: 	/**
0: 	 * Get the TypeCompiler that corresponds to the given TypeId.
0: 	 */
0: 	protected TypeCompiler getTypeCompiler(TypeId typeId)
0: 	{
0: 		return TypeCompilerFactoryImpl.staticGetTypeCompiler(typeId);
0: 	}
0: 
0: 	/**
0: 	 * Set the TypeCompiler that corresponds to the given TypeId.
0: 	 */
0: 	void setTypeId(TypeId typeId)
0: 	{
0: 		correspondingTypeId = typeId;
0: 	}
0: 
0: 	/**
0: 	 * Get the StoredFormatId from the corresponding
0: 	 * TypeId.
0: 	 *
0: 	 * @return The StoredFormatId from the corresponding
0: 	 * TypeId.
0: 	 */
0: 	protected int getStoredFormatIdFromTypeId()
0: 	{
0: 		return correspondingTypeId.getTypeFormatId();
0: 	}
0: 
0: 
0: }
0: 
0: 
0: 
0: 
0: 
============================================================================