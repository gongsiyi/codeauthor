1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.GenericStatement
1:345de35: 
1:67c1c96:    Licensed to the Apache Software Foundation (ASF) under one or more
1:67c1c96:    contributor license agreements.  See the NOTICE file distributed with
1:67c1c96:    this work for additional information regarding copyright ownership.
1:67c1c96:    The ASF licenses this file to you under the Apache License, Version 2.0
1:67c1c96:    (the "License"); you may not use this file except in compliance with
1:67c1c96:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
23:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql;
1:eac0369: 
1:dee279c: import java.sql.Timestamp;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:dee279c: import org.apache.derby.iapi.reference.SQLState;
1:47eac7d: import org.apache.derby.iapi.services.daemon.IndexStatisticsDaemon;
1:eac0369: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:dee279c: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:dee279c: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:dee279c: import org.apache.derby.iapi.sql.PreparedStatement;
1:dee279c: import org.apache.derby.iapi.sql.Statement;
1:dee279c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:dee279c: import org.apache.derby.iapi.sql.compile.Parser;
1:3ff5ce3: import org.apache.derby.iapi.sql.compile.Visitable;
1:3ff5ce3: import org.apache.derby.iapi.sql.compile.ASTVisitor;
1:dee279c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:dee279c: import org.apache.derby.iapi.sql.conn.StatementContext;
1:dee279c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:dee279c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:47eac7d: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:dee279c: import org.apache.derby.impl.sql.compile.StatementNode;
1:dee279c: import org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext;
1:38f02ec: import org.apache.derby.iapi.transaction.TransactionControl;
1:5d97422: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:eac0369: public class GenericStatement
1:eac0369: 	implements Statement {
1:eac0369: 
1:eac0369: 	// these fields define the identity of the statement
1:eac0369: 	private final SchemaDescriptor compilationSchema;
1:eac0369: 	private final String			statementText;
1:5087be8:         private final boolean isForReadOnly;
1:eac0369: 	private int                      prepareIsolationLevel;
1:eac0369: 	private GenericPreparedStatement preparedStmt;
1:eac0369: 
2:eac0369: 	/**
1:eac0369: 	 * Constructor for a Statement given the text of the statement in a String
1:6b50965: 	 * @param compilationSchema schema
1:eac0369: 	 * @param statementText	The text of the statement
1:5087be8: 	 * @param isForReadOnly if the statement is opened with level CONCUR_READ_ONLY
1:eac0369: 	 */
1:eac0369: 
1:5087be8: 	public GenericStatement(SchemaDescriptor compilationSchema, String statementText, boolean isForReadOnly)
7:eac0369: 	{
1:eac0369: 		this.compilationSchema = compilationSchema;
1:eac0369: 		this.statementText = statementText;
1:5087be8: 		this.isForReadOnly = isForReadOnly;
10:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Statement interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/* RESOLVE: may need error checking, debugging code here */
1:eac0369: 	public PreparedStatement prepare(LanguageConnectionContext lcc) throws StandardException
1:7fc54b9: 	{
1:eac0369: 		/*
1:eac0369: 		** Note: don't reset state since this might be
1:eac0369: 		** a recompilation of an already prepared statement.
1:eac0369: 		*/ 
1:be1b5ea: 		return prepare(lcc, false);
1:eac0369: 	}
1:2dc0b91: 	public PreparedStatement prepare(LanguageConnectionContext lcc, boolean forMetaData) throws StandardException
1:7fc54b9: 	{
1:2dc0b91: 		/*
1:2dc0b91: 		** Note: don't reset state since this might be
1:2dc0b91: 		** a recompilation of an already prepared statement.
1:eac0369: 		*/ 
1:be1b5ea: 
1:be1b5ea:         final int depth = lcc.getStatementDepth();
1:878e211:         String prevErrorId = null;
1:be1b5ea:         while (true) {
1:878e211:             boolean recompile = false;
1:be1b5ea:             try {
1:be1b5ea:                 return prepMinion(lcc, true, (Object[]) null,
1:be1b5ea:                                   (SchemaDescriptor) null, forMetaData);
1:878e211:             } catch (StandardException se) {
1:878e211:                 // There is a chance that we didn't see the invalidation
1:878e211:                 // request from a DDL operation in another thread because
1:878e211:                 // the statement wasn't registered as a dependent until
1:878e211:                 // after the invalidation had been completed. Assume that's
1:878e211:                 // what has happened if we see a conglomerate does not exist
1:878e211:                 // error, and force a retry even if the statement hasn't been
1:878e211:                 // invalidated.
1:878e211:                 if (SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST.equals(
1:878e211:                         se.getMessageId())) {
1:878e211:                     // STORE_CONGLOMERATE_DOES_NOT_EXIST has exactly one
1:878e211:                     // argument: the conglomerate id
1:878e211:                     String conglomId = String.valueOf(se.getArguments()[0]);
1:be1b5ea: 
1:878e211:                     // Request a recompile of the statement if a conglomerate
1:878e211:                     // disappears while we are compiling it. But if we have
1:878e211:                     // already retried once because the same conglomerate was
1:878e211:                     // missing, there's probably no hope that yet another retry
1:878e211:                     // will help, so let's break out instead of potentially
1:878e211:                     // looping infinitely.
1:878e211:                     if (!conglomId.equals(prevErrorId)) {
1:878e211:                         recompile = true;
1:878e211:                     }
1:878e211: 
1:878e211:                     prevErrorId = conglomId;
1:878e211:                 }
1:878e211:                 throw se;
1:878e211:             } finally {
1:be1b5ea:                 // Check if the statement was invalidated while it was
1:be1b5ea:                 // compiled. If so, the newly compiled plan may not be
1:be1b5ea:                 // up to date anymore, so we recompile the statement
1:be1b5ea:                 // if this happens. Note that this is checked in a finally
1:be1b5ea:                 // block, so we also retry if an exception was thrown. The
1:be1b5ea:                 // exception was probably thrown because of the changes
1:be1b5ea:                 // that invalidated the statement. If not, recompiling
1:be1b5ea:                 // will also fail, and the exception will be exposed to
1:be1b5ea:                 // the caller.
1:be1b5ea:                 //
1:be1b5ea:                 // invalidatedWhileCompiling and isValid are protected by
1:be1b5ea:                 // synchronization on the prepared statement.
1:be1b5ea:                 synchronized (preparedStmt) {
1:878e211:                     if (recompile || preparedStmt.invalidatedWhileCompiling) {
1:be1b5ea:                         preparedStmt.isValid = false;
1:be1b5ea:                         preparedStmt.invalidatedWhileCompiling = false;
1:be1b5ea:                         recompile = true;
1:be1b5ea:                     }
1:be1b5ea:                 }
1:be1b5ea: 
1:be1b5ea:                 if (recompile) {
1:be1b5ea:                     // A new statement context is pushed while compiling.
1:be1b5ea:                     // Typically, this context is popped by an error
1:be1b5ea:                     // handler at a higher level. But since we retry the
1:be1b5ea:                     // compilation, the error handler won't be invoked, so
1:be1b5ea:                     // the stack must be reset to its original state first.
1:be1b5ea:                     while (lcc.getStatementDepth() > depth) {
1:be1b5ea:                         lcc.popStatementContext(
1:be1b5ea:                                 lcc.getStatementContext(), null);
1:be1b5ea:                     }
1:be1b5ea: 
1:be1b5ea:                     // Don't return yet. The statement was invalidated, so
1:be1b5ea:                     // we must retry the compilation.
1:be1b5ea:                     continue;
1:be1b5ea:                 }
1:be1b5ea:             }
1:be1b5ea:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private PreparedStatement prepMinion(LanguageConnectionContext lcc, boolean cacheMe, Object[] paramDefaults,
1:eac0369: 		SchemaDescriptor spsSchema, boolean internalSQL)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 						  
1:eac0369: 		long				beginTime = 0;
1:eac0369: 		long				parseTime = 0;
1:eac0369: 		long				bindTime = 0;
1:eac0369: 		long				optimizeTime = 0;
1:eac0369: 		long				generateTime = 0;
1:eac0369: 		Timestamp			beginTimestamp = null;
1:eac0369: 		Timestamp			endTimestamp = null;
1:eac0369: 		StatementContext	statementContext = null;
1:eac0369: 
1:eac0369: 		// verify it isn't already prepared...
1:eac0369: 		// if it is, and is valid, simply return that tree.
1:eac0369: 		// if it is invalid, we will recompile now.
1:eac0369: 		if (preparedStmt != null) {
1:eac0369: 			if (preparedStmt.upToDate())
1:eac0369: 				return preparedStmt;
1:eac0369: 		}
1:eac0369: 
1:049f993: 		// Start a new optimizer trace for this statement
1:049f993: 		if (lcc.optimizerTracingIsOn())
1:049f993:         {
1:049f993:             lcc.getOptimizerTracer().traceStartStatement( getSource() );
1:049f993:         }
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis(lcc);
1:eac0369: 		/* beginTimestamp only meaningful if beginTime is meaningful.
1:eac0369: 		 * beginTime is meaningful if STATISTICS TIMING is ON.
1:eac0369: 		 */
2:eac0369: 		if (beginTime != 0)
1:eac0369: 		{
1:eac0369: 			beginTimestamp = new Timestamp(beginTime);
1:eac0369: 		}
1:eac0369: 
1:801cf0d:         /** set the prepare isolation from the LanguageConnectionContext now as
1:eac0369: 		 * we need to consider it in caching decisions
1:eac0369: 		 */
1:eac0369: 		prepareIsolationLevel = lcc.getPrepareIsolationLevel();
1:eac0369: 
1:eac0369: 		/* a note on statement caching:
2:eac0369: 		 * 
1:eac0369: 		 * A GenericPreparedStatement (GPS) is only added it to the cache if the
1:eac0369: 		 * parameter cacheMe is set to TRUE when the GPS is created.
1:eac0369: 		 * 
1:eac0369: 		 * Earlier only CacheStatement (CS) looked in the statement cache for a
1:eac0369: 		 * prepared statement when prepare was called. Now the functionality 
1:eac0369: 		 * of CS has been folded into GenericStatement (GS). So we search the
1:eac0369: 		 * cache for an existing PreparedStatement only when cacheMe is TRUE.
1:eac0369: 		 * i.e if the user calls prepare with cacheMe set to TRUE:
1:eac0369: 		 * then we 
1:eac0369: 		 *         a) look for the prepared statement in the cache.
1:eac0369: 		 *         b) add the prepared statement to the cache.
1:eac0369: 		 *
1:eac0369: 		 * In cases where the statement cache has been disabled (by setting the
1:94f158a: 		 * relevant Derby property) then the value of cacheMe is irrelevant.
1:eac0369: 		 */ 
1:eac0369: 		boolean foundInCache = false;
1:eac0369: 		if (preparedStmt == null) 
1:eac0369: 		{
1:eac0369: 			if (cacheMe)
1:eac0369: 				preparedStmt = (GenericPreparedStatement)((GenericLanguageConnectionContext)lcc).lookupStatement(this);
1:eac0369: 
1:eac0369: 			if (preparedStmt == null) 
1:eac0369: 			{
1:7fc54b9: 				preparedStmt = new GenericPreparedStatement(this);
1:7fc54b9: 			}
2:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				foundInCache = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// if anyone else also has this prepared statement,
1:eac0369: 		// we don't want them trying to compile with it while
1:eac0369: 		// we are.  So, we synchronize on it and re-check
1:eac0369: 		// its validity first.
1:eac0369: 		// this is a no-op if and until there is a central
1:eac0369: 		// cache of prepared statement objects...
1:eac0369: 		synchronized (preparedStmt) 
1:7fc54b9: 		{
1:eac0369: 
1:85132a2: 			for (;;) {
1:85132a2: 
1:85132a2: 				if (foundInCache) {
1:85132a2: 					if (preparedStmt.referencesSessionSchema()) {
1:eac0369: 						// cannot use this state since it is private to a connection.
1:eac0369: 						// switch to a new statement.
1:eac0369: 						foundInCache = false;
2:eac0369: 						preparedStmt = new GenericPreparedStatement(this);
1:85132a2: 						break;
1:85132a2: 					}
1:eac0369: 				}
1:85132a2: 
1:eac0369: 				// did it get updated while we waited for the lock on it?
1:eac0369: 				if (preparedStmt.upToDate()) {
1:eac0369: 					return preparedStmt;
1:eac0369: 				}
1:eac0369: 
1:6995fff:                 if (!preparedStmt.isCompiling()) {
1:7fc54b9: 					break;
1:eac0369: 				}
1:eac0369: 
1:85132a2: 				try {
1:85132a2: 					preparedStmt.wait();
1:85132a2: 				} catch (InterruptedException ie) {
1:5d97422:                     InterruptStatus.setInterrupted();
1:85132a2: 				}
1:eac0369: 			}
1:eac0369: 
1:6995fff:             preparedStmt.beginCompiling();
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		try {
1:eac0369: 
1:eac0369: 			HeaderPrintWriter istream = lcc.getLogStatementText() ? Monitor.getStream() : null;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** For stored prepared statements, we want all
1:eac0369: 			** errors, etc in the context of the underlying
1:eac0369: 			** EXECUTE STATEMENT statement, so don't push/pop
1:eac0369: 			** another statement context unless we don't have
1:eac0369: 			** one.  We won't have one if it is an internal
1:eac0369: 			** SPS (e.g. jdbcmetadata).
1:eac0369: 			*/
1:eac0369: 			if (!preparedStmt.isStorable() || lcc.getStatementDepth() == 0)
1:eac0369: 			{
1:eac0369: 				// since this is for compilation only, set atomic
1:3fcea8a: 				// param to true and timeout param to 0
1:5087be8: 				statementContext = lcc.pushStatementContext(true, isForReadOnly, getSource(),
1:3fcea8a:                                                             null, false, 0L);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** RESOLVE: we may ultimately wish to pass in
1:eac0369: 			** whether we are a jdbc metadata query or not to
1:eac0369: 			** get the CompilerContext to make the createDependency()
1:eac0369: 			** call a noop.
1:eac0369: 			*/
1:eac0369: 			CompilerContext cc = lcc.pushCompilerContext(compilationSchema);
1:eac0369: 			
1:eac0369: 			if (prepareIsolationLevel != 
1:38f02ec: 				TransactionControl.UNSPECIFIED_ISOLATION_LEVEL)
1:eac0369: 			{
1:eac0369: 				cc.setScanIsolationLevel(prepareIsolationLevel);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			// Look for stored statements that are in a system schema
1:eac0369: 			// and with a match compilation schema. If so, allow them
1:eac0369: 			// to compile using internal SQL constructs.
1:eac0369: 
1:eac0369: 			if (internalSQL ||
1:eac0369: 				(spsSchema != null) && (spsSchema.isSystemSchema()) &&
1:eac0369: 					(spsSchema.equals(compilationSchema))) {
1:eac0369: 						cc.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			try 
1:eac0369: 			{
1:eac0369: 				// Statement logging if lcc.getLogStatementText() is true
1:eac0369: 				if (istream != null)
1:eac0369: 				{
1:eac0369: 					String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1:eac0369: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1:eac0369: 											  xactId + 
1:eac0369: 											  "), " +
1:eac0369: 											  LanguageConnectionContext.lccStr +
1:eac0369: 												  lcc.getInstanceNumber() +
1:eac0369: 											  "), " +
1:eac0369: 											  LanguageConnectionContext.dbnameStr +
1:eac0369: 												  lcc.getDbname() +
1:eac0369: 											  "), " +
1:eac0369: 											  LanguageConnectionContext.drdaStr +
1:eac0369: 												  lcc.getDrdaID() +
1:eac0369: 											  "), Begin compiling prepared statement: " + 
1:eac0369: 											  getSource() +
1:eac0369: 											  " :End prepared statement");
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				Parser p = cc.getParser();
1:eac0369: 
1:eac0369: 				cc.setCurrentDependent(preparedStmt);
1:eac0369: 
1:eac0369: 				//Only top level statements go through here, nested statement
1:eac0369: 				//will invoke this method from other places
1:70a4f2d: 				StatementNode qt = (StatementNode)
1:70a4f2d:                         p.parseStatement(statementText, paramDefaults);
1:eac0369: 
1:eac0369: 				parseTime = getCurrentTimeMillis(lcc);
1:eac0369: 
1:3ff5ce3:                 // Call user-written tree-printer if it exists
1:3ff5ce3:                 walkAST( lcc, qt, ASTVisitor.AFTER_PARSE);
1:3ff5ce3: 
1:eac0369: 				if (SanityManager.DEBUG) 
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG_ON("DumpParseTree")) 
1:eac0369: 					{
1:c9a1206: 						SanityManager.GET_DEBUG_STREAM().print(
1:c9a1206: 							"\n\n============PARSE===========\n\n");
1:eac0369: 						qt.treePrint();
1:c9a1206: 						lcc.getPrintedObjectsMap().clear();
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG_ON("StopAfterParsing")) 
1:eac0369: 					{
1:a19a896:                         lcc.setLastQueryTree( qt );
1:a19a896:                         
1:eac0369: 						throw StandardException.newException(SQLState.LANG_STOP_AFTER_PARSING);
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** Tell the data dictionary that we are about to do
1:eac0369: 				** a bunch of "get" operations that must be consistent with
1:eac0369: 				** each other.
1:eac0369: 				*/
1:eac0369: 				
1:eac0369: 				DataDictionary dataDictionary = lcc.getDataDictionary();
1:eac0369: 
1:eac0369: 				int ddMode = dataDictionary == null ? 0 : dataDictionary.startReading(lcc);
1:eac0369: 
1:eac0369: 				try
1:eac0369: 				{
1:eac0369: 					// start a nested transaction -- all locks acquired by bind
1:eac0369: 					// and optimize will be released when we end the nested
1:eac0369: 					// transaction.
1:eac0369: 					lcc.beginNestedTransaction(true);
1:eac0369: 
1:8a93440: 					qt.bindStatement();
1:eac0369: 					bindTime = getCurrentTimeMillis(lcc);
1:eac0369: 
1:3ff5ce3:                     // Call user-written tree-printer if it exists
1:3ff5ce3:                     walkAST( lcc, qt, ASTVisitor.AFTER_BIND);
1:3ff5ce3: 
1:eac0369: 					if (SanityManager.DEBUG) 
1:eac0369: 					{
1:eac0369: 						if (SanityManager.DEBUG_ON("DumpBindTree")) 
1:eac0369: 						{
1:c9a1206: 							SanityManager.GET_DEBUG_STREAM().print(
1:c9a1206: 								"\n\n============BIND===========\n\n");
1:eac0369: 							qt.treePrint();
1:c9a1206: 							lcc.getPrintedObjectsMap().clear();
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (SanityManager.DEBUG_ON("StopAfterBinding")) {
1:eac0369: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_BINDING);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:6d9c32a: 					//Derby424 - In order to avoid caching select statements referencing
1:6d9c32a: 					// any SESSION schema objects (including statements referencing views
1:6d9c32a: 					// in SESSION schema), we need to do the SESSION schema object check
1:6d9c32a: 					// here.  
1:6d9c32a: 					//a specific eg for statement referencing a view in SESSION schema 
1:6d9c32a: 					//CREATE TABLE t28A (c28 int)
1:6d9c32a: 					//INSERT INTO t28A VALUES (280),(281)
1:6d9c32a: 					//CREATE VIEW SESSION.t28v1 as select * from t28A
1:6d9c32a: 					//SELECT * from SESSION.t28v1 should show contents of view and we
1:6d9c32a: 					// should not cache this statement because a user can later define
1:6d9c32a: 					// a global temporary table with the same name as the view name.
1:6d9c32a: 					//Following demonstrates that
1:6d9c32a: 					//DECLARE GLOBAL TEMPORARY TABLE SESSION.t28v1(c21 int, c22 int) not
1:6d9c32a: 					//     logged
1:6d9c32a: 					//INSERT INTO SESSION.t28v1 VALUES (280,1),(281,2)
1:6d9c32a: 					//SELECT * from SESSION.t28v1 should show contents of global temporary
1:6d9c32a: 					//table and not the view.  Since this select statement was not cached
1:6d9c32a: 					// earlier, it will be compiled again and will go to global temporary
1:6d9c32a: 					// table to fetch data. This plan will not be cached either because
1:6d9c32a: 					// select statement is using SESSION schema object.
1:6d9c32a: 					//
1:6d9c32a: 					//Following if statement makes sure that if the statement is
1:6d9c32a: 					// referencing SESSION schema objects, then we do not want to cache it.
1:6d9c32a: 					// We will remove the entry that was made into the cache for 
1:6d9c32a: 					//this statement at the beginning of the compile phase.
1:6d9c32a: 					//The reason we do this check here rather than later in the compile
1:6d9c32a: 					// phase is because for a view, later on, we loose the information that
1:6d9c32a: 					// it was referencing SESSION schema because the reference
1:6d9c32a: 					//view gets replaced with the actual view definition. Right after
1:6d9c32a: 					// binding, we still have the information on the view and that is why
1:6d9c32a: 					// we do the check here.
1:6d9c32a: 					if (preparedStmt.referencesSessionSchema(qt)) {
1:7fc54b9: 						if (foundInCache)
3:eac0369: 							((GenericLanguageConnectionContext)lcc).removeStatement(this);
1:9609996: 					}
1:b93f9db: 
1:b93f9db:                     // stop adding privileges for user-defined types
1:b93f9db:                     cc.skipTypePrivileges( true );
1:b93f9db:                     
1:8a93440: 					qt.optimizeStatement();
1:9609996: 
1:eac0369: 					optimizeTime = getCurrentTimeMillis(lcc);
1:9609996: 
1:3ff5ce3:                     // Call user-written tree-printer if it exists
1:3ff5ce3:                     walkAST( lcc, qt, ASTVisitor.AFTER_OPTIMIZE);
1:3ff5ce3: 
1:eac0369: 					// Statement logging if lcc.getLogStatementText() is true
1:eac0369: 					if (istream != null)
1:7fc54b9: 					{
1:eac0369: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1:eac0369: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1:eac0369: 												  xactId + 
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.lccStr +
1:eac0369: 												  lcc.getInstanceNumber() +
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.dbnameStr +
1:eac0369: 												  lcc.getDbname() +
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.drdaStr +
1:eac0369: 												  lcc.getDrdaID() +
1:eac0369: 												  "), End compiling prepared statement: " + 
1:eac0369: 												  getSource() +
1:eac0369: 												  " :End prepared statement");
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				catch (StandardException se)
1:eac0369: 				{
1:eac0369: 					lcc.commitNestedTransaction();
1:eac0369: 
1:eac0369: 					// Statement logging if lcc.getLogStatementText() is true
1:eac0369: 					if (istream != null)
1:eac0369: 					{
1:eac0369: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1:eac0369: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1:eac0369: 												  xactId + 
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.lccStr +
1:eac0369: 												  lcc.getInstanceNumber() +
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.dbnameStr +
1:eac0369: 												  lcc.getDbname() +
1:eac0369: 												  "), " +
1:eac0369: 												  LanguageConnectionContext.drdaStr +
1:eac0369: 												  lcc.getDrdaID() +
1:eac0369: 												  "), Error compiling prepared statement: " + 
1:eac0369: 												  getSource() +
1:eac0369: 												  " :End prepared statement");
1:eac0369: 					}
1:eac0369: 					throw se;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				finally
1:eac0369: 				{
1:eac0369: 					/* Tell the data dictionary that we are done reading */
1:eac0369: 					if (dataDictionary != null)
1:eac0369: 					dataDictionary.doneReading(ddMode, lcc);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* we need to move the commit of nested sub-transaction
1:eac0369: 				 * after we mark PS valid, during compilation, we might need
1:eac0369: 				 * to get some lock to synchronize with another thread's DDL
1:eac0369: 				 * execution, in particular, the compilation of insert/update/
1:eac0369: 				 * delete vs. create index/constraint (see Beetle 3976).  We
1:eac0369: 				 * can't release such lock until after we mark the PS valid.
1:eac0369: 				 * Otherwise we would just erase the DDL's invalidation when
1:eac0369: 				 * we mark it valid.
1:eac0369: 				 */
1:eac0369: 				try		// put in try block, commit sub-transaction if bad
1:eac0369: 				{
1:eac0369: 					if (SanityManager.DEBUG) 
1:eac0369: 					{
1:eac0369: 						if (SanityManager.DEBUG_ON("DumpOptimizedTree")) 
1:eac0369: 						{
1:c9a1206: 							SanityManager.GET_DEBUG_STREAM().print(
1:c9a1206: 								"\n\n============OPT===========\n\n");
1:eac0369: 							qt.treePrint();
1:c9a1206: 							lcc.getPrintedObjectsMap().clear();
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (SanityManager.DEBUG_ON("StopAfterOptimizing")) 
1:eac0369: 						{
1:eac0369: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_OPTIMIZING);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					GeneratedClass ac = qt.generate(preparedStmt.getByteCodeSaver());
1:eac0369: 
1:eac0369: 					generateTime = getCurrentTimeMillis(lcc);
1:eac0369: 					/* endTimestamp only meaningful if generateTime is meaningful.
1:eac0369: 					 * generateTime is meaningful if STATISTICS TIMING is ON.
1:eac0369: 					 */
1:eac0369: 					if (generateTime != 0)
1:eac0369: 					{
1:eac0369: 						endTimestamp = new Timestamp(generateTime);
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG) 
1:eac0369: 					{
1:eac0369: 						if (SanityManager.DEBUG_ON("StopAfterGenerating")) 
1:eac0369: 						{
1:eac0369: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_GENERATING);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					/*
1:eac0369: 						copy over the compile-time created objects
1:eac0369: 						to the prepared statement.  This always happens
1:eac0369: 						at the end of a compile, so there is no need
1:eac0369: 						to erase the previous entries on a re-compile --
1:eac0369: 						this erases as it replaces.  Set the activation
1:eac0369: 						class in case it came from a StorablePreparedStatement
1:eac0369: 					*/
1:eac0369: 					preparedStmt.setConstantAction( qt.makeConstantAction() );
1:eac0369: 					preparedStmt.setSavedObjects( cc.getSavedObjects() );
1:c45f5b1: 					preparedStmt.setRequiredPermissionsList(cc.getRequiredPermissionsList());
1:f9a0689:                     preparedStmt.incrementVersionCounter();
1:eac0369: 					preparedStmt.setActivationClass(ac);
1:eac0369: 					preparedStmt.setNeedsSavepoint(qt.needsSavepoint());
1:eac0369: 					preparedStmt.setCursorInfo((CursorInfo)cc.getCursorInfo());
1:eac0369: 					preparedStmt.setIsAtomic(qt.isAtomic());
1:eac0369: 					preparedStmt.setExecuteStatementNameAndSchema(
1:eac0369: 												qt.executeStatementName(),
1:eac0369: 												qt.executeSchemaName()
1:eac0369: 												);
1:eac0369: 					preparedStmt.setSPSName(qt.getSPSName());
1:6d9c32a: 					preparedStmt.completeCompile(qt);
1:eac0369: 					preparedStmt.setCompileTimeWarnings(cc.getWarnings());
1:47eac7d: 
1:47eac7d:                     // Schedule updates of any stale index statistics we may
1:47eac7d:                     // have detected when creating the plan.
1:47eac7d:                     TableDescriptor[] tds = qt.updateIndexStatisticsFor();
1:47eac7d:                     if (tds.length > 0) {
1:47eac7d:                         IndexStatisticsDaemon isd = lcc.getDataDictionary().
1:47eac7d:                             getIndexStatsRefresher(true);
1:47eac7d:                         if (isd != null) {
1:47eac7d:                             for (int i=0; i < tds.length; i++) {
1:47eac7d:                                 isd.schedule(tds[i]);
1:47eac7d:                             }
1:47eac7d:                         }
1:47eac7d:                     }
1:47eac7d:                 }
1:eac0369: 				catch (StandardException e) 	// hold it, throw it
1:eac0369: 				{
1:eac0369: 					lcc.commitNestedTransaction();
1:eac0369: 					throw e;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (lcc.getRunTimeStatisticsMode())
1:eac0369: 				{
1:eac0369: 					preparedStmt.setCompileTimeMillis(
1:eac0369: 						parseTime - beginTime, //parse time
1:eac0369: 						bindTime - parseTime, //bind time
1:eac0369: 						optimizeTime - bindTime, //optimize time
1:eac0369: 						generateTime - optimizeTime, //generate time
1:b28e47c: 						generateTime - beginTime, //total compile time
1:eac0369: 						beginTimestamp,
1:eac0369: 						endTimestamp);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 			finally // for block introduced by pushCompilerContext()
1:eac0369: 			{
1:eac0369: 				lcc.popCompilerContext( cc );
1:daebcb9: 			}
1:eac0369: 		}
1:daebcb9: 		catch (StandardException se)
1:daebcb9: 		{
1:daebcb9: 			if (foundInCache)
1:daebcb9: 				((GenericLanguageConnectionContext)lcc).removeStatement(this);
1:eac0369: 
1:daebcb9: 			throw se;
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:6995fff:             preparedStmt.endCompiling();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		lcc.commitNestedTransaction();
1:eac0369: 
1:eac0369: 		if (statementContext != null)
1:eac0369: 			lcc.popStatementContext(statementContext, null);
1:eac0369: 
1:eac0369: 		return preparedStmt;
1:eac0369: 	}
1:eac0369: 
1:3ff5ce3:     /** Walk the AST, using a (user-supplied) Visitor */
1:3ff5ce3:     private void walkAST( LanguageConnectionContext lcc, Visitable queryTree, int phase ) throws StandardException
1:3ff5ce3:     {
1:3ff5ce3:         ASTVisitor visitor = lcc.getASTVisitor();
1:3ff5ce3:         if ( visitor != null )
1:3ff5ce3:         {
1:3ff5ce3:             visitor.begin( statementText, phase );
1:3ff5ce3:             queryTree.accept( visitor );
1:3ff5ce3:             visitor.end( phase );
1:3ff5ce3:         }
1:3ff5ce3:     }
1:3ff5ce3: 
1:0bcca1b: 	/**
1:eac0369: 	 * Generates an execution plan given a set of named parameters.
1:eac0369: 	 * Does so for a storable prepared statement.
1:eac0369: 	 *
1:eac0369: 	 * @param	paramDefaults		Parameter defaults
1:eac0369: 	 *
1:eac0369: 	 * @return A PreparedStatement that allows execution of the execution
1:eac0369: 	 *	   plan.
1:eac0369: 	 * @exception StandardException	Thrown if this is an
1:eac0369: 	 *	   execution-only version of the module (the prepare() method
1:eac0369: 	 *	   relies on compilation).
1:eac0369: 	 */
1:eac0369: 	public	PreparedStatement prepareStorable(
1:eac0369: 				LanguageConnectionContext lcc,
1:eac0369: 				PreparedStatement ps,
1:eac0369: 				Object[]			paramDefaults,
1:eac0369: 				SchemaDescriptor	spsSchema,
1:eac0369: 				boolean internalSQL)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (ps == null)
1:eac0369: 			ps = new GenericStorablePreparedStatement(this);
1:eac0369: 		else
1:eac0369: 			((GenericPreparedStatement) ps).statement = this;
1:eac0369: 
1:eac0369: 		this.preparedStmt = (GenericPreparedStatement) ps;
1:eac0369: 		return prepMinion(lcc, false, paramDefaults, spsSchema, internalSQL);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getSource() {
1:eac0369: 		return statementText;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getCompilationSchema() {
1:eac0369: 		return compilationSchema.getDescriptorName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private static long getCurrentTimeMillis(LanguageConnectionContext lcc)
1:eac0369: 	{
1:eac0369: 		if (lcc.getStatisticsTiming())
1:eac0369: 		{
1:eac0369: 			return System.currentTimeMillis();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
2:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:0bcca1b:      * Return the {@link PreparedStatement} currently associated with this
1:0bcca1b:      * statement.
1:0bcca1b:      *
1:0bcca1b:      * @return the prepared statement that is associated with this statement
1:0bcca1b:      */
1:0bcca1b:     public PreparedStatement getPreparedStatement() {
1:0bcca1b:         return preparedStmt;
1:0bcca1b:     }
1:0bcca1b: 
1:eac0369: 	/*
1:eac0369: 	** Identity
1:eac0369: 	*/
1:801cf0d:     @Override
1:eac0369: 	public boolean equals(Object other) {
1:eac0369: 
1:eac0369: 		if (other instanceof GenericStatement) {
1:eac0369: 
1:eac0369: 			GenericStatement os = (GenericStatement) other;
1:eac0369: 
1:5087be8: 			return statementText.equals(os.statementText) && isForReadOnly==os.isForReadOnly
1:eac0369: 				&& compilationSchema.equals(os.compilationSchema) &&
1:eac0369: 				(prepareIsolationLevel == os.prepareIsolationLevel);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:801cf0d:     @Override
1:eac0369: 	public int hashCode() {
1:eac0369: 
1:eac0369: 		return statementText.hashCode();
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b93f9db
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // stop adding privileges for user-defined types
1:                     cc.skipTypePrivileges( true );
1:                     
commit:049f993
/////////////////////////////////////////////////////////////////////////
1: 		// Start a new optimizer trace for this statement
1: 		if (lcc.optimizerTracingIsOn())
1:         {
1:             lcc.getOptimizerTracer().traceStartStatement( getSource() );
1:         }
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.transaction.TransactionControl;
/////////////////////////////////////////////////////////////////////////
1: 				TransactionControl.UNSPECIFIED_ISOLATION_LEVEL)
commit:3ff5ce3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.ASTVisitor;
/////////////////////////////////////////////////////////////////////////
1:                 // Call user-written tree-printer if it exists
1:                 walkAST( lcc, qt, ASTVisitor.AFTER_PARSE);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     // Call user-written tree-printer if it exists
1:                     walkAST( lcc, qt, ASTVisitor.AFTER_BIND);
1: 
/////////////////////////////////////////////////////////////////////////
1:                     // Call user-written tree-printer if it exists
1:                     walkAST( lcc, qt, ASTVisitor.AFTER_OPTIMIZE);
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** Walk the AST, using a (user-supplied) Visitor */
1:     private void walkAST( LanguageConnectionContext lcc, Visitable queryTree, int phase ) throws StandardException
1:     {
1:         ASTVisitor visitor = lcc.getASTVisitor();
1:         if ( visitor != null )
1:         {
1:             visitor.begin( statementText, phase );
1:             queryTree.accept( visitor );
1:             visitor.end( phase );
1:         }
1:     }
1: 
commit:a19a896
/////////////////////////////////////////////////////////////////////////
1:                         lcc.setLastQueryTree( qt );
1:                         
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6995fff
/////////////////////////////////////////////////////////////////////////
1:                 if (!preparedStmt.isCompiling()) {
/////////////////////////////////////////////////////////////////////////
1:             preparedStmt.beginCompiling();
/////////////////////////////////////////////////////////////////////////
1:             preparedStmt.endCompiling();
commit:878e211
/////////////////////////////////////////////////////////////////////////
1:         String prevErrorId = null;
1:             boolean recompile = false;
1:             } catch (StandardException se) {
1:                 // There is a chance that we didn't see the invalidation
1:                 // request from a DDL operation in another thread because
1:                 // the statement wasn't registered as a dependent until
1:                 // after the invalidation had been completed. Assume that's
1:                 // what has happened if we see a conglomerate does not exist
1:                 // error, and force a retry even if the statement hasn't been
1:                 // invalidated.
1:                 if (SQLState.STORE_CONGLOMERATE_DOES_NOT_EXIST.equals(
1:                         se.getMessageId())) {
1:                     // STORE_CONGLOMERATE_DOES_NOT_EXIST has exactly one
1:                     // argument: the conglomerate id
1:                     String conglomId = String.valueOf(se.getArguments()[0]);
1:                     // Request a recompile of the statement if a conglomerate
1:                     // disappears while we are compiling it. But if we have
1:                     // already retried once because the same conglomerate was
1:                     // missing, there's probably no hope that yet another retry
1:                     // will help, so let's break out instead of potentially
1:                     // looping infinitely.
1:                     if (!conglomId.equals(prevErrorId)) {
1:                         recompile = true;
1:                     }
1: 
1:                     prevErrorId = conglomId;
1:                 }
1:                 throw se;
1:             } finally {
/////////////////////////////////////////////////////////////////////////
1:                     if (recompile || preparedStmt.invalidatedWhileCompiling) {
commit:70a4f2d
/////////////////////////////////////////////////////////////////////////
1: 				StatementNode qt = (StatementNode)
1:                         p.parseStatement(statementText, paramDefaults);
commit:be1b5ea
/////////////////////////////////////////////////////////////////////////
1: 		return prepare(lcc, false);
/////////////////////////////////////////////////////////////////////////
1: 
1:         final int depth = lcc.getStatementDepth();
1:         while (true) {
1:             try {
1:                 return prepMinion(lcc, true, (Object[]) null,
1:                                   (SchemaDescriptor) null, forMetaData);
0:             } finally {
0:                 boolean recompile = false;
1: 
1:                 // Check if the statement was invalidated while it was
1:                 // compiled. If so, the newly compiled plan may not be
1:                 // up to date anymore, so we recompile the statement
1:                 // if this happens. Note that this is checked in a finally
1:                 // block, so we also retry if an exception was thrown. The
1:                 // exception was probably thrown because of the changes
1:                 // that invalidated the statement. If not, recompiling
1:                 // will also fail, and the exception will be exposed to
1:                 // the caller.
1:                 //
1:                 // invalidatedWhileCompiling and isValid are protected by
1:                 // synchronization on the prepared statement.
1:                 synchronized (preparedStmt) {
0:                     if (preparedStmt.invalidatedWhileCompiling) {
1:                         preparedStmt.isValid = false;
1:                         preparedStmt.invalidatedWhileCompiling = false;
1:                         recompile = true;
1:                     }
1:                 }
1: 
1:                 if (recompile) {
1:                     // A new statement context is pushed while compiling.
1:                     // Typically, this context is popped by an error
1:                     // handler at a higher level. But since we retry the
1:                     // compilation, the error handler won't be invoked, so
1:                     // the stack must be reset to its original state first.
1:                     while (lcc.getStatementDepth() > depth) {
1:                         lcc.popStatementContext(
1:                                 lcc.getStatementContext(), null);
1:                     }
1: 
1:                     // Don't return yet. The statement was invalidated, so
1:                     // we must retry the compilation.
1:                     continue;
1:                 }
1:             }
1:         }
commit:42114da
/////////////////////////////////////////////////////////////////////////
commit:9609996
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (statementContext != null) {
0:                 statementContext.cleanupOnError(se);
1:             }
1: 
commit:85132a2
/////////////////////////////////////////////////////////////////////////
1: 			for (;;) {
1: 
1: 				if (foundInCache) {
1: 					if (preparedStmt.referencesSessionSchema()) {
/////////////////////////////////////////////////////////////////////////
0: 				if (!preparedStmt.compilingStatement) {
1: 					break;
1: 				}
1: 
1: 				try {
1: 					preparedStmt.wait();
1: 				} catch (InterruptedException ie) {
0: 					throw StandardException.interrupt(ie);
1: 				}
/////////////////////////////////////////////////////////////////////////
0: 				preparedStmt.notifyAll();
commit:7fc54b9
/////////////////////////////////////////////////////////////////////////
0: 			for (;;)
1: 			{
0: 				if (preparedStmt.compilingStatement)
1: 				{
1: 					preparedStmt = new GenericPreparedStatement(this);
1: 					break;
1: 				}
1: 				if (foundInCache)
1: 				{
0: 					if (preparedStmt.referencesSessionSchema())
1: 					{
/////////////////////////////////////////////////////////////////////////
0: 				break;
/////////////////////////////////////////////////////////////////////////
commit:93f457a
/////////////////////////////////////////////////////////////////////////
commit:0bcca1b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the {@link PreparedStatement} currently associated with this
1:      * statement.
1:      *
1:      * @return the prepared statement that is associated with this statement
1:      */
1:     public PreparedStatement getPreparedStatement() {
1:         return preparedStmt;
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:b28e47c
/////////////////////////////////////////////////////////////////////////
1: 						generateTime - beginTime, //total compile time
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         /** set the prepare isolation from the LanguageConnectionContext now as
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:f9a0689
/////////////////////////////////////////////////////////////////////////
1:                     preparedStmt.incrementVersionCounter();
commit:5d97422
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:                     InterruptStatus.setInterrupted();
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 						SanityManager.GET_DEBUG_STREAM().print(
1: 							"\n\n============PARSE===========\n\n");
1: 						lcc.getPrintedObjectsMap().clear();
/////////////////////////////////////////////////////////////////////////
1: 							SanityManager.GET_DEBUG_STREAM().print(
1: 								"\n\n============BIND===========\n\n");
1: 							lcc.getPrintedObjectsMap().clear();
/////////////////////////////////////////////////////////////////////////
1: 							SanityManager.GET_DEBUG_STREAM().print(
1: 								"\n\n============OPT===========\n\n");
1: 							lcc.getPrintedObjectsMap().clear();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:47eac7d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.daemon.IndexStatisticsDaemon;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // Schedule updates of any stale index statistics we may
1:                     // have detected when creating the plan.
1:                     TableDescriptor[] tds = qt.updateIndexStatisticsFor();
1:                     if (tds.length > 0) {
1:                         IndexStatisticsDaemon isd = lcc.getDataDictionary().
1:                             getIndexStatsRefresher(true);
1:                         if (isd != null) {
1:                             for (int i=0; i < tds.length; i++) {
1:                                 isd.schedule(tds[i]);
1:                             }
1:                         }
1:                     }
1:                 }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		 * relevant Derby property) then the value of cacheMe is irrelevant.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:dee279c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.Statement;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Parser;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.impl.sql.compile.StatementNode;
1: import org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext;
commit:8a93440
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.sql.compile.StatementNode;
/////////////////////////////////////////////////////////////////////////
0: 				StatementNode qt = p.parseStatement(statementText, paramDefaults);
/////////////////////////////////////////////////////////////////////////
1: 					qt.bindStatement();
/////////////////////////////////////////////////////////////////////////
1: 					qt.optimizeStatement();
commit:daebcb9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		catch (StandardException se)
1: 		{
1: 			if (foundInCache)
1: 				((GenericLanguageConnectionContext)lcc).removeStatement(this);
1: 			throw se;
1: 		}
commit:ddc6f41
/////////////////////////////////////////////////////////////////////////
commit:d387dac
/////////////////////////////////////////////////////////////////////////
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1: 				// param to true and timeout param to 0
0: 				statementContext = lcc.pushStatementContext(true, getSource(),
1:                                                             null, false, 0L);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.GenericStatement
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
1: 
0: import org.apache.derby.impl.sql.compile.QueryTreeNode;
0: import org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.util.ByteArray;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
1: 
1: public class GenericStatement
1: 	implements Statement {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	// these fields define the identity of the statement
1: 	private final SchemaDescriptor compilationSchema;
1: 	private final String			statementText;
1: 	private int                      prepareIsolationLevel;
1: 	private GenericPreparedStatement preparedStmt;
1: 
1: 	/**
1: 	 * Constructor for a Statement given the text of the statement in a String
1: 	 *
1: 	 * @param statementText	The text of the statement
1: 	 */
1: 
0: 	public GenericStatement(SchemaDescriptor compilationSchema, String statementText)
1: 	{
1: 		this.compilationSchema = compilationSchema;
1: 		this.statementText = statementText;
1: 	}
1: 
1: 	/*
1: 	 * Statement interface
1: 	 */
1: 
1: 
1: 	/* RESOLVE: may need error checking, debugging code here */
1: 	public PreparedStatement prepare(LanguageConnectionContext lcc) throws StandardException
1: 	{
1: 		/*
1: 		** Note: don't reset state since this might be
1: 		** a recompilation of an already prepared statement.
1: 		*/ 
0: 		return prepMinion(lcc, true, (Object[]) null, (SchemaDescriptor) null, false); 
1: 	}
1: 
1: 	private PreparedStatement prepMinion(LanguageConnectionContext lcc, boolean cacheMe, Object[] paramDefaults,
1: 		SchemaDescriptor spsSchema, boolean internalSQL)
1: 		throws StandardException
1: 	{
1: 						  
1: 		long				beginTime = 0;
1: 		long				parseTime = 0;
1: 		long				bindTime = 0;
1: 		long				optimizeTime = 0;
1: 		long				generateTime = 0;
1: 		Timestamp			beginTimestamp = null;
1: 		Timestamp			endTimestamp = null;
1: 		StatementContext	statementContext = null;
1: 
1: 		// verify it isn't already prepared...
1: 		// if it is, and is valid, simply return that tree.
1: 		// if it is invalid, we will recompile now.
1: 		if (preparedStmt != null) {
1: 			if (preparedStmt.upToDate())
1: 				return preparedStmt;
1: 		}
1: 
0: 		// Clear the optimizer trace from the last statement
0: 		if (lcc.getOptimizerTrace())
0: 			lcc.setOptimizerTraceOutput(getSource() + "\n");
1: 
1: 		beginTime = getCurrentTimeMillis(lcc);
1: 		/* beginTimestamp only meaningful if beginTime is meaningful.
1: 		 * beginTime is meaningful if STATISTICS TIMING is ON.
1: 		 */
1: 		if (beginTime != 0)
1: 		{
1: 			beginTimestamp = new Timestamp(beginTime);
1: 		}
1: 
0: 		/** set the prepare Isolaton from the LanguageConnectionContext now as 
1: 		 * we need to consider it in caching decisions
1: 		 */
1: 		prepareIsolationLevel = lcc.getPrepareIsolationLevel();
1: 
1: 		/* a note on statement caching:
1: 		 * 
1: 		 * A GenericPreparedStatement (GPS) is only added it to the cache if the
1: 		 * parameter cacheMe is set to TRUE when the GPS is created.
1: 		 * 
1: 		 * Earlier only CacheStatement (CS) looked in the statement cache for a
1: 		 * prepared statement when prepare was called. Now the functionality 
1: 		 * of CS has been folded into GenericStatement (GS). So we search the
1: 		 * cache for an existing PreparedStatement only when cacheMe is TRUE.
1: 		 * i.e if the user calls prepare with cacheMe set to TRUE:
1: 		 * then we 
1: 		 *         a) look for the prepared statement in the cache.
1: 		 *         b) add the prepared statement to the cache.
1: 		 *
1: 		 * In cases where the statement cache has been disabled (by setting the
0: 		 * relevant cloudscape property) then the value of cacheMe is irrelevant.
1: 		 */ 
1: 		boolean foundInCache = false;
1: 		if (preparedStmt == null) 
1: 		{
1: 			if (cacheMe)
1: 				preparedStmt = (GenericPreparedStatement)((GenericLanguageConnectionContext)lcc).lookupStatement(this);
1: 
1: 			if (preparedStmt == null) 
1: 			{
1: 				preparedStmt = new GenericPreparedStatement(this);
1: 			}
1: 			else
1: 			{
1: 				foundInCache = true;
1: 			}
1: 		}
1: 
1: 		// if anyone else also has this prepared statement,
1: 		// we don't want them trying to compile with it while
1: 		// we are.  So, we synchronize on it and re-check
1: 		// its validity first.
1: 		// this is a no-op if and until there is a central
1: 		// cache of prepared statement objects...
1: 		synchronized (preparedStmt) 
1: 		{
1: 
0: 			for (;;) {
1: 
0: 				if (foundInCache) {
0: 					if (preparedStmt.referencesSessionSchema()) {
1: 						// cannot use this state since it is private to a connection.
1: 						// switch to a new statement.
1: 						foundInCache = false;
1: 						preparedStmt = new GenericPreparedStatement(this);
0: 						break;
1: 					}
1: 				}
1: 
1: 				// did it get updated while we waited for the lock on it?
1: 				if (preparedStmt.upToDate()) {
1: 					return preparedStmt;
1: 				}
1: 
0: 				if (!preparedStmt.compilingStatement) {
0: 					break;
1: 				}
1: 
1: 				try {
0: 					preparedStmt.wait();
0: 				} catch (InterruptedException ie) {
0: 					throw StandardException.interrupt(ie);
1: 				}
1: 			}
1: 
0: 			preparedStmt.compilingStatement = true;
0: 			preparedStmt.setActivationClass(null);
1: 		}
1: 
1: 		try {
1: 
1: 			HeaderPrintWriter istream = lcc.getLogStatementText() ? Monitor.getStream() : null;
1: 
1: 			/*
1: 			** For stored prepared statements, we want all
1: 			** errors, etc in the context of the underlying
1: 			** EXECUTE STATEMENT statement, so don't push/pop
1: 			** another statement context unless we don't have
1: 			** one.  We won't have one if it is an internal
1: 			** SPS (e.g. jdbcmetadata).
1: 			*/
1: 			if (!preparedStmt.isStorable() || lcc.getStatementDepth() == 0)
1: 			{
1: 				// since this is for compilation only, set atomic
0: 				// param to true
0: 				statementContext = lcc.pushStatementContext(true, getSource(), null, false);
1: 			}
1: 
1: 
1: 
1: 			/*
1: 			** RESOLVE: we may ultimately wish to pass in
1: 			** whether we are a jdbc metadata query or not to
1: 			** get the CompilerContext to make the createDependency()
1: 			** call a noop.
1: 			*/
1: 			CompilerContext cc = lcc.pushCompilerContext(compilationSchema);
1: 			
1: 			if (prepareIsolationLevel != 
0: 				ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
1: 			{
1: 				cc.setScanIsolationLevel(prepareIsolationLevel);
1: 			}
1: 
1: 
1: 			// Look for stored statements that are in a system schema
1: 			// and with a match compilation schema. If so, allow them
1: 			// to compile using internal SQL constructs.
1: 
1: 			if (internalSQL ||
1: 				(spsSchema != null) && (spsSchema.isSystemSchema()) &&
1: 					(spsSchema.equals(compilationSchema))) {
1: 						cc.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
1: 			}
1: 
1: 			try 
1: 			{
1: 				// Statement logging if lcc.getLogStatementText() is true
1: 				if (istream != null)
1: 				{
1: 					String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1: 											  xactId + 
1: 											  "), " +
1: 											  LanguageConnectionContext.lccStr +
1: 												  lcc.getInstanceNumber() +
1: 											  "), " +
1: 											  LanguageConnectionContext.dbnameStr +
1: 												  lcc.getDbname() +
1: 											  "), " +
1: 											  LanguageConnectionContext.drdaStr +
1: 												  lcc.getDrdaID() +
1: 											  "), Begin compiling prepared statement: " + 
1: 											  getSource() +
1: 											  " :End prepared statement");
1: 				}
1: 
1: 				Parser p = cc.getParser();
1: 
1: 				cc.setCurrentDependent(preparedStmt);
1: 
1: 				//Only top level statements go through here, nested statement
1: 				//will invoke this method from other places
0: 				QueryTreeNode qt = p.parseStatement(statementText, paramDefaults);
1: 
1: 				parseTime = getCurrentTimeMillis(lcc);
1: 
1: 				if (SanityManager.DEBUG) 
1: 				{
1: 					if (SanityManager.DEBUG_ON("DumpParseTree")) 
1: 					{
1: 						qt.treePrint();
1: 					}
1: 
1: 					if (SanityManager.DEBUG_ON("StopAfterParsing")) 
1: 					{
1: 						throw StandardException.newException(SQLState.LANG_STOP_AFTER_PARSING);
1: 					}
1: 				}
1: 
1: 				/*
1: 				** Tell the data dictionary that we are about to do
1: 				** a bunch of "get" operations that must be consistent with
1: 				** each other.
1: 				*/
1: 				
1: 				DataDictionary dataDictionary = lcc.getDataDictionary();
1: 
1: 				int ddMode = dataDictionary == null ? 0 : dataDictionary.startReading(lcc);
1: 
1: 				try
1: 				{
1: 					// start a nested transaction -- all locks acquired by bind
1: 					// and optimize will be released when we end the nested
1: 					// transaction.
1: 					lcc.beginNestedTransaction(true);
1: 
0: 					qt = qt.bind();
1: 					bindTime = getCurrentTimeMillis(lcc);
1: 
1: 					if (SanityManager.DEBUG) 
1: 					{
1: 						if (SanityManager.DEBUG_ON("DumpBindTree")) 
1: 						{
1: 							qt.treePrint();
1: 						}
1: 
1: 						if (SanityManager.DEBUG_ON("StopAfterBinding")) {
1: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_BINDING);
1: 						}
1: 					}
1: 
0: 					qt = qt.optimize();
1: 
1: 					optimizeTime = getCurrentTimeMillis(lcc);
1: 
1: 					// Statement logging if lcc.getLogStatementText() is true
1: 					if (istream != null)
1: 					{
1: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1: 												  xactId + 
1: 												  "), " +
1: 												  LanguageConnectionContext.lccStr +
1: 												  lcc.getInstanceNumber() +
1: 												  "), " +
1: 												  LanguageConnectionContext.dbnameStr +
1: 												  lcc.getDbname() +
1: 												  "), " +
1: 												  LanguageConnectionContext.drdaStr +
1: 												  lcc.getDrdaID() +
1: 												  "), End compiling prepared statement: " + 
1: 												  getSource() +
1: 												  " :End prepared statement");
1: 					}
1: 				}
1: 
1: 				catch (StandardException se)
1: 				{
1: 					lcc.commitNestedTransaction();
0: 					if (foundInCache)
1: 						((GenericLanguageConnectionContext)lcc).removeStatement(this);
1: 
1: 
1: 					// Statement logging if lcc.getLogStatementText() is true
1: 					if (istream != null)
1: 					{
1: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
1: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
1: 												  xactId + 
1: 												  "), " +
1: 												  LanguageConnectionContext.lccStr +
1: 												  lcc.getInstanceNumber() +
1: 												  "), " +
1: 												  LanguageConnectionContext.dbnameStr +
1: 												  lcc.getDbname() +
1: 												  "), " +
1: 												  LanguageConnectionContext.drdaStr +
1: 												  lcc.getDrdaID() +
1: 												  "), Error compiling prepared statement: " + 
1: 												  getSource() +
1: 												  " :End prepared statement");
1: 					}
1: 					throw se;
1: 				}
1: 
1: 				finally
1: 				{
1: 					/* Tell the data dictionary that we are done reading */
1: 					if (dataDictionary != null)
1: 					dataDictionary.doneReading(ddMode, lcc);
1: 				}
1: 
1: 				/* we need to move the commit of nested sub-transaction
1: 				 * after we mark PS valid, during compilation, we might need
1: 				 * to get some lock to synchronize with another thread's DDL
1: 				 * execution, in particular, the compilation of insert/update/
1: 				 * delete vs. create index/constraint (see Beetle 3976).  We
1: 				 * can't release such lock until after we mark the PS valid.
1: 				 * Otherwise we would just erase the DDL's invalidation when
1: 				 * we mark it valid.
1: 				 */
1: 				try		// put in try block, commit sub-transaction if bad
1: 				{
1: 					if (SanityManager.DEBUG) 
1: 					{
1: 						if (SanityManager.DEBUG_ON("DumpOptimizedTree")) 
1: 						{
1: 							qt.treePrint();
1: 						}
1: 
1: 						if (SanityManager.DEBUG_ON("StopAfterOptimizing")) 
1: 						{
1: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_OPTIMIZING);
1: 						}
1: 					}
1: 
1: 					GeneratedClass ac = qt.generate(preparedStmt.getByteCodeSaver());
1: 
1: 					generateTime = getCurrentTimeMillis(lcc);
1: 					/* endTimestamp only meaningful if generateTime is meaningful.
1: 					 * generateTime is meaningful if STATISTICS TIMING is ON.
1: 					 */
1: 					if (generateTime != 0)
1: 					{
1: 						endTimestamp = new Timestamp(generateTime);
1: 					}
1: 
1: 					if (SanityManager.DEBUG) 
1: 					{
1: 						if (SanityManager.DEBUG_ON("StopAfterGenerating")) 
1: 						{
1: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_GENERATING);
1: 						}
1: 					}
1: 
1: 					/*
1: 						copy over the compile-time created objects
1: 						to the prepared statement.  This always happens
1: 						at the end of a compile, so there is no need
1: 						to erase the previous entries on a re-compile --
1: 						this erases as it replaces.  Set the activation
1: 						class in case it came from a StorablePreparedStatement
1: 					*/
1: 					preparedStmt.setConstantAction( qt.makeConstantAction() );
1: 					preparedStmt.setSavedObjects( cc.getSavedObjects() );
1: 					preparedStmt.setActivationClass(ac);
0: 					preparedStmt.setParams(cc.getParams());
1: 					preparedStmt.setNeedsSavepoint(qt.needsSavepoint());
1: 					preparedStmt.setCursorInfo((CursorInfo)cc.getCursorInfo());
1: 					preparedStmt.setIsAtomic(qt.isAtomic());
1: 					preparedStmt.setExecuteStatementNameAndSchema(
1: 												qt.executeStatementName(),
1: 												qt.executeSchemaName()
1: 												);
1: 					preparedStmt.setSPSName(qt.getSPSName());
1: 
0: 					//if this statement is referencing session schema tables, then we do not want cache it. Following will remove the
0: 					//entry that was made into the cache for this statement at the beginning of the compile phase
0: 					if (preparedStmt.completeCompile(qt)) {
0: 						if (foundInCache)
1: 							((GenericLanguageConnectionContext)lcc).removeStatement(this);
1: 					}
1: 
1: 					preparedStmt.setCompileTimeWarnings(cc.getWarnings());
1: 				}
1: 				catch (StandardException e) 	// hold it, throw it
1: 				{
1: 					lcc.commitNestedTransaction();
0: 					if (foundInCache)
1: 						((GenericLanguageConnectionContext)lcc).removeStatement(this);
1: 					throw e;
1: 				}
1: 
1: 				if (lcc.getRunTimeStatisticsMode())
1: 				{
1: 					preparedStmt.setCompileTimeMillis(
1: 						parseTime - beginTime, //parse time
1: 						bindTime - parseTime, //bind time
1: 						optimizeTime - bindTime, //optimize time
1: 						generateTime - optimizeTime, //generate time
0: 						getElapsedTimeMillis(beginTime),
1: 						beginTimestamp,
1: 						endTimestamp);
1: 				}
1: 
1: 			}
1: 			finally // for block introduced by pushCompilerContext()
1: 			{
1: 				lcc.popCompilerContext( cc );
1: 			}
1: 		}
1: 		finally
1: 		{
0: 			synchronized (preparedStmt) {
0: 				preparedStmt.compilingStatement = false;
0: 				preparedStmt.notifyAll();
1: 			}
1: 		}
1: 
1: 		lcc.commitNestedTransaction();
1: 
1: 		if (statementContext != null)
1: 			lcc.popStatementContext(statementContext, null);
1: 
1: 		return preparedStmt;
1: 	}
1: 
1: 	/**
1: 	 * Generates an execution plan given a set of named parameters.
1: 	 * Does so for a storable prepared statement.
1: 	 *
0: 	 * @param 	compilationSchema	the schema to compile against
1: 	 * @param	paramDefaults		Parameter defaults
1: 	 *
1: 	 * @return A PreparedStatement that allows execution of the execution
1: 	 *	   plan.
1: 	 * @exception StandardException	Thrown if this is an
1: 	 *	   execution-only version of the module (the prepare() method
1: 	 *	   relies on compilation).
1: 	 */
1: 	public	PreparedStatement prepareStorable(
1: 				LanguageConnectionContext lcc,
1: 				PreparedStatement ps,
1: 				Object[]			paramDefaults,
1: 				SchemaDescriptor	spsSchema,
1: 				boolean internalSQL)
1: 		throws StandardException
1: 	{
1: 		if (ps == null)
1: 			ps = new GenericStorablePreparedStatement(this);
1: 		else
1: 			((GenericPreparedStatement) ps).statement = this;
1: 
1: 		this.preparedStmt = (GenericPreparedStatement) ps;
1: 		return prepMinion(lcc, false, paramDefaults, spsSchema, internalSQL);
1: 	}
1: 
1: 	public String getSource() {
1: 		return statementText;
1: 	}
1: 
0: 	public boolean getUnicode() {
0: 		return true;
1: 	}
1: 
1: 	public String getCompilationSchema() {
1: 		return compilationSchema.getDescriptorName();
1: 	}
1: 
1: 	private static long getCurrentTimeMillis(LanguageConnectionContext lcc)
1: 	{
1: 		if (lcc.getStatisticsTiming())
1: 		{
1: 			return System.currentTimeMillis();
1: 		}
1: 		else
1: 		{
1: 			return 0;
1: 		}
1: 	}
1: 
0: 	private static long getElapsedTimeMillis(long beginTime)
1: 	{
1: 		if (beginTime != 0)
1: 		{
0: 			return System.currentTimeMillis() - beginTime;
1: 		}
1: 		else
1: 		{
1: 			return 0;
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Identity
1: 	*/
1: 
1: 	public boolean equals(Object other) {
1: 
1: 		if (other instanceof GenericStatement) {
1: 
1: 			GenericStatement os = (GenericStatement) other;
1: 
0: 			return statementText.equals(os.statementText)
1: 				&& compilationSchema.equals(os.compilationSchema) &&
1: 				(prepareIsolationLevel == os.prepareIsolationLevel);
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	public int hashCode() {
1: 
1: 		return statementText.hashCode();
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:67c1c96
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param compilationSchema schema
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: 					preparedStmt.setRequiredPermissionsList(cc.getRequiredPermissionsList());
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
0: 	
/////////////////////////////////////////////////////////////////////////
1: 	public PreparedStatement prepare(LanguageConnectionContext lcc, boolean forMetaData) throws StandardException
0: 	{
1: 		/*
1: 		** Note: don't reset state since this might be
1: 		** a recompilation of an already prepared statement.
0: 		*/ 
0: 		return prepMinion(lcc, true, (Object[]) null, (SchemaDescriptor) null, forMetaData); 
0: 	}
commit:6d9c32a
/////////////////////////////////////////////////////////////////////////
1: 					//Derby424 - In order to avoid caching select statements referencing
1: 					// any SESSION schema objects (including statements referencing views
1: 					// in SESSION schema), we need to do the SESSION schema object check
1: 					// here.  
1: 					//a specific eg for statement referencing a view in SESSION schema 
1: 					//CREATE TABLE t28A (c28 int)
1: 					//INSERT INTO t28A VALUES (280),(281)
1: 					//CREATE VIEW SESSION.t28v1 as select * from t28A
1: 					//SELECT * from SESSION.t28v1 should show contents of view and we
1: 					// should not cache this statement because a user can later define
1: 					// a global temporary table with the same name as the view name.
1: 					//Following demonstrates that
1: 					//DECLARE GLOBAL TEMPORARY TABLE SESSION.t28v1(c21 int, c22 int) not
1: 					//     logged
1: 					//INSERT INTO SESSION.t28v1 VALUES (280,1),(281,2)
1: 					//SELECT * from SESSION.t28v1 should show contents of global temporary
1: 					//table and not the view.  Since this select statement was not cached
1: 					// earlier, it will be compiled again and will go to global temporary
1: 					// table to fetch data. This plan will not be cached either because
1: 					// select statement is using SESSION schema object.
1: 					//
1: 					//Following if statement makes sure that if the statement is
1: 					// referencing SESSION schema objects, then we do not want to cache it.
1: 					// We will remove the entry that was made into the cache for 
1: 					//this statement at the beginning of the compile phase.
1: 					//The reason we do this check here rather than later in the compile
1: 					// phase is because for a view, later on, we loose the information that
1: 					// it was referencing SESSION schema because the reference
1: 					//view gets replaced with the actual view definition. Right after
1: 					// binding, we still have the information on the view and that is why
1: 					// we do the check here.
1: 					if (preparedStmt.referencesSessionSchema(qt)) {
0: 						if (foundInCache)
0: 							((GenericLanguageConnectionContext)lcc).removeStatement(this);
0: 					}
0: 					
/////////////////////////////////////////////////////////////////////////
1: 					preparedStmt.completeCompile(qt);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1:         private final boolean isForReadOnly;
0: 	 * @param compliationSchema schema
1: 	 * @param isForReadOnly if the statement is opened with level CONCUR_READ_ONLY
1: 	public GenericStatement(SchemaDescriptor compilationSchema, String statementText, boolean isForReadOnly)
1: 		this.isForReadOnly = isForReadOnly;
/////////////////////////////////////////////////////////////////////////
1: 				statementContext = lcc.pushStatementContext(true, isForReadOnly, getSource(),
/////////////////////////////////////////////////////////////////////////
1: 			return statementText.equals(os.statementText) && isForReadOnly==os.isForReadOnly
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Statement;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionFactory;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.sql.compile.Parser;
0: 
0: import org.apache.derby.impl.sql.compile.QueryTreeNode;
0: import org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: import org.apache.derby.iapi.util.ByteArray;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
0: 
0: public class GenericStatement
0: 	implements Statement {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	// these fields define the identity of the statement
0: 	private final SchemaDescriptor compilationSchema;
0: 	private final String			statementText;
0: 	private int                      prepareIsolationLevel;
0: 	private GenericPreparedStatement preparedStmt;
0: 
0: 	/**
0: 	 * Constructor for a Statement given the text of the statement in a String
0: 	 *
0: 	 * @param statementText	The text of the statement
0: 	 */
0: 
0: 	public GenericStatement(SchemaDescriptor compilationSchema, String statementText)
0: 	{
0: 		this.compilationSchema = compilationSchema;
0: 		this.statementText = statementText;
0: 	}
0: 
0: 	/*
0: 	 * Statement interface
0: 	 */
0: 
0: 
0: 	/* RESOLVE: may need error checking, debugging code here */
0: 	public PreparedStatement prepare(LanguageConnectionContext lcc) throws StandardException
0: 	{
0: 		/*
0: 		** Note: don't reset state since this might be
0: 		** a recompilation of an already prepared statement.
0: 		*/ 
0: 		return prepMinion(lcc, true, (Object[]) null, (SchemaDescriptor) null, false); 
0: 	}
0: 
0: 	private PreparedStatement prepMinion(LanguageConnectionContext lcc, boolean cacheMe, Object[] paramDefaults,
0: 		SchemaDescriptor spsSchema, boolean internalSQL)
0: 		throws StandardException
0: 	{
0: 						  
0: 		long				beginTime = 0;
0: 		long				parseTime = 0;
0: 		long				bindTime = 0;
0: 		long				optimizeTime = 0;
0: 		long				generateTime = 0;
0: 		Timestamp			beginTimestamp = null;
0: 		Timestamp			endTimestamp = null;
0: 		StatementContext	statementContext = null;
0: 
0: 		// verify it isn't already prepared...
0: 		// if it is, and is valid, simply return that tree.
0: 		// if it is invalid, we will recompile now.
0: 		if (preparedStmt != null) {
0: 			if (preparedStmt.upToDate())
0: 				return preparedStmt;
0: 		}
0: 
0: 		// Clear the optimizer trace from the last statement
0: 		if (lcc.getOptimizerTrace())
0: 			lcc.setOptimizerTraceOutput(getSource() + "\n");
0: 
0: 		beginTime = getCurrentTimeMillis(lcc);
0: 		/* beginTimestamp only meaningful if beginTime is meaningful.
0: 		 * beginTime is meaningful if STATISTICS TIMING is ON.
0: 		 */
0: 		if (beginTime != 0)
0: 		{
0: 			beginTimestamp = new Timestamp(beginTime);
0: 		}
0: 
0: 		/** set the prepare Isolaton from the LanguageConnectionContext now as 
0: 		 * we need to consider it in caching decisions
0: 		 */
0: 		prepareIsolationLevel = lcc.getPrepareIsolationLevel();
0: 
0: 		/* a note on statement caching:
0: 		 * 
0: 		 * A GenericPreparedStatement (GPS) is only added it to the cache if the
0: 		 * parameter cacheMe is set to TRUE when the GPS is created.
0: 		 * 
0: 		 * Earlier only CacheStatement (CS) looked in the statement cache for a
0: 		 * prepared statement when prepare was called. Now the functionality 
0: 		 * of CS has been folded into GenericStatement (GS). So we search the
0: 		 * cache for an existing PreparedStatement only when cacheMe is TRUE.
0: 		 * i.e if the user calls prepare with cacheMe set to TRUE:
0: 		 * then we 
0: 		 *         a) look for the prepared statement in the cache.
0: 		 *         b) add the prepared statement to the cache.
0: 		 *
0: 		 * In cases where the statement cache has been disabled (by setting the
0: 		 * relevant cloudscape property) then the value of cacheMe is irrelevant.
0: 		 */ 
0: 		boolean foundInCache = false;
0: 		if (preparedStmt == null) 
0: 		{
0: 			if (cacheMe)
0: 				preparedStmt = (GenericPreparedStatement)((GenericLanguageConnectionContext)lcc).lookupStatement(this);
0: 
0: 			if (preparedStmt == null) 
0: 			{
0: 				preparedStmt = new GenericPreparedStatement(this);
0: 			}
0: 			else
0: 			{
0: 				foundInCache = true;
0: 			}
0: 		}
0: 
0: 		// if anyone else also has this prepared statement,
0: 		// we don't want them trying to compile with it while
0: 		// we are.  So, we synchronize on it and re-check
0: 		// its validity first.
0: 		// this is a no-op if and until there is a central
0: 		// cache of prepared statement objects...
0: 		synchronized (preparedStmt) 
0: 		{
0: 
0: 			for (;;) {
0: 
0: 				if (foundInCache) {
0: 					if (preparedStmt.referencesSessionSchema()) {
0: 						// cannot use this state since it is private to a connection.
0: 						// switch to a new statement.
0: 						foundInCache = false;
0: 						preparedStmt = new GenericPreparedStatement(this);
0: 						break;
0: 					}
0: 				}
0: 
0: 				// did it get updated while we waited for the lock on it?
0: 				if (preparedStmt.upToDate()) {
0: 					return preparedStmt;
0: 				}
0: 
0: 				if (!preparedStmt.compilingStatement) {
0: 					break;
0: 				}
0: 
0: 				try {
0: 					preparedStmt.wait();
0: 				} catch (InterruptedException ie) {
0: 					throw StandardException.interrupt(ie);
0: 				}
0: 			}
0: 
0: 			preparedStmt.compilingStatement = true;
0: 			preparedStmt.setActivationClass(null);
0: 		}
0: 
0: 		try {
0: 
0: 			HeaderPrintWriter istream = lcc.getLogStatementText() ? Monitor.getStream() : null;
0: 
0: 			/*
0: 			** For stored prepared statements, we want all
0: 			** errors, etc in the context of the underlying
0: 			** EXECUTE STATEMENT statement, so don't push/pop
0: 			** another statement context unless we don't have
0: 			** one.  We won't have one if it is an internal
0: 			** SPS (e.g. jdbcmetadata).
0: 			*/
0: 			if (!preparedStmt.isStorable() || lcc.getStatementDepth() == 0)
0: 			{
0: 				// since this is for compilation only, set atomic
0: 				// param to true
0: 				statementContext = lcc.pushStatementContext(true, getSource(), null, false);
0: 			}
0: 
0: 
0: 
0: 			/*
0: 			** RESOLVE: we may ultimately wish to pass in
0: 			** whether we are a jdbc metadata query or not to
0: 			** get the CompilerContext to make the createDependency()
0: 			** call a noop.
0: 			*/
0: 			CompilerContext cc = lcc.pushCompilerContext(compilationSchema);
0: 			
0: 			if (prepareIsolationLevel != 
0: 				ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
0: 			{
0: 				cc.setScanIsolationLevel(prepareIsolationLevel);
0: 			}
0: 
0: 
0: 			// Look for stored statements that are in a system schema
0: 			// and with a match compilation schema. If so, allow them
0: 			// to compile using internal SQL constructs.
0: 
0: 			if (internalSQL ||
0: 				(spsSchema != null) && (spsSchema.isSystemSchema()) &&
0: 					(spsSchema.equals(compilationSchema))) {
0: 						cc.setReliability(CompilerContext.INTERNAL_SQL_LEGAL);
0: 			}
0: 
0: 			try 
0: 			{
0: 				// Statement logging if lcc.getLogStatementText() is true
0: 				if (istream != null)
0: 				{
0: 					String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
0: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 											  xactId + 
0: 											  "), " +
0: 											  LanguageConnectionContext.lccStr +
0: 												  lcc.getInstanceNumber() +
0: 											  "), " +
0: 											  LanguageConnectionContext.dbnameStr +
0: 												  lcc.getDbname() +
0: 											  "), " +
0: 											  LanguageConnectionContext.drdaStr +
0: 												  lcc.getDrdaID() +
0: 											  "), Begin compiling prepared statement: " + 
0: 											  getSource() +
0: 											  " :End prepared statement");
0: 				}
0: 
0: 				Parser p = cc.getParser();
0: 
0: 				cc.setCurrentDependent(preparedStmt);
0: 
0: 				//Only top level statements go through here, nested statement
0: 				//will invoke this method from other places
0: 				QueryTreeNode qt = p.parseStatement(statementText, paramDefaults);
0: 
0: 				parseTime = getCurrentTimeMillis(lcc);
0: 
0: 				if (SanityManager.DEBUG) 
0: 				{
0: 					if (SanityManager.DEBUG_ON("DumpParseTree")) 
0: 					{
0: 						qt.treePrint();
0: 					}
0: 
0: 					if (SanityManager.DEBUG_ON("StopAfterParsing")) 
0: 					{
0: 						throw StandardException.newException(SQLState.LANG_STOP_AFTER_PARSING);
0: 					}
0: 				}
0: 
0: 				/*
0: 				** Tell the data dictionary that we are about to do
0: 				** a bunch of "get" operations that must be consistent with
0: 				** each other.
0: 				*/
0: 				
0: 				DataDictionary dataDictionary = lcc.getDataDictionary();
0: 
0: 				int ddMode = dataDictionary == null ? 0 : dataDictionary.startReading(lcc);
0: 
0: 				try
0: 				{
0: 					// start a nested transaction -- all locks acquired by bind
0: 					// and optimize will be released when we end the nested
0: 					// transaction.
0: 					lcc.beginNestedTransaction(true);
0: 
0: 					qt = qt.bind();
0: 					bindTime = getCurrentTimeMillis(lcc);
0: 
0: 					if (SanityManager.DEBUG) 
0: 					{
0: 						if (SanityManager.DEBUG_ON("DumpBindTree")) 
0: 						{
0: 							qt.treePrint();
0: 						}
0: 
0: 						if (SanityManager.DEBUG_ON("StopAfterBinding")) {
0: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_BINDING);
0: 						}
0: 					}
0: 
0: 					qt = qt.optimize();
0: 
0: 					optimizeTime = getCurrentTimeMillis(lcc);
0: 
0: 					// Statement logging if lcc.getLogStatementText() is true
0: 					if (istream != null)
0: 					{
0: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
0: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 												  xactId + 
0: 												  "), " +
0: 												  LanguageConnectionContext.lccStr +
0: 												  lcc.getInstanceNumber() +
0: 												  "), " +
0: 												  LanguageConnectionContext.dbnameStr +
0: 												  lcc.getDbname() +
0: 												  "), " +
0: 												  LanguageConnectionContext.drdaStr +
0: 												  lcc.getDrdaID() +
0: 												  "), End compiling prepared statement: " + 
0: 												  getSource() +
0: 												  " :End prepared statement");
0: 					}
0: 				}
0: 
0: 				catch (StandardException se)
0: 				{
0: 					lcc.commitNestedTransaction();
0: 					if (foundInCache)
0: 						((GenericLanguageConnectionContext)lcc).removeStatement(this);
0: 
0: 
0: 					// Statement logging if lcc.getLogStatementText() is true
0: 					if (istream != null)
0: 					{
0: 						String xactId = lcc.getTransactionExecute().getActiveStateTxIdString();
0: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 												  xactId + 
0: 												  "), " +
0: 												  LanguageConnectionContext.lccStr +
0: 												  lcc.getInstanceNumber() +
0: 												  "), " +
0: 												  LanguageConnectionContext.dbnameStr +
0: 												  lcc.getDbname() +
0: 												  "), " +
0: 												  LanguageConnectionContext.drdaStr +
0: 												  lcc.getDrdaID() +
0: 												  "), Error compiling prepared statement: " + 
0: 												  getSource() +
0: 												  " :End prepared statement");
0: 					}
0: 					throw se;
0: 				}
0: 
0: 				finally
0: 				{
0: 					/* Tell the data dictionary that we are done reading */
0: 					if (dataDictionary != null)
0: 					dataDictionary.doneReading(ddMode, lcc);
0: 				}
0: 
0: 				/* we need to move the commit of nested sub-transaction
0: 				 * after we mark PS valid, during compilation, we might need
0: 				 * to get some lock to synchronize with another thread's DDL
0: 				 * execution, in particular, the compilation of insert/update/
0: 				 * delete vs. create index/constraint (see Beetle 3976).  We
0: 				 * can't release such lock until after we mark the PS valid.
0: 				 * Otherwise we would just erase the DDL's invalidation when
0: 				 * we mark it valid.
0: 				 */
0: 				try		// put in try block, commit sub-transaction if bad
0: 				{
0: 					if (SanityManager.DEBUG) 
0: 					{
0: 						if (SanityManager.DEBUG_ON("DumpOptimizedTree")) 
0: 						{
0: 							qt.treePrint();
0: 						}
0: 
0: 						if (SanityManager.DEBUG_ON("StopAfterOptimizing")) 
0: 						{
0: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_OPTIMIZING);
0: 						}
0: 					}
0: 
0: 					GeneratedClass ac = qt.generate(preparedStmt.getByteCodeSaver());
0: 
0: 					generateTime = getCurrentTimeMillis(lcc);
0: 					/* endTimestamp only meaningful if generateTime is meaningful.
0: 					 * generateTime is meaningful if STATISTICS TIMING is ON.
0: 					 */
0: 					if (generateTime != 0)
0: 					{
0: 						endTimestamp = new Timestamp(generateTime);
0: 					}
0: 
0: 					if (SanityManager.DEBUG) 
0: 					{
0: 						if (SanityManager.DEBUG_ON("StopAfterGenerating")) 
0: 						{
0: 							throw StandardException.newException(SQLState.LANG_STOP_AFTER_GENERATING);
0: 						}
0: 					}
0: 
0: 					/*
0: 						copy over the compile-time created objects
0: 						to the prepared statement.  This always happens
0: 						at the end of a compile, so there is no need
0: 						to erase the previous entries on a re-compile --
0: 						this erases as it replaces.  Set the activation
0: 						class in case it came from a StorablePreparedStatement
0: 					*/
0: 					preparedStmt.setConstantAction( qt.makeConstantAction() );
0: 					preparedStmt.setSavedObjects( cc.getSavedObjects() );
0: 					preparedStmt.setActivationClass(ac);
0: 					preparedStmt.setParams(cc.getParams());
0: 					preparedStmt.setNeedsSavepoint(qt.needsSavepoint());
0: 					preparedStmt.setCursorInfo((CursorInfo)cc.getCursorInfo());
0: 					preparedStmt.setIsAtomic(qt.isAtomic());
0: 					preparedStmt.setExecuteStatementNameAndSchema(
0: 												qt.executeStatementName(),
0: 												qt.executeSchemaName()
0: 												);
0: 					preparedStmt.setSPSName(qt.getSPSName());
0: 
0: 					//if this statement is referencing session schema tables, then we do not want cache it. Following will remove the
0: 					//entry that was made into the cache for this statement at the beginning of the compile phase
0: 					if (preparedStmt.completeCompile(qt)) {
0: 						if (foundInCache)
0: 							((GenericLanguageConnectionContext)lcc).removeStatement(this);
0: 					}
0: 
0: 					preparedStmt.setCompileTimeWarnings(cc.getWarnings());
0: 				}
0: 				catch (StandardException e) 	// hold it, throw it
0: 				{
0: 					lcc.commitNestedTransaction();
0: 					if (foundInCache)
0: 						((GenericLanguageConnectionContext)lcc).removeStatement(this);
0: 					throw e;
0: 				}
0: 
0: 				if (lcc.getRunTimeStatisticsMode())
0: 				{
0: 					preparedStmt.setCompileTimeMillis(
0: 						parseTime - beginTime, //parse time
0: 						bindTime - parseTime, //bind time
0: 						optimizeTime - bindTime, //optimize time
0: 						generateTime - optimizeTime, //generate time
0: 						getElapsedTimeMillis(beginTime),
0: 						beginTimestamp,
0: 						endTimestamp);
0: 				}
0: 
0: 			}
0: 			finally // for block introduced by pushCompilerContext()
0: 			{
0: 				lcc.popCompilerContext( cc );
0: 			}
0: 		}
0: 		finally
0: 		{
0: 			synchronized (preparedStmt) {
0: 				preparedStmt.compilingStatement = false;
0: 				preparedStmt.notifyAll();
0: 			}
0: 		}
0: 
0: 		lcc.commitNestedTransaction();
0: 
0: 		if (statementContext != null)
0: 			lcc.popStatementContext(statementContext, null);
0: 
0: 		return preparedStmt;
0: 	}
0: 
0: 	/**
0: 	 * Generates an execution plan given a set of named parameters.
0: 	 * Does so for a storable prepared statement.
0: 	 *
0: 	 * @param 	compilationSchema	the schema to compile against
0: 	 * @param	paramDefaults		Parameter defaults
0: 	 *
0: 	 * @return A PreparedStatement that allows execution of the execution
0: 	 *	   plan.
0: 	 * @exception StandardException	Thrown if this is an
0: 	 *	   execution-only version of the module (the prepare() method
0: 	 *	   relies on compilation).
0: 	 */
0: 	public	PreparedStatement prepareStorable(
0: 				LanguageConnectionContext lcc,
0: 				PreparedStatement ps,
0: 				Object[]			paramDefaults,
0: 				SchemaDescriptor	spsSchema,
0: 				boolean internalSQL)
0: 		throws StandardException
0: 	{
0: 		if (ps == null)
0: 			ps = new GenericStorablePreparedStatement(this);
0: 		else
0: 			((GenericPreparedStatement) ps).statement = this;
0: 
0: 		this.preparedStmt = (GenericPreparedStatement) ps;
0: 		return prepMinion(lcc, false, paramDefaults, spsSchema, internalSQL);
0: 	}
0: 
0: 	public String getSource() {
0: 		return statementText;
0: 	}
0: 
0: 	public boolean getUnicode() {
0: 		return true;
0: 	}
0: 
0: 	public String getCompilationSchema() {
0: 		return compilationSchema.getDescriptorName();
0: 	}
0: 
0: 	private static long getCurrentTimeMillis(LanguageConnectionContext lcc)
0: 	{
0: 		if (lcc.getStatisticsTiming())
0: 		{
0: 			return System.currentTimeMillis();
0: 		}
0: 		else
0: 		{
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	private static long getElapsedTimeMillis(long beginTime)
0: 	{
0: 		if (beginTime != 0)
0: 		{
0: 			return System.currentTimeMillis() - beginTime;
0: 		}
0: 		else
0: 		{
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Identity
0: 	*/
0: 
0: 	public boolean equals(Object other) {
0: 
0: 		if (other instanceof GenericStatement) {
0: 
0: 			GenericStatement os = (GenericStatement) other;
0: 
0: 			return statementText.equals(os.statementText)
0: 				&& compilationSchema.equals(os.compilationSchema) &&
0: 				(prepareIsolationLevel == os.prepareIsolationLevel);
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	public int hashCode() {
0: 
0: 		return statementText.hashCode();
0: 	}
0: }
============================================================================