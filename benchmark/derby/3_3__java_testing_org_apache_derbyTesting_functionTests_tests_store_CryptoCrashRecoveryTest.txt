1:698e880: /*
6:698e880: 
1:698e880:    Derby - Class org.apache.derbyTesting.functionTests.store.CryptoCrashRecoveryTest
1:698e880: 
1:698e880:    Licensed to the Apache Software Foundation (ASF) under one or more
1:698e880:    contributor license agreements.  See the NOTICE file distributed with
1:698e880:    this work for additional information regarding copyright ownership.
1:698e880:    The ASF licenses this file to You under the Apache License, Version 2.0
1:698e880:    (the "License"); you may not use this file except in compliance with
1:698e880:    the License.  You may obtain a copy of the License at
1:698e880: 
1:698e880:       http://www.apache.org/licenses/LICENSE-2.0
1:698e880: 
1:698e880:    Unless required by applicable law or agreed to in writing, software
1:698e880:    distributed under the License is distributed on an "AS IS" BASIS,
1:698e880:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:698e880:    See the License for the specific language governing permissions and
1:698e880:    limitations under the License.
1:698e880: 
1:698e880:  */
1:698e880: 
1:698e880: package org.apache.derbyTesting.functionTests.tests.store;
1:698e880: 
1:698e880: import java.io.File;
1:698e880: import java.sql.Connection;
1:698e880: import java.sql.PreparedStatement;
1:698e880: import java.sql.ResultSet;
1:698e880: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:698e880: import javax.sql.DataSource;
1:698e880: import junit.framework.Test;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:698e880: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:698e880: import org.apache.derbyTesting.junit.JDBC;
1:698e880: import org.apache.derbyTesting.junit.JDBCDataSource;
1:698e880: import org.apache.derbyTesting.junit.TestConfiguration;
1:698e880: 
1:698e880: /**
1:698e880:  * This class tests crash/recovery scenarios during cryptographic operations on
1:698e880:  * the database.
1:698e880:  * <p>
1:698e880:  * Debug flags are used to simulate crashes during the encryption of an
1:d203eea:  * un-encrypted database, re-encryption of an encrypted database with new
1:d203eea:  * password/key, and decryption of an encrypted database.
1:698e880:  * <p>
1:698e880:  * Unlike the other recovery tests which do a setup and recovery as different
1:698e880:  * tests, crash/recovery for cryptographic operations can be simulated in one
1:698e880:  * test itself because the cryptographic operation is performed at boot time.
1:698e880:  * When debug flags are set the database boot itself fails. To test the
1:698e880:  * recovery, it is just a matter of clearing up the debug flag and rebooting
1:698e880:  * the database.
1:698e880:  * <p>
1:698e880:  * In non-debug mode (compiled as "insane") this test does nothing.
1:698e880:  */
1:698e880: public class CryptoCrashRecoveryTest
1:698e880:     extends BaseJDBCTestCase {
1:698e880: 
1:698e880:     private static boolean USE_ENC_PWD = true;
1:698e880:     private static boolean USE_ENC_KEY = false;
1:698e880: 
1:698e880:     private static final int OP_ENCRYPT = 0;
1:698e880:     private static final int OP_DECRYPT = 1;
1:698e880:     private static final int OP_REENCRYPT = 2;
1:698e880: 
1:698e880:     /** Table name used by the test. */
1:698e880:     private static final String TEST_TABLE_NAME = "emp";
1:698e880: 
1:698e880:     private static final String OLD_PASSWORD = "xyz1234abc";
1:698e880:     private static final String NEW_PASSWORD = "new1234xyz";
1:698e880: 
1:698e880:     private static final String OLD_KEY = "6162636465666768";
1:698e880:     private static final String NEW_KEY = "5666768616263646";
1:698e880: 
1:698e880: 	public CryptoCrashRecoveryTest(String name) {
1:698e880:         super(name);
3:698e880: 	}
1:698e880: 
1:698e880:     public static Test suite() {
1:698e880:         Test suite;
1:698e880:         if (SanityManager.DEBUG) {
1:698e880:             suite = TestConfiguration.embeddedSuite(
1:698e880:                     CryptoCrashRecoveryTest.class);
3:698e880:         } else {
1:1ae02c9:             suite = new BaseTestSuite(
1:d203eea:                     "CryptoCrashRecovery disabled due to non-debug build");
1:d203eea:             println("CryptoCrashRecoveryTest disabled due to non-debug build");
1:698e880:         }
1:698e880:         return suite;
1:698e880:     }
1:698e880: 
1:d203eea: 	public void testDecryptionWithBootPassword()
1:d203eea:             throws Exception {
1:d203eea:         String db = "wombat_pwd_de";
1:d203eea:         // Crash recovery during decryption (with password mechanism).
1:d203eea:         DataSource ds = JDBCDataSource.getDataSource(db);
1:d203eea:         runCrashRecoveryTestCases(ds, OP_DECRYPT, USE_ENC_PWD);
1:d203eea:         assertDirectoryDeleted(new File("system", db));
1:d203eea:     }
1:d203eea: 
1:d203eea:     public void testDecryptionWithEncryptionKey()
1:d203eea:             throws Exception {
1:d203eea:         String db = "wombat_key_de";
1:d203eea:         // Crash recovery during database decryption (with encryption key).
1:d203eea:         DataSource ds = JDBCDataSource.getDataSource(db);
1:d203eea:         runCrashRecoveryTestCases(ds, OP_DECRYPT, USE_ENC_KEY);
1:d203eea:         assertDirectoryDeleted(new File("system", db));
1:d203eea:     }
1:d203eea: 
1:698e880: 	public void testEncryptionWithBootPassword()
1:698e880:             throws Exception {
1:698e880:         String db = "wombat_pwd_en";
1:698e880:         // Crash recovery during encryption using the password mechanism.
1:698e880:         DataSource ds = JDBCDataSource.getDataSource(db);
1:698e880:         runCrashRecoveryTestCases(ds, OP_ENCRYPT, USE_ENC_PWD);
1:698e880:         assertDirectoryDeleted(new File("system", db));
1:698e880:     }
1:698e880: 
1:d203eea: 	public void testEncryptionWithEncryptionKey()
1:698e880:             throws Exception {
1:698e880:         String db = "wombat_key_en";
1:698e880:         // Crash recovery during database encryption using the encryption key.
1:698e880:         DataSource ds = JDBCDataSource.getDataSource(db);
1:698e880:         runCrashRecoveryTestCases(ds, OP_ENCRYPT, USE_ENC_KEY);
1:698e880:         assertDirectoryDeleted(new File("system", db));
1:698e880:     }
1:698e880: 
1:698e880: 	public void testReEncryptionWithBootPassword()
1:698e880:             throws Exception {
1:698e880:         String db = "wombat_pwd_ren";
1:698e880:         // Crash recovery during re-encryption using the password mechanism.
1:698e880:         DataSource ds = JDBCDataSource.getDataSource(db);
1:698e880:         runCrashRecoveryTestCases(ds, OP_REENCRYPT, USE_ENC_PWD);
1:698e880:         assertDirectoryDeleted(new File("system", db));
1:698e880:     }
1:698e880: 
1:698e880: 	public void testReEncryptionWithEncryptionKey()
1:698e880:             throws Exception {
1:698e880:         String db = "wombat_key_ren";
1:698e880:         // Crash recovery during re-encryption using an encryption key.
1:698e880:         DataSource ds = JDBCDataSource.getDataSource(db);
1:698e880:         runCrashRecoveryTestCases(ds, OP_REENCRYPT, USE_ENC_KEY);
1:698e880:         assertDirectoryDeleted(new File("system", db));
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Runs crash recovery test scenarios for the given cryptographic operation
1:698e880:      * using the debug flags.
1:698e880:      *
1:698e880:      * @param ds data source
1:698e880:      * @param operation the cryptographic operation to perform
1:698e880:      * @param useEncPwd whether to use encryption key or boot password (see
1:698e880:      *      {@linkplain #USE_ENC_KEY} and {@linkplain #USE_ENC_PWD})
1:698e880:      */
1:698e880:     private void runCrashRecoveryTestCases(DataSource ds, int operation,
1:698e880:                                            boolean useEncPwd)
1:698e880:             throws SQLException {
1:d203eea:         Connection con = null; // silence the compiler
1:d203eea:         switch (operation) {
1:d203eea:             case OP_DECRYPT:
1:d203eea:                 // Fall through.
1:d203eea:             case OP_REENCRYPT:
1:d203eea:                 con = createEncryptedDatabase(ds, useEncPwd);
1:d203eea:                 break;
1:d203eea:             case OP_ENCRYPT:
1:d203eea:                 con = createDatabase(ds);
1:d203eea:                 break;
1:d203eea:             default:
1:d203eea:                 fail("unsupported operation: " + operation);
1:698e880:         }
1:698e880: 
1:698e880:         createTable(con, TEST_TABLE_NAME);
1:698e880:         // Load some rows, used for verification later.
1:698e880:         insert(con, TEST_TABLE_NAME, 100);
1:698e880:         con.commit();
1:698e880:         con.close();
1:698e880:         JDBCDataSource.shutdownDatabase(ds);
1:698e880: 
1:d203eea:         // Following cases of cryptographic operations should be rolled back.
1:698e880:         Boolean useNewCredential =
1:698e880:                 (operation == OP_REENCRYPT ? Boolean.FALSE : null);
1:698e880: 
1:698e880:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_BEFORE_COMMT);
1:698e880: 
1:698e880:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1:698e880: 
1:698e880: 
1:698e880:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
1:d203eea:         // Retry operation and crash.
1:698e880:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1:698e880: 
1:698e880:         crash(ds, operation, useEncPwd,
1:698e880:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1:698e880: 
1:698e880:         crash(ds, operation, useEncPwd,
1:698e880:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
1:d203eea:         // Retry operation and crash.
1:698e880:         crash(ds, operation, useEncPwd,
1:698e880:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1:698e880: 
1:d203eea:         // Following cases should be successful, only cleanup is pending.
1:d203eea:         // Crash after the cryptographic operation has been performed, but
1:d203eea:         // before cleanup.
1:698e880:         // If re-encryption is complete, database should be bootable with the
1:d203eea:         // new password. If decryption is complete, database should be bootable
1:d203eea:         // without specifying a boot password / key.
1:698e880:         useNewCredential =
1:698e880:                 (operation == OP_REENCRYPT ? Boolean.TRUE : Boolean.FALSE);
1:698e880:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT);
1:698e880:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:698e880:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1:d203eea:         if (operation == OP_DECRYPT) {
1:d203eea:             useNewCredential = null;
1:d203eea:         }
1:698e880:         recover(ds, useEncPwd, useNewCredential);
1:698e880:         JDBCDataSource.shutdownDatabase(ds);
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Crashes the engine at the point specified by the debug flag while
1:698e880:      * performing the requested operation.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param operation cryptographic operation to perform
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      * @param debugFlag debug flag to enable to make the engine crash
1:698e880:      */
1:698e880:     private void crash(DataSource ds, int operation, boolean useEncPwd,
1:698e880:                        String debugFlag) {
1:698e880:         println("Testing crash at " + debugFlag);
1:698e880:         // Set the debug flag to crash.
1:698e880:         setDebugFlag(debugFlag);
1:698e880: 
1:698e880:         try {
1:d203eea:             switch (operation) {
1:d203eea:                 case OP_REENCRYPT:
1:d203eea:                     reEncryptDatabase(ds, useEncPwd);
1:d203eea:                     break;
1:d203eea:                 case OP_ENCRYPT:
1:d203eea:                     encryptDatabase(ds, useEncPwd);
1:d203eea:                     break;
1:d203eea:                 case OP_DECRYPT:
1:d203eea:                     decryptDatabase(ds, useEncPwd);
1:d203eea:                     break;
1:d203eea:                 default:
1:d203eea:                     fail("unsupported operation");
1:698e880:             }
1:698e880:             fail("crypto operation didn't crash as expected");
1:698e880:         } catch (SQLException sqle) {
1:698e880:             // check that database boot failed at the set debug flag.
1:698e880:             verifyBootException(sqle, debugFlag);
1:698e880:         } finally {
1:698e880:             clearDebugFlag(debugFlag);
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Crashes the engine in recovery of the given database at the point
1:698e880:      * specified by the debug flag.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      * @param useNewCredential tri-state telling whether to use the old, the
1:698e880:      *      new, or no credential when booting the database
1:698e880:      * @param debugFlag debug flag to enable to make the engine crash
1:698e880:      */
1:698e880:     private void crashInRecovery(DataSource ds, boolean useEncPwd,
1:698e880:                                  Boolean useNewCredential, String debugFlag)
1:698e880:             throws SQLException {
1:698e880:         println("Recovery crash at " + debugFlag);
1:698e880: 
1:698e880:         // set the debug flag to crash.
1:698e880:         setDebugFlag(debugFlag);
1:698e880:         try {
1:698e880:             bootDatabase(ds, useEncPwd, useNewCredential);
1:698e880:             fail("database booted unexpectedly");
1:698e880:         } catch (SQLException sqle) {
1:698e880:             // check that database boot failed at the set debug flag.
1:698e880:             verifyBootException(sqle, debugFlag);
1:698e880:         } finally {
1:698e880:             clearDebugFlag(debugFlag);
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /*
1:698e880:      * Recover the database that failed during re-encryption and
1:698e880:      * perform some simple sanity checks on the database.
1:698e880:      */
1:698e880:     private void recover(DataSource ds, boolean useEncKey,
1:698e880:                          Boolean useNewCredential)
1:698e880:             throws SQLException {
1:698e880:         // starting recovery of database with failed Re-encryption
1:698e880:         // in debug mode;
1:698e880: 
1:698e880:         Connection con = bootDatabase(ds, useEncKey, useNewCredential);
1:698e880: 
1:698e880:         // Verify that the contents of the db are ok.
1:698e880:         runConsistencyChecker(con, TEST_TABLE_NAME);
1:698e880:         // Insert some rows, this might fail if anything is
1:698e880:         // wrong in the logging system setup.
1:698e880:         insert(con, TEST_TABLE_NAME, 100);
1:698e880:         con.commit();
1:698e880:         con.close();
1:698e880:     }
1:698e880: 
1:698e880:     // Debug flags are set to simulate a crash at different
1:698e880:     // points during a cryptographic operation on the database.
1:698e880:     // These flags should match the flags in the engine code, and they
1:698e880:     // are redefined here to avoid pulling the engine code into the tests.
1:698e880: 
1:698e880: 	private static final String TEST_REENCRYPT_CRASH_BEFORE_COMMT =
1:698e880:             "TEST_REENCRYPT_CRASH_BEFORE_COMMT";
1:698e880:     private static final String TEST_REENCRYPT_CRASH_AFTER_COMMT =
1:698e880:             "TEST_REENCRYPT_CRASH_AFTER_COMMT";
1:698e880:     private static final String TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY =
1:698e880:         "TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY";
1:698e880:     private static final String TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT =
1:698e880:         "TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT";
1:698e880:     private static final String
1:698e880:         TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE =
1:698e880:             "TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE";
1:698e880:     private static final String
1:698e880:         TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY =
1:698e880:             "TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY";
1:698e880:     private static final String
1:698e880:         TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP =
1:698e880:             "TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP";
1:698e880: 
1:698e880:     private void setDebugFlag(String debugFlag) {
1:698e880:         if (SanityManager.DEBUG) {
1:698e880:             SanityManager.DEBUG_SET(debugFlag);
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     private void clearDebugFlag(String debugFlag) {
1:698e880:         if (SanityManager.DEBUG) {
1:698e880:             SanityManager.DEBUG_CLEAR(debugFlag);
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Verifies that database boot failed because of the right reasons.
1:698e880:      *
1:698e880:      * @param sqle the exception thrown when
1:698e880:      * @param debugFlag the debug flag that was set before booting
1:698e880:      * @throws junit.framework.AssertionFailedError if the boot failure is
1:698e880:      *      deemed invalid
1:698e880:      */
1:698e880:     private void verifyBootException(SQLException sqle, String debugFlag) {
1:698e880:         assertSQLState("XJ040", sqle);
1:698e880:         // Boot failed as expected triggered by a debug flag.
1:698e880:         // Now check if it failed because of the expected debug flag.
1:698e880:         SQLException ne = sqle.getNextException();
1:698e880:         while (ne != null) {
1:698e880:             String message = ne.getMessage();
1:698e880:             // Check if debug flag exists in the message.
1:698e880:             if (message.indexOf(debugFlag) != -1) {
2:698e880:                 return;
1:698e880:             }
1:698e880:             ne = ne.getNextException();
1:698e880:         }
1:698e880:         fail("real error or wrong debug flag triggered crash", sqle);
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Creates the table that is used by this test.
1:698e880:      *
1:698e880:      * @param con connection to the database
1:698e880:      * @param tableName  name of the table to create
1:698e880:      * @exception SQLException if any database exception occurs.
1:698e880:      */
1:698e880:     private void createTable(Connection con, String tableName)
1:698e880:             throws SQLException {
1:698e880:         Statement s = con.createStatement();
1:698e880:         s.executeUpdate("CREATE TABLE " + tableName +
1:698e880:                         "(id INT," +
1:698e880:                         "name VARCHAR(200))");
1:698e880:         s.executeUpdate("create index " + tableName + "_id_idx on " +
1:698e880:                         tableName + "(id)");
1:698e880:         s.close();
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880: 	 * Runs some consistency checks on the specified table.
1:698e880:      *
1:698e880:      * @param con connection to the database
1:698e880: 	 * @param tableName target table
1:698e880:      * @exception SQLException if any database exception occurs
1:698e880: 	 */
1:698e880: 	private void runConsistencyChecker(Connection con, String tableName)
1:698e880:             throws SQLException {
1:698e880: 		Statement stmt = con.createStatement();
1:698e880: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
1:698e880:         // Check the data in the EMP table.
1:698e880:         verifyContents(con, tableName);
1:698e880: 	}
1:698e880: 
1:698e880:     /**
1:698e880:      * Inserts rows into the specified table.
1:698e880:      *
1:698e880:      * @param con connection to the database
1:698e880:      * @param tableName target table
1:698e880:      * @param rowCount number of rows to insert
1:698e880:      * @exception SQLException if any database exception occurs
1:698e880:      */
1:698e880:     private void insert(Connection con, String tableName, int rowCount)
1:698e880:             throws SQLException {
1:698e880:         PreparedStatement ps = con.prepareStatement(
1:698e880:                 "INSERT INTO " + tableName + " VALUES(?,?)");
1:698e880:         int startId = findMaxId(con, tableName);
1:698e880:         int endId = rowCount + startId;
1:698e880:         for (int i = startId; i < endId; i++) {
1:698e880:             ps.setInt(1, i); // ID
1:698e880:             ps.setString(2 , "skywalker" + i);
1:698e880:             ps.executeUpdate();
1:698e880:         }
1:698e880:         ps.close();
1:698e880:         con.commit();
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Returns the highest id in the given table.
1:698e880:      *
1:698e880:      * @param con connection to the database.
1:698e880:      * @param tableName name of the table
1:698e880:      * @return The highest id.
1:698e880:      * @exception SQLException if any database exception occurs.
1:698e880:      */
1:698e880:     private int findMaxId(Connection con, String tableName)
1:698e880:             throws SQLException {
1:698e880:         Statement s = con.createStatement();
1:698e880:         ResultSet rs = s.executeQuery("SELECT max(ID) from " + tableName);
1:698e880:         assertTrue(rs.next());
1:698e880:         int max = rs.getInt(1);
1:698e880:         rs.close();
1:698e880:         s.close();
1:698e880:         return max;
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Verifies the rows in the given table.
1:698e880:      *
1:698e880:      * @param con connection to the database
1:698e880:      * @param tableName table to select from
1:698e880:      * @exception SQLException if any database exception occurs
1:698e880:      */
1:698e880:     private void verifyContents(Connection con, String tableName)
1:698e880:             throws SQLException {
1:698e880:         Statement s = con.createStatement();
1:698e880:         ResultSet rs = s.executeQuery(
1:698e880:                 "SELECT ID, name from " +  tableName + " order by id");
1:698e880:         int count = 0;
1:698e880:         int id = 0;
1:698e880:         while (rs.next()) {
1:698e880:             int tid = rs.getInt(1);
1:698e880:             String name = rs.getString(2);
1:698e880:             assertEquals("skywalker" + id, name);
1:698e880:             assertEquals(id, tid);
1:698e880:             id++;
1:698e880:             count++;
1:698e880:         }
1:698e880: 
1:698e880:         rs.close();
1:698e880:         s.close();
1:698e880:         con.commit();
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Creates an encrypted database.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      */
1:698e880:     private Connection createEncryptedDatabase(DataSource ds, boolean useEncPwd)
1:698e880:             throws SQLException {
1:698e880:         String connAttrs = "dataEncryption=true;";
1:698e880:         if (useEncPwd) {
1:698e880:             // create encrypted database.
1:698e880:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:698e880:         } else {
1:698e880:             // create an encrypted  database.
1:698e880:             connAttrs += "encryptionKey=" + OLD_KEY;
1:698e880:         }
1:698e880:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:698e880:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:698e880:         try {
1:698e880:             return ds.getConnection();
1:698e880:         } finally {
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "createDatabase");
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Creates an un-encrypted database.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      */
1:698e880:     private Connection createDatabase(DataSource ds)
1:698e880:             throws SQLException {
1:698e880:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:698e880:         try {
1:698e880:             Connection con = ds.getConnection();
1:698e880:             JDBC.assertNoWarnings(con.getWarnings());
1:698e880:             return con;
1:698e880:         } finally {
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "createDatabase");
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Re-encrypts the database.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      * @throws SQLException if any database exception occurs
1:698e880:      */
1:698e880:     private Connection reEncryptDatabase(DataSource ds, boolean useEncPwd)
1:698e880:             throws SQLException {
1:698e880:         String connAttrs;
1:698e880:         if (useEncPwd) {
1:698e880:             connAttrs = "bootPassword=" + OLD_PASSWORD +
1:698e880:                 ";newBootPassword=" + NEW_PASSWORD;
1:698e880:         } else {
1:698e880:             connAttrs = "encryptionKey=" + OLD_KEY +
1:698e880:                 ";newEncryptionKey=" + NEW_KEY;
1:698e880:         }
1:698e880: 
1:698e880:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:698e880:         println("re-encrypting " + db(ds) + " with " + connAttrs);
1:698e880:         // Re-encrypt the database.
1:698e880:         try {
1:698e880:             return ds.getConnection();
1:698e880:         } finally {
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:698e880:      * Encrypts an un-encrypted database.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      * @exception SQLException if any database exception occurs.
1:698e880:      */
1:698e880:     private Connection encryptDatabase(DataSource ds, boolean useEncPwd)
1:698e880:         throws SQLException {
1:698e880:         String connAttrs = "dataEncryption=true;";
1:698e880:         if (useEncPwd) {
1:698e880:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:698e880:         } else {
1:698e880:             connAttrs += "encryptionKey=" + OLD_KEY;
1:698e880:         }
1:698e880: 
1:698e880:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:698e880:         println("encrypting " + db(ds) + " with " + connAttrs);
1:698e880:         //Encrypt the existing database.
1:698e880:         try {
1:698e880:             return ds.getConnection();
1:698e880:         } finally {
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /**
1:d203eea:      * Decrypts an encrypted database.
1:d203eea:      *
1:d203eea:      * @param ds database
1:d203eea:      * @param useEncPwd whether to use boot password or encryption key
1:d203eea:      * @throws SQLException if any database exception occurs
1:d203eea:      */
1:d203eea:     private Connection decryptDatabase(DataSource ds, boolean useEncPwd)
1:d203eea:         throws SQLException {
1:d203eea:         String connAttrs = "decryptDatabase=true;";
1:d203eea:         if (useEncPwd) {
1:d203eea:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:d203eea:         } else {
1:d203eea:             connAttrs += "encryptionKey=" + OLD_KEY;
1:d203eea:         }
1:d203eea: 
1:d203eea:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:d203eea:         println("decrypting " + db(ds) + " with " + connAttrs);
1:d203eea:         //Decrypt the existing database.
1:d203eea:         try {
1:d203eea:             return ds.getConnection();
1:d203eea:         } finally {
1:d203eea:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:d203eea:         }
1:d203eea:     }
1:d203eea: 
1:d203eea:     /**
1:698e880:      * Boots the database.
1:698e880:      *
1:698e880:      * @param ds database
1:698e880:      * @param useEncPwd whether to use boot password or encryption key
1:698e880:      * @param useNewCredential tri-state telling whether to use the old, the
1:698e880:      *      new, or no credential when booting the database
1:698e880:      * @exception SQLException if any database exception occurs.
1:698e880:      */
1:698e880:     private Connection bootDatabase(DataSource ds,
1:698e880:                                     boolean useEncPwd, Boolean useNewCredential)
1:698e880:             throws SQLException {
1:698e880:         String connAttrs = "";
1:698e880:         if (useEncPwd) {
1:698e880:             if (Boolean.TRUE.equals(useNewCredential)) {
1:698e880:                 connAttrs = "bootPassword=" + NEW_PASSWORD;
1:698e880:             } else if (Boolean.FALSE.equals(useNewCredential)) {
1:698e880:                 connAttrs = "bootPassword=" + OLD_PASSWORD;
1:698e880:             }
1:698e880:         } else {
1:698e880:             if (Boolean.TRUE.equals(useNewCredential)) {
1:698e880:                 connAttrs = "encryptionKey=" + NEW_KEY;
1:698e880:             } else if (Boolean.FALSE.equals(useNewCredential)) {
1:698e880:                 connAttrs = "encryptionKey=" + OLD_KEY;
1:698e880:             }
1:698e880:         }
1:698e880: 
1:698e880:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:698e880:         println("booting " + db(ds) +
1:698e880:                 (connAttrs.length() > 0 ? " with " + connAttrs : ""));
1:698e880:         try {
1:698e880:             return ds.getConnection();
1:698e880:         } finally {
1:698e880:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:698e880:         }
1:698e880:     }
1:698e880: 
1:698e880:     /** Extracts the database name from the data source. */
1:698e880:     private static String db(DataSource ds) {
1:698e880:         try {
1:698e880:             return (String)JDBCDataSource.getBeanProperty(ds, "databaseName");
1:698e880:         } catch (Exception e) {
1:698e880:             return "<unknown/error>";
1:698e880:         }
1:698e880:     }
1:698e880: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             suite = new BaseTestSuite(
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d203eea
/////////////////////////////////////////////////////////////////////////
1:  * un-encrypted database, re-encryption of an encrypted database with new
1:  * password/key, and decryption of an encrypted database.
/////////////////////////////////////////////////////////////////////////
0:             suite = new TestSuite(
1:                     "CryptoCrashRecovery disabled due to non-debug build");
1:             println("CryptoCrashRecoveryTest disabled due to non-debug build");
1: 	public void testDecryptionWithBootPassword()
1:             throws Exception {
1:         String db = "wombat_pwd_de";
1:         // Crash recovery during decryption (with password mechanism).
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_DECRYPT, USE_ENC_PWD);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
1:     public void testDecryptionWithEncryptionKey()
1:             throws Exception {
1:         String db = "wombat_key_de";
1:         // Crash recovery during database decryption (with encryption key).
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_DECRYPT, USE_ENC_KEY);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public void testEncryptionWithEncryptionKey()
/////////////////////////////////////////////////////////////////////////
1:         Connection con = null; // silence the compiler
1:         switch (operation) {
1:             case OP_DECRYPT:
1:                 // Fall through.
1:             case OP_REENCRYPT:
1:                 con = createEncryptedDatabase(ds, useEncPwd);
1:                 break;
1:             case OP_ENCRYPT:
1:                 con = createDatabase(ds);
1:                 break;
1:             default:
1:                 fail("unsupported operation: " + operation);
/////////////////////////////////////////////////////////////////////////
1:         // Following cases of cryptographic operations should be rolled back.
/////////////////////////////////////////////////////////////////////////
1:         // Retry operation and crash.
/////////////////////////////////////////////////////////////////////////
1:         // Retry operation and crash.
1:         // Following cases should be successful, only cleanup is pending.
1:         // Crash after the cryptographic operation has been performed, but
1:         // before cleanup.
1:         // new password. If decryption is complete, database should be bootable
1:         // without specifying a boot password / key.
1:         if (operation == OP_DECRYPT) {
1:             useNewCredential = null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             switch (operation) {
1:                 case OP_REENCRYPT:
1:                     reEncryptDatabase(ds, useEncPwd);
1:                     break;
1:                 case OP_ENCRYPT:
1:                     encryptDatabase(ds, useEncPwd);
1:                     break;
1:                 case OP_DECRYPT:
1:                     decryptDatabase(ds, useEncPwd);
1:                     break;
1:                 default:
1:                     fail("unsupported operation");
/////////////////////////////////////////////////////////////////////////
1:      * Decrypts an encrypted database.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @throws SQLException if any database exception occurs
1:      */
1:     private Connection decryptDatabase(DataSource ds, boolean useEncPwd)
1:         throws SQLException {
1:         String connAttrs = "decryptDatabase=true;";
1:         if (useEncPwd) {
1:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:         } else {
1:             connAttrs += "encryptionKey=" + OLD_KEY;
1:         }
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:         println("decrypting " + db(ds) + " with " + connAttrs);
1:         //Decrypt the existing database.
1:         try {
1:             return ds.getConnection();
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
commit:698e880
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.store.CryptoCrashRecoveryTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.io.File;
1: import java.sql.Connection;
0: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * This class tests crash/recovery scenarios during cryptographic operations on
1:  * the database.
1:  * <p>
1:  * Debug flags are used to simulate crashes during the encryption of an
0:  * un-encrypted database and re-encryption of an encrypted database with new
0:  * password/key.
1:  * <p>
1:  * Unlike the other recovery tests which do a setup and recovery as different
1:  * tests, crash/recovery for cryptographic operations can be simulated in one
1:  * test itself because the cryptographic operation is performed at boot time.
1:  * When debug flags are set the database boot itself fails. To test the
1:  * recovery, it is just a matter of clearing up the debug flag and rebooting
1:  * the database.
1:  * <p>
1:  * In non-debug mode (compiled as "insane") this test does nothing.
1:  */
1: public class CryptoCrashRecoveryTest
1:     extends BaseJDBCTestCase {
1: 
1:     private static boolean USE_ENC_PWD = true;
1:     private static boolean USE_ENC_KEY = false;
1: 
1:     private static final int OP_ENCRYPT = 0;
1:     private static final int OP_DECRYPT = 1;
1:     private static final int OP_REENCRYPT = 2;
1: 
1:     /** Table name used by the test. */
1:     private static final String TEST_TABLE_NAME = "emp";
1: 
1:     private static final String OLD_PASSWORD = "xyz1234abc";
1:     private static final String NEW_PASSWORD = "new1234xyz";
1: 
1:     private static final String OLD_KEY = "6162636465666768";
1:     private static final String NEW_KEY = "5666768616263646";
1: 
1: 	public CryptoCrashRecoveryTest(String name) {
1:         super(name);
1: 	}
1: 
1:     public static Test suite() {
1:         Test suite;
1:         if (SanityManager.DEBUG) {
1:             suite = TestConfiguration.embeddedSuite(
1:                     CryptoCrashRecoveryTest.class);
1:         } else {
0:             suite = new TestSuite("disabled due to non-debug build");
0:             println("test disabled due to non-debug build");
1:         }
1:         return suite;
1:     }
1: 
1: 	public void testEncryptionWithBootPassword()
1:             throws Exception {
1:         String db = "wombat_pwd_en";
1:         // Crash recovery during encryption using the password mechanism.
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_ENCRYPT, USE_ENC_PWD);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
0: 	public void testEncryptionWitEncryptionKey()
1:             throws Exception {
1:         String db = "wombat_key_en";
1:         // Crash recovery during database encryption using the encryption key.
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_ENCRYPT, USE_ENC_KEY);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
1: 	public void testReEncryptionWithBootPassword()
1:             throws Exception {
1:         String db = "wombat_pwd_ren";
1:         // Crash recovery during re-encryption using the password mechanism.
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_REENCRYPT, USE_ENC_PWD);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
1: 	public void testReEncryptionWithEncryptionKey()
1:             throws Exception {
1:         String db = "wombat_key_ren";
1:         // Crash recovery during re-encryption using an encryption key.
1:         DataSource ds = JDBCDataSource.getDataSource(db);
1:         runCrashRecoveryTestCases(ds, OP_REENCRYPT, USE_ENC_KEY);
1:         assertDirectoryDeleted(new File("system", db));
1:     }
1: 
1:     /**
1:      * Runs crash recovery test scenarios for the given cryptographic operation
1:      * using the debug flags.
1:      *
1:      * @param ds data source
1:      * @param operation the cryptographic operation to perform
1:      * @param useEncPwd whether to use encryption key or boot password (see
1:      *      {@linkplain #USE_ENC_KEY} and {@linkplain #USE_ENC_PWD})
1:      */
1:     private void runCrashRecoveryTestCases(DataSource ds, int operation,
1:                                            boolean useEncPwd)
1:             throws SQLException {
0:         verifyOperation(operation);
0:         Connection con;
0:         if (operation == OP_REENCRYPT) {
0:             con = createEncryptedDatabase(ds, useEncPwd);
1:         } else {
0:             con = createDatabase(ds);
1:         }
1: 
1:         createTable(con, TEST_TABLE_NAME);
1:         // Load some rows, used for verification later.
1:         insert(con, TEST_TABLE_NAME, 100);
1:         con.commit();
1:         con.close();
1:         JDBCDataSource.shutdownDatabase(ds);
1: 
0:         // Following cases of (re-)encryption should be rolled back.
1:         Boolean useNewCredential =
1:                 (operation == OP_REENCRYPT ? Boolean.FALSE : null);
1: 
1:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_BEFORE_COMMT);
1: 
1:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1: 
1: 
1:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
0:         // retry (re)encryption and crash.
1:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_COMMT);
1: 
1:         crash(ds, operation, useEncPwd,
1:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1: 
1:         crash(ds, operation, useEncPwd,
1:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY);
0:         // Retry (re-)encryption and crash.
1:         crash(ds, operation, useEncPwd,
1:                 TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1: 
0:         // Rollowing cases of (re-)encryption should be successful, only
0:         // cleanup is pending.
1: 
0:         // Crash after database is (re-)encrypted, but before cleanup.
1:         // If re-encryption is complete, database should be bootable with the
0:         // new password.
1:         useNewCredential =
1:                 (operation == OP_REENCRYPT ? Boolean.TRUE : Boolean.FALSE);
1:         crash(ds, operation, useEncPwd, TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT);
1:         crashInRecovery(ds, useEncPwd, useNewCredential,
1:                      TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP);
1: 
1:         recover(ds, useEncPwd, useNewCredential);
1:         JDBCDataSource.shutdownDatabase(ds);
1:     }
1: 
1:     /**
1:      * Crashes the engine at the point specified by the debug flag while
1:      * performing the requested operation.
1:      *
1:      * @param ds database
1:      * @param operation cryptographic operation to perform
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @param debugFlag debug flag to enable to make the engine crash
1:      */
1:     private void crash(DataSource ds, int operation, boolean useEncPwd,
1:                        String debugFlag) {
1:         println("Testing crash at " + debugFlag);
1:         // Set the debug flag to crash.
1:         setDebugFlag(debugFlag);
1: 
1:         try {
0:             if (operation == OP_REENCRYPT) {
0:                 reEncryptDatabase(ds, useEncPwd);
1:             } else {
0:                 encryptDatabase(ds, useEncPwd);
1:             }
1:             fail("crypto operation didn't crash as expected");
1:         } catch (SQLException sqle) {
1:             // check that database boot failed at the set debug flag.
1:             verifyBootException(sqle, debugFlag);
1:         } finally {
1:             clearDebugFlag(debugFlag);
1:         }
1:     }
1: 
1:     /**
1:      * Crashes the engine in recovery of the given database at the point
1:      * specified by the debug flag.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @param useNewCredential tri-state telling whether to use the old, the
1:      *      new, or no credential when booting the database
1:      * @param debugFlag debug flag to enable to make the engine crash
1:      */
1:     private void crashInRecovery(DataSource ds, boolean useEncPwd,
1:                                  Boolean useNewCredential, String debugFlag)
1:             throws SQLException {
1:         println("Recovery crash at " + debugFlag);
1: 
1:         // set the debug flag to crash.
1:         setDebugFlag(debugFlag);
1:         try {
1:             bootDatabase(ds, useEncPwd, useNewCredential);
1:             fail("database booted unexpectedly");
1:         } catch (SQLException sqle) {
1:             // check that database boot failed at the set debug flag.
1:             verifyBootException(sqle, debugFlag);
1:         } finally {
1:             clearDebugFlag(debugFlag);
1:         }
1:     }
1: 
1:     /*
1:      * Recover the database that failed during re-encryption and
1:      * perform some simple sanity checks on the database.
1:      */
1:     private void recover(DataSource ds, boolean useEncKey,
1:                          Boolean useNewCredential)
1:             throws SQLException {
1:         // starting recovery of database with failed Re-encryption
1:         // in debug mode;
1: 
1:         Connection con = bootDatabase(ds, useEncKey, useNewCredential);
1: 
1:         // Verify that the contents of the db are ok.
1:         runConsistencyChecker(con, TEST_TABLE_NAME);
1:         // Insert some rows, this might fail if anything is
1:         // wrong in the logging system setup.
1:         insert(con, TEST_TABLE_NAME, 100);
1:         con.commit();
1:         con.close();
1:     }
1: 
1:     // Debug flags are set to simulate a crash at different
1:     // points during a cryptographic operation on the database.
1:     // These flags should match the flags in the engine code, and they
1:     // are redefined here to avoid pulling the engine code into the tests.
1: 
1: 	private static final String TEST_REENCRYPT_CRASH_BEFORE_COMMT =
1:             "TEST_REENCRYPT_CRASH_BEFORE_COMMT";
1:     private static final String TEST_REENCRYPT_CRASH_AFTER_COMMT =
1:             "TEST_REENCRYPT_CRASH_AFTER_COMMT";
1:     private static final String TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY =
1:         "TEST_REENCRYPT_CRASH_AFTER_SWITCH_TO_NEWKEY";
1:     private static final String TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT =
1:         "TEST_REENCRYPT_CRASH_AFTER_CHECKPOINT";
1:     private static final String
1:         TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE =
1:             "TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_LOGFILE_DELETE";
1:     private static final String
1:         TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY =
1:             "TEST_REENCRYPT_CRASH_AFTER_RECOVERY_UNDO_REVERTING_KEY";
1:     private static final String
1:         TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP =
1:             "TEST_REENCRYPT_CRASH_BEFORE_RECOVERY_FINAL_CLEANUP";
1: 
1:     private void setDebugFlag(String debugFlag) {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.DEBUG_SET(debugFlag);
1:         }
1:     }
1: 
1:     private void clearDebugFlag(String debugFlag) {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.DEBUG_CLEAR(debugFlag);
1:         }
1:     }
1: 
1:     /**
1:      * Verifies that database boot failed because of the right reasons.
1:      *
1:      * @param sqle the exception thrown when
1:      * @param debugFlag the debug flag that was set before booting
1:      * @throws junit.framework.AssertionFailedError if the boot failure is
1:      *      deemed invalid
1:      */
1:     private void verifyBootException(SQLException sqle, String debugFlag) {
1:         assertSQLState("XJ040", sqle);
1:         // Boot failed as expected triggered by a debug flag.
1:         // Now check if it failed because of the expected debug flag.
1:         SQLException ne = sqle.getNextException();
1:         while (ne != null) {
1:             String message = ne.getMessage();
1:             // Check if debug flag exists in the message.
1:             if (message.indexOf(debugFlag) != -1) {
1:                 return;
1:             }
1:             ne = ne.getNextException();
1:         }
1:         fail("real error or wrong debug flag triggered crash", sqle);
1:     }
1: 
1:     /**
1:      * Creates the table that is used by this test.
1:      *
1:      * @param con connection to the database
1:      * @param tableName  name of the table to create
1:      * @exception SQLException if any database exception occurs.
1:      */
1:     private void createTable(Connection con, String tableName)
1:             throws SQLException {
1:         Statement s = con.createStatement();
1:         s.executeUpdate("CREATE TABLE " + tableName +
1:                         "(id INT," +
1:                         "name VARCHAR(200))");
1:         s.executeUpdate("create index " + tableName + "_id_idx on " +
1:                         tableName + "(id)");
1:         s.close();
1:     }
1: 
1:     /**
1: 	 * Runs some consistency checks on the specified table.
1:      *
1:      * @param con connection to the database
1: 	 * @param tableName target table
1:      * @exception SQLException if any database exception occurs
1: 	 */
1: 	private void runConsistencyChecker(Connection con, String tableName)
1:             throws SQLException {
1: 		Statement stmt = con.createStatement();
1: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
1:         // Check the data in the EMP table.
1:         verifyContents(con, tableName);
1: 	}
1: 
1:     /**
1:      * Inserts rows into the specified table.
1:      *
1:      * @param con connection to the database
1:      * @param tableName target table
1:      * @param rowCount number of rows to insert
1:      * @exception SQLException if any database exception occurs
1:      */
1:     private void insert(Connection con, String tableName, int rowCount)
1:             throws SQLException {
1:         PreparedStatement ps = con.prepareStatement(
1:                 "INSERT INTO " + tableName + " VALUES(?,?)");
1:         int startId = findMaxId(con, tableName);
1:         int endId = rowCount + startId;
1:         for (int i = startId; i < endId; i++) {
1:             ps.setInt(1, i); // ID
1:             ps.setString(2 , "skywalker" + i);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1:         con.commit();
1:     }
1: 
1:     /**
1:      * Returns the highest id in the given table.
1:      *
1:      * @param con connection to the database.
1:      * @param tableName name of the table
1:      * @return The highest id.
1:      * @exception SQLException if any database exception occurs.
1:      */
1:     private int findMaxId(Connection con, String tableName)
1:             throws SQLException {
1:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery("SELECT max(ID) from " + tableName);
1:         assertTrue(rs.next());
1:         int max = rs.getInt(1);
1:         rs.close();
1:         s.close();
1:         return max;
1:     }
1: 
1:     /**
1:      * Verifies the rows in the given table.
1:      *
1:      * @param con connection to the database
1:      * @param tableName table to select from
1:      * @exception SQLException if any database exception occurs
1:      */
1:     private void verifyContents(Connection con, String tableName)
1:             throws SQLException {
1:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery(
1:                 "SELECT ID, name from " +  tableName + " order by id");
1:         int count = 0;
1:         int id = 0;
1:         while (rs.next()) {
1:             int tid = rs.getInt(1);
1:             String name = rs.getString(2);
1:             assertEquals("skywalker" + id, name);
1:             assertEquals(id, tid);
1:             id++;
1:             count++;
1:         }
1: 
1:         rs.close();
1:         s.close();
1:         con.commit();
1:     }
1: 
1:     /**
1:      * Creates an encrypted database.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      */
1:     private Connection createEncryptedDatabase(DataSource ds, boolean useEncPwd)
1:             throws SQLException {
1:         String connAttrs = "dataEncryption=true;";
1:         if (useEncPwd) {
1:             // create encrypted database.
1:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:         } else {
1:             // create an encrypted  database.
1:             connAttrs += "encryptionKey=" + OLD_KEY;
1:         }
1:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:         try {
1:             return ds.getConnection();
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "createDatabase");
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:         }
1:     }
1: 
1:     /**
1:      * Creates an un-encrypted database.
1:      *
1:      * @param ds database
1:      */
1:     private Connection createDatabase(DataSource ds)
1:             throws SQLException {
1:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:         try {
1:             Connection con = ds.getConnection();
1:             JDBC.assertNoWarnings(con.getWarnings());
1:             return con;
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "createDatabase");
1:         }
1:     }
1: 
1:     /**
1:      * Re-encrypts the database.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @throws SQLException if any database exception occurs
1:      */
1:     private Connection reEncryptDatabase(DataSource ds, boolean useEncPwd)
1:             throws SQLException {
1:         String connAttrs;
1:         if (useEncPwd) {
1:             connAttrs = "bootPassword=" + OLD_PASSWORD +
1:                 ";newBootPassword=" + NEW_PASSWORD;
1:         } else {
1:             connAttrs = "encryptionKey=" + OLD_KEY +
1:                 ";newEncryptionKey=" + NEW_KEY;
1:         }
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:         println("re-encrypting " + db(ds) + " with " + connAttrs);
1:         // Re-encrypt the database.
1:         try {
1:             return ds.getConnection();
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:         }
1:     }
1: 
1:     /**
1:      * Encrypts an un-encrypted database.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @exception SQLException if any database exception occurs.
1:      */
1:     private Connection encryptDatabase(DataSource ds, boolean useEncPwd)
1:         throws SQLException {
1:         String connAttrs = "dataEncryption=true;";
1:         if (useEncPwd) {
1:             connAttrs += "bootPassword=" + OLD_PASSWORD;
1:         } else {
1:             connAttrs += "encryptionKey=" + OLD_KEY;
1:         }
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:         println("encrypting " + db(ds) + " with " + connAttrs);
1:         //Encrypt the existing database.
1:         try {
1:             return ds.getConnection();
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:         }
1:     }
1: 
1:     /**
1:      * Boots the database.
1:      *
1:      * @param ds database
1:      * @param useEncPwd whether to use boot password or encryption key
1:      * @param useNewCredential tri-state telling whether to use the old, the
1:      *      new, or no credential when booting the database
1:      * @exception SQLException if any database exception occurs.
1:      */
1:     private Connection bootDatabase(DataSource ds,
1:                                     boolean useEncPwd, Boolean useNewCredential)
1:             throws SQLException {
1:         String connAttrs = "";
1:         if (useEncPwd) {
1:             if (Boolean.TRUE.equals(useNewCredential)) {
1:                 connAttrs = "bootPassword=" + NEW_PASSWORD;
1:             } else if (Boolean.FALSE.equals(useNewCredential)) {
1:                 connAttrs = "bootPassword=" + OLD_PASSWORD;
1:             }
1:         } else {
1:             if (Boolean.TRUE.equals(useNewCredential)) {
1:                 connAttrs = "encryptionKey=" + NEW_KEY;
1:             } else if (Boolean.FALSE.equals(useNewCredential)) {
1:                 connAttrs = "encryptionKey=" + OLD_KEY;
1:             }
1:         }
1: 
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes", connAttrs);
1:         println("booting " + db(ds) +
1:                 (connAttrs.length() > 0 ? " with " + connAttrs : ""));
1:         try {
1:             return ds.getConnection();
1:         } finally {
1:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
1:         }
1:     }
1: 
0:     /** Verifies if the operation constant is a known operation. */
0:     private static void verifyOperation(int operation) {
0:         switch (operation) {
0:             case OP_ENCRYPT:
0:             //case OP_DECRYPT:
0:             case OP_REENCRYPT:
1:                 return;
0:             default:
0:                 fail("unknown operation constant: " + operation);
1:         }
1:     }
1: 
1:     /** Extracts the database name from the data source. */
1:     private static String db(DataSource ds) {
1:         try {
1:             return (String)JDBCDataSource.getBeanProperty(ds, "databaseName");
1:         } catch (Exception e) {
1:             return "<unknown/error>";
1:         }
1:     }
1: }
============================================================================