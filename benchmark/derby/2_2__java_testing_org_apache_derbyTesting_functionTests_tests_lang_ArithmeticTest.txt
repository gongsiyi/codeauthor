1:079cd70: /*
1:079cd70: 
1:079cd70: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ArithmeticTest
1:079cd70: 
1:079cd70: Licensed to the Apache Software Foundation (ASF) under one or more
1:079cd70: contributor license agreements.  See the NOTICE file distributed with
1:079cd70: this work for additional information regarding copyright ownership.
1:079cd70: The ASF licenses this file to You under the Apache License, Version 2.0
1:079cd70: (the "License"); you may not use this file except in compliance with
1:079cd70: the License.  You may obtain a copy of the License at
1:079cd70: 
1:079cd70: http://www.apache.org/licenses/LICENSE-2.0
1:079cd70: 
1:079cd70: Unless required by applicable law or agreed to in writing, software
1:079cd70: distributed under the License is distributed on an "AS IS" BASIS,
1:079cd70: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:079cd70: See the License for the specific language governing permissions and
1:079cd70: limitations under the License.
1:079cd70: 
1:079cd70: */
1:079cd70: package org.apache.derbyTesting.functionTests.tests.lang;
1:079cd70: 
1:e27c25c: import java.math.BigInteger;
1:079cd70: import java.sql.SQLException;
1:079cd70: import java.sql.Statement;
1:079cd70: 
1:079cd70: import junit.framework.Test;
1:079cd70: 
1:079cd70: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:079cd70: import org.apache.derbyTesting.junit.JDBC;
1:079cd70: import org.apache.derbyTesting.junit.TestConfiguration;
1:079cd70: 
1:079cd70: /**
1:079cd70:  * Test case for arithmetic.sql. It tests the arithmetic operators. 
1:079cd70:  */
1:079cd70: public class ArithmeticTest extends BaseJDBCTestCase {
1:079cd70: 
1:e27c25c:     private static final String BIGINT = "bigint";
1:e27c25c:     private static final String DECIMAL = "decimal(31,0)";
1:e27c25c: 
1:079cd70:     public ArithmeticTest(String name) {
1:079cd70:         super(name);
1:079cd70:     }
1:079cd70: 
1:079cd70:     public static Test suite(){
1:079cd70:         return TestConfiguration.defaultSuite(ArithmeticTest.class);
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test arithmetic on different types.
1:079cd70:      * i.e. int and bigint, or int and smallint.
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:079cd70:     public void testTypes() throws SQLException {
1:e27c25c:         String[] tableNames = { "smallint_r", "t", "bigint_r", "decimal_r" };
1:e27c25c:         String[] types = { "smallint", "int", BIGINT, DECIMAL };
1:e27c25c:         BigInteger[][] boundaries = {
1:e27c25c:             { BigInteger.valueOf(Short.MIN_VALUE),
1:e27c25c:               BigInteger.valueOf(Short.MAX_VALUE) },
1:e27c25c:             { BigInteger.valueOf(Integer.MIN_VALUE),
1:e27c25c:               BigInteger.valueOf(Integer.MAX_VALUE) },
1:e27c25c:             { BigInteger.valueOf(Long.MIN_VALUE),
1:e27c25c:               BigInteger.valueOf(Long.MAX_VALUE) },
1:e27c25c:             { new BigInteger("-9999999999999999999999999999999", 10),
1:e27c25c:               new BigInteger("9999999999999999999999999999999", 10) },
1:e27c25c:         };
1:079cd70: 
1:079cd70:         for (int i = 0; i < types.length; i++) {
1:e27c25c:             doBasically(tableNames[i], types[i]);
1:e27c25c:             doOverflow(tableNames[i], types[i],
1:e27c25c:                     boundaries[i][0], boundaries[i][1]);
1:079cd70: 
1:079cd70:             dropTable(tableNames[i]);
1:079cd70:         }
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test basic arithmetic operations.
1:079cd70:      * i.e. int and bigint, or int and smallint.
1:079cd70:      * 
1:079cd70:      * @param tableName
1:079cd70:      *                the name of table to test. 
1:079cd70:      *                If a table with the same name has existed,
1:079cd70:      *                it will be dropped.
1:079cd70:      * @param type
1:079cd70:      *                the type to test. i.e. "smallint" or "bigint".
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:e27c25c:     private void doBasically(String tableName, String type)
1:e27c25c:             throws SQLException {
1:079cd70:         String sql = "create table " + tableName + "(i " + 
1:079cd70:             type + ", j " + type + ")";
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into " + tableName + " values (null, null)";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into " + tableName + " values (0, 100)";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into " + tableName + " values (1, 101)";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into " + tableName + " values (-2, -102)";
1:079cd70:         st.addBatch(sql);
1:079cd70: 
1:079cd70:         st.executeBatch();
1:079cd70: 
1:079cd70:         sql = "select * from " + tableName;
1:079cd70:         String[][] result = {
1:079cd70:             {null, null}, {"0", "100"}, {"1", "101"}, {"-2", "-102"},
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1:079cd70: 
1:079cd70:         sql = "select i + j from " + tableName;
1:079cd70:         result = new String[][]{
1:079cd70:             {null}, {"100"}, {"102"}, {"-104"},
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select i, i + 10 + 20, j, j + 100 + 200" +
1:079cd70:                 " from " + tableName;
1:079cd70:         result = new String [][]{
1:079cd70:                     {null, null, null, null},
1:079cd70:                     {"0", "30", "100", "400"},
1:079cd70:                     {"1", "31", "101", "401"},
1:079cd70:                     {"-2", "28", "-102", "198"}
1:079cd70:                 };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select i - j, j - i from " + tableName;
1:079cd70:         result = new String [][]{
1:079cd70:                     {null, null},
1:079cd70:                     {"-100", "100"},
1:079cd70:                     {"-100", "100"},
1:079cd70:                     {"100", "-100"}
1:079cd70:             };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select i, i - 10 - 20, 20 - 10 - i, j, " +
1:079cd70:                 "j - 100 - 200, 200 - 100 - j from " 
1:079cd70:                 + tableName;
1:079cd70:         result = new String [][]{
1:079cd70:                 {null, null, null, null, null, null},
1:079cd70:                 {"0", "-30", "10", "100", "-200", "0"},
1:079cd70:                 {"1", "-29", "9", "101", "-199", "-1"},
1:079cd70:                 {"-2", "-32", "12", "-102", "-402", "202"}
1:079cd70:             };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select i, j, i * j, j * i from " + tableName;
1:079cd70:         result = new String [][]{
1:079cd70:                     {null, null, null, null},
1:079cd70:                     {"0", "100", "0", "0"},
1:079cd70:                     {"1", "101", "101", "101"},
1:079cd70:                     {"-2", "-102", "204", "204"}
1:079cd70:             };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select i, j, i * 10 * -20, j * 100 * -200 " +
1:079cd70:                 "from " + tableName;
1:079cd70:         result = new String [][]{
1:079cd70:                     {null, null, null, null},
1:079cd70:                     {"0", "100", "0", "-2000000"},
1:079cd70:                     {"1", "101", "-200", "-2020000"},
1:079cd70:                     {"-2", "-102", "400", "2040000"}
1:079cd70:             };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         // try unary minus on some expressions
1:079cd70:         sql = "select -i, -j, -(i * 10 * -20), " +
1:079cd70:                 "-(j * 100 * -200) from " + tableName;
1:079cd70:         result = new String[][]{
1:079cd70:                 {null, null, null, null},
1:079cd70:                 {"0", "-100", "0", "2000000"},
1:079cd70:                 {"-1", "-101", "200", "2020000"},
1:079cd70:                 {"2", "102", "-400", "-2040000"}
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         //unary plus doesn't do anything
1:079cd70:         sql = "select +i, +j, +(+i * +10 * -20), " +
1:079cd70:                 "+(+j * +100 * -200) from " + tableName;
1:079cd70:         result = new String[][]{
1:079cd70:                     {null, null, null, null},
1:079cd70:                     {"0", "100", "0", "-2000000"},
1:079cd70:                     {"1", "101", "-200", "-2020000"},
1:079cd70:                     {"-2", "-102", "400", "2040000"}
1:079cd70:                 };
1:079cd70: 
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         //test null/null, constant/null, null/constant
1:079cd70:         sql = "select i, j, i / j, 10 / j, j / 10 " +
1:079cd70:                 "from " + tableName;
1:079cd70:         result = new String[][]{
1:079cd70:                     {null, null, null, null, null},
1:079cd70:                     {"0", "100", "0", "0", "10"},
1:079cd70:                     {"1", "101", "0", "0", "10"},
1:079cd70:                     {"-2", "-102", "0", "0", "-10"}
1:079cd70:                 };
1:e27c25c:         if (type.equals(DECIMAL)) {
1:e27c25c:             // With DECIMAL, the fraction part won't be truncated from i/j.
1:e27c25c:             result[1][3] = "0.100000000000000000000";
1:e27c25c:             result[2][3] = "0.099009900990099009900";
1:e27c25c:             result[3][3] = "-0.098039215686274509803";
1:e27c25c:         }
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         //test for divide by 0
1:079cd70:         sql = "select j / i from " + tableName;
1:079cd70:         assertStatementError("22012", st, sql);
1:079cd70: 
1:079cd70:         sql = "select (j - 1) / (i + 4), 20 / 5 / 4, " +
1:079cd70:                 "20 / 4 / 5 from " + tableName;
1:079cd70:         result = new String[][]{
1:079cd70:                     {null, "1", "1"},
1:079cd70:                     {"24", "1", "1"},
1:079cd70:                     {"20", "1", "1"},
1:079cd70:                     {"-51", "1", "1"}
1:079cd70:                 };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         //-- test positive/negative, negative/positive 
1:079cd70:         //and negative/negative
1:079cd70:         sql = "select j, j / (0 - j), (0 - j) / j, " +
1:079cd70:                 "(0 - j) / (0 - j) from " + tableName;
1:079cd70:         result = new String [][] {
1:079cd70:                      {null, null, null, null},
1:079cd70:                      {"100", "-1", "-1", "1"},
1:079cd70:                      {"101", "-1", "-1", "1"},
1:079cd70:                      {"-102", "-1", "-1", "1"}
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         //test some "more complex" expressions
1:079cd70:         sql = "select i, i + 10, i - (10 - 20), i - 10, " +
1:079cd70:                 "i - (20 - 10) from " + tableName;
1:079cd70:         result = new String [][] {
1:079cd70:                     {null, null, null, null, null},
1:079cd70:                     {"0", "10", "10", "-10", "-10"},
1:079cd70:                     {"1", "11", "11", "-9", "-9"},
1:079cd70:                     {"-2", "8", "8", "-12", "-12"}
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select  'The next 2 columns should agree', " +
1:079cd70:                 "2 + 3 * 4 + 5, 2 + (3 * 4) + 5 " +
1:079cd70:                 "from " + tableName;
1:079cd70:         result = new String [][] {
1:079cd70:                 {"The next 2 columns should agree", "19", "19"},
1:079cd70:                 {"The next 2 columns should agree", "19", "19"},
1:079cd70:                 {"The next 2 columns should agree", "19", "19"},
1:079cd70:                 {"The next 2 columns should agree", "19", "19"}
1:079cd70:             };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70: 
1:079cd70:         sql = "select 'The next column should be 45', " +
1:079cd70:                 "(2 + 3) * (4 + 5) from " + tableName;
1:079cd70:         result = new String [][] {
1:079cd70:                 {"The next column should be 45", "45"},
1:079cd70:                 {"The next column should be 45", "45"},
1:079cd70:                 {"The next column should be 45", "45"},
1:079cd70:                 {"The next column should be 45", "45"}
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:             result);
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test overflow on some types.
1:079cd70:      * i.e. int and bigint, or int and smallint.
1:079cd70:      * 
1:079cd70:      * @param tableName
1:079cd70:      *                the name of table to test. 
1:079cd70:      *                If a table with the same name has existed,
1:079cd70:      *                it will be dropped.
1:079cd70:      * @param type
1:079cd70:      *                the type to test. i.e. "smallint" or "bigint".
1:e27c25c:      * @param negativeBoundary
1:e27c25c:      *                the negative boundary for the data type
2:079cd70:      * @param positiveBoundary
1:e27c25c:      *                the positive boundary for the data type
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:079cd70:     private void doOverflow(String tableName, String type,
1:e27c25c:             BigInteger negativeBoundary, BigInteger positiveBoundary)
1:e27c25c:         throws SQLException
1:e27c25c:     {
1:079cd70:         dropTable(tableName);
1:079cd70:         String sql = "create table " + tableName
1:079cd70:                 + " (i " + type + ", j " + type + ")";
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.executeUpdate(sql);
1:079cd70: 
1:079cd70:         long i = 1L;
1:079cd70:         sql = "insert into " + tableName + " values (" 
1:079cd70:                 + i + "," + positiveBoundary + ")";
1:e27c25c:         assertUpdateCount(st, 1, sql);
1:079cd70: 
1:079cd70:         sql = "select i + j from " + tableName;
2:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         sql = "select i - j - j from " + tableName;
1:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         sql = "select j + j from " + tableName;
1:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         sql = "select j * j from " + tableName;
1:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         sql = "insert into " + tableName + " values "
1:e27c25c:                 + "(" + negativeBoundary + ", 0)";
1:e27c25c:         assertUpdateCount(st, 1, sql);
1:e27c25c: 
1:e27c25c:         // Check if the boundaries of the data type are asymmetric and
1:e27c25c:         // allow more negative values than positive values.
1:e27c25c:         final boolean asymmetricTowardsNegative =
1:e27c25c:                 negativeBoundary.negate().compareTo(positiveBoundary) > 0;
1:079cd70: 
1:079cd70:         sql = "select -i from " + tableName;
1:e27c25c:         if (asymmetricTowardsNegative) {
1:e27c25c:             // For most numeric data types, the legal range is not symmetric
1:e27c25c:             // around zero, so negating the negative boundary will make the
1:e27c25c:             // resulting value out of range. Expect failure.
1:e27c25c:             assertStatementError("22003", st, sql);
1:e27c25c:         } else {
1:e27c25c:             // For DECIMAL, the boundaries are symmetric around zero, so
1:e27c25c:             // expect the query to succeed.
1:e27c25c:             JDBC.assertFullResultSet(st.executeQuery(sql),
1:e27c25c:                     new String[][] {
1:e27c25c:                         { "-1" },
1:e27c25c:                         { negativeBoundary.negate().toString() },
1:e27c25c:                     });
1:e27c25c:         }
1:079cd70: 
1:079cd70:         sql = "select -j from " + tableName;
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql),
1:079cd70:                 new String[][] {
1:e27c25c:                 { positiveBoundary.negate().toString() }, { "0" }, }
1:079cd70:         );
1:079cd70: 
1:079cd70:         sql = "select j / 2 * 2 from " + tableName;
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:079cd70:                 new String[][] {
1:e27c25c:                     { positiveBoundary.subtract(BigInteger.ONE).toString() },
1:e27c25c:                     { "0" },
1:e27c25c:                 }
1:079cd70:         );
1:079cd70: 
1:e27c25c:         // When type is not BIGINT or DECIMAL, it won't overflow.
1:079cd70:         // Just like testMixedType().
1:e27c25c:         if (type.equals(BIGINT) || type.equals(DECIMAL)) {
1:079cd70:             sql = "select 2 * (" + positiveBoundary + " / 2 + 1) from "
1:079cd70:                     + tableName;
1:079cd70:             assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:             sql = "select -2 * (" + positiveBoundary + " / 2 + 2) from " 
1:079cd70:                     + tableName;
1:079cd70:             assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:             sql = "select 2 * ((-" + positiveBoundary + " - 1) / 2 - 1) from "
1:079cd70:                     + tableName;
1:079cd70:             assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:             sql = "select -2 * ((-" + positiveBoundary + " - 1) / 2 - 1) from "
1:079cd70:                     + tableName;
1:079cd70:             assertStatementError("22003", st, sql);
1:079cd70: 
1:e27c25c:             // Check if the negative boundary is even, in which case the
1:e27c25c:             // arithmetic operation below won't lose precision when dividing
1:e27c25c:             // by two.
1:e27c25c:             final boolean negativeBoundaryIsEven = !negativeBoundary.testBit(0);
1:e27c25c: 
1:079cd70:             //different from arithmetic. This can support better test.
1:079cd70:             sql = "select i / 2 * 2 - 1 from " + tableName;
1:e27c25c:             if (negativeBoundaryIsEven) {
1:e27c25c:                 // Since the negative boundary is even, dividing by two and
1:e27c25c:                 // subsequently multiplying by two will result in the same
1:e27c25c:                 // value, and subtracting one from that value will make the
1:e27c25c:                 // result out of range (less than negative boundary).
1:e27c25c:                 assertStatementError("22003", st, sql);
1:e27c25c:             } else {
1:e27c25c:                 // If the negative boundary is odd, dividing by two and
1:e27c25c:                 // subsequently multiplying by two will result in a value
1:e27c25c:                 // that is one above the negative boundary, because the
1:e27c25c:                 // fraction part is lost in the intermediate result. Result
1:e27c25c:                 // will still be in valid range, also after the subtraction.
1:e27c25c:                 JDBC.assertFullResultSet(st.executeQuery(sql),
1:e27c25c:                         new String[][] {
1:e27c25c:                             { "-1" },
1:e27c25c:                             { negativeBoundary.toString() },
1:e27c25c:                         });
1:e27c25c:             }
1:e27c25c: 
1:e27c25c:             // Same test case as above, but subtract two to force error
1:e27c25c:             // also when the negative boundary is odd.
1:e27c25c:             sql = "select i / 2 * 2 - 2 from " + tableName;
1:079cd70:             assertStatementError("22003", st, sql);
1:079cd70:         }
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test mixed types.i.e. int and bigint, or int and smallint.
1:079cd70:      * 
1:079cd70:      * @param tableName
1:079cd70:      *                the name of table to test.
1:079cd70:      * @param type
1:079cd70:      *                the type to test. i.e. "smallint" or "bigint".
1:079cd70:      * @param i
1:079cd70:      *                an integer number to test with.
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:079cd70:     private void doMixedTypeImpl(String tableName, String type,
1:e27c25c:         BigInteger i) throws SQLException{
1:079cd70:         String sql = "create table " + tableName 
1:079cd70:             + " (y "  + type+ ")" ;
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.executeUpdate(sql);
1:079cd70: 
1:e27c25c:         BigInteger y = BigInteger.valueOf(2);
1:079cd70:         sql = "insert into " + tableName + " values (" + y + ")";
3:079cd70:         assertEquals(1, st.executeUpdate(sql));
1:079cd70: 
1:079cd70:         sql = "select " + i + " + y from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 i.add(y).toString());
1:079cd70: 
1:079cd70:         sql = "select y + " + i + " from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 y.add(i).toString());
1:079cd70: 
1:079cd70:         sql = "select y - " + i + " from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 y.subtract(i).toString());
1:079cd70: 
1:079cd70:         sql = "select " + i + " - y from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 i.subtract(y).toString());
1:079cd70: 
1:079cd70:         sql = "select " + i + " * y from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 i.multiply(y).toString());
1:079cd70: 
1:079cd70:         sql = "select y * " + i + " from "+ tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 y.multiply(i).toString());
1:079cd70: 
1:079cd70:         sql = "select " + i + " / y from " + tableName;
1:e27c25c:         String fraction = type.equals(DECIMAL) ? ".000000000000" : "";
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 i.divide(y) + fraction);
1:079cd70: 
1:079cd70:         sql = "select y / " + i + " from " + tableName;
1:e27c25c:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:e27c25c:                 y.divide(i).toString());
1:079cd70: 
1:079cd70:         st.close();
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test mixed types.i.e. int and bigint, or int and smallint.
1:079cd70:      * @throws SQLException
1:079cd70:      */
1:079cd70:     public void testMixedType() throws SQLException{
1:e27c25c:         String[] types = {"smallint", BIGINT, DECIMAL};
1:e27c25c:         String[] tableNames = {"smallint_r", "bigint_r", "decimal_r"};
1:e27c25c:         BigInteger[] testValues = {
1:e27c25c:                 BigInteger.valueOf(65535),
1:e27c25c:                 BigInteger.valueOf(Integer.MAX_VALUE),
1:e27c25c:                 BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE),
1:e27c25c:         };
1:079cd70: 
1:079cd70:         for(int i = 0; i < types.length; i++){
1:e27c25c:             doMixedTypeImpl(tableNames[i], types[i], testValues[i]);
1:079cd70:             dropTable(tableNames[i]);
1:079cd70:         }
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Test the arithmetic operators on a type we know they don't work on.
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:079cd70:     public void testWrongType() throws SQLException{
1:079cd70:         String sql = "create table s (x char(10), y char(10))";
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.executeUpdate(sql);
1:079cd70:         st.close();
1:079cd70: 
1:079cd70:         sql ="select x + y from s";
1:079cd70:         assertCompileError("42Y95", sql);
1:079cd70: 
1:079cd70:         sql = "select x - y from s";
1:079cd70:         assertCompileError("42Y95", sql);
1:079cd70: 
1:079cd70:         sql = "select x * y from s";
1:079cd70:         assertCompileError("42Y95", sql);
1:079cd70: 
1:079cd70:         sql = "select x / y from s";
1:079cd70:         assertCompileError("42Y95", sql);
1:079cd70: 
1:079cd70:         sql = "select -x from s";
1:079cd70:         assertCompileError("42X37", sql);
1:079cd70: 
1:079cd70:         dropTable("s");
1:079cd70:     }
1:079cd70: 
1:079cd70:     /**
1:079cd70:      * Arithmetic on a numeric data type.
1:079cd70:      * @throws SQLException 
1:079cd70:      */
1:079cd70:     public void testNumericDataType() throws SQLException{
1:079cd70:         String sql = "create table u (c1 int, c2 char(10))";    
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into u (c2) values 'asdf'";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into u (c1) values null";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into u (c1) values 1";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into u (c1) values null";
1:079cd70:         st.addBatch(sql);
1:079cd70:         sql = "insert into u (c1) values 2";
1:079cd70:         st.addBatch(sql);
1:079cd70:         st.executeBatch();
1:079cd70: 
1:079cd70:         sql = "select * from u";
1:079cd70:         String[][] result = {
1:079cd70:             {null, "asdf",},
1:079cd70:             {null, null,},
1:079cd70:             {"1", null,},
1:079cd70:             {null, null,},
1:079cd70:             {"2", null,},
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1:079cd70: 
1:079cd70:         sql = "select c1 + c1 from u";
1:079cd70:         result = new String[][]{
1:079cd70:             {null,}, {null,}, {"2",}, {null,}, {"4",},
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1:079cd70: 
1:079cd70:         sql = "select c1 / c1 from u";
1:079cd70:         result = new String[][]{
1:079cd70:             {null,}, {null,}, {"1",}, {null,}, {"1",},
1:079cd70:         };
1:079cd70:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1:079cd70: 
1:079cd70:         //arithmetic between a numeric and a string data type fails.
1:079cd70:         sql = "select c1 + c2 from u";
1:079cd70:         assertStatementError("22018", st, sql);
1:079cd70: 
1:079cd70:         st.close();
1:079cd70: 
1:079cd70:         dropTable("u");
1:079cd70:     }
1:079cd70: 
1:079cd70:     public void testPrecedenceAndAssociativity() throws SQLException{
1:079cd70:         String sql = "create table r (x int)";
1:079cd70:         Statement st = createStatement();
1:079cd70:         st.executeUpdate(sql);
1:079cd70: 
1:079cd70:         sql = "insert into r values (1)";
1:079cd70:         assertEquals(1, st.executeUpdate(sql));
1:079cd70: 
1:079cd70:         sql = "select 2 + 3 * 4 from r";
9:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (2 + 3 * 4) + "");
1:079cd70: 
1:079cd70:         sql = "select (2 + 3) * 4 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ((2 + 3) * 4) + "");
1:079cd70: 
1:079cd70:         sql = "select 3 * 4 + 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ( 3 * 4 + 2) + "");
1:079cd70: 
1:079cd70:         sql = "select 3 * (4 + 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ( 3 * (4 + 2)) + "");
1:079cd70: 
1:079cd70:         sql = "select 2 - 3 * 4 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (2 - 3 * 4) + "");
1:079cd70: 
1:079cd70:         sql = "select (2 - 3) * 4 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ((2 - 3) * 4) + "");
1:079cd70: 
1:079cd70:         sql = "select  3 * 4 - 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ( 3 * 4 - 2) + "");
1:079cd70: 
1:079cd70:         sql = "select 3 * (4 - 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (3 * (4 - 2)) + "");
1:079cd70: 
1:079cd70:         sql = "select 4 + 3 / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (4 + 3 / 2) + "");
1:079cd70: 
1:079cd70:         sql = "select (4 + 3) / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ((4 + 3) / 2) + "");
1:079cd70: 
1:079cd70:         sql = "select 3 / 2 + 4 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (3 / 2 + 4) + "");
1:079cd70: 
1:079cd70:         sql = "select 3 / (2 + 4) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (3 / (2 + 4)) + "");
1:079cd70: 
1:079cd70:         sql = "select 4 - 3 / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             (4 - 3 / 2) + "");
1:079cd70: 
1:079cd70:         sql = "select (4 - 3) / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:079cd70:             ((4 - 3) / 2) + "");
1:079cd70: 
1:079cd70:         sql = "select 1 + 2147483647 - 2 from r";
1:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         sql = "select 1 + (2147483647 - 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (1 + (2147483647 - 2)) + "");
1:079cd70: 
1:079cd70:         sql = "select 4 * 3 / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (4 * 3 / 2) + "");
1:079cd70: 
1:079cd70:         sql = "select 4 * (3 / 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (4 * (3 / 2)) + "");
1:079cd70: 
1:079cd70:         //Test associativity of unary - versus the binary operators
1:079cd70:         sql = "select -1 + 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-1 + 2) + "");
1:079cd70: 
1:079cd70:         sql = "select -(1 + 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-(1 + 2)) + "");
1:079cd70: 
1:079cd70:         sql = "select -1 - 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-1 - 2) + "");
1:079cd70: 
1:079cd70:         sql = "select -(1 - 2) from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-(1 - 2)) + "");
1:079cd70: 
1:079cd70:     //The test the associativity of unary - with respect to binary *,
1:079cd70:       //we must use a trick.  The value -1073741824 is the minimum integer 
1:079cd70:        //divided by 2. So, 1073741824 * 2 will overflow, but (-1073741824) * 2
1:079cd70:        //will not (because of two's complement arithmetic.
1:079cd70:         sql = "select -1073741824 * 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-1073741824 * 2) + "");
1:079cd70: 
1:079cd70:         sql = "select -(1073741824 * 2) from r";
1:079cd70:         assertStatementError("22003", st, sql);
1:079cd70: 
1:079cd70:         //-- This should not get an overflow
1:079cd70:         sql = "select -2147483648 / 2 from r";
1:079cd70:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:079cd70:             (-2147483648 / 2) + "");
1:079cd70: 
1:079cd70:         dropTable("r");
1:079cd70:     }
1:079cd70: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e27c25c
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigInteger;
/////////////////////////////////////////////////////////////////////////
1:     private static final String BIGINT = "bigint";
1:     private static final String DECIMAL = "decimal(31,0)";
1: 
/////////////////////////////////////////////////////////////////////////
1:         String[] tableNames = { "smallint_r", "t", "bigint_r", "decimal_r" };
1:         String[] types = { "smallint", "int", BIGINT, DECIMAL };
1:         BigInteger[][] boundaries = {
1:             { BigInteger.valueOf(Short.MIN_VALUE),
1:               BigInteger.valueOf(Short.MAX_VALUE) },
1:             { BigInteger.valueOf(Integer.MIN_VALUE),
1:               BigInteger.valueOf(Integer.MAX_VALUE) },
1:             { BigInteger.valueOf(Long.MIN_VALUE),
1:               BigInteger.valueOf(Long.MAX_VALUE) },
1:             { new BigInteger("-9999999999999999999999999999999", 10),
1:               new BigInteger("9999999999999999999999999999999", 10) },
1:         };
1:             doBasically(tableNames[i], types[i]);
1:             doOverflow(tableNames[i], types[i],
1:                     boundaries[i][0], boundaries[i][1]);
/////////////////////////////////////////////////////////////////////////
1:     private void doBasically(String tableName, String type)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         if (type.equals(DECIMAL)) {
1:             // With DECIMAL, the fraction part won't be truncated from i/j.
1:             result[1][3] = "0.100000000000000000000";
1:             result[2][3] = "0.099009900990099009900";
1:             result[3][3] = "-0.098039215686274509803";
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * @param negativeBoundary
1:      *                the negative boundary for the data type
1:      *                the positive boundary for the data type
1:             BigInteger negativeBoundary, BigInteger positiveBoundary)
1:         throws SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
1:         assertUpdateCount(st, 1, sql);
/////////////////////////////////////////////////////////////////////////
1:                 + "(" + negativeBoundary + ", 0)";
1:         assertUpdateCount(st, 1, sql);
1: 
1:         // Check if the boundaries of the data type are asymmetric and
1:         // allow more negative values than positive values.
1:         final boolean asymmetricTowardsNegative =
1:                 negativeBoundary.negate().compareTo(positiveBoundary) > 0;
1:         if (asymmetricTowardsNegative) {
1:             // For most numeric data types, the legal range is not symmetric
1:             // around zero, so negating the negative boundary will make the
1:             // resulting value out of range. Expect failure.
1:             assertStatementError("22003", st, sql);
1:         } else {
1:             // For DECIMAL, the boundaries are symmetric around zero, so
1:             // expect the query to succeed.
1:             JDBC.assertFullResultSet(st.executeQuery(sql),
1:                     new String[][] {
1:                         { "-1" },
1:                         { negativeBoundary.negate().toString() },
1:                     });
1:         }
1:                 { positiveBoundary.negate().toString() }, { "0" }, }
1:                     { positiveBoundary.subtract(BigInteger.ONE).toString() },
1:                     { "0" },
1:                 }
1:         // When type is not BIGINT or DECIMAL, it won't overflow.
1:         if (type.equals(BIGINT) || type.equals(DECIMAL)) {
/////////////////////////////////////////////////////////////////////////
1:             // Check if the negative boundary is even, in which case the
1:             // arithmetic operation below won't lose precision when dividing
1:             // by two.
1:             final boolean negativeBoundaryIsEven = !negativeBoundary.testBit(0);
1: 
1:             if (negativeBoundaryIsEven) {
1:                 // Since the negative boundary is even, dividing by two and
1:                 // subsequently multiplying by two will result in the same
1:                 // value, and subtracting one from that value will make the
1:                 // result out of range (less than negative boundary).
1:                 assertStatementError("22003", st, sql);
1:             } else {
1:                 // If the negative boundary is odd, dividing by two and
1:                 // subsequently multiplying by two will result in a value
1:                 // that is one above the negative boundary, because the
1:                 // fraction part is lost in the intermediate result. Result
1:                 // will still be in valid range, also after the subtraction.
1:                 JDBC.assertFullResultSet(st.executeQuery(sql),
1:                         new String[][] {
1:                             { "-1" },
1:                             { negativeBoundary.toString() },
1:                         });
1:             }
1: 
1:             // Same test case as above, but subtract two to force error
1:             // also when the negative boundary is odd.
1:             sql = "select i / 2 * 2 - 2 from " + tableName;
/////////////////////////////////////////////////////////////////////////
1:         BigInteger i) throws SQLException{
1:         BigInteger y = BigInteger.valueOf(2);
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 i.add(y).toString());
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 y.add(i).toString());
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 y.subtract(i).toString());
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 i.subtract(y).toString());
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 i.multiply(y).toString());
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 y.multiply(i).toString());
1:         String fraction = type.equals(DECIMAL) ? ".000000000000" : "";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 i.divide(y) + fraction);
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:                 y.divide(i).toString());
/////////////////////////////////////////////////////////////////////////
1:         String[] types = {"smallint", BIGINT, DECIMAL};
1:         String[] tableNames = {"smallint_r", "bigint_r", "decimal_r"};
1:         BigInteger[] testValues = {
1:                 BigInteger.valueOf(65535),
1:                 BigInteger.valueOf(Integer.MAX_VALUE),
1:                 BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE),
1:         };
1:             doMixedTypeImpl(tableNames[i], types[i], testValues[i]);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:079cd70
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.ArithmeticTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test case for arithmetic.sql. It tests the arithmetic operators. 
1:  */
1: public class ArithmeticTest extends BaseJDBCTestCase {
1: 
1:     public ArithmeticTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite(){
1:         return TestConfiguration.defaultSuite(ArithmeticTest.class);
1:     }
1: 
1:     /**
1:      * Test arithmetic on different types.
1:      * i.e. int and bigint, or int and smallint.
1:      * @throws SQLException 
1:      */
1:     public void testTypes() throws SQLException {
0:         String[] tableNames = { "smallint_r", "t", "bigint_r" };
0:         String[] types = { "smallint", "int", "bigint", };
0:         long[] positiveBoundaries = {32767, 2147483647, 9223372036854775807L};
1: 
1:         for (int i = 0; i < types.length; i++) {
0:             doBasically(tableNames[i], types[i], positiveBoundaries[i]);
0:             doOverflow(tableNames[i], types[i], positiveBoundaries[i]);
1: 
1:             dropTable(tableNames[i]);
1:         }
1:     }
1: 
1:     /**
1:      * Test basic arithmetic operations.
1:      * i.e. int and bigint, or int and smallint.
1:      * 
1:      * @param tableName
1:      *                the name of table to test. 
1:      *                If a table with the same name has existed,
1:      *                it will be dropped.
1:      * @param type
1:      *                the type to test. i.e. "smallint" or "bigint".
1:      * @param positiveBoundary
0:      *                for "smallint", it's 32767; for "bigint", it's 9223372036854775807.
1:      * @throws SQLException 
1:      */
0:     private void doBasically(String tableName, String type,
0:         long positiveBoundary) throws SQLException{
1:         String sql = "create table " + tableName + "(i " + 
1:             type + ", j " + type + ")";
1:         Statement st = createStatement();
1:         st.addBatch(sql);
1:         sql = "insert into " + tableName + " values (null, null)";
1:         st.addBatch(sql);
1:         sql = "insert into " + tableName + " values (0, 100)";
1:         st.addBatch(sql);
1:         sql = "insert into " + tableName + " values (1, 101)";
1:         st.addBatch(sql);
1:         sql = "insert into " + tableName + " values (-2, -102)";
1:         st.addBatch(sql);
1: 
1:         st.executeBatch();
1: 
1:         sql = "select * from " + tableName;
1:         String[][] result = {
1:             {null, null}, {"0", "100"}, {"1", "101"}, {"-2", "-102"},
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1: 
1:         sql = "select i + j from " + tableName;
1:         result = new String[][]{
1:             {null}, {"100"}, {"102"}, {"-104"},
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select i, i + 10 + 20, j, j + 100 + 200" +
1:                 " from " + tableName;
1:         result = new String [][]{
1:                     {null, null, null, null},
1:                     {"0", "30", "100", "400"},
1:                     {"1", "31", "101", "401"},
1:                     {"-2", "28", "-102", "198"}
1:                 };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select i - j, j - i from " + tableName;
1:         result = new String [][]{
1:                     {null, null},
1:                     {"-100", "100"},
1:                     {"-100", "100"},
1:                     {"100", "-100"}
1:             };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select i, i - 10 - 20, 20 - 10 - i, j, " +
1:                 "j - 100 - 200, 200 - 100 - j from " 
1:                 + tableName;
1:         result = new String [][]{
1:                 {null, null, null, null, null, null},
1:                 {"0", "-30", "10", "100", "-200", "0"},
1:                 {"1", "-29", "9", "101", "-199", "-1"},
1:                 {"-2", "-32", "12", "-102", "-402", "202"}
1:             };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select i, j, i * j, j * i from " + tableName;
1:         result = new String [][]{
1:                     {null, null, null, null},
1:                     {"0", "100", "0", "0"},
1:                     {"1", "101", "101", "101"},
1:                     {"-2", "-102", "204", "204"}
1:             };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select i, j, i * 10 * -20, j * 100 * -200 " +
1:                 "from " + tableName;
1:         result = new String [][]{
1:                     {null, null, null, null},
1:                     {"0", "100", "0", "-2000000"},
1:                     {"1", "101", "-200", "-2020000"},
1:                     {"-2", "-102", "400", "2040000"}
1:             };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         // try unary minus on some expressions
1:         sql = "select -i, -j, -(i * 10 * -20), " +
1:                 "-(j * 100 * -200) from " + tableName;
1:         result = new String[][]{
1:                 {null, null, null, null},
1:                 {"0", "-100", "0", "2000000"},
1:                 {"-1", "-101", "200", "2020000"},
1:                 {"2", "102", "-400", "-2040000"}
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         //unary plus doesn't do anything
1:         sql = "select +i, +j, +(+i * +10 * -20), " +
1:                 "+(+j * +100 * -200) from " + tableName;
1:         result = new String[][]{
1:                     {null, null, null, null},
1:                     {"0", "100", "0", "-2000000"},
1:                     {"1", "101", "-200", "-2020000"},
1:                     {"-2", "-102", "400", "2040000"}
1:                 };
1: 
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         //test null/null, constant/null, null/constant
1:         sql = "select i, j, i / j, 10 / j, j / 10 " +
1:                 "from " + tableName;
1:         result = new String[][]{
1:                     {null, null, null, null, null},
1:                     {"0", "100", "0", "0", "10"},
1:                     {"1", "101", "0", "0", "10"},
1:                     {"-2", "-102", "0", "0", "-10"}
1:                 };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         //test for divide by 0
1:         sql = "select j / i from " + tableName;
1:         assertStatementError("22012", st, sql);
1: 
1:         sql = "select (j - 1) / (i + 4), 20 / 5 / 4, " +
1:                 "20 / 4 / 5 from " + tableName;
1:         result = new String[][]{
1:                     {null, "1", "1"},
1:                     {"24", "1", "1"},
1:                     {"20", "1", "1"},
1:                     {"-51", "1", "1"}
1:                 };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         //-- test positive/negative, negative/positive 
1:         //and negative/negative
1:         sql = "select j, j / (0 - j), (0 - j) / j, " +
1:                 "(0 - j) / (0 - j) from " + tableName;
1:         result = new String [][] {
1:                      {null, null, null, null},
1:                      {"100", "-1", "-1", "1"},
1:                      {"101", "-1", "-1", "1"},
1:                      {"-102", "-1", "-1", "1"}
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         //test some "more complex" expressions
1:         sql = "select i, i + 10, i - (10 - 20), i - 10, " +
1:                 "i - (20 - 10) from " + tableName;
1:         result = new String [][] {
1:                     {null, null, null, null, null},
1:                     {"0", "10", "10", "-10", "-10"},
1:                     {"1", "11", "11", "-9", "-9"},
1:                     {"-2", "8", "8", "-12", "-12"}
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select  'The next 2 columns should agree', " +
1:                 "2 + 3 * 4 + 5, 2 + (3 * 4) + 5 " +
1:                 "from " + tableName;
1:         result = new String [][] {
1:                 {"The next 2 columns should agree", "19", "19"},
1:                 {"The next 2 columns should agree", "19", "19"},
1:                 {"The next 2 columns should agree", "19", "19"},
1:                 {"The next 2 columns should agree", "19", "19"}
1:             };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1: 
1:         sql = "select 'The next column should be 45', " +
1:                 "(2 + 3) * (4 + 5) from " + tableName;
1:         result = new String [][] {
1:                 {"The next column should be 45", "45"},
1:                 {"The next column should be 45", "45"},
1:                 {"The next column should be 45", "45"},
1:                 {"The next column should be 45", "45"}
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:             result);
1:     }
1: 
1:     /**
1:      * Test overflow on some types.
1:      * i.e. int and bigint, or int and smallint.
1:      * 
1:      * @param tableName
1:      *                the name of table to test. 
1:      *                If a table with the same name has existed,
1:      *                it will be dropped.
1:      * @param type
1:      *                the type to test. i.e. "smallint" or "bigint".
1:      * @param positiveBoundary
0:      *                for "smallint", it's 32767; for "bigint", it's 9223372036854775807.
1:      * @throws SQLException 
1:      */
1:     private void doOverflow(String tableName, String type,
0:         long positiveBoundary) throws SQLException{
1:         dropTable(tableName);
1:         String sql = "create table " + tableName
1:                 + " (i " + type + ", j " + type + ")";
1:         Statement st = createStatement();
1:         st.executeUpdate(sql);
1: 
1:         long i = 1L;
1:         sql = "insert into " + tableName + " values (" 
1:                 + i + "," + positiveBoundary + ")";
1:         assertEquals(1, st.executeUpdate(sql));
1: 
1:         sql = "select i + j from " + tableName;
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "select i - j - j from " + tableName;
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "select j + j from " + tableName;
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "select j * j from " + tableName;
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "insert into " + tableName + " values "
0:                 + "(" + (-positiveBoundary - 1) + ", 0)";
1:         assertEquals(1, st.executeUpdate(sql));
1: 
1:         sql = "select -i from " + tableName;
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "select -j from " + tableName;
1:         JDBC.assertFullResultSet(st.executeQuery(sql),
1:                 new String[][] {
0:                 { "" + (-positiveBoundary) }, { "0" }, }
1:         );
1: 
1:         sql = "select j / 2 * 2 from " + tableName;
1:         JDBC.assertFullResultSet(st.executeQuery(sql), 
1:                 new String[][] {
0:                 { "" + (positiveBoundary - 1) }, { "0" }, }
1:         );
1: 
0:         // when type is not bigint, it won't overflow.
1:         // Just like testMixedType().
0:         if (type.equals("bigint")) {
1:             sql = "select 2 * (" + positiveBoundary + " / 2 + 1) from "
1:                     + tableName;
1:             assertStatementError("22003", st, sql);
1: 
1:             sql = "select -2 * (" + positiveBoundary + " / 2 + 2) from " 
1:                     + tableName;
1:             assertStatementError("22003", st, sql);
1: 
1:             sql = "select 2 * ((-" + positiveBoundary + " - 1) / 2 - 1) from "
1:                     + tableName;
1:             assertStatementError("22003", st, sql);
1: 
1:             sql = "select -2 * ((-" + positiveBoundary + " - 1) / 2 - 1) from "
1:                     + tableName;
1:             assertStatementError("22003", st, sql);
1: 
1:             //different from arithmetic. This can support better test.
1:             sql = "select i / 2 * 2 - 1 from " + tableName;
1:             assertStatementError("22003", st, sql);
1:         }
1:     }
1: 
1:     /**
1:      * Test mixed types.i.e. int and bigint, or int and smallint.
1:      * 
1:      * @param tableName
1:      *                the name of table to test.
1:      * @param type
1:      *                the type to test. i.e. "smallint" or "bigint".
1:      * @param i
1:      *                an integer number to test with.
1:      * @throws SQLException 
1:      */
1:     private void doMixedTypeImpl(String tableName, String type,
0:         int i) throws SQLException{
1:         String sql = "create table " + tableName 
1:             + " (y "  + type+ ")" ;
1:         Statement st = createStatement();
1:         st.executeUpdate(sql);
1: 
0:         long y = 2L;
1:         sql = "insert into " + tableName + " values (" + y + ")";
1:         assertEquals(1, st.executeUpdate(sql));
1: 
1:         sql = "select " + i + " + y from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (i + y));    
1: 
1:         sql = "select y + " + i + " from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (y + i));    
1: 
1:         sql = "select y - " + i + " from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (y - i));
1: 
1:         sql = "select " + i + " - y from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (i - y));
1: 
1:         sql = "select " + i + " * y from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (i * y));
1: 
1:         sql = "select y * " + i + " from "+ tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (y * i));
1: 
1:         sql = "select " + i + " / y from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (i / y));
1: 
1:         sql = "select y / " + i + " from " + tableName;
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
0:             "" + (y / i));    
1: 
1:         st.close();
1:     }
1: 
1:     /**
1:      * Test mixed types.i.e. int and bigint, or int and smallint.
1:      * @throws SQLException
1:      */
1:     public void testMixedType() throws SQLException{
0:         String[] types = {"smallint", "bigint",};
0:         String[] tableNames = {"smallint_r", "bigint_r"};
0:         int[]positiveBoundaries = {65535, 2147483647,};
1: 
1:         for(int i = 0; i < types.length; i++){
0:             doMixedTypeImpl(tableNames[i], types[i],
0:                 positiveBoundaries[i]);
1:             dropTable(tableNames[i]);
1:         }
1:     }
1: 
1:     /**
1:      * Test the arithmetic operators on a type we know they don't work on.
1:      * @throws SQLException 
1:      */
1:     public void testWrongType() throws SQLException{
1:         String sql = "create table s (x char(10), y char(10))";
1:         Statement st = createStatement();
1:         st.executeUpdate(sql);
1:         st.close();
1: 
1:         sql ="select x + y from s";
1:         assertCompileError("42Y95", sql);
1: 
1:         sql = "select x - y from s";
1:         assertCompileError("42Y95", sql);
1: 
1:         sql = "select x * y from s";
1:         assertCompileError("42Y95", sql);
1: 
1:         sql = "select x / y from s";
1:         assertCompileError("42Y95", sql);
1: 
1:         sql = "select -x from s";
1:         assertCompileError("42X37", sql);
1: 
1:         dropTable("s");
1:     }
1: 
1:     /**
1:      * Arithmetic on a numeric data type.
1:      * @throws SQLException 
1:      */
1:     public void testNumericDataType() throws SQLException{
1:         String sql = "create table u (c1 int, c2 char(10))";    
1:         Statement st = createStatement();
1:         st.addBatch(sql);
1:         sql = "insert into u (c2) values 'asdf'";
1:         st.addBatch(sql);
1:         sql = "insert into u (c1) values null";
1:         st.addBatch(sql);
1:         sql = "insert into u (c1) values 1";
1:         st.addBatch(sql);
1:         sql = "insert into u (c1) values null";
1:         st.addBatch(sql);
1:         sql = "insert into u (c1) values 2";
1:         st.addBatch(sql);
1:         st.executeBatch();
1: 
1:         sql = "select * from u";
1:         String[][] result = {
1:             {null, "asdf",},
1:             {null, null,},
1:             {"1", null,},
1:             {null, null,},
1:             {"2", null,},
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1: 
1:         sql = "select c1 + c1 from u";
1:         result = new String[][]{
1:             {null,}, {null,}, {"2",}, {null,}, {"4",},
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1: 
1:         sql = "select c1 / c1 from u";
1:         result = new String[][]{
1:             {null,}, {null,}, {"1",}, {null,}, {"1",},
1:         };
1:         JDBC.assertFullResultSet(st.executeQuery(sql), result);
1: 
1:         //arithmetic between a numeric and a string data type fails.
1:         sql = "select c1 + c2 from u";
1:         assertStatementError("22018", st, sql);
1: 
1:         st.close();
1: 
1:         dropTable("u");
1:     }
1: 
1:     public void testPrecedenceAndAssociativity() throws SQLException{
1:         String sql = "create table r (x int)";
1:         Statement st = createStatement();
1:         st.executeUpdate(sql);
1: 
1:         sql = "insert into r values (1)";
1:         assertEquals(1, st.executeUpdate(sql));
1: 
1:         sql = "select 2 + 3 * 4 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (2 + 3 * 4) + "");
1: 
1:         sql = "select (2 + 3) * 4 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ((2 + 3) * 4) + "");
1: 
1:         sql = "select 3 * 4 + 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ( 3 * 4 + 2) + "");
1: 
1:         sql = "select 3 * (4 + 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ( 3 * (4 + 2)) + "");
1: 
1:         sql = "select 2 - 3 * 4 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (2 - 3 * 4) + "");
1: 
1:         sql = "select (2 - 3) * 4 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ((2 - 3) * 4) + "");
1: 
1:         sql = "select  3 * 4 - 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ( 3 * 4 - 2) + "");
1: 
1:         sql = "select 3 * (4 - 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (3 * (4 - 2)) + "");
1: 
1:         sql = "select 4 + 3 / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (4 + 3 / 2) + "");
1: 
1:         sql = "select (4 + 3) / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ((4 + 3) / 2) + "");
1: 
1:         sql = "select 3 / 2 + 4 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (3 / 2 + 4) + "");
1: 
1:         sql = "select 3 / (2 + 4) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (3 / (2 + 4)) + "");
1: 
1:         sql = "select 4 - 3 / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             (4 - 3 / 2) + "");
1: 
1:         sql = "select (4 - 3) / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql),
1:             ((4 - 3) / 2) + "");
1: 
1:         sql = "select 1 + 2147483647 - 2 from r";
1:         assertStatementError("22003", st, sql);
1: 
1:         sql = "select 1 + (2147483647 - 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (1 + (2147483647 - 2)) + "");
1: 
1:         sql = "select 4 * 3 / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (4 * 3 / 2) + "");
1: 
1:         sql = "select 4 * (3 / 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (4 * (3 / 2)) + "");
1: 
1:         //Test associativity of unary - versus the binary operators
1:         sql = "select -1 + 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-1 + 2) + "");
1: 
1:         sql = "select -(1 + 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-(1 + 2)) + "");
1: 
1:         sql = "select -1 - 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-1 - 2) + "");
1: 
1:         sql = "select -(1 - 2) from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-(1 - 2)) + "");
1: 
1:     //The test the associativity of unary - with respect to binary *,
1:       //we must use a trick.  The value -1073741824 is the minimum integer 
1:        //divided by 2. So, 1073741824 * 2 will overflow, but (-1073741824) * 2
1:        //will not (because of two's complement arithmetic.
1:         sql = "select -1073741824 * 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-1073741824 * 2) + "");
1: 
1:         sql = "select -(1073741824 * 2) from r";
1:         assertStatementError("22003", st, sql);
1: 
1:         //-- This should not get an overflow
1:         sql = "select -2147483648 / 2 from r";
1:         JDBC.assertSingleValueResultSet(st.executeQuery(sql), 
1:             (-2147483648 / 2) + "");
1: 
1:         dropTable("r");
1:     }
1: }
============================================================================