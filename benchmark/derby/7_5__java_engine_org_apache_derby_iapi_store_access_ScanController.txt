1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.ScanController
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   A scan is the mechanism for iterating over the rows in a conglomerate,
1:eac0369:   the scan controller is the interface through which access clients
1:eac0369:   control the underlying scan.  An instance of a scan controller can 
1:eac0369:   be thought of as an open scan.
1:eac0369:   <p>
1:eac0369:   Scans are opened from a TransactionController.
1:eac0369:   <P>
1:eac0369:   A ScanController can handle partial rows. Partial rows
1:eac0369:   are described in RowUtil.
1:eac0369:   <BR>
1:eac0369:   A scan controller is opened with a FormatableBitSet that describes the
1:eac0369:   columns that need to be returned on a fetch call. This FormatableBitSet
1:eac0369:   need not include any columns referenced in the qualifers, start
1:eac0369:   and/or stop keys.
1:eac0369: 
1:eac0369:   @see TransactionController#openScan
1:eac0369:   @see GenericScanController
1:eac0369:   @see RowCountable
1:eac0369:   @see RowUtil
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public interface ScanController extends GenericScanController
1:eac0369: {
1:eac0369:     /**
1:eac0369: 
1:eac0369:     GE is used to position a scan at values greater than or or equal to the
1:eac0369:     given key in the scan.  This positioning argument refers to the order 
1:eac0369:     within the scan (not necessarily actual compare calls on the datatypes).  
1:eac0369:     "greater" than is interpreted in terms of the 
1:eac0369:     current conglomerate and scan.  For instance, a btree may be ordered
1:eac0369:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
1:eac0369:     scan on that index, and 1 is "greater" than 2 in a backward scan.
1:eac0369:     If the btree was ordered descending on an int then 1 is "greater" than
1:eac0369:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
1:eac0369:     scan.
1:eac0369: 
1:eac0369:     @see TransactionController#openScan
1:eac0369:     */
1:eac0369: 
1:eac0369:     /* The value of this must be the same value returned by the Orderable
1:eac0369:      * interface when a key is > than another key.
1:eac0369:      */
1:eac0369:     public static final int GE = 1;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     GT is used to position a scan at values greater than the given key.
1:eac0369:     This positioning argument refers to the order 
1:eac0369:     within the scan (not necessarily actual compare calls on the datatypes).  
1:eac0369:     "greater" than is interpreted in terms of the 
1:eac0369:     current conglomerate and scan.  For instance, a btree may be ordered
1:eac0369:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
1:eac0369:     scan on that index, and 1 is "greater" than 2 in a backward scan.
1:eac0369:     If the btree was ordered descending on an int then 1 is "greater" than
1:eac0369:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
1:eac0369:     scan.
1:eac0369: 
1:eac0369:     @see TransactionController#openScan
1:eac0369:     */
1:eac0369:     /* The value of this must be the same value returned by the Orderable
1:eac0369:      * interface when a key is < than another key.
1:eac0369:      */
1:eac0369:     public static final int GT = -1;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     NA - argument is unused in call.  For some scans the key is set to null
1:eac0369:     to indicate no start or stop position, in those cases the position 
1:eac0369:     operator is ignored.
1:eac0369: 
1:eac0369:     @see TransactionController#openScan
1:eac0369:     */
1:eac0369:     /* The value of this must be the same value returned by the Orderable
1:eac0369:      * interface when a key is < than another key.
1:eac0369:      */
1:eac0369:     public static final int NA = 0;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Delete the row at the current position of the scan.
1:eac0369: 
1:eac0369:     @return true if the delete was successful,
1:eac0369: 	false if the current position is no longer valid (ie. if it was already
1:eac0369: 	deleted).
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     boolean delete()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * A call to allow client to indicate that current row does not qualify.
1:eac0369:      * <p>
1:eac0369:      * Indicates to the ScanController that the current row does not
1:eac0369:      * qualify for the scan.  If the isolation level of the scan allows, 
1:eac0369:      * this may result in the scan releasing the lock on this row.
1:eac0369:      * <p>
1:eac0369:      * Note that some scan implimentations may not support releasing locks on 
1:eac0369:      * non-qualifying rows, or may delay releasing the lock until sometime
1:eac0369:      * later in the scan (ie. it may be necessary to keep the lock until 
1:eac0369:      * either the scan is repositioned on the next row or page).
1:eac0369:      * <p>
1:eac0369:      * This call should only be made while the scan is positioned on a current
1:eac0369:      * valid row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     void didNotQualify() throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Returns true if the current position of the scan still qualifies
1:eac0369:     under the set of qualifiers passed to the openScan().  When called
1:eac0369:     this routine will reapply all qualifiers against the row currently
1:eac0369:     positioned and return true if the row still qualifies.  If the row
1:eac0369:     has been deleted or no longer passes the qualifiers then this routine
1:eac0369:     will return false.
1:eac0369:     
1:eac0369:     This case can come about if the current scan
1:eac0369:     or another scan on the same table in the same transaction 
1:eac0369:     deleted the row or changed columns referenced by the qualifier after 
1:eac0369:     the next() call which positioned the scan at this row.  
1:eac0369: 
1:eac0369:     Note that for comglomerates which don't support update, like btree's, 
1:eac0369:     there is no need to recheck the qualifiers.
1:eac0369: 
1:eac0369:     The results of a fetch() performed on a scan positioned on 
1:eac0369:     a deleted row are undefined, note that this can happen even if next()
1:eac0369:     has returned true (for instance the client can delete the row, or if
1:eac0369:     using read uncommitted another thread can delete the row after the
1:eac0369:     next() call but before the fetch).
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     boolean doesCurrentPositionQualify()
1:eac0369: 		throws StandardException;
1:1e762f5: 
1:eac0369: 
1:1e762f5:     /**
1:1e762f5:      * Return true is the scan has been closed after a commit, but was
1:1e762f5:      * opened with holdability and can be reopened using
1:1e762f5:      * positionAtRowLocation.
1:1e762f5:      *
1:1e762f5:      * @exception StandardException Standard exception policy.
1:1e762f5:      *
1:1e762f5:      * @see ScanController#positionAtRowLocation
1:1e762f5:      */
1:1e762f5:     boolean isHeldAfterCommit() throws StandardException;
1:1e762f5: 
1:eac0369:     /**
1:eac0369:     Fetch the (partial) row at the current position of the Scan.
1:eac0369: 	The value in the destRow storable row is replaced
1:eac0369: 	with the value of the row at the current scan
1:eac0369: 	position.  The columns of the destRow row must
1:eac0369: 	be of the same type as the actual columns in the
1:eac0369: 	underlying conglomerate. The number of elements in
1:eac0369: 	fetch must be compatible with the number of scan columns
1:eac0369: 	requested at the openScan call time.
1:eac0369: 	<BR>
1:af1c18c:     A fetch can return a sub-set of the scan columns requested
1:eac0369: 	at scan open time by supplying a destRow will less elements
1:eac0369: 	than the number of requested columns. In this case the N leftmost
1:eac0369: 	of the requested columns are fetched, where N = destRow.length.
1:eac0369: 	In the case where all columns are rested and N = 2 then columns 0 and 1
1:eac0369: 	are returned. In the case where the openScan FormatableBitSet requested columns
1:eac0369: 	1, 4 and 7, then columns 1 and 4 would be fetched when N = 2.
1:eac0369: 	<BR>
1:eac0369: 
1:eac0369:     The results of a fetch() performed on a scan after next() has returned
1:eac0369:     false are undefined.
1:eac0369: 
1:eac0369:     A fetch() performed on a scan positioned on 
1:eac0369:     a deleted row will throw a StandardException with 
1:eac0369:     state = SQLState.AM_RECORD_NOT_FOUND.  Note that this can happen even if 
1:eac0369:     next() has returned true (for instance the client can delete the row, or if
1:eac0369:     using read uncommitted another thread can delete the row after the
1:eac0369:     next() call but before the fetch).
1:eac0369: 
1:eac0369:     @param destRow The row into which the value of the current 
1:eac0369:     position in the scan is to be stored.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	@see RowUtil
1:eac0369:     **/
1:eac0369:     void fetch(DataValueDescriptor[] destRow)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:2700e3d:      The same as fetch, except that the qualifiers passed to the openScan()
1:2700e3d:      will not be applied. destRow will contain the current row even if it
1:2700e3d:      has been changed and no longer qualifies.
1:2700e3d: 
1:2700e3d:      @param destRow The row into which the value of the current 
1:2700e3d:      position in the scan is to be stored.
1:2700e3d: 
1:2700e3d:      @exception StandardException Standard exception policy.
1:2700e3d:      */
1:2700e3d:     void fetchWithoutQualify(DataValueDescriptor[] destRow)
1:2700e3d: 		throws StandardException;
1:2700e3d: 
1:2700e3d:     /**
1:eac0369:     Fetch the (partial) row at the next position of the Scan.
1:eac0369: 
1:eac0369:     If there is a valid next position in the scan then
1:eac0369: 	the value in the destRow storable row is replaced
1:eac0369: 	with the value of the row at the current scan
1:eac0369: 	position.  The columns of the destRow row must
1:eac0369: 	be of the same type as the actual columns in the
1:eac0369: 	underlying conglomerate.
1:eac0369: 
1:eac0369:     The resulting contents of destRow after a fetchNext() 
1:eac0369:     which returns false is undefined.
1:eac0369: 
1:eac0369:     The result of calling fetchNext(row) is exactly logically
1:eac0369:     equivalent to making a next() call followed by a fetch(row)
1:eac0369:     call.  This interface allows implementations to optimize 
1:eac0369:     the 2 calls if possible.
1:eac0369: 
1:eac0369:     @param destRow The destRow row into which the value
1:eac0369: 	of the next position in the scan is to be stored.
1:eac0369: 
1:eac0369:     @return True if there is a next position in the scan,
1:eac0369: 	false if there isn't.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	@see ScanController#fetch
1:eac0369: 	@see RowUtil
1:eac0369:     **/
1:eac0369:     boolean fetchNext(DataValueDescriptor[] destRow)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Fetch the location of the current position in the scan.
1:eac0369: 	The destination location is replaced with the location
1:eac0369: 	corresponding to the current position in the scan.
1:eac0369: 	The destination location must be of the correct actual
1:eac0369: 	type to accept a location from the underlying conglomerate
1:eac0369: 	location.
1:eac0369: 
1:eac0369:     The results of a fetchLocation() performed on a scan after next() has 
1:eac0369:     returned false are undefined.
1:eac0369: 
1:eac0369:     The results of a fetchLocation() performed on a scan positioned on 
1:eac0369:     a deleted row are undefined, note that this can happen even if next()
1:eac0369:     has returned true (for instance the client can delete the row, or if
1:eac0369:     using read uncommitted another thread can delete the row after the
1:eac0369:     next() call but before the fetchLocation).
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	void fetchLocation(RowLocation destRowLocation)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Returns true if the current position of the scan is at a 
1:eac0369:     deleted row.  This case can come about if the current scan
1:eac0369:     or another scan on the same table in the same transaction 
1:eac0369:     deleted the row after the next() call which positioned the
1:eac0369:     scan at this row.  
1:eac0369: 
1:eac0369:     The results of a fetch() performed on a scan positioned on 
1:eac0369:     a deleted row are undefined.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     boolean isCurrentPositionDeleted()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Move to the next position in the scan.  If this is the first
1:eac0369:     call to next(), the position is set to the first row.
1:eac0369:     Returns false if there is not a next row to move to.
1:eac0369:     It is possible, but not guaranteed, that this method could return 
1:eac0369:     true again, after returning false, if some other operation in the same 
1:eac0369:     transaction appended a row to the underlying conglomerate.
1:eac0369: 
1:eac0369:     @return True if there is a next position in the scan,
1:eac0369: 	false if there isn't.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     boolean next()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:d376440:      * Positions the scan at row location and locks the row. 
1:d376440:      * If the scan is not opened, it will be reopened if this is a holdable 
1:d376440:      * scan and there has not been any operations which causes RowLocations 
1:d376440:      * to be invalidated.
1:d376440:      * @param rl RowLocation for the new position for the scan. The 
1:d376440:      *           RowLocation submitted should be a RowLocation which has 
1:d376440:      *           previously been returned by this ScanController.
1:d376440:      * @return true if the scan has been positioned at the RowLocation.
1:d376440:      *         false if the scan could not be positioned.
1:d376440:      * 
1:d376440:      * @exception StandardException Standard exception policy.
1:d376440:      *
1:d376440:      */
1:d376440:     boolean positionAtRowLocation(RowLocation rl) 
1:d376440:         throws StandardException;
1:d376440: 
1:d376440: 
1:d376440:     /**
1:eac0369:     Replace the (partial) row at the current position of the scan.
1:eac0369: 
1:eac0369:     @return true if the replace was successful,
1:eac0369: 	false if the current position is no longer valid (ie. if it was deleted).
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	@see RowUtil
1:eac0369:     **/
1:eac0369: 
1:eac0369:     boolean replace(DataValueDescriptor[] row, FormatableBitSet validColumns)
1:eac0369: 		throws StandardException;
1:2700e3d: 
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     A fetch can return a sub-set of the scan columns requested
commit:1e762f5
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return true is the scan has been closed after a commit, but was
1:      * opened with holdability and can be reopened using
1:      * positionAtRowLocation.
1:      *
1:      * @exception StandardException Standard exception policy.
1:      *
1:      * @see ScanController#positionAtRowLocation
1:      */
1:     boolean isHeldAfterCommit() throws StandardException;
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1:      The same as fetch, except that the qualifiers passed to the openScan()
1:      will not be applied. destRow will contain the current row even if it
1:      has been changed and no longer qualifies.
1: 
1:      @param destRow The row into which the value of the current 
1:      position in the scan is to be stored.
1: 
1:      @exception StandardException Standard exception policy.
1:      */
1:     void fetchWithoutQualify(DataValueDescriptor[] destRow)
1: 		throws StandardException;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1:      * Positions the scan at row location and locks the row. 
1:      * If the scan is not opened, it will be reopened if this is a holdable 
1:      * scan and there has not been any operations which causes RowLocations 
1:      * to be invalidated.
1:      * @param rl RowLocation for the new position for the scan. The 
1:      *           RowLocation submitted should be a RowLocation which has 
1:      *           previously been returned by this ScanController.
1:      * @return true if the scan has been positioned at the RowLocation.
1:      *         false if the scan could not be positioned.
1:      * 
1:      * @exception StandardException Standard exception policy.
1:      *
1:      */
1:     boolean positionAtRowLocation(RowLocation rl) 
1:         throws StandardException;
1: 
1: 
1:     /**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.ScanController
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access;
1: 
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1: 
1:   A scan is the mechanism for iterating over the rows in a conglomerate,
1:   the scan controller is the interface through which access clients
1:   control the underlying scan.  An instance of a scan controller can 
1:   be thought of as an open scan.
1:   <p>
1:   Scans are opened from a TransactionController.
1:   <P>
1:   A ScanController can handle partial rows. Partial rows
1:   are described in RowUtil.
1:   <BR>
1:   A scan controller is opened with a FormatableBitSet that describes the
1:   columns that need to be returned on a fetch call. This FormatableBitSet
1:   need not include any columns referenced in the qualifers, start
1:   and/or stop keys.
1: 
1:   @see TransactionController#openScan
1:   @see GenericScanController
1:   @see RowCountable
1:   @see RowUtil
1: 
1: **/
1: 
1: public interface ScanController extends GenericScanController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     /**
1: 
1:     GE is used to position a scan at values greater than or or equal to the
1:     given key in the scan.  This positioning argument refers to the order 
1:     within the scan (not necessarily actual compare calls on the datatypes).  
1:     "greater" than is interpreted in terms of the 
1:     current conglomerate and scan.  For instance, a btree may be ordered
1:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
1:     scan on that index, and 1 is "greater" than 2 in a backward scan.
1:     If the btree was ordered descending on an int then 1 is "greater" than
1:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
1:     scan.
1: 
1:     @see TransactionController#openScan
1:     */
1: 
1:     /* The value of this must be the same value returned by the Orderable
1:      * interface when a key is > than another key.
1:      */
1:     public static final int GE = 1;
1: 
1:     /**
1:     GT is used to position a scan at values greater than the given key.
1:     This positioning argument refers to the order 
1:     within the scan (not necessarily actual compare calls on the datatypes).  
1:     "greater" than is interpreted in terms of the 
1:     current conglomerate and scan.  For instance, a btree may be ordered
1:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
1:     scan on that index, and 1 is "greater" than 2 in a backward scan.
1:     If the btree was ordered descending on an int then 1 is "greater" than
1:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
1:     scan.
1: 
1:     @see TransactionController#openScan
1:     */
1:     /* The value of this must be the same value returned by the Orderable
1:      * interface when a key is < than another key.
1:      */
1:     public static final int GT = -1;
1: 
1:     /**
1:     NA - argument is unused in call.  For some scans the key is set to null
1:     to indicate no start or stop position, in those cases the position 
1:     operator is ignored.
1: 
1:     @see TransactionController#openScan
1:     */
1:     /* The value of this must be the same value returned by the Orderable
1:      * interface when a key is < than another key.
1:      */
1:     public static final int NA = 0;
1: 
1:     /**
1:     Delete the row at the current position of the scan.
1: 
1:     @return true if the delete was successful,
1: 	false if the current position is no longer valid (ie. if it was already
1: 	deleted).
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     boolean delete()
1: 		throws StandardException;
1: 
1:     /**
1:      * A call to allow client to indicate that current row does not qualify.
1:      * <p>
1:      * Indicates to the ScanController that the current row does not
1:      * qualify for the scan.  If the isolation level of the scan allows, 
1:      * this may result in the scan releasing the lock on this row.
1:      * <p>
1:      * Note that some scan implimentations may not support releasing locks on 
1:      * non-qualifying rows, or may delay releasing the lock until sometime
1:      * later in the scan (ie. it may be necessary to keep the lock until 
1:      * either the scan is repositioned on the next row or page).
1:      * <p>
1:      * This call should only be made while the scan is positioned on a current
1:      * valid row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void didNotQualify() throws StandardException;
1: 
1:     /**
1:     Returns true if the current position of the scan still qualifies
1:     under the set of qualifiers passed to the openScan().  When called
1:     this routine will reapply all qualifiers against the row currently
1:     positioned and return true if the row still qualifies.  If the row
1:     has been deleted or no longer passes the qualifiers then this routine
1:     will return false.
1:     
1:     This case can come about if the current scan
1:     or another scan on the same table in the same transaction 
1:     deleted the row or changed columns referenced by the qualifier after 
1:     the next() call which positioned the scan at this row.  
1: 
1:     Note that for comglomerates which don't support update, like btree's, 
1:     there is no need to recheck the qualifiers.
1: 
1:     The results of a fetch() performed on a scan positioned on 
1:     a deleted row are undefined, note that this can happen even if next()
1:     has returned true (for instance the client can delete the row, or if
1:     using read uncommitted another thread can delete the row after the
1:     next() call but before the fetch).
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     boolean doesCurrentPositionQualify()
1: 		throws StandardException;
1: 
1:     /**
1:     Fetch the (partial) row at the current position of the Scan.
1: 	The value in the destRow storable row is replaced
1: 	with the value of the row at the current scan
1: 	position.  The columns of the destRow row must
1: 	be of the same type as the actual columns in the
1: 	underlying conglomerate. The number of elements in
1: 	fetch must be compatible with the number of scan columns
1: 	requested at the openScan call time.
1: 	<BR>
0: 	A fetch can return a sub-set of the scan columns reqested
1: 	at scan open time by supplying a destRow will less elements
1: 	than the number of requested columns. In this case the N leftmost
1: 	of the requested columns are fetched, where N = destRow.length.
1: 	In the case where all columns are rested and N = 2 then columns 0 and 1
1: 	are returned. In the case where the openScan FormatableBitSet requested columns
1: 	1, 4 and 7, then columns 1 and 4 would be fetched when N = 2.
1: 	<BR>
1: 
1:     The results of a fetch() performed on a scan after next() has returned
1:     false are undefined.
1: 
1:     A fetch() performed on a scan positioned on 
1:     a deleted row will throw a StandardException with 
1:     state = SQLState.AM_RECORD_NOT_FOUND.  Note that this can happen even if 
1:     next() has returned true (for instance the client can delete the row, or if
1:     using read uncommitted another thread can delete the row after the
1:     next() call but before the fetch).
1: 
1:     @param destRow The row into which the value of the current 
1:     position in the scan is to be stored.
1: 
1: 	@exception StandardException Standard exception policy.
1: 	@see RowUtil
1:     **/
1:     void fetch(DataValueDescriptor[] destRow)
1: 		throws StandardException;
1: 
1:     /**
1:     Fetch the (partial) row at the next position of the Scan.
1: 
1:     If there is a valid next position in the scan then
1: 	the value in the destRow storable row is replaced
1: 	with the value of the row at the current scan
1: 	position.  The columns of the destRow row must
1: 	be of the same type as the actual columns in the
1: 	underlying conglomerate.
1: 
1:     The resulting contents of destRow after a fetchNext() 
1:     which returns false is undefined.
1: 
1:     The result of calling fetchNext(row) is exactly logically
1:     equivalent to making a next() call followed by a fetch(row)
1:     call.  This interface allows implementations to optimize 
1:     the 2 calls if possible.
1: 
1:     @param destRow The destRow row into which the value
1: 	of the next position in the scan is to be stored.
1: 
1:     @return True if there is a next position in the scan,
1: 	false if there isn't.
1: 
1: 	@exception StandardException Standard exception policy.
1: 	@see ScanController#fetch
1: 	@see RowUtil
1:     **/
1:     boolean fetchNext(DataValueDescriptor[] destRow)
1: 		throws StandardException;
1: 
1: 	/**
1: 	Fetch the location of the current position in the scan.
1: 	The destination location is replaced with the location
1: 	corresponding to the current position in the scan.
1: 	The destination location must be of the correct actual
1: 	type to accept a location from the underlying conglomerate
1: 	location.
1: 
1:     The results of a fetchLocation() performed on a scan after next() has 
1:     returned false are undefined.
1: 
1:     The results of a fetchLocation() performed on a scan positioned on 
1:     a deleted row are undefined, note that this can happen even if next()
1:     has returned true (for instance the client can delete the row, or if
1:     using read uncommitted another thread can delete the row after the
1:     next() call but before the fetchLocation).
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	void fetchLocation(RowLocation destRowLocation)
1: 		throws StandardException;
1: 
1:     /**
1:     Returns true if the current position of the scan is at a 
1:     deleted row.  This case can come about if the current scan
1:     or another scan on the same table in the same transaction 
1:     deleted the row after the next() call which positioned the
1:     scan at this row.  
1: 
1:     The results of a fetch() performed on a scan positioned on 
1:     a deleted row are undefined.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     boolean isCurrentPositionDeleted()
1: 		throws StandardException;
1: 
1:     /**
1:     Move to the next position in the scan.  If this is the first
1:     call to next(), the position is set to the first row.
1:     Returns false if there is not a next row to move to.
1:     It is possible, but not guaranteed, that this method could return 
1:     true again, after returning false, if some other operation in the same 
1:     transaction appended a row to the underlying conglomerate.
1: 
1:     @return True if there is a next position in the scan,
1: 	false if there isn't.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     boolean next()
1: 		throws StandardException;
1: 
1:     /**
1:     Replace the (partial) row at the current position of the scan.
1: 
1:     @return true if the replace was successful,
1: 	false if the current position is no longer valid (ie. if it was deleted).
1: 
1: 	@exception StandardException Standard exception policy.
1: 	@see RowUtil
1:     **/
1: 
1:     boolean replace(DataValueDescriptor[] row, FormatableBitSet validColumns)
1: 		throws StandardException;
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0: 
0:   A scan is the mechanism for iterating over the rows in a conglomerate,
0:   the scan controller is the interface through which access clients
0:   control the underlying scan.  An instance of a scan controller can 
0:   be thought of as an open scan.
0:   <p>
0:   Scans are opened from a TransactionController.
0:   <P>
0:   A ScanController can handle partial rows. Partial rows
0:   are described in RowUtil.
0:   <BR>
0:   A scan controller is opened with a FormatableBitSet that describes the
0:   columns that need to be returned on a fetch call. This FormatableBitSet
0:   need not include any columns referenced in the qualifers, start
0:   and/or stop keys.
0: 
0:   @see TransactionController#openScan
0:   @see GenericScanController
0:   @see RowCountable
0:   @see RowUtil
0: 
0: **/
0: 
0: public interface ScanController extends GenericScanController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     /**
0: 
0:     GE is used to position a scan at values greater than or or equal to the
0:     given key in the scan.  This positioning argument refers to the order 
0:     within the scan (not necessarily actual compare calls on the datatypes).  
0:     "greater" than is interpreted in terms of the 
0:     current conglomerate and scan.  For instance, a btree may be ordered
0:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
0:     scan on that index, and 1 is "greater" than 2 in a backward scan.
0:     If the btree was ordered descending on an int then 1 is "greater" than
0:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
0:     scan.
0: 
0:     @see TransactionController#openScan
0:     */
0: 
0:     /* The value of this must be the same value returned by the Orderable
0:      * interface when a key is > than another key.
0:      */
0:     public static final int GE = 1;
0: 
0:     /**
0:     GT is used to position a scan at values greater than the given key.
0:     This positioning argument refers to the order 
0:     within the scan (not necessarily actual compare calls on the datatypes).  
0:     "greater" than is interpreted in terms of the 
0:     current conglomerate and scan.  For instance, a btree may be ordered
0:     ascending on an int, in that case a 2 is "greater" than 1 in a forward
0:     scan on that index, and 1 is "greater" than 2 in a backward scan.
0:     If the btree was ordered descending on an int then 1 is "greater" than
0:     2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
0:     scan.
0: 
0:     @see TransactionController#openScan
0:     */
0:     /* The value of this must be the same value returned by the Orderable
0:      * interface when a key is < than another key.
0:      */
0:     public static final int GT = -1;
0: 
0:     /**
0:     NA - argument is unused in call.  For some scans the key is set to null
0:     to indicate no start or stop position, in those cases the position 
0:     operator is ignored.
0: 
0:     @see TransactionController#openScan
0:     */
0:     /* The value of this must be the same value returned by the Orderable
0:      * interface when a key is < than another key.
0:      */
0:     public static final int NA = 0;
0: 
0:     /**
0:     Delete the row at the current position of the scan.
0: 
0:     @return true if the delete was successful,
0: 	false if the current position is no longer valid (ie. if it was already
0: 	deleted).
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     boolean delete()
0: 		throws StandardException;
0: 
0:     /**
0:      * A call to allow client to indicate that current row does not qualify.
0:      * <p>
0:      * Indicates to the ScanController that the current row does not
0:      * qualify for the scan.  If the isolation level of the scan allows, 
0:      * this may result in the scan releasing the lock on this row.
0:      * <p>
0:      * Note that some scan implimentations may not support releasing locks on 
0:      * non-qualifying rows, or may delay releasing the lock until sometime
0:      * later in the scan (ie. it may be necessary to keep the lock until 
0:      * either the scan is repositioned on the next row or page).
0:      * <p>
0:      * This call should only be made while the scan is positioned on a current
0:      * valid row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     void didNotQualify() throws StandardException;
0: 
0:     /**
0:     Returns true if the current position of the scan still qualifies
0:     under the set of qualifiers passed to the openScan().  When called
0:     this routine will reapply all qualifiers against the row currently
0:     positioned and return true if the row still qualifies.  If the row
0:     has been deleted or no longer passes the qualifiers then this routine
0:     will return false.
0:     
0:     This case can come about if the current scan
0:     or another scan on the same table in the same transaction 
0:     deleted the row or changed columns referenced by the qualifier after 
0:     the next() call which positioned the scan at this row.  
0: 
0:     Note that for comglomerates which don't support update, like btree's, 
0:     there is no need to recheck the qualifiers.
0: 
0:     The results of a fetch() performed on a scan positioned on 
0:     a deleted row are undefined, note that this can happen even if next()
0:     has returned true (for instance the client can delete the row, or if
0:     using read uncommitted another thread can delete the row after the
0:     next() call but before the fetch).
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     boolean doesCurrentPositionQualify()
0: 		throws StandardException;
0: 
0:     /**
0:     Fetch the (partial) row at the current position of the Scan.
0: 	The value in the destRow storable row is replaced
0: 	with the value of the row at the current scan
0: 	position.  The columns of the destRow row must
0: 	be of the same type as the actual columns in the
0: 	underlying conglomerate. The number of elements in
0: 	fetch must be compatible with the number of scan columns
0: 	requested at the openScan call time.
0: 	<BR>
0: 	A fetch can return a sub-set of the scan columns reqested
0: 	at scan open time by supplying a destRow will less elements
0: 	than the number of requested columns. In this case the N leftmost
0: 	of the requested columns are fetched, where N = destRow.length.
0: 	In the case where all columns are rested and N = 2 then columns 0 and 1
0: 	are returned. In the case where the openScan FormatableBitSet requested columns
0: 	1, 4 and 7, then columns 1 and 4 would be fetched when N = 2.
0: 	<BR>
0: 
0:     The results of a fetch() performed on a scan after next() has returned
0:     false are undefined.
0: 
0:     A fetch() performed on a scan positioned on 
0:     a deleted row will throw a StandardException with 
0:     state = SQLState.AM_RECORD_NOT_FOUND.  Note that this can happen even if 
0:     next() has returned true (for instance the client can delete the row, or if
0:     using read uncommitted another thread can delete the row after the
0:     next() call but before the fetch).
0: 
0:     @param destRow The row into which the value of the current 
0:     position in the scan is to be stored.
0: 
0: 	@exception StandardException Standard exception policy.
0: 	@see RowUtil
0:     **/
0:     void fetch(DataValueDescriptor[] destRow)
0: 		throws StandardException;
0: 
0:     /**
0:     Fetch the (partial) row at the next position of the Scan.
0: 
0:     If there is a valid next position in the scan then
0: 	the value in the destRow storable row is replaced
0: 	with the value of the row at the current scan
0: 	position.  The columns of the destRow row must
0: 	be of the same type as the actual columns in the
0: 	underlying conglomerate.
0: 
0:     The resulting contents of destRow after a fetchNext() 
0:     which returns false is undefined.
0: 
0:     The result of calling fetchNext(row) is exactly logically
0:     equivalent to making a next() call followed by a fetch(row)
0:     call.  This interface allows implementations to optimize 
0:     the 2 calls if possible.
0: 
0:     @param destRow The destRow row into which the value
0: 	of the next position in the scan is to be stored.
0: 
0:     @return True if there is a next position in the scan,
0: 	false if there isn't.
0: 
0: 	@exception StandardException Standard exception policy.
0: 	@see ScanController#fetch
0: 	@see RowUtil
0:     **/
0:     boolean fetchNext(DataValueDescriptor[] destRow)
0: 		throws StandardException;
0: 
0: 	/**
0: 	Fetch the location of the current position in the scan.
0: 	The destination location is replaced with the location
0: 	corresponding to the current position in the scan.
0: 	The destination location must be of the correct actual
0: 	type to accept a location from the underlying conglomerate
0: 	location.
0: 
0:     The results of a fetchLocation() performed on a scan after next() has 
0:     returned false are undefined.
0: 
0:     The results of a fetchLocation() performed on a scan positioned on 
0:     a deleted row are undefined, note that this can happen even if next()
0:     has returned true (for instance the client can delete the row, or if
0:     using read uncommitted another thread can delete the row after the
0:     next() call but before the fetchLocation).
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	void fetchLocation(RowLocation destRowLocation)
0: 		throws StandardException;
0: 
0:     /**
0:     Returns true if the current position of the scan is at a 
0:     deleted row.  This case can come about if the current scan
0:     or another scan on the same table in the same transaction 
0:     deleted the row after the next() call which positioned the
0:     scan at this row.  
0: 
0:     The results of a fetch() performed on a scan positioned on 
0:     a deleted row are undefined.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     boolean isCurrentPositionDeleted()
0: 		throws StandardException;
0: 
0:     /**
0:     Move to the next position in the scan.  If this is the first
0:     call to next(), the position is set to the first row.
0:     Returns false if there is not a next row to move to.
0:     It is possible, but not guaranteed, that this method could return 
0:     true again, after returning false, if some other operation in the same 
0:     transaction appended a row to the underlying conglomerate.
0: 
0:     @return True if there is a next position in the scan,
0: 	false if there isn't.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     boolean next()
0: 		throws StandardException;
0: 
0:     /**
0:     Replace the (partial) row at the current position of the scan.
0: 
0:     @return true if the replace was successful,
0: 	false if the current position is no longer valid (ie. if it was deleted).
0: 
0: 	@exception StandardException Standard exception policy.
0: 	@see RowUtil
0:     **/
0: 
0:     boolean replace(DataValueDescriptor[] row, FormatableBitSet validColumns)
0: 		throws StandardException;
0: }
============================================================================