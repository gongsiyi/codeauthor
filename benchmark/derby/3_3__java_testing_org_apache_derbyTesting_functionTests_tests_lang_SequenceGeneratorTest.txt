1:139ca85: /*
1:139ca85: 
1:139ca85:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SequenceGeneratorTest
1:139ca85: 
1:139ca85:    Licensed to the Apache Software Foundation (ASF) under one or more
1:139ca85:    contributor license agreements.  See the NOTICE file distributed with
1:139ca85:    this work for additional information regarding copyright ownership.
1:139ca85:    The ASF licenses this file to you under the Apache License, Version 2.0
1:139ca85:    (the "License"); you may not use this file except in compliance with
1:139ca85:    the License.  You may obtain a copy of the License at
1:139ca85: 
1:139ca85:      http://www.apache.org/licenses/LICENSE-2.0
1:139ca85: 
1:139ca85:    Unless required by applicable law or agreed to in writing, software
1:139ca85:    distributed under the License is distributed on an "AS IS" BASIS,
1:139ca85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:139ca85:    See the License for the specific language governing permissions and
1:139ca85:    limitations under the License.
1:139ca85: 
1:139ca85:  */
1:139ca85: 
1:139ca85: package org.apache.derbyTesting.functionTests.tests.lang;
1:139ca85: 
1:139ca85: import java.sql.Connection;
1:139ca85: import java.sql.PreparedStatement;
1:139ca85: import java.sql.ResultSet;
1:139ca85: import junit.framework.Test;
1:311ee54: import org.apache.derby.catalog.SequencePreallocator;
1:139ca85: import org.apache.derby.iapi.store.access.TransactionController;
1:139ca85: import org.apache.derby.iapi.types.SQLLongint;
1:139ca85: import org.apache.derby.impl.sql.catalog.SequenceGenerator;
1:311ee54: import org.apache.derby.impl.sql.catalog.SequenceRange;
1:139ca85: import org.apache.derby.impl.sql.catalog.SequenceUpdater;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:139ca85: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:139ca85: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:139ca85: import org.apache.derbyTesting.junit.TestConfiguration;
1:139ca85: 
1:139ca85: /**
1:139ca85:  * <p>
1:139ca85:  * Test sequence generators. See DERBY-712.
1:139ca85:  * </p>
1:139ca85:  */
1:139ca85: public class SequenceGeneratorTest  extends GeneratedColumnsHelper
1:139ca85: {
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // CONSTANTS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     // number of pre-allocated values in a sequence generator
1:810f2b9:     private static final long ALLOCATION_COUNT = 100L;
1:311ee54:     private static final int TWEAKED_ALLOCATION_COUNT = 7;
1:139ca85: 
1:139ca85:     private static  final   String      TEST_DBO = "TEST_DBO";
1:139ca85:     private static  final   String      RUTH = "RUTH";
1:139ca85:     private static  final   String      ALICE = "ALICE";
1:139ca85:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH  };
1:139ca85: 
1:311ee54:     private static  final   String      MISSING_ALLOCATOR = "X0Y85";
1:c077ea0:     private static  final   String      DUPLICATE_SEQUENCE = "X0Y68";
1:311ee54: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // STATE
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     private static boolean _fullDebug = false;
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // CONSTRUCTOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * Create a new instance.
1:139ca85:      */
1:139ca85: 
1:139ca85:     public SequenceGeneratorTest(String name)
1:139ca85:     {
1:139ca85:         super(name);
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // JUnit BEHAVIOR
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85: 
1:365a750:     /**
1:139ca85:      * Construct top level suite in this JUnit test
1:139ca85:      */
1:139ca85:     public static Test suite()
1:139ca85:     {
1:1ae02c9:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:1ae02c9:             SequenceGeneratorTest.class);
1:139ca85: 
1:139ca85:         Test        cleanTest = new CleanDatabaseTestSetup( suite );
1:8e352d6:         Test        timeoutTest = DatabasePropertyTestSetup.setLockTimeouts( cleanTest, 5, 5 );
1:139ca85:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:8e352d6:             ( timeoutTest, LEGAL_USERS, "sequenceGenerator" );
1:139ca85:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1:139ca85: 
1:139ca85:         return authorizedTest;
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // TESTS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:365a750:      * <p>
1:139ca85:      * Test basic incrementing and pre-allocating of sequence values on disk.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_01_basic() throws Exception
1:139ca85:     {
2:139ca85:         Connection  conn = openUserConnection( TEST_DBO );
1:139ca85: 
1:139ca85:         int initialValue = Integer.MIN_VALUE;
1:139ca85: 
1:139ca85:         goodStatement( conn, "create sequence seq_01\n" );
1:139ca85: 
1:139ca85:         assertEquals( (long) initialValue, getCurrentValue( TEST_DBO, "SEQ_01" ) );
1:139ca85: 
1:139ca85:         // first run is allocated
1:139ca85:         int seq_01_value = initialValue;
1:139ca85:         long seq_01_upperBound = seq_01_value + ALLOCATION_COUNT;
1:139ca85:         for ( int i = 0; i < ALLOCATION_COUNT; i++ )
1:139ca85:         {
1:139ca85:             vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1:139ca85:         }
1:139ca85: 
1:139ca85:         // another run is allocated
1:139ca85:         seq_01_upperBound += ALLOCATION_COUNT;
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1:139ca85: 
1:139ca85:         // DDL flushes the metadata cache
1:139ca85:         goodStatement( conn, "create sequence seq_01_a\n" );
1:139ca85: 
1:139ca85:         int seq_01_a_value = initialValue;
1:139ca85:         long seq_01_a_upperBound = seq_01_a_value + ALLOCATION_COUNT;
1:139ca85:         // check the other sequence
1:139ca85:         for ( int i = 0; i < 2; i++ )
1:139ca85:         {
1:139ca85:             vetBumping( conn, TEST_DBO, "SEQ_01_A", seq_01_a_value++, seq_01_a_upperBound );
1:139ca85:         }
1:139ca85: 
1:139ca85:         //
1:139ca85:         // The cache was flushed when seq_01_a was created. This
1:139ca85:         // restarts the generator for that sequence and allocates a new range.
1:139ca85:         //
1:139ca85:         seq_01_upperBound = seq_01_value + ALLOCATION_COUNT;
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1:139ca85:     }
1:139ca85:     private void vetBumping( Connection conn, String schemaName, String sequenceName, int expectedValue, long expectedValueOnDisk )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         PreparedStatement ps = chattyPrepare( conn, "values( next value for " + schemaName + '.' + sequenceName + " )\n" );
1:139ca85: 
1:139ca85:         assertEquals( expectedValue, getScalarInteger( ps ) );
1:139ca85:         assertEquals( expectedValueOnDisk, getCurrentValue( schemaName, sequenceName ) );
1:139ca85:     }
1:139ca85: 
1:c077ea0:     /**
1:c077ea0:      * <p>
1:139ca85:      * Test boundary conditions in sequence generators.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_02_boundary() throws Exception
1:139ca85:     {
1:139ca85:         T_SequenceUpdater updater;
1:139ca85: 
1:139ca85:         updater = new T_SequenceUpdater
1:39b3237:           ( (long)Integer.MIN_VALUE, true, 1L, (long) Integer.MAX_VALUE, (long) Integer.MIN_VALUE, (long) Integer.MIN_VALUE );
1:139ca85: 
1:139ca85:         assertEquals( -2147483648L, updater.getValueOnDisk().longValue() );
1:139ca85: 
1:365a750:         long        initialValue = (long) Integer.MIN_VALUE;
1:365a750:         long        expectedValueOnDisk = initialValue + ALLOCATION_COUNT;
1:365a750: 
1:365a750:         for ( long i = 0; i < ALLOCATION_COUNT; i++ )
1:365a750:         {
1:365a750:             vetBumping( updater, initialValue + i, expectedValueOnDisk );
1:365a750:         }
1:365a750:         expectedValueOnDisk += ALLOCATION_COUNT;
1:365a750: 
1:365a750:         vetBumping( updater, initialValue + ALLOCATION_COUNT, expectedValueOnDisk );
1:139ca85: 
1:139ca85:         vetBoundaries( Short.MAX_VALUE, Short.MIN_VALUE );
1:139ca85:         vetBoundaries( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:139ca85:         vetBoundaries( Long.MAX_VALUE, Long.MIN_VALUE );
1:139ca85: 
1:139ca85:         vetBoundaries( Short.MAX_VALUE/2, Short.MIN_VALUE/2 );
1:139ca85:         vetBoundaries( Integer.MAX_VALUE/2, Integer.MIN_VALUE/2 );
1:139ca85:         vetBoundaries( Long.MAX_VALUE/2, Long.MIN_VALUE/2 );
1:139ca85:     }
1:139ca85:     private void vetBoundaries
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:810f2b9:         vetBoundaries( maxValue, minValue, 1L );
1:810f2b9:         vetBoundaries( maxValue, minValue, ALLOCATION_COUNT );
1:810f2b9:         vetBoundaries( maxValue, minValue, 2 * ALLOCATION_COUNT );
1:810f2b9:     }
1:810f2b9:     private void vetBoundaries
1:810f2b9:         (
1:810f2b9:          long maxValue,
1:810f2b9:          long minValue,
1:810f2b9:          long stepSize
1:810f2b9:          )
1:810f2b9:         throws Exception
1:810f2b9:     {
1:810f2b9:         vetUpperBoundary( maxValue, minValue, stepSize );
1:810f2b9:         vetLowerBoundary( maxValue, minValue, stepSize );
1:139ca85:     }
1:139ca85:     private void vetUpperBoundary
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long stepSize
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         long restartValue = minValue;
1:139ca85:         long firstValue;
1:139ca85: 
1:139ca85:         long initValue = maxValue - (ALLOCATION_COUNT * stepSize);
1:810f2b9:         long finalValue = maxValue;
1:810f2b9:         long midpoint = (finalValue - initValue) / 2;
1:139ca85: 
1:810f2b9:         if ( initValue > 0 ) { vetBoundaries( maxValue, minValue, stepSize, initValue, restartValue ); }
1:810f2b9:         if ( midpoint > 0 ) { vetBoundaries( maxValue, minValue, stepSize, midpoint, restartValue ); }
1:810f2b9:         if ( finalValue > 0 ) { vetBoundaries( maxValue, minValue, stepSize, finalValue, restartValue ); }
1:139ca85:     }
1:139ca85:     private void vetLowerBoundary
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long stepSize
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         long restartValue = maxValue;
1:139ca85:         long firstValue;
1:139ca85: 
1:139ca85:         long initValue = minValue + (ALLOCATION_COUNT * stepSize);
1:810f2b9:         long finalValue = minValue;
1:810f2b9:         long midpoint = (finalValue - initValue) / 2;
1:139ca85: 
1:810f2b9:         if ( initValue < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, initValue, restartValue ); }
1:810f2b9:         if ( midpoint < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, midpoint, restartValue ); }
1:810f2b9:         if ( finalValue < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, finalValue, restartValue ); }
1:139ca85:     }
1:139ca85:     private void vetBoundaries
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long stepSize,
1:139ca85:          long firstValue,
1:139ca85:          long restartValue
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         long bumps = (2 * ALLOCATION_COUNT) + 1;
1:139ca85:         
1:139ca85:         vetBumping( firstValue, true, stepSize, maxValue, minValue, restartValue, bumps );
1:139ca85:         vetBumping( firstValue, false, stepSize, maxValue, minValue, restartValue, bumps );
1:139ca85:     }
1:139ca85:     private void vetBumping
1:139ca85:         (
1:139ca85:          long firstValue,
1:139ca85:          boolean canCycle,
1:139ca85:          long stepSize,
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long restartValue,
1:139ca85:          long bumps
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         if ( _fullDebug) { println( "stepSize = " + stepSize + " and firstValue = " + firstValue + " and canCycle = " + canCycle ); }
1:139ca85:         
1:139ca85:         SGVetter vetter = new SGVetter
1:39b3237:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:139ca85:         T_SequenceUpdater updater = new T_SequenceUpdater
1:39b3237:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue );
1:139ca85: 
1:139ca85:         if ( _fullDebug) { println( "" ); }
1:139ca85:         for ( long i = 0; i < bumps; i++ ) { vetBump( vetter, updater ); }
1:139ca85:     }
1:139ca85:     private void vetBump( SGVetter vetter, T_SequenceUpdater updater ) throws Exception
1:139ca85:     {
1:139ca85:         assertLongEquals( vetter.getUpperBound(), updater.getValueOnDisk() );
1:139ca85: 
1:139ca85:         Long vetterValue = vetter.getNextValue();
1:139ca85: 
1:139ca85:         if ( _fullDebug ) { println( "Expecting value = " + vetterValue + " and expecting ValueOnDisk = " + vetter.getUpperBound() ); }
1:139ca85:         
1:139ca85:         if ( vetterValue != null )
1:139ca85:         {
1:139ca85:             long updaterValue = updater.getCurrentValueAndAdvance();
1:139ca85: 
1:139ca85:             assertEquals( vetterValue.longValue(), updaterValue );
1:139ca85:         }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             try {
1:139ca85:                 updater.getCurrentValueAndAdvance();
1:139ca85:                 fail( "Expected to catch cycle exception." );
1:139ca85:             }
1:139ca85:             catch (Exception e)
1:139ca85:             {}
1:139ca85:         }
1:139ca85: 
1:139ca85:         assertLongEquals( vetter.getUpperBound(), updater.getValueOnDisk() );
1:139ca85:     }
1:139ca85:     private void assertLongEquals( Long left, Long right )
1:139ca85:     {
1:139ca85:         if ( left == null ) { assertNull( right ); }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             assertNotNull( right );
1:139ca85:             assertEquals( left.longValue(), right.longValue() );
1:139ca85:         }
1:139ca85:     }
1:139ca85:     
1:139ca85:     private void vetBumping( T_SequenceUpdater updater, long expectedValue, long expectedValueOnDisk )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         long actualValue = updater.getCurrentValueAndAdvance();
1:139ca85:         long actualValueOnDisk = updater.getValueOnDisk().longValue();
1:139ca85:         
1:139ca85:         println( "Expected value = " + expectedValue + " vs actual value = " + actualValue );
1:365a750:         println( "    Expected value on disk = " + expectedValueOnDisk + " vs actual value on disk = " + actualValueOnDisk );
1:139ca85:         
1:139ca85:         assertEquals( expectedValue, actualValue );
1:139ca85:         assertEquals( expectedValueOnDisk, actualValueOnDisk );
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Test non cycling sequence generators.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_03_nonCycling() throws Exception
1:139ca85:     {
1:139ca85:         vetNonCycling( Short.MAX_VALUE, Short.MIN_VALUE );
1:139ca85:         vetNonCycling( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:139ca85:         vetNonCycling( Long.MAX_VALUE, Long.MIN_VALUE );
1:139ca85:     }
1:139ca85:     private void vetNonCycling
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         vetNonCycling( maxValue, minValue, 1L );
1:139ca85:         vetNonCycling( maxValue, minValue, -1L );
1:139ca85:     }
1:139ca85:     private void vetNonCycling
1:139ca85:         (
1:139ca85:          long maxValue,
1:139ca85:          long minValue,
1:139ca85:          long stepSize
1:139ca85:          )
1:139ca85:         throws Exception
1:139ca85:     {
1:139ca85:         long bumps = 3;
1:139ca85:         long firstValue;
1:139ca85:         long restartValue;
1:139ca85: 
1:139ca85:         if ( stepSize > 0 )
1:139ca85:         {
1:139ca85:             firstValue = maxValue - bumps;
1:139ca85:             restartValue = minValue;
1:139ca85:         }
1:139ca85:         else
1:139ca85:         {
1:139ca85:             firstValue = minValue + bumps;
1:139ca85:             restartValue = maxValue;
1:139ca85:         }
1:139ca85: 
1:139ca85:         SGVetter vetter = new SGVetter
1:39b3237:             ( firstValue, false, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:139ca85:         T_SequenceUpdater updater = new T_SequenceUpdater
1:39b3237:             ( firstValue, false, stepSize, maxValue, minValue, restartValue );
1:139ca85: 
1:139ca85:         // make sure we can survive trying to bust the cycle more than once
1:139ca85:         long extraBumps = bumps + 2;
1:139ca85:         for ( long i = 0; i <= extraBumps; i++ )
1:139ca85:         {
1:139ca85:             vetBump( vetter, updater );
1:139ca85:         }
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Test that when you reboot the database, you pick up the sequence
1:139ca85:      * number on disk, not the last version in memory.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_04_reboot() throws Exception
1:139ca85:     {
1:139ca85:         Connection  conn = openUserConnection( TEST_DBO );
1:139ca85:         
1:139ca85:         int initialValue = Integer.MIN_VALUE;
1:139ca85: 
1:139ca85:         goodStatement( conn, "create sequence seq_04\n" );
1:139ca85: 
1:139ca85:         int seq_04_value = initialValue;
1:139ca85:         long seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:139ca85: 
1:139ca85:         getTestConfiguration().shutdownDatabase();
1:139ca85:         conn = openUserConnection( TEST_DBO );
1:139ca85:         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:139ca85: 
1:139ca85:         getTestConfiguration().shutdownDatabase();
1:139ca85:         conn = openUserConnection( TEST_DBO );
1:139ca85:         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:139ca85:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Test that multiple transactions can access the same sequence generator
1:139ca85:      * and not block.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_05_concurrency() throws Exception
1:139ca85:     {
1:139ca85:         Connection  conn = openUserConnection( TEST_DBO );
1:139ca85:         
1:139ca85:         int initialValue = Integer.MIN_VALUE;
1:139ca85: 
1:139ca85:         goodStatement( conn, "create sequence seq_05\n" );
1:139ca85:         goodStatement( conn, "grant usage on sequence seq_05 to public\n" );
1:139ca85: 
1:139ca85:         int seq_05_value = initialValue;
1:139ca85:         long seq_05_upperBound = seq_05_value;
1:139ca85: 
1:139ca85:         Connection  ruthConnection = openUserConnection( "RUTH" );
1:139ca85:         Connection  aliceConnection = openUserConnection( "ALICE" );
1:139ca85: 
1:139ca85:         ruthConnection.setAutoCommit( false );
1:139ca85:         aliceConnection.setAutoCommit( false );
1:139ca85: 
1:139ca85:         long loopCount = 2 * ALLOCATION_COUNT;
1:139ca85:         for ( long i = 0; i < loopCount; i++ )
1:139ca85:         {
1:139ca85:             Connection loopConn = ( i % 2 == 0 ) ? ruthConnection : aliceConnection;
1:139ca85: 
1:139ca85:             if ( (i % ALLOCATION_COUNT) == 0 ) { seq_05_upperBound += ALLOCATION_COUNT; }
1:139ca85: 
1:139ca85:             vetBumping( loopConn, TEST_DBO, "SEQ_05", seq_05_value++, seq_05_upperBound );
1:139ca85:         }
1:139ca85: 
1:139ca85:         ruthConnection.commit();
1:139ca85:         aliceConnection.commit();
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Test big step sizes.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_06_bigStepSize() throws Exception
1:139ca85:     {
1:139ca85:         T_SequenceUpdater updater;
1:139ca85:         long stepSize = (Long.MAX_VALUE / ALLOCATION_COUNT) * 3;
1:139ca85: 
1:139ca85:         updater = new T_SequenceUpdater
1:39b3237:             ( Long.MIN_VALUE, true, stepSize, (long) Long.MAX_VALUE, (long) Long.MIN_VALUE, (long) Long.MIN_VALUE );
1:139ca85: 
1:139ca85:         long nextValue = updater.getCurrentValueAndAdvance();
1:139ca85:         long currentValueOnDisk = updater.getValueOnDisk().longValue();
1:139ca85:         long rangeSize = currentValueOnDisk - nextValue;
1:139ca85: 
1:139ca85:         // allocation count truncated to 1 because the step size is so large
1:139ca85:         assertEquals( stepSize, rangeSize );
1:139ca85: 
1:139ca85:         vetBigStep( Short.MAX_VALUE, Short.MIN_VALUE );
1:139ca85:         vetBigStep( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:139ca85:         vetBigStep( Long.MAX_VALUE, Long.MIN_VALUE );
1:139ca85: 
1:139ca85:         vetBigStep( ALLOCATION_COUNT, 0L );
1:139ca85:     }
1:139ca85:     private void vetBigStep( long maxValue, long minValue )
1:139ca85:         throws Exception
1:139ca85:     {
1:39b3237:         Long firstValue = minValue;
1:139ca85:         long restartValue = minValue;
1:139ca85:         long stepSize = maxValue - 1;
1:139ca85:         boolean canCycle = true;
1:139ca85:         long truncatedAllocationCount = 1L;
1:139ca85:         
1:139ca85:         SGVetter vetter = new SGVetter
1:139ca85:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue, truncatedAllocationCount );           
1:139ca85:         T_SequenceUpdater updater = new T_SequenceUpdater
1:139ca85:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue );
1:139ca85: 
1:139ca85:         for ( long i = 0; i < ALLOCATION_COUNT; i++ )
1:139ca85:         {
1:139ca85:             vetBump( vetter, updater );
1:139ca85:         }
1:139ca85:     }
1:139ca85:     
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Test that cache flushing doesn't prevent us from dropping
1:139ca85:      * a sequence generator.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public void test_07_dropSequence() throws Exception
1:139ca85:     {
1:139ca85:         Connection  conn = getConnection();
1:139ca85: 
1:139ca85:         goodStatement( conn, "create sequence seq_07\n" );
1:139ca85:         
1:139ca85:         int initialValue = Integer.MIN_VALUE;
1:139ca85:         int seq_07_value = initialValue;
1:139ca85:         long seq_07_upperBound = seq_07_value + ALLOCATION_COUNT;
1:139ca85:         for ( int i = 0; i < ALLOCATION_COUNT; i++ )
1:139ca85:         {
1:139ca85:             vetBumping( conn, TEST_DBO, "SEQ_07", seq_07_value++, seq_07_upperBound );
1:139ca85:         }
1:139ca85: 
1:139ca85:         goodStatement( conn, "values( next value for seq_07 )\n" );
1:2f4a1a0:         goodStatement( conn, "drop sequence seq_07 restrict\n" );
1:139ca85:         
1:139ca85:         expectCompilationError( OBJECT_DOES_NOT_EXIST, "values ( next value for seq_07 )\n" );
1:139ca85:     }
1:139ca85:     
1:311ee54:     /**
1:311ee54:      * <p>
1:311ee54:      * Test user-written range allocators.
1:311ee54:      * </p>
1:311ee54:      */
1:311ee54:     public void test_08_userWrittenAllocators() throws Exception
1:311ee54:     {
1:311ee54:         Connection  conn = openUserConnection( TEST_DBO );
1:311ee54:         String  className;
1:311ee54: 
1:311ee54:         goodStatement( conn, "create sequence seq_08\n" );
1:311ee54: 
1:311ee54:         className = getClass().getName() + "$" + "UnknownClass";
1:311ee54:         goodStatement
1:311ee54:             (
1:311ee54:              conn,
1:311ee54:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:311ee54:              );
1:311ee54:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
1:311ee54: 
1:311ee54:         className = getClass().getName() + "$" + "BadAllocator";
1:311ee54:         goodStatement
1:311ee54:             (
1:311ee54:              conn,
1:311ee54:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:311ee54:              );
1:311ee54:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
1:311ee54: 
1:311ee54:         className = getClass().getName() + "$" + "LegalAllocator";
1:311ee54:         goodStatement
1:311ee54:             (
1:311ee54:              conn,
1:311ee54:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:311ee54:              );
1:311ee54:         vetBumping( conn, TEST_DBO, "SEQ_08", Integer.MIN_VALUE, Integer.MIN_VALUE + TWEAKED_ALLOCATION_COUNT );
1:311ee54: 
1:311ee54:         goodStatement
1:311ee54:             (
1:311ee54:              conn,
1:311ee54:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
1:311ee54:              );
1:311ee54:     }
1:311ee54:         
1:c8986df:     /**
1:c8986df:      * <p>
1:365a750:      * Test overriding the default length of sequence/identity ranges.
1:365a750:      * </p>
1:365a750:      */
1:365a750:     public void test_09_defaultRangeSize() throws Exception
1:365a750:     {
1:365a750:         Connection  conn = openUserConnection( TEST_DBO );
1:365a750:         long    number;
1:365a750: 
1:365a750:         goodStatement( conn, "create sequence seq_09_01\n" );
1:365a750:         number = 30L;
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:365a750:              );
1:365a750:         vetBumping( conn, TEST_DBO, "SEQ_09_01", Integer.MIN_VALUE, Integer.MIN_VALUE + number );
1:365a750: 
1:365a750:         // 0 results in the usual default
1:365a750:         goodStatement( conn, "create sequence seq_09_02\n" );
1:365a750:         number = 0L;
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:365a750:              );
1:365a750:         vetBumping( conn, TEST_DBO, "SEQ_09_02", Integer.MIN_VALUE, Integer.MIN_VALUE + ALLOCATION_COUNT );
1:365a750: 
1:365a750:         // negative numbers result in Missing Allocator exception
1:365a750:         goodStatement( conn, "create sequence seq_09_03\n" );
1:365a750:         number = -1L;
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:365a750:              );
1:365a750:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_03 )" );
1:365a750: 
1:365a750:         // If the value doesn't fit in an int, we also get a Missing Allocator exception
1:365a750:         goodStatement( conn, "create sequence seq_09_04\n" );
1:365a750:         number = Long.MAX_VALUE - 1L;
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:365a750:              );
1:365a750:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_04 )" );
1:365a750:         
1:365a750:         // out of range values will stifle preallocation
1:365a750:         goodStatement( conn, "create sequence seq_09_05 as smallint\n" );
1:365a750:         number = ((long) 3 * Short.MAX_VALUE);
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:365a750:              );
1:365a750:         vetBumping( conn, TEST_DBO, "SEQ_09_05", Short.MIN_VALUE, Short.MIN_VALUE + 1 );
1:365a750: 
1:365a750:         goodStatement
1:365a750:             (
1:365a750:              conn,
1:365a750:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
1:365a750:              );
1:365a750:     }
1:365a750:     
1:139ca85:     /**
1:139ca85:      * <p>
1:c8986df:      * Test that sequence values are not leaked during an orderly system shutdown.
1:c8986df:      * See DERBY-5398.
1:c8986df:      * </p>
1:c8986df:      */
1:c8986df:     public void test_10_5398() throws Exception
1:c8986df:     {
1:c8986df:         Connection  conn = openUserConnection( TEST_DBO );
1:c8986df: 
1:c8986df:         goodStatement( conn, "create sequence seq_10\n" );
1:c8986df: 
1:c8986df:         int seq_10_value = Integer.MIN_VALUE;
1:c8986df:         long seq_10_upperBound;
1:c8986df: 
1:c8986df:         seq_10_upperBound = seq_10_value + ALLOCATION_COUNT;
1:c8986df:         vetBumping( conn, TEST_DBO, "SEQ_10", seq_10_value++, seq_10_upperBound );
1:c8986df: 
1:c8986df:         // bring down the engine, then reboot the database
1:c8986df:         getTestConfiguration().shutdownEngine();
1:c8986df:         conn = openUserConnection( TEST_DBO );
1:c8986df: 
1:c8986df:         // verify that we did not leak any values
1:c8986df:         seq_10_upperBound = seq_10_value + ALLOCATION_COUNT;
1:c8986df:         vetBumping( conn, TEST_DBO, "SEQ_10", seq_10_value++, seq_10_upperBound );
1:c8986df:     }
1:c8986df: 
1:139ca85:     /**
1:139ca85:      * <p>
1:8e352d6:      * Test that sequence values don't repeat via transaction trickery. See DERBY-5493.
1:8e352d6:      * </p>
1:8e352d6:      */
1:8e352d6:     public void test_11_5493_correctness() throws Exception
1:8e352d6:     {
1:8e352d6:         Connection  conn = openUserConnection( TEST_DBO );
1:8e352d6: 
1:8e352d6:         goodStatement( conn, "create table t_5493 (x int)\n" );
1:8e352d6:         goodStatement( conn, "create sequence s_5493\n" );
1:8e352d6: 
1:8e352d6:         boolean oldAutoCommit = conn.getAutoCommit();
1:8e352d6:         conn.setAutoCommit( false );
1:8e352d6: 
1:8e352d6:         PreparedStatement   ps = chattyPrepare( conn, "select count(*) from sys.syssequences with rs\n" );
1:8e352d6:         getScalarInteger( ps );
1:8e352d6:         ps.close();
1:8e352d6: 
1:8e352d6:         int     expectedValue = -2147483648;
1:8e352d6:         expectExecutionError( conn, TOO_MUCH_CONTENTION, "values next value for s_5493" );
1:8e352d6: 
1:8e352d6:         goodStatement( conn, "drop table t_5493\n" );
1:8e352d6:         conn.rollback();
1:8e352d6: 
1:8e352d6:         ps = chattyPrepare( conn, "values next value for s_5493" );
1:8e352d6:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:8e352d6:         ps.close();
1:8e352d6: 
1:8e352d6:         goodStatement( conn, "drop sequence s_5493 restrict\n" );
1:8e352d6:         conn.commit();
1:8e352d6: 
1:8e352d6:         conn.setAutoCommit( oldAutoCommit );
1:8e352d6:     }
1:8e352d6: 
1:8e352d6:     /**
1:8e352d6:      * <p>
1:8e352d6:      * Verify the syscs_peek_at_sequence function introduced by DERBY-5493.
1:8e352d6:      * </p>
1:8e352d6:      */
1:8e352d6:     public void test_12_5493_function() throws Exception
1:8e352d6:     {
1:8e352d6:         Connection  dboConn = openUserConnection( TEST_DBO );
1:8e352d6:         Connection  ruthConn = openUserConnection( "RUTH" );
1:8e352d6:         PreparedStatement   ps;
1:8e352d6:         int                 expectedValue;
1:8e352d6: 
1:8e352d6:         goodStatement( dboConn, "create sequence s_5493\n" );
1:8e352d6:         goodStatement( dboConn, "grant usage on sequence s_5493 to public\n" );
1:8e352d6: 
1:8e352d6:         expectedValue = -2147483648;
1:8e352d6:         ps = chattyPrepare( dboConn, "values next value for s_5493" );
1:8e352d6:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:8e352d6:         ps.close();
1:8e352d6: 
1:8e352d6:         // test the syscs_peek_at_sequence() function
1:8e352d6:         ps = chattyPrepare
1:8e352d6:             (
1:8e352d6:              dboConn,
1:8e352d6:              "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n"
1:8e352d6:              );
1:8e352d6:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:8e352d6:         ps.close();
1:8e352d6: 
1:8e352d6:         // error if sequence doesn't exist
1:8e352d6:         expectExecutionError
1:8e352d6:             ( dboConn, MISSING_OBJECT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493_1' )\n" );
1:8e352d6: 
1:8e352d6:         // drop the sequence but don't commit
1:8e352d6: 
1:8e352d6:         dboConn.setAutoCommit( false );
1:8e352d6:         goodStatement( dboConn, "drop sequence s_5493 restrict\n" );
1:8e352d6:         
1:8e352d6:         expectExecutionError( dboConn, MISSING_OBJECT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n" );
1:8e352d6:         expectCompilationError( dboConn, OBJECT_DOES_NOT_EXIST, "values next value for s_5493" );
1:8e352d6: 
1:8e352d6:         expectExecutionError( ruthConn, LOCK_TIMEOUT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n" );
1:8e352d6:         expectCompilationError( ruthConn, LOCK_TIMEOUT, "values next value for " + TEST_DBO + ".s_5493" );
1:8e352d6: 
1:8e352d6:         dboConn.commit();
1:8e352d6:         dboConn.setAutoCommit( true );
1:8e352d6:     }
1:8e352d6: 
1:8e352d6:     /**
1:8e352d6:      * <p>
1:5705f5b:      * Verify that system crash does not rollback changes to SYSSEQUENCES.CURRENTVALUE.
1:5705f5b:      * See DERBY-5494.
1:5705f5b:      * </p>
1:5705f5b:      */
1:5705f5b:     public void test_13_5494() throws Exception
1:139ca85:     {
1:5705f5b:         String  dbName = "DB_5494";
1:139ca85:         
1:5705f5b:         // create a sequence and get the first value from it, then crash
1:5705f5b:         assertLaunchedJUnitTestMethod( getClass().getName() + ".preCrashActions", dbName );
1:139ca85: 
1:5705f5b:         // now check that the sequence state was correctly recovered
1:5705f5b:         assertLaunchedJUnitTestMethod( getClass().getName() + ".postCrashActions", dbName );
1:139ca85:     }
1:5705f5b:     // actions to perform just before a crash
1:5705f5b:     public void    preCrashActions()   throws Exception
1:139ca85:     {
1:5705f5b:         Connection  dboConn = openUserConnection( TEST_DBO );
1:5705f5b:         Connection  ruthConn = openUserConnection( "RUTH" );
1:5705f5b:         int initialValue = Integer.MIN_VALUE;
1:139ca85: 
1:5705f5b:         goodStatement( dboConn, "create sequence s_5494\n" );
1:139ca85:         
1:5705f5b:         assertNextValue( dboConn, TEST_DBO, "S_5494", initialValue );
1:139ca85: 
1:5705f5b:         assertEquals( (long) (initialValue + ALLOCATION_COUNT), getCurrentValue( ruthConn, TEST_DBO, "S_5494" ) );
1:139ca85:     }
1:5705f5b:     // actions to perform after the crash
1:5705f5b:     public void    postCrashActions()   throws Exception
1:139ca85:     {
1:5705f5b:         int initialValue = (int) (Integer.MIN_VALUE + ALLOCATION_COUNT);
1:139ca85:         
1:5705f5b:         // now verify that, after the crash, SYSSEQUENCES has still been advanced
1:5705f5b:         Connection  dboConn = openUserConnection( TEST_DBO );
1:5705f5b:         assertEquals( (long) initialValue, getCurrentValue( dboConn, TEST_DBO, "S_5494" ) );
1:1ae02c9: 
1:5705f5b:         assertNextValue( dboConn, TEST_DBO, "S_5494", initialValue );
8:5705f5b: 
1:5705f5b:         goodStatement( dboConn, "drop sequence s_5494 restrict\n" );
1:139ca85:     }
1:5705f5b:     private void    assertNextValue( Connection conn, String schema, String sequenceName, int expectedValue )
1:5705f5b:         throws Exception
3:5705f5b:     {
1:5705f5b:         PreparedStatement ps = chattyPrepare( conn, "values( next value for " + schema + "." + sequenceName + " )\n" );
1:5705f5b: 
1:5705f5b:         assertEquals( expectedValue, getScalarInteger( ps ) );
3:5705f5b:     }
1:5705f5b:     
1:5705f5b:     /**
1:5705f5b:      * <p>
1:c077ea0:      * Verify that we don't get an internal error when creating a sequence-invoking trigger.
1:c077ea0:      * See DERBY-6553.
1:c077ea0:      * </p>
1:c077ea0:      */
1:c077ea0:     public void test_14_6553() throws Exception
1:c077ea0:     {
1:c077ea0:         Connection  dboConn = openUserConnection( TEST_DBO );
1:c077ea0: 
1:c077ea0:         //
1:c077ea0:         // The original DERBY-6553 test case.
1:c077ea0:         //
1:c077ea0:         goodStatement( dboConn, "create table t1_6553_1(x int, y int, z int)" );
1:c077ea0:         goodStatement( dboConn, "create table t2_6553_1(x int, y int, z int)" );
1:c077ea0:         goodStatement( dboConn, "create sequence seq_6553_1" );
1:c077ea0:         goodStatement( dboConn, "values next value for seq_6553_1" );
1:c077ea0:         goodStatement
1:c077ea0:             ( dboConn, "create trigger tr1 after insert on t1_6553_1 insert into t2_6553_1(x) values (next value for seq_6553_1)" );
1:c077ea0: 
1:c077ea0:         //
1:c077ea0:         // The abbreviated test case.
1:c077ea0:         //
1:c077ea0:         dboConn.setAutoCommit( false );
1:c077ea0:         goodStatement( dboConn, "create sequence seq_6553" );
1:c077ea0:         dboConn.commit();
1:c077ea0:         goodStatement( dboConn, "values next value for seq_6553" );
1:c077ea0:         expectExecutionError( dboConn, DUPLICATE_SEQUENCE, "create sequence seq_6553" );
1:c077ea0:         dboConn.rollback();
1:c077ea0:         dboConn.setAutoCommit( true );
1:c077ea0:     }
1:c077ea0:     
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:139ca85:     // MINIONS
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /** Get the current value from a sequence */
1:139ca85:     private long getCurrentValue( String schemaName, String sequenceName )
1:139ca85:         throws Exception
1:139ca85:     {
1:8e352d6:         return getCurrentValue( openUserConnection( TEST_DBO ), schemaName, sequenceName );
1:5705f5b:     }
1:8e352d6:     
1:5705f5b:     /** Get the current value from a sequence */
1:8e352d6:     private long getCurrentValue( Connection conn, String schemaName, String sequenceName )
1:5705f5b:         throws Exception
1:5705f5b:     {
1:139ca85:         PreparedStatement ps = chattyPrepare
1:139ca85:             ( conn,
1:139ca85:               "select currentvalue from sys.syssequences seq, sys.sysschemas s where s.schemaname = ? and seq.sequencename = ? and s.schemaid = seq.schemaid" );
1:139ca85:         ps.setString( 1, schemaName );
1:139ca85:         ps.setString( 2, sequenceName );
1:139ca85: 
1:139ca85:         long retval = getScalarLong( ps );
1:139ca85: 
1:139ca85:         conn.commit();
1:139ca85:         
1:139ca85:         return retval;
1:139ca85:     }
1:8e352d6: 
1:139ca85:     /** Get a scalar integer result from a query */
1:139ca85:     private int getScalarInteger( PreparedStatement ps ) throws Exception
1:139ca85:     {
1:139ca85:         ResultSet rs = ps.executeQuery();
1:139ca85:         rs.next();
1:139ca85:         int retval = rs.getInt( 1 );
1:139ca85: 
1:139ca85:         rs.close();
1:139ca85:         ps.close();
1:139ca85: 
1:139ca85:         return retval;
1:139ca85:     }
1:139ca85: 
1:139ca85:     /** Get a scalar long result from a query */
1:139ca85:     private long getScalarLong( PreparedStatement ps ) throws Exception
1:139ca85:     {
1:139ca85:         ResultSet rs = ps.executeQuery();
1:139ca85:         rs.next();
1:139ca85:         long retval = rs.getLong( 1 );
1:139ca85: 
1:139ca85:         rs.close();
1:139ca85:         ps.close();
1:139ca85: 
1:139ca85:         return retval;
1:139ca85:     }
1:139ca85: 
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85:     //
1:311ee54:     // NESTED CLASSES
1:139ca85:     //
1:139ca85:     ///////////////////////////////////////////////////////////////////////////////////
1:139ca85: 
1:139ca85:     /**
1:139ca85:      * <p>
1:139ca85:      * Machine for testing sequence generators standalone.
1:139ca85:      * </p>
1:139ca85:      */
1:139ca85:     public static final class T_SequenceUpdater extends SequenceUpdater
1:139ca85:     {
1:139ca85:         private Long _valueOnDisk;
1:139ca85:         
1:139ca85:         public T_SequenceUpdater
1:139ca85:             (
1:139ca85:              Long currentValue,
1:139ca85:              boolean canCycle,
1:139ca85:              long increment,
1:139ca85:              long maxValue,
1:139ca85:              long minValue,
1:139ca85:              long restartValue
1:139ca85:              )
1:139ca85:         {
1:139ca85:             _valueOnDisk = currentValue;
1:139ca85:             
1:139ca85:             _sequenceGenerator = new SequenceGenerator
1:139ca85:                 (
1:139ca85:                  currentValue,
1:139ca85:                  canCycle,
1:139ca85:                  increment,
1:139ca85:                  maxValue,
1:139ca85:                  minValue,
1:139ca85:                  restartValue,
1:311ee54:                  "DUMMY_SCHEMA",
1:311ee54:                  "DUMMY_SEQUENCE",
1:311ee54:                  new SequenceRange()
1:139ca85:                  );
1:139ca85:         }
1:139ca85:         
1:139ca85:         public Long getValueOnDisk() { return _valueOnDisk; }
1:139ca85:         
1:139ca85:         public long getCurrentValueAndAdvance() throws Exception
1:139ca85:         {
1:139ca85:             SQLLongint nextValue = new SQLLongint();
1:139ca85:             
1:139ca85:             getCurrentValueAndAdvance( nextValue );
1:139ca85:             
1:139ca85:             return nextValue.getLong();
1:139ca85:         }
1:139ca85:         
1:139ca85:         // SequenceUpdater BEHAVIOR
1:139ca85:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC ) { return _sequenceGenerator; }
1:139ca85:         
1:139ca85:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait )
1:139ca85:         {
1:139ca85:             _valueOnDisk = newValue;
1:139ca85: 
1:139ca85:             return true;
1:139ca85:         }
1:139ca85:         
1:139ca85:         // override so the tests don't get a null pointer exception looking up the lcc
1:139ca85:         public boolean updateCurrentValueOnDisk( Long oldValue, Long newValue )
1:139ca85:         {
1:139ca85:             return updateCurrentValueOnDisk( null, oldValue, newValue, false );
1:139ca85:         }
1:39c6ffc:     
1:139ca85:     }
1:39c6ffc: 
1:311ee54:     // Illegal preallocator, which does not implement the correct interface
1:311ee54:     public  static  final   class   BadAllocator {}
1:311ee54: 
1:311ee54:     // Legal preallocator, which preallocates a fixed size range
1:311ee54:     public  static final   class   LegalAllocator  implements  SequencePreallocator
1:311ee54:     {
1:311ee54:         public  LegalAllocator() {}
1:311ee54:         
1:311ee54:         public  int nextRangeSize( String s, String n ) { return TWEAKED_ALLOCATION_COUNT; }
1:311ee54:     }
1:311ee54: 
1:139ca85: }
1:139ca85: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:           ( (long)Integer.MIN_VALUE, true, 1L, (long) Integer.MAX_VALUE, (long) Integer.MIN_VALUE, (long) Integer.MIN_VALUE );
/////////////////////////////////////////////////////////////////////////
1:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue );
/////////////////////////////////////////////////////////////////////////
1:             ( firstValue, false, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:             ( firstValue, false, stepSize, maxValue, minValue, restartValue );
/////////////////////////////////////////////////////////////////////////
1:             ( Long.MIN_VALUE, true, stepSize, (long) Long.MAX_VALUE, (long) Long.MIN_VALUE, (long) Long.MIN_VALUE );
/////////////////////////////////////////////////////////////////////////
1:         Long firstValue = minValue;
commit:c077ea0
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      DUPLICATE_SEQUENCE = "X0Y68";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that we don't get an internal error when creating a sequence-invoking trigger.
1:      * See DERBY-6553.
1:      * </p>
1:      */
1:     public void test_14_6553() throws Exception
1:     {
1:         Connection  dboConn = openUserConnection( TEST_DBO );
1: 
1:         //
1:         // The original DERBY-6553 test case.
1:         //
1:         goodStatement( dboConn, "create table t1_6553_1(x int, y int, z int)" );
1:         goodStatement( dboConn, "create table t2_6553_1(x int, y int, z int)" );
1:         goodStatement( dboConn, "create sequence seq_6553_1" );
1:         goodStatement( dboConn, "values next value for seq_6553_1" );
1:         goodStatement
1:             ( dboConn, "create trigger tr1 after insert on t1_6553_1 insert into t2_6553_1(x) values (next value for seq_6553_1)" );
1: 
1:         //
1:         // The abbreviated test case.
1:         //
1:         dboConn.setAutoCommit( false );
1:         goodStatement( dboConn, "create sequence seq_6553" );
1:         dboConn.commit();
1:         goodStatement( dboConn, "values next value for seq_6553" );
1:         expectExecutionError( dboConn, DUPLICATE_SEQUENCE, "create sequence seq_6553" );
1:         dboConn.rollback();
1:         dboConn.setAutoCommit( true );
1:     }
1:     
commit:810f2b9
/////////////////////////////////////////////////////////////////////////
1:     private static final long ALLOCATION_COUNT = 100L;
/////////////////////////////////////////////////////////////////////////
1:         vetBoundaries( maxValue, minValue, 1L );
1:         vetBoundaries( maxValue, minValue, ALLOCATION_COUNT );
1:         vetBoundaries( maxValue, minValue, 2 * ALLOCATION_COUNT );
1:     }
1:     private void vetBoundaries
1:         (
1:          long maxValue,
1:          long minValue,
1:          long stepSize
1:          )
1:         throws Exception
1:     {
1:         vetUpperBoundary( maxValue, minValue, stepSize );
1:         vetLowerBoundary( maxValue, minValue, stepSize );
/////////////////////////////////////////////////////////////////////////
1:         long finalValue = maxValue;
1:         long midpoint = (finalValue - initValue) / 2;
1:         if ( initValue > 0 ) { vetBoundaries( maxValue, minValue, stepSize, initValue, restartValue ); }
1:         if ( midpoint > 0 ) { vetBoundaries( maxValue, minValue, stepSize, midpoint, restartValue ); }
1:         if ( finalValue > 0 ) { vetBoundaries( maxValue, minValue, stepSize, finalValue, restartValue ); }
/////////////////////////////////////////////////////////////////////////
1:         long finalValue = minValue;
1:         long midpoint = (finalValue - initValue) / 2;
1:         if ( initValue < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, initValue, restartValue ); }
1:         if ( midpoint < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, midpoint, restartValue ); }
1:         if ( finalValue < 0 ) { vetBoundaries( maxValue, minValue, -stepSize, finalValue, restartValue ); }
commit:8e352d6
/////////////////////////////////////////////////////////////////////////
1:         Test        timeoutTest = DatabasePropertyTestSetup.setLockTimeouts( cleanTest, 5, 5 );
1:             ( timeoutTest, LEGAL_USERS, "sequenceGenerator" );
/////////////////////////////////////////////////////////////////////////
1:      * Test that sequence values don't repeat via transaction trickery. See DERBY-5493.
1:      * </p>
1:      */
1:     public void test_11_5493_correctness() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1: 
1:         goodStatement( conn, "create table t_5493 (x int)\n" );
1:         goodStatement( conn, "create sequence s_5493\n" );
1: 
1:         boolean oldAutoCommit = conn.getAutoCommit();
1:         conn.setAutoCommit( false );
1: 
1:         PreparedStatement   ps = chattyPrepare( conn, "select count(*) from sys.syssequences with rs\n" );
1:         getScalarInteger( ps );
1:         ps.close();
1: 
1:         int     expectedValue = -2147483648;
1:         expectExecutionError( conn, TOO_MUCH_CONTENTION, "values next value for s_5493" );
1: 
1:         goodStatement( conn, "drop table t_5493\n" );
1:         conn.rollback();
1: 
1:         ps = chattyPrepare( conn, "values next value for s_5493" );
1:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:         ps.close();
1: 
1:         goodStatement( conn, "drop sequence s_5493 restrict\n" );
1:         conn.commit();
1: 
1:         conn.setAutoCommit( oldAutoCommit );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Verify the syscs_peek_at_sequence function introduced by DERBY-5493.
1:      * </p>
1:      */
1:     public void test_12_5493_function() throws Exception
1:     {
1:         Connection  dboConn = openUserConnection( TEST_DBO );
1:         Connection  ruthConn = openUserConnection( "RUTH" );
1:         PreparedStatement   ps;
1:         int                 expectedValue;
1: 
1:         goodStatement( dboConn, "create sequence s_5493\n" );
1:         goodStatement( dboConn, "grant usage on sequence s_5493 to public\n" );
1: 
1:         expectedValue = -2147483648;
1:         ps = chattyPrepare( dboConn, "values next value for s_5493" );
1:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:         ps.close();
1: 
1:         // test the syscs_peek_at_sequence() function
1:         ps = chattyPrepare
1:             (
1:              dboConn,
1:              "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n"
1:              );
1:         assertEquals( expectedValue++, getScalarInteger( ps ) );
1:         ps.close();
1: 
1:         // error if sequence doesn't exist
1:         expectExecutionError
1:             ( dboConn, MISSING_OBJECT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493_1' )\n" );
1: 
1:         // drop the sequence but don't commit
1: 
1:         dboConn.setAutoCommit( false );
1:         goodStatement( dboConn, "drop sequence s_5493 restrict\n" );
1:         
1:         expectExecutionError( dboConn, MISSING_OBJECT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n" );
1:         expectCompilationError( dboConn, OBJECT_DOES_NOT_EXIST, "values next value for s_5493" );
1: 
1:         expectExecutionError( ruthConn, LOCK_TIMEOUT, "values syscs_util.syscs_peek_at_sequence( '" + TEST_DBO + "', 'S_5493' )\n" );
1:         expectCompilationError( ruthConn, LOCK_TIMEOUT, "values next value for " + TEST_DBO + ".s_5493" );
1: 
1:         dboConn.commit();
1:         dboConn.setAutoCommit( true );
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:         return getCurrentValue( openUserConnection( TEST_DBO ), schemaName, sequenceName );
1:     
1:     private long getCurrentValue( Connection conn, String schemaName, String sequenceName )
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
commit:c8986df
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test that sequence values are not leaked during an orderly system shutdown.
1:      * See DERBY-5398.
1:      * </p>
1:      */
1:     public void test_10_5398() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1: 
1:         goodStatement( conn, "create sequence seq_10\n" );
1: 
1:         int seq_10_value = Integer.MIN_VALUE;
1:         long seq_10_upperBound;
1: 
1:         seq_10_upperBound = seq_10_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_10", seq_10_value++, seq_10_upperBound );
1: 
1:         // bring down the engine, then reboot the database
1:         getTestConfiguration().shutdownEngine();
1:         conn = openUserConnection( TEST_DBO );
1: 
1:         // verify that we did not leak any values
1:         seq_10_upperBound = seq_10_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_10", seq_10_value++, seq_10_upperBound );
1:     }
1:     
commit:365a750
/////////////////////////////////////////////////////////////////////////
0:     private static final long ALLOCATION_COUNT = 20L;
/////////////////////////////////////////////////////////////////////////
1:         long        initialValue = (long) Integer.MIN_VALUE;
1:         long        expectedValueOnDisk = initialValue + ALLOCATION_COUNT;
1: 
1:         for ( long i = 0; i < ALLOCATION_COUNT; i++ )
1:         {
1:             vetBumping( updater, initialValue + i, expectedValueOnDisk );
1:         }
1:         expectedValueOnDisk += ALLOCATION_COUNT;
1: 
1:         vetBumping( updater, initialValue + ALLOCATION_COUNT, expectedValueOnDisk );
/////////////////////////////////////////////////////////////////////////
1:         println( "    Expected value on disk = " + expectedValueOnDisk + " vs actual value on disk = " + actualValueOnDisk );
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test overriding the default length of sequence/identity ranges.
1:      * </p>
1:      */
1:     public void test_09_defaultRangeSize() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1:         long    number;
1: 
1:         goodStatement( conn, "create sequence seq_09_01\n" );
1:         number = 30L;
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:              );
1:         vetBumping( conn, TEST_DBO, "SEQ_09_01", Integer.MIN_VALUE, Integer.MIN_VALUE + number );
1: 
1:         // 0 results in the usual default
1:         goodStatement( conn, "create sequence seq_09_02\n" );
1:         number = 0L;
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:              );
1:         vetBumping( conn, TEST_DBO, "SEQ_09_02", Integer.MIN_VALUE, Integer.MIN_VALUE + ALLOCATION_COUNT );
1: 
1:         // negative numbers result in Missing Allocator exception
1:         goodStatement( conn, "create sequence seq_09_03\n" );
1:         number = -1L;
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:              );
1:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_03 )" );
1: 
1:         // If the value doesn't fit in an int, we also get a Missing Allocator exception
1:         goodStatement( conn, "create sequence seq_09_04\n" );
1:         number = Long.MAX_VALUE - 1L;
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:              );
1:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_04 )" );
1:         
1:         // out of range values will stifle preallocation
1:         goodStatement( conn, "create sequence seq_09_05 as smallint\n" );
1:         number = ((long) 3 * Short.MAX_VALUE);
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
1:              );
1:         vetBumping( conn, TEST_DBO, "SEQ_09_05", Short.MIN_VALUE, Short.MIN_VALUE + 1 );
1: 
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
1:              );
1:     }
1:     
commit:311ee54
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.catalog.SequenceRange;
1: import org.apache.derby.catalog.SequencePreallocator;
/////////////////////////////////////////////////////////////////////////
1:     private static final int TWEAKED_ALLOCATION_COUNT = 7;
1:     private static  final   String      MISSING_ALLOCATOR = "X0Y85";
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Test user-written range allocators.
1:      * </p>
1:      */
1:     public void test_08_userWrittenAllocators() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1:         String  className;
1: 
1:         goodStatement( conn, "create sequence seq_08\n" );
1: 
1:         className = getClass().getName() + "$" + "UnknownClass";
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:              );
1:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
1: 
1:         className = getClass().getName() + "$" + "BadAllocator";
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:              );
1:         expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
1: 
1:         className = getClass().getName() + "$" + "LegalAllocator";
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
1:              );
1:         vetBumping( conn, TEST_DBO, "SEQ_08", Integer.MIN_VALUE, Integer.MIN_VALUE + TWEAKED_ALLOCATION_COUNT );
1: 
1:         goodStatement
1:             (
1:              conn,
1:              "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
1:              );
1:     }
1:         
/////////////////////////////////////////////////////////////////////////
1:     // NESTED CLASSES
/////////////////////////////////////////////////////////////////////////
1:                  "DUMMY_SCHEMA",
1:                  "DUMMY_SEQUENCE",
1:                  new SequenceRange()
/////////////////////////////////////////////////////////////////////////
1:     // Illegal preallocator, which does not implement the correct interface
1:     public  static  final   class   BadAllocator {}
1: 
1:     // Legal preallocator, which preallocates a fixed size range
1:     public  static final   class   LegalAllocator  implements  SequencePreallocator
1:     {
1:         public  LegalAllocator() {}
1:         
1:         public  int nextRangeSize( String s, String n ) { return TWEAKED_ALLOCATION_COUNT; }
1:     }
1: 
commit:b023843
/////////////////////////////////////////////////////////////////////////
commit:39c6ffc
/////////////////////////////////////////////////////////////////////////
1:         
0:         // overridden to avoid a null pointer exception when we don't have a language context
0:         protected int getLockTimeout() { return 1000; }
1:     
commit:2f4a1a0
/////////////////////////////////////////////////////////////////////////
1:         goodStatement( conn, "drop sequence seq_07 restrict\n" );
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SequenceGeneratorTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.math.BigDecimal;
0: import java.lang.reflect.Constructor;
0: import java.lang.reflect.Method;
1: import java.sql.Connection;
0: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.Timestamp;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
1: import org.apache.derby.impl.sql.catalog.SequenceGenerator;
1: import org.apache.derby.impl.sql.catalog.SequenceUpdater;
1: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: /**
1:  * <p>
1:  * Test sequence generators. See DERBY-712.
1:  * </p>
1:  */
1: public class SequenceGeneratorTest  extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     // number of pre-allocated values in a sequence generator
0:     private static final long ALLOCATION_COUNT = 5L;
1: 
1:     private static  final   String      TEST_DBO = "TEST_DBO";
1:     private static  final   String      RUTH = "RUTH";
1:     private static  final   String      ALICE = "ALICE";
1:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH  };
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static boolean _fullDebug = false;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public SequenceGeneratorTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(SequenceGeneratorTest.class);
1:         Test        cleanTest = new CleanDatabaseTestSetup( suite );
1:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
0:             ( cleanTest, LEGAL_USERS, "sequenceGenerator" );
1:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1: 
1:         return authorizedTest;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Test basic incrementing and pre-allocating of sequence values on disk.
1:      * </p>
1:      */
1:     public void test_01_basic() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1: 
1:         int initialValue = Integer.MIN_VALUE;
1: 
1:         goodStatement( conn, "create sequence seq_01\n" );
1: 
1:         assertEquals( (long) initialValue, getCurrentValue( TEST_DBO, "SEQ_01" ) );
1: 
1:         // first run is allocated
1:         int seq_01_value = initialValue;
1:         long seq_01_upperBound = seq_01_value + ALLOCATION_COUNT;
1:         for ( int i = 0; i < ALLOCATION_COUNT; i++ )
1:         {
1:             vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1:         }
1: 
1:         // another run is allocated
1:         seq_01_upperBound += ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1: 
1:         // DDL flushes the metadata cache
1:         goodStatement( conn, "create sequence seq_01_a\n" );
1: 
1:         int seq_01_a_value = initialValue;
1:         long seq_01_a_upperBound = seq_01_a_value + ALLOCATION_COUNT;
1:         // check the other sequence
1:         for ( int i = 0; i < 2; i++ )
1:         {
1:             vetBumping( conn, TEST_DBO, "SEQ_01_A", seq_01_a_value++, seq_01_a_upperBound );
1:         }
1: 
1:         //
1:         // The cache was flushed when seq_01_a was created. This
1:         // restarts the generator for that sequence and allocates a new range.
1:         //
1:         seq_01_upperBound = seq_01_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_01", seq_01_value++, seq_01_upperBound );
1:     }
1:     private void vetBumping( Connection conn, String schemaName, String sequenceName, int expectedValue, long expectedValueOnDisk )
1:         throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "values( next value for " + schemaName + '.' + sequenceName + " )\n" );
1: 
1:         assertEquals( expectedValue, getScalarInteger( ps ) );
1:         assertEquals( expectedValueOnDisk, getCurrentValue( schemaName, sequenceName ) );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Test boundary conditions in sequence generators.
1:      * </p>
1:      */
1:     public void test_02_boundary() throws Exception
1:     {
1:         T_SequenceUpdater updater;
1: 
1:         updater = new T_SequenceUpdater
0:             ( new Long(  Integer.MIN_VALUE ), true, 1L, (long) Integer.MAX_VALUE, (long) Integer.MIN_VALUE, (long) Integer.MIN_VALUE );
1: 
1:         assertEquals( -2147483648L, updater.getValueOnDisk().longValue() );
1: 
0:         vetBumping( updater, -2147483648L, -2147483643L );
0:         vetBumping( updater, -2147483647L, -2147483643L );
0:         vetBumping( updater, -2147483646L, -2147483643L );
0:         vetBumping( updater, -2147483645L, -2147483643L );
0:         vetBumping( updater, -2147483644L, -2147483643L );
0:         vetBumping( updater, -2147483643L, -2147483638L );
1: 
1:         vetBoundaries( Short.MAX_VALUE, Short.MIN_VALUE );
1:         vetBoundaries( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:         vetBoundaries( Long.MAX_VALUE, Long.MIN_VALUE );
1: 
1:         vetBoundaries( Short.MAX_VALUE/2, Short.MIN_VALUE/2 );
1:         vetBoundaries( Integer.MAX_VALUE/2, Integer.MIN_VALUE/2 );
1:         vetBoundaries( Long.MAX_VALUE/2, Long.MIN_VALUE/2 );
1:     }
1:     private void vetBoundaries
1:         (
1:          long maxValue,
1:          long minValue
1:          )
1:         throws Exception
1:     {
0:         long biggestStep = 2 * ALLOCATION_COUNT;
1:         
0:         for ( long i = 1L; i <= biggestStep; i++ )
1:         {
0:             vetUpperBoundary( maxValue, minValue, i );
0:             vetLowerBoundary( maxValue, minValue, i );
1:         }
1:     }
1:     private void vetUpperBoundary
1:         (
1:          long maxValue,
1:          long minValue,
1:          long stepSize
1:          )
1:         throws Exception
1:     {
1:         long restartValue = minValue;
1:         long firstValue;
1: 
1:         long initValue = maxValue - (ALLOCATION_COUNT * stepSize);
1: 
0:         for ( long i = initValue; (i > 0) && (i <= maxValue); i++ )
1:         {
0:             firstValue = i;
0:             vetBoundaries( maxValue, minValue, stepSize, firstValue, restartValue );
1:         }
1:     }
1:     private void vetLowerBoundary
1:         (
1:          long maxValue,
1:          long minValue,
1:          long stepSize
1:          )
1:         throws Exception
1:     {
1:         long restartValue = maxValue;
1:         long firstValue;
1: 
1:         long initValue = minValue + (ALLOCATION_COUNT * stepSize);
1: 
0:         for ( long i = initValue; (i < 0) && (i >= minValue); i-- )
1:         {
0:             firstValue = i;
0:             vetBoundaries( maxValue, minValue, -stepSize, firstValue, restartValue );
1:         }
1:     }
1:     private void vetBoundaries
1:         (
1:          long maxValue,
1:          long minValue,
1:          long stepSize,
1:          long firstValue,
1:          long restartValue
1:          )
1:         throws Exception
1:     {
1:         long bumps = (2 * ALLOCATION_COUNT) + 1;
1:         
1:         vetBumping( firstValue, true, stepSize, maxValue, minValue, restartValue, bumps );
1:         vetBumping( firstValue, false, stepSize, maxValue, minValue, restartValue, bumps );
1:     }
1:     private void vetBumping
1:         (
1:          long firstValue,
1:          boolean canCycle,
1:          long stepSize,
1:          long maxValue,
1:          long minValue,
1:          long restartValue,
1:          long bumps
1:          )
1:         throws Exception
1:     {
1:         if ( _fullDebug) { println( "stepSize = " + stepSize + " and firstValue = " + firstValue + " and canCycle = " + canCycle ); }
1:         
1:         SGVetter vetter = new SGVetter
0:             ( new Long(  firstValue ), canCycle, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:         T_SequenceUpdater updater = new T_SequenceUpdater
0:             ( new Long(  firstValue ), canCycle, stepSize, maxValue, minValue, restartValue );
1: 
1:         if ( _fullDebug) { println( "" ); }
1:         for ( long i = 0; i < bumps; i++ ) { vetBump( vetter, updater ); }
1:     }
1:     private void vetBump( SGVetter vetter, T_SequenceUpdater updater ) throws Exception
1:     {
1:         assertLongEquals( vetter.getUpperBound(), updater.getValueOnDisk() );
1: 
1:         Long vetterValue = vetter.getNextValue();
1: 
1:         if ( _fullDebug ) { println( "Expecting value = " + vetterValue + " and expecting ValueOnDisk = " + vetter.getUpperBound() ); }
1:         
1:         if ( vetterValue != null )
1:         {
1:             long updaterValue = updater.getCurrentValueAndAdvance();
1: 
1:             assertEquals( vetterValue.longValue(), updaterValue );
1:         }
1:         else
1:         {
1:             try {
1:                 updater.getCurrentValueAndAdvance();
1:                 fail( "Expected to catch cycle exception." );
1:             }
1:             catch (Exception e)
1:             {}
1:         }
1: 
1:         assertLongEquals( vetter.getUpperBound(), updater.getValueOnDisk() );
1:     }
1:     private void assertLongEquals( Long left, Long right )
1:     {
1:         if ( left == null ) { assertNull( right ); }
1:         else
1:         {
1:             assertNotNull( right );
1:             assertEquals( left.longValue(), right.longValue() );
1:         }
1:     }
1:     
1:     private void vetBumping( T_SequenceUpdater updater, long expectedValue, long expectedValueOnDisk )
1:         throws Exception
1:     {
1:         long actualValue = updater.getCurrentValueAndAdvance();
1:         long actualValueOnDisk = updater.getValueOnDisk().longValue();
1:         
1:         println( "Expected value = " + expectedValue + " vs actual value = " + actualValue );
0:         println( "    Expected value on disk = " + expectedValue + " vs actual value on disk = " + actualValueOnDisk );
1:         
1:         assertEquals( expectedValue, actualValue );
1:         assertEquals( expectedValueOnDisk, actualValueOnDisk );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test non cycling sequence generators.
1:      * </p>
1:      */
1:     public void test_03_nonCycling() throws Exception
1:     {
1:         vetNonCycling( Short.MAX_VALUE, Short.MIN_VALUE );
1:         vetNonCycling( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:         vetNonCycling( Long.MAX_VALUE, Long.MIN_VALUE );
1:     }
1:     private void vetNonCycling
1:         (
1:          long maxValue,
1:          long minValue
1:          )
1:         throws Exception
1:     {
1:         vetNonCycling( maxValue, minValue, 1L );
1:         vetNonCycling( maxValue, minValue, -1L );
1:     }
1:     private void vetNonCycling
1:         (
1:          long maxValue,
1:          long minValue,
1:          long stepSize
1:          )
1:         throws Exception
1:     {
1:         long bumps = 3;
1:         long firstValue;
1:         long restartValue;
1: 
1:         if ( stepSize > 0 )
1:         {
1:             firstValue = maxValue - bumps;
1:             restartValue = minValue;
1:         }
1:         else
1:         {
1:             firstValue = minValue + bumps;
1:             restartValue = maxValue;
1:         }
1: 
1:         SGVetter vetter = new SGVetter
0:             ( new Long(  firstValue ), false, stepSize, maxValue, minValue, restartValue, ALLOCATION_COUNT );           
1:         T_SequenceUpdater updater = new T_SequenceUpdater
0:             ( new Long(  firstValue ), false, stepSize, maxValue, minValue, restartValue );
1: 
1:         // make sure we can survive trying to bust the cycle more than once
1:         long extraBumps = bumps + 2;
1:         for ( long i = 0; i <= extraBumps; i++ )
1:         {
1:             vetBump( vetter, updater );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test that when you reboot the database, you pick up the sequence
1:      * number on disk, not the last version in memory.
1:      * </p>
1:      */
1:     public void test_04_reboot() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1:         
1:         int initialValue = Integer.MIN_VALUE;
1: 
1:         goodStatement( conn, "create sequence seq_04\n" );
1: 
1:         int seq_04_value = initialValue;
1:         long seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1: 
1:         getTestConfiguration().shutdownDatabase();
1:         conn = openUserConnection( TEST_DBO );
0:         seq_04_value = (int) seq_04_upperBound;
1:         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1: 
1:         getTestConfiguration().shutdownDatabase();
1:         conn = openUserConnection( TEST_DBO );
0:         seq_04_value = (int) seq_04_upperBound;
1:         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
1:         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test that multiple transactions can access the same sequence generator
1:      * and not block.
1:      * </p>
1:      */
1:     public void test_05_concurrency() throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1:         
1:         int initialValue = Integer.MIN_VALUE;
1: 
1:         goodStatement( conn, "create sequence seq_05\n" );
1:         goodStatement( conn, "grant usage on sequence seq_05 to public\n" );
1: 
1:         int seq_05_value = initialValue;
1:         long seq_05_upperBound = seq_05_value;
1: 
1:         Connection  ruthConnection = openUserConnection( "RUTH" );
1:         Connection  aliceConnection = openUserConnection( "ALICE" );
1: 
1:         ruthConnection.setAutoCommit( false );
1:         aliceConnection.setAutoCommit( false );
1: 
1:         long loopCount = 2 * ALLOCATION_COUNT;
1:         for ( long i = 0; i < loopCount; i++ )
1:         {
1:             Connection loopConn = ( i % 2 == 0 ) ? ruthConnection : aliceConnection;
1: 
1:             if ( (i % ALLOCATION_COUNT) == 0 ) { seq_05_upperBound += ALLOCATION_COUNT; }
1: 
1:             vetBumping( loopConn, TEST_DBO, "SEQ_05", seq_05_value++, seq_05_upperBound );
1:         }
1: 
1:         ruthConnection.commit();
1:         aliceConnection.commit();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test big step sizes.
1:      * </p>
1:      */
1:     public void test_06_bigStepSize() throws Exception
1:     {
1:         T_SequenceUpdater updater;
1:         long stepSize = (Long.MAX_VALUE / ALLOCATION_COUNT) * 3;
1: 
1:         updater = new T_SequenceUpdater
0:             ( new Long(  Long.MIN_VALUE ), true, stepSize, (long) Long.MAX_VALUE, (long) Long.MIN_VALUE, (long) Long.MIN_VALUE );
1: 
1:         long nextValue = updater.getCurrentValueAndAdvance();
1:         long currentValueOnDisk = updater.getValueOnDisk().longValue();
1:         long rangeSize = currentValueOnDisk - nextValue;
1: 
1:         // allocation count truncated to 1 because the step size is so large
1:         assertEquals( stepSize, rangeSize );
1: 
1:         vetBigStep( Short.MAX_VALUE, Short.MIN_VALUE );
1:         vetBigStep( Integer.MAX_VALUE, Integer.MIN_VALUE );
1:         vetBigStep( Long.MAX_VALUE, Long.MIN_VALUE );
1: 
1:         vetBigStep( ALLOCATION_COUNT, 0L );
1:     }
1:     private void vetBigStep( long maxValue, long minValue )
1:         throws Exception
1:     {
0:         Long firstValue = new Long( minValue );
1:         long restartValue = minValue;
1:         long stepSize = maxValue - 1;
1:         boolean canCycle = true;
1:         long truncatedAllocationCount = 1L;
1:         
1:         SGVetter vetter = new SGVetter
1:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue, truncatedAllocationCount );           
1:         T_SequenceUpdater updater = new T_SequenceUpdater
1:             ( firstValue, canCycle, stepSize, maxValue, minValue, restartValue );
1: 
1:         for ( long i = 0; i < ALLOCATION_COUNT; i++ )
1:         {
1:             vetBump( vetter, updater );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Test that cache flushing doesn't prevent us from dropping
1:      * a sequence generator.
1:      * </p>
1:      */
1:     public void test_07_dropSequence() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         goodStatement( conn, "create sequence seq_07\n" );
1:         
1:         int initialValue = Integer.MIN_VALUE;
1:         int seq_07_value = initialValue;
1:         long seq_07_upperBound = seq_07_value + ALLOCATION_COUNT;
1:         for ( int i = 0; i < ALLOCATION_COUNT; i++ )
1:         {
1:             vetBumping( conn, TEST_DBO, "SEQ_07", seq_07_value++, seq_07_upperBound );
1:         }
1: 
1:         goodStatement( conn, "values( next value for seq_07 )\n" );
0:         goodStatement( conn, "drop sequence seq_07\n" );
1:         
1:         expectCompilationError( OBJECT_DOES_NOT_EXIST, "values ( next value for seq_07 )\n" );
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the current value from a sequence */
1:     private long getCurrentValue( String schemaName, String sequenceName )
1:         throws Exception
1:     {
1:         Connection  conn = openUserConnection( TEST_DBO );
1:         
1:         PreparedStatement ps = chattyPrepare
1:             ( conn,
1:               "select currentvalue from sys.syssequences seq, sys.sysschemas s where s.schemaname = ? and seq.sequencename = ? and s.schemaid = seq.schemaid" );
1:         ps.setString( 1, schemaName );
1:         ps.setString( 2, sequenceName );
1: 
1:         long retval = getScalarLong( ps );
1: 
1:         conn.commit();
1:         
1:         return retval;
1:     }
1:     
1:     /** Get a scalar integer result from a query */
1:     private int getScalarInteger( PreparedStatement ps ) throws Exception
1:     {
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         int retval = rs.getInt( 1 );
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
1:     /** Get a scalar long result from a query */
1:     private long getScalarLong( PreparedStatement ps ) throws Exception
1:     {
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         long retval = rs.getLong( 1 );
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // INNER CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Machine for testing sequence generators standalone.
1:      * </p>
1:      */
1:     public static final class T_SequenceUpdater extends SequenceUpdater
1:     {
1:         private Long _valueOnDisk;
1:         
1:         public T_SequenceUpdater
1:             (
1:              Long currentValue,
1:              boolean canCycle,
1:              long increment,
1:              long maxValue,
1:              long minValue,
1:              long restartValue
1:              )
1:         {
1:             _valueOnDisk = currentValue;
1:             
1:             _sequenceGenerator = new SequenceGenerator
1:                 (
1:                  currentValue,
1:                  canCycle,
1:                  increment,
1:                  maxValue,
1:                  minValue,
1:                  restartValue,
0:                  "DUMMY_SEQUENCE"
1:                  );
1:         }
1:         
1:         public Long getValueOnDisk() { return _valueOnDisk; }
1:         
1:         public long getCurrentValueAndAdvance() throws Exception
1:         {
1:             SQLLongint nextValue = new SQLLongint();
1:             
1:             getCurrentValueAndAdvance( nextValue );
1:             
1:             return nextValue.getLong();
1:         }
1:         
1:         // SequenceUpdater BEHAVIOR
1:         protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC ) { return _sequenceGenerator; }
1:         
1:         protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait )
1:         {
1:             _valueOnDisk = newValue;
1: 
1:             return true;
1:         }
1:         
1:         // override so the tests don't get a null pointer exception looking up the lcc
1:         public boolean updateCurrentValueOnDisk( Long oldValue, Long newValue )
1:         {
1:             return updateCurrentValueOnDisk( null, oldValue, newValue, false );
1:         }
1:     }
1: 
1: }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.SequencePreallocator;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:             SequenceGeneratorTest.class);
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:5705f5b
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Verify that system crash does not rollback changes to SYSSEQUENCES.CURRENTVALUE.
1:      * See DERBY-5494.
1:      * </p>
1:      */
1:     public void test_13_5494() throws Exception
1:     {
1:         String  dbName = "DB_5494";
1:         
1:         // create a sequence and get the first value from it, then crash
1:         assertLaunchedJUnitTestMethod( getClass().getName() + ".preCrashActions", dbName );
1: 
1:         // now check that the sequence state was correctly recovered
1:         assertLaunchedJUnitTestMethod( getClass().getName() + ".postCrashActions", dbName );
1:     }
1:     // actions to perform just before a crash
1:     public void    preCrashActions()   throws Exception
1:     {
1:         Connection  dboConn = openUserConnection( TEST_DBO );
1:         Connection  ruthConn = openUserConnection( "RUTH" );
1:         int initialValue = Integer.MIN_VALUE;
1: 
1:         goodStatement( dboConn, "create sequence s_5494\n" );
1:         
1:         assertNextValue( dboConn, TEST_DBO, "S_5494", initialValue );
1: 
1:         assertEquals( (long) (initialValue + ALLOCATION_COUNT), getCurrentValue( ruthConn, TEST_DBO, "S_5494" ) );
1:     }
1:     // actions to perform after the crash
1:     public void    postCrashActions()   throws Exception
1:     {
1:         int initialValue = (int) (Integer.MIN_VALUE + ALLOCATION_COUNT);
1:         
1:         // now verify that, after the crash, SYSSEQUENCES has still been advanced
1:         Connection  dboConn = openUserConnection( TEST_DBO );
1:         assertEquals( (long) initialValue, getCurrentValue( dboConn, TEST_DBO, "S_5494" ) );
1: 
1:         assertNextValue( dboConn, TEST_DBO, "S_5494", initialValue );
1: 
1:         goodStatement( dboConn, "drop sequence s_5494 restrict\n" );
1:     }
1:     private void    assertNextValue( Connection conn, String schema, String sequenceName, int expectedValue )
1:         throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, "values( next value for " + schema + "." + sequenceName + " )\n" );
1: 
1:         assertEquals( expectedValue, getScalarInteger( ps ) );
1:     }
/////////////////////////////////////////////////////////////////////////
0: 
1:     /** Get the current value from a sequence */
0:     private long getCurrentValue(
0:     Connection  conn, 
0:     String      schemaName, 
0:     String      sequenceName )
1:         throws Exception
0:     {
0:         PreparedStatement ps = chattyPrepare
0:             ( conn,
0:               "select currentvalue from sys.syssequences seq, sys.sysschemas s where s.schemaname = ? and seq.sequencename = ? and s.schemaid = seq.schemaid" );
0:         ps.setString( 1, schemaName );
0:         ps.setString( 2, sequenceName );
0: 
0:         long retval = getScalarLong( ps );
0: 
0:         conn.commit();
0:         
0:         return retval;
0:     }
============================================================================