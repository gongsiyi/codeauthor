1:49653be: /*
12:49653be:  
1:49653be:    Derby - Class
1:1bac3f3:    org.apache.derby.impl.store.replication.slave.SlaveController
1:49653be:  
1:49653be:    Licensed to the Apache Software Foundation (ASF) under one or more
1:49653be:    contributor license agreements.  See the NOTICE file distributed with
1:49653be:    this work for additional information regarding copyright ownership.
1:49653be:    The ASF licenses this file to you under the Apache License, Version 2.0
1:49653be:    (the "License"); you may not use this file except in compliance with
1:49653be:    the License.  You may obtain a copy of the License at
1:49653be:  
1:49653be:       http://www.apache.org/licenses/LICENSE-2.0
1:49653be:  
1:49653be:    Unless required by applicable law or agreed to in writing, software
1:49653be:    distributed under the License is distributed on an "AS IS" BASIS,
1:49653be:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:49653be:    See the License for the specific language governing permissions and
1:49653be:    limitations under the License.
1:49653be:  
1:49653be:  */
1:e071963: 
1:1bac3f3: package org.apache.derby.impl.store.replication.slave;
1:49653be: 
1:49653be: import org.apache.derby.iapi.error.StandardException;
1:c458b05: import org.apache.derby.iapi.reference.Attribute;
1:e071963: import org.apache.derby.iapi.reference.MessageId;
1:49653be: import org.apache.derby.iapi.reference.SQLState;
1:49653be: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:49653be: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:e071963: import org.apache.derby.iapi.services.monitor.Monitor;
1:49653be: 
1:49653be: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:29fd25c: import org.apache.derby.impl.store.raw.log.LogCounter;
1:49653be: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:e071963: import org.apache.derby.impl.store.raw.log.LogToFile;
1:f2ec1d8: import org.apache.derby.impl.store.replication.net.SlaveAddress;
1:49653be: 
1:1bac3f3: import org.apache.derby.impl.store.replication.ReplicationLogger;
1:1bac3f3: import org.apache.derby.impl.store.replication.net.ReplicationMessage;
1:1bac3f3: import org.apache.derby.impl.store.replication.net.ReplicationMessageReceive;
1:1bac3f3: import org.apache.derby.iapi.store.replication.slave.SlaveFactory;
1:49653be: 
1:e071963: import java.io.EOFException;
1:b9c57d5: import java.io.IOException;
1:e071963: import java.net.SocketTimeoutException;
1:f2ec1d8: import java.net.UnknownHostException;
1:49653be: import java.util.Properties;
1:49653be: 
1:49653be: /**
4:49653be:  * <p> 
1:49653be:  * This is an implementation of the replication slave controller
1:49653be:  * service. The service is booted when this instance of Derby will
1:49653be:  * have the replication slave role for this database.
4:49653be:  * </p> 
1:49653be:  * <p>
1:49653be:  * Note: The current version of the class is far from complete. Code
1:49653be:  * to control the replication slave behavior will be added as more
1:49653be:  * parts of the replication functionality is added to Derby. 
1:49653be:  * </p>
6:49653be:  *
1:49653be:  * @see SlaveFactory
1:49653be:  */
1:696377a: public class SlaveController
1:e071963:     implements SlaveFactory, ModuleControl, ModuleSupportable {
1:e071963: 
1:e071963: 
1:e071963:     // How long to wait for a connection to be established with the
1:e071963:     // master before timing out. Note that this is done so that we can
1:e071963:     // detect if replication slave mode has been stopped. If
1:e071963:     // replication mode has not been stopped, a new attempt is made to
1:e071963:     // set up the connection. 
1:e071963:     // TODO: make this configurable through a property
1:e071963:     private static final int DEFAULT_SOCKET_TIMEOUT = 1000; // 1 second
1:49653be: 
1:49653be:     private RawStoreFactory rawStoreFactory;
1:e071963:     private LogToFile logToFile;
1:e071963:     private ReplicationMessageReceive receiver;
1:1d0892e:     private ReplicationLogger repLogger;
1:49653be: 
1:f2ec1d8:     private SlaveAddress slaveAddr;
1:e071963:     private String dbname; // The name of the replicated database
1:e071963: 
1:29fd25c:     /** The instant of the latest log record received from the master 
1:29fd25c:      * and processed so far. Used to check that master and slave log files 
1:29fd25c:      * are in synch */
1:29fd25c:     private volatile long highestLogInstant = -1;
1:29fd25c: 
1:29fd25c:     /**
1:29fd25c:      * Whether or not replication slave mode is still on. Will be set
1:29fd25c:      * to false when slave replication is shut down. The value of this
1:29fd25c:      * variable is checked after every timeout when trying to set up a
1:29fd25c:      * connection to the master, and by the thread that applies log
1:29fd25c:      * chunks received from the master. */
1:e071963:     private volatile boolean inReplicationSlaveMode = true;
1:e071963: 
1:334e9a3:     /** Whether or not this SlaveController has been successfully
1:334e9a3:      * started, including setting up a connection with the master and
1:334e9a3:      * starting the log receiver thread. The client connection that
1:334e9a3:      * initiated slave replication mode on this database will not
1:334e9a3:      * report that slave mode was successfully started (i.e., it will
1:334e9a3:      * hang) until startupSuccessful has been set to true */
1:334e9a3:     private volatile boolean startupSuccessful = false;
1:334e9a3: 
1:e071963:     // Used to parse chunks of log records received from the master.
1:e071963:     private ReplicationLogScan logScan;
1:e071963: 
1:e071963:     // Thread that listens for log chunk messages from the master, and
1:e071963:     // applies these to the local log
1:e071963:     private SlaveLogReceiverThread logReceiverThread;
1:49653be: 
1:49653be:     /**
1:49653be:      * Empty constructor required by Monitor.bootServiceModule
1:49653be:      */
1:49653be:     public SlaveController() { }
1:49653be: 
1:49653be:     ////////////////////////////////////////////////////////////
1:49653be:     // Implementation of methods from interface ModuleControl //
1:49653be:     ////////////////////////////////////////////////////////////
1:49653be: 
1:49653be:     /**
1:49653be:      * Used by Monitor.bootServiceModule to start the service. It will
1:49653be:      * set up basic variables 
1:49653be:      *
1:49653be:      * @param create Currently ignored
1:49653be:      * @param properties Properties used to start the service in the
1:49653be:      * correct mode
1:49653be:      * @exception StandardException Standard Derby exception policy,
1:49653be:      * thrown on error.
1:49653be:      */
1:49653be:     public void boot(boolean create, Properties properties)
1:49653be:         throws StandardException {
1:e071963: 
1:c458b05:         String port = properties.getProperty(Attribute.REPLICATION_SLAVE_PORT);
1:f2ec1d8:         
1:f2ec1d8:         try {
1:f2ec1d8:             //if slavePort is -1 the default port
1:f2ec1d8:             //value will be used.
1:f2ec1d8:             int slavePort = -1;
1:f2ec1d8:             if (port != null) {
1:ce40a31:                 slavePort = Integer.parseInt(port);
1:f2ec1d8:             }
1:f2ec1d8:             slaveAddr = new SlaveAddress(
1:f2ec1d8:                     properties.getProperty(Attribute.REPLICATION_SLAVE_HOST), 
1:f2ec1d8:                     slavePort);
1:f2ec1d8:         } catch (UnknownHostException uhe) {
1:f2ec1d8:             throw StandardException.newException
1:f2ec1d8:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe, 
1:f2ec1d8:                      dbname, getHostName(), String.valueOf(getPortNumber()));
1:b9c57d5:         }
1:e071963: 
1:e071963:         dbname = properties.getProperty(SlaveFactory.SLAVE_DB);
1:1d0892e:         repLogger = new ReplicationLogger(dbname);
1:b9c57d5:     }
1:e071963: 
1:49653be:     /**
1:b9c57d5:      * Will tear down the replication slave service. 
1:49653be:      */
1:b9c57d5:     public void stop() { 
1:b9c57d5:         if (inReplicationSlaveMode) {
1:b9c57d5:             // For some reason, stopSlave or failover have not been
1:b9c57d5:             // called yet. Force slave to stop.
1:b9c57d5:             try {
1:b9c57d5:                 stopSlave(true);
1:b9c57d5:             } catch (StandardException se) {
1:b9c57d5:                 // do nothing
1:b9c57d5:             }
1:b9c57d5:         }
1:b9c57d5:     }
1:49653be: 
1:49653be:     ////////////////////////////////////////////////////////////////
1:49653be:     // Implementation of methods from interface ModuleSupportable //
1:49653be:     ////////////////////////////////////////////////////////////////
1:49653be: 
1:49653be:     /**
1:49653be:      * Used by Monitor.bootServiceModule to check if this class is
1:49653be:      * usable for replication. To be usable, we require that slave
1:49653be:      * replication mode is specified in startParams by checking that a
1:49653be:      * property with key SlaveFactory.REPLICATION_MODE has the value
1:49653be:      * SlaveFactory.SLAVE_MODE.
1:49653be:      * @param startParams The properties used to start replication
1:49653be:      * @return true if slave repliation is specified, meaning that
1:49653be:      * this MasterController is a suitable implementation for the
1:49653be:      * SlaveFactory service. False otherwise.
1:49653be:      * @see ModuleSupportable#canSupport 
1:49653be:      */
1:49653be:     public boolean canSupport(Properties startParams) {
1:49653be:         String modeParam =
1:49653be:             startParams.getProperty(SlaveFactory.REPLICATION_MODE);
1:49653be: 
1:49653be:         // currently only one attribute: slave replication mode
1:49653be:         if (modeParam != null && 
1:49653be:             modeParam.equals(SlaveFactory.SLAVE_MODE)) {
1:49653be:             return true;
1:e071963:         } else {
1:e071963:             return false;
1:e071963:         }
7:49653be:     }
1:49653be: 
1:49653be:     ///////////////////////////////////////////////////////////
1:49653be:     // Implementation of methods from interface SlaveFactory //
1:49653be:     ///////////////////////////////////////////////////////////
1:49653be: 
1:49653be:     /**
1:49653be:      * Start slave replication. This method establishes a network
1:49653be:      * connection with the associated replication master and starts a
1:e071963:      * thread that applies operations received from the master (in the
1:49653be:      * form of log records) to the local slave database.
1:49653be:      *
1:49653be:      * @param rawStore The RawStoreFactory for the database
1:e071963:      * @param logFac The LogFactory ensuring recoverability for this
1:e071963:      * database
1:e071963:      *
1:e071963:      * @exception StandardException Thrown if the slave could not be
1:e071963:      * started.
1:49653be:      */
1:e071963:     public void startSlave(RawStoreFactory rawStore, LogFactory logFac)
1:e071963:         throws StandardException {
1:b9c57d5: 
1:b9c57d5:         rawStoreFactory = rawStore;
1:b9c57d5: 
1:b9c57d5:         try {
1:b9c57d5:             logToFile = (LogToFile)logFac;
1:b9c57d5:         } catch (ClassCastException cce) {
1:b9c57d5:             // Since there are only two implementing classes of
1:b9c57d5:             // LogFactory, the class type has to be ReadOnly if it is
1:b9c57d5:             // not LogToFile.
1:b9c57d5:             throw StandardException.newException(
1:b9c57d5:                 SQLState.LOGMODULE_DOES_NOT_SUPPORT_REPLICATION);
1:b9c57d5:         }
1:b9c57d5: 
1:b9c57d5:         logToFile.initializeReplicationSlaveRole();
1:b9c57d5: 
1:e071963:         // Retry to setup a connection with the master until a
1:e071963:         // connection has been established or until we are no longer
1:e071963:         // in replication slave mode
1:f2ec1d8:         receiver = new ReplicationMessageReceive(slaveAddr, dbname);
1:e071963:         while (!setupConnection()) {
1:e071963:             if (!inReplicationSlaveMode) {
1:e071963:                 // If we get here, another thread has called
1:e071963:                 // stopSlave() while we waited for a connection with
1:e071963:                 // the master. The thread shutting the slave down will
1:e071963:                 // clean up anything we did during setupConnection, so
1:e071963:                 // simply return.
1:e071963:                 return;
1:e071963:             }
1:e071963:         }
1:e071963: 
1:e071963:         // Setup the log scan used to parse chunks of log received
1:e071963:         // from the master
1:e071963:         logScan = new ReplicationLogScan();
1:49653be: 
1:e071963:         startLogReceiverThread();
1:334e9a3:         startupSuccessful = true;
1:e071963: 
1:e071963:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_STARTED, dbname);
1:e071963:     }
1:49653be: 
1:e071963:     /**
1:49653be:      * Will perform all work that is needed to stop replication
1:49653be:      */
1:b9c57d5:     private void stopSlave() throws StandardException {
1:0217bc6:         inReplicationSlaveMode = false;
1:d9d733a:         teardownNetwork();
1:b9c57d5: 
1:29fd25c:         logToFile.stopReplicationSlaveRole();
1:b9c57d5: 
1:e071963:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_STOPPED, dbname);
1:b9c57d5:     }
1:b9c57d5: 
1:49653be:     /**
1:b9c57d5:      * @see SlaveFactory#stopSlave
1:b9c57d5:      */
1:b9c57d5:     public void stopSlave(boolean forcedStop) 
1:b9c57d5:             throws StandardException {
1:c283bcd:         if (!forcedStop && isConnectedToMaster()){
1:b9c57d5:             throw StandardException.newException(
1:9e88b9d:                     SQLState.SLAVE_OPERATION_DENIED_WHILE_CONNECTED);
1:e071963:         }
1:0f8eece:         stopSlave();
1:e071963:     }
1:49653be: 
1:9e88b9d:     public void failover() throws StandardException {
1:c283bcd:         if (isConnectedToMaster()){
1:9e88b9d:             throw StandardException.newException(
1:9e88b9d:                 SQLState.SLAVE_OPERATION_DENIED_WHILE_CONNECTED);
1:9e88b9d:         }
1:9e88b9d:         doFailover();
1:d9d733a:         teardownNetwork();
1:9e88b9d:     } 
1:9e88b9d: 
1:49653be:     /**
1:9e88b9d:      * Performs failover on this database. May be called because a
1:9e88b9d:      * failover command has been received from the master, or because
1:9e88b9d:      * a client has requested a failover after the network connection
1:9e88b9d:      * with the master has been lost.
1:9e88b9d:      * @see SlaveFactory#failover
1:49653be:      */
1:9e88b9d:     private void doFailover() {
1:e071963:         inReplicationSlaveMode = false;
1:b9c57d5:         logToFile.failoverSlave();
1:0217bc6:         Monitor.logTextMessage
1:0217bc6:                 (MessageId.REPLICATION_FAILOVER_SUCCESSFUL, dbname);
1:49653be:     }
1:49653be: 
1:334e9a3:     /**
1:334e9a3:      * @see SlaveFactory#isStarted
1:334e9a3:      */
1:334e9a3:     public boolean isStarted() {
1:334e9a3:         return startupSuccessful;
1:334e9a3:     }
1:334e9a3: 
1:e071963:     ////////////////////////////////////////////////////////////
1:e071963:     // Private Methods                                        //
1:e071963:     ////////////////////////////////////////////////////////////
1:e071963: 
1:e071963:     /**
1:e071963:      * Establish a connection with the replication master. Listens for
1:e071963:      * a connection on the slavehost/port for DEFAULT_SOCKET_TIMEOUT
1:e071963:      * milliseconds. 
1:e071963:      *
1:e071963:      * @return true if a connection has been set up with the master,
1:e071963:      * false if the connection attempt timed out.
1:e071963:      *
1:e071963:      * @exception StandardException if an unexpected exception occured
1:e071963:      * that prevented a connection with the master.
1:e071963:      */
1:e071963:     private boolean setupConnection() throws StandardException {
1:e071963: 
1:b9c57d5:         try {
1:29fd25c:             // highestLogInstant is -1 until the first log chunk has
1:29fd25c:             // been received from the master. If a log chunk has been
1:29fd25c:             // received, use the instant of the latest received log
1:29fd25c:             // record to synchronize log files. If no log has been
1:29fd25c:             // received yet, use the end position of the log (i.e.,
1:29fd25c:             // logToFile.getFlushedInstant)
1:29fd25c:             if (highestLogInstant != -1) {
1:29fd25c:                 // timeout to check if still in replication slave mode
1:29fd25c:                 receiver.initConnection(DEFAULT_SOCKET_TIMEOUT,
1:29fd25c:                                         highestLogInstant,
1:29fd25c:                                         dbname);
1:29fd25c:             } else {
1:29fd25c:                 // timeout to check if still in replication slave mode
1:29fd25c:                 receiver.initConnection(DEFAULT_SOCKET_TIMEOUT,
1:29fd25c:                                         logToFile.
1:29fd25c:                                         getFirstUnflushedInstantAsLong(),
1:29fd25c:                                         dbname);
1:29fd25c:             }
1:e071963:             return true; // will not reach this if timeout
1:e071963:         } catch (StandardException se) {
1:e071963:             throw se;
1:b06f20e:         } catch (SocketTimeoutException ste) {
1:b06f20e:             // Got a timeout. Return normally and let the caller retry.
1:b06f20e:             return false;
1:e071963:         } catch (Exception e) {
1:b06f20e:             throw StandardException.newException
1:334e9a3:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e,
1:f2ec1d8:                     dbname, getHostName(), String.valueOf(getPortNumber()));
1:e071963:         }
1:e071963:     }
1:e071963: 
1:e071963:     /**
1:e071963:      * Write the reason for the lost connection to the log (derby.log)
1:e071963:      * and reconnect with the master. Once the network is up and
1:e071963:      * running, a new LogReceiverThread is started. The method returns
1:e071963:      * without doing anything if inReplicationSlaveMode=false, which
1:e071963:      * means that stopSlave() has been called by another thread.
1:e071963:      *
1:b9c57d5:      * @param e The reason the connection to the master was lost
1:e071963:      */
1:e071963: 
1:b9c57d5:     private void handleDisconnect(Exception e) {
1:e071963:         if (!inReplicationSlaveMode) {
1:e071963:             return;
1:e071963:         }
1:e071963: 
1:1d0892e:         repLogger.logError(MessageId.REPLICATION_SLAVE_LOST_CONN, e);
1:e071963: 
1:b9c57d5:         try {
1:e071963:             while (!setupConnection()) {
1:e071963:                 if (!inReplicationSlaveMode) {
1:e071963:                     // stopSlave may have been called, turning
1:e071963:                     // replication slave mode off. Simply return if
1:e071963:                     // that is the case. The thread that called
1:e071963:                     // stopSlave will clean up everything.
1:e071963:                     return;
1:e071963:                 }
1:e071963:             }
1:e071963: 
1:e071963:             startLogReceiverThread();
1:e071963:         } catch (StandardException se) {
1:e071963:             handleFatalException(se);
1:e071963:         }
1:e071963:     }
1:e071963: 
1:e071963:     /**
1:c283bcd:      * Check if the repliation network connection to the master is working
1:c283bcd:      * @return true if the network connection is working, false otherwise
1:c283bcd:      */
1:c283bcd:     private boolean isConnectedToMaster() {
1:c283bcd:         if (receiver == null) {
1:c283bcd:             return false;
1:c283bcd:         } else {
1:c283bcd:             return receiver.isConnectedToMaster();
1:c283bcd:         }
1:c283bcd:     }
1:c283bcd: 
1:c283bcd:     /**
1:e071963:      * Starts the LogReceiverThread that will listen for chunks of log
1:e071963:      * records from the master and apply the log records to the local
1:e071963:      * log file.
1:e071963:      */
1:e071963:     private void startLogReceiverThread() {
1:e071963:         logReceiverThread = new SlaveLogReceiverThread();
1:56c419e:         logReceiverThread.setDaemon(true);
1:e071963:         logReceiverThread.start();
1:e071963:     }
1:e071963: 
1:e071963:     /**
1:e071963:      * Handles fatal errors for slave replication functionality. These
1:e071963:      * are errors that requires us to stop replication. Calling this
1:e071963:      * method has the following effects:
1:e071963:      *
1:e071963:      * 1) Debug messages are written to the log file (usually
1:e071963:      *    derby.log) if ReplicationLogger#LOG_REPLICATION_MESSAGES is
1:e071963:      *    true.
1:e071963:      *
1:e071963:      * 2) If the network connection is up, the master is notified of
1:e071963:      *    the problem.
1:e071963:      *
1:e071963:      * 3) All slave replication functionality is stopped, and the
1:e071963:      *    database is then shut down without being booted.
1:e071963:      *
1:e071963:      * The method will return without doing anything if
1:e071963:      * inReplicationSlaveMode=false, meaning that stopSlave has been
1:e071963:      * called.
1:e071963:      *
1:e071963:      * @param e The fatal exception that is the reason for calling
1:e071963:      * this method
1:e071963:      */
1:e071963:     private void handleFatalException(Exception e) {
1:e071963:         // If inReplicationSlaveMode is false, the stopSlave method in
1:e071963:         // this controller has already been called. If so, we ignore
1:e071963:         // this fatal error.
1:e071963:         if (!inReplicationSlaveMode) {
1:e071963:             return;
1:e071963:         }
1:e071963: 
1:1d0892e:         repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, e);
1:e071963: 
1:e071963:         // todo: notify master of the problem
1:334e9a3:         try {
1:334e9a3:             stopSlave();
1:334e9a3:         } catch (StandardException se) {
1:1d0892e:             repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, se);
1:334e9a3:         }
1:e071963:     }
1:e071963: 
1:d9d733a:     private void teardownNetwork() {
1:d9d733a:         try {
1:d9d733a:             // Unplug the replication network connection layer
1:d9d733a:             if (receiver != null) {
1:d9d733a:                 receiver.tearDown();
1:d9d733a:                 receiver = null;
1:d9d733a:             }
1:d9d733a:         } catch (IOException ioe) {
1:1d0892e:             repLogger.logError(null, ioe);
1:d9d733a:         }
1:d9d733a:     }
1:f2ec1d8:     
1:f2ec1d8:     /**
1:f2ec1d8:      * Used to return the host name of the slave.
1:f2ec1d8:      *
1:f2ec1d8:      * @return a String containing the host name of the slave.
1:f2ec1d8:      */
1:f2ec1d8:     private String getHostName() {
1:f2ec1d8:         return slaveAddr.getHostAddress().getHostName();
1:f2ec1d8:     }
1:f2ec1d8:     
1:f2ec1d8:     /**
1:f2ec1d8:      * Used to return the port number of the slave.
1:f2ec1d8:      *
1:f2ec1d8:      * @return an Integer that represents the port number of the slave.
1:f2ec1d8:      */
1:f2ec1d8:     private int getPortNumber() {
1:f2ec1d8:         return slaveAddr.getPortNumber();
1:f2ec1d8:     }
1:b9c57d5: 
1:e071963:     ///////////////////////////////////////////////////////////////////////////
1:e071963:     // Inner Class - Thread used to apply chunks of log received from master //
1:e071963:     ///////////////////////////////////////////////////////////////////////////
1:e071963: 
1:b9c57d5:     /**
1:e071963:      * Thread that listens for incoming messages from the master and
1:e071963:      * applies chunks of log records to the local log files.
1:e071963:      */
1:e071963:     private class SlaveLogReceiverThread extends Thread {
1:41a2601:         
1:41a2601:         /**
1:41a2601:          * Creates a new instance of <tt>SlaveLogReceiverThread</tt>
1:41a2601:          * with a debugging-friendly thread name.
1:41a2601:          */
1:41a2601:         SlaveLogReceiverThread() {
1:41a2601:             super("derby.slave.logger-" + dbname);
1:41a2601:         }
1:41a2601:         
1:e071963:         public void run() {
1:e071963:             try {
1:e071963:                 ReplicationMessage message;
1:e071963:                 while (inReplicationSlaveMode) {
1:e071963:                     message = receiver.readMessage();
1:e071963: 
1:e071963:                     switch (message.getType()){
1:e071963:                     case ReplicationMessage.TYPE_LOG:
1:e071963:                         byte[] logChunk = (byte[])message.getMessage();
1:e071963:                         handleLogChunk(logChunk);
1:e071963:                         break;
1:0217bc6:                     case ReplicationMessage.TYPE_FAILOVER:
1:9e88b9d:                         doFailover();
1:0217bc6:                         ReplicationMessage ack = new ReplicationMessage
1:0217bc6:                             (ReplicationMessage.TYPE_ACK, "failover succeeded");
1:0217bc6:                         receiver.sendMessage(ack);
1:d9d733a:                         teardownNetwork();
1:0217bc6:                         break;
1:0f8eece:                     case ReplicationMessage.TYPE_STOP:
1:b9c57d5:                         stopSlave();
1:0f8eece:                         break;
1:e071963:                     default:
1:e071963:                         // debug; will be removed
1:e071963:                         System.out.println("Not handling non-log messages yet "
1:e071963:                                            +"- got a type "+message.getType());
1:e071963:                         break;
1:334e9a3:                     }
1:b9c57d5:                 }
1:e071963: 
1:e071963:             } catch (EOFException eofe) {
1:e071963:                 // Network connection with master has been lost.
1:e071963:                 handleDisconnect(eofe);
1:e071963:             } catch (StandardException se) {
1:e071963:                 handleFatalException(se);
1:e071963:             } catch (Exception e) {
1:e071963:                 // Exceptions not caused by disconnect are unexpected,
1:e071963:                 // and therefore fatal
1:e071963:                 StandardException se = 
1:e071963:                     StandardException.newException
1:e071963:                     (SQLState.REPLICATION_UNEXPECTED_EXCEPTION, e);
1:e071963:                 handleFatalException(se);
1:b9c57d5:             }
1:e071963:         }
1:e071963: 
1:e071963:         /**
1:e071963:          * Parses a chunk of log received from the master, and applies
1:e071963:          * the individual log records to the local log file.
1:e071963:          *
1:e071963:          * @param logChunk A chunk of log records received from the
1:e071963:          * master
1:e071963:          * @exception StandardException If the chunk of log records
1:e071963:          * could not be parsed or the local log file is out of synch
1:e071963:          * with the master log file.
1:e071963:          */
1:e071963:         private void handleLogChunk(byte[] logChunk)
1:e071963:             throws StandardException{
1:e071963:             logScan.init(logChunk);
1:e071963: 
1:e071963:             while (logScan.next()){
1:e071963:                 if (logScan.isLogFileSwitch()) {
1:e071963:                     logToFile.switchLogFile();
1:e071963:                 } else {
1:e071963: 
1:e071963:                     long localInstant = logToFile.
1:e071963:                         appendLogRecord(logScan.getData(), 
1:e071963:                                         0, 
1:e071963:                                         logScan.getDataLength(), 
1:e071963:                                         null, 
1:e071963:                                         0, 
1:e071963:                                         0);
1:e071963: 
1:e071963:                     // If the log instant of the received log does not
1:e071963:                     // match with the local log instant, the log
1:e071963:                     // records are not written to the same physical
1:e071963:                     // location in the log files. This is fatal since
1:e071963:                     // log records are identified by their physical
1:e071963:                     // location in the log files.
1:e071963:                     if (logScan.getInstant() != localInstant) {
2:e071963:                         throw StandardException.newException
1:e071963:                             (SQLState.REPLICATION_LOG_OUT_OF_SYNCH,
1:e071963:                              dbname,
1:ce40a31:                              LogCounter.getLogFileNumber(logScan.getInstant()),
1:ce40a31:                              LogCounter.getLogFilePosition(logScan.getInstant()),
1:ce40a31:                              LogCounter.getLogFileNumber(localInstant),
1:ce40a31:                              LogCounter.getLogFilePosition(localInstant));
1:e071963:                     }
1:29fd25c:                     highestLogInstant = localInstant;
1:e071963:                 }
1:e071963:             }
1:e071963:         }
1:e071963:     }
1:e071963:     ///////////////////////////////////////////////////////////
1:e071963:     // END Inner Class                                       //
1:e071963:     ///////////////////////////////////////////////////////////
1:e071963: 
1:e071963: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 slavePort = Integer.parseInt(port);
/////////////////////////////////////////////////////////////////////////
1:                              LogCounter.getLogFileNumber(logScan.getInstant()),
1:                              LogCounter.getLogFilePosition(logScan.getInstant()),
1:                              LogCounter.getLogFileNumber(localInstant),
1:                              LogCounter.getLogFilePosition(localInstant));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b06f20e
/////////////////////////////////////////////////////////////////////////
1:         } catch (SocketTimeoutException ste) {
1:             // Got a timeout. Return normally and let the caller retry.
1:             return false;
1:             throw StandardException.newException
commit:1d0892e
/////////////////////////////////////////////////////////////////////////
1:     private ReplicationLogger repLogger;
/////////////////////////////////////////////////////////////////////////
1:         repLogger = new ReplicationLogger(dbname);
/////////////////////////////////////////////////////////////////////////
1:         repLogger.logError(MessageId.REPLICATION_SLAVE_LOST_CONN, e);
/////////////////////////////////////////////////////////////////////////
1:         repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, e);
1:             repLogger.logError(MessageId.REPLICATION_FATAL_ERROR, se);
/////////////////////////////////////////////////////////////////////////
1:             repLogger.logError(null, ioe);
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f2ec1d8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.replication.net.SlaveAddress;
/////////////////////////////////////////////////////////////////////////
1: import java.net.UnknownHostException;
/////////////////////////////////////////////////////////////////////////
1:     private SlaveAddress slaveAddr;
/////////////////////////////////////////////////////////////////////////
1:         
1:         try {
1:             //if slavePort is -1 the default port
1:             //value will be used.
1:             int slavePort = -1;
1:             if (port != null) {
0:                 slavePort = (new Integer(port)).intValue();
1:             }
1:             slaveAddr = new SlaveAddress(
1:                     properties.getProperty(Attribute.REPLICATION_SLAVE_HOST), 
1:                     slavePort);
1:         } catch (UnknownHostException uhe) {
1:             throw StandardException.newException
1:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, uhe, 
1:                      dbname, getHostName(), String.valueOf(getPortNumber()));
/////////////////////////////////////////////////////////////////////////
1:         receiver = new ReplicationMessageReceive(slaveAddr, dbname);
/////////////////////////////////////////////////////////////////////////
1:                     dbname, getHostName(), String.valueOf(getPortNumber()));
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Used to return the host name of the slave.
1:      *
1:      * @return a String containing the host name of the slave.
1:      */
1:     private String getHostName() {
1:         return slaveAddr.getHostAddress().getHostName();
1:     }
1:     
1:     /**
1:      * Used to return the port number of the slave.
1:      *
1:      * @return an Integer that represents the port number of the slave.
1:      */
1:     private int getPortNumber() {
1:         return slaveAddr.getPortNumber();
1:     }
commit:c283bcd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (!forcedStop && isConnectedToMaster()){
/////////////////////////////////////////////////////////////////////////
1:         if (isConnectedToMaster()){
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Check if the repliation network connection to the master is working
1:      * @return true if the network connection is working, false otherwise
1:      */
1:     private boolean isConnectedToMaster() {
1:         if (receiver == null) {
1:             return false;
1:         } else {
1:             return receiver.isConnectedToMaster();
1:         }
1:     }
1: 
1:     /**
commit:56c419e
/////////////////////////////////////////////////////////////////////////
1:         logReceiverThread.setDaemon(true);
commit:f201787
/////////////////////////////////////////////////////////////////////////
0:         // If slaveport was not specified when starting the slave, the
0:         // receiver will use the default port. Set slaveport to the port
0:         // actually used by the receiver
0:         slaveport = receiver.getPort();
/////////////////////////////////////////////////////////////////////////
0:                     dbname, slavehost, String.valueOf(slaveport));
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1:    org.apache.derby.impl.store.replication.slave.SlaveController
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.store.replication.slave;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.replication.ReplicationLogger;
1: import org.apache.derby.impl.store.replication.net.ReplicationMessage;
1: import org.apache.derby.impl.store.replication.net.ReplicationMessageReceive;
1: import org.apache.derby.iapi.store.replication.slave.SlaveFactory;
commit:41a2601
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Creates a new instance of <tt>SlaveLogReceiverThread</tt>
1:          * with a debugging-friendly thread name.
1:          */
1:         SlaveLogReceiverThread() {
1:             super("derby.slave.logger-" + dbname);
1:         }
1:         
commit:d9d733a
/////////////////////////////////////////////////////////////////////////
1:         teardownNetwork();
/////////////////////////////////////////////////////////////////////////
1:         teardownNetwork();
/////////////////////////////////////////////////////////////////////////
1:     private void teardownNetwork() {
1:         try {
1:             // Unplug the replication network connection layer
1:             if (receiver != null) {
1:                 receiver.tearDown();
1:                 receiver = null;
1:             }
1:         } catch (IOException ioe) {
0:             ReplicationLogger.logError(null, ioe, dbname);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:                         teardownNetwork();
commit:9e88b9d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.SLAVE_OPERATION_DENIED_WHILE_CONNECTED);
1:     public void failover() throws StandardException {
0:         if (connectedToMaster){
1:             throw StandardException.newException(
1:                 SQLState.SLAVE_OPERATION_DENIED_WHILE_CONNECTED);
1:         }
1:         doFailover();
1:     } 
1: 
1:      * Performs failover on this database. May be called because a
1:      * failover command has been received from the master, or because
1:      * a client has requested a failover after the network connection
1:      * with the master has been lost.
1:      * @see SlaveFactory#failover
1:     private void doFailover() {
/////////////////////////////////////////////////////////////////////////
1:                         doFailover();
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.store.raw.log.LogCounter;
/////////////////////////////////////////////////////////////////////////
1:     /** The instant of the latest log record received from the master 
1:      * and processed so far. Used to check that master and slave log files 
1:      * are in synch */
1:     private volatile long highestLogInstant = -1;
1: 
1:     /**
1:      * Whether or not replication slave mode is still on. Will be set
1:      * to false when slave replication is shut down. The value of this
1:      * variable is checked after every timeout when trying to set up a
1:      * connection to the master, and by the thread that applies log
1:      * chunks received from the master. */
/////////////////////////////////////////////////////////////////////////
1:         logToFile.stopReplicationSlaveRole();
/////////////////////////////////////////////////////////////////////////
1:             // highestLogInstant is -1 until the first log chunk has
1:             // been received from the master. If a log chunk has been
1:             // received, use the instant of the latest received log
1:             // record to synchronize log files. If no log has been
1:             // received yet, use the end position of the log (i.e.,
1:             // logToFile.getFlushedInstant)
1:             if (highestLogInstant != -1) {
1:                 // timeout to check if still in replication slave mode
1:                 receiver.initConnection(DEFAULT_SOCKET_TIMEOUT,
1:                                         highestLogInstant,
1:                                         dbname);
1:             } else {
1:                 // timeout to check if still in replication slave mode
1:                 receiver.initConnection(DEFAULT_SOCKET_TIMEOUT,
1:                                         logToFile.
1:                                         getFirstUnflushedInstantAsLong(),
1:                                         dbname);
1:             }
/////////////////////////////////////////////////////////////////////////
0:                              new Long(LogCounter.
0:                                       getLogFileNumber(logScan.getInstant())),
0:                              new Long(LogCounter.
0:                                       getLogFilePosition(logScan.
0:                                                          getInstant())),
0:                              new Long(LogCounter.
0:                                       getLogFileNumber(localInstant)),
0:                              new Long(LogCounter.
0:                                       getLogFilePosition(localInstant)));
1:                     highestLogInstant = localInstant;
commit:334e9a3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Whether or not this SlaveController has been successfully
1:      * started, including setting up a connection with the master and
1:      * starting the log receiver thread. The client connection that
1:      * initiated slave replication mode on this database will not
1:      * report that slave mode was successfully started (i.e., it will
1:      * hang) until startupSuccessful has been set to true */
1:     private volatile boolean startupSuccessful = false;
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         receiver = new ReplicationMessageReceive(slavehost, slaveport, dbname);
/////////////////////////////////////////////////////////////////////////
1:         startupSuccessful = true;
/////////////////////////////////////////////////////////////////////////
0:             if (receiver != null) {
0:                 receiver.tearDown(); 
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see SlaveFactory#isStarted
1:      */
1:     public boolean isStarted() {
1:         return startupSuccessful;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e,
0:                     dbname, slavehost, String.valueOf(receiver.getPort()));
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             stopSlave();
1:         } catch (StandardException se) {
0:             ReplicationLogger.
0:                 logError(MessageId.REPLICATION_FATAL_ERROR, se, dbname);
1:         }
/////////////////////////////////////////////////////////////////////////
commit:b9c57d5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.db.SlaveDatabase;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
0:     private SlaveDatabase slaveDb;
0:     private volatile boolean connectedToMaster = false;
/////////////////////////////////////////////////////////////////////////
1:      * Will tear down the replication slave service. 
1:     public void stop() { 
1:         if (inReplicationSlaveMode) {
1:             // For some reason, stopSlave or failover have not been
1:             // called yet. Force slave to stop.
1:             try {
1:                 stopSlave(true);
1:             } catch (StandardException se) {
1:                 // do nothing
1:             }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0:         slaveDb = (SlaveDatabase)
0:                 Monitor.findService(Property.DATABASE_MODULE, dbname);
0:         slaveDb.setSlaveFactory(this);
1: 
1:         rawStoreFactory = rawStore;
1: 
1:         try {
1:             logToFile = (LogToFile)logFac;
1:         } catch (ClassCastException cce) {
1:             // Since there are only two implementing classes of
1:             // LogFactory, the class type has to be ReadOnly if it is
1:             // not LogToFile.
1:             throw StandardException.newException(
1:                 SQLState.LOGMODULE_DOES_NOT_SUPPORT_REPLICATION);
1:         }
1: 
1:         logToFile.initializeReplicationSlaveRole();
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void stopSlave() throws StandardException {
1:         try {
0:             if (logReceiverThread != null) {
0:                 logReceiverThread.interrupt();
1:             }
0:         } catch (SecurityException se) {
0:             // Do nothing - the logReceiverThread will get an
0:             // exception when receiver.tearDown is called below
1:         }
1: 
1:         try {
0:             // Unplug the replication network connection layer
0:             receiver.tearDown(); 
0:         } catch (IOException ioe) {
0:             ReplicationLogger.logError(null, ioe, dbname);
1:         }
1: 
0:         logToFile.flushAll();
0:         logToFile.stopReplicationSlaveMode();
1: 
1:      * @see SlaveFactory#stopSlave
1:      */
1:     public void stopSlave(boolean forcedStop) 
1:             throws StandardException {
0:         if (!forcedStop && connectedToMaster){
1:             throw StandardException.newException(
0:                     SQLState.SLAVE_STOP_DENIED_WHILE_CONNECTED);
1:         }
1:         stopSlave();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         logToFile.failoverSlave();
/////////////////////////////////////////////////////////////////////////
0:             connectedToMaster = true;
/////////////////////////////////////////////////////////////////////////
1:      * @param e The reason the connection to the master was lost
1:     private void handleDisconnect(Exception e) {
0:         connectedToMaster = false;
0:             logError(MessageId.REPLICATION_SLAVE_LOST_CONN, e, dbname);
commit:696377a
/////////////////////////////////////////////////////////////////////////
1: public class SlaveController
/////////////////////////////////////////////////////////////////////////
0:         ReplicationLogger.
0:             logError(MessageId.REPLICATION_SLAVE_LOST_CONN, eofe, dbname);
/////////////////////////////////////////////////////////////////////////
0:         ReplicationLogger.
0:             logError(MessageId.REPLICATION_FATAL_ERROR, e, dbname);
commit:0217bc6
/////////////////////////////////////////////////////////////////////////
1:         inReplicationSlaveMode = false;
0:         logToFile.stopReplicationSlaveRole();
1:         Monitor.logTextMessage
1:                 (MessageId.REPLICATION_FAILOVER_SUCCESSFUL, dbname);
/////////////////////////////////////////////////////////////////////////
1:                     case ReplicationMessage.TYPE_FAILOVER:
0:                         failover();
1:                         ReplicationMessage ack = new ReplicationMessage
1:                             (ReplicationMessage.TYPE_ACK, "failover succeeded");
1:                         receiver.sendMessage(ack);
1:                         break;
commit:c458b05
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Attribute;
/////////////////////////////////////////////////////////////////////////
0:         slavehost = properties.getProperty(Attribute.REPLICATION_SLAVE_HOST);
1:         String port = properties.getProperty(Attribute.REPLICATION_SLAVE_PORT);
commit:0f8eece
/////////////////////////////////////////////////////////////////////////
1:                     case ReplicationMessage.TYPE_STOP:
1:                         stopSlave();
1:                         break;
commit:e071963
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.impl.store.raw.log.LogToFile;
0: import org.apache.derby.impl.services.replication.ReplicationLogger;
0: import org.apache.derby.impl.services.replication.net.ReplicationMessage;
0: import org.apache.derby.impl.services.replication.net.ReplicationMessageReceive;
1: import java.io.EOFException;
1: import java.net.SocketTimeoutException;
/////////////////////////////////////////////////////////////////////////
0: public class SlaveController extends ReplicationLogger
1:     implements SlaveFactory, ModuleControl, ModuleSupportable {
1: 
1: 
1:     // How long to wait for a connection to be established with the
1:     // master before timing out. Note that this is done so that we can
1:     // detect if replication slave mode has been stopped. If
1:     // replication mode has not been stopped, a new attempt is made to
1:     // set up the connection. 
1:     // TODO: make this configurable through a property
1:     private static final int DEFAULT_SOCKET_TIMEOUT = 1000; // 1 second
1:     private LogToFile logToFile;
1:     private ReplicationMessageReceive receiver;
0:     private String slavehost;
1:     private String dbname; // The name of the replicated database
1: 
0:     // Whether or not replication slave mode is still on. Will be set
0:     // to false when slave replication is shut down. The value of this
0:     // variable is checked after every timeout when trying to set up a
0:     // connection to the master, and by the thread that applies log
0:     // chunks received from the master.
1:     private volatile boolean inReplicationSlaveMode = true;
1: 
1:     // Used to parse chunks of log records received from the master.
1:     private ReplicationLogScan logScan;
1: 
1:     // Thread that listens for log chunk messages from the master, and
1:     // applies these to the local log
1:     private SlaveLogReceiverThread logReceiverThread;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         slavehost = properties.getProperty(SlaveFactory.SLAVE_HOST);
1: 
1:         dbname = properties.getProperty(SlaveFactory.SLAVE_DB);
/////////////////////////////////////////////////////////////////////////
1:      * thread that applies operations received from the master (in the
1:      * @param logFac The LogFactory ensuring recoverability for this
1:      * database
1:      *
1:      * @exception StandardException Thrown if the slave could not be
1:      * started.
1:     public void startSlave(RawStoreFactory rawStore, LogFactory logFac)
1:         throws StandardException {
1: 
1:         // Retry to setup a connection with the master until a
1:         // connection has been established or until we are no longer
1:         // in replication slave mode
0:         receiver = new ReplicationMessageReceive(slavehost, slaveport);
1:         while (!setupConnection()) {
1:             if (!inReplicationSlaveMode) {
1:                 // If we get here, another thread has called
1:                 // stopSlave() while we waited for a connection with
1:                 // the master. The thread shutting the slave down will
1:                 // clean up anything we did during setupConnection, so
1:                 // simply return.
1:                 return;
1:             }
1:         }
1: 
1:         // Setup the log scan used to parse chunks of log received
1:         // from the master
1:         logScan = new ReplicationLogScan();
1:         try {
0:             logToFile = (LogToFile)logFac;
0:         } catch (ClassCastException cce) {
0:             // Since there are only two implementing classes of
0:             // LogFactory, the class type has to be ReadOnly if it is
0:             // not LogToFile.
0:             throw StandardException.newException(
0:                 SQLState.CANNOT_REPLICATE_READONLY_DATABASE);
1:         }
0:         logToFile.initializeReplicationSlaveRole();
1:         startLogReceiverThread();
1: 
1:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_STARTED, dbname);
/////////////////////////////////////////////////////////////////////////
1:         inReplicationSlaveMode = false;
1: 
0:         // todo: shutdown slave
1:         Monitor.logTextMessage(MessageId.REPLICATION_SLAVE_STOPPED, dbname);
/////////////////////////////////////////////////////////////////////////
0:         // logToFile.setReplicationMode(false);
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////
1:     // Private Methods                                        //
1:     ////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Establish a connection with the replication master. Listens for
1:      * a connection on the slavehost/port for DEFAULT_SOCKET_TIMEOUT
1:      * milliseconds. 
1:      *
1:      * @return true if a connection has been set up with the master,
1:      * false if the connection attempt timed out.
1:      *
1:      * @exception StandardException if an unexpected exception occured
1:      * that prevented a connection with the master.
1:      */
1:     private boolean setupConnection() throws StandardException {
1: 
0:         try {
0:             // timeout to check if still in replication slave mode
0:             receiver.initConnection(DEFAULT_SOCKET_TIMEOUT);
1:             return true; // will not reach this if timeout
1:         } catch (StandardException se) {
1:             throw se;
1:         } catch (Exception e) {
0:             // SocketTimeoutException is wrapped in
0:             // PrivilegedActionException.
0:             Throwable cause = e.getCause();
0:             if (cause instanceof SocketTimeoutException) {
0:                 // Timeout! 
1:                 return false;
1:             } else {
1:                 throw StandardException.newException
0:                     (SQLState.REPLICATION_CONNECTION_EXCEPTION, e, dbname);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Write the reason for the lost connection to the log (derby.log)
1:      * and reconnect with the master. Once the network is up and
1:      * running, a new LogReceiverThread is started. The method returns
1:      * without doing anything if inReplicationSlaveMode=false, which
1:      * means that stopSlave() has been called by another thread.
1:      *
0:      * @param eofe The reason the connection to the master was lost
1:      */
1: 
0:     private void handleDisconnect(EOFException eofe) {
1:         if (!inReplicationSlaveMode) {
1:             return;
1:         }
1: 
0:         logError(MessageId.REPLICATION_SLAVE_LOST_CONN, eofe, dbname);
1: 
0:         try {
1:             while (!setupConnection()) {
1:                 if (!inReplicationSlaveMode) {
1:                     // stopSlave may have been called, turning
1:                     // replication slave mode off. Simply return if
1:                     // that is the case. The thread that called
1:                     // stopSlave will clean up everything.
1:                     return;
1:                 }
1:             }
1: 
1:             startLogReceiverThread();
1:         } catch (StandardException se) {
1:             handleFatalException(se);
1:         }
1:     }
1: 
1:     /**
1:      * Starts the LogReceiverThread that will listen for chunks of log
1:      * records from the master and apply the log records to the local
1:      * log file.
1:      */
1:     private void startLogReceiverThread() {
1:         logReceiverThread = new SlaveLogReceiverThread();
1:         logReceiverThread.start();
1:     }
1: 
1:     /**
1:      * Handles fatal errors for slave replication functionality. These
1:      * are errors that requires us to stop replication. Calling this
1:      * method has the following effects:
1:      *
1:      * 1) Debug messages are written to the log file (usually
1:      *    derby.log) if ReplicationLogger#LOG_REPLICATION_MESSAGES is
1:      *    true.
1:      *
1:      * 2) If the network connection is up, the master is notified of
1:      *    the problem.
1:      *
1:      * 3) All slave replication functionality is stopped, and the
1:      *    database is then shut down without being booted.
1:      *
1:      * The method will return without doing anything if
1:      * inReplicationSlaveMode=false, meaning that stopSlave has been
1:      * called.
1:      *
1:      * @param e The fatal exception that is the reason for calling
1:      * this method
1:      */
1:     private void handleFatalException(Exception e) {
1:         // If inReplicationSlaveMode is false, the stopSlave method in
1:         // this controller has already been called. If so, we ignore
1:         // this fatal error.
1:         if (!inReplicationSlaveMode) {
1:             return;
1:         }
1: 
0:         logError(MessageId.REPLICATION_FATAL_ERROR, e, dbname);
1: 
1:         // todo: notify master of the problem
0:         // todo: rawStoreFactory.stopReplicationSlave();
1:     }
1: 
1: 
1:     ///////////////////////////////////////////////////////////////////////////
1:     // Inner Class - Thread used to apply chunks of log received from master //
1:     ///////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Thread that listens for incoming messages from the master and
1:      * applies chunks of log records to the local log files.
1:      */
1:     private class SlaveLogReceiverThread extends Thread {
1:         public void run() {
0:             // Debug only - println will be removed
0:             System.out.println("Started log receiver thread");
0:             try {
1:                 ReplicationMessage message;
1:                 while (inReplicationSlaveMode) {
1:                     message = receiver.readMessage();
1: 
1:                     switch (message.getType()){
1:                     case ReplicationMessage.TYPE_LOG:
1:                         byte[] logChunk = (byte[])message.getMessage();
1:                         handleLogChunk(logChunk);
1:                         break;
1:                     default:
1:                         // debug; will be removed
1:                         System.out.println("Not handling non-log messages yet "
1:                                            +"- got a type "+message.getType());
1:                         break;
1:                     }
1:                 }
1: 
1:             } catch (EOFException eofe) {
1:                 // Network connection with master has been lost.
1:                 handleDisconnect(eofe);
1:             } catch (StandardException se) {
1:                 handleFatalException(se);
1:             } catch (Exception e) {
1:                 // Exceptions not caused by disconnect are unexpected,
1:                 // and therefore fatal
1:                 StandardException se = 
1:                     StandardException.newException
1:                     (SQLState.REPLICATION_UNEXPECTED_EXCEPTION, e);
1:                 handleFatalException(se);
1:             }
1:         }
1: 
1:         /**
1:          * Parses a chunk of log received from the master, and applies
1:          * the individual log records to the local log file.
1:          *
1:          * @param logChunk A chunk of log records received from the
1:          * master
1:          * @exception StandardException If the chunk of log records
1:          * could not be parsed or the local log file is out of synch
1:          * with the master log file.
1:          */
1:         private void handleLogChunk(byte[] logChunk)
1:             throws StandardException{
1:             logScan.init(logChunk);
1: 
1:             while (logScan.next()){
1:                 if (logScan.isLogFileSwitch()) {
1:                     logToFile.switchLogFile();
1:                 } else {
1: 
1:                     long localInstant = logToFile.
1:                         appendLogRecord(logScan.getData(), 
1:                                         0, 
1:                                         logScan.getDataLength(), 
1:                                         null, 
1:                                         0, 
1:                                         0);
1: 
1:                     // If the log instant of the received log does not
1:                     // match with the local log instant, the log
1:                     // records are not written to the same physical
1:                     // location in the log files. This is fatal since
1:                     // log records are identified by their physical
1:                     // location in the log files.
1:                     if (logScan.getInstant() != localInstant) {
1:                         throw StandardException.newException
1:                             (SQLState.REPLICATION_LOG_OUT_OF_SYNCH,
1:                              dbname,
0:                              new Long(logScan.getInstant()),
0:                              new Long(localInstant));
1: 
1:                     }
1:                 }
1:             }
1:         }
1:     }
1:     ///////////////////////////////////////////////////////////
1:     // END Inner Class                                       //
1:     ///////////////////////////////////////////////////////////
commit:49653be
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class
0:    org.apache.derby.impl.services.replication.slave.SlaveController
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
0: package org.apache.derby.impl.services.replication.slave;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: 
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
1: 
0: import org.apache.derby.iapi.services.replication.slave.SlaveFactory;
1: 
1: import java.util.Properties;
1: 
1: /**
1:  * <p> 
1:  * This is an implementation of the replication slave controller
1:  * service. The service is booted when this instance of Derby will
1:  * have the replication slave role for this database.
1:  * </p> 
1:  * <p>
1:  * Note: The current version of the class is far from complete. Code
1:  * to control the replication slave behavior will be added as more
1:  * parts of the replication functionality is added to Derby. 
1:  * </p>
1:  *
1:  * @see SlaveFactory
1:  */
0: public class SlaveController implements SlaveFactory, ModuleControl,
0:                                         ModuleSupportable {
1: 
1:     private RawStoreFactory rawStoreFactory;
0:     private LogFactory logFactory;
0:     // waiting for code to go into trunk:
0:     //    private NetworkReceive connection; 
1: 
0:     private int slaveport;
1: 
1:     /**
1:      * Empty constructor required by Monitor.bootServiceModule
1:      */
1:     public SlaveController() { }
1: 
1:     ////////////////////////////////////////////////////////////
1:     // Implementation of methods from interface ModuleControl //
1:     ////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Used by Monitor.bootServiceModule to start the service. It will
1:      * set up basic variables 
1:      *
0:      * Not implemented yet
1:      *
1:      * @param create Currently ignored
1:      * @param properties Properties used to start the service in the
1:      * correct mode
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
1:     public void boot(boolean create, Properties properties)
1:         throws StandardException {
1: 
0:         String port = properties.getProperty(SlaveFactory.SLAVE_PORT);
0:         if (port != null) {
0:             slaveport = new Integer(port).intValue();
1:         }
1: 
0:         // Added when Network Service has been committed to trunk
0:         // connection = new NetworkReceive();
1: 
0:         System.out.println("SlaveController booted");
1:     }
1: 
1:     /**
0:      * Will tear down the replication slave service. Should be called
0:      * after either stopSlave or failover have been called.
1:      *
0:      * Not implemented yet
1:      */
0:     public void stop() { }
1: 
1:     ////////////////////////////////////////////////////////////////
1:     // Implementation of methods from interface ModuleSupportable //
1:     ////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Used by Monitor.bootServiceModule to check if this class is
1:      * usable for replication. To be usable, we require that slave
1:      * replication mode is specified in startParams by checking that a
1:      * property with key SlaveFactory.REPLICATION_MODE has the value
1:      * SlaveFactory.SLAVE_MODE.
1:      * @param startParams The properties used to start replication
1:      * @return true if slave repliation is specified, meaning that
1:      * this MasterController is a suitable implementation for the
1:      * SlaveFactory service. False otherwise.
1:      * @see ModuleSupportable#canSupport 
1:      */
1:     public boolean canSupport(Properties startParams) {
1:         String modeParam =
1:             startParams.getProperty(SlaveFactory.REPLICATION_MODE);
1: 
1:         // currently only one attribute: slave replication mode
1:         if (modeParam != null && 
1:             modeParam.equals(SlaveFactory.SLAVE_MODE)) {
1:             return true;
0:         } else {
0:             return false;
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////
1:     // Implementation of methods from interface SlaveFactory //
1:     ///////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Start slave replication. This method establishes a network
1:      * connection with the associated replication master and starts a
0:      * daemon that applies operations received from the master (in the
1:      * form of log records) to the local slave database.
1:      *
0:      * Not implemented yet
1:      *
1:      * @param rawStore The RawStoreFactory for the database
0:      * @param logFac The LogFactory ensuring recoverability for this database
1:      */
0:     public void startSlave(RawStoreFactory rawStore, LogFactory logFac) {
0:         // Added when Network Service has been committed to trunk:
0:         // connection.connect(); // sets up a network connection to the slave
1: 
0:         rawStoreFactory = rawStore;
0:         logFactory = logFac;
1: 
0:         // Add code that initializes replication by setting up a
0:         // network connection with the master, receiving the database
0:         // from the master, make a DaemonService for applying log
0:         // records etc. Repliation should be up and running when this
0:         // method returns.
1: 
0:         System.out.println("SlaveController started");
1:     }
1: 
1:     /**
1:      * Will perform all work that is needed to stop replication
1:      *
0:      * Not implemented yet
1:      */
0:     public void stopSlave() {
0:         System.out.println("SlaveController stopped");
1:     }
1: 
1:     /**
1:      * <p>
0:      * Used to turn this slave instance of the database into a normal
0:      * instance that clients can connect to. This is typically done in
0:      * cases where a fatal error has happened on the master instance
0:      * of the database, or when the master database is unreachable due
0:      * to network problems.
1:      * </p>
1:      * <p>
0:      * By calling failover, this slave instance of the database will
0:      * be recovered so that all committed operations that have been
0:      * received from the master are reflected here. On the other hand,
0:      * operations from transactions where the commit log record has
0:      * not been received from the master will not be reflected.
1:      * </p>
1:      * <p>
0:      * Note that even though an operation has been executed (and even
0:      * committed) on the master, it is not neccessarily reflected in
0:      * the slave instance of the database. This depends on the
0:      * replication strategy used by the MasterFactory.
1:      * </p>
1:      *
0:      * @see org.apache.derby.iapi.services.replication.master.MasterFactory
0:      * @see org.apache.derby.impl.services.replication.master.MasterController#flushedTo
1:      */
0:     public void failover() {
0:         // Apply all received log records, thus completing the boot of
0:         // this database. The database can be connected to after this.
1: 
0:         // // complete recovery of the database 
0:         // logFactory.setReplicationMode(false); 
1: 
0:         // Added when Network Service has been committed to trunk:
0:         // connection.shutdown();
1: 
0:         System.out.println("SlaveController failover");
1:     }
1: 
1: 
1: }
============================================================================