1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.ConglomerateController
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: A conglomerate is an abstract storage structure (they
1:eac0369: correspond to access methods).  The ConglomerateController interface
1:eac0369: is the interface that access manager clients can use to manipulate
1:eac0369: the contents of the underlying conglomerate.
1:eac0369: <p>
1:eac0369: Each conglomerate holds a set of rows.  Each row has a row location.
1:eac0369: The conglomerate provides methods for:
1:eac0369: <ul>
1:eac0369: <li>
1:eac0369: Inserting rows,
1:eac0369: <li>
1:eac0369: Fetching, deleting, and replacing entire rows by row location, and
1:eac0369: <li>
1:eac0369: fetching and updating individual columns of a row identified by row
1:eac0369: location.
1:eac0369: </ul>
1:eac0369: <p>
1:eac0369: Conglomerates do not provide any mechanism for associative access to
1:eac0369: rows within the conglomerate; this type of access is provided by scans
1:eac0369: via the ScanController interface.
1:eac0369: <p>
1:eac0369: Although all conglomerates have the same interface, they have different
1:eac0369: implementations.  The implementation of a conglomerate determines some
1:eac0369: of its user-visible semantics; for example whether the rows are ordered
1:eac0369: or what the types of the rows' columns must be.  The implementation is
1:eac0369: specified by an implementation id.  Currently there are two implementations,
1:eac0369: "heap", and "btree".  The details of their behavior are specified in their
1:eac0369: implementation documentation.  (Currently, only "heap" is implemented).
1:eac0369: <p>
1:eac0369: All conglomerate operations are subject to the transactional isolation
1:eac0369: of the transaction they were opened from.  Transaction rollback will
1:eac0369: close all conglomerates.  Transaction commit will close all non-held
1:eac0369: conglomerates.
1:eac0369: <p>
1:eac0369: Scans are opened from a TransactionController.
1:eac0369: <P>
1:eac0369: A ConglomerateController can handle partial rows. Partial rows
1:eac0369: are described in RowUtil.
1:eac0369: 
1:eac0369: @see TransactionController#openConglomerate
1:eac0369: @see RowUtil
1:eac0369: */
1:eac0369: 
1:eac0369: public interface ConglomerateController extends ConglomPropertyQueryable
1:eac0369: {
1:eac0369:     public static final int ROWISDUPLICATE = 1;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close the conglomerate controller.
1:eac0369:      * <p>
1:eac0369:      * Close the conglomerate controller.  Callers must not use
1:eac0369: 	 * the conglomerate controller after calling close.  It is
1:eac0369: 	 * strongly recommended that callers clear out the reference
1:eac0369: 	 * after closing, e.g., 
1:eac0369: 	 * <p>
1:eac0369: 	 * <blockquote><pre>
1:eac0369: 	 * ConglomerateController cc;
1:eac0369: 	 * cc.close;
1:eac0369: 	 * cc = null;
1:eac0369: 	 * </pre></blockquote>
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void close()
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close conglomerate controller as part of terminating a transaction.
1:eac0369:      * <p>
1:eac0369:      * Use this call to close the conglomerate controller resources as part of
1:eac0369:      * committing or aborting a transaction.  The normal close() routine may 
1:eac0369:      * do some cleanup that is either unnecessary, or not correct due to the 
1:eac0369:      * unknown condition of the controller following a transaction ending error.
1:eac0369:      * Use this call when closing all controllers as part of an abort of a 
1:eac0369:      * transaction.
1:dbed020:      * <p>
1:eac0369:      * This call is meant to only be used internally by the Storage system,
1:eac0369:      * clients of the storage system should use the simple close() interface.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:f2ee915:      * @param closeHeldScan           If true, means to close controller even if
1:eac0369:      *                                it has been opened to be kept opened 
1:eac0369:      *                                across commit.  This is
1:eac0369:      *                                used to close these controllers on abort.
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating that the close has resulted in a real close
1:eac0369:      *                 of the controller.  A held scan will return false if 
1:eac0369:      *                 called by closeForEndTransaction(false), otherwise it 
1:eac0369:      *                 will return true.  A non-held scan will always return 
1:eac0369:      *                 true.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     boolean closeForEndTransaction(boolean closeHeldScan)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Check consistency of a conglomerate.
1:eac0369: 
1:eac0369:     Checks the consistency of the data within a given conglomerate, does not
1:eac0369:     check consistency external to the conglomerate (ie. does not check that 
1:eac0369:     base table row pointed at by a secondary index actually exists).
1:eac0369: 
1:eac0369:     Raises a StandardException on first consistency problem. 
1:eac0369:     
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     void checkConsistency()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Delete a row from the conglomerate.  
1:eac0369: 	@return Returns true if delete was successful, false if the record pointed
1:eac0369: 	at no longer represents a valid record.
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     boolean delete(RowLocation loc)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the (partial) row at the given location.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @param loc             The "RowLocation" which describes the exact row
1:eac0369:      *                        to fetch from the table.
1:eac0369: 	 * @param destRow         The row to read the data into.
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "destRow."  destRow
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369:      *
1:eac0369: 	 * @return Returns true if fetch was successful, false if the record 
1:eac0369:      *         pointed at no longer represents a valid record.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369:     boolean fetch(
1:eac0369:     RowLocation             loc, 
1:eac0369:     DataValueDescriptor[]   destRow, 
1:eac0369:     FormatableBitSet                 validColumns) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the (partial) row at the given location.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @param loc             The "RowLocation" which describes the exact row
1:eac0369:      *                        to fetch from the table.
1:eac0369: 	 * @param destRow         The row to read the data into.
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "destRow."  destRow
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369: 	 * @param waitForLock     If false, then the call will throw a lock timeout
1:eac0369:      *                        exception immediately, if the lock can not be
1:eac0369:      *                        granted without waiting.  If true call will 
1:eac0369:      *                        act exactly as fetch() interface with no 
1:eac0369:      *                        waitForLock parameter.
1:eac0369:      *
1:eac0369: 	 * @return Returns true if fetch was successful, false if the record 
1:eac0369:      *         pointed at no longer represents a valid record.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369:     boolean fetch(
1:eac0369:     RowLocation loc, 
1:eac0369:     DataValueDescriptor[]   destRow, 
1:eac0369:     FormatableBitSet     validColumns,
1:eac0369:     boolean     waitForLock) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the (partial) row at the given location.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - interface NOT SUPPORTED YET!!!!!
1:eac0369:      *
1:eac0369: 	 * @param loc             The "RowLocation" which describes the exact row
1:eac0369:      *                        to fetch from the table.
1:eac0369: 	 * @param destRow         The row to read the data into.
1:eac0369: 	 * @param validColumns    A description of which columns to return from
1:eac0369:      *                        row on the page into "destRow."  destRow,
1:eac0369:      *                        and validColumns work together to
1:eac0369:      *                        describe the row to be returned by the fetch - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a fetched 
1:eac0369:      *                        "row".
1:eac0369: 	 * @param qualifier       An array of qualifiers which, 
1:eac0369:      *                        applied to each key, restrict the rows returned 
1:eac0369:      *                        by the scan.  Rows for which any one of the 
1:eac0369:      *                        qualifiers returns false are not returned by 
1:eac0369:      *                        the scan. If null, all rows are returned.  
1:eac0369:      *                        Qualifiers can only reference columns which are 
1:eac0369:      *                        included in the scanColumnList.  The column id 
1:eac0369:      *                        that a qualifier returns in the column id the 
1:eac0369:      *                        table, not the column id in the partial row being
1:eac0369:      *                        returned.  See openScan() for description of how 
1:eac0369:      *                        qualifiers are applied.
1:eac0369:      *
1:eac0369: 	 * @return Returns true if fetch was successful, false if the record 
1:eac0369:      *         pointed at no longer represents a valid record.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369:     /*
1:eac0369:     boolean fetch(
1:eac0369:     RowLocation             loc, 
1:eac0369:     DataValueDescriptor[]   destRow, 
1:eac0369:     FormatableBitSet                 validColumns, 
1:eac0369:     Qualifier[][]           qualifier)
1:eac0369: 		throws StandardException;
1:eac0369:     */
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Insert a row into the conglomerate.
1:eac0369: 
1:eac0369:     @param row The row to insert into the conglomerate.  The stored
1:eac0369: 	representations of the row's columns are copied into a new row
1:eac0369: 	somewhere in the conglomerate.
1:eac0369: 
1:eac0369: 	@return Returns 0 if insert succeeded.  Returns 
1:eac0369:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:eac0369:     checks and has been created to disallow duplicates, and the row inserted
1:eac0369:     had key columns which were duplicate of a row already in the table.  Other
1:eac0369:     insert failures will raise StandardException's.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	@see RowUtil
1:eac0369:     **/
1:eac0369: 	int insert(DataValueDescriptor[]    row) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * insert row and fetch it's row location in one operation.
1:eac0369:      * <p>
1:eac0369:      * Insert a row into the conglomerate, and store its location in 
1:eac0369:      * the provided destination row location.  The row location must be of the
1:eac0369:      * correct type for this conglomerate (a new row location of the correct 
1:eac0369:      * type can be obtained from newRowLocationTemplate()).
1:eac0369:      *
1:eac0369:      * @param row           The row to insert into the conglomerate.  The 
1:eac0369:      *                      stored representations of the row's columns are 
1:eac0369:      *                      copied into a new row somewhere in the conglomerate.
1:eac0369:      *
1:eac0369:      * @param destRowLocation The rowlocation to read the inserted row location
1:eac0369:      *                      into.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369: 	 * @see RowUtil
1:eac0369:      **/
1:eac0369: 	void insertAndFetchLocation(
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     RowLocation             destRowLocation)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	Return whether this is a keyed conglomerate.
1:eac0369: 	**/
1:eac0369: 	boolean isKeyed();
1:eac0369: 
1:eac0369: 
1:eac0369:     public static final int LOCK_READ         = (0x00000000);
1:eac0369:     public static final int LOCK_UPD          = (0x00000001);
1:eac0369:     public static final int LOCK_INS          = (0x00000002);
1:eac0369:     public static final int LOCK_INS_PREVKEY  = (0x00000004);
1:eac0369:     public static final int LOCK_UPDATE_LOCKS = (0x00000008);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the given row location.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @return true if lock was granted, only can be false if wait was false.
1:eac0369:      *
2:eac0369: 	 * @param loc           The "RowLocation" of the exact row to lock.
1:eac0369:      * @param lock_oper     For what operation are we requesting the lock, this
1:eac0369:      *                      should be one of the following 4 options:
1:eac0369:      *                      LOCK_READ [read lock], 
1:eac0369:      *                      (LOCK_INS | LOCK_UPD) [ lock for insert], 
1:eac0369:      *                      (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for 
1:eac0369:      *                      previous key to insert],
1:eac0369:      *                      (LOCK_UPD) [lock for delete or replace]
1:eac0369:      *                      (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for 
1:eac0369:      *                          update, will upgrade lock later if actual update
1:eac0369:      *                          is take place]
1:eac0369:      * @param wait          Should the lock call wait to be granted?
1:eac0369:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
1:eac0369:      *                      then lock will be released immediately after being
1:eac0369:      *                      granted.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     boolean lockRow(
1:eac0369:     RowLocation     loc,
1:eac0369:     int             lock_oper,
1:eac0369:     boolean         wait,
1:eac0369:     int             lock_duration)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the given record id/page num pair.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access, to lock "special" locks formed from
1:eac0369:      * the Recordhandle.* reserved constants for page specific locks.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @return true if lock was granted, only can be false if wait was false.
1:eac0369:      *
1:f2ee915:      * @param page_num      page number of record to lock.
1:f2ee915:      * @param record_id     record id of record to lock.
1:f2ee915:      * @param lock_oper     For what operation are we requesting the lock, this
1:f2ee915:      *                      should be one of the following 4 options:
1:f2ee915:      *                      LOCK_READ [read lock], 
1:f2ee915:      *                      (LOCK_INS | LOCK_UPD) [ lock for insert], 
1:f2ee915:      *                      (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for 
1:f2ee915:      *                      previous key to insert],
1:f2ee915:      *                      (LOCK_UPD) [lock for delete or replace]
1:f2ee915:      *                      (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for 
1:f2ee915:      *                          update, will upgrade lock later if actual update
1:f2ee915:      *                          is take place]
1:eac0369:      * @param wait          Should the lock call wait to be granted?
1:eac0369:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
1:eac0369:      *                      then lock will be released immediately after being
1:eac0369:      *                      granted.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     boolean lockRow(
1:eac0369:     long            page_num,
1:eac0369:     int             record_id,
1:eac0369:     int             lock_oper,
1:eac0369:     boolean         wait,
1:eac0369:     int             lock_duration)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * UnLock the given row location.
1:eac0369:      * <p>
1:eac0369:      * Should only be called by access.
1:eac0369:      * <p>
1:eac0369:      * This call can be made on a ConglomerateController that was opened
1:eac0369:      * for locking only.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:eac0369:      * obvious that non-access clients should not call this.
1:eac0369:      *
1:eac0369: 	 * @param loc           The "RowLocation" which describes the row to unlock.
1:eac0369:      * @param forUpdate     Row was locked for read or update.
1:eac0369:      * @param row_qualified Row was qualified and returned to the user.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void unlockRowAfterRead(
1:eac0369:     RowLocation     loc,
1:eac0369:     boolean         forUpdate,
1:eac0369:     boolean         row_qualified)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return a row location object of the correct type to be
1:eac0369: 	used in calls to insertAndFetchLocation.
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Replace the (partial) row at the given location.  
1:eac0369: 	@return true if update was successful, returns false if the update 
1:eac0369: 	fails because the record pointed at no longer represents a valid record.
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	@see RowUtil
1:eac0369:     **/
1:eac0369:     boolean replace(
1:eac0369:     RowLocation             loc, 
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 validColumns)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Get information about space used by the conglomerate.
1:eac0369:     **/
1:eac0369:     SpaceInfo getSpaceInfo()
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Dump debugging output to error log.
1:eac0369:      * <p>
1:eac0369:      * Dump information about the conglomerate to error log.
1:eac0369:      * This is only for debugging purposes, does nothing in a delivered 
1:eac0369:      * system, currently.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     void debugConglomerate()
1:eac0369: 		throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * <p>
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f2ee915
/////////////////////////////////////////////////////////////////////////
1:      * @param closeHeldScan           If true, means to close controller even if
/////////////////////////////////////////////////////////////////////////
1:      * @param page_num      page number of record to lock.
1:      * @param record_id     record id of record to lock.
1:      * @param lock_oper     For what operation are we requesting the lock, this
1:      *                      should be one of the following 4 options:
1:      *                      LOCK_READ [read lock], 
1:      *                      (LOCK_INS | LOCK_UPD) [ lock for insert], 
1:      *                      (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for 
1:      *                      previous key to insert],
1:      *                      (LOCK_UPD) [lock for delete or replace]
1:      *                      (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for 
1:      *                          update, will upgrade lock later if actual update
1:      *                          is take place]
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.ConglomerateController
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access;
1: 
1: import org.apache.derby.iapi.store.access.RowUtil;
1: 
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import java.util.Properties;
1: 
1: 
1: /**
1: 
1: A conglomerate is an abstract storage structure (they
1: correspond to access methods).  The ConglomerateController interface
1: is the interface that access manager clients can use to manipulate
1: the contents of the underlying conglomerate.
1: <p>
1: Each conglomerate holds a set of rows.  Each row has a row location.
1: The conglomerate provides methods for:
1: <ul>
1: <li>
1: Inserting rows,
1: <li>
1: Fetching, deleting, and replacing entire rows by row location, and
1: <li>
1: fetching and updating individual columns of a row identified by row
1: location.
1: </ul>
1: <p>
1: Conglomerates do not provide any mechanism for associative access to
1: rows within the conglomerate; this type of access is provided by scans
1: via the ScanController interface.
1: <p>
1: Although all conglomerates have the same interface, they have different
1: implementations.  The implementation of a conglomerate determines some
1: of its user-visible semantics; for example whether the rows are ordered
1: or what the types of the rows' columns must be.  The implementation is
1: specified by an implementation id.  Currently there are two implementations,
1: "heap", and "btree".  The details of their behavior are specified in their
1: implementation documentation.  (Currently, only "heap" is implemented).
1: <p>
1: All conglomerate operations are subject to the transactional isolation
1: of the transaction they were opened from.  Transaction rollback will
1: close all conglomerates.  Transaction commit will close all non-held
1: conglomerates.
1: <p>
1: Scans are opened from a TransactionController.
1: <P>
1: A ConglomerateController can handle partial rows. Partial rows
1: are described in RowUtil.
1: 
1: @see TransactionController#openConglomerate
1: @see RowUtil
1: */
1: 
1: public interface ConglomerateController extends ConglomPropertyQueryable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     public static final int ROWISDUPLICATE = 1;
1: 
1:     /**
1:      * Close the conglomerate controller.
1:      * <p>
1:      * Close the conglomerate controller.  Callers must not use
1: 	 * the conglomerate controller after calling close.  It is
1: 	 * strongly recommended that callers clear out the reference
1: 	 * after closing, e.g., 
1: 	 * <p>
1: 	 * <blockquote><pre>
1: 	 * ConglomerateController cc;
1: 	 * cc.close;
1: 	 * cc = null;
1: 	 * </pre></blockquote>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void close()
1:         throws StandardException;
1: 
1:     /**
1:      * Close conglomerate controller as part of terminating a transaction.
1:      * <p>
1:      * Use this call to close the conglomerate controller resources as part of
1:      * committing or aborting a transaction.  The normal close() routine may 
1:      * do some cleanup that is either unnecessary, or not correct due to the 
1:      * unknown condition of the controller following a transaction ending error.
1:      * Use this call when closing all controllers as part of an abort of a 
1:      * transaction.
0:      * <p)
1:      * This call is meant to only be used internally by the Storage system,
1:      * clients of the storage system should use the simple close() interface.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
0:      * @param closeHeldController     If true, means to close controller even if
1:      *                                it has been opened to be kept opened 
1:      *                                across commit.  This is
1:      *                                used to close these controllers on abort.
1:      *
1: 	 * @return boolean indicating that the close has resulted in a real close
1:      *                 of the controller.  A held scan will return false if 
1:      *                 called by closeForEndTransaction(false), otherwise it 
1:      *                 will return true.  A non-held scan will always return 
1:      *                 true.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     boolean closeForEndTransaction(boolean closeHeldScan)
1: 		throws StandardException;
1: 
1:     /**
1:     Check consistency of a conglomerate.
1: 
1:     Checks the consistency of the data within a given conglomerate, does not
1:     check consistency external to the conglomerate (ie. does not check that 
1:     base table row pointed at by a secondary index actually exists).
1: 
1:     Raises a StandardException on first consistency problem. 
1:     
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     void checkConsistency()
1: 		throws StandardException;
1: 
1:     /**
1:     Delete a row from the conglomerate.  
1: 	@return Returns true if delete was successful, false if the record pointed
1: 	at no longer represents a valid record.
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     boolean delete(RowLocation loc)
1: 		throws StandardException;
1: 
1:     /**
1:      * Fetch the (partial) row at the given location.
1:      * <p>
1:      *
1: 	 * @param loc             The "RowLocation" which describes the exact row
1:      *                        to fetch from the table.
1: 	 * @param destRow         The row to read the data into.
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "destRow."  destRow
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1: 	 * @return Returns true if fetch was successful, false if the record 
1:      *         pointed at no longer represents a valid record.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1:     boolean fetch(
1:     RowLocation             loc, 
1:     DataValueDescriptor[]   destRow, 
1:     FormatableBitSet                 validColumns) 
1: 		throws StandardException;
1: 
1:     /**
1:      * Fetch the (partial) row at the given location.
1:      * <p>
1:      *
1: 	 * @param loc             The "RowLocation" which describes the exact row
1:      *                        to fetch from the table.
1: 	 * @param destRow         The row to read the data into.
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "destRow."  destRow
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1: 	 * @param waitForLock     If false, then the call will throw a lock timeout
1:      *                        exception immediately, if the lock can not be
1:      *                        granted without waiting.  If true call will 
1:      *                        act exactly as fetch() interface with no 
1:      *                        waitForLock parameter.
1:      *
1: 	 * @return Returns true if fetch was successful, false if the record 
1:      *         pointed at no longer represents a valid record.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1:     boolean fetch(
1:     RowLocation loc, 
1:     DataValueDescriptor[]   destRow, 
1:     FormatableBitSet     validColumns,
1:     boolean     waitForLock) 
1: 		throws StandardException;
1: 
1:     /**
1:      * Fetch the (partial) row at the given location.
1:      * <p>
1:      * RESOLVE - interface NOT SUPPORTED YET!!!!!
1:      *
1: 	 * @param loc             The "RowLocation" which describes the exact row
1:      *                        to fetch from the table.
1: 	 * @param destRow         The row to read the data into.
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "destRow."  destRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1: 	 * @param qualifier       An array of qualifiers which, 
1:      *                        applied to each key, restrict the rows returned 
1:      *                        by the scan.  Rows for which any one of the 
1:      *                        qualifiers returns false are not returned by 
1:      *                        the scan. If null, all rows are returned.  
1:      *                        Qualifiers can only reference columns which are 
1:      *                        included in the scanColumnList.  The column id 
1:      *                        that a qualifier returns in the column id the 
1:      *                        table, not the column id in the partial row being
1:      *                        returned.  See openScan() for description of how 
1:      *                        qualifiers are applied.
1:      *
1: 	 * @return Returns true if fetch was successful, false if the record 
1:      *         pointed at no longer represents a valid record.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1:     /*
1:     boolean fetch(
1:     RowLocation             loc, 
1:     DataValueDescriptor[]   destRow, 
1:     FormatableBitSet                 validColumns, 
1:     Qualifier[][]           qualifier)
1: 		throws StandardException;
1:     */
1: 
1: 	/**
1:     Insert a row into the conglomerate.
1: 
1:     @param row The row to insert into the conglomerate.  The stored
1: 	representations of the row's columns are copied into a new row
1: 	somewhere in the conglomerate.
1: 
1: 	@return Returns 0 if insert succeeded.  Returns 
1:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
1:     checks and has been created to disallow duplicates, and the row inserted
1:     had key columns which were duplicate of a row already in the table.  Other
1:     insert failures will raise StandardException's.
1: 
1: 	@exception StandardException Standard exception policy.
1: 	@see RowUtil
1:     **/
1: 	int insert(DataValueDescriptor[]    row) 
1: 		throws StandardException;
1: 
1:     /**
1:      * insert row and fetch it's row location in one operation.
1:      * <p>
1:      * Insert a row into the conglomerate, and store its location in 
1:      * the provided destination row location.  The row location must be of the
1:      * correct type for this conglomerate (a new row location of the correct 
1:      * type can be obtained from newRowLocationTemplate()).
1:      *
1:      * @param row           The row to insert into the conglomerate.  The 
1:      *                      stored representations of the row's columns are 
1:      *                      copied into a new row somewhere in the conglomerate.
1:      *
1:      * @param destRowLocation The rowlocation to read the inserted row location
1:      *                      into.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1: 	 * @see RowUtil
1:      **/
1: 	void insertAndFetchLocation(
1:     DataValueDescriptor[]   row, 
1:     RowLocation             destRowLocation)
1: 		throws StandardException;
1: 
1:     /**
1: 	Return whether this is a keyed conglomerate.
1: 	**/
1: 	boolean isKeyed();
1: 
1: 
1:     public static final int LOCK_READ         = (0x00000000);
1:     public static final int LOCK_UPD          = (0x00000001);
1:     public static final int LOCK_INS          = (0x00000002);
1:     public static final int LOCK_INS_PREVKEY  = (0x00000004);
1:     public static final int LOCK_UPDATE_LOCKS = (0x00000008);
1: 
1:     /**
1:      * Lock the given row location.
1:      * <p>
1:      * Should only be called by access.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @return true if lock was granted, only can be false if wait was false.
1:      *
1: 	 * @param loc           The "RowLocation" of the exact row to lock.
1:      * @param lock_oper     For what operation are we requesting the lock, this
1:      *                      should be one of the following 4 options:
1:      *                      LOCK_READ [read lock], 
1:      *                      (LOCK_INS | LOCK_UPD) [ lock for insert], 
1:      *                      (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for 
1:      *                      previous key to insert],
1:      *                      (LOCK_UPD) [lock for delete or replace]
1:      *                      (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for 
1:      *                          update, will upgrade lock later if actual update
1:      *                          is take place]
1:      * @param wait          Should the lock call wait to be granted?
1:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
1:      *                      then lock will be released immediately after being
1:      *                      granted.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     boolean lockRow(
1:     RowLocation     loc,
1:     int             lock_oper,
1:     boolean         wait,
1:     int             lock_duration)
1:         throws StandardException;
1: 
1:     /**
1:      * Lock the given record id/page num pair.
1:      * <p>
1:      * Should only be called by access, to lock "special" locks formed from
1:      * the Recordhandle.* reserved constants for page specific locks.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @return true if lock was granted, only can be false if wait was false.
1:      *
1: 	 * @param loc           The "RowLocation" of the exact row to lock.
0:      * @param forUpdate     Lock the record for read or write.
0:      * @param forInsert     Lock the record for insert?
1:      * @param wait          Should the lock call wait to be granted?
1:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
1:      *                      then lock will be released immediately after being
1:      *                      granted.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     boolean lockRow(
1:     long            page_num,
1:     int             record_id,
1:     int             lock_oper,
1:     boolean         wait,
1:     int             lock_duration)
1:         throws StandardException;
1: 
1:     /**
1:      * UnLock the given row location.
1:      * <p>
1:      * Should only be called by access.
1:      * <p>
1:      * This call can be made on a ConglomerateController that was opened
1:      * for locking only.
1:      * <p>
1:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
1:      * obvious that non-access clients should not call this.
1:      *
1: 	 * @param loc           The "RowLocation" which describes the row to unlock.
1:      * @param forUpdate     Row was locked for read or update.
1:      * @param row_qualified Row was qualified and returned to the user.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void unlockRowAfterRead(
1:     RowLocation     loc,
1:     boolean         forUpdate,
1:     boolean         row_qualified)
1:         throws StandardException;
1: 
1: 	/**
1: 	Return a row location object of the correct type to be
1: 	used in calls to insertAndFetchLocation.
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	RowLocation newRowLocationTemplate()
1: 		throws StandardException;
1: 
1: 	/**
1:     Replace the (partial) row at the given location.  
1: 	@return true if update was successful, returns false if the update 
1: 	fails because the record pointed at no longer represents a valid record.
1: 	@exception StandardException Standard exception policy.
1: 	@see RowUtil
1:     **/
1:     boolean replace(
1:     RowLocation             loc, 
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 validColumns)
1: 		throws StandardException;
1: 
1:     /**
1:     Get information about space used by the conglomerate.
1:     **/
1:     SpaceInfo getSpaceInfo()
1:         throws StandardException;
1: 
1:     /**
1:      * Dump debugging output to error log.
1:      * <p>
1:      * Dump information about the conglomerate to error log.
1:      * This is only for debugging purposes, does nothing in a delivered 
1:      * system, currently.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void debugConglomerate()
1: 		throws StandardException;
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access;
0: 
0: import org.apache.derby.iapi.store.access.RowUtil;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.util.Properties;
0: 
0: 
0: /**
0: 
0: A conglomerate is an abstract storage structure (they
0: correspond to access methods).  The ConglomerateController interface
0: is the interface that access manager clients can use to manipulate
0: the contents of the underlying conglomerate.
0: <p>
0: Each conglomerate holds a set of rows.  Each row has a row location.
0: The conglomerate provides methods for:
0: <ul>
0: <li>
0: Inserting rows,
0: <li>
0: Fetching, deleting, and replacing entire rows by row location, and
0: <li>
0: fetching and updating individual columns of a row identified by row
0: location.
0: </ul>
0: <p>
0: Conglomerates do not provide any mechanism for associative access to
0: rows within the conglomerate; this type of access is provided by scans
0: via the ScanController interface.
0: <p>
0: Although all conglomerates have the same interface, they have different
0: implementations.  The implementation of a conglomerate determines some
0: of its user-visible semantics; for example whether the rows are ordered
0: or what the types of the rows' columns must be.  The implementation is
0: specified by an implementation id.  Currently there are two implementations,
0: "heap", and "btree".  The details of their behavior are specified in their
0: implementation documentation.  (Currently, only "heap" is implemented).
0: <p>
0: All conglomerate operations are subject to the transactional isolation
0: of the transaction they were opened from.  Transaction rollback will
0: close all conglomerates.  Transaction commit will close all non-held
0: conglomerates.
0: <p>
0: Scans are opened from a TransactionController.
0: <P>
0: A ConglomerateController can handle partial rows. Partial rows
0: are described in RowUtil.
0: 
0: @see TransactionController#openConglomerate
0: @see RowUtil
0: */
0: 
0: public interface ConglomerateController extends ConglomPropertyQueryable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     public static final int ROWISDUPLICATE = 1;
0: 
0:     /**
0:      * Close the conglomerate controller.
0:      * <p>
0:      * Close the conglomerate controller.  Callers must not use
0: 	 * the conglomerate controller after calling close.  It is
0: 	 * strongly recommended that callers clear out the reference
0: 	 * after closing, e.g., 
0: 	 * <p>
0: 	 * <blockquote><pre>
0: 	 * ConglomerateController cc;
0: 	 * cc.close;
0: 	 * cc = null;
0: 	 * </pre></blockquote>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void close()
0:         throws StandardException;
0: 
0:     /**
0:      * Close conglomerate controller as part of terminating a transaction.
0:      * <p>
0:      * Use this call to close the conglomerate controller resources as part of
0:      * committing or aborting a transaction.  The normal close() routine may 
0:      * do some cleanup that is either unnecessary, or not correct due to the 
0:      * unknown condition of the controller following a transaction ending error.
0:      * Use this call when closing all controllers as part of an abort of a 
0:      * transaction.
0:      * <p)
0:      * This call is meant to only be used internally by the Storage system,
0:      * clients of the storage system should use the simple close() interface.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0:      * @param closeHeldController     If true, means to close controller even if
0:      *                                it has been opened to be kept opened 
0:      *                                across commit.  This is
0:      *                                used to close these controllers on abort.
0:      *
0: 	 * @return boolean indicating that the close has resulted in a real close
0:      *                 of the controller.  A held scan will return false if 
0:      *                 called by closeForEndTransaction(false), otherwise it 
0:      *                 will return true.  A non-held scan will always return 
0:      *                 true.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     boolean closeForEndTransaction(boolean closeHeldScan)
0: 		throws StandardException;
0: 
0:     /**
0:     Check consistency of a conglomerate.
0: 
0:     Checks the consistency of the data within a given conglomerate, does not
0:     check consistency external to the conglomerate (ie. does not check that 
0:     base table row pointed at by a secondary index actually exists).
0: 
0:     Raises a StandardException on first consistency problem. 
0:     
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     void checkConsistency()
0: 		throws StandardException;
0: 
0:     /**
0:     Delete a row from the conglomerate.  
0: 	@return Returns true if delete was successful, false if the record pointed
0: 	at no longer represents a valid record.
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     boolean delete(RowLocation loc)
0: 		throws StandardException;
0: 
0:     /**
0:      * Fetch the (partial) row at the given location.
0:      * <p>
0:      *
0: 	 * @param loc             The "RowLocation" which describes the exact row
0:      *                        to fetch from the table.
0: 	 * @param destRow         The row to read the data into.
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "destRow."  destRow
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0: 	 * @return Returns true if fetch was successful, false if the record 
0:      *         pointed at no longer represents a valid record.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     boolean fetch(
0:     RowLocation             loc, 
0:     DataValueDescriptor[]   destRow, 
0:     FormatableBitSet                 validColumns) 
0: 		throws StandardException;
0: 
0:     /**
0:      * Fetch the (partial) row at the given location.
0:      * <p>
0:      *
0: 	 * @param loc             The "RowLocation" which describes the exact row
0:      *                        to fetch from the table.
0: 	 * @param destRow         The row to read the data into.
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "destRow."  destRow
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0: 	 * @param waitForLock     If false, then the call will throw a lock timeout
0:      *                        exception immediately, if the lock can not be
0:      *                        granted without waiting.  If true call will 
0:      *                        act exactly as fetch() interface with no 
0:      *                        waitForLock parameter.
0:      *
0: 	 * @return Returns true if fetch was successful, false if the record 
0:      *         pointed at no longer represents a valid record.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     boolean fetch(
0:     RowLocation loc, 
0:     DataValueDescriptor[]   destRow, 
0:     FormatableBitSet     validColumns,
0:     boolean     waitForLock) 
0: 		throws StandardException;
0: 
0:     /**
0:      * Fetch the (partial) row at the given location.
0:      * <p>
0:      * RESOLVE - interface NOT SUPPORTED YET!!!!!
0:      *
0: 	 * @param loc             The "RowLocation" which describes the exact row
0:      *                        to fetch from the table.
0: 	 * @param destRow         The row to read the data into.
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "destRow."  destRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0: 	 * @param qualifier       An array of qualifiers which, 
0:      *                        applied to each key, restrict the rows returned 
0:      *                        by the scan.  Rows for which any one of the 
0:      *                        qualifiers returns false are not returned by 
0:      *                        the scan. If null, all rows are returned.  
0:      *                        Qualifiers can only reference columns which are 
0:      *                        included in the scanColumnList.  The column id 
0:      *                        that a qualifier returns in the column id the 
0:      *                        table, not the column id in the partial row being
0:      *                        returned.  See openScan() for description of how 
0:      *                        qualifiers are applied.
0:      *
0: 	 * @return Returns true if fetch was successful, false if the record 
0:      *         pointed at no longer represents a valid record.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     /*
0:     boolean fetch(
0:     RowLocation             loc, 
0:     DataValueDescriptor[]   destRow, 
0:     FormatableBitSet                 validColumns, 
0:     Qualifier[][]           qualifier)
0: 		throws StandardException;
0:     */
0: 
0: 	/**
0:     Insert a row into the conglomerate.
0: 
0:     @param row The row to insert into the conglomerate.  The stored
0: 	representations of the row's columns are copied into a new row
0: 	somewhere in the conglomerate.
0: 
0: 	@return Returns 0 if insert succeeded.  Returns 
0:     ConglomerateController.ROWISDUPLICATE if conglomerate supports uniqueness
0:     checks and has been created to disallow duplicates, and the row inserted
0:     had key columns which were duplicate of a row already in the table.  Other
0:     insert failures will raise StandardException's.
0: 
0: 	@exception StandardException Standard exception policy.
0: 	@see RowUtil
0:     **/
0: 	int insert(DataValueDescriptor[]    row) 
0: 		throws StandardException;
0: 
0:     /**
0:      * insert row and fetch it's row location in one operation.
0:      * <p>
0:      * Insert a row into the conglomerate, and store its location in 
0:      * the provided destination row location.  The row location must be of the
0:      * correct type for this conglomerate (a new row location of the correct 
0:      * type can be obtained from newRowLocationTemplate()).
0:      *
0:      * @param row           The row to insert into the conglomerate.  The 
0:      *                      stored representations of the row's columns are 
0:      *                      copied into a new row somewhere in the conglomerate.
0:      *
0:      * @param destRowLocation The rowlocation to read the inserted row location
0:      *                      into.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0: 	void insertAndFetchLocation(
0:     DataValueDescriptor[]   row, 
0:     RowLocation             destRowLocation)
0: 		throws StandardException;
0: 
0:     /**
0: 	Return whether this is a keyed conglomerate.
0: 	**/
0: 	boolean isKeyed();
0: 
0: 
0:     public static final int LOCK_READ         = (0x00000000);
0:     public static final int LOCK_UPD          = (0x00000001);
0:     public static final int LOCK_INS          = (0x00000002);
0:     public static final int LOCK_INS_PREVKEY  = (0x00000004);
0:     public static final int LOCK_UPDATE_LOCKS = (0x00000008);
0: 
0:     /**
0:      * Lock the given row location.
0:      * <p>
0:      * Should only be called by access.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @return true if lock was granted, only can be false if wait was false.
0:      *
0: 	 * @param loc           The "RowLocation" of the exact row to lock.
0:      * @param lock_oper     For what operation are we requesting the lock, this
0:      *                      should be one of the following 4 options:
0:      *                      LOCK_READ [read lock], 
0:      *                      (LOCK_INS | LOCK_UPD) [ lock for insert], 
0:      *                      (LOCK_INSERT_PREVKEY | LOCK_UPD) [lock for 
0:      *                      previous key to insert],
0:      *                      (LOCK_UPD) [lock for delete or replace]
0:      *                      (LOCK_UPD | LOCK_UPDATE_LOCKS) [lock scan for 
0:      *                          update, will upgrade lock later if actual update
0:      *                          is take place]
0:      * @param wait          Should the lock call wait to be granted?
0:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
0:      *                      then lock will be released immediately after being
0:      *                      granted.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     boolean lockRow(
0:     RowLocation     loc,
0:     int             lock_oper,
0:     boolean         wait,
0:     int             lock_duration)
0:         throws StandardException;
0: 
0:     /**
0:      * Lock the given record id/page num pair.
0:      * <p>
0:      * Should only be called by access, to lock "special" locks formed from
0:      * the Recordhandle.* reserved constants for page specific locks.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @return true if lock was granted, only can be false if wait was false.
0:      *
0: 	 * @param loc           The "RowLocation" of the exact row to lock.
0:      * @param forUpdate     Lock the record for read or write.
0:      * @param forInsert     Lock the record for insert?
0:      * @param wait          Should the lock call wait to be granted?
0:      * @param lock_duration If set to TransactionManager.LOCK_INSTANT_DURATION,
0:      *                      then lock will be released immediately after being
0:      *                      granted.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     boolean lockRow(
0:     long            page_num,
0:     int             record_id,
0:     int             lock_oper,
0:     boolean         wait,
0:     int             lock_duration)
0:         throws StandardException;
0: 
0:     /**
0:      * UnLock the given row location.
0:      * <p>
0:      * Should only be called by access.
0:      * <p>
0:      * This call can be made on a ConglomerateController that was opened
0:      * for locking only.
0:      * <p>
0:      * RESOLVE (mikem) - move this call to ConglomerateManager so it is
0:      * obvious that non-access clients should not call this.
0:      *
0: 	 * @param loc           The "RowLocation" which describes the row to unlock.
0:      * @param forUpdate     Row was locked for read or update.
0:      * @param row_qualified Row was qualified and returned to the user.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void unlockRowAfterRead(
0:     RowLocation     loc,
0:     boolean         forUpdate,
0:     boolean         row_qualified)
0:         throws StandardException;
0: 
0: 	/**
0: 	Return a row location object of the correct type to be
0: 	used in calls to insertAndFetchLocation.
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	RowLocation newRowLocationTemplate()
0: 		throws StandardException;
0: 
0: 	/**
0:     Replace the (partial) row at the given location.  
0: 	@return true if update was successful, returns false if the update 
0: 	fails because the record pointed at no longer represents a valid record.
0: 	@exception StandardException Standard exception policy.
0: 	@see RowUtil
0:     **/
0:     boolean replace(
0:     RowLocation             loc, 
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 validColumns)
0: 		throws StandardException;
0: 
0:     /**
0:     Get information about space used by the conglomerate.
0:     **/
0:     SpaceInfo getSpaceInfo()
0:         throws StandardException;
0: 
0:     /**
0:      * Dump debugging output to error log.
0:      * <p>
0:      * Dump information about the conglomerate to error log.
0:      * This is only for debugging purposes, does nothing in a delivered 
0:      * system, currently.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     void debugConglomerate()
0: 		throws StandardException;
0: }
============================================================================