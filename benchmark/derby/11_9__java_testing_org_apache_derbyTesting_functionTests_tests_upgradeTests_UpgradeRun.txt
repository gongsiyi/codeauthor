1:10e07a5: /*
1:740f64e: 
1:10e07a5: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeRun
1:ca1a8f2: 
1:10e07a5: Licensed to the Apache Software Foundation (ASF) under one or more
1:10e07a5: contributor license agreements.  See the NOTICE file distributed with
1:10e07a5: this work for additional information regarding copyright ownership.
1:10e07a5: The ASF licenses this file to You under the Apache License, Version 2.0
1:10e07a5: (the "License"); you may not use this file except in compliance with
1:10e07a5: the License.  You may obtain a copy of the License at
1:2a42e33: 
1:10e07a5:    http://www.apache.org/licenses/LICENSE-2.0
1:cdda215: 
1:10e07a5: Unless required by applicable law or agreed to in writing, software
1:10e07a5: distributed under the License is distributed on an "AS IS" BASIS,
1:10e07a5: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:10e07a5: See the License for the specific language governing permissions and
1:10e07a5: limitations under the License.
1:cdda215: 
3:10e07a5: */
1:10e07a5: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
2:cdda215: 
1:9ba17d8: import java.lang.reflect.Method;
1:10e07a5: import java.util.Properties;
1:10e07a5: import junit.extensions.TestSetup;
1:10e07a5: import junit.framework.Test;
1:740f64e: import org.apache.derbyTesting.functionTests.tests.jdbcapi.DatabaseMetaDataTest;
1:daa4827: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:10e07a5: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:10e07a5: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:10e07a5: import org.apache.derbyTesting.junit.TestConfiguration;
1:cdda215: 
1:ca1a8f2: /**
1:10e07a5:  * Utility class for creating a set of tests that
1:10e07a5:  * comprise a complete upgrade run through all
1:10e07a5:  * five phases. This includes handling the
1:10e07a5:  * class loading for the old jar files
1:10e07a5:  * and setting up the configuration to
1:10e07a5:  * use a single use database and DataSource for
1:10e07a5:  * connections.
3:10e07a5:  *
1:10e07a5:  */
1:e65365e: class UpgradeRun extends UpgradeClassLoader
1:e65365e: {
1:ca1a8f2:     
1:daf5fa3:     /**
1:ca1a8f2:      * Set of additional databases for tests that
1:ca1a8f2:      * require a one-off database. The additional
1:ca1a8f2:      * database decorator wraps all the tests and phases.
1:ca1a8f2:      * They are only created if a test opens a
1:e6cce75:      * connection against them. In hard upgrade the test
1:e6cce75:      * must explictly upgrade the database.
1:aaa1403:      * The databases are shutdown at the end of each phase, unless
1:aaa1403:      * "NoShutDown" is specified. The latter is used by databases
1:aaa1403:      * which need sqlAuthorization (specified by test). This thwarts
1:aaa1403:      * normal shutdown since credentials are required so shutdown is
1:aaa1403:      * done in test, not by the tearDown methods. See
1:acfdb76:      * Changes10_5#testSQLRoles for example.
1:ca1a8f2:      */
1:aaa1403: 
1:aaa1403:     static final AdditionalDb[] ADDITIONAL_DBS = {
1:aaa1403:         new AdditionalDb("COLLATED_DB_10_3", true), // db with territory
1:aaa1403:                                                     // based collation
1:aaa1403:         new AdditionalDb("NO_ENCRYPT_10_2", true),
1:aaa1403:         new AdditionalDb("ENCRYPT_10_2",  true),
1:60edeb0:         new AdditionalDb("ROLES_10_5", false),
1:1ede0a8:         new AdditionalDb("BUILTIN_10_9", false),
1:7b6ad6d:         new AdditionalDb("DERBY-4753", true),
1:ca1a8f2:     };
1:daa4827:     
1:cde004c:     public static Test suite(final int[] version, boolean useCreateOnUpgrade) {
1:daa4827:         
1:e65365e:         ClassLoader oldLoader = makeClassLoader( version );
1:daa4827:         
1:cdda215:         // If no jars then just skip.
1:cdda215:         if (oldLoader == null)
1:cdda215:         {
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite(
1:cdda215:                     "Empty: Skipped upgrade Tests (no jars) for " + getTextVersion(version));
1:cdda215:             return suite;
1:daa4827:         }
1:daa4827:         
1:daa4827: 
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(
1:cdda215:                 "Upgrade Tests from " + getTextVersion(version));
1:daa4827:         BaseTestCase.traceit("Prepare to run upgrade tests from " + getTextVersion(version));
1:daa4827: 
1:daa4827:         
1:10e07a5:         for (int phase = 0;
1:10e07a5:               phase < UpgradeChange.PHASES.length; phase++)
1:10e07a5:         {
1:10e07a5:             ClassLoader loader = null;
1:10e07a5:             switch (phase)
1:10e07a5:             {
1:10e07a5:             case UpgradeChange.PH_CREATE:
1:10e07a5:             case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:10e07a5:             case UpgradeChange.PH_POST_HARD_UPGRADE:
1:10e07a5:                 loader = oldLoader;
1:10e07a5:                 break;
1:10e07a5:             case UpgradeChange.PH_SOFT_UPGRADE:
1:10e07a5:             case UpgradeChange.PH_HARD_UPGRADE:
1:10e07a5:                 break;
1:aaa1403:                 
1:daa4827:             }
1:daa4827:             Test phaseTests = baseSuite(getTextVersion(version)
1:daa4827:                     + " Upgrade Phase: " + UpgradeChange.PHASES[phase] + " ",
1:daf5fa3:                     phase, version);
1:aaa1403:             
1:000d4bc:             Test phaseSet = new PhaseChanger(phaseTests, phase, loader, version, useCreateOnUpgrade);
1:8e20531:             phaseSet = handleJavaSE6(phase, version, phaseSet);
1:8e20531:             suite.addTest(phaseSet);
1:daa4827:         }
1:aaa1403:           
1:10e07a5:         TestSetup setup = TestConfiguration.singleUseDatabaseDecorator(suite);
1:e3f8545:         
1:ca1a8f2:         for (int i = 0; i < ADDITIONAL_DBS.length; i++)
1:ca1a8f2:         {
1:aaa1403:             if (ADDITIONAL_DBS[i].shutDown) {
1:aaa1403:                 setup = TestConfiguration.additionalDatabaseDecorator(
1:aaa1403:                     setup, ADDITIONAL_DBS[i].logicalName);
1:aaa1403:             } else {
1:aaa1403:                 setup = TestConfiguration.additionalDatabaseDecoratorNoShutdown(
1:aaa1403:                     setup, ADDITIONAL_DBS[i].logicalName);
1:aaa1403:             }
1:aaa1403:         }
1:e3f8545:         
1:10e07a5:         Properties preReleaseUpgrade = new Properties();
1:10e07a5:         preReleaseUpgrade.setProperty(
1:10e07a5:                 "derby.database.allowPreReleaseUpgrade", "true");
1:e3f8545:         
1:10e07a5:         setup = new SystemPropertyTestSetup(setup, preReleaseUpgrade);
1:e3f8545:    
1:10e07a5:         return SecurityManagerSetup.noSecurityManager(setup);
1:e3f8545:     }
1:e3f8545:     
1:ae72a30:     /**
1:daf5fa3:      * Add the tests from the various Changes classes (sub-classes
1:daf5fa3:      * of UpgradeChange) to the base suite which corresponds to
1:daf5fa3:      * a single phase of a run against an old database version.
1:daf5fa3:      * <BR>
1:daf5fa3:      * Changes are only added if the old version is older than
1:daf5fa3:      * then version the changes represent. Thus Changes10_2
1:daf5fa3:      * is not added if the old database (upgrade from) is already
1:daf5fa3:      * at 10.2, since Changes10_2 is intended to test upgrade
1:daf5fa3:      * from an older version to 10.2.
1:daf5fa3:      * <BR>
1:daf5fa3:      * This is for two reasons:
1:daf5fa3:      * <OL>
1:daf5fa3:      * <LI> Prevents an endless increase in number of test
1:daf5fa3:      * cases that do no real testing. 
1:daf5fa3:      * <LI> Simplifies test fixtures by allowing them to
1:daf5fa3:      * focus on cases where testing is required, and not
1:daf5fa3:      * handling all future situations.
1:daf5fa3:      * </OL>
1:daf5fa3:      * 
1:daf5fa3:      */
1:daf5fa3:     private static Test baseSuite(String name, int phase, int[] version) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:ca1a8f2:         
1:daf5fa3:         int oldMajor = version[0];
1:daf5fa3:         int oldMinor = version[1];
1:daa4827: 
1:cdda215:         // No connection is expected in the post hard upgrade
1:cdda215:         // phase, so don't bother adding test fixtures.
1:cdda215:         if (phase != UpgradeChange.PH_POST_HARD_UPGRADE)
1:cdda215:         {
1:cdda215:             suite.addTest(BasicSetup.suite());
1:8e20531:             
1:daf5fa3:             if (oldMajor == 10) {
1:daf5fa3:                 if (oldMinor < 1)
1:daf5fa3:                     suite.addTest(Changes10_1.suite());
1:daf5fa3:                 if (oldMinor < 2)
1:daf5fa3:                    suite.addTest(Changes10_2.suite());
1:bbe895f:                 if (oldMinor < 3) {
1:bbe895f:                    //Pass the phase as a parameter to the
1:bbe895f:                    //suite method that will enable the test to add existing
1:bbe895f:                    //junit tests after checking for the phase of the current
1:bbe895f:                    //run. 
1:bbe895f:                    suite.addTest(Changes10_3.suite(phase));
1:bbe895f:                 }
1:29e9328:                 if (oldMinor < 4)
1:29e9328:                 	suite.addTest(Changes10_4.suite(phase));
1:963d9f4:                 if (oldMinor < 5)
1:963d9f4:                 	suite.addTest(Changes10_5.suite(phase));
1:a6f35a4:                 if (oldMinor < 6)
1:a6f35a4:                 	suite.addTest(Changes10_6.suite(phase));
1:a584888:                 if (oldMinor < 7)
1:a584888:                 	suite.addTest(Changes10_7.suite(phase));
1:6e000cc:                 if (oldMinor < 9)
1:6e000cc:                 	suite.addTest(Changes10_9.suite(phase));
1:f448bbb:                 if (oldMinor < 10)
1:f448bbb:                 	suite.addTest(Changes10_10.suite(phase));
1:d9878ca:                 if (oldMinor < 11)
1:d9878ca:                     suite.addTest(Changes10_11.suite(phase));
1:a826375:                 if (oldMinor < 12)
1:a826375:                     suite.addTest(Changes10_12.suite(phase));
1:5b838fd:                 if (oldMinor < 13)
1:5b838fd:                     suite.addTest(Changes10_13.suite(phase));
1:2e3ed68:             }
1:8e20531:             
1:740f64e:             // Add DatabaseMetaData tests. Since metadata
1:740f64e:             // queries may be changed by an upgrade it is
1:740f64e:             // an area that is subject to bugs. Here we run
1:740f64e:             // all or a subset of DatabaseMetaData tests
1:740f64e:             // as required.
1:740f64e:             switch (phase) {
1:740f64e:             case UpgradeChange.PH_CREATE:
1:740f64e:                 // No need to test, should have been covered
1:740f64e:                 // by the original tests of the old release 
1:740f64e:                 break;
1:740f64e:                 
1:740f64e:             case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:740f64e:                 // reverted to old engine and metadata queries
1:740f64e:                 // must continue to work. Cannot run the full
1:740f64e:                 // set of tests here as the full DatabaseMetaDataTest
1:740f64e:                 // functionality may not match the old engine.
1:740f64e:                 // However we run individual fixtures that exercise
1:740f64e:                 // the code path for the metadata queries.
1:740f64e:                 //
1:740f64e:                 // Any specific change to the metadata queries
1:740f64e:                 // due to upgrade (e.g. fixing a system catalog)
1:740f64e:                 // must be tested in a ChangesM_n fixture.
1:740f64e:                 break;
1:740f64e:             
1:740f64e:             // Running at the new level so the full functionality
1:740f64e:             // of DatabaseMetaData should be available.
1:740f64e:             case UpgradeChange.PH_SOFT_UPGRADE:
1:740f64e:             case UpgradeChange.PH_HARD_UPGRADE:
1:cde004c:                 runDataBaseMetaDataTest(suite, oldMinor);
1:740f64e:                 break;
1:e3f8545:             }
1:e3f8545:         }
1:24390c9:         else
1:24390c9:         {
1:24390c9:             suite.addTest(new BasicSetup("noConnectionAfterHardUpgrade"));
1:24390c9:         }
1:ae72a30: 
1:ae72a30:         if (phase == UpgradeChange.PH_SOFT_UPGRADE &&
1:ae72a30:                 suffersFromDerby4835or5289(version)) {
1:ae72a30:             // If the old version suffers from DERBY-4835 or DERBY-5289,
1:ae72a30:             // it may not be able to read the trigger plans after soft upgrade.
1:ae72a30:             // Drop all trigger plans at the end of soft upgrade to prevent
1:ae72a30:             // problems in the post soft upgrade phase.
1:ae72a30:             suite.addTest(new BasicSetup("dropAllTriggerPlans"));
1:ae72a30:         }
1:ae72a30: 
1:10e07a5:         return TestConfiguration.connectionDSDecorator(suite);
1:ca1a8f2:     }
1:ae72a30: 
1:35067bf:     /**
1:ae72a30:      * Check if a version suffers from DERBY-4835 or DERBY-5289.
1:ae72a30:      */
1:ae72a30:     private static boolean suffersFromDerby4835or5289(int[] version) {
1:ae72a30:         // DERBY-4835 affects the 10.5 and 10.6 branches, and was fixed in
1:ae72a30:         // 10.5.3.2 and 10.6.2.3.
1:ae72a30:         // DERBY-5289 affects the 10.5, 10.6, 10.7 and 10.8 branches, and was
1:ae72a30:         // fixed in 10.5.3.1, 10.6.2.2, 10.7.1.4 and 10.8.2.2.
1:ae72a30:         return
1:ae72a30:                 (lessThan(new int[] { 10, 5, 0, 0 }, version) &&
1:ae72a30:                  lessThan(version, new int[] { 10, 5, 3, 2 }))
1:ae72a30:             ||
1:ae72a30:                 (lessThan(new int[] { 10, 6, 0, 0 }, version) &&
1:ae72a30:                  lessThan(version, new int[] { 10, 6, 2, 3 }))
1:ae72a30:             ||
1:ae72a30:                 (lessThan(new int[] { 10, 7, 0, 0 }, version) &&
1:ae72a30:                  lessThan(version, new int[] { 10, 7, 1, 4 }))
1:ae72a30:             ||
1:ae72a30:                 (lessThan(new int[] { 10, 8, 0, 0 }, version) &&
1:ae72a30:                  lessThan(version, new int[] { 10, 8, 2, 2 }));
1:ae72a30:     }
1:daf5fa3:     
1:8e20531:     /**
1:35067bf:      * Return true if and only if the left version is less than the
1:35067bf:      * right version.
1:35067bf:      */
1:c34c1d2:     static boolean lessThan( int[] left, int[] right )
1:35067bf:     {
1:35067bf:         for (int i = 0; i < left.length; i++)
1:35067bf:         {
1:35067bf:             if ( left[ i ] < right[ i ] ) return true;
1:35067bf:             if ( left[ i ] > right[ i ] ) return false;
1:35067bf:         }
1:35067bf: 
1:35067bf:         // Versions match exactly. That is, not less than.
1:35067bf:         return false;
1:35067bf:     } 
1:cdda215:     
3:10e07a5:     /**
1:8e20531:      * When running against certains old releases in Java SE 6
1:8e20531:      * we need to setup the connections to the old
1:8e20531:      * database to not use the specific JDBC 4
1:8e20531:      * datasources (e.g. EmbeddedDataSource40).
1:8e20531:      * (Since they don't exist in the old release).
1:8e20531:      *
1:8e20531:      */
1:8e20531:     private static Test handleJavaSE6(int phase, int[] version, Test test)
1:8e20531:     {
1:8e20531:         // 
1:8e20531:         // we need to tell the JUnit infratructure not to
1:8e20531:         // look for the  40 datasources (e.g. EmbeddedDataSource40)
1:8e20531:         boolean oldReleaseNeedsJDBC3 = false;
1:8e20531:         switch (phase)
1:8e20531:         {
1:8e20531:         case UpgradeChange.PH_CREATE:
1:8e20531:         case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:8e20531:             
1:8e20531:             // Pre 10.2.2.0 need jdbc 3 drivers.
1:8e20531:             if (version[0] == 10 && version[1] < 3)
1:8e20531:             {
1:8e20531:                 if (version[1] < 2 || version[2] < 2)
1:8e20531:                    oldReleaseNeedsJDBC3 = true;
1:8e20531:             }
1:8e20531:             break;
1:8e20531:         default:
1:8e20531:             break;
1:8e20531:         }
1:8e20531:         
1:8e20531:         if (oldReleaseNeedsJDBC3) {
1:8e20531:             return TestConfiguration.forceJDBC3Embedded(test);
1:8e20531:         }
1:8e20531:         return test;
1:8e20531:     }
1:cdda215:     
1:cde004c:     /**
1:cde004c:      * Adds a subset of the tests from DatabaseMetaDataTest to the test suite.
1:cde004c:      * <p>
1:cde004c:      * We want to run DatabaseMetaDataTest, but it includes some
1:cde004c:      * features not supported in older versions, so we cannot just
1:cde004c:      * add the DatabaseMetaDataTest.class as is.
1:cde004c:      * Note also, that this does not execute fixture initialCompilationTest.
1:cde004c:      */
1:1ae02c9:     private static void runDataBaseMetaDataTest (
1:1ae02c9:         BaseTestSuite suite, int oldMinor)
1:10e07a5:     {
1:1ae02c9:         BaseTestSuite dmdSuite =
1:1ae02c9:             new BaseTestSuite("DatabaseMetaData subsuite");
1:1ae02c9: 
1:9ba17d8:         Method[] methods = DatabaseMetaDataTest.class.getMethods();
1:9ba17d8:         for (int i = 0; i < methods.length; i++) {
1:9ba17d8:             Method m = methods[i];
1:9ba17d8:             if (m.getParameterTypes().length > 0 ||
1:9ba17d8:                     !m.getReturnType().equals(Void.TYPE)) {
1:9ba17d8:                 continue;
1:740f64e:             }
1:9ba17d8:             String name = m.getName();
1:9ba17d8:             if (name.startsWith("test"))
1:10e07a5:             {
1:7e85449:                 if ((!(name.equals("testGetTablesModify") && oldMinor < 1)) &&
1:7e85449:                    // these two tests will fail with versions before 10.2.1.6
1:7e85449:                    // because of missing support for grant/revoke/privileges
1:7e85449:                    (!(name.equals("testGetTablePrivileges") && oldMinor <2)) &&
1:7e85449:                    (!(name.equals("testGetColumnPrivileges") && oldMinor <2)))
1:720294e:                     dmdSuite.addTest(new DatabaseMetaDataTest(name));
1:daf5fa3:             }
1:cdda215:         }
1:720294e:         // Run the test in its own schema to avoid interference from other
1:720294e:         // tests. A typical example is additional matching rows when querying
1:720294e:         // system tables like SYS.SYSFOREIGNKEYS.
1:720294e:         suite.addTest(TestConfiguration.changeUserDecorator(
1:720294e:                                                     dmdSuite, "DMDT", "DMDT"));
1:cdda215:     }
1:cdda215: 
11:10e07a5: }
1:cdda215: 
1:aaa1403: class AdditionalDb
1:aaa1403: {
1:aaa1403:     final String logicalName;
1:aaa1403:     final boolean shutDown;
1:aaa1403:     public AdditionalDb(String logicalName, boolean shutDown)
1:aaa1403:     {
1:aaa1403:         this.logicalName = logicalName;
1:aaa1403:         this.shutDown  = shutDown;
1:aaa1403:     }
1:10e07a5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5b838fd
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 13)
1:                     suite.addTest(Changes10_13.suite(phase));
commit:9020cea
/////////////////////////////////////////////////////////////////////////
commit:35067bf
/////////////////////////////////////////////////////////////////////////
0:                 if ( lessThan( version, new int[] { 10, 8, 1, 6 } ) )
0:                 { suite.addTest(Changes10_8_2.suite(phase)); }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return true if and only if the left version is less than the
1:      * right version.
1:      */
0:     private static boolean lessThan( int[] left, int[] right )
1:     {
1:         for (int i = 0; i < left.length; i++)
1:         {
1:             if ( left[ i ] < right[ i ] ) return true;
1:             if ( left[ i ] > right[ i ] ) return false;
1:         }
1: 
1:         // Versions match exactly. That is, not less than.
1:         return false;
1:     } 
commit:6e000cc
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 9)
1:                 	suite.addTest(Changes10_9.suite(phase));
commit:a584888
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 7)
1:                 	suite.addTest(Changes10_7.suite(phase));
commit:a6f35a4
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 6)
1:                 	suite.addTest(Changes10_6.suite(phase));
commit:e65365e
/////////////////////////////////////////////////////////////////////////
1: class UpgradeRun extends UpgradeClassLoader
1: {
/////////////////////////////////////////////////////////////////////////
1:         ClassLoader oldLoader = makeClassLoader( version );
/////////////////////////////////////////////////////////////////////////
commit:daa4827
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestCase;
/////////////////////////////////////////////////////////////////////////
0:     static final String oldVersionsPath;
1:          
0:         oldVersionsPath = (String) AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
1: 
0:             public Object run(){
0:             return System.getProperty(_Suite.OLD_VERSIONS_PATH_PROPERTY);
1: 
1:             }
1: 
1:         }
0:          );
1: 
0:          jarPath = (String ) AccessController.doPrivileged
/////////////////////////////////////////////////////////////////////////
0:             BaseTestCase.traceit("Empty: Skip upgrade Tests (no jars) for " + getTextVersion(version));
1: 
1:         BaseTestCase.traceit("Prepare to run upgrade tests from " + getTextVersion(version));
/////////////////////////////////////////////////////////////////////////
1:             Test phaseTests = baseSuite(getTextVersion(version)
1:                     + " Upgrade Phase: " + UpgradeChange.PHASES[phase] + " ",
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (!lib.exists()){
0:                 BaseTestCase.alarm("Non-existing location for jar files: '" 
0:                     + jarLocation + "'. Upgrade tests can NOT be run!");
1:             }
/////////////////////////////////////////////////////////////////////////
0:                     Object dummy = url[i].getContent(); // IOException if not available.
0:                 } catch (IOException e) {
0:                     BaseTestCase.alarm("IOException msg: '" + e.getMessage() + "'." 
0:                         + " Upgrade tests can NOT be run!");
0:                     return null;
1: 
commit:bbe895f
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 3) {
1:                    //Pass the phase as a parameter to the
1:                    //suite method that will enable the test to add existing
1:                    //junit tests after checking for the phase of the current
1:                    //run. 
1:                    suite.addTest(Changes10_3.suite(phase));
1:                  }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a826375
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 12)
1:                     suite.addTest(Changes10_12.suite(phase));
commit:f448bbb
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 10)
1:                 	suite.addTest(Changes10_10.suite(phase));
commit:eba8dff
/////////////////////////////////////////////////////////////////////////
commit:df731e9
/////////////////////////////////////////////////////////////////////////
0:                 if (oldMinor < 8)
0:                 	suite.addTest(Changes10_8.suite(phase));
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 5)
1:                 	suite.addTest(Changes10_5.suite(phase));
commit:ea5ca3f
/////////////////////////////////////////////////////////////////////////
0:         "COLLATED_DB_10_3",//db with territory based collation 
commit:29e9328
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 4)
1:                 	suite.addTest(Changes10_4.suite(phase));
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = new BaseTestSuite(
1:         BaseTestSuite suite = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:     private static void runDataBaseMetaDataTest (
1:         BaseTestSuite suite, int oldMinor)
1:         BaseTestSuite dmdSuite =
1:             new BaseTestSuite("DatabaseMetaData subsuite");
1: 
commit:15b2b98
/////////////////////////////////////////////////////////////////////////
0:         new AdditionalDb("ROLES_10_5", false)
commit:aaa1403
/////////////////////////////////////////////////////////////////////////
1:      * The databases are shutdown at the end of each phase, unless
1:      * "NoShutDown" is specified. The latter is used by databases
1:      * which need sqlAuthorization (specified by test). This thwarts
1:      * normal shutdown since credentials are required so shutdown is
1:      * done in test, not by the tearDown methods. See
0:      * Changes10_4#testSQLRoles for example.
1: 
1:     static final AdditionalDb[] ADDITIONAL_DBS = {
1:         new AdditionalDb("COLLATED_DB_10_3", true), // db with territory
1:                                                     // based collation
1:         new AdditionalDb("NO_ENCRYPT_10_2", true),
1:         new AdditionalDb("ENCRYPT_10_2",  true),
0:         new AdditionalDb("ROLES_10_4", false)
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (ADDITIONAL_DBS[i].shutDown) {
1:                 setup = TestConfiguration.additionalDatabaseDecorator(
1:                     setup, ADDITIONAL_DBS[i].logicalName);
1:             } else {
1:                 setup = TestConfiguration.additionalDatabaseDecoratorNoShutdown(
1:                     setup, ADDITIONAL_DBS[i].logicalName);
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
1: }
1: 
1: class AdditionalDb
1: {
1:     final String logicalName;
1:     final boolean shutDown;
1:     public AdditionalDb(String logicalName, boolean shutDown)
1:     {
1:         this.logicalName = logicalName;
1:         this.shutDown  = shutDown;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7b6ad6d
/////////////////////////////////////////////////////////////////////////
1:         new AdditionalDb("DERBY-4753", true),
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:                 if (oldMinor < 11)
1:                     suite.addTest(Changes10_11.suite(phase));
commit:ae72a30
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (phase == UpgradeChange.PH_SOFT_UPGRADE &&
1:                 suffersFromDerby4835or5289(version)) {
1:             // If the old version suffers from DERBY-4835 or DERBY-5289,
1:             // it may not be able to read the trigger plans after soft upgrade.
1:             // Drop all trigger plans at the end of soft upgrade to prevent
1:             // problems in the post soft upgrade phase.
1:             suite.addTest(new BasicSetup("dropAllTriggerPlans"));
1:         }
1: 
1: 
1:     /**
1:      * Check if a version suffers from DERBY-4835 or DERBY-5289.
1:      */
1:     private static boolean suffersFromDerby4835or5289(int[] version) {
1:         // DERBY-4835 affects the 10.5 and 10.6 branches, and was fixed in
1:         // 10.5.3.2 and 10.6.2.3.
1:         // DERBY-5289 affects the 10.5, 10.6, 10.7 and 10.8 branches, and was
1:         // fixed in 10.5.3.1, 10.6.2.2, 10.7.1.4 and 10.8.2.2.
1:         return
1:                 (lessThan(new int[] { 10, 5, 0, 0 }, version) &&
1:                  lessThan(version, new int[] { 10, 5, 3, 2 }))
1:             ||
1:                 (lessThan(new int[] { 10, 6, 0, 0 }, version) &&
1:                  lessThan(version, new int[] { 10, 6, 2, 3 }))
1:             ||
1:                 (lessThan(new int[] { 10, 7, 0, 0 }, version) &&
1:                  lessThan(version, new int[] { 10, 7, 1, 4 }))
1:             ||
1:                 (lessThan(new int[] { 10, 8, 0, 0 }, version) &&
1:                  lessThan(version, new int[] { 10, 8, 2, 2 }));
1:     }
commit:1ede0a8
/////////////////////////////////////////////////////////////////////////
1:         new AdditionalDb("BUILTIN_10_9", false),
commit:c34c1d2
/////////////////////////////////////////////////////////////////////////
1:     static boolean lessThan( int[] left, int[] right )
commit:60edeb0
/////////////////////////////////////////////////////////////////////////
1:         new AdditionalDb("ROLES_10_5", false),
0:         new AdditionalDb("BUILTIN_10_6", false),
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:720294e
/////////////////////////////////////////////////////////////////////////
0:         TestSuite dmdSuite = new TestSuite("DatabaseMetaData subsuite");
/////////////////////////////////////////////////////////////////////////
1:                     dmdSuite.addTest(new DatabaseMetaDataTest(name));
1:         // Run the test in its own schema to avoid interference from other
1:         // tests. A typical example is additional matching rows when querying
1:         // system tables like SYS.SYSFOREIGNKEYS.
1:         suite.addTest(TestConfiguration.changeUserDecorator(
1:                                                     dmdSuite, "DMDT", "DMDT"));
commit:cde004c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite(final int[] version, boolean useCreateOnUpgrade) {
/////////////////////////////////////////////////////////////////////////
1:                 runDataBaseMetaDataTest(suite, oldMinor);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Adds a subset of the tests from DatabaseMetaDataTest to the test suite.
1:      * <p>
1:      * We want to run DatabaseMetaDataTest, but it includes some
1:      * features not supported in older versions, so we cannot just
1:      * add the DatabaseMetaDataTest.class as is.
1:      * Note also, that this does not execute fixture initialCompilationTest.
1:      */
0:     private static void runDataBaseMetaDataTest (TestSuite suite, int oldMinor)
commit:acfdb76
/////////////////////////////////////////////////////////////////////////
1:      * Changes10_5#testSQLRoles for example.
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:000d4bc
/////////////////////////////////////////////////////////////////////////
0:     public final static Test suite(final int[] version, boolean useCreateOnUpgrade) {
/////////////////////////////////////////////////////////////////////////
1:             Test phaseSet = new PhaseChanger(phaseTests, phase, loader, version, useCreateOnUpgrade);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:48a9884
/////////////////////////////////////////////////////////////////////////
0:                 //if (oldMinor < 6)
0:                 //	suite.addTest(Changes10_6.suite(phase));
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2e3ed68
/////////////////////////////////////////////////////////////////////////
1:                 }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e3f8545
/////////////////////////////////////////////////////////////////////////
1:     
0:     static final String jarPath;
1:     
0:     static {
0:         jarPath = (String ) AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
1: 
0:             public Object run(){
0:             return System.getProperty(_Suite.OLD_RELEASE_PATH_PROPERTY);
1: 
1:             }
1: 
1:         }
0:          );
1:     }
/////////////////////////////////////////////////////////////////////////
commit:73bff1b
/////////////////////////////////////////////////////////////////////////
0:      * in the property derbyTesting.oldReleasePath. If derbyTesting.oldReleasePath
0:      * is set to the empty string it is ignored.
0:         if (jarPath == null || jarPath.length() == 0)
commit:24390c9
/////////////////////////////////////////////////////////////////////////
1:         else
1:         {
1:             suite.addTest(new BasicSetup("noConnectionAfterHardUpgrade"));
1:         }
commit:918e8b0
/////////////////////////////////////////////////////////////////////////
0:         "NO_ENCRYPT_10_2",
0:         "ENCRYPT_10_2"
commit:e6cce75
/////////////////////////////////////////////////////////////////////////
1:      * connection against them. In hard upgrade the test
1:      * must explictly upgrade the database.
0:      * The databases are shutdown at the end of each phase.
commit:ca1a8f2
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set of additional databases for tests that
1:      * require a one-off database. The additional
1:      * database decorator wraps all the tests and phases.
1:      * They are only created if a test opens a
0:      * connection against them.
1:      */
0:     static final String[] ADDITIONAL_DBS = {
0:         "NO_ENCRYPT_10_2"
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < ADDITIONAL_DBS.length; i++)
1:         {
0:             setup = TestConfiguration.additionalDatabaseDecorator(setup,
0:                     ADDITIONAL_DBS[i]);
1:         }
1:         
commit:8e20531
/////////////////////////////////////////////////////////////////////////
0:             Test phaseSet = new PhaseChanger(phaseTests, phase, loader, version);
1:             phaseSet = handleJavaSE6(phase, version, phaseSet);
1:             suite.addTest(phaseSet);
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     /**
1:      * When running against certains old releases in Java SE 6
1:      * we need to setup the connections to the old
1:      * database to not use the specific JDBC 4
1:      * datasources (e.g. EmbeddedDataSource40).
1:      * (Since they don't exist in the old release).
1:      *
1:      */
1:     private static Test handleJavaSE6(int phase, int[] version, Test test)
1:     {
1:         // 
1:         // we need to tell the JUnit infratructure not to
1:         // look for the  40 datasources (e.g. EmbeddedDataSource40)
1:         boolean oldReleaseNeedsJDBC3 = false;
1:         switch (phase)
1:         {
1:         case UpgradeChange.PH_CREATE:
1:         case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:             
1:             // Pre 10.2.2.0 need jdbc 3 drivers.
1:             if (version[0] == 10 && version[1] < 3)
1:             {
1:                 if (version[1] < 2 || version[2] < 2)
1:                    oldReleaseNeedsJDBC3 = true;
1:             }
1:             break;
1:         default:
1:             break;
1:         }
1:         
1:         if (oldReleaseNeedsJDBC3) {
1:             return TestConfiguration.forceJDBC3Embedded(test);
1:         }
1:         return test;
1:     }
commit:740f64e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.tests.jdbcapi.DatabaseMetaDataTest;
/////////////////////////////////////////////////////////////////////////
1:             
1:             // Add DatabaseMetaData tests. Since metadata
1:             // queries may be changed by an upgrade it is
1:             // an area that is subject to bugs. Here we run
1:             // all or a subset of DatabaseMetaData tests
1:             // as required.
1:             switch (phase) {
1:             case UpgradeChange.PH_CREATE:
1:                 // No need to test, should have been covered
1:                 // by the original tests of the old release 
1:                 break;
1:                 
1:             case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:                 // reverted to old engine and metadata queries
1:                 // must continue to work. Cannot run the full
1:                 // set of tests here as the full DatabaseMetaDataTest
1:                 // functionality may not match the old engine.
1:                 // However we run individual fixtures that exercise
1:                 // the code path for the metadata queries.
1:                 //
1:                 // Any specific change to the metadata queries
1:                 // due to upgrade (e.g. fixing a system catalog)
1:                 // must be tested in a ChangesM_n fixture.
1:                 break;
1:             
1:             // Running at the new level so the full functionality
1:             // of DatabaseMetaData should be available.
1:             case UpgradeChange.PH_SOFT_UPGRADE:
1:             case UpgradeChange.PH_HARD_UPGRADE:
0:                 suite.addTestSuite(DatabaseMetaDataTest.class);
1:                 break;
1:             }
commit:2a42e33
/////////////////////////////////////////////////////////////////////////
0:      * in the property derbyTesting.oldReleasePath.
0:         String jarPath = System.getProperty(_Suite.OLD_RELEASE_PATH_PROPERTY);
0:         Assert.assertNotNull(_Suite.OLD_RELEASE_PATH_PROPERTY
0:                 + " not set", jarPath);
/////////////////////////////////////////////////////////////////////////
1:                 
commit:daf5fa3
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     phase, version);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add the tests from the various Changes classes (sub-classes
1:      * of UpgradeChange) to the base suite which corresponds to
1:      * a single phase of a run against an old database version.
1:      * <BR>
1:      * Changes are only added if the old version is older than
1:      * then version the changes represent. Thus Changes10_2
1:      * is not added if the old database (upgrade from) is already
1:      * at 10.2, since Changes10_2 is intended to test upgrade
1:      * from an older version to 10.2.
1:      * <BR>
1:      * This is for two reasons:
1:      * <OL>
1:      * <LI> Prevents an endless increase in number of test
1:      * cases that do no real testing. 
1:      * <LI> Simplifies test fixtures by allowing them to
1:      * focus on cases where testing is required, and not
1:      * handling all future situations.
1:      * </OL>
1:      * 
1:      */
1:     private static Test baseSuite(String name, int phase, int[] version) {
1:         
1:         int oldMajor = version[0];
1:         int oldMinor = version[1];
/////////////////////////////////////////////////////////////////////////
1:             if (oldMajor == 10) {
1:                 if (oldMinor < 1)
1:                     suite.addTest(Changes10_1.suite());
1:                 if (oldMinor < 2)
1:                    suite.addTest(Changes10_2.suite());
0:                 if (oldMinor < 3)
0:                    suite.addTest(Changes10_3.suite());
1:             }
commit:cdda215
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // If no jars then just skip.
1:         if (oldLoader == null)
1:         {
0:             TestSuite suite = new TestSuite(
1:                     "Empty: Skipped upgrade Tests (no jars) for " + getTextVersion(version));
1:             return suite;
1:         }
1:         
1:         
0:         TestSuite suite = new TestSuite(
1:                 "Upgrade Tests from " + getTextVersion(version));
1: 
1:         
/////////////////////////////////////////////////////////////////////////
0:                     "Upgrade Phase: " + UpgradeChange.PHASES[phase],
0:                     phase);
/////////////////////////////////////////////////////////////////////////
0:     private static Test baseSuite(String name, int phase) {
1:           
1:         // No connection is expected in the post hard upgrade
1:         // phase, so don't bother adding test fixtures.
1:         if (phase != UpgradeChange.PH_POST_HARD_UPGRADE)
1:         {
1:             suite.addTest(BasicSetup.suite());
1:             
0:             suite.addTest(Changes10_1.suite());
0:             suite.addTest(Changes10_2.suite());
0:             suite.addTest(Changes10_3.suite());
1:         }
/////////////////////////////////////////////////////////////////////////
0:         File lib = new File(jarLocation);
1:         
0:         // If the jars do not exist then return null
0:         // and the caller will set up to skip this.
0:         if (!lib.exists())
0:             return null;
1:         
1:         
0:                 url[i] = new File(lib, jarFiles[i]).toURL();
commit:10e07a5
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeRun
0: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
0: 
1:    http://www.apache.org/licenses/LICENSE-2.0
0: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
0: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
0: 
0: import java.io.File;
0: import java.net.MalformedURLException;
0: import java.net.URL;
0: import java.net.URLClassLoader;
0: import java.security.AccessController;
1: import java.util.Properties;
0: 
1: import junit.extensions.TestSetup;
0: import junit.framework.Assert;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: 
0: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: 
1: /**
1:  * Utility class for creating a set of tests that
1:  * comprise a complete upgrade run through all
1:  * five phases. This includes handling the
1:  * class loading for the old jar files
1:  * and setting up the configuration to
1:  * use a single use database and DataSource for
1:  * connections.
1:  *
1:  */
0: class UpgradeRun {
0:     private static final String[] jarFiles = {
0:             "derby.jar", 
0:             //"derbynet.jar",
0:             //"derbyclient.jar",
0:             //"derbytools.jar"
0:             };
0:     
0:     private static String getTextVersion(int[] iv)
1:     {
0:         String version = iv[0] + "." + iv[1] +
0:         "." + iv[2] + "." + iv[3];
0:         return version;
1:     }
0: 
0:     public final static Test suite(final int[] version) {
0:         
0:         TestSuite suite = new TestSuite(
0:                 "Upgrade Tests from " + getTextVersion(version));
0:         
0:         ClassLoader oldLoader = (ClassLoader )AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0: 
0:             public Object run(){
0:             return createClassLoader(version);
0: 
1:             }
0: 
1:         }
0:          );
0:         
1:         for (int phase = 0;
1:               phase < UpgradeChange.PHASES.length; phase++)
1:         {
1:             ClassLoader loader = null;
1:             switch (phase)
1:             {
1:             case UpgradeChange.PH_CREATE:
1:             case UpgradeChange.PH_POST_SOFT_UPGRADE:
1:             case UpgradeChange.PH_POST_HARD_UPGRADE:
1:                 loader = oldLoader;
1:                 break;
1:             case UpgradeChange.PH_SOFT_UPGRADE:
1:             case UpgradeChange.PH_HARD_UPGRADE:
1:                 break;
0:                 
1:             }
0:             Test phaseTests = baseSuite(
0:                     "Upgrade Phase: " + UpgradeChange.PHASES[phase]);
0:             
0:             suite.addTest(new PhaseChanger(phaseTests, phase, loader, version));
1:         }
0:           
1:         TestSetup setup = TestConfiguration.singleUseDatabaseDecorator(suite);
0:         
1:         Properties preReleaseUpgrade = new Properties();
1:         preReleaseUpgrade.setProperty(
1:                 "derby.database.allowPreReleaseUpgrade", "true");
0:         
1:         setup = new SystemPropertyTestSetup(setup, preReleaseUpgrade);
0:    
1:         return SecurityManagerSetup.noSecurityManager(setup);
1:     }
0:     
0:     private static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
0:         
0:         suite.addTest(BasicSetup.suite());
0:         
0:         suite.addTest(Changes10_1.suite());
0:                 
1:         return TestConfiguration.connectionDSDecorator(suite);
1:     }
0:     
1:     /**
0:      * Get the location of jars of old release. The location is specified 
0:      * in the property "derbyTesting.jar.path".
1:      *  
0:      * @return location of jars of old release
1:      */
0:     private static String getOldJarLocation(int[] oldVersion) {
0:         String jarPath = System.getProperty("derbyTesting.jar.path");
0:         
0:         Assert.assertNotNull("derbyTesting.jar.path not set", jarPath);
0:       
0:         String version = getTextVersion(oldVersion);
0:         String jarLocation = jarPath + File.separator + version
0:             + File.separator + "lib";
0:                 
0:         return jarLocation;
1:     }
0:     
1:     /**
0:      * Create a class loader using jars in the specified location. Add all jars 
0:      * specified in jarFiles and the testing jar.
1:      * 
0:      * @param jarLoc Location of jar files
0:      * @return class loader
1:      */
0:     private static ClassLoader createClassLoader(int[] version)
1:     {
0:         URL[] url = new URL[jarFiles.length];
0:         
0:         String jarLocation = getOldJarLocation(version);
0:         
0:         for (int i=0; i < jarFiles.length; i++) {
0:             try {
0:                 url[i] = new File(jarLocation + File.separator + jarFiles[i]).toURL();
0:                 System.out.println("URL " + url[i].toString());
0:             } catch (MalformedURLException e) {
0:                 Assert.fail(e.toString());
1:             }
1:         }
0:         
0:         // Specify null for parent class loader to avoid mixing up 
0:         // jars specified in the system classpath
0:         return new URLClassLoader(url, null);       
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7e85449
/////////////////////////////////////////////////////////////////////////
1:                 if ((!(name.equals("testGetTablesModify") && oldMinor < 1)) &&
1:                    // these two tests will fail with versions before 10.2.1.6
1:                    // because of missing support for grant/revoke/privileges
1:                    (!(name.equals("testGetTablePrivileges") && oldMinor <2)) &&
1:                    (!(name.equals("testGetColumnPrivileges") && oldMinor <2)))
commit:b4fdbf8
/////////////////////////////////////////////////////////////////////////
0:         if (jarPath == null)
0:             return null;
0:         
0:         String jarLocation = jarPath + File.separator + version;
0:         
0: 
0:     /**
0:      * Get the location of jars of old release, using the url for svn at apache.
0:      *  
0:      * @return location of jars of old release
0:      */
0:     private static String getOldJarURLLocation(int[] oldVersion) {
0: 
0:         String oldJarUrl = _Suite.OLD_JAR_URL;
0:         
0:         String version = getTextVersion(oldVersion);
0:         String jarLocation = oldJarUrl + "/" + version;
0:         
0:         return jarLocation;       
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0:         if (jarLocation != null)
0:         {
0:             File lib = new File(jarLocation);
0: 
0:             // If the jars do not exist then return null
0:             // and the caller will set up to skip this.
0:             if (!lib.exists())
0:                 return null;
0: 
0:             for (int i=0; i < jarFiles.length; i++) {
0:                 try {
0:                     url[i] = new File(lib, jarFiles[i]).toURL();
0:                 } catch (MalformedURLException e) {
0:                     Assert.fail(e.toString());
0:                 }
0:             }
0:         }
0:         else
0:         // if the property was not set, attempt to access the jars from 
0:         // the saved svn location.
0:         // Note, this means the test fails if there is no network connection
0:         // (or the server at apache is down) unless the property is set
0:         // to a valid location
0:         {
0:             String oldURLJarLocation = getOldJarURLLocation(version);
0:             for (int i=0; i < jarFiles.length; i++) {
0:                 try {
0:                     url[i] = new URL(oldURLJarLocation + "/" + jarFiles[i]);
0:                 } catch (MalformedURLException e) {
0:                     Assert.fail(e.toString());
0:                 }
commit:9ba17d8
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Method;
/////////////////////////////////////////////////////////////////////////
0:                 RunDataBaseMetaDataTest(suite, oldMinor);
/////////////////////////////////////////////////////////////////////////
0:     
0:     // We want to run DatabaseMetaDataTest, but it includes some
0:     // features not supported in older versions, so we cannot just
0:     // add the DatabaseMetaDataTest.class as is.
0:     // Note also, that this does not execute fixture initialCompilationTest.
0:     private static void RunDataBaseMetaDataTest (TestSuite suite, int oldMinor)
0:     {
1:         Method[] methods = DatabaseMetaDataTest.class.getMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             Method m = methods[i];
1:             if (m.getParameterTypes().length > 0 ||
1:                     !m.getReturnType().equals(Void.TYPE)) {
1:                 continue;
0:             }
1:             String name = m.getName();
1:             if (name.startsWith("test"))
0:             {
0:                 if (!(name.equals("testGetTablesModify") && oldMinor < 1))
0:                     suite.addTest(new DatabaseMetaDataTest(name));
0:             }
0:         }
0:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
0:      * @param version the Derby version to create a classloader for.
============================================================================