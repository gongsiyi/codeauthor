1:d211792: /*
6:d211792: 
1:d211792:    Derby - Class org.apache.derby.impl.jdbc.StoreStreamClob
1:d211792: 
1:d211792:    Licensed to the Apache Software Foundation (ASF) under one
1:d211792:    or more contributor license agreements.  See the NOTICE file
1:d211792:    distributed with this work for additional information
1:d211792:    regarding copyright ownership.  The ASF licenses this file
1:d211792:    to you under the Apache License, Version 2.0 (the
1:d211792:    "License"); you may not use this file except in compliance
1:d211792:    with the License.  You may obtain a copy of the License at
1:d211792: 
1:d211792:      http://www.apache.org/licenses/LICENSE-2.0
1:d211792: 
1:d211792:    Unless required by applicable law or agreed to in writing,
1:d211792:    software distributed under the License is distributed on an
1:d211792:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:d211792:    KIND, either express or implied.  See the License for the
1:d211792:    specific language governing permissions and limitations
1:d211792:    under the License.
1:d211792: 
5:d211792:  */
1:d211792: package org.apache.derby.impl.jdbc;
1:d211792: 
1:d211792: import java.io.BufferedInputStream;
1:d211792: import java.io.EOFException;
1:ab2037f: import java.io.FilterReader;
1:d211792: import java.io.IOException;
1:d211792: import java.io.InputStream;
1:d211792: import java.io.Reader;
1:d211792: import java.io.Writer;
1:d211792: 
1:d211792: import java.sql.SQLException;
1:d211792: import org.apache.derby.iapi.error.StandardException;
1:910b77f: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:d211792: import org.apache.derby.iapi.reference.SQLState;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:d211792: import org.apache.derby.iapi.types.Resetable;
1:d211792: import org.apache.derby.iapi.util.UTF8Util;
1:d211792: 
1:6f9cd95: /**
1:d211792:  * A read-only Clob representation operating on streams out of the Derby store
1:d211792:  * module.
1:d211792:  * <p>
1:d211792:  * Note that the streams from the store are expected to have the following
1:d211792:  * properties:
1:7672693:  * <ol> <li>The first few bytes are used for length encoding. Currently the
1:7672693:  *          number of bytes is either 2 or 5.
1:d211792:  *      <li>A Derby-specific end-of-stream marker at the end of the stream can
1:d211792:  *          be present. The marker is expected to be <code>0xe0 0x00 0x00</code>
1:d211792:  * </ol>
1:6f9cd95:  */
1:d211792: final class StoreStreamClob
1:d211792:     implements InternalClob {
1:d211792: 
1:d211792:     /** Tells whether this Clob has been released or not. */
1:d211792:     private volatile boolean released = false;
1:d211792: 
5:d211792:     /**
1:d211792:      * The stream from store, used to read bytes from the database.
1:d211792:      * <p>
1:d211792:      * To be able to support the requirements, the stream must implement
1:d211792:      * {@link Resetable}.
1:d211792:      */
1:d211792:     //@GuardedBy("synchronizationObject")
1:f839f5e:     private final PositionedStoreStream positionedStoreStream;
1:7672693:     /** The descriptor used to describe the underlying source stream. */
1:7672693:     private CharacterStreamDescriptor csd;
1:d211792:     /** The connection (child) this Clob belongs to. */
1:d211792:     private final ConnectionChild conChild;
1:d211792:     /** Object used for synchronizing access to the store stream. */
1:d211792:     private final Object synchronizationObject;
1:ab2037f:     /**
1:ab2037f:      * Shared internal reader, closed when the Clob is released.
1:ab2037f:      * This is a performance optimization, and the stream is shared between
1:ab2037f:      * "one time" operations, for instance {@code getSubString} calls. Often a
1:ab2037f:      * subset, or the whole, of the Clob is read subsequently and then this
1:ab2037f:      * optimization avoids repositioning costs (the store does not support
1:ab2037f:      * random access for LOBs).
1:ab2037f:      * <b>NOTE</b>: Do not publish this reader to the end-user.
1:ab2037f:      */
1:ab2037f:     private UTF8Reader internalReader;
1:ab2037f:     /** The internal reader wrapped so that it cannot be closed. */
1:ab2037f:     private FilterReader unclosableInternalReader;
1:d211792: 
1:d211792:     /**
1:d211792:      * Creates a new Clob based on a stream from store.
1:d211792:      * <p>
1:7672693:      * The stream used as a source for this Clob has to implement the interface
1:7672693:      * {@code Resetable}, as the stream interface from store only allows for
1:7672693:      * movement forwards. If the stream has been advanced too far with regards
1:7672693:      * to the user request, the stream must be reset and we start from the
1:7672693:      * beginning.
4:d211792:      *
1:7672693:      * @param csd descriptor for the source stream, including a reference to it
1:d211792:      * @param conChild the connection (child) this Clob belongs to
1:d211792:      */
1:7672693:     public StoreStreamClob(CharacterStreamDescriptor csd,
1:7672693:                            ConnectionChild conChild)
1:d211792:             throws StandardException {
1:7672693:         if (SanityManager.DEBUG) {
1:7672693:             // We create a position aware stream below, the stream is not
1:7672693:             // supposed to be a position aware stream already!
1:7672693:             SanityManager.ASSERT(!csd.isPositionAware());
1:7672693:         }
1:dd2650f:         try {
1:7672693:             this.positionedStoreStream = 
1:7672693:                     new PositionedStoreStream(csd.getStream());
1:dd2650f:         } catch (StandardException se) {
1:dd2650f:             if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:dd2650f:                 throw StandardException
1:dd2650f:                         .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:dd2650f:             } else {
1:dd2650f:                 throw se;
1:dd2650f:             }
1:dd2650f:         } catch (IOException ioe) {
1:dd2650f:             throw StandardException.newException(
1:dd2650f:                     SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, "CLOB");
1:dd2650f:         }
1:d211792:         this.conChild = conChild;
1:d211792:         this.synchronizationObject = conChild.getConnectionSynchronization();
1:7672693:         if (SanityManager.DEBUG) {
1:7672693:             // Creating the positioned stream should reset the stream.
1:7672693:             SanityManager.ASSERT(positionedStoreStream.getPosition() == 0);
1:7672693:         }
1:7672693:         this.csd = new CharacterStreamDescriptor.Builder().copyState(csd).
1:7672693:                 stream(positionedStoreStream). // Replace with positioned stream
1:7672693:                 positionAware(true). // Update description
1:7672693:                 curBytePos(0L).
1:7672693:                 curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).
1:7672693:                 build();
14:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Releases resources associated with this Clob.
1:d211792:      */
1:d211792:     public void release() {
1:d211792:         if (!released) {
1:ab2037f:             if (this.internalReader != null) {
1:ab2037f:                 this.internalReader.close();
1:ab2037f:             }
1:f839f5e:             this.positionedStoreStream.closeStream();
1:d211792:             this.released = true;
1:d211792:         }
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Returns the number of characters in the Clob.
1:d211792:      *
1:d211792:      * @return Number of characters in the Clob.
1:d211792:      * @throws SQLException if any kind of error is encountered, be it related
1:d211792:      *      to I/O or something else
1:d211792:      */
1:d211792:     public long getCharLength()
1:d211792:             throws SQLException {
2:d211792:         checkIfValid();
1:7672693:         if (this.csd.getCharLength() == 0) {
1:6f9cd95:             // Decode the stream to find the length.
1:7672693:             long charLength = 0;
1:6f9cd95:             synchronized (this.synchronizationObject) {
1:6f9cd95:                 this.conChild.setupContextStack();
1:6f9cd95:                 try {
1:7672693:                     charLength = UTF8Util.skipUntilEOF(
1:6f9cd95:                             new BufferedInputStream(getRawByteStream()));
1:6f9cd95:                 } catch (Throwable t) {
1:6f9cd95:                     throw noStateChangeLOB(t);
1:6f9cd95:                 } finally {
1:56a7b39:                     ConnectionChild.restoreIntrFlagIfSeen(
1:3a6f4cf:                         true, conChild.getEmbedConnection());
1:56a7b39:                     conChild.restoreContextStack();
1:6f9cd95:                 }
1:d211792:             }
1:7672693:             // Update the stream descriptor.
1:7672693:             this.csd = new CharacterStreamDescriptor.Builder().
1:7672693:                     copyState(this.csd).charLength(charLength).build();
1:d211792:         }
1:7672693:         return this.csd.getCharLength();
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:dac5aed:      * Returns the cached character count for the Clob, if any.
1:dac5aed:      *
1:dac5aed:      * @return The number of characters in the Clob, or {@code -1} if unknown.
1:dac5aed:      */
1:dac5aed:     public long getCharLengthIfKnown() {
1:dac5aed:         checkIfValid();
1:dac5aed:         // Treat a cached value of zero as a special case.
1:dac5aed:         return (csd.getCharLength() == 0 ? -1 : csd.getCharLength());
1:dac5aed:     }
1:dac5aed: 
1:dac5aed:     /**
1:d211792:      * Returns a stream serving the raw bytes of this Clob.
1:d211792:      * <p>
1:d211792:      * Note that the stream returned is an internal stream, and it should not be
1:d211792:      * pulished to end users.
1:d211792:      *
1:d211792:      * @return A stream serving the bytes of this Clob, initialized at byte 0 of
1:d211792:      *      the data. The buffer must be assumed to be unbuffered, but no such
1:d211792:      *      guarantee is made.
2:d211792:      * @throws IOException if accessing the I/O resources fail
2:d211792:      * @throws SQLException if accessing the store resources fail
1:d211792:      */
1:d211792:     public InputStream getRawByteStream()
4:d211792:             throws IOException, SQLException {
1:d211792:         checkIfValid();
1:f839f5e:         try {
1:f839f5e:             // Skip the encoded length.
1:7672693:             this.positionedStoreStream.reposition(this.csd.getDataOffset());
1:f839f5e:         } catch (StandardException se) {
1:f839f5e:             throw Util.generateCsSQLException(se);
1:f839f5e:         }
1:f839f5e:         return this.positionedStoreStream;
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Returns a reader for the Clob, initialized at the specified character
1:d211792:      * position.
1:d211792:      *
1:d211792:      * @param pos character position. The first character is at position 1.
1:d211792:      * @return A reader initialized at the specified position.
1:d211792:      * @throws EOFException if the positions is larger than the Clob
1:d211792:      * @throws IOException if accessing the I/O resources fail
1:d211792:      * @throws SQLException if accessing the store resources fail
1:d211792:      */
1:d211792:     public Reader getReader(long pos)
1:d211792:             throws IOException, SQLException  {
1:d211792:         checkIfValid();
1:f839f5e:         try {
1:f839f5e:             this.positionedStoreStream.reposition(0L);
1:f839f5e:         } catch (StandardException se) {
1:f839f5e:             throw Util.generateCsSQLException(se);
1:f839f5e:         }
1:910b77f:         Reader reader = new UTF8Reader(
1:910b77f:                 csd, this.conChild, this.synchronizationObject);
1:d211792:         long leftToSkip = pos -1;
1:d211792:         long skipped;
1:d211792:         while (leftToSkip > 0) {
1:d211792:             skipped = reader.skip(leftToSkip);
1:d211792:             // Since Reader.skip block until some characters are available,
1:d211792:             // a return value of 0 must mean EOF.
2:d211792:             if (skipped <= 0) {
1:d211792:                 throw new EOFException("Reached end-of-stream prematurely");
1:d211792:             }
1:d211792:             leftToSkip -= skipped;
1:d211792:         }
1:d211792:         return reader;
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:ab2037f:      * Returns an internal reader for the Clob, initialized at the specified
1:ab2037f:      * character position.
1:ab2037f:      *
1:ab2037f:      * @param characterPosition 1-based character position.
1:ab2037f:      * @return A reader initialized at the specified position.
1:ab2037f:      * @throws EOFException if the positions is larger than the Clob
1:ab2037f:      * @throws IOException if accessing the I/O resources fail
1:ab2037f:      * @throws SQLException if accessing the store resources fail
1:ab2037f:      */
1:ab2037f:     public Reader getInternalReader(long characterPosition)
1:ab2037f:             throws IOException, SQLException {
1:ab2037f:         if (this.internalReader == null) {
1:910b77f:             if (positionedStoreStream.getPosition() != 0) {
1:910b77f:                 try {
1:910b77f:                     positionedStoreStream.resetStream();
1:910b77f:                 } catch (StandardException se) {
1:910b77f:                     throw Util.generateCsSQLException(se);
1:910b77f:                 }
1:910b77f:             }
1:910b77f:             this.internalReader =
1:910b77f:                     new UTF8Reader(csd, conChild, synchronizationObject);
1:ab2037f:             this.unclosableInternalReader =
1:ab2037f:                     new FilterReader(this.internalReader) {
1:ab2037f:                         public void close() {
1:ab2037f:                             // Do nothing.
1:ab2037f:                             // Stream will be closed when the Clob is released.
1:ab2037f:                         }
1:ab2037f:                     };
1:ab2037f:         }
1:ab2037f:         try {
1:ab2037f:             this.internalReader.reposition(characterPosition);
1:ab2037f:         } catch (StandardException se) {
1:ab2037f:             throw Util.generateCsSQLException(se);
1:ab2037f:         }
1:ab2037f:         return this.unclosableInternalReader;
1:ab2037f:     }
1:ab2037f: 
1:ab2037f:     /**
1:d9319b8:      * Returns the update count of this Clob.
1:d9319b8:      * <p>
1:d9319b8:      * Always returns zero, as this Clob cannot be updated.
1:d9319b8:      *
1:d9319b8:      * @return Zero (read-only Clob).
1:d9319b8:      */
1:d9319b8:     public long getUpdateCount() {
1:d9319b8:         return 0L;
1:d9319b8:     }
1:d9319b8: 
1:d9319b8:     /**
1:d211792:      * Not supported.
1:d211792:      *
1:d211792:      * @see InternalClob#getWriter
1:d211792:      */
1:d211792:     public Writer getWriter(long pos) {
1:d211792:         throw new UnsupportedOperationException(
1:d211792:             "A StoreStreamClob object is not updatable");
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Not supported.
1:d211792:      *
1:d211792:      * @see InternalClob#insertString
1:d211792:      */
1:d211792:     public long insertString(String str, long pos) {
1:d211792:         throw new UnsupportedOperationException(
1:d211792:             "A StoreStreamClob object is not updatable");
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d9319b8:      * Tells if this Clob has been released.
1:d9319b8:      *
1:d9319b8:      * @return {@code true} if released, {@code false} if not.
1:d9319b8:      */
1:d9319b8:     public boolean isReleased() {
1:d9319b8:         return released;
1:d9319b8:     }
1:d9319b8: 
1:d9319b8:     /**
1:d211792:      * Tells if this Clob can be modified.
1:d211792:      *
1:d211792:      * @return <code>false</code>, this Clob is read-only.
1:d211792:      */
1:d211792:     public boolean isWritable() {
1:d211792:         return false;
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Not supported.
1:d211792:      *
1:d211792:      * @see InternalClob#truncate
1:d211792:      */
1:d211792:     public void truncate(long newLength) {
1:d211792:         throw new UnsupportedOperationException(
1:d211792:             "A StoreStreamClob object is not updatable");
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Wrap real exception in a {@link SQLException} to avoid changing the state
1:d211792:      * of the connection child by cleaning it up.
1:d211792:      *
1:d211792:      * @param t real cause of error that we want to "ignore" with respect to
1:d211792:      *      transaction context cleanup
1:d211792:      * @return A {@link SQLException} wrapped around the real cause of the error
1:d211792:      */
1:d211792:     private static SQLException noStateChangeLOB(Throwable t) {
1:d211792:         if (t instanceof StandardException)
1:d211792:         {
1:d211792:             // container closed means the blob or clob was accessed after commit
1:d211792:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
1:d211792:             {
1:d211792:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:d211792:             }
1:d211792:         }
1:d211792:         return org.apache.derby.impl.jdbc.EmbedResultSet.noStateChangeException(t);
1:d211792:     }
1:d211792: 
1:d211792:     /**
1:d211792:      * Makes sure the Clob has not been released.
1:d211792:      * <p>
1:d211792:      * All operations are invalid on a released Clob.
1:d211792:      *
1:d211792:      * @throws IllegalStateException if the Clob has been released
1:d211792:      */
1:d211792:     private void checkIfValid() {
1:d211792:         if (this.released) {
1:d211792:             throw new IllegalStateException(
1:d211792:                 "The Clob has been released and is not valid");
1:d211792:         }
1:d211792:     }
1:d211792: } // End class StoreStreamClob
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Lily Wei
-------------------------------------------------------------------------------
commit:56a7b39
/////////////////////////////////////////////////////////////////////////
1:                     ConnectionChild.restoreIntrFlagIfSeen(
1:                     conChild.restoreContextStack();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
0:                     conChild.restoreIntrFlagIfSeen(
1:                         true, conChild.getEmbedConnection());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:dac5aed
/////////////////////////////////////////////////////////////////////////
1:      * Returns the cached character count for the Clob, if any.
1:      *
1:      * @return The number of characters in the Clob, or {@code -1} if unknown.
1:      */
1:     public long getCharLengthIfKnown() {
1:         checkIfValid();
1:         // Treat a cached value of zero as a special case.
1:         return (csd.getCharLength() == 0 ? -1 : csd.getCharLength());
1:     }
1: 
1:     /**
commit:7672693
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:  * <ol> <li>The first few bytes are used for length encoding. Currently the
1:  *          number of bytes is either 2 or 5.
/////////////////////////////////////////////////////////////////////////
1:     /** The descriptor used to describe the underlying source stream. */
1:     private CharacterStreamDescriptor csd;
/////////////////////////////////////////////////////////////////////////
1:      * The stream used as a source for this Clob has to implement the interface
1:      * {@code Resetable}, as the stream interface from store only allows for
1:      * movement forwards. If the stream has been advanced too far with regards
1:      * to the user request, the stream must be reset and we start from the
1:      * beginning.
1:      * @param csd descriptor for the source stream, including a reference to it
1:     public StoreStreamClob(CharacterStreamDescriptor csd,
1:                            ConnectionChild conChild)
1:         if (SanityManager.DEBUG) {
1:             // We create a position aware stream below, the stream is not
1:             // supposed to be a position aware stream already!
1:             SanityManager.ASSERT(!csd.isPositionAware());
1:         }
1:             this.positionedStoreStream = 
1:                     new PositionedStoreStream(csd.getStream());
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             // Creating the positioned stream should reset the stream.
1:             SanityManager.ASSERT(positionedStoreStream.getPosition() == 0);
1:         }
1:         this.csd = new CharacterStreamDescriptor.Builder().copyState(csd).
1:                 stream(positionedStoreStream). // Replace with positioned stream
1:                 positionAware(true). // Update description
1:                 curBytePos(0L).
1:                 curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).
1:                 build();
/////////////////////////////////////////////////////////////////////////
1:         if (this.csd.getCharLength() == 0) {
1:             long charLength = 0;
1:                     charLength = UTF8Util.skipUntilEOF(
/////////////////////////////////////////////////////////////////////////
1:             // Update the stream descriptor.
1:             this.csd = new CharacterStreamDescriptor.Builder().
1:                     copyState(this.csd).charLength(charLength).build();
1:         return this.csd.getCharLength();
/////////////////////////////////////////////////////////////////////////
1:             this.positionedStoreStream.reposition(this.csd.getDataOffset());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:910b77f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
/////////////////////////////////////////////////////////////////////////
0:         // Describe the stream to allow the reader to configure itself.
0:         CharacterStreamDescriptor csd =
0:                 new CharacterStreamDescriptor.Builder().
0:                 stream(positionedStoreStream).bufferable(false).
0:                 positionAware(true).dataOffset(2L). // TODO
0:                 curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).
0:                 maxCharLength(TypeId.CLOB_MAXWIDTH).
0:                 charLength(cachedCharLength). // 0 means unknown.
0:                 build();
1:         Reader reader = new UTF8Reader(
1:                 csd, this.conChild, this.synchronizationObject);
/////////////////////////////////////////////////////////////////////////
1:             if (positionedStoreStream.getPosition() != 0) {
1:                 try {
1:                     positionedStoreStream.resetStream();
1:                 } catch (StandardException se) {
1:                     throw Util.generateCsSQLException(se);
1:                 }
1:             }
0:             // Describe the stream to allow the reader to configure itself.
0:             CharacterStreamDescriptor csd =
0:                     new CharacterStreamDescriptor.Builder().
0:                     stream(positionedStoreStream).bufferable(false).
0:                     positionAware(true).dataOffset(2L). // TODO: Fix offset.
0:                     curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).
0:                     maxCharLength(TypeId.CLOB_MAXWIDTH).
0:                     charLength(cachedCharLength). // 0 means unknown.
0:                     build();
1:             this.internalReader =
1:                     new UTF8Reader(csd, conChild, synchronizationObject);
commit:dd2650f
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             this.positionedStoreStream = new PositionedStoreStream(stream);
1:         } catch (StandardException se) {
1:             if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:                 throw StandardException
1:                         .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:             } else {
1:                 throw se;
1:             }
1:         } catch (IOException ioe) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, "CLOB");
1:         }
commit:d9319b8
/////////////////////////////////////////////////////////////////////////
1:      * Returns the update count of this Clob.
1:      * <p>
1:      * Always returns zero, as this Clob cannot be updated.
1:      *
1:      * @return Zero (read-only Clob).
1:      */
1:     public long getUpdateCount() {
1:         return 0L;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Tells if this Clob has been released.
1:      *
1:      * @return {@code true} if released, {@code false} if not.
1:      */
1:     public boolean isReleased() {
1:         return released;
1:     }
1: 
1:     /**
commit:6f9cd95
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * The cached length of the store stream in number of characters.
0:      * A value of {@code 0} means the length is unknown, and zero is an invalid
0:      * length for a store stream Clob. It is set to zero because that is the
0:      * value encoded as length in the store stream (on disk format) when the
0:      * length is unknown or cannot be represented.
1:      */
0:     private long cachedCharLength = 0;
/////////////////////////////////////////////////////////////////////////
0:         if (this.cachedCharLength == 0) {
1:             // Decode the stream to find the length.
1:             synchronized (this.synchronizationObject) {
1:                 this.conChild.setupContextStack();
1:                 try {
0:                     this.cachedCharLength = UTF8Util.skipUntilEOF(
1:                             new BufferedInputStream(getRawByteStream()));
1:                 } catch (Throwable t) {
1:                     throw noStateChangeLOB(t);
1:                 } finally {
0:                     this.conChild.restoreContextStack();
1:                 }
0:         return this.cachedCharLength;
commit:ab2037f
/////////////////////////////////////////////////////////////////////////
1: import java.io.FilterReader;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Shared internal reader, closed when the Clob is released.
1:      * This is a performance optimization, and the stream is shared between
1:      * "one time" operations, for instance {@code getSubString} calls. Often a
1:      * subset, or the whole, of the Clob is read subsequently and then this
1:      * optimization avoids repositioning costs (the store does not support
1:      * random access for LOBs).
1:      * <b>NOTE</b>: Do not publish this reader to the end-user.
1:      */
1:     private UTF8Reader internalReader;
1:     /** The internal reader wrapped so that it cannot be closed. */
1:     private FilterReader unclosableInternalReader;
/////////////////////////////////////////////////////////////////////////
1:             if (this.internalReader != null) {
1:                 this.internalReader.close();
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * Returns an internal reader for the Clob, initialized at the specified
1:      * character position.
1:      *
1:      * @param characterPosition 1-based character position.
1:      * @return A reader initialized at the specified position.
1:      * @throws EOFException if the positions is larger than the Clob
1:      * @throws IOException if accessing the I/O resources fail
1:      * @throws SQLException if accessing the store resources fail
1:      */
1:     public Reader getInternalReader(long characterPosition)
1:             throws IOException, SQLException {
1:         if (this.internalReader == null) {
0:             this.internalReader = new UTF8Reader(positionedStoreStream,
0:                     TypeId.CLOB_MAXWIDTH, conChild, synchronizationObject);
1:             this.unclosableInternalReader =
1:                     new FilterReader(this.internalReader) {
1:                         public void close() {
1:                             // Do nothing.
1:                             // Stream will be closed when the Clob is released.
1:                         }
1:                     };
1:         }
1:         try {
1:             this.internalReader.reposition(characterPosition);
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:         return this.unclosableInternalReader;
1:     }
1: 
1:     /**
commit:e8fd686
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:65e0386
/////////////////////////////////////////////////////////////////////////
commit:f839f5e
/////////////////////////////////////////////////////////////////////////
1:     private final PositionedStoreStream positionedStoreStream;
/////////////////////////////////////////////////////////////////////////
0:         this.positionedStoreStream = new PositionedStoreStream(stream);
0:         this.positionedStoreStream.initStream();
/////////////////////////////////////////////////////////////////////////
1:             this.positionedStoreStream.closeStream();
/////////////////////////////////////////////////////////////////////////
1:             this.positionedStoreStream.reposition(0L);
0:             int us1 = this.positionedStoreStream.read();
0:             int us2 = this.positionedStoreStream.read();
0:             byteLength = (us1 << 8) + (us2 << 0);
0:                     long skipped =
0:                         this.positionedStoreStream.skip(SKIP_BUFFER_SIZE);
/////////////////////////////////////////////////////////////////////////
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             // Skip the encoded length.
0:             this.positionedStoreStream.reposition(2L);
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
1:         }
1:         return this.positionedStoreStream;
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             this.positionedStoreStream.reposition(0L);
0:         } catch (StandardException se) {
0:             throw Util.generateCsSQLException(se);
1:         }
0:         Reader reader = new UTF8Reader(this.positionedStoreStream,
0:                                 TypeId.CLOB_MAXWIDTH, this.conChild,
0:                                 this.synchronizationObject);
/////////////////////////////////////////////////////////////////////////
commit:45ba22f
/////////////////////////////////////////////////////////////////////////
0:      * @throws NullPointerException if <code>stream</code> or
0:      *      <code>conChild</code> is null
0:      * @throws ClassCastException if <code>stream</code> is not an instance
0:      *      of <code>Resetable</code>
commit:d211792
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.jdbc.StoreStreamClob
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: 
1:  */
1: package org.apache.derby.impl.jdbc;
1: 
1: import java.io.BufferedInputStream;
1: import java.io.EOFException;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.Reader;
1: import java.io.Writer;
1: 
1: import java.sql.SQLException;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.UTF8Util;
1: 
1: /**
1:  * A read-only Clob representation operating on streams out of the Derby store
1:  * module.
1:  * <p>
1:  * Note that the streams from the store are expected to have the following
1:  * properties:
0:  * <ol> <li>The first two bytes are used for length encoding. Note that due to
0:  *          the inadequate max number of this format, it is always ignored. This
0:  *          is also true if there actually is a length encoded there. The two
0:  *          bytes are excluded from the length of the stream.
1:  *      <li>A Derby-specific end-of-stream marker at the end of the stream can
1:  *          be present. The marker is expected to be <code>0xe0 0x00 0x00</code>
1:  * </ol>
1:  */
1: final class StoreStreamClob
1:     implements InternalClob {
1: 
0:     /** Maximum value used when requesting bytes/chars to be skipped. */
0:     private static final long SKIP_BUFFER_SIZE = 8*1024; // 8 KB
1: 
1:     /** Tells whether this Clob has been released or not. */
1:     private volatile boolean released = false;
1: 
1:     /**
1:      * The stream from store, used to read bytes from the database.
1:      * <p>
1:      * To be able to support the requirements, the stream must implement
1:      * {@link Resetable}.
1:      */
1:     //@GuardedBy("synchronizationObject")
0:     private final InputStream storeStream;
1:     /** The connection (child) this Clob belongs to. */
1:     private final ConnectionChild conChild;
1:     /** Object used for synchronizing access to the store stream. */
1:     private final Object synchronizationObject;
1: 
1: 
1:     /**
1:      * Creates a new Clob based on a stream from store.
1:      * <p>
0:      * Note that the stream passed in have to fulfill certain requirements,
0:      * which are not currently totally enforced by Java (the language).
1:      *
0:      * @param stream the stream containing the Clob value. This stream is
0:      *      expected to implement {@link Resetable} and to be a
0:      *      {@link org.apache.derby.iapi.services.io.FormatIdInputStream} with
0:      *      an ${link org.apache.derby.impl.store.raw.data.OverflowInputStream}
0:      *      inside. However, the available interfaces does not guarantee this.
0:      *      See the class JavaDoc for more information about this stream.
1:      * @param conChild the connection (child) this Clob belongs to
0:      * @throws StandardException if initializing the store stream fails
0:      * @see org.apache.derby.iapi.services.io.FormatIdInputStream
0:      * @see org.apache.derby.impl.store.raw.data.OverflowInputStream
1:      */
0:     public StoreStreamClob(InputStream stream, ConnectionChild conChild)
1:             throws StandardException {
0:         if (stream == null) {
0:             throw new IllegalArgumentException("Stream cannot be <null>");
1:         }
0:         if (conChild == null) {
0:             throw new IllegalArgumentException("conChild cannot be <null>");
1:         }
0:         if (!(stream instanceof Resetable)) {
0:             throw new IllegalArgumentException("Stream must be resetable: " +
0:                 stream.toString());
1:         }
0:         this.storeStream = stream;
1:         this.conChild = conChild;
1:         this.synchronizationObject = conChild.getConnectionSynchronization();
0:         ((Resetable)this.storeStream).initStream();
1:     }
1: 
1:     /**
1:      * Releases resources associated with this Clob.
1:      */
1:     public void release() {
1:         if (!released) {
0:             ((Resetable)this.storeStream).closeStream();
1:             this.released = true;
1:         }
1:     }
1: 
1:     /**
0:      * Returns the number of bytes in the Clob.
1:      *
0:      * @return The number of bytes in the Clob.
1:      * @throws IOException if accessing the I/O resources fail
1:      * @throws SQLException if accessing the store resources fail
1:      */
0:     public long getByteLength()
1:             throws IOException, SQLException {
1:         checkIfValid();
0:         // Read through the whole stream to get the length.
0:         long byteLength = 0;
0:         try {
0:             this.conChild.setupContextStack();
0:             // See if length is encoded in the stream.
0:             byteLength = resetStoreStream(true);
0:             if (byteLength == 0) {
0:                 while (true) {
0:                     long skipped = this.storeStream.skip(SKIP_BUFFER_SIZE);
1:                     if (skipped <= 0) {
0:                         break;
1:                     }
0:                     byteLength += skipped;
1:                 }
0:                 // Subtract 3 bytes for the end-of-stream marker.
0:                 byteLength -= 3;
1:             }
0:             return byteLength;
0:         } finally {
0:             this.conChild.restoreContextStack();
1:         }
1:     }
1: 
1:     /**
1:      * Returns the number of characters in the Clob.
1:      *
1:      * @return Number of characters in the Clob.
1:      * @throws SQLException if any kind of error is encountered, be it related
1:      *      to I/O or something else
1:      */
1:     public long getCharLength()
1:             throws SQLException {
1:         checkIfValid();
0:         synchronized (this.synchronizationObject) {
0:             this.conChild.setupContextStack();
0:             try {
0:                 return UTF8Util.skipUntilEOF(
0:                                 new BufferedInputStream(getRawByteStream()));
0:             } catch (Throwable t) {
0:                 throw noStateChangeLOB(t);
0:             } finally {
0:                 this.conChild.restoreContextStack();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Returns a stream serving the raw bytes of this Clob.
1:      * <p>
1:      * Note that the stream returned is an internal stream, and it should not be
1:      * pulished to end users.
1:      *
1:      * @return A stream serving the bytes of this Clob, initialized at byte 0 of
1:      *      the data. The buffer must be assumed to be unbuffered, but no such
1:      *      guarantee is made.
1:      * @throws IOException if accessing the I/O resources fail
1:      * @throws SQLException if accessing the store resources fail
1:      */
1:     public InputStream getRawByteStream()
1:             throws IOException, SQLException {
1:         checkIfValid();
0:         resetStoreStream(true);
0:         return this.storeStream;
1:     }
1: 
1:     /**
1:      * Returns a reader for the Clob, initialized at the specified character
1:      * position.
1:      *
1:      * @param pos character position. The first character is at position 1.
1:      * @return A reader initialized at the specified position.
1:      * @throws EOFException if the positions is larger than the Clob
1:      * @throws IOException if accessing the I/O resources fail
1:      * @throws SQLException if accessing the store resources fail
1:      */
1:     public Reader getReader(long pos)
1:             throws IOException, SQLException  {
1:         checkIfValid();
0:         resetStoreStream(false);
0:         Reader reader = new UTF8Reader(this.storeStream, TypeId.CLOB_MAXWIDTH,
0:             this.conChild, this.synchronizationObject);
1:         long leftToSkip = pos -1;
1:         long skipped;
1:         while (leftToSkip > 0) {
1:             skipped = reader.skip(leftToSkip);
1:             // Since Reader.skip block until some characters are available,
1:             // a return value of 0 must mean EOF.
1:             if (skipped <= 0) {
1:                 throw new EOFException("Reached end-of-stream prematurely");
1:             }
1:             leftToSkip -= skipped;
1:         }
1:         return reader;
1:     }
1: 
1:     /**
0:      * Returns the byte position for the specified character position.
1:      *
0:      * @param charPos character position. First character is at position 1.
0:      * @return Corresponding byte position. First byte is at position 0.
0:      * @throws EOFException if the position is bigger then the Clob
0:      * @throws IOException if accessing the underlying I/O resources fail
0:      * @throws SQLException if accessing the underlying store resources fail
1:      */
0:     public long getBytePosition(long charPos)
1:             throws IOException, SQLException {
0:         return UTF8Util.skipFully(getRawByteStream(), charPos -1);
1:     }
1: 
1:     /**
1:      * Not supported.
1:      *
1:      * @see InternalClob#getWriter
1:      */
1:     public Writer getWriter(long pos) {
1:         throw new UnsupportedOperationException(
1:             "A StoreStreamClob object is not updatable");
1:     }
1: 
1:     /**
1:      * Not supported.
1:      *
1:      * @see InternalClob#insertString
1:      */
1:     public long insertString(String str, long pos) {
1:         throw new UnsupportedOperationException(
1:             "A StoreStreamClob object is not updatable");
1:     }
1: 
1:     /**
1:      * Tells if this Clob can be modified.
1:      *
1:      * @return <code>false</code>, this Clob is read-only.
1:      */
1:     public boolean isWritable() {
1:         return false;
1:     }
1: 
1:     /**
1:      * Not supported.
1:      *
1:      * @see InternalClob#truncate
1:      */
1:     public void truncate(long newLength) {
1:         throw new UnsupportedOperationException(
1:             "A StoreStreamClob object is not updatable");
1:     }
1: 
1:     /**
1:      * Wrap real exception in a {@link SQLException} to avoid changing the state
1:      * of the connection child by cleaning it up.
1:      *
1:      * @param t real cause of error that we want to "ignore" with respect to
1:      *      transaction context cleanup
1:      * @return A {@link SQLException} wrapped around the real cause of the error
1:      */
1:     private static SQLException noStateChangeLOB(Throwable t) {
1:         if (t instanceof StandardException)
1:         {
1:             // container closed means the blob or clob was accessed after commit
1:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
1:             {
1:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:             }
1:         }
1:         return org.apache.derby.impl.jdbc.EmbedResultSet.noStateChangeException(t);
1:     }
1: 
1:     /**
1:      * Makes sure the Clob has not been released.
1:      * <p>
1:      * All operations are invalid on a released Clob.
1:      *
1:      * @throws IllegalStateException if the Clob has been released
1:      */
1:     private void checkIfValid() {
1:         if (this.released) {
1:             throw new IllegalStateException(
1:                 "The Clob has been released and is not valid");
1:         }
1:     }
1: 
1:     /**
0:      * Reset the store stream, skipping two bytes of length encoding if
0:      * requested.
1:      *
0:      * @param skipEncodedLength <code>true</code> will cause length encoding to
0:      *      be skipped. Note that the length is not always recorded when data is
0:      *      written to store, and therefore it is ignored.
0:      * @return The length encoded in the stream, or <code>-1</code> if the
0:      *      length information is not decoded. A return value of <code>0</code>
0:      *      means the stream is ended with a Derby end-of-stream marker.
0:      * @throws IOException if skipping the two bytes fails
0:      * @throws SQLException if resetting the stream fails in store
1:      */
0:     private long resetStoreStream(boolean skipEncodedLength)
1:             throws IOException, SQLException {
0:         try {
0:             ((Resetable)this.storeStream).resetStream();
0:         } catch (StandardException se) {
0:             throw noStateChangeLOB(se);
1:         }
0:         long encodedLength = -1L;
0:         if (skipEncodedLength) {
0:             int b1 = this.storeStream.read();
0:             int b2 = this.storeStream.read();
0:             if (b1 == -1 || b2 == -1) {
0:                 throw Util.setStreamFailure(
0:                     new IOException("Reached end-of-stream prematurely"));
1:             }
0:             // Length is currently written as an unsigned short.
0:             encodedLength = (b1 << 8) + (b2 << 0);
1:         }
0:         return encodedLength;
1:     }
1: } // End class StoreStreamClob
============================================================================