2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.DeleteNode
1:a6f9586: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
4:eac0369:  */
31:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import java.lang.reflect.Modifier;
1:1c6c2e8: import java.util.ArrayList;
1:3541af3: import java.util.HashSet;
1:47d4a4c: import java.util.List;
1:eac0369: import java.util.Properties;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableProperties;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.ResultDescription;
1:3bb140c: import org.apache.derby.iapi.sql.StatementType;
1:fc9fd0d: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:fc9fd0d: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1:fc9fd0d: import org.apache.derby.iapi.sql.compile.ScopeFilter;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:801cf0d: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:3bb140c: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:3bb140c: import org.apache.derby.iapi.store.access.TransactionController;
1:3bb140c: import org.apache.derby.vti.DeferModification;
1:f246c9c: 
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A DeleteNode represents a DELETE statement. It is the top-level node
1:eac0369:  * for the statement.
1:eac0369:  *
1:eac0369:  * For positioned delete, there may be no from table specified.
1:eac0369:  * The from table will be derived from the cursor specification of
1:eac0369:  * the named cursor.
1:eac0369:  *
1:eac0369:  */
1:3bb140c: class DeleteNode extends DMLModStatementNode
1:eac0369: {
1:eac0369: 	/* Column name for the RowLocation column in the ResultSet */
1:0061383: 	private static final String COLUMNNAME = "###RowLocationToDelete";
1:eac0369: 
1:eac0369: 	/* Filled in by bind. */
1:9f2ed7d:     private boolean deferred;
1:9f2ed7d:     private FromTable targetTable;
1:9f2ed7d:     private FormatableBitSet readColsBitSet;
1:eac0369: 
1:eac0369: 	private ConstantAction[] dependentConstantActions;
1:eac0369: 	private boolean cascadeDelete;
1:8a93440: 	private StatementNode[] dependentNodes;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a DeleteNode.
1:eac0369: 	 *
1:eac0369: 	 * @param targetTableName	The name of the table to delete from
1:6b50965: 	 * @param queryExpression	The query expression that will generate
1:eac0369: 	 *				the rows to delete from the given table
1:508a010:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 */
1:eac0369: 
1:508a010:     DeleteNode
1:508a010:         (
1:508a010:          TableName targetTableName,
1:3bb140c:          ResultSetNode queryExpression,
1:508a010:          MatchingClauseNode matchingClause,
1:508a010:          ContextManager cm
1:508a010:          )
1:508a010:     {
1:508a010:         super( queryExpression, matchingClause, cm );
1:3bb140c:         this.targetTableName = targetTableName;
1:eac0369: 	}
1:fc9fd0d: 
1:3bb140c:     @Override
1:3bb140c:     String statementToString()
1:2d2e717: 	{
1:eac0369: 		return "DELETE";
1:eac0369: 	}
1:5a95e6b: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this DeleteNode.  This means looking up tables and columns and
1:eac0369: 	 * getting their types, and figuring out the result types of all
1:eac0369: 	 * expressions, as well as doing view resolution, permissions checking,
1:eac0369: 	 * etc.
1:eac0369: 	 * <p>
1:eac0369: 	 * If any indexes need to be updated, we add all the columns in the
1:eac0369: 	 * base table to the result column list, so that we can use the column
1:eac0369: 	 * values as look-up keys for the index rows to be deleted.  Binding a
1:eac0369: 	 * delete will also massage the tree so that the ResultSetNode has 
1:eac0369: 	 * column containing the RowLocation of the base row.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:c45f5b1: 		// We just need select privilege on the where clause tables
1:c45f5b1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
1:c45f5b1: 		try
1:eac0369: 		{
1:3bb140c:             FromList fromList = new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                     getContextManager());
1:3bb140c: 
1:3bb140c:             ResultColumn                rowLocationColumn = null;
1:eac0369: 			CurrentRowLocationNode		rowLocationNode;
1:eac0369: 			TableName					cursorTargetTableName = null;
1:eac0369: 			CurrentOfNode       		currentOfNode = null;
1:508a010: 
1:fc9fd0d:             //
1:fc9fd0d:             // Don't add privilege requirements for the UDT types of columns.
1:fc9fd0d:             // The compiler will attempt to add these when generating the full column list during
1:fc9fd0d:             // binding of the tables.
1:fc9fd0d:             //
1:fc9fd0d:             IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:fc9fd0d:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:fc9fd0d:             
1:eac0369: 			DataDictionary dataDictionary = getDataDictionary();
1:508a010:             // for DELETE clause of a MERGE statement, the tables have already been bound
1:508a010: 			if ( !inMatchingClause() ) { super.bindTables(dataDictionary); }
1:5a95e6b: 
1:eac0369: 			// wait to bind named target table until the underlying
1:eac0369: 			// cursor is bound, so that we can get it from the
1:eac0369: 			// cursor if this is a positioned delete.
1:5a95e6b: 
1:eac0369: 			// for positioned delete, get the cursor's target table.
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(resultSet != null && resultSet instanceof SelectNode,
1:eac0369: 				"Delete must have a select result set");
1:eac0369: 
1:3bb140c:             SelectNode sel = (SelectNode)resultSet;
1:eac0369: 			targetTable = (FromTable) sel.fromList.elementAt(0);
1:eac0369: 			if (targetTable instanceof CurrentOfNode)
1:eac0369: 			{
1:eac0369: 				currentOfNode = (CurrentOfNode) targetTable;
1:eac0369: 
1:508a010: 				cursorTargetTableName = inMatchingClause() ?
1:508a010:                     targetTableName : currentOfNode.getBaseCursorTargetTableName();
1:eac0369: 				// instead of an assert, we might say the cursor is not updatable.
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.ASSERT(cursorTargetTableName != null);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (targetTable instanceof FromVTI)
1:eac0369: 			{
1:eac0369: 				targetVTI = (FromVTI) targetTable;
1:eac0369: 				targetVTI.setTarget();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				// positioned delete can leave off the target table.
1:eac0369: 				// we get it from the cursor supplying the position.
1:eac0369: 				if (targetTableName == null)
1:eac0369: 				{
1:eac0369: 					// verify we have current of
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(cursorTargetTableName!=null);
1:508a010: 
1:eac0369: 				targetTableName = cursorTargetTableName;
1:eac0369: 				}
1:eac0369: 				// for positioned delete, we need to verify that
1:eac0369: 				// the named table is the same as the cursor's target (base table name).
1:eac0369: 				else if (cursorTargetTableName != null)
1:eac0369: 				{
1:eac0369: 					// this match requires that the named table in the delete
1:eac0369: 					// be the same as a base name in the cursor.
1:eac0369: 					if ( !targetTableName.equals(cursorTargetTableName))
1:eac0369: 					{
1:eac0369: 						throw StandardException.newException(SQLState.LANG_CURSOR_DELETE_MISMATCH, 
1:eac0369: 							targetTableName,
1:eac0369: 							currentOfNode.getCursorName());
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		
1:5a95e6b: 			// descriptor must exist, tables already bound.
1:5a95e6b: 			verifyTargetTable();
1:eac0369: 
1:eac0369: 			/* Generate a select list for the ResultSetNode - CurrentRowLocation(). */
1:508a010: 			if ( SanityManager.DEBUG )
1:508a010:             {
1:11f7ee3: 				SanityManager.ASSERT((resultSet.getResultColumns() == null),
1:eac0369: 							  "resultColumns is expected to be null until bind time");
1:508a010:             }
1:eac0369: 
1:eac0369: 
1:eac0369: 			if (targetTable instanceof FromVTI)
1:eac0369: 			{
1:eac0369: 				getResultColumnList();
1:c45f5b1: 				resultColumnList = targetTable.getResultColumnsForList(null, 
1:c45f5b1: 								resultColumnList, null);
1:eac0369: 
2:eac0369: 				/* Set the new result column list in the result set */
1:eac0369: 				resultSet.setResultColumns(resultColumnList);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369:             
1:eac0369: 				/*
1:eac0369: 				** Start off assuming no columns from the base table
1:eac0369: 				** are needed in the rcl.
1:eac0369: 				*/
1:eac0369: 
1:3bb140c:                 resultColumnList =
1:3bb140c:                         new ResultColumnList(getContextManager());
1:eac0369: 
1:eac0369: 				FromBaseTable fbt = getResultColumnList(resultColumnList);
1:eac0369: 
1:eac0369: 				readColsBitSet = getReadMap(dataDictionary,
1:eac0369: 										targetTableDescriptor);
1:eac0369: 
1:eac0369: 				resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** If all bits are set, then behave as if we chose all
1:eac0369: 				** in the first place
1:eac0369: 				*/
1:eac0369: 				int i = 1;
1:eac0369: 				int size = targetTableDescriptor.getMaxColumnID();
1:eac0369: 				for (; i <= size; i++)
1:eac0369: 				{
1:eac0369: 					if (!readColsBitSet.get(i))
1:eac0369: 					{
1:eac0369: 						break;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (i > size)
1:eac0369: 				{
1:eac0369: 					readColsBitSet = null;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* Generate the RowLocation column */
1:3bb140c:                 rowLocationNode =
1:3bb140c:                         new CurrentRowLocationNode(getContextManager());
1:3bb140c:                 rowLocationColumn =
1:3bb140c:                         new ResultColumn(COLUMNNAME,
1:3bb140c:                                          rowLocationNode,
1:3bb140c:                                          getContextManager());
1:eac0369: 				rowLocationColumn.markGenerated();
1:eac0369: 
1:eac0369: 				/* Append to the ResultColumnList */
1:eac0369: 				resultColumnList.addResultColumn(rowLocationColumn);
1:eac0369: 
1:444aa52: 				/* Force the added columns to take on the table's correlation name, if any */
1:444aa52: 				correlateAddedColumns( resultColumnList, targetTable );
1:eac0369: 			
1:508a010:                 /* Add the new result columns to the driving result set */
1:11f7ee3:                 ResultColumnList    originalRCL = resultSet.getResultColumns();
1:508a010:                 if ( originalRCL != null )
1:508a010:                 {
1:508a010:                     originalRCL.appendResultColumns( resultColumnList, false );
1:508a010:                     resultColumnList = originalRCL;
1:508a010:                 }
1:eac0369: 				resultSet.setResultColumns(resultColumnList);
1:eac0369: 			}
1:eac0369: 
1:fc9fd0d:             // done excluding column types from privilege checking
1:fc9fd0d:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:fc9fd0d: 
1:eac0369: 			/* Bind the expressions before the ResultColumns are bound */
1:fc9fd0d: 
1:fc9fd0d:             // only add privileges when we're inside the WHERE clause
1:fc9fd0d:             ScopeFilter scopeFilter = new ScopeFilter( getCompilerContext(), CompilerContext.WHERE_SCOPE, 1 );
1:fc9fd0d:             getCompilerContext().addPrivilegeFilter( scopeFilter );
1:eac0369: 			super.bindExpressions();
1:daffaee:             getCompilerContext().removePrivilegeFilter( scopeFilter );
1:fc9fd0d: 
1:eac0369: 			/* Bind untyped nulls directly under the result columns */
1:c45f5b1: 			resultSet.getResultColumns().
1:eac0369: 				bindUntypedNullsToResultColumns(resultColumnList);
1:eac0369: 
1:eac0369: 			if (! (targetTable instanceof FromVTI))
1:eac0369: 			{
1:eac0369: 				/* Bind the new ResultColumn */
1:eac0369: 				rowLocationColumn.bindResultColumnToExpression();
1:eac0369: 				bindConstraints(dataDictionary,
1:af1c18c:                         getOptimizerFactory(),
1:af1c18c:                         targetTableDescriptor,
1:af1c18c:                         null,
1:af1c18c:                         resultColumnList,
1:af1c18c:                         (int[]) null,
1:af1c18c:                         readColsBitSet,
1:af1c18c:                         true, // we alway include triggers in core language
1:af1c18c:                         new boolean[1]); // dummy
1:eac0369: 
1:eac0369: 				/* If the target table is also a source table, then
1:eac0369: 			 	* the delete will have to be in deferred mode
1:eac0369: 			 	* For deletes, this means that the target table appears in a
1:eac0369: 			 	* subquery.  Also, self-referencing foreign key deletes
1:eac0369: 		 	 	* are deferred.  And triggers cause the delete to be deferred.
1:eac0369: 			 	*/
1:eac0369: 				if (resultSet.subqueryReferencesTarget(
1:eac0369: 									targetTableDescriptor.getName(), true) ||
1:eac0369: 					requiresDeferredProcessing())
1:eac0369: 				{
1:eac0369: 					deferred = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369:             	deferred = VTIDeferModPolicy.deferIt( DeferModification.DELETE_STATEMENT,
1:eac0369:                                                   targetVTI,
7:eac0369:                                                   null,
1:eac0369:                                                   sel.getWhereClause());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Verify that all underlying ResultSets reclaimed their FromList */
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(fromList.size() == 0,
1:eac0369: 					"fromList.size() is expected to be 0, not " +
1:eac0369: 					fromList.size() +
1:eac0369: 					" on return from RS.bindExpressions()");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			//In case of cascade delete , create nodes for
1:eac0369: 			//the ref action  dependent tables and bind them.
1:eac0369: 			if(fkTableNames != null)
1:eac0369: 			{
1:c45f5b1: 				String currentTargetTableName = targetTableDescriptor.getSchemaName() +
1:c45f5b1: 						 "." + targetTableDescriptor.getName();
1:eac0369: 
1:eac0369: 				if(!isDependentTable){
1:eac0369: 					//graph node
1:9d5bd0e:                     dependentTables = new HashSet<String>();
1:eac0369: 				}
1:eac0369: 
1:3541af3: 				/*Check whether the current target has already been explored.
1:eac0369: 			 	*If we are seeing the same table name which we binded earlier
1:eac0369: 			 	*means we have cyclic references.
1:eac0369: 			 	*/
1:3541af3: 				if (dependentTables.add(currentTargetTableName))
1:eac0369: 				{
1:eac0369: 					cascadeDelete = true;
1:eac0369: 					int noDependents = fkTableNames.length;
1:8a93440: 					dependentNodes = new StatementNode[noDependents];
1:eac0369: 					for(int i =0 ; i < noDependents ; i ++)
1:eac0369: 					{
1:eac0369: 						dependentNodes[i] = getDependentTableNode(fkTableNames[i],
1:eac0369: 															  fkRefActions[i],
1:eac0369: 															  fkColDescriptors[i]);
1:8a93440: 						dependentNodes[i].bindStatement();
1:eac0369: 					}
1:eac0369: 				}
6:c45f5b1: 			}
2:c45f5b1: 			else
1:eac0369: 			{
1:eac0369: 				//case where current dependent table does not have dependent tables
1:eac0369: 				if(isDependentTable)
1:eac0369: 				{
1:c45f5b1: 					String currentTargetTableName = targetTableDescriptor.getSchemaName()
1:c45f5b1: 							 + "." + targetTableDescriptor.getName();
1:3541af3:                     dependentTables.add(currentTargetTableName);
1:eac0369: 
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:fc9fd0d:             // add need for DELETE privilege on the target table
1:fc9fd0d:             getCompilerContext().pushCurrentPrivType( getPrivType());
1:fc9fd0d:             getCompilerContext().addRequiredTablePriv( targetTableDescriptor);
1:fc9fd0d:             getCompilerContext().popCurrentPrivType();
1:2d2e717: 		}
1:c45f5b1: 		finally
1:eac0369: 		{
1:2d2e717: 			getCompilerContext().popCurrentPrivType();
1:c45f5b1: 		}
1:eac0369: 	} // end of bind
1:eac0369: 
1:3bb140c:     @Override
1:c45f5b1: 	int getPrivType()
1:444aa52: 	{
1:c45f5b1: 		return Authorizer.DELETE_PRIV;
1:c45f5b1: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		//If delete table is on a SESSION schema table, then return true. 
1:eac0369: 		return resultSet.referencesSessionSchema();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compile constants that Execution will use
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/* Different constant actions for base tables and updatable VTIs */
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 		{
1:eac0369: 			// Base table
1:e1f49ca:             int lckMode = resultSet.updateTargetLockMode();
1:eac0369: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1:eac0369: 			TransactionController tc = getLanguageConnectionContext().getTransactionCompile();
1:eac0369: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1:eac0369: 				new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
1:eac0369: 
1:eac0369: 			for (int index = 0; index < indexSCOCIs.length; index++)
1:eac0369: 			{
1:eac0369: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Do table locking if the table's lock granularity is
1:eac0369: 			** set to table.
1:eac0369: 			*/
1:eac0369: 			if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1:eac0369: 			{
1:e1f49ca:                 lckMode = TransactionController.MODE_TABLE;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ResultDescription resultDescription = null;
1:eac0369: 			if(isDependentTable)
1:eac0369: 			{
1:eac0369: 				//triggers need the result description ,
1:eac0369: 				//dependent tables  don't have a source from generation time
1:eac0369: 				//to get the result description
1:eac0369: 				resultDescription = makeResultDescription();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 
1:eac0369: 			return	getGenericConstantActionFactory().getDeleteConstantAction
1:eac0369: 				( heapConglomId,
1:eac0369: 				  targetTableDescriptor.getTableType(),
1:eac0369: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
1:eac0369: 				  indicesToMaintain,
1:eac0369: 				  indexConglomerateNumbers,
1:eac0369: 				  indexSCOCIs,
1:eac0369: 				  deferred,
2:eac0369: 				  false,
1:eac0369: 				  targetTableDescriptor.getUUID(),
1:e1f49ca:                   lckMode,
1:eac0369: 				  null, null, null, 0, null, null, 
1:eac0369: 				  resultDescription,
1:eac0369: 				  getFKInfo(), 
1:eac0369: 				  getTriggerInfo(), 
1:eac0369: 				  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
1:eac0369: 				  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
1:eac0369: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1:eac0369:  				  (readColsBitSet == null) ? 
1:eac0369: 					  targetTableDescriptor.getNumberOfColumns() :
1:eac0369: 					  readColsBitSet.getNumBitsSet(),			
1:eac0369: 				  (UUID) null,
1:eac0369: 				  resultSet.isOneRowResultSet(),
1:01632c2: 				  dependentConstantActions,
1:01632c2:                   inMatchingClause());
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* Return constant action for VTI
1:eac0369: 			 * NOTE: ConstantAction responsible for preserving instantiated
1:eac0369: 			 * VTIs for in-memory queries and for only preserving VTIs
1:eac0369: 			 * that implement Serializable for SPSs.
1:eac0369: 			 */
1:eac0369: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.DELETE_STATEMENT,
1:eac0369: 						deferred);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Code generation for delete.
1:eac0369: 	 * The generated code will contain:
1:eac0369: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations
1:eac0369: 	 *		o  The static member will be assigned the appropriate ResultSet within
1:eac0369: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
1:eac0369: 	 *		   (xxx)ResultSet will be generated.)
1:eac0369: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
1:eac0369: 	 *		   a new method for returning the RowLocation as well as a call to
1:eac0369: 	 *		   that method which will be stuffed in the call to the 
1:eac0369: 	 *		    ProjectRestrictResultSet.
1:eac0369: 	 *      o In case of referential actions, this function generate an
1:eac0369: 	 *        array of resultsets on its dependent tables.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb	The execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:ccee531: 		// If the DML is on the temporary table, generate the code to
1:ccee531: 		// mark temporary table as modified in the current UOW. After
1:ccee531: 		// DERBY-827 this must be done in execute() since
1:d11ed08: 		// createResultSet() will only be called once.
1:d11ed08: 		generateCodeForTemporaryTable(acb);
1:eac0369: 
1:eac0369: 		/* generate the parameters */
2:eac0369: 		if(!isDependentTable)
1:eac0369: 			generateParameterValueSet(acb);
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb); 
1:eac0369: 		acb.newRowLocationScanResultSetName();
1:508a010: 
1:508a010:         // arg 1
1:508a010:         if ( inMatchingClause() )
1:508a010:         {
1:508a010:             matchingClause.generateResultSetField( acb, mb );
1:508a010:         }
1:508a010:         else
1:508a010:         {
1:508a010:             resultSet.generate( acb, mb );
1:508a010:         }
1:eac0369: 
1:eac0369: 		String resultSetGetter;
1:eac0369: 		int argCount;
1:eac0369: 		String parentResultSetId;
1:eac0369: 
1:eac0369: 		// Base table
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 		{
1:eac0369: 			/* Create the declaration for the scan ResultSet which generates the
1:eac0369: 			 * RowLocations to be deleted.
1:eac0369: 	 		 * Note that the field cannot be static because there
1:eac0369: 			 * can be multiple activations of the same activation class,
1:eac0369: 			 * and they can't share this field.  Only exprN fields can
1:eac0369: 			 * be shared (or, more generally, read-only fields).
1:eac0369: 			 * RESOLVE - Need to deal with the type of the field.
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			acb.newFieldDeclaration(Modifier.PRIVATE, 
1:eac0369: 									ClassName.CursorResultSet, 
1:eac0369: 									acb.getRowLocationScanResultSetName());
1:eac0369: 
1:eac0369: 			if(cascadeDelete || isDependentTable)
1:eac0369: 			{
1:eac0369: 				resultSetGetter = "getDeleteCascadeResultSet";
1:6b26ee1: 				argCount = 4;
1:eac0369: 			}		
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				resultSetGetter = "getDeleteResultSet";
1:6b26ee1: 				argCount = 1;
1:eac0369: 			}
1:6b26ee1: 			
1:eac0369: 		} else {
1:6b26ee1: 			argCount = 1;
1:eac0369: 			resultSetGetter = "getDeleteVTIResultSet";
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(isDependentTable)
1:eac0369: 		{
1:eac0369: 			mb.push(acb.addItem(makeConstantAction()));
1:eac0369: 		
2:eac0369: 		}else
1:eac0369: 		{
1:eac0369: 			if(cascadeDelete)
1:eac0369: 			{
1:eac0369: 				mb.push(-1); //root table.
1:eac0369: 			}
1:eac0369: 		}		
1:eac0369: 
1:eac0369: 		String		resultSetArrayType = ClassName.ResultSet + "[]";
1:eac0369: 		if(cascadeDelete)
1:eac0369: 		{
1:eac0369: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
1:eac0369: 			                       "." + targetTableDescriptor.getName();
1:eac0369: 			// Generate the code to build the array
1:eac0369: 			LocalField arrayField =
1:eac0369: 				acb.newFieldDeclaration(Modifier.PRIVATE, resultSetArrayType);
1:eac0369: 			mb.pushNewArray(ClassName.ResultSet, dependentNodes.length);  // new ResultSet[size]
1:afa871e: 			mb.setField(arrayField);
1:eac0369: 			for(int index=0 ; index <  dependentNodes.length ; index++)
1:eac0369: 			{
1:eac0369: 				dependentNodes[index].setRefActionInfo(fkIndexConglomNumbers[index],
1:eac0369: 													   fkColArrays[index],
1:eac0369: 													   parentResultSetId,
1:eac0369: 													   true);
1:eac0369: 				mb.getField(arrayField); // first arg (resultset array reference)
1:eac0369: 				/*beetle:5360 : if too many statements are added  to a  method, 
1:eac0369: 				 *size of method can hit  65k limit, which will
1:eac0369: 				 *lead to the class format errors at load time.
1:eac0369: 				 *To avoid this problem, when number of statements added 
1:eac0369: 				 *to a method is > 2048, remaing statements are added to  a new function
1:eac0369: 				 *and called from the function which created the function.
1:eac0369: 				 *See Beetle 5135 or 4293 for further details on this type of problem.
1:eac0369: 				*/
1:eac0369: 				if(mb.statementNumHitLimit(10))
1:eac0369: 				{
1:eac0369: 					MethodBuilder dmb = acb.newGeneratedFun(ClassName.ResultSet, Modifier.PRIVATE);
1:eac0369: 					dependentNodes[index].generate(acb,dmb); //generates the resultset expression
1:eac0369: 					dmb.methodReturn();
1:eac0369: 					dmb.complete();
1:eac0369: 					/* Generate the call to the new method */
1:eac0369: 					mb.pushThis(); 
1:eac0369: 					//second arg will be generated by this call
1:eac0369: 					mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, dmb.getName(), ClassName.ResultSet, 0);
1:eac0369: 				}else
1:eac0369: 				{
1:eac0369: 					dependentNodes[index].generate(acb,mb); //generates the resultset expression
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				mb.setArrayElement(index);
1:eac0369: 			}	
1:eac0369: 			mb.getField(arrayField); // fourth argument - array reference
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if(isDependentTable)
1:eac0369: 			{
1:eac0369: 				mb.pushNull(resultSetArrayType); //No dependent tables for this table
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		if(cascadeDelete || isDependentTable)
1:eac0369: 		{
1:eac0369: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
1:eac0369: 			                       "." + targetTableDescriptor.getName();
1:eac0369: 			mb.push(parentResultSetId);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSetGetter, ClassName.ResultSet, argCount);
1:eac0369: 
1:eac0369: 
1:eac0369: 		if(!isDependentTable && cascadeDelete)
1:eac0369: 		{
1:eac0369: 			int numResultSets = acb.getRowCount();
1:eac0369: 			if(numResultSets > 0)
1:eac0369: 			{
1:eac0369: 				//generate activation.raParentResultSets = new NoPutResultSet[size]
1:eac0369: 				MethodBuilder constructor = acb.getConstructor();
1:eac0369: 				constructor.pushThis();
1:eac0369: 				constructor.pushNewArray(ClassName.CursorResultSet, numResultSets);
1:eac0369: 				constructor.putField(ClassName.BaseActivation,
1:eac0369: 									 "raParentResultSets",
1:eac0369: 									 ClassName.CursorResultSet + "[]");
1:eac0369: 				constructor.endStatement();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the type of statement, something from
1:eac0369: 	 * StatementType.
1:eac0369: 	 *
1:eac0369: 	 * @return the type of statement
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected final int getStatementType()
1:eac0369: 	{
1:eac0369: 		return StatementType.DELETE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets the map of all columns which must be read out of the base table.
1:eac0369: 	  * These are the columns needed to:
1:eac0369: 	  *
1:eac0369: 	  *		o	maintain indices
1:eac0369: 	  *		o	maintain foreign keys
1:eac0369: 	  *
1:eac0369: 	  *	The returned map is a FormatableBitSet with 1 bit for each column in the
1:eac0369: 	  * table plus an extra, unsued 0-bit. If a 1-based column id must
1:eac0369: 	  * be read from the base table, then the corresponding 1-based bit
1:eac0369: 	  * is turned ON in the returned FormatableBitSet.
1:eac0369: 	  *
1:eac0369: 	  *	@param	dd				the data dictionary to look in
1:eac0369: 	  *	@param	baseTable		the base table descriptor
1:eac0369: 	  *
1:eac0369: 	  *	@return	a FormatableBitSet of columns to be read out of the base table
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	public	FormatableBitSet	getReadMap
1:eac0369: 	(
1:eac0369: 		DataDictionary		dd,
1:eac0369: 		TableDescriptor		baseTable
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean[]	needsDeferredProcessing = new boolean[1];
1:eac0369: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
1:eac0369: 
1:71c8e86:         ArrayList<ConglomerateDescriptor> conglomerates = new ArrayList<ConglomerateDescriptor>();
1:801cf0d:         relevantTriggers = new TriggerDescriptorList();
1:eac0369: 
1:b153b24:         FormatableBitSet columnMap = DeleteNode.getDeleteReadMap(baseTable,
1:b153b24:                 conglomerates, relevantTriggers, needsDeferredProcessing);
1:b153b24: 
1:b153b24:         markAffectedIndexes(conglomerates);
1:eac0369: 
1:eac0369: 		adjustDeferredFlag( needsDeferredProcessing[0] );
1:eac0369: 
1:eac0369: 		return	columnMap;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * In case of referential actions, we require to perform
1:eac0369: 	 * DML (UPDATE or DELETE) on the dependent tables. 
1:eac0369: 	 * Following function returns the DML Node for the dependent table.
1:eac0369: 	 */
1:8a93440: 	private StatementNode getDependentTableNode(String tableName, int refAction,
1:eac0369: 												ColumnDescriptorList cdl) throws StandardException
1:eac0369: 	{
1:3541af3:         DMLModStatementNode node = null;
1:eac0369: 
1:eac0369: 		int index = tableName.indexOf('.');
1:eac0369: 		String schemaName = tableName.substring(0 , index);
1:eac0369: 		String tName = tableName.substring(index+1);
1:eac0369: 		if(refAction == StatementType.RA_CASCADE)
1:eac0369: 		{
1:eac0369: 			node = getEmptyDeleteNode(schemaName , tName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if(refAction == StatementType.RA_SETNULL)
1:eac0369: 		{
1:eac0369: 			node = getEmptyUpdateNode(schemaName , tName, cdl);
1:eac0369: 		}
1:eac0369: 
1:3541af3:         // The dependent node should be marked as such, and it should inherit
1:3541af3:         // the set of dependent tables from the parent so that it can break
1:3541af3:         // out of cycles in the dependency graph.
1:3541af3:         if (node != null) {
1:3541af3:             node.isDependentTable = true;
1:3541af3:             node.dependentTables = dependentTables;
1:3541af3:         }
1:3541af3: 
1:eac0369: 		return node;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:3541af3:     private DeleteNode getEmptyDeleteNode(String schemaName, String targetTableName)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ValueNode whereClause = null;
1:eac0369: 
1:3bb140c:         TableName tableName =
1:3bb140c:             new TableName(schemaName , targetTableName, getContextManager());
1:eac0369: 
1:3bb140c:         FromList fromList = new FromList(getContextManager());
1:3bb140c: 
1:3bb140c:         FromTable fromTable = new FromBaseTable(
1:3bb140c:                 tableName,
1:3bb140c:                 null,
1:bb5be6f:                 FromBaseTable.DELETE,
1:3bb140c:                 null,
1:3bb140c:                 getContextManager());
1:3bb140c: 
1:eac0369: 		//we would like to use references index & table scan instead of 
1:eac0369: 		//what optimizer says for the dependent table scan.
1:eac0369: 		Properties targetProperties = new FormatableProperties();
1:eac0369: 		targetProperties.put("index", "null");
1:eac0369: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
1:eac0369: 
1:eac0369:         fromList.addFromTable(fromTable);
1:3bb140c:         SelectNode rs = new SelectNode(null,
1:3bb140c:                                        fromList, /* FROM list */
1:3bb140c:                                        whereClause, /* WHERE clause */
1:3bb140c:                                        null, /* GROUP BY list */
1:3bb140c:                                        null, /* having clause */
1:3bb140c:                                        null, /* windows */
1:a56ecfa:                                        null, /* optimizer override plan */
1:3bb140c:                                        getContextManager());
1:eac0369: 
1:508a010:         return new DeleteNode(tableName, rs, null, getContextManager());
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:3541af3:     private UpdateNode getEmptyUpdateNode(String schemaName,
1:eac0369: 											 String targetTableName,
2:eac0369: 											 ColumnDescriptorList cdl)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 
1:eac0369:         ValueNode whereClause = null;
1:eac0369: 
1:3bb140c:         TableName tableName =
1:3bb140c:             new TableName(schemaName , targetTableName, getContextManager());
1:eac0369: 
1:3bb140c:         FromList fromList = new FromList(getContextManager());
1:eac0369: 
1:3bb140c:         FromTable fromTable = new FromBaseTable(
1:3bb140c:                 tableName,
1:3bb140c:                 null,
1:3bb140c:                 FromBaseTable.DELETE,
1:3bb140c:                 null,
1:3bb140c:                 getContextManager());
1:eac0369: 
1:eac0369: 
1:eac0369: 		//we would like to use references index & table scan instead of 
1:eac0369: 		//what optimizer says for the dependent table scan.
1:eac0369: 		Properties targetProperties = new FormatableProperties();
1:eac0369: 		targetProperties.put("index", "null");
1:eac0369: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
1:eac0369: 
1:eac0369:         fromList.addFromTable(fromTable);
1:eac0369: 
1:e1f49ca:         SelectNode sn = new SelectNode(getSetClause(cdl),
1:3bb140c:                                               fromList, /* FROM list */
1:3bb140c:                                               whereClause, /* WHERE clause */
1:3bb140c:                                               null, /* GROUP BY list */
1:3bb140c:                                               null, /* having clause */
1:3bb140c:                                               null, /* windows */
1:a56ecfa:                                               null, /* optimizer override plan */
1:3bb140c:                                               getContextManager());
1:eac0369: 
1:508a010:         return new UpdateNode(tableName, sn, null, getContextManager());
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:  
1:3bb140c:     private ResultColumnList getSetClause(ColumnDescriptorList cdl)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultColumn resultColumn;
1:eac0369: 		ValueNode	 valueNode;
1:eac0369: 
1:3bb140c:         ResultColumnList columnList = new ResultColumnList(getContextManager());
1:eac0369: 
1:3bb140c:         valueNode = new UntypedNullConstantNode(getContextManager());
1:eac0369: 		for(int index =0 ; index < cdl.size() ; index++)
1:eac0369: 		{
1:3bb140c:             ColumnDescriptor cd = cdl.elementAt(index);
1:eac0369: 			//only columns that are nullable need to be set to 'null' for ON
1:eac0369: 			//DELETE SET NULL
1:eac0369: 			if((cd.getType()).isNullable())
1:eac0369: 			{
1:3bb140c:                 resultColumn =
1:3bb140c:                         new ResultColumn(cd, valueNode, getContextManager());
1:eac0369: 
1:eac0369: 				columnList.addResultColumn(resultColumn);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return columnList;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:d725d43: 	public void optimizeStatement() throws StandardException
1:eac0369: 	{
1:daffaee:         // Don't add any more permissions during pre-processing
1:daffaee:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:daffaee:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:daffaee:         
1:eac0369: 		if(cascadeDelete)
1:eac0369: 		{
1:eac0369: 			for(int index=0 ; index < dependentNodes.length ; index++)
1:eac0369: 			{
1:8a93440: 				dependentNodes[index].optimizeStatement();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:508a010:         super.optimizeStatement();
1:daffaee: 
1:daffaee:         // allow more permissions to be added in case we're just one action
1:daffaee:         // of a MERGE statement
1:daffaee:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	  *	Builds a bitmap of all columns which should be read from the
1:eac0369: 	  *	Store in order to satisfy an DELETE statement.
1:eac0369: 	  *
1:eac0369: 	  *
1:eac0369: 	  *	1)	finds all indices on this table
1:eac0369: 	  *	2)	adds the index columns to a bitmap of affected columns
1:eac0369: 	  *	3)	adds the index descriptors to a list of conglomerate
1:eac0369: 	  *		descriptors.
1:eac0369: 	  *	4)	finds all DELETE triggers on the table
1:f246c9c: 	  *	5)	if there are any DELETE triggers, then do one of the following
1:f246c9c: 	  *     a)If all of the triggers have MISSING referencing clause, then that
1:f246c9c: 	  *      means that the trigger actions do not have access to before and
1:f246c9c: 	  *      after values. In that case, there is no need to blanketly decide 
1:f246c9c: 	  *      to include all the columns in the read map just because there are
1:f246c9c: 	  *      triggers defined on the table.
1:f246c9c: 	  *     b)Since one/more triggers have REFERENCING clause on them, get all
1:f246c9c: 	  *      the columns because we don't know what the user will ultimately 
1:f246c9c: 	  *      reference.
1:eac0369: 	  *	6)	adds the triggers to an evolving list of triggers
1:eac0369: 	  *
1:b153b24:       * @param  conglomerates       OUT: list of affected indices
1:eac0369: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
1:eac0369: 	  *	@param	needsDeferredProcessing			IN/OUT. true if the statement already needs
1:eac0369: 	  *											deferred processing. set while evaluating this
1:eac0369: 	  *											routine if a trigger requires
1:eac0369: 	  *											deferred processing
1:eac0369: 	  *
1:eac0369: 	  * @return a FormatableBitSet of columns to be read out of the base table
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	private static FormatableBitSet getDeleteReadMap
1:eac0369: 	(
1:eac0369: 		TableDescriptor				baseTable,
1:71c8e86:         List<ConglomerateDescriptor>  conglomerates,
1:801cf0d:         TriggerDescriptorList       relevantTriggers,
1:eac0369: 		boolean[]					needsDeferredProcessing
1:eac0369: 	)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int		columnCount = baseTable.getMaxColumnID();
1:eac0369: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
1:eac0369: 
1:eac0369: 		/* 
1:eac0369: 		** Get a list of the indexes that need to be 
1:eac0369: 		** updated.  ColumnMap contains all indexed
1:eac0369: 		** columns where 1 or more columns in the index
1:eac0369: 		** are going to be modified.
1:eac0369: 		**
1:eac0369: 		** Notice that we don't need to add constraint
1:eac0369: 		** columns.  This is because we add all key constraints
1:eac0369: 		** (e.g. foreign keys) as a side effect of adding their
1:eac0369: 		** indexes above.  And we don't need to deal with
1:eac0369: 		** check constraints on a delete.
1:eac0369: 		**
1:eac0369: 		** Adding indexes also takes care of the replication 
1:eac0369: 		** requirement of having the primary key.
1:eac0369: 		*/
1:b153b24:         DMLModStatementNode.getXAffectedIndexes(
1:b153b24:                 baseTable, null, columnMap, conglomerates);
1:eac0369: 
1:eac0369: 		/*
1:f246c9c: 	 	** If we have any DELETE triggers, then do one of the following
1:f246c9c: 	 	** 1)If all of the triggers have MISSING referencing clause, then that
1:f246c9c: 	 	** means that the trigger actions do not have access to before and 
1:f246c9c: 	 	** after values. In that case, there is no need to blanketly decide to
1:f246c9c: 	 	** include all the columns in the read map just because there are
1:f246c9c: 	 	** triggers defined on the table.
1:f246c9c: 	 	** 2)Since one/more triggers have REFERENCING clause on them, get all 
1:f246c9c: 	 	** the columns because we don't know what the user will ultimately reference.
1:eac0369: 	 	*/
1:eac0369: 		baseTable.getAllRelevantTriggers( StatementType.DELETE, (int[])null, relevantTriggers );
1:eac0369: 
1:eac0369: 		if (relevantTriggers.size() > 0)
1:eac0369: 		{
1:f246c9c: 			needsDeferredProcessing[0] = true;
1:f246c9c: 			
1:f246c9c: 			boolean needToIncludeAllColumns = false;
1:801cf0d: 
1:801cf0d:             for (TriggerDescriptor trd : relevantTriggers) {
1:a6f9586: 				//Does this trigger have REFERENCING clause defined on it.
1:a6f9586: 				//If yes, then read all the columns from the trigger table.
1:f246c9c: 				if (!trd.getReferencingNew() && !trd.getReferencingOld())
1:f246c9c: 					continue;
1:f246c9c: 				else
1:f246c9c: 				{
1:f246c9c: 					needToIncludeAllColumns = true;
1:f246c9c: 					break;
1:f246c9c: 				}
1:f246c9c: 			}
1:f246c9c: 
1:f246c9c: 			if (needToIncludeAllColumns) {
1:f246c9c: 				for (int i = 1; i <= columnCount; i++)
1:f246c9c: 				{
1:f246c9c: 					columnMap.set(i);
1:f246c9c: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return	columnMap;
1:eac0369: 	}
1:eac0369:     
1:eac0369: 	/*
1:444aa52: 	 * Force column references (particularly those added by the compiler)
1:444aa52: 	 * to use the correlation name on the base table, if any.
1:eac0369: 	 */
1:444aa52: 	private	void	correlateAddedColumns( ResultColumnList rcl, FromTable fromTable )
1:444aa52: 		throws StandardException
1:eac0369: 	{
1:444aa52: 		String		correlationName = fromTable.getCorrelationName();
1:eac0369: 
1:444aa52: 		if ( correlationName == null ) { return; }
1:eac0369: 
1:444aa52: 		TableName	correlationNameNode = makeTableName( null, correlationName );
1:eac0369: 
1:e1f49ca:         for (ResultColumn column : rcl)
1:444aa52: 		{
1:444aa52: 			ValueNode		expression = column.getExpression();
1:eac0369: 
1:444aa52: 			if ( (expression != null) && (expression instanceof ColumnReference) )
1:444aa52: 			{
1:444aa52: 				ColumnReference	reference = (ColumnReference) expression;
1:eac0369: 				
1:b0456a0: 				reference.setQualifiedTableName( correlationNameNode );
1:eac0369: 			}
1:444aa52: 		}
1:eac0369: 		
1:444aa52: 	}
1:eac0369: 	
1:444aa52: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 FromBaseTable.DELETE,
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     private boolean deferred;
1:     private FromTable targetTable;
1:     private FormatableBitSet readColsBitSet;
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:b153b24
/////////////////////////////////////////////////////////////////////////
0:         ArrayList conglomerates = new ArrayList();
1:         FormatableBitSet columnMap = DeleteNode.getDeleteReadMap(baseTable,
1:                 conglomerates, relevantTriggers, needsDeferredProcessing);
1: 
1:         markAffectedIndexes(conglomerates);
/////////////////////////////////////////////////////////////////////////
1:       * @param  conglomerates       OUT: list of affected indices
/////////////////////////////////////////////////////////////////////////
0:         List                        conglomerates,
/////////////////////////////////////////////////////////////////////////
1:         DMLModStatementNode.getXAffectedIndexes(
1:                 baseTable, null, columnMap, conglomerates);
commit:09c2697
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:1c6c2e8
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
0: 		ArrayList conglomVector = new ArrayList();
commit:3541af3
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
0:                     dependentTables = new HashSet();
1: 				/*Check whether the current target has already been explored.
1: 				if (dependentTables.add(currentTargetTableName))
/////////////////////////////////////////////////////////////////////////
1:                     dependentTables.add(currentTargetTableName);
/////////////////////////////////////////////////////////////////////////
1:         DMLModStatementNode node = null;
/////////////////////////////////////////////////////////////////////////
1:         // The dependent node should be marked as such, and it should inherit
1:         // the set of dependent tables from the parent so that it can break
1:         // out of cycles in the dependency graph.
1:         if (node != null) {
1:             node.isDependentTable = true;
1:             node.dependentTables = dependentTables;
1:         }
1: 
1:     private DeleteNode getEmptyDeleteNode(String schemaName, String targetTableName)
/////////////////////////////////////////////////////////////////////////
0:         return (DeleteNode) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
1:     private UpdateNode getEmptyUpdateNode(String schemaName,
/////////////////////////////////////////////////////////////////////////
0:         return (UpdateNode) nodeFactory.getNode(
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List						conglomVector,
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1: 		// createResultSet() will only be called once.
1: 		generateCodeForTemporaryTable(acb);
commit:ccee531
/////////////////////////////////////////////////////////////////////////
1: 		// If the DML is on the temporary table, generate the code to
1: 		// mark temporary table as modified in the current UOW. After
1: 		// DERBY-827 this must be done in execute() since
0: 		// fillResultSet() will only be called once.
0: 		generateCodeForTemporaryTable(acb, acb.getExecuteMethod());
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:                         getOptimizerFactory(),
1:                         targetTableDescriptor,
1:                         null,
1:                         resultColumnList,
1:                         (int[]) null,
1:                         readColsBitSet,
1:                         true, // we alway include triggers in core language
1:                         new boolean[1]); // dummy
commit:f167762
/////////////////////////////////////////////////////////////////////////
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
/////////////////////////////////////////////////////////////////////////
1:         relevantTriggers = new TriggerDescriptorList();
/////////////////////////////////////////////////////////////////////////
1:         TriggerDescriptorList       relevantTriggers,
/////////////////////////////////////////////////////////////////////////
1: 
1:             for (TriggerDescriptor trd : relevantTriggers) {
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:             int lckMode = resultSet.updateTargetLockMode();
/////////////////////////////////////////////////////////////////////////
1:                 lckMode = TransactionController.MODE_TABLE;
/////////////////////////////////////////////////////////////////////////
1:                   lckMode,
/////////////////////////////////////////////////////////////////////////
1:         SelectNode sn = new SelectNode(getSetClause(cdl),
/////////////////////////////////////////////////////////////////////////
0:         return new UpdateNode(tableName, sn, getContextManager());
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator<?> descIter = relevantTriggers.iterator();
/////////////////////////////////////////////////////////////////////////
1:         for (ResultColumn column : rcl)
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.FormatableProperties;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: import org.apache.derby.vti.DeferModification;
/////////////////////////////////////////////////////////////////////////
1: class DeleteNode extends DMLModStatementNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a DeleteNode.
1:      * @param cm                The context manager
0:     DeleteNode(TableName targetTableName,
1:                ResultSetNode queryExpression,
0:                ContextManager cm) {
0:         super(queryExpression, cm);
0:         setNodeType(C_NodeTypes.DELETE_NODE);
1:         this.targetTableName = targetTableName;
1:     @Override
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:             FromList fromList = new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
1:                     getContextManager());
1: 
1:             ResultColumn                rowLocationColumn = null;
/////////////////////////////////////////////////////////////////////////
1:             SelectNode sel = (SelectNode)resultSet;
/////////////////////////////////////////////////////////////////////////
1:                 resultColumnList =
1:                         new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:                 rowLocationNode =
1:                         new CurrentRowLocationNode(getContextManager());
1:                 rowLocationColumn =
1:                         new ResultColumn(COLUMNNAME,
1:                                          rowLocationNode,
1:                                          getContextManager());
/////////////////////////////////////////////////////////////////////////
0:                             getOptimizerFactory(),
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         TableName tableName =
1:             new TableName(schemaName , targetTableName, getContextManager());
1:         FromList fromList = new FromList(getContextManager());
1: 
1:         FromTable fromTable = new FromBaseTable(
1:                 tableName,
1:                 null,
1:                 FromBaseTable.DELETE,
1:                 null,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         SelectNode rs = new SelectNode(null,
1:                                        fromList, /* FROM list */
1:                                        whereClause, /* WHERE clause */
1:                                        null, /* GROUP BY list */
1:                                        null, /* having clause */
1:                                        null, /* windows */
1:                                        getContextManager());
0:         return new DeleteNode(tableName, rs, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         TableName tableName =
1:             new TableName(schemaName , targetTableName, getContextManager());
1:         FromList fromList = new FromList(getContextManager());
1: 
1:         FromTable fromTable = new FromBaseTable(
1:                 tableName,
1:                 null,
0:                 ReuseFactory.getInteger(FromBaseTable.DELETE),
1:                 null,
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
0:         SelectNode resultSet = new SelectNode(getSetClause(cdl),
1:                                               fromList, /* FROM list */
1:                                               whereClause, /* WHERE clause */
1:                                               null, /* GROUP BY list */
1:                                               null, /* having clause */
1:                                               null, /* windows */
1:                                               getContextManager());
0:         return new UpdateNode(tableName, resultSet, getContextManager());
1:     private ResultColumnList getSetClause(ColumnDescriptorList cdl)
1:         ResultColumnList columnList = new ResultColumnList(getContextManager());
1:         valueNode = new UntypedNullConstantNode(getContextManager());
1:             ColumnDescriptor cd = cdl.elementAt(index);
1:                 resultColumn =
1:                         new ResultColumn(cd, valueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
0: 													 null, /* windows */
0: 													 getContextManager());
/////////////////////////////////////////////////////////////////////////
0: 													 null, /* having clause */
0: 													 null, /* windows */
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1:             getCompilerContext().removePrivilegeFilter( scopeFilter );
/////////////////////////////////////////////////////////////////////////
1:         // Don't add any more permissions during pre-processing
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:         // allow more permissions to be added in case we're just one action
1:         // of a MERGE statement
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.ASSERT((resultSet.getResultColumns() == null),
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumnList    originalRCL = resultSet.getResultColumns();
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1: 				reference.setQualifiedTableName( correlationNameNode );
commit:fc9fd0d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1: import org.apache.derby.iapi.sql.compile.ScopeFilter;
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // Don't add privilege requirements for the UDT types of columns.
1:             // The compiler will attempt to add these when generating the full column list during
1:             // binding of the tables.
1:             //
1:             IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:             
/////////////////////////////////////////////////////////////////////////
1:             // done excluding column types from privilege checking
1:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
1: 
1:             // only add privileges when we're inside the WHERE clause
1:             ScopeFilter scopeFilter = new ScopeFilter( getCompilerContext(), CompilerContext.WHERE_SCOPE, 1 );
1:             getCompilerContext().addPrivilegeFilter( scopeFilter );
0:             //
0:             // Don't remove the WHERE scopeFilter. Pre-processing may try to
0:             // add other privileges which we don't need.
0:             //
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             // add need for DELETE privilege on the target table
1:             getCompilerContext().pushCurrentPrivType( getPrivType());
1:             getCompilerContext().addRequiredTablePriv( targetTableDescriptor);
1:             getCompilerContext().popCurrentPrivType();
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 				  dependentConstantActions,
1:                   inMatchingClause());
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
1:     DeleteNode
1:         (
1:          TableName targetTableName,
0:          ResultSetNode queryExpression,
1:          MatchingClauseNode matchingClause,
1:          ContextManager cm
1:          )
1:     {
1:         super( queryExpression, matchingClause, cm );
/////////////////////////////////////////////////////////////////////////
1: 
1:             // for DELETE clause of a MERGE statement, the tables have already been bound
1: 			if ( !inMatchingClause() ) { super.bindTables(dataDictionary); }
/////////////////////////////////////////////////////////////////////////
1: 				cursorTargetTableName = inMatchingClause() ?
1:                     targetTableName : currentOfNode.getBaseCursorTargetTableName();
/////////////////////////////////////////////////////////////////////////
1: 			if ( SanityManager.DEBUG )
1:             {
1:             }
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:                 /* Add the new result columns to the driving result set */
0:                 ResultColumnList    originalRCL = resultSet.resultColumns;
1:                 if ( originalRCL != null )
1:                 {
1:                     originalRCL.appendResultColumns( resultColumnList, false );
1:                     resultColumnList = originalRCL;
1:                 }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // arg 1
1:         if ( inMatchingClause() )
1:         {
1:             matchingClause.generateResultSetField( acb, mb );
1:         }
1:         else
1:         {
1:             resultSet.generate( acb, mb );
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return new DeleteNode(tableName, rs, null, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         return new UpdateNode(tableName, sn, null, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         super.optimizeStatement();
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
0:         return new UpdateNode(tableName, sn, false, getContextManager());
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1:                                        null, /* optimizer override plan */
/////////////////////////////////////////////////////////////////////////
1:                                               null, /* optimizer override plan */
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ConglomerateDescriptor> conglomerates = new ArrayList<ConglomerateDescriptor>();
/////////////////////////////////////////////////////////////////////////
1:         List<ConglomerateDescriptor>  conglomerates,
commit:9d5bd0e
/////////////////////////////////////////////////////////////////////////
1:                     dependentTables = new HashSet<String>();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c44e39a
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0:             for (Iterator descIter = relevantTriggers.iterator();
0:                     descIter.hasNext(); ) {
0:                 TriggerDescriptor trd = (TriggerDescriptor)descIter.next();
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
0: 		FormatableBitSet	columnMap = DeleteNode.getDeleteReadMap(baseTable,conglomVector, relevantTriggers, needsDeferredProcessing);
1: 		
/////////////////////////////////////////////////////////////////////////
1: 				//Does this trigger have REFERENCING clause defined on it.
1: 				//If yes, then read all the columns from the trigger table.
commit:f246c9c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1: 	  *	5)	if there are any DELETE triggers, then do one of the following
1: 	  *     a)If all of the triggers have MISSING referencing clause, then that
1: 	  *      means that the trigger actions do not have access to before and
1: 	  *      after values. In that case, there is no need to blanketly decide 
1: 	  *      to include all the columns in the read map just because there are
1: 	  *      triggers defined on the table.
1: 	  *     b)Since one/more triggers have REFERENCING clause on them, get all
1: 	  *      the columns because we don't know what the user will ultimately 
1: 	  *      reference.
/////////////////////////////////////////////////////////////////////////
1: 	 	** If we have any DELETE triggers, then do one of the following
1: 	 	** 1)If all of the triggers have MISSING referencing clause, then that
1: 	 	** means that the trigger actions do not have access to before and 
1: 	 	** after values. In that case, there is no need to blanketly decide to
1: 	 	** include all the columns in the read map just because there are
1: 	 	** triggers defined on the table.
1: 	 	** 2)Since one/more triggers have REFERENCING clause on them, get all 
1: 	 	** the columns because we don't know what the user will ultimately reference.
1: 			needsDeferredProcessing[0] = true;
1: 			
1: 			boolean needToIncludeAllColumns = false;
0: 			Enumeration descs = relevantTriggers.elements();
0: 			while (descs.hasMoreElements())
0: 				TriggerDescriptor trd = (TriggerDescriptor) descs.nextElement();
0: 				//Does this trigger have REFERENCING clause defined on it
1: 				if (!trd.getReferencingNew() && !trd.getReferencingOld())
1: 					continue;
1: 				else
1: 				{
1: 					needToIncludeAllColumns = true;
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (needToIncludeAllColumns) {
1: 				for (int i = 1; i <= columnCount; i++)
1: 				{
1: 					columnMap.set(i);
1: 				}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e5bbea4
/////////////////////////////////////////////////////////////////////////
0: 				emptyHeapRow = targetTableDescriptor.getEmptyExecRow();
commit:47efb18
/////////////////////////////////////////////////////////////////////////
commit:8a93440
/////////////////////////////////////////////////////////////////////////
1: 	private StatementNode[] dependentNodes;
/////////////////////////////////////////////////////////////////////////
1: 					dependentNodes = new StatementNode[noDependents];
1: 						dependentNodes[i].bindStatement();
/////////////////////////////////////////////////////////////////////////
1: 	private StatementNode getDependentTableNode(String tableName, int refAction,
0: 		StatementNode node=null;
/////////////////////////////////////////////////////////////////////////
0:     private StatementNode getEmptyDeleteNode(String schemaName, String targetTableName)
0:         TableName tableName = new TableName();
0:         FromTable fromTable = (FromTable) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
0:         SelectNode resultSet = (SelectNode) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
0:         return (StatementNode) nodeFactory.getNode(
0:     private StatementNode getEmptyUpdateNode(String schemaName, 
0:         TableName tableName = new TableName();
0:         FromTable fromTable = (FromTable) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
0:         SelectNode resultSet = (SelectNode) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
0:         return (StatementNode) nodeFactory.getNode(
/////////////////////////////////////////////////////////////////////////
1: 				dependentNodes[index].optimizeStatement();
commit:d725d43
/////////////////////////////////////////////////////////////////////////
1: 	public void optimizeStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 		super.optimizeStatement();
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
0: 			if (isPrivilegeCollectionRequired())
1: 			{
0: 				getCompilerContext().pushCurrentPrivType( getPrivType());
0: 				getCompilerContext().addRequiredTablePriv( targetTableDescriptor);
1: 				getCompilerContext().popCurrentPrivType();
1: 			}
commit:0061383
/////////////////////////////////////////////////////////////////////////
1: 	private static final String COLUMNNAME = "###RowLocationToDelete";
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
1: 				argCount = 4;
1: 				argCount = 1;
1: 			
1: 			argCount = 1;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:7736829
/////////////////////////////////////////////////////////////////////////
commit:5a95e6b
/////////////////////////////////////////////////////////////////////////
1: 		
/////////////////////////////////////////////////////////////////////////
1: 
1: 		
1: 		// descriptor must exist, tables already bound.
1: 		verifyTargetTable();
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 			mb.setField(arrayField);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.DeleteNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: 
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.StatementType;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.vti.DeferModification;
1: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.impl.sql.execute.DeleteConstantAction;
0: import org.apache.derby.impl.sql.execute.FKInfo;
1: 
1: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
0: import java.util.Vector;
0: import java.util.Hashtable;
1: import java.util.Properties;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: 
1: 
1: /**
1:  * A DeleteNode represents a DELETE statement. It is the top-level node
1:  * for the statement.
1:  *
1:  * For positioned delete, there may be no from table specified.
1:  * The from table will be derived from the cursor specification of
1:  * the named cursor.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public class DeleteNode extends DMLModStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/* Column name for the RowLocation column in the ResultSet */
0: 	public static final String COLUMNNAME = "###RowLocationToDelete";
1: 
1: 	/* Filled in by bind. */
0: 	protected boolean				deferred;
0: 	protected ExecRow				emptyHeapRow;
0: 	protected FromTable				targetTable;
0: 	protected FKInfo				fkInfo;
0: 	protected FormatableBitSet readColsBitSet;
1: 
1: 	private ConstantAction[] dependentConstantActions;
1: 	private boolean cascadeDelete;
0: 	private QueryTreeNode[] dependentNodes;
1: 
1: 	/**
0: 	 * Initializer for a DeleteNode.
1: 	 *
1: 	 * @param targetTableName	The name of the table to delete from
0: 	 * @param queryExpresssion	The query expression that will generate
1: 	 *				the rows to delete from the given table
1: 	 */
1: 
0: 	public void init(Object targetTableName,
0: 					  Object queryExpression)
1: 	{
0: 		super.init(queryExpression);
0: 		this.targetTableName = (TableName) targetTableName;
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "DELETE";
1: 	}
1: 
1: 	/**
1: 	 * Bind this DeleteNode.  This means looking up tables and columns and
1: 	 * getting their types, and figuring out the result types of all
1: 	 * expressions, as well as doing view resolution, permissions checking,
1: 	 * etc.
1: 	 * <p>
1: 	 * If any indexes need to be updated, we add all the columns in the
1: 	 * base table to the result column list, so that we can use the column
1: 	 * values as look-up keys for the index rows to be deleted.  Binding a
1: 	 * delete will also massage the tree so that the ResultSetNode has 
1: 	 * column containing the RowLocation of the base row.
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		FromList					fromList =
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 		ResultColumn				rowLocationColumn = null;
1: 		CurrentRowLocationNode		rowLocationNode;
1: 		TableName					cursorTargetTableName = null;
1: 		CurrentOfNode       		currentOfNode = null;
1: 
1:                 DataDictionary dataDictionary = getDataDictionary();
0: 		super.bindTables(dataDictionary);
1: 
1: 		// wait to bind named target table until the underlying
1: 		// cursor is bound, so that we can get it from the
1: 		// cursor if this is a positioned delete.
1: 
1: 		// for positioned delete, get the cursor's target table.
1: 		if (SanityManager.DEBUG)
1: 		SanityManager.ASSERT(resultSet != null && resultSet instanceof SelectNode,
1: 			"Delete must have a select result set");
1: 
0: 		SelectNode sel;
0: 		sel = (SelectNode)resultSet;
1: 		targetTable = (FromTable) sel.fromList.elementAt(0);
1: 		if (targetTable instanceof CurrentOfNode)
1: 		{
1: 			currentOfNode = (CurrentOfNode) targetTable;
1: 
0: 			cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
1: 			// instead of an assert, we might say the cursor is not updatable.
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(cursorTargetTableName != null);
1: 		}
1: 
1: 		if (targetTable instanceof FromVTI)
1: 		{
1: 			targetVTI = (FromVTI) targetTable;
1: 			targetVTI.setTarget();
1: 		}
1: 		else
1: 		{
1: 			// positioned delete can leave off the target table.
1: 			// we get it from the cursor supplying the position.
1: 			if (targetTableName == null)
1: 			{
1: 				// verify we have current of
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.ASSERT(cursorTargetTableName!=null);
1: 
1: 				targetTableName = cursorTargetTableName;
1: 			}
1: 			// for positioned delete, we need to verify that
1: 			// the named table is the same as the cursor's target (base table name).
1: 			else if (cursorTargetTableName != null)
1: 			{
1: 				// this match requires that the named table in the delete
1: 				// be the same as a base name in the cursor.
1: 				if ( !targetTableName.equals(cursorTargetTableName))
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_CURSOR_DELETE_MISMATCH, 
1: 						targetTableName,
1: 						currentOfNode.getCursorName());
1: 				}
1: 			}
1: 
0: 			/* descriptor must exist, tables already bound.
0: 			 * No need to do this for VTI as VTI was bound in
0: 			 * super.bindTables() above.
1: 			 */
0: 			verifyTargetTable();
1: 		}
1: 
1: 		/* Generate a select list for the ResultSetNode - CurrentRowLocation(). */
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((resultSet.resultColumns == null),
1: 							  "resultColumns is expected to be null until bind time");
1: 
1: 
1: 		if (targetTable instanceof FromVTI)
1: 		{
1: 			getResultColumnList();
0: 			resultColumnList = targetTable.getResultColumnsForList(null, resultColumnList, null);
1: 
1: 			/* Set the new result column list in the result set */
1: 			resultSet.setResultColumns(resultColumnList);
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** Start off assuming no columns from the base table
1: 			** are needed in the rcl.
1: 			*/
0: 			resultColumnList = new ResultColumnList();
1: 
1: 			FromBaseTable fbt = getResultColumnList(resultColumnList);
1: 
1: 			readColsBitSet = getReadMap(dataDictionary,
1: 										targetTableDescriptor);
1: 
1: 			resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
1: 			/*
1: 			** If all bits are set, then behave as if we chose all
1: 			** in the first place
1: 			*/
1: 			int i = 1;
1: 			int size = targetTableDescriptor.getMaxColumnID();
1: 			for (; i <= size; i++)
1: 			{
1: 				if (!readColsBitSet.get(i))
1: 				{
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (i > size)
1: 			{
1: 				readColsBitSet = null;
1: 			}
1: 
1: 			/*
0: 			** Construct an empty heap row for use in our constant action.
1: 			*/
0: 			emptyHeapRow = targetTableDescriptor.getEmptyExecRow(getContextManager());
1: 
1: 			/* Generate the RowLocation column */
0: 			rowLocationNode = (CurrentRowLocationNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CURRENT_ROW_LOCATION_NODE,
0: 										getContextManager());
0: 			rowLocationColumn =
0: 				(ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									COLUMNNAME,
0: 									rowLocationNode,
0: 									getContextManager());
1: 			rowLocationColumn.markGenerated();
1: 
1: 			/* Append to the ResultColumnList */
1: 			resultColumnList.addResultColumn(rowLocationColumn);
1: 
1: 			/* Set the new result column list in the result set */
1: 			resultSet.setResultColumns(resultColumnList);
1: 		}
1: 
1: 		/* Bind the expressions before the ResultColumns are bound */
1: 		super.bindExpressions();
1: 
1: 		/* Bind untyped nulls directly under the result columns */
0: 		resultSet.
0: 			getResultColumns().
1: 				bindUntypedNullsToResultColumns(resultColumnList);
1: 
1: 		if (! (targetTable instanceof FromVTI))
1: 		{
1: 			/* Bind the new ResultColumn */
1: 			rowLocationColumn.bindResultColumnToExpression();
1: 
1: 			bindConstraints(dataDictionary,
0: 							getNodeFactory(),
0: 							targetTableDescriptor,
1: 							null,
0: 							resultColumnList,
0: 							(int[]) null,
0: 							readColsBitSet,
1: 							false,
0: 							true);  /* we alway include triggers in core language */
1: 
1: 			/* If the target table is also a source table, then
1: 			 * the delete will have to be in deferred mode
1: 			 * For deletes, this means that the target table appears in a
1: 			 * subquery.  Also, self-referencing foreign key deletes
1: 		 	 * are deferred.  And triggers cause the delete to be deferred.
1: 			 */
1: 			if (resultSet.subqueryReferencesTarget(
1: 									targetTableDescriptor.getName(), true) ||
1: 				requiresDeferredProcessing())
1: 			{
1: 				deferred = true;
1: 			}
1: 		}
1: 		else
1: 		{
1:             deferred = VTIDeferModPolicy.deferIt( DeferModification.DELETE_STATEMENT,
1:                                                   targetVTI,
1:                                                   null,
1:                                                   sel.getWhereClause());
1: 		}
0:         sel = null; // done with sel
1: 
1: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromList.size() == 0,
1: 				"fromList.size() is expected to be 0, not " +
1: 				fromList.size() +
1: 				" on return from RS.bindExpressions()");
1: 		}
1: 
1: 
1: 		//In case of cascade delete , create nodes for
1: 		//the ref action  dependent tables and bind them.
1: 		if(fkTableNames != null)
1: 		{
0: 			String currentTargetTableName =
0: 				targetTableDescriptor.getSchemaName() + "." + targetTableDescriptor.getName();
1: 
1: 			if(!isDependentTable){
1: 				//graph node
0: 				graphHashTable = new Hashtable();
1: 			}
1: 
0: 			/*Check whether the current tatget is already been explored.
1: 			 *If we are seeing the same table name which we binded earlier
1: 			 *means we have cyclic references.
1: 			 */
0: 			if(!graphHashTable.containsKey(currentTargetTableName))
1: 			{
1: 				cascadeDelete = true;
1: 				int noDependents = fkTableNames.length;
0: 				dependentNodes = new QueryTreeNode[noDependents];
0: 				graphHashTable.put(currentTargetTableName, new Integer(noDependents));
1: 				for(int i =0 ; i < noDependents ; i ++)
1: 				{
1: 					dependentNodes[i] = getDependentTableNode(fkTableNames[i],
1: 															  fkRefActions[i],
1: 															  fkColDescriptors[i]);
0: 					dependentNodes[i].bind();
1: 				}
1: 			}
1: 		}else
1: 		{
1: 			//case where current dependent table does not have dependent tables
1: 			if(isDependentTable)
1: 			{
0: 				String currentTargetTableName =
0: 					targetTableDescriptor.getSchemaName() + "." + targetTableDescriptor.getName();
0: 				graphHashTable.put(currentTargetTableName, new Integer(0));
1: 
1: 			}
1: 
1: 		}
0: 		return this;
1: 	} // end of bind
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		//If delete table is on a SESSION schema table, then return true. 
1: 		return resultSet.referencesSessionSchema();
1: 	}
1: 
1: 	/**
1: 	 * Compile constants that Execution will use
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 
1: 		/* Different constant actions for base tables and updatable VTIs */
1: 		if (targetTableDescriptor != null)
1: 		{
1: 			// Base table
0: 			int lockMode = resultSet.updateTargetLockMode();
1: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1: 			TransactionController tc = getLanguageConnectionContext().getTransactionCompile();
1: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1: 				new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
1: 
1: 			for (int index = 0; index < indexSCOCIs.length; index++)
1: 			{
1: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1: 			}
1: 
1: 			/*
1: 			** Do table locking if the table's lock granularity is
1: 			** set to table.
1: 			*/
1: 			if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1: 			{
0: 				lockMode = TransactionController.MODE_TABLE;
1: 			}
1: 
1: 			ResultDescription resultDescription = null;
1: 			if(isDependentTable)
1: 			{
1: 				//triggers need the result description ,
1: 				//dependent tables  don't have a source from generation time
1: 				//to get the result description
1: 				resultDescription = makeResultDescription();
1: 			}
1: 
1: 
1: 			return	getGenericConstantActionFactory().getDeleteConstantAction
1: 				( heapConglomId,
1: 				  targetTableDescriptor.getTableType(),
1: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
1: 				  indicesToMaintain,
1: 				  indexConglomerateNumbers,
1: 				  indexSCOCIs,
0: 				  emptyHeapRow,
1: 				  deferred,
1: 				  false,
1: 				  targetTableDescriptor.getUUID(),
0: 				  lockMode,
1: 				  null, null, null, 0, null, null, 
1: 				  resultDescription,
1: 				  getFKInfo(), 
1: 				  getTriggerInfo(), 
1: 				  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
1: 				  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
1: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1:  				  (readColsBitSet == null) ? 
1: 					  targetTableDescriptor.getNumberOfColumns() :
1: 					  readColsBitSet.getNumBitsSet(),			
1: 				  (UUID) null,
1: 				  resultSet.isOneRowResultSet(),
0: 				  dependentConstantActions);
1: 		}
1: 		else
1: 		{
1: 			/* Return constant action for VTI
1: 			 * NOTE: ConstantAction responsible for preserving instantiated
1: 			 * VTIs for in-memory queries and for only preserving VTIs
1: 			 * that implement Serializable for SPSs.
1: 			 */
1: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.DELETE_STATEMENT,
1: 						deferred);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Code generation for delete.
1: 	 * The generated code will contain:
1: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations
1: 	 *		o  The static member will be assigned the appropriate ResultSet within
1: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
1: 	 *		   (xxx)ResultSet will be generated.)
1: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
1: 	 *		   a new method for returning the RowLocation as well as a call to
1: 	 *		   that method which will be stuffed in the call to the 
1: 	 *		    ProjectRestrictResultSet.
1: 	 *      o In case of referential actions, this function generate an
1: 	 *        array of resultsets on its dependent tables.
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb	The execute() method to be built
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
1: 
1: 		/* generate the parameters */
1: 		if(!isDependentTable)
1: 			generateParameterValueSet(acb);
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb); 
1: 		acb.newRowLocationScanResultSetName();
0: 		resultSet.generate(acb, mb); // arg 1
1: 
1: 		String resultSetGetter;
1: 		int argCount;
1: 		String parentResultSetId;
1: 
1: 		// Base table
1: 		if (targetTableDescriptor != null)
1: 		{
1: 			/* Create the declaration for the scan ResultSet which generates the
1: 			 * RowLocations to be deleted.
1: 	 		 * Note that the field cannot be static because there
1: 			 * can be multiple activations of the same activation class,
1: 			 * and they can't share this field.  Only exprN fields can
1: 			 * be shared (or, more generally, read-only fields).
1: 			 * RESOLVE - Need to deal with the type of the field.
1: 			 */
1: 
1: 			acb.newFieldDeclaration(Modifier.PRIVATE, 
1: 									ClassName.CursorResultSet, 
1: 									acb.getRowLocationScanResultSetName());
1: 
1: 			if(cascadeDelete || isDependentTable)
1: 			{
1: 				resultSetGetter = "getDeleteCascadeResultSet";
1: 			}		
1: 			else
1: 			{
1: 				resultSetGetter = "getDeleteResultSet";
1: 			}
0: 			argCount = 2;
1: 		} else {
0: 			argCount = 2;
1: 			resultSetGetter = "getDeleteVTIResultSet";
1: 		}
1: 
1: 
0: 		acb.pushThisAsActivation(mb);
1: 
1: 		if(isDependentTable)
1: 		{
0: 			argCount = 3;
1: 			mb.push(acb.addItem(makeConstantAction()));
1: 		
1: 		}else
1: 		{
1: 			if(cascadeDelete)
1: 			{
0: 				argCount = 3;
1: 				mb.push(-1); //root table.
1: 			}
1: 		}		
1: 
1: 		String		resultSetArrayType = ClassName.ResultSet + "[]";
1: 		if(cascadeDelete)
1: 		{
1: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
1: 			                       "." + targetTableDescriptor.getName();
1: 			// Generate the code to build the array
1: 			LocalField arrayField =
1: 				acb.newFieldDeclaration(Modifier.PRIVATE, resultSetArrayType);
1: 			mb.pushNewArray(ClassName.ResultSet, dependentNodes.length);  // new ResultSet[size]
0: 			mb.putField(arrayField);
0: 			mb.endStatement();
1: 
0: 			argCount = 4;
1: 			for(int index=0 ; index <  dependentNodes.length ; index++)
1: 			{
1: 
1: 				dependentNodes[index].setRefActionInfo(fkIndexConglomNumbers[index],
1: 													   fkColArrays[index],
1: 													   parentResultSetId,
1: 													   true);
1: 				mb.getField(arrayField); // first arg (resultset array reference)
1: 				/*beetle:5360 : if too many statements are added  to a  method, 
1: 				 *size of method can hit  65k limit, which will
1: 				 *lead to the class format errors at load time.
1: 				 *To avoid this problem, when number of statements added 
1: 				 *to a method is > 2048, remaing statements are added to  a new function
1: 				 *and called from the function which created the function.
1: 				 *See Beetle 5135 or 4293 for further details on this type of problem.
1: 				*/
1: 				if(mb.statementNumHitLimit(10))
1: 				{
1: 					MethodBuilder dmb = acb.newGeneratedFun(ClassName.ResultSet, Modifier.PRIVATE);
1: 					dependentNodes[index].generate(acb,dmb); //generates the resultset expression
1: 					dmb.methodReturn();
1: 					dmb.complete();
1: 					/* Generate the call to the new method */
1: 					mb.pushThis(); 
1: 					//second arg will be generated by this call
1: 					mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, dmb.getName(), ClassName.ResultSet, 0);
1: 				}else
1: 				{
1: 					dependentNodes[index].generate(acb,mb); //generates the resultset expression
1: 				}
1: 
1: 				mb.setArrayElement(index);
1: 			}	
1: 			mb.getField(arrayField); // fourth argument - array reference
1: 		}
1: 		else
1: 		{
1: 			if(isDependentTable)
1: 			{
0: 				argCount =4;
1: 				mb.pushNull(resultSetArrayType); //No dependent tables for this table
1: 			}
1: 		}
1: 
1: 
1: 		if(cascadeDelete || isDependentTable)
1: 		{
1: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
1: 			                       "." + targetTableDescriptor.getName();
0: 			argCount = 5;
1: 			mb.push(parentResultSetId);
1: 
1: 		}
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSetGetter, ClassName.ResultSet, argCount);
1: 
1: 
1: 		if(!isDependentTable && cascadeDelete)
1: 		{
1: 			int numResultSets = acb.getRowCount();
1: 			if(numResultSets > 0)
1: 			{
1: 				//generate activation.raParentResultSets = new NoPutResultSet[size]
1: 				MethodBuilder constructor = acb.getConstructor();
1: 				constructor.pushThis();
1: 				constructor.pushNewArray(ClassName.CursorResultSet, numResultSets);
1: 				constructor.putField(ClassName.BaseActivation,
1: 									 "raParentResultSets",
1: 									 ClassName.CursorResultSet + "[]");
1: 				constructor.endStatement();
1: 			}
1: 		}
1: 
1: 		/*
0: 		** ensure all parameters have been generated
1: 		*/
1: 		if(!isDependentTable)
0: 			generateParameterHolders(acb);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return the type of statement, something from
1: 	 * StatementType.
1: 	 *
1: 	 * @return the type of statement
1: 	 */
1: 	protected final int getStatementType()
1: 	{
1: 		return StatementType.DELETE;
1: 	}
1: 
1: 
1: 	/**
1: 	  *	Gets the map of all columns which must be read out of the base table.
1: 	  * These are the columns needed to:
1: 	  *
1: 	  *		o	maintain indices
1: 	  *		o	maintain foreign keys
1: 	  *
1: 	  *	The returned map is a FormatableBitSet with 1 bit for each column in the
1: 	  * table plus an extra, unsued 0-bit. If a 1-based column id must
1: 	  * be read from the base table, then the corresponding 1-based bit
1: 	  * is turned ON in the returned FormatableBitSet.
1: 	  *
1: 	  *	@param	dd				the data dictionary to look in
1: 	  *	@param	baseTable		the base table descriptor
1: 	  *
1: 	  *	@return	a FormatableBitSet of columns to be read out of the base table
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	public	FormatableBitSet	getReadMap
1: 	(
1: 		DataDictionary		dd,
1: 		TableDescriptor		baseTable
1: 	)
1: 		throws StandardException
1: 	{
1: 		boolean[]	needsDeferredProcessing = new boolean[1];
1: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
1: 
0: 		Vector		conglomVector = new Vector();
0: 		relevantTriggers = new GenericDescriptorList();
1: 
0: 		FormatableBitSet	columnMap = DeleteNode.getDeleteReadMap(baseTable, conglomVector, relevantTriggers, needsDeferredProcessing );
1: 
0: 		markAffectedIndexes( conglomVector );
1: 
1: 		adjustDeferredFlag( needsDeferredProcessing[0] );
1: 
1: 		return	columnMap;
1: 	}
1: 
1: 	/**
1: 	 * In case of referential actions, we require to perform
1: 	 * DML (UPDATE or DELETE) on the dependent tables. 
1: 	 * Following function returns the DML Node for the dependent table.
1: 	 */
0: 	private QueryTreeNode getDependentTableNode(String tableName, int refAction,
1: 												ColumnDescriptorList cdl) throws StandardException
1: 	{
0: 		QueryTreeNode node=null;
1: 
1: 		int index = tableName.indexOf('.');
1: 		String schemaName = tableName.substring(0 , index);
1: 		String tName = tableName.substring(index+1);
1: 		if(refAction == StatementType.RA_CASCADE)
1: 		{
1: 			node = getEmptyDeleteNode(schemaName , tName);
0: 			((DeleteNode)node).isDependentTable = true;
0: 			((DeleteNode)node).graphHashTable = graphHashTable;
1: 		}
1: 
1: 		if(refAction == StatementType.RA_SETNULL)
1: 		{
1: 			node = getEmptyUpdateNode(schemaName , tName, cdl);
0: 			((UpdateNode)node).isDependentTable = true;
0: 			((UpdateNode)node).graphHashTable = graphHashTable;
1: 		}
1: 
1: 		return node;
1: 	}
1: 
1: 
0:     private QueryTreeNode getEmptyDeleteNode(String schemaName, String targetTableName)
1:         throws StandardException
1:     {
1: 
1:         ValueNode whereClause = null;
0:         TableName tableName = null;
0:         FromTable fromTable = null;
0:         QueryTreeNode retval;
0:         SelectNode resultSet;
1: 
0:         tableName = new TableName();
0:         tableName.init(schemaName , targetTableName);
1: 
0:         NodeFactory nodeFactory = getNodeFactory();
0:         FromList   fromList = (FromList) nodeFactory.getNode(C_NodeTypes.FROM_LIST, getContextManager());
0:         fromTable = (FromTable) nodeFactory.getNode(
0:                                                     C_NodeTypes.FROM_BASE_TABLE,
0:                                                     tableName,
1:                                                     null,
0:                                                     ReuseFactory.getInteger(FromBaseTable.DELETE),
1:                                                     null,
0:                                                     getContextManager());
1: 
1: 		//we would like to use references index & table scan instead of 
1: 		//what optimizer says for the dependent table scan.
1: 		Properties targetProperties = new FormatableProperties();
1: 		targetProperties.put("index", "null");
1: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
1: 
1:         fromList.addFromTable(fromTable);
0:         resultSet = (SelectNode) nodeFactory.getNode(
0:                                                      C_NodeTypes.SELECT_NODE,
1:                                                      null,
0:                                                      null,   /* AGGREGATE list */
0:                                                      fromList, /* FROM list */
0:                                                      whereClause, /* WHERE clause */
0:                                                      null, /* GROUP BY list */
0:                                                      getContextManager());
1: 
0:         retval =(QueryTreeNode) nodeFactory.getNode(
0:                                                     C_NodeTypes.DELETE_NODE,
0:                                                     tableName,
0:                                                     resultSet,
0:                                                     getContextManager());
1: 
0:         return retval;
1:     }
1: 
1: 
1: 	
0:     private QueryTreeNode getEmptyUpdateNode(String schemaName, 
1: 											 String targetTableName,
1: 											 ColumnDescriptorList cdl)
1:         throws StandardException
1:     {
1: 
1:         ValueNode whereClause = null;
0:         TableName tableName = null;
0:         FromTable fromTable = null;
0:         QueryTreeNode retval;
0:         SelectNode resultSet;
1: 
0:         tableName = new TableName();
0:         tableName.init(schemaName , targetTableName);
1: 
0:         NodeFactory nodeFactory = getNodeFactory();
0:         FromList   fromList = (FromList) nodeFactory.getNode(C_NodeTypes.FROM_LIST, getContextManager());
0:         fromTable = (FromTable) nodeFactory.getNode(
0:                                                     C_NodeTypes.FROM_BASE_TABLE,
0:                                                     tableName,
1:                                                     null,
0:                                                     ReuseFactory.getInteger(FromBaseTable.DELETE),
1:                                                     null,
0:                                                     getContextManager());
1: 
1: 
1: 		//we would like to use references index & table scan instead of 
1: 		//what optimizer says for the dependent table scan.
1: 		Properties targetProperties = new FormatableProperties();
1: 		targetProperties.put("index", "null");
1: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
1: 
1:         fromList.addFromTable(fromTable);
1: 
0: 		resultSet = (SelectNode) nodeFactory.getNode(
0:                                                      C_NodeTypes.SELECT_NODE,
0:                                                      getSetClause(tableName, cdl),
0:                                                      null,   /* AGGREGATE list */
0:                                                      fromList, /* FROM list */
0:                                                      whereClause, /* WHERE clause */
0:                                                      null, /* GROUP BY list */
0:                                                      getContextManager());
1: 
0:         retval =(QueryTreeNode) nodeFactory.getNode(
0:                                                     C_NodeTypes.UPDATE_NODE,
0:                                                     tableName,
0:                                                     resultSet,
0:                                                     getContextManager());
1: 
0:         return retval;
1:     }
1: 
1: 
1:  
0: 	private ResultColumnList getSetClause(TableName tabName,
1: 										  ColumnDescriptorList cdl)
1: 		throws StandardException
1: 	{
1: 		ResultColumn resultColumn;
1: 		ValueNode	 valueNode;
1: 
0: 		NodeFactory nodeFactory = getNodeFactory();
0: 		ResultColumnList	columnList = (ResultColumnList) nodeFactory.getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
1: 
0: 		valueNode =  (ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
0: 															 getContextManager());
1: 		for(int index =0 ; index < cdl.size() ; index++)
1: 		{
0: 			ColumnDescriptor cd = (ColumnDescriptor) cdl.elementAt(index);
1: 			//only columns that are nullable need to be set to 'null' for ON
1: 			//DELETE SET NULL
1: 			if((cd.getType()).isNullable())
1: 			{
0: 				resultColumn = (ResultColumn) nodeFactory.getNode(
0:    									    C_NodeTypes.RESULT_COLUMN,
0: 										cd,
0: 										valueNode,
0: 										getContextManager());
1: 
1: 				columnList.addResultColumn(resultColumn);
1: 			}
1: 		}
1: 		return columnList;
1: 	}
1: 
1: 
0: 	public QueryTreeNode optimize() throws StandardException
1: 	{
1: 		if(cascadeDelete)
1: 		{
1: 			for(int index=0 ; index < dependentNodes.length ; index++)
1: 			{
0: 				dependentNodes[index] =  dependentNodes[index].optimize();
1: 			}
1: 		}
1: 
0: 		return super.optimize();
1: 	}
1: 
1:     /**
1: 	  *	Builds a bitmap of all columns which should be read from the
1: 	  *	Store in order to satisfy an DELETE statement.
1: 	  *
1: 	  *
1: 	  *	1)	finds all indices on this table
1: 	  *	2)	adds the index columns to a bitmap of affected columns
1: 	  *	3)	adds the index descriptors to a list of conglomerate
1: 	  *		descriptors.
1: 	  *	4)	finds all DELETE triggers on the table
0: 	  *	5)	if there are any DELETE triggers, marks all columns in the bitmap
1: 	  *	6)	adds the triggers to an evolving list of triggers
1: 	  *
0: 	  *	@param	conglomVector		OUT: vector of affected indices
1: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
1: 	  *	@param	needsDeferredProcessing			IN/OUT. true if the statement already needs
1: 	  *											deferred processing. set while evaluating this
1: 	  *											routine if a trigger requires
1: 	  *											deferred processing
1: 	  *
1: 	  * @return a FormatableBitSet of columns to be read out of the base table
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	private static FormatableBitSet getDeleteReadMap
1: 	(
1: 		TableDescriptor				baseTable,
0: 		Vector						conglomVector,
0: 		GenericDescriptorList		relevantTriggers,
1: 		boolean[]					needsDeferredProcessing
1: 	)
1: 		throws StandardException
1: 	{
1: 		int		columnCount = baseTable.getMaxColumnID();
1: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
1: 
1: 		/* 
1: 		** Get a list of the indexes that need to be 
1: 		** updated.  ColumnMap contains all indexed
1: 		** columns where 1 or more columns in the index
1: 		** are going to be modified.
1: 		**
1: 		** Notice that we don't need to add constraint
1: 		** columns.  This is because we add all key constraints
1: 		** (e.g. foreign keys) as a side effect of adding their
1: 		** indexes above.  And we don't need to deal with
1: 		** check constraints on a delete.
1: 		**
1: 		** Adding indexes also takes care of the replication 
1: 		** requirement of having the primary key.
1: 		*/
0: 		DMLModStatementNode.getXAffectedIndexes(baseTable,  null, columnMap, conglomVector );
1: 
1: 		/*
0: 	 	** If we have any triggers, then get all the columns
0: 		** because we don't know what the user will ultimately
0: 		** reference.
1: 	 	*/
1: 		baseTable.getAllRelevantTriggers( StatementType.DELETE, (int[])null, relevantTriggers );
0: 		if ( relevantTriggers.size() > 0 ) { needsDeferredProcessing[0] = true; }
1: 
1: 		if (relevantTriggers.size() > 0)
1: 		{
0: 			for (int i = 1; i <= columnCount; i++)
1: 			{
0: 				columnMap.set(i);
1: 			}
1: 		}
1: 
1: 		return	columnMap;
1: 	}
1:     
1: }
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
0:                                                      null, /* having clause */
/////////////////////////////////////////////////////////////////////////
0: 						     null, /* having clause */
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param queryExpression	The query expression that will generate
commit:444aa52
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: 			/* Force the added columns to take on the table's correlation name, if any */
1: 			correlateAddedColumns( resultColumnList, targetTable );
0: 			
/////////////////////////////////////////////////////////////////////////
0: 	/*
1: 	 * Force column references (particularly those added by the compiler)
1: 	 * to use the correlation name on the base table, if any.
0: 	 */
1: 	private	void	correlateAddedColumns( ResultColumnList rcl, FromTable fromTable )
1: 		throws StandardException
1: 	{
1: 		String		correlationName = fromTable.getCorrelationName();
0: 
1: 		if ( correlationName == null ) { return; }
0: 
1: 		TableName	correlationNameNode = makeTableName( null, correlationName );
0: 		int			count = rcl.size();
0: 
0: 		for ( int i = 0; i < count; i++ )
1: 		{
0: 			ResultColumn	column = (ResultColumn) rcl.elementAt( i );
0: 
1: 			ValueNode		expression = column.getExpression();
0: 
1: 			if ( (expression != null) && (expression instanceof ColumnReference) )
1: 			{
1: 				ColumnReference	reference = (ColumnReference) expression;
0: 				
0: 				reference.setTableNameNode( correlationNameNode );
1: 			}
1: 		}
0: 		
1: 	}
0: 	
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1: 		// We just need select privilege on the where clause tables
1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
1: 		try
0: 		{
0: 			FromList	fromList = (FromList) getNodeFactory().getNode(
0: 			ResultColumn				rowLocationColumn = null;
0: 			CurrentRowLocationNode		rowLocationNode;
0: 			TableName					cursorTargetTableName = null;
0: 			CurrentOfNode       		currentOfNode = null;
0: 			DataDictionary dataDictionary = getDataDictionary();
0: 			super.bindTables(dataDictionary);
0: 			// wait to bind named target table until the underlying
0: 			// cursor is bound, so that we can get it from the
0: 			// cursor if this is a positioned delete.
0: 			// for positioned delete, get the cursor's target table.
0: 				SanityManager.ASSERT(resultSet != null && resultSet instanceof SelectNode,
0: 				"Delete must have a select result set");
0: 			SelectNode sel;
0: 			sel = (SelectNode)resultSet;
0: 			targetTable = (FromTable) sel.fromList.elementAt(0);
0: 			if (targetTable instanceof CurrentOfNode)
0: 				currentOfNode = (CurrentOfNode) targetTable;
0: 
0: 				cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
0: 				// instead of an assert, we might say the cursor is not updatable.
0: 					SanityManager.ASSERT(cursorTargetTableName != null);
1: 			}
0: 
0: 			if (targetTable instanceof FromVTI)
0: 			{
0: 				targetVTI = (FromVTI) targetTable;
0: 				targetVTI.setTarget();
1: 			}
1: 			else
0: 			{
0: 				// positioned delete can leave off the target table.
0: 				// we get it from the cursor supplying the position.
0: 				if (targetTableName == null)
0: 				{
0: 					// verify we have current of
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(cursorTargetTableName!=null);
1: 				}
0: 				// for positioned delete, we need to verify that
0: 				// the named table is the same as the cursor's target (base table name).
0: 				else if (cursorTargetTableName != null)
0: 					// this match requires that the named table in the delete
0: 					// be the same as a base name in the cursor.
0: 					if ( !targetTableName.equals(cursorTargetTableName))
0: 					{
0: 						throw StandardException.newException(SQLState.LANG_CURSOR_DELETE_MISMATCH, 
0: 							targetTableName,
0: 							currentOfNode.getCursorName());
1: 					}
0: 			// descriptor must exist, tables already bound.
0: 			verifyTargetTable();
0: 			/* Generate a select list for the ResultSetNode - CurrentRowLocation(). */
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT((resultSet.resultColumns == null),
0: 			if (targetTable instanceof FromVTI)
0: 			{
0: 				getResultColumnList();
1: 				resultColumnList = targetTable.getResultColumnsForList(null, 
1: 								resultColumnList, null);
0: 				/* Set the new result column list in the result set */
0: 				resultSet.setResultColumns(resultColumnList);
1: 			}
1: 			else
0: 			{
0: 				/*
0: 				** Start off assuming no columns from the base table
0: 				** are needed in the rcl.
0: 				*/
0: 				resultColumnList = new ResultColumnList();
0: 				FromBaseTable fbt = getResultColumnList(resultColumnList);
0: 				readColsBitSet = getReadMap(dataDictionary,
0: 				resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
0: 				/*
0: 				** If all bits are set, then behave as if we chose all
0: 				** in the first place
0: 				*/
0: 				int i = 1;
0: 				int size = targetTableDescriptor.getMaxColumnID();
0: 				for (; i <= size; i++)
0: 					if (!readColsBitSet.get(i))
0: 					{
0: 						break;
1: 					}
0: 				if (i > size)
0: 				{
0: 					readColsBitSet = null;
1: 				}
0: 				/*
0: 				** Construct an empty heap row for use in our constant action.
0: 				*/
0: 				emptyHeapRow = targetTableDescriptor.getEmptyExecRow(getContextManager());
0: 				/* Generate the RowLocation column */
0: 				rowLocationNode = (CurrentRowLocationNode) getNodeFactory().getNode(
0: 				rowLocationColumn =
0: 					(ResultColumn) getNodeFactory().getNode(
0: 				rowLocationColumn.markGenerated();
0: 				/* Append to the ResultColumnList */
0: 				resultColumnList.addResultColumn(rowLocationColumn);
0: 				/* Force the added columns to take on the table's correlation name, if any */
0: 				correlateAddedColumns( resultColumnList, targetTable );
0: 				/* Set the new result column list in the result set */
0: 				resultSet.setResultColumns(resultColumnList);
1: 			}
0: 			/* Bind the expressions before the ResultColumns are bound */
0: 			super.bindExpressions();
0: 			/* Bind untyped nulls directly under the result columns */
1: 			resultSet.getResultColumns().
0: 			if (! (targetTable instanceof FromVTI))
0: 			{
0: 				/* Bind the new ResultColumn */
0: 				rowLocationColumn.bindResultColumnToExpression();
0: 				bindConstraints(dataDictionary,
/////////////////////////////////////////////////////////////////////////
0: 				/* If the target table is also a source table, then
0: 			 	* the delete will have to be in deferred mode
0: 			 	* For deletes, this means that the target table appears in a
0: 			 	* subquery.  Also, self-referencing foreign key deletes
0: 		 	 	* are deferred.  And triggers cause the delete to be deferred.
0: 			 	*/
0: 				if (resultSet.subqueryReferencesTarget(
0: 					requiresDeferredProcessing())
0: 				{
0: 					deferred = true;
0: 				}
0: 			else
0: 			{
0:             	deferred = VTIDeferModPolicy.deferIt( DeferModification.DELETE_STATEMENT,
0: 			}
0:         	sel = null; // done with sel
0: 			/* Verify that all underlying ResultSets reclaimed their FromList */
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(fromList.size() == 0,
0: 					"fromList.size() is expected to be 0, not " +
0: 					fromList.size() +
0: 					" on return from RS.bindExpressions()");
0: 			//In case of cascade delete , create nodes for
0: 			//the ref action  dependent tables and bind them.
0: 			if(fkTableNames != null)
1: 				String currentTargetTableName = targetTableDescriptor.getSchemaName() +
1: 						 "." + targetTableDescriptor.getName();
0: 
0: 				if(!isDependentTable){
0: 					//graph node
0: 					graphHashTable = new Hashtable();
0: 				}
0: 
0: 				/*Check whether the current tatget is already been explored.
0: 			 	*If we are seeing the same table name which we binded earlier
0: 			 	*means we have cyclic references.
0: 			 	*/
0: 				if(!graphHashTable.containsKey(currentTargetTableName))
0: 					cascadeDelete = true;
0: 					int noDependents = fkTableNames.length;
0: 					dependentNodes = new QueryTreeNode[noDependents];
0: 					graphHashTable.put(currentTargetTableName, new Integer(noDependents));
0: 					for(int i =0 ; i < noDependents ; i ++)
0: 					{
0: 						dependentNodes[i] = getDependentTableNode(fkTableNames[i],
0: 						dependentNodes[i].bind();
0: 					}
0: 			else
0: 				//case where current dependent table does not have dependent tables
0: 				if(isDependentTable)
0: 				{
1: 					String currentTargetTableName = targetTableDescriptor.getSchemaName()
1: 							 + "." + targetTableDescriptor.getName();
0: 					graphHashTable.put(currentTargetTableName, new Integer(0));
0: 				}
0: 			getCompilerContext().pushCurrentPrivType( getPrivType());
0: 			getCompilerContext().addRequiredTablePriv( targetTableDescriptor);
0: 			getCompilerContext().popCurrentPrivType();
0: 		}
1: 		finally
0: 		{
0: 			getCompilerContext().popCurrentPrivType();
1: 	int getPrivType()
0: 	{
1: 		return Authorizer.DELETE_PRIV;
0: 	}
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.GenericDescriptorList;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: 
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.StatementType;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.vti.DeferModification;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.impl.sql.execute.DeleteConstantAction;
0: import org.apache.derby.impl.sql.execute.FKInfo;
0: 
0: import java.lang.reflect.Modifier;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.services.io.FormatableProperties;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: import java.util.Properties;
0: import org.apache.derby.iapi.sql.compile.NodeFactory;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: 
0: 
0: /**
0:  * A DeleteNode represents a DELETE statement. It is the top-level node
0:  * for the statement.
0:  *
0:  * For positioned delete, there may be no from table specified.
0:  * The from table will be derived from the cursor specification of
0:  * the named cursor.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public class DeleteNode extends DMLModStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* Column name for the RowLocation column in the ResultSet */
0: 	public static final String COLUMNNAME = "###RowLocationToDelete";
0: 
0: 	/* Filled in by bind. */
0: 	protected boolean				deferred;
0: 	protected ExecRow				emptyHeapRow;
0: 	protected FromTable				targetTable;
0: 	protected FKInfo				fkInfo;
0: 	protected FormatableBitSet readColsBitSet;
0: 
0: 	private ConstantAction[] dependentConstantActions;
0: 	private boolean cascadeDelete;
0: 	private QueryTreeNode[] dependentNodes;
0: 
0: 	/**
0: 	 * Initializer for a DeleteNode.
0: 	 *
0: 	 * @param targetTableName	The name of the table to delete from
0: 	 * @param queryExpresssion	The query expression that will generate
0: 	 *				the rows to delete from the given table
0: 	 */
0: 
0: 	public void init(Object targetTableName,
0: 					  Object queryExpression)
0: 	{
0: 		super.init(queryExpression);
0: 		this.targetTableName = (TableName) targetTableName;
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "DELETE";
0: 	}
0: 
0: 	/**
0: 	 * Bind this DeleteNode.  This means looking up tables and columns and
0: 	 * getting their types, and figuring out the result types of all
0: 	 * expressions, as well as doing view resolution, permissions checking,
0: 	 * etc.
0: 	 * <p>
0: 	 * If any indexes need to be updated, we add all the columns in the
0: 	 * base table to the result column list, so that we can use the column
0: 	 * values as look-up keys for the index rows to be deleted.  Binding a
0: 	 * delete will also massage the tree so that the ResultSetNode has 
0: 	 * column containing the RowLocation of the base row.
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		FromList					fromList =
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 		ResultColumn				rowLocationColumn = null;
0: 		CurrentRowLocationNode		rowLocationNode;
0: 		TableName					cursorTargetTableName = null;
0: 		CurrentOfNode       		currentOfNode = null;
0: 
0:                 DataDictionary dataDictionary = getDataDictionary();
0: 		super.bindTables(dataDictionary);
0: 
0: 		// wait to bind named target table until the underlying
0: 		// cursor is bound, so that we can get it from the
0: 		// cursor if this is a positioned delete.
0: 
0: 		// for positioned delete, get the cursor's target table.
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(resultSet != null && resultSet instanceof SelectNode,
0: 			"Delete must have a select result set");
0: 
0: 		SelectNode sel;
0: 		sel = (SelectNode)resultSet;
0: 		targetTable = (FromTable) sel.fromList.elementAt(0);
0: 		if (targetTable instanceof CurrentOfNode)
0: 		{
0: 			currentOfNode = (CurrentOfNode) targetTable;
0: 
0: 			cursorTargetTableName = currentOfNode.getBaseCursorTargetTableName();
0: 			// instead of an assert, we might say the cursor is not updatable.
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(cursorTargetTableName != null);
0: 		}
0: 
0: 		if (targetTable instanceof FromVTI)
0: 		{
0: 			targetVTI = (FromVTI) targetTable;
0: 			targetVTI.setTarget();
0: 		}
0: 		else
0: 		{
0: 			// positioned delete can leave off the target table.
0: 			// we get it from the cursor supplying the position.
0: 			if (targetTableName == null)
0: 			{
0: 				// verify we have current of
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.ASSERT(cursorTargetTableName!=null);
0: 
0: 				targetTableName = cursorTargetTableName;
0: 			}
0: 			// for positioned delete, we need to verify that
0: 			// the named table is the same as the cursor's target (base table name).
0: 			else if (cursorTargetTableName != null)
0: 			{
0: 				// this match requires that the named table in the delete
0: 				// be the same as a base name in the cursor.
0: 				if ( !targetTableName.equals(cursorTargetTableName))
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_CURSOR_DELETE_MISMATCH, 
0: 						targetTableName,
0: 						currentOfNode.getCursorName());
0: 				}
0: 			}
0: 
0: 			/* descriptor must exist, tables already bound.
0: 			 * No need to do this for VTI as VTI was bound in
0: 			 * super.bindTables() above.
0: 			 */
0: 			verifyTargetTable();
0: 		}
0: 
0: 		/* Generate a select list for the ResultSetNode - CurrentRowLocation(). */
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT((resultSet.resultColumns == null),
0: 							  "resultColumns is expected to be null until bind time");
0: 
0: 
0: 		if (targetTable instanceof FromVTI)
0: 		{
0: 			getResultColumnList();
0: 			resultColumnList = targetTable.getResultColumnsForList(null, resultColumnList, null);
0: 
0: 			/* Set the new result column list in the result set */
0: 			resultSet.setResultColumns(resultColumnList);
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Start off assuming no columns from the base table
0: 			** are needed in the rcl.
0: 			*/
0: 			resultColumnList = new ResultColumnList();
0: 
0: 			FromBaseTable fbt = getResultColumnList(resultColumnList);
0: 
0: 			readColsBitSet = getReadMap(dataDictionary,
0: 										targetTableDescriptor);
0: 
0: 			resultColumnList = fbt.addColsToList(resultColumnList, readColsBitSet);
0: 			/*
0: 			** If all bits are set, then behave as if we chose all
0: 			** in the first place
0: 			*/
0: 			int i = 1;
0: 			int size = targetTableDescriptor.getMaxColumnID();
0: 			for (; i <= size; i++)
0: 			{
0: 				if (!readColsBitSet.get(i))
0: 				{
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (i > size)
0: 			{
0: 				readColsBitSet = null;
0: 			}
0: 
0: 			/*
0: 			** Construct an empty heap row for use in our constant action.
0: 			*/
0: 			emptyHeapRow = targetTableDescriptor.getEmptyExecRow(getContextManager());
0: 
0: 			/* Generate the RowLocation column */
0: 			rowLocationNode = (CurrentRowLocationNode) getNodeFactory().getNode(
0: 										C_NodeTypes.CURRENT_ROW_LOCATION_NODE,
0: 										getContextManager());
0: 			rowLocationColumn =
0: 				(ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									COLUMNNAME,
0: 									rowLocationNode,
0: 									getContextManager());
0: 			rowLocationColumn.markGenerated();
0: 
0: 			/* Append to the ResultColumnList */
0: 			resultColumnList.addResultColumn(rowLocationColumn);
0: 
0: 			/* Set the new result column list in the result set */
0: 			resultSet.setResultColumns(resultColumnList);
0: 		}
0: 
0: 		/* Bind the expressions before the ResultColumns are bound */
0: 		super.bindExpressions();
0: 
0: 		/* Bind untyped nulls directly under the result columns */
0: 		resultSet.
0: 			getResultColumns().
0: 				bindUntypedNullsToResultColumns(resultColumnList);
0: 
0: 		if (! (targetTable instanceof FromVTI))
0: 		{
0: 			/* Bind the new ResultColumn */
0: 			rowLocationColumn.bindResultColumnToExpression();
0: 
0: 			bindConstraints(dataDictionary,
0: 							getNodeFactory(),
0: 							targetTableDescriptor,
0: 							null,
0: 							resultColumnList,
0: 							(int[]) null,
0: 							readColsBitSet,
0: 							false,
0: 							true);  /* we alway include triggers in core language */
0: 
0: 			/* If the target table is also a source table, then
0: 			 * the delete will have to be in deferred mode
0: 			 * For deletes, this means that the target table appears in a
0: 			 * subquery.  Also, self-referencing foreign key deletes
0: 		 	 * are deferred.  And triggers cause the delete to be deferred.
0: 			 */
0: 			if (resultSet.subqueryReferencesTarget(
0: 									targetTableDescriptor.getName(), true) ||
0: 				requiresDeferredProcessing())
0: 			{
0: 				deferred = true;
0: 			}
0: 		}
0: 		else
0: 		{
0:             deferred = VTIDeferModPolicy.deferIt( DeferModification.DELETE_STATEMENT,
0:                                                   targetVTI,
0:                                                   null,
0:                                                   sel.getWhereClause());
0: 		}
0:         sel = null; // done with sel
0: 
0: 		/* Verify that all underlying ResultSets reclaimed their FromList */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromList.size() == 0,
0: 				"fromList.size() is expected to be 0, not " +
0: 				fromList.size() +
0: 				" on return from RS.bindExpressions()");
0: 		}
0: 
0: 
0: 		//In case of cascade delete , create nodes for
0: 		//the ref action  dependent tables and bind them.
0: 		if(fkTableNames != null)
0: 		{
0: 			String currentTargetTableName =
0: 				targetTableDescriptor.getSchemaName() + "." + targetTableDescriptor.getName();
0: 
0: 			if(!isDependentTable){
0: 				//graph node
0: 				graphHashTable = new Hashtable();
0: 			}
0: 
0: 			/*Check whether the current tatget is already been explored.
0: 			 *If we are seeing the same table name which we binded earlier
0: 			 *means we have cyclic references.
0: 			 */
0: 			if(!graphHashTable.containsKey(currentTargetTableName))
0: 			{
0: 				cascadeDelete = true;
0: 				int noDependents = fkTableNames.length;
0: 				dependentNodes = new QueryTreeNode[noDependents];
0: 				graphHashTable.put(currentTargetTableName, new Integer(noDependents));
0: 				for(int i =0 ; i < noDependents ; i ++)
0: 				{
0: 					dependentNodes[i] = getDependentTableNode(fkTableNames[i],
0: 															  fkRefActions[i],
0: 															  fkColDescriptors[i]);
0: 					dependentNodes[i].bind();
0: 				}
0: 			}
0: 		}else
0: 		{
0: 			//case where current dependent table does not have dependent tables
0: 			if(isDependentTable)
0: 			{
0: 				String currentTargetTableName =
0: 					targetTableDescriptor.getSchemaName() + "." + targetTableDescriptor.getName();
0: 				graphHashTable.put(currentTargetTableName, new Integer(0));
0: 
0: 			}
0: 
0: 		}
0: 		return this;
0: 	} // end of bind
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		//If delete table is on a SESSION schema table, then return true. 
0: 		return resultSet.referencesSessionSchema();
0: 	}
0: 
0: 	/**
0: 	 * Compile constants that Execution will use
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 
0: 		/* Different constant actions for base tables and updatable VTIs */
0: 		if (targetTableDescriptor != null)
0: 		{
0: 			// Base table
0: 			int lockMode = resultSet.updateTargetLockMode();
0: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
0: 			TransactionController tc = getLanguageConnectionContext().getTransactionCompile();
0: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
0: 				new StaticCompiledOpenConglomInfo[indexConglomerateNumbers.length];
0: 
0: 			for (int index = 0; index < indexSCOCIs.length; index++)
0: 			{
0: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
0: 			}
0: 
0: 			/*
0: 			** Do table locking if the table's lock granularity is
0: 			** set to table.
0: 			*/
0: 			if (targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
0: 			{
0: 				lockMode = TransactionController.MODE_TABLE;
0: 			}
0: 
0: 			ResultDescription resultDescription = null;
0: 			if(isDependentTable)
0: 			{
0: 				//triggers need the result description ,
0: 				//dependent tables  don't have a source from generation time
0: 				//to get the result description
0: 				resultDescription = makeResultDescription();
0: 			}
0: 
0: 
0: 			return	getGenericConstantActionFactory().getDeleteConstantAction
0: 				( heapConglomId,
0: 				  targetTableDescriptor.getTableType(),
0: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
0: 				  indicesToMaintain,
0: 				  indexConglomerateNumbers,
0: 				  indexSCOCIs,
0: 				  emptyHeapRow,
0: 				  deferred,
0: 				  false,
0: 				  targetTableDescriptor.getUUID(),
0: 				  lockMode,
0: 				  null, null, null, 0, null, null, 
0: 				  resultDescription,
0: 				  getFKInfo(), 
0: 				  getTriggerInfo(), 
0: 				  (readColsBitSet == null) ? (FormatableBitSet)null : new FormatableBitSet(readColsBitSet),
0: 				  getReadColMap(targetTableDescriptor.getNumberOfColumns(),readColsBitSet),
0: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
0:  				  (readColsBitSet == null) ? 
0: 					  targetTableDescriptor.getNumberOfColumns() :
0: 					  readColsBitSet.getNumBitsSet(),			
0: 				  (UUID) null,
0: 				  resultSet.isOneRowResultSet(),
0: 				  dependentConstantActions);
0: 		}
0: 		else
0: 		{
0: 			/* Return constant action for VTI
0: 			 * NOTE: ConstantAction responsible for preserving instantiated
0: 			 * VTIs for in-memory queries and for only preserving VTIs
0: 			 * that implement Serializable for SPSs.
0: 			 */
0: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.DELETE_STATEMENT,
0: 						deferred);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Code generation for delete.
0: 	 * The generated code will contain:
0: 	 *		o  A static member for the (xxx)ResultSet with the RowLocations
0: 	 *		o  The static member will be assigned the appropriate ResultSet within
0: 	 *		   the nested calls to get the ResultSets.  (The appropriate cast to the
0: 	 *		   (xxx)ResultSet will be generated.)
0: 	 *		o  The CurrentRowLocation() in SelectNode's select list will generate
0: 	 *		   a new method for returning the RowLocation as well as a call to
0: 	 *		   that method which will be stuffed in the call to the 
0: 	 *		    ProjectRestrictResultSet.
0: 	 *      o In case of referential actions, this function generate an
0: 	 *        array of resultsets on its dependent tables.
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb	The execute() method to be built
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
0: 
0: 		/* generate the parameters */
0: 		if(!isDependentTable)
0: 			generateParameterValueSet(acb);
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb); 
0: 		acb.newRowLocationScanResultSetName();
0: 		resultSet.generate(acb, mb); // arg 1
0: 
0: 		String resultSetGetter;
0: 		int argCount;
0: 		String parentResultSetId;
0: 
0: 		// Base table
0: 		if (targetTableDescriptor != null)
0: 		{
0: 			/* Create the declaration for the scan ResultSet which generates the
0: 			 * RowLocations to be deleted.
0: 	 		 * Note that the field cannot be static because there
0: 			 * can be multiple activations of the same activation class,
0: 			 * and they can't share this field.  Only exprN fields can
0: 			 * be shared (or, more generally, read-only fields).
0: 			 * RESOLVE - Need to deal with the type of the field.
0: 			 */
0: 
0: 			acb.newFieldDeclaration(Modifier.PRIVATE, 
0: 									ClassName.CursorResultSet, 
0: 									acb.getRowLocationScanResultSetName());
0: 
0: 			if(cascadeDelete || isDependentTable)
0: 			{
0: 				resultSetGetter = "getDeleteCascadeResultSet";
0: 			}		
0: 			else
0: 			{
0: 				resultSetGetter = "getDeleteResultSet";
0: 			}
0: 			argCount = 2;
0: 		} else {
0: 			argCount = 2;
0: 			resultSetGetter = "getDeleteVTIResultSet";
0: 		}
0: 
0: 
0: 		acb.pushThisAsActivation(mb);
0: 
0: 		if(isDependentTable)
0: 		{
0: 			argCount = 3;
0: 			mb.push(acb.addItem(makeConstantAction()));
0: 		
0: 		}else
0: 		{
0: 			if(cascadeDelete)
0: 			{
0: 				argCount = 3;
0: 				mb.push(-1); //root table.
0: 			}
0: 		}		
0: 
0: 		String		resultSetArrayType = ClassName.ResultSet + "[]";
0: 		if(cascadeDelete)
0: 		{
0: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
0: 			                       "." + targetTableDescriptor.getName();
0: 			// Generate the code to build the array
0: 			LocalField arrayField =
0: 				acb.newFieldDeclaration(Modifier.PRIVATE, resultSetArrayType);
0: 			mb.pushNewArray(ClassName.ResultSet, dependentNodes.length);  // new ResultSet[size]
0: 			mb.putField(arrayField);
0: 			mb.endStatement();
0: 
0: 			argCount = 4;
0: 			for(int index=0 ; index <  dependentNodes.length ; index++)
0: 			{
0: 
0: 				dependentNodes[index].setRefActionInfo(fkIndexConglomNumbers[index],
0: 													   fkColArrays[index],
0: 													   parentResultSetId,
0: 													   true);
0: 				mb.getField(arrayField); // first arg (resultset array reference)
0: 				/*beetle:5360 : if too many statements are added  to a  method, 
0: 				 *size of method can hit  65k limit, which will
0: 				 *lead to the class format errors at load time.
0: 				 *To avoid this problem, when number of statements added 
0: 				 *to a method is > 2048, remaing statements are added to  a new function
0: 				 *and called from the function which created the function.
0: 				 *See Beetle 5135 or 4293 for further details on this type of problem.
0: 				*/
0: 				if(mb.statementNumHitLimit(10))
0: 				{
0: 					MethodBuilder dmb = acb.newGeneratedFun(ClassName.ResultSet, Modifier.PRIVATE);
0: 					dependentNodes[index].generate(acb,dmb); //generates the resultset expression
0: 					dmb.methodReturn();
0: 					dmb.complete();
0: 					/* Generate the call to the new method */
0: 					mb.pushThis(); 
0: 					//second arg will be generated by this call
0: 					mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, dmb.getName(), ClassName.ResultSet, 0);
0: 				}else
0: 				{
0: 					dependentNodes[index].generate(acb,mb); //generates the resultset expression
0: 				}
0: 
0: 				mb.setArrayElement(index);
0: 			}	
0: 			mb.getField(arrayField); // fourth argument - array reference
0: 		}
0: 		else
0: 		{
0: 			if(isDependentTable)
0: 			{
0: 				argCount =4;
0: 				mb.pushNull(resultSetArrayType); //No dependent tables for this table
0: 			}
0: 		}
0: 
0: 
0: 		if(cascadeDelete || isDependentTable)
0: 		{
0: 			parentResultSetId = targetTableDescriptor.getSchemaName() +
0: 			                       "." + targetTableDescriptor.getName();
0: 			argCount = 5;
0: 			mb.push(parentResultSetId);
0: 
0: 		}
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, resultSetGetter, ClassName.ResultSet, argCount);
0: 
0: 
0: 		if(!isDependentTable && cascadeDelete)
0: 		{
0: 			int numResultSets = acb.getRowCount();
0: 			if(numResultSets > 0)
0: 			{
0: 				//generate activation.raParentResultSets = new NoPutResultSet[size]
0: 				MethodBuilder constructor = acb.getConstructor();
0: 				constructor.pushThis();
0: 				constructor.pushNewArray(ClassName.CursorResultSet, numResultSets);
0: 				constructor.putField(ClassName.BaseActivation,
0: 									 "raParentResultSets",
0: 									 ClassName.CursorResultSet + "[]");
0: 				constructor.endStatement();
0: 			}
0: 		}
0: 
0: 		/*
0: 		** ensure all parameters have been generated
0: 		*/
0: 		if(!isDependentTable)
0: 			generateParameterHolders(acb);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return the type of statement, something from
0: 	 * StatementType.
0: 	 *
0: 	 * @return the type of statement
0: 	 */
0: 	protected final int getStatementType()
0: 	{
0: 		return StatementType.DELETE;
0: 	}
0: 
0: 
0: 	/**
0: 	  *	Gets the map of all columns which must be read out of the base table.
0: 	  * These are the columns needed to:
0: 	  *
0: 	  *		o	maintain indices
0: 	  *		o	maintain foreign keys
0: 	  *
0: 	  *	The returned map is a FormatableBitSet with 1 bit for each column in the
0: 	  * table plus an extra, unsued 0-bit. If a 1-based column id must
0: 	  * be read from the base table, then the corresponding 1-based bit
0: 	  * is turned ON in the returned FormatableBitSet.
0: 	  *
0: 	  *	@param	dd				the data dictionary to look in
0: 	  *	@param	baseTable		the base table descriptor
0: 	  *
0: 	  *	@return	a FormatableBitSet of columns to be read out of the base table
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	public	FormatableBitSet	getReadMap
0: 	(
0: 		DataDictionary		dd,
0: 		TableDescriptor		baseTable
0: 	)
0: 		throws StandardException
0: 	{
0: 		boolean[]	needsDeferredProcessing = new boolean[1];
0: 		needsDeferredProcessing[0] = requiresDeferredProcessing();
0: 
0: 		Vector		conglomVector = new Vector();
0: 		relevantTriggers = new GenericDescriptorList();
0: 
0: 		FormatableBitSet	columnMap = DeleteNode.getDeleteReadMap(baseTable, conglomVector, relevantTriggers, needsDeferredProcessing );
0: 
0: 		markAffectedIndexes( conglomVector );
0: 
0: 		adjustDeferredFlag( needsDeferredProcessing[0] );
0: 
0: 		return	columnMap;
0: 	}
0: 
0: 	/**
0: 	 * In case of referential actions, we require to perform
0: 	 * DML (UPDATE or DELETE) on the dependent tables. 
0: 	 * Following function returns the DML Node for the dependent table.
0: 	 */
0: 	private QueryTreeNode getDependentTableNode(String tableName, int refAction,
0: 												ColumnDescriptorList cdl) throws StandardException
0: 	{
0: 		QueryTreeNode node=null;
0: 
0: 		int index = tableName.indexOf('.');
0: 		String schemaName = tableName.substring(0 , index);
0: 		String tName = tableName.substring(index+1);
0: 		if(refAction == StatementType.RA_CASCADE)
0: 		{
0: 			node = getEmptyDeleteNode(schemaName , tName);
0: 			((DeleteNode)node).isDependentTable = true;
0: 			((DeleteNode)node).graphHashTable = graphHashTable;
0: 		}
0: 
0: 		if(refAction == StatementType.RA_SETNULL)
0: 		{
0: 			node = getEmptyUpdateNode(schemaName , tName, cdl);
0: 			((UpdateNode)node).isDependentTable = true;
0: 			((UpdateNode)node).graphHashTable = graphHashTable;
0: 		}
0: 
0: 		return node;
0: 	}
0: 
0: 
0:     private QueryTreeNode getEmptyDeleteNode(String schemaName, String targetTableName)
0:         throws StandardException
0:     {
0: 
0:         ValueNode whereClause = null;
0:         TableName tableName = null;
0:         FromTable fromTable = null;
0:         QueryTreeNode retval;
0:         SelectNode resultSet;
0: 
0:         tableName = new TableName();
0:         tableName.init(schemaName , targetTableName);
0: 
0:         NodeFactory nodeFactory = getNodeFactory();
0:         FromList   fromList = (FromList) nodeFactory.getNode(C_NodeTypes.FROM_LIST, getContextManager());
0:         fromTable = (FromTable) nodeFactory.getNode(
0:                                                     C_NodeTypes.FROM_BASE_TABLE,
0:                                                     tableName,
0:                                                     null,
0:                                                     ReuseFactory.getInteger(FromBaseTable.DELETE),
0:                                                     null,
0:                                                     getContextManager());
0: 
0: 		//we would like to use references index & table scan instead of 
0: 		//what optimizer says for the dependent table scan.
0: 		Properties targetProperties = new FormatableProperties();
0: 		targetProperties.put("index", "null");
0: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
0: 
0:         fromList.addFromTable(fromTable);
0:         resultSet = (SelectNode) nodeFactory.getNode(
0:                                                      C_NodeTypes.SELECT_NODE,
0:                                                      null,
0:                                                      null,   /* AGGREGATE list */
0:                                                      fromList, /* FROM list */
0:                                                      whereClause, /* WHERE clause */
0:                                                      null, /* GROUP BY list */
0:                                                      getContextManager());
0: 
0:         retval =(QueryTreeNode) nodeFactory.getNode(
0:                                                     C_NodeTypes.DELETE_NODE,
0:                                                     tableName,
0:                                                     resultSet,
0:                                                     getContextManager());
0: 
0:         return retval;
0:     }
0: 
0: 
0: 	
0:     private QueryTreeNode getEmptyUpdateNode(String schemaName, 
0: 											 String targetTableName,
0: 											 ColumnDescriptorList cdl)
0:         throws StandardException
0:     {
0: 
0:         ValueNode whereClause = null;
0:         TableName tableName = null;
0:         FromTable fromTable = null;
0:         QueryTreeNode retval;
0:         SelectNode resultSet;
0: 
0:         tableName = new TableName();
0:         tableName.init(schemaName , targetTableName);
0: 
0:         NodeFactory nodeFactory = getNodeFactory();
0:         FromList   fromList = (FromList) nodeFactory.getNode(C_NodeTypes.FROM_LIST, getContextManager());
0:         fromTable = (FromTable) nodeFactory.getNode(
0:                                                     C_NodeTypes.FROM_BASE_TABLE,
0:                                                     tableName,
0:                                                     null,
0:                                                     ReuseFactory.getInteger(FromBaseTable.DELETE),
0:                                                     null,
0:                                                     getContextManager());
0: 
0: 
0: 		//we would like to use references index & table scan instead of 
0: 		//what optimizer says for the dependent table scan.
0: 		Properties targetProperties = new FormatableProperties();
0: 		targetProperties.put("index", "null");
0: 		((FromBaseTable) fromTable).setTableProperties(targetProperties);
0: 
0:         fromList.addFromTable(fromTable);
0: 
0: 		resultSet = (SelectNode) nodeFactory.getNode(
0:                                                      C_NodeTypes.SELECT_NODE,
0:                                                      getSetClause(tableName, cdl),
0:                                                      null,   /* AGGREGATE list */
0:                                                      fromList, /* FROM list */
0:                                                      whereClause, /* WHERE clause */
0:                                                      null, /* GROUP BY list */
0:                                                      getContextManager());
0: 
0:         retval =(QueryTreeNode) nodeFactory.getNode(
0:                                                     C_NodeTypes.UPDATE_NODE,
0:                                                     tableName,
0:                                                     resultSet,
0:                                                     getContextManager());
0: 
0:         return retval;
0:     }
0: 
0: 
0:  
0: 	private ResultColumnList getSetClause(TableName tabName,
0: 										  ColumnDescriptorList cdl)
0: 		throws StandardException
0: 	{
0: 		ResultColumn resultColumn;
0: 		ValueNode	 valueNode;
0: 
0: 		NodeFactory nodeFactory = getNodeFactory();
0: 		ResultColumnList	columnList = (ResultColumnList) nodeFactory.getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 
0: 		valueNode =  (ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
0: 															 getContextManager());
0: 		for(int index =0 ; index < cdl.size() ; index++)
0: 		{
0: 			ColumnDescriptor cd = (ColumnDescriptor) cdl.elementAt(index);
0: 			//only columns that are nullable need to be set to 'null' for ON
0: 			//DELETE SET NULL
0: 			if((cd.getType()).isNullable())
0: 			{
0: 				resultColumn = (ResultColumn) nodeFactory.getNode(
0:    									    C_NodeTypes.RESULT_COLUMN,
0: 										cd,
0: 										valueNode,
0: 										getContextManager());
0: 
0: 				columnList.addResultColumn(resultColumn);
0: 			}
0: 		}
0: 		return columnList;
0: 	}
0: 
0: 
0: 	public QueryTreeNode optimize() throws StandardException
0: 	{
0: 		if(cascadeDelete)
0: 		{
0: 			for(int index=0 ; index < dependentNodes.length ; index++)
0: 			{
0: 				dependentNodes[index] =  dependentNodes[index].optimize();
0: 			}
0: 		}
0: 
0: 		return super.optimize();
0: 	}
0: 
0:     /**
0: 	  *	Builds a bitmap of all columns which should be read from the
0: 	  *	Store in order to satisfy an DELETE statement.
0: 	  *
0: 	  *
0: 	  *	1)	finds all indices on this table
0: 	  *	2)	adds the index columns to a bitmap of affected columns
0: 	  *	3)	adds the index descriptors to a list of conglomerate
0: 	  *		descriptors.
0: 	  *	4)	finds all DELETE triggers on the table
0: 	  *	5)	if there are any DELETE triggers, marks all columns in the bitmap
0: 	  *	6)	adds the triggers to an evolving list of triggers
0: 	  *
0: 	  *	@param	conglomVector		OUT: vector of affected indices
0: 	  *	@param	relevantTriggers	IN/OUT. Passed in as an empty list. Filled in as we go.
0: 	  *	@param	needsDeferredProcessing			IN/OUT. true if the statement already needs
0: 	  *											deferred processing. set while evaluating this
0: 	  *											routine if a trigger requires
0: 	  *											deferred processing
0: 	  *
0: 	  * @return a FormatableBitSet of columns to be read out of the base table
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	private static FormatableBitSet getDeleteReadMap
0: 	(
0: 		TableDescriptor				baseTable,
0: 		Vector						conglomVector,
0: 		GenericDescriptorList		relevantTriggers,
0: 		boolean[]					needsDeferredProcessing
0: 	)
0: 		throws StandardException
0: 	{
0: 		int		columnCount = baseTable.getMaxColumnID();
0: 		FormatableBitSet	columnMap = new FormatableBitSet(columnCount + 1);
0: 
0: 		/* 
0: 		** Get a list of the indexes that need to be 
0: 		** updated.  ColumnMap contains all indexed
0: 		** columns where 1 or more columns in the index
0: 		** are going to be modified.
0: 		**
0: 		** Notice that we don't need to add constraint
0: 		** columns.  This is because we add all key constraints
0: 		** (e.g. foreign keys) as a side effect of adding their
0: 		** indexes above.  And we don't need to deal with
0: 		** check constraints on a delete.
0: 		**
0: 		** Adding indexes also takes care of the replication 
0: 		** requirement of having the primary key.
0: 		*/
0: 		DMLModStatementNode.getXAffectedIndexes(baseTable,  null, columnMap, conglomVector );
0: 
0: 		/*
0: 	 	** If we have any triggers, then get all the columns
0: 		** because we don't know what the user will ultimately
0: 		** reference.
0: 	 	*/
0: 		baseTable.getAllRelevantTriggers( StatementType.DELETE, (int[])null, relevantTriggers );
0: 		if ( relevantTriggers.size() > 0 ) { needsDeferredProcessing[0] = true; }
0: 
0: 		if (relevantTriggers.size() > 0)
0: 		{
0: 			for (int i = 1; i <= columnCount; i++)
0: 			{
0: 				columnMap.set(i);
0: 			}
0: 		}
0: 
0: 		return	columnMap;
0: 	}
0:     
0: }
============================================================================