1:29e9328: /*
1:2f99495: 
1:29e9328: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_4
9:62af56f: 
1:29e9328: Licensed to the Apache Software Foundation (ASF) under one or more
1:29e9328: contributor license agreements.  See the NOTICE file distributed with
1:29e9328: this work for additional information regarding copyright ownership.
1:29e9328: The ASF licenses this file to You under the Apache License, Version 2.0
1:29e9328: (the "License"); you may not use this file except in compliance with
1:29e9328: the License.  You may obtain a copy of the License at
1:62af56f: 
1:29e9328:    http://www.apache.org/licenses/LICENSE-2.0
1:62af56f: 
1:29e9328: Unless required by applicable law or agreed to in writing, software
1:29e9328: distributed under the License is distributed on an "AS IS" BASIS,
1:29e9328: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:29e9328: See the License for the specific language governing permissions and
1:29e9328: limitations under the License.
1:62af56f: 
1:62af56f: */
1:29e9328: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:62af56f: 
1:29e9328: import java.sql.Connection;
1:29e9328: import java.sql.DatabaseMetaData;
1:35dff7c: import java.sql.PreparedStatement;
1:29e9328: import java.sql.ResultSet;
1:29e9328: import java.sql.SQLException;
1:29e9328: import java.sql.Statement;
1:1ae02c9: import java.text.Collator;
1:1ae02c9: import java.util.Locale;
1:29e9328: import javax.sql.DataSource;
1:29e9328: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBCDataSource;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:62af56f: 
1:62af56f: /**
1:29e9328:  * Upgrade test cases for 10.4.
1:29e9328:  * If the old version is 10.4 or later then these tests
1:29e9328:  * will not be run.
1:29e9328:  * <BR>
1:29e9328:     10.4 Upgrade issues
1:62af56f: 
1:ea5ca3f:     <UL>
1:ea5ca3f:     <LI> testMetaDataQueryRunInSYScompilationSchema - DERBY-2946 
1:ea5ca3f:     Make sure that metadata queries get run with SYS schema as the current 
1:ea5ca3f:     compilation schema rather than a user schema as the current compilation 
1:ea5ca3f:     schema. This is because if the user is inside a user schema in a collated 
1:ea5ca3f:     database and if the meta data query gets run inside the user schema, then 
1:ea5ca3f:     we will run into collation mismatch errors for a subclause like following 
1:ea5ca3f:     in the WHERE clause.
1:ea5ca3f:     P.SELECTPRIV = 'Y' 
1:ea5ca3f:     The reason for error is that the left hand side of the = operation will 
1:ea5ca3f:     have collation type of UCS_BASIC because that column belongs to a table 
1:ea5ca3f:     from system schema. But the collation type of the right hand will be 
1:ea5ca3f:     territory based if the current compilation schema is user schema. But if 
1:ea5ca3f:     the current compilation schema is set to SYS schema, then right hand side 
1:ea5ca3f:     will also have collation of UCS_BASIC and hence there won't be any 
1:ea5ca3f:     collation mismatch. 
1:ea5ca3f:     Background info : character string constants pick up the collation of the
1:ea5ca3f:     current compilation schema. 
1:ea5ca3f:     </UL>
1:62af56f: 
1:62af56f:  */
1:29e9328: public class Changes10_4 extends UpgradeChange {
1:62af56f: 
1:29e9328:     public Changes10_4(String name) {
1:29e9328:         super(name);
7:62af56f:     }
1:62af56f:     
1:aaa1403:     /**
1:29e9328:      * Return the suite of tests to test the changes made in 10.4.
1:29e9328:      * @param phase an integer that indicates the current phase in
1:29e9328:      *              the upgrade test.
1:29e9328:      * @return the test suite created.
1:62af56f:      */   
1:29e9328:     public static Test suite(int phase) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.4");
1:62af56f:         
1:29e9328:         suite.addTestSuite(Changes10_4.class);
1:29e9328:         return new SupportFilesSetup((Test) suite);
1:62af56f:     }
1:62af56f:     
1:62af56f:     /**
1:ea5ca3f:      * Check that even though we have set schema to a user schema, the 
1:ea5ca3f:      * metadata queries get run with compilation schema as SYS.
1:ea5ca3f:      * DERBY-2946
1:ea5ca3f:      * Test added for 10.4.
1:aaa1403:      * @throws SQLException 
1:aaa1403:      *
1:aaa1403:      */
1:ea5ca3f:     public void testMetaDataQueryRunInSYScompilationSchema() throws SQLException
1:aaa1403:     {
1:ea5ca3f:     	//This test is for databases with territory based collation. That
1:ea5ca3f:     	//feature was added in 10.3 codeline and hence there is no point in
1:ea5ca3f:     	//doing any testing with pre-10.3 databases.
1:ea5ca3f:         if (!oldAtLeast(10, 3))
1:ea5ca3f:         	return;
1:aaa1403: 
1:ea5ca3f:         DataSource ds = JDBCDataSource.getDataSourceLogical("COLLATED_DB_10_3");
1:aaa1403:         
1:aaa1403:         switch (getPhase())
1:aaa1403:         {
1:aaa1403:         case PH_CREATE:
1:ea5ca3f:             // create the database if it was not already created. Note the
1:ea5ca3f:         	// JDBC url attributes.
1:fc061da:             String locale = "en";
1:fc061da:             Locale[] availableLocales = Collator.getAvailableLocales();
1:fc061da:             for (int i = 0; i < availableLocales.length; i++) {
1:fc061da:                 if ("no".equals(availableLocales[i].getLanguage())) {
1:fc061da:                     locale="no"; // Use something different than 'en' 
1:fc061da:                     // if the JVM supports it.
1:aaa1403:                     break;
1:fc061da:                 }
1:fc061da:             }
1:aaa1403: 
1:aaa1403:             JDBCDataSource.setBeanProperty(
1:fc061da:                     ds, "ConnectionAttributes", 
1:fc061da:                     "create=true;territory="+locale+";"
1:fc061da:                         +"collation=TERRITORY_BASED");
1:ea5ca3f:             ds.getConnection().close();
1:fc061da:             break;
1:fc061da:             
1:62af56f:         case PH_SOFT_UPGRADE:
1:35dff7c:         case PH_POST_SOFT_UPGRADE:
1:35dff7c:         case PH_HARD_UPGRADE:
1:ea5ca3f:             Connection con = ds.getConnection();
1:ea5ca3f:         	//First make the current schema as a user schema. And then run a 
1:ea5ca3f:         	//metadata query to make sure that it runs fine. If it does (which
1:ea5ca3f:         	//is the expected behavior), then it will mean that the metadata
1:ea5ca3f:         	//query is getting run with SYS as the compilation schema rather
1:ea5ca3f:         	//than the current schema which is APP.
1:ea5ca3f:             Statement s = con.createStatement();
1:ea5ca3f:             s.execute("SET SCHEMA APP");
1:419210d: 
1:ea5ca3f:             DatabaseMetaData dmd = con.getMetaData();
1:ea5ca3f:             ResultSet rs = dmd.getTables(null,"APP",null,null);
1:ea5ca3f:             JDBC.assertDrainResults(rs);
1:e9ff7be:             s.close();
1:aaa1403:             break;
1:aaa1403:         }
1:aaa1403:     }
1:aaa1403: 
1:aaa1403: 
1:aaa1403:     /**
1:e9ff7be:      * Check that you must be hard-upgraded to 10.4 or later in order to declare
1:e9ff7be:      * table functions.
1:aaa1403:      * @throws SQLException 
1:aaa1403:      *
1:aaa1403:      */
1:e9ff7be:     public void testTableFunctionDeclaration() throws SQLException
1:aaa1403:     {
1:e9ff7be:         Statement       s = createStatement();
1:e9ff7be:         String          createTableFunctionText =
1:e9ff7be:             "create function svnLogReader( logFileName varchar( 32672 ) )\n" +
1:e9ff7be:             "returns TABLE\n" +
1:e9ff7be:             "  (\n" +
1:e9ff7be:             "     XID varchar( 15 ),\n" +
1:e9ff7be:             "     committer    varchar( 20 ),\n" +
1:e9ff7be:             "     commit_time  timestamp,\n" +
1:e9ff7be:             "     line_count   varchar( 10 ),\n" +
1:e9ff7be:             "     description  varchar( 32672 )\n" +
1:e9ff7be:             "  )\n" +
1:e9ff7be:             "language java\n" +
1:e9ff7be:             "parameter style DERBY_JDBC_RESULT_SET\n" +
1:e9ff7be:             "no sql\n" +
1:e9ff7be:             "external name 'org.apache.derbyDemo.vtis.example.SubversionLogVTI.subversionLogVTI'\n"
1:e9ff7be:             ;
1:aaa1403: 
1:e9ff7be:         switch (getPhase())
2:e9ff7be:         {
1:62af56f:         case PH_CREATE:
1:e9ff7be:             assertStatementError("42X01", s, createTableFunctionText );
1:aaa1403:             break;
1:aaa1403:             
1:aaa1403:         case PH_SOFT_UPGRADE:
1:e9ff7be:             assertStatementError("XCL47", s, createTableFunctionText );
1:aaa1403:             break;
1:419210d:             
1:aaa1403:         case PH_POST_SOFT_UPGRADE:
1:e9ff7be:             assertStatementError("42X01", s, createTableFunctionText );
4:62af56f:             break;
1:a8edfcf:             
1:aaa1403:         case PH_HARD_UPGRADE:
1:e9ff7be:             s.execute( createTableFunctionText );
1:62af56f:             break;
1:62af56f:         }
1:a8edfcf: 
1:aaa1403:         s.close();
1:62af56f:     }
1:0982847:     
1:419210d:     /**
1:35dff7c:      * Test that routine parameters and return types are
1:35dff7c:      * handled correctly with 10.4 creating a procedure
1:35dff7c:      * in soft-upgrade. 10.4 simplified the stored
1:35dff7c:      * format of the types by ensuring the catalog
1:35dff7c:      * type was written. See DERBY-2917 for details.
1:35dff7c:      * 
1:35dff7c:      * @throws SQLException 
1:35dff7c:      *
1:0982847:      */
1:35dff7c:     public void testRoutineParameters() throws SQLException
1:35dff7c:     {
1:0982847:         
1:0982847: 
1:35dff7c:         switch (getPhase())
1:35dff7c:         {
1:62af56f:         case PH_CREATE:
1:62af56f:           break;
1:0982847:             
1:62af56f:         case PH_SOFT_UPGRADE:
1:aaa1403:             Statement s = createStatement();
1:35dff7c:             s.execute("CREATE FUNCTION TYPES_10_4" +
1:35dff7c:                     "(A INTEGER) RETURNS CHAR(10) " +
1:35dff7c:                     "LANGUAGE JAVA " +
1:35dff7c:                     "PARAMETER STYLE JAVA " +
1:35dff7c:                     "NO SQL " +
1:35dff7c:                     "EXTERNAL NAME 'java.lang.Integer.toHexString'");
1:35dff7c:            // fall through to test it
1:aaa1403:             
1:62af56f:         case PH_HARD_UPGRADE:
1:62af56f:         case PH_POST_SOFT_UPGRADE:
1:35dff7c:             PreparedStatement ps = prepareStatement(
1:35dff7c:                     "VALUES TYPES_10_4(?)");
1:35dff7c:             ps.setInt(1, 48879);
1:35dff7c:             // Don't use the single value check method here
1:35dff7c:             // because we want to check the returned value
1:35dff7c:             // was converted to its correct type of CHAR(10)
1:35dff7c:             // (so no trimming of values)
1:35dff7c:             JDBC.assertFullResultSet(ps.executeQuery(),
1:35dff7c:                     new Object[][] {{"beef      "}}, false);
1:62af56f:             break;
1:62af56f:         }
1:62af56f:     }
1:aaa1403: 
1:a8edfcf:     /**
1:62af56f:      * Tests whether or not indexes are exibiting their expected behaviour.
1:62af56f:      *
1:62af56f:      * @param s         Statement 
1:62af56f:      * @param tableName table name to be used for testing
1:62af56f:      * @param val       value to be used for insertion
1:62af56f:      * @param nulls     if nulls are allowed 
1:62af56f:      * @param duplicate if duplicates are allowed
1:62af56f:      */
1:62af56f:     private void testIndexes (Statement s, String tableName, int val,
1:62af56f:             boolean nulls, boolean duplicate) throws Exception {
1:aaa1403: 
1:62af56f:         //clean table first
1:62af56f:         s.executeUpdate("delete from " + tableName);
1:62af56f:         s.executeUpdate("insert into " + tableName + " values (" + val +")");
1:aaa1403: 
1:62af56f:         // verify insert of input value results in expected duplicate behavior
1:a8edfcf:         try {
1:62af56f:             s.executeUpdate(
1:62af56f:                 "insert into " + tableName + " values (" + val +")");
1:aaa1403: 
1:62af56f:             if (!duplicate)
1:62af56f:                 fail("no duplicates allowed");
1:a8edfcf:         }
1:62af56f:         catch (SQLException e) {
1:62af56f:             //throw 23505
1:62af56f:             if (!duplicate) {
1:62af56f:                 assertSQLState("duplicate record", "23505", e);
1:a8edfcf:             }
1:62af56f:             else {
1:62af56f:                 throw e;
1:a8edfcf:             }
1:0982847:         }
1:aaa1403: 
1:62af56f:         // verify insert of a null value results in expected behavior
1:a8edfcf:         try {
1:62af56f:             s.executeUpdate("insert into " + tableName + " values (null)");
1:62af56f:             if (!nulls)
1:62af56f:                 fail("null in a not null column");
1:0982847:         }
1:62af56f:         catch (SQLException e) {
1:62af56f:             if (!nulls) { //23502
1:62af56f:                 assertSQLState("null in not null column", "23502", e);
1:0982847:             }
1:62af56f:             else {
1:62af56f:                 throw e;
1:0982847:             }
1:0982847:         }
1:aaa1403: 
1:62af56f:         // if nulls are allowed, verify expected behavior of 2nd null insert.
1:62af56f:         if (!nulls)
1:62af56f:             return;
4:0982847:         try {
1:62af56f:             s.executeUpdate("insert into " + tableName + " values (null)");
1:62af56f:             if (!duplicate)
1:62af56f:                 fail("no duplicates allowed");
1:0982847:         }
1:62af56f:         catch (SQLException e) {
1:62af56f:         if (!duplicate) {
1:62af56f:                 assertSQLState("duplicate record", "23505", e);
1:62af56f:             }
1:62af56f:             else {
1:62af56f:                 throw e;
1:62af56f:             }
1:62af56f:         }
1:62af56f:     }
1:aaa1403:     
1:0982847:     /**
1:62af56f:      * Creates tables to test indexes during and after soft and hard 
1:62af56f:      * upgrades
1:62af56f:      * @param s Statement
1:62af56f:      * @param prefix prefix for table names
1:0982847:      */
1:62af56f:     private void createTablesForIndexTesting (Statement s, String prefix) 
1:62af56f:                                     throws Exception {
1:aaa1403: 
1:62af56f:         // unique index on non-null column
1:62af56f:         s.executeUpdate("create table  " + prefix + "_indextest1" +
1:62af56f:                 "(col1 integer not null)"); 
1:62af56f:         s.executeUpdate("create unique index "+ prefix
1:62af56f:                 + "_uinn on " + prefix + "_indextest1 (col1)");
1:aaa1403: 
1:62af56f:         // unique index on nullable column
1:62af56f:         s.executeUpdate("create table  " + prefix + "_indextest2" +
1:62af56f:                 "(col1 integer)"); 
1:62af56f:         s.executeUpdate("create unique index "+ prefix
1:62af56f:                 + "_uin on " + prefix + "_indextest2 (col1)");
1:aaa1403: 
1:62af56f:         // non-unique index on non-nullable column
1:62af56f:         s.executeUpdate("create table  " + prefix + "_indextest3" +
1:62af56f:                 "(col1 integer not null)");     
1:62af56f:         s.executeUpdate("create index "+ prefix
1:62af56f:                 + "_nuinn on " + prefix + "_indextest3 (col1)");
1:a8edfcf: 
1:62af56f:         // non-unique index on nullable column
1:62af56f:         s.executeUpdate("create table  " + prefix + "_indextest4" +
1:62af56f:                 "(col1 integer)"); 
1:62af56f:         s.executeUpdate("create index "+ prefix
1:62af56f:                 + "_nuin on " + prefix + "_indextest4 (col1)");
1:a8edfcf: 
1:2f99495:         // behavior of unique constraint on non-nullable columns 
1:2f99495:         // should not change, should match behavior of unique index
1:2f99495:         // on non-null column.
1:2f99495:         s.executeUpdate("create table  " + prefix + "_indextest5" +
1:2f99495:                 "(col1 integer not null)"); 
1:2f99495:         //try creating index without seting column as not null 
1:2f99495:         s.executeUpdate("alter table " + prefix + "_indextest5 " +
1:2f99495:                 "add constraint " + 
1:2f99495:                 prefix + "_cons1 unique(col1)");
1:62af56f:     }
1:0982847:     /**
1:62af56f:      * Test index created before upgrades to insure their behaviour 
1:62af56f:      * remains same after soft and hard upgrades.  This is an index
1:62af56f:      * test and does not apply to constraint behavior.
1:0982847:      */
1:62af56f:     public void testIndexes () throws Exception {
1:62af56f:         Statement s = createStatement();
1:aaa1403:         switch (getPhase()) {
1:aaa1403:             case PH_CREATE:
1:62af56f:                 //create tables for testing in soft and hard upgrade
1:62af56f:                 createTablesForIndexTesting (s, "ph_create");
1:62af56f:                 //test if indexes are created properly
1:62af56f:                 testIndexes(s, "ph_create_indextest1", 1, false, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest2", 1, true, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest3", 1, false, true);
1:62af56f:                 testIndexes(s, "ph_create_indextest4", 1, true, true);
1:2f99495:                 testIndexes(s, "ph_create_indextest5", 1, false, false);
1:aaa1403:                 break;
1:aaa1403:                 
1:aaa1403:             case PH_SOFT_UPGRADE:
1:62af56f:                 //test old tables
1:62af56f:                 testIndexes(s, "ph_create_indextest1", 2, false, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest2", 2, true, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest3", 2, false, true);
1:62af56f:                 testIndexes(s, "ph_create_indextest4", 2, true, true);
1:2f99495:                 testIndexes(s, "ph_create_indextest5", 2, false, false);
1:62af56f:                 //create one more set of tables
1:62af56f:                 createTablesForIndexTesting (s, "ph__soft_upg");
1:62af56f:                 //test newly created tables
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest1", 2, false, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest2", 2, true, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest3", 2, false, true);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest4", 2, true, true);
1:2f99495:                 testIndexes(s, "ph__soft_upg_indextest5", 2, false, false);
1:aaa1403:                 break;
1:aaa1403:                 
1:aaa1403:             case PH_POST_SOFT_UPGRADE:
1:62af56f:                 //test tables created so far
1:62af56f:                 testIndexes(s, "ph_create_indextest1", 3, false, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest2", 3, true, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest3", 3, false, true);
1:62af56f:                 testIndexes(s, "ph_create_indextest4", 3, true, true);
1:2f99495:                 testIndexes(s, "ph_create_indextest5", 3, false, false);
1:aaa1403: 
1:aaa1403:                 
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest1", 3, false, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest2", 3, true, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest3", 3, false, true);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest4", 3, true, true);
1:2f99495:                 testIndexes(s, "ph__soft_upg_indextest5", 3, false, false);
1:aaa1403:                 break;
1:aaa1403:                 
1:aaa1403:             case PH_HARD_UPGRADE:
1:62af56f:                 //test tables created so far
1:62af56f:                 testIndexes(s, "ph_create_indextest1", 4, false, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest2", 4, true, false);
1:62af56f:                 testIndexes(s, "ph_create_indextest3", 4, false, true);
1:62af56f:                 testIndexes(s, "ph_create_indextest4", 4, true, true);
1:2f99495:                 testIndexes(s, "ph_create_indextest5", 4, false, false);
1:aaa1403: 
1:aaa1403:                 
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest1", 4, false, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest2", 4, true, false);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest3", 4, false, true);
1:62af56f:                 testIndexes(s, "ph__soft_upg_indextest4", 4, true, true);
1:2f99495:                 testIndexes(s, "ph__soft_upg_indextest5", 5, false, false);
1:aaa1403:                 
1:62af56f:                 //create final set of tables
1:62af56f:                 createTablesForIndexTesting (s, "ph_upgrade");
1:62af56f:                 //test them
1:62af56f:                 testIndexes(s, "ph_upgrade_indextest1", 4, false, false);
1:62af56f:                 testIndexes(s, "ph_upgrade_indextest2", 4, true, false);
1:62af56f:                 testIndexes(s, "ph_upgrade_indextest3", 4, false, true);
1:62af56f:                 testIndexes(s, "ph_upgrade_indextest4", 4, true, true);
1:2f99495:                 testIndexes(s, "ph_upgrade_indextest5", 4, false, false);
1:aaa1403:                 break;
1:aaa1403:         }
1:62af56f:         s.close();
1:0982847:     }
1:62af56f:     /**
1:62af56f:      * Tests Unique constraint in soft and hard upgrade enviornment. 
1:62af56f:      * Under soft upgrade environment creation of unique constrant 
1:62af56f:      * over nullable columns and setting columns from unique constraint
1:62af56f:      * to null should fail. Also the constraint created during soft 
1:2f99495:      * upgrade run should work fine when running under previous version.
1:62af56f:      * @throws SQLException at any unexpected failure.
1:aaa1403:      */
1:62af56f:     public void testUniqueConstraint () throws SQLException {
1:62af56f:         Statement s = createStatement();
1:0982847:         switch (getPhase()) {
1:0982847:             case PH_CREATE:
1:62af56f:                 //create a table with unique constraint
1:2f99495:                 s.executeUpdate(
1:2f99495:                     "create table constraintest1 (i integer not null" +
1:2f99495:                     ", j integer, k integer, constraint ucon unique (i))");
1:62af56f:                 //and one without constraint
1:62af56f:                 s.executeUpdate("create table constraintest2 (i integer" +
1:62af56f:                         ", j integer, k integer)");
1:62af56f:                 s.executeUpdate("create table constraintest3 (" +
1:62af56f:                         "i integer not null, j integer, k integer)");
1:a8edfcf:                 break;
1:0982847:             case PH_SOFT_UPGRADE:
1:62af56f:                 //try setting i to nullable 42Z20
1:62af56f:                 assertStatementError("42Z20", s, "alter table constraintest1 " +
1:62af56f:                         "alter column i null");
1:62af56f:                 //try creating index without seting column as not null 
1:2f99495:                 assertStatementError("42831", s, "alter table constraintest2 " +
1:62af56f:                         "add constraint ucon1 unique(i, j)");
1:62af56f:                 //this should work fine
1:62af56f:                 s.execute ("alter table constraintest3 add " +
1:62af56f:                         "constraint ucon2 unique(i)");
1:0982847:                 break;
1:62af56f:             case PH_POST_SOFT_UPGRADE:
1:62af56f:                 //try violating ucon2
1:62af56f:                 s.executeUpdate ("insert into constraintest3 (i) values (1)");
1:62af56f:                 //duplicate key violation 23505
1:62af56f:                 assertStatementError ("23505", s, 
1:62af56f:                             "insert into constraintest3 (i) values (1)");
1:0982847:                 break;
1:62af56f:             case PH_HARD_UPGRADE:
1:62af56f:                 //test unique constraint
1:62af56f:                 s.executeUpdate ("insert into constraintest1 (i) values (2)");
1:62af56f:                 //duplicate key violation 23505
1:62af56f:                 assertStatementError ("23505", s, 
1:62af56f:                             "insert into constraintest1 (i) values (2)");
1:a52a206:                 //should able to drop nullablity
1:a52a206:                 s.executeUpdate("alter table constraintest1 " +
1:a52a206:                         "alter column i null");
1:a52a206:                 //try creating index without seting column as not null
1:a52a206:                 s.executeUpdate("alter table constraintest2 " +
1:a52a206:                         "add constraint ucon1 unique(i, j)");
1:a52a206:                 //test null values in unique constraint
1:a52a206:                 s.executeUpdate ("insert into constraintest1 (j) values (1)");
1:a52a206:                 s.executeUpdate ("insert into constraintest1 (j) values (1)");
1:a52a206:                 //test null values in new index
1:a52a206:                 s.executeUpdate ("insert into constraintest2 (j) values (1)");
1:a52a206:                 s.executeUpdate ("insert into constraintest2 (j) values (1)");
1:a52a206:                 break;
1:0982847:         }
1:62af56f:         s.close();
1:62af56f:     }
1:aaa1403:     
1:62af56f:     /**
1:a8edfcf:      * Verifies error messages priviously generated.
1:a8edfcf:      */
1:a8edfcf:     private void verifyError() throws SQLException {
1:a8edfcf:         Statement stmt = createStatement();
1:a8edfcf:         PreparedStatement ps = prepareStatement("select text " +
1:a8edfcf:                                     "from errormessage where state = ?");
1:aaa1403:         if (oldAtLeast(10,2)) {
1:aaa1403:             try {
1:a8edfcf:                 stmt.execute("alter table t1 alter column i null");
1:a8edfcf:                 fail ("expected error while setting primary key " +
1:a8edfcf:                         "column to nullable");
1:aaa1403:             } catch (SQLException e) {
1:a8edfcf:                 assertSQLState("expected state 42Z20", "42Z20", e);
1:a8edfcf:                 ps.setString(1, e.getSQLState());
1:a8edfcf:                 ResultSet rs = ps.executeQuery();
1:a8edfcf:                 rs.next();
1:a8edfcf:                 assertEquals("error message mismatch", rs.getString(1),
1:a8edfcf:                                         e.getMessage());
1:a8edfcf:                 rs.close();
1:aaa1403:             }
1:aaa1403:         }
1:aaa1403:         try {
1:a8edfcf:             stmt.execute("alter table t1 add constraint  uidx " +
1:a8edfcf:                     "unique(j)");
1:a8edfcf:             fail ("expected error while creating unique constraint " +
1:a8edfcf:                     "over nullable column");
1:aaa1403: 
1:aaa1403:         } catch (SQLException e) {
1:a8edfcf:             assertSQLState("expected state 42831", "42831", e);
1:a8edfcf:             ps.setString(1, e.getSQLState());
1:a8edfcf:             ResultSet rs = ps.executeQuery();
1:a8edfcf:             rs.next();
1:a8edfcf:             assertEquals("error message mismatch", rs.getString(1),
1:a8edfcf:                                     e.getMessage());
1:a8edfcf:             rs.close();
1:aaa1403:         }
1:a8edfcf:         stmt.close();
1:a8edfcf:         ps.close();
1:aaa1403:     }
1:aaa1403:     
1:a8edfcf:     /**
1:a8edfcf:      * Generates error messages and stores in a table.
1:a8edfcf:      */
1:a8edfcf:     private void prepareTable() throws SQLException {
1:a8edfcf:         Statement stmt = createStatement();
1:a8edfcf:         stmt.executeUpdate("create table errormessage (state varchar (6), " +
1:a8edfcf:                                             "text varchar (200))");
1:a8edfcf:         PreparedStatement ps = prepareStatement("insert into errormessage " +
1:a8edfcf:                     "(state, text) values (?, ?)");
1:a8edfcf:         stmt.executeUpdate("create table t1 (i integer not null primary key, " +
1:a8edfcf:                                                             "j integer)");
2:a8edfcf:         if (oldAtLeast(10,2)) {
1:a8edfcf:             try {
1:a8edfcf:                 stmt.execute("alter table t1 alter column i null");
1:a8edfcf:                 fail ("expected error while setting primary key " +
1:a8edfcf:                         "column to nullable");
3:a8edfcf:             } catch (SQLException e) {
1:a8edfcf:                 assertSQLState("expected state 42Z20", "42Z20", e);
1:a8edfcf:                 ps.setString(1, e.getSQLState());
1:a8edfcf:                 ps.setString(2, e.getMessage());
1:a8edfcf:                 ps.executeUpdate();
1:a8edfcf:             }
1:a8edfcf:         }
1:a8edfcf:         try {
1:a8edfcf:             stmt.execute("alter table t1 add constraint  uidx " +
1:a8edfcf:                     "unique(j)");
1:a8edfcf:             fail ("expected error while creating unique constraint " +
1:a8edfcf:                     "over nullable column");
1:a8edfcf:         } catch (SQLException e) {
1:a8edfcf:             assertSQLState("expected state 42831", "42831", e);
1:a8edfcf:             ps.setString(1, e.getSQLState());
1:a8edfcf:             ps.setString(2, e.getMessage());
1:a8edfcf:             ps.executeUpdate();
1:a8edfcf:         }
1:a8edfcf:         stmt.close();
1:a8edfcf:         ps.close();
1:a8edfcf:     }
1:aaa1403:     
1:a8edfcf:     /**
1:a8edfcf:      * check if error message generated during soft upgrade is 
1:a8edfcf:      * same as privious version.
1:a8edfcf:      */
1:a8edfcf:     public void testErrorMessage () throws Exception {
1:a8edfcf:         switch (getPhase()) {
1:a8edfcf:             case PH_CREATE:
1:a8edfcf:                 prepareTable();
1:aaa1403:                 break;
1:a8edfcf:             case PH_SOFT_UPGRADE:
1:a8edfcf:                 verifyError();
1:a8edfcf:                 break;
1:a8edfcf:         }
1:a8edfcf:     }
1:aaa1403:     
1:0982847:     /**
1:419210d:      * Tests if alter column works for a column in unique constraint.
1:419210d:      */
1:419210d:     public void testAlterColumnOfUniqueConstraint () throws Exception {
1:419210d:         Statement stmt = createStatement();
1:419210d:         switch (getPhase()) {
1:419210d:            case PH_CREATE:
1:419210d:                stmt.executeUpdate("create table datatype_test (fl1 varchar (2) " +
1:419210d:                        "not null)");
1:419210d:                stmt.executeUpdate("alter table datatype_test " +
1:419210d:                        "add constraint ucon_datatype_test unique (fl1)");
1:419210d:                stmt.executeUpdate("alter table datatype_test alter column fl1" +
1:419210d:                        " set data type varchar (3)");
1:419210d:                break;
1:419210d:            case PH_SOFT_UPGRADE:
1:419210d:                stmt.executeUpdate("alter table datatype_test alter column fl1 " +
1:419210d:                        " set data type varchar (4)");
1:419210d:                break;
1:aaa1403: 
1:419210d:            case PH_HARD_UPGRADE:
1:419210d:                stmt.executeUpdate("alter table datatype_test alter column fl1 " +
1:419210d:                        " set data type varchar (5)");
1:419210d:                break;
1:419210d:         }
1:419210d:         stmt.close();
1:419210d:     }
1:a8edfcf: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.text.Collator;
1: import java.util.Locale;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade test for 10.4");
commit:15b2b98
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:aaa1403
/////////////////////////////////////////////////////////////////////////
0: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Check that you must be hard-upgraded to 10.4 or later in order to use
0:      * SQL roles
1:      * @throws SQLException
1:      *
1:      */
0:     public void testSQLRolesBasic() throws SQLException
1:     {
0:         // The standard upgrade database doesn't have sqlAuthorization
0:         // set, so we can only check if the system tables for roles is
0:         // present.
1: 
1:         Statement s = createStatement();
0:         String createRoleText = "create role foo";
1: 
1:         switch (getPhase())
1:             {
1:             case PH_CREATE:
0:                 assertStatementError("42X01", s, createRoleText );
1:                 break;
1: 
1:             case PH_SOFT_UPGRADE:
0:                 // needs hard upgrade
0:                 assertStatementError("XCL47", s, createRoleText );
1:                 break;
1: 
1:             case PH_POST_SOFT_UPGRADE:
0:                 assertStatementError("42X01", s, createRoleText );
1:                 break;
1: 
1:             case PH_HARD_UPGRADE:
0:             case PH_POST_HARD_UPGRADE:
0:                 // not supported because SQL authorization not set
0:                 assertStatementError("42Z60", s, createRoleText );
1:                 break;
1:             }
1: 
1:         s.close();
1:     }
1: 
1:     /**
0:      * Check that when hard-upgraded to 10.4 or later SQL roles can be
0:      * declared if DB has sqlAuthorization.
1:      * @throws SQLException
1:      *
1:      */
0:     public void testSQLRoles() throws SQLException
1:     {
0:         // Do rudimentary sanity checking: that we can create and drop roles
0:         // when we are database owner. If so, we can presume SYS.SYSROLES
0:         // has been upgraded correctly.
1: 
0:         DataSource ds = JDBCDataSource.getDataSourceLogical("ROLES_10_4");
0:         String createRoleText = "create role foo";
0:         String dropRoleText   = "drop role foo";
0:         Connection conn = null;
0:         Statement s = null;
0:         boolean supportSqlAuthorization = oldAtLeast(10, 2);
1: 
0:         JDBCDataSource.setBeanProperty(ds, "user", "garfield");
0:         JDBCDataSource.setBeanProperty(ds, "password", "theCat");
1: 
1:         switch (getPhase()) {
1:         case PH_CREATE:
0:             // create the database if it was not already created.
0:             JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
0:             conn = ds.getConnection();
1: 
0:             // Make the database have std security, and define
0:             // a database user for the database owner).
0:             CallableStatement cs = conn.prepareCall(
0:                 "call syscs_util.syscs_set_database_property(?,?)");
1: 
0:             cs.setString(1, "derby.connection.requireAuthentication");
0:             cs.setString(2, "true");
0:             cs.execute();
1: 
0:             cs.setString(1, "derby.authentication.provider");
0:             cs.setString(2, "BUILTIN");
0:             cs.execute();
1: 
0:             cs.setString(1, "derby.database.sqlAuthorization");
0:             cs.setString(2, "true");
0:             cs.execute();
1: 
0:             cs.setString(1, "derby.database.propertiesOnly");
0:             cs.setString(2, "true");
0:             cs.execute();
1: 
0:             cs.setString(1, "derby.user.garfield");
0:             cs.setString(2, "theCat");
0:             cs.execute();
1: 
0:             conn.close();
1: 
0:             JDBCDataSource.shutdownDatabase(ds);
1:             break;
1: 
1:         case PH_SOFT_UPGRADE:
0:             /* We can't always do soft upgrade, because when
0:              * sqlAuthorization is set and we are coming from a
0:              * pre-10.2 database, connecting will fail with a message
0:              * to hard upgrade before setting sqlAuthorization, so we
0:              * skip this step.
1:              */
1:             if (oldAtLeast(10,2)) {
0:                 // needs hard upgrade
0:                 conn = ds.getConnection();
0:                 s = conn.createStatement();
1: 
0:                 assertStatementError("XCL47", s, createRoleText );
0:                 conn.close();
1: 
0:                 JDBCDataSource.shutdownDatabase(ds);
1:             }
1:             break;
1: 
1:         case PH_POST_SOFT_UPGRADE:
0:             conn = ds.getConnection();
0:             s = conn.createStatement();
1: 
0:             // syntax error
0:             assertStatementError("42X01", s, createRoleText );
0:             conn.close();
1: 
0:             JDBCDataSource.shutdownDatabase(ds);
1:             break;
1: 
1:         case PH_HARD_UPGRADE:
1:             JDBCDataSource.setBeanProperty(
0:                 ds, "connectionAttributes", "upgrade=true");
0:             conn = ds.getConnection();
0:             s = conn.createStatement();
1: 
0:             // should work now
1:             try {
0:                 s.execute(createRoleText);
1:             } catch (SQLException e) {
0:                 fail("can't create role on hard upgrade");
1:             }
1: 
0:             s.execute(dropRoleText);
0:             conn.close();
1: 
0:             JDBCDataSource.clearStringBeanProperty(ds, "connectionAttributes");
0:             JDBCDataSource.shutdownDatabase(ds);
1:             break;
1: 
0:         case PH_POST_HARD_UPGRADE:
0:             conn = ds.getConnection();
0:             s = conn.createStatement();
1: 
0:             // should work now
1:             try {
0:                 s.execute(createRoleText);
1:             } catch (SQLException e) {
0:                 fail("can't create role post hard upgrade");
1:             }
1: 
0:             s.execute(dropRoleText);
0:             conn.close();
1: 
0:             JDBCDataSource.shutdownDatabase(ds);
1:             break;
1:         }
1:     }
author:Ole Solberg
-------------------------------------------------------------------------------
commit:fc061da
/////////////////////////////////////////////////////////////////////////
0: import java.text.Collator;
0: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:             String locale = "en";
1:             Locale[] availableLocales = Collator.getAvailableLocales();
1:             for (int i = 0; i < availableLocales.length; i++) {
1:                 if ("no".equals(availableLocales[i].getLanguage())) {
1:                     locale="no"; // Use something different than 'en' 
1:                     // if the JVM supports it.
1:                     break;
1:                 }
1:             }
1: 
1:                     ds, "ConnectionAttributes", 
1:                     "create=true;territory="+locale+";"
1:                         +"collation=TERRITORY_BASED");
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:419210d
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Tests if alter column works for a column in unique constraint.
1:      */
1:     public void testAlterColumnOfUniqueConstraint () throws Exception {
1:         Statement stmt = createStatement();
1:         switch (getPhase()) {
1:            case PH_CREATE:
1:                stmt.executeUpdate("create table datatype_test (fl1 varchar (2) " +
1:                        "not null)");
1:                stmt.executeUpdate("alter table datatype_test " +
1:                        "add constraint ucon_datatype_test unique (fl1)");
1:                stmt.executeUpdate("alter table datatype_test alter column fl1" +
1:                        " set data type varchar (3)");
1:                break;
1:            case PH_SOFT_UPGRADE:
1:                stmt.executeUpdate("alter table datatype_test alter column fl1 " +
1:                        " set data type varchar (4)");
1:                break;
1: 
1:            case PH_HARD_UPGRADE:
1:                stmt.executeUpdate("alter table datatype_test alter column fl1 " +
1:                        " set data type varchar (5)");
1:                break;
1:         }
1:         stmt.close();
1:     }
commit:a8edfcf
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Verifies error messages priviously generated.
1:      */
1:     private void verifyError() throws SQLException {
1:         Statement stmt = createStatement();
1:         PreparedStatement ps = prepareStatement("select text " +
1:                                     "from errormessage where state = ?");
1:         if (oldAtLeast(10,2)) {
1:             try {
1:                 stmt.execute("alter table t1 alter column i null");
1:                 fail ("expected error while setting primary key " +
1:                         "column to nullable");
1:             } catch (SQLException e) {
1:                 assertSQLState("expected state 42Z20", "42Z20", e);
1:                 ps.setString(1, e.getSQLState());
1:                 ResultSet rs = ps.executeQuery();
1:                 rs.next();
1:                 assertEquals("error message mismatch", rs.getString(1),
1:                                         e.getMessage());
1:                 rs.close();
1:             }
1:         }
1:         try {
1:             stmt.execute("alter table t1 add constraint  uidx " +
1:                     "unique(j)");
1:             fail ("expected error while creating unique constraint " +
1:                     "over nullable column");
1: 
1:         } catch (SQLException e) {
1:             assertSQLState("expected state 42831", "42831", e);
1:             ps.setString(1, e.getSQLState());
1:             ResultSet rs = ps.executeQuery();
1:             rs.next();
1:             assertEquals("error message mismatch", rs.getString(1),
1:                                     e.getMessage());
1:             rs.close();
1:         }
1:         stmt.close();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Generates error messages and stores in a table.
1:      */
1:     private void prepareTable() throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table errormessage (state varchar (6), " +
1:                                             "text varchar (200))");
1:         PreparedStatement ps = prepareStatement("insert into errormessage " +
1:                     "(state, text) values (?, ?)");
1:         stmt.executeUpdate("create table t1 (i integer not null primary key, " +
1:                                                             "j integer)");
1:         if (oldAtLeast(10,2)) {
1:             try {
1:                 stmt.execute("alter table t1 alter column i null");
1:                 fail ("expected error while setting primary key " +
1:                         "column to nullable");
1:             } catch (SQLException e) {
1:                 assertSQLState("expected state 42Z20", "42Z20", e);
1:                 ps.setString(1, e.getSQLState());
1:                 ps.setString(2, e.getMessage());
1:                 ps.executeUpdate();
1:             }
1:         }
1:         try {
1:             stmt.execute("alter table t1 add constraint  uidx " +
1:                     "unique(j)");
1:             fail ("expected error while creating unique constraint " +
1:                     "over nullable column");
1:         } catch (SQLException e) {
1:             assertSQLState("expected state 42831", "42831", e);
1:             ps.setString(1, e.getSQLState());
1:             ps.setString(2, e.getMessage());
1:             ps.executeUpdate();
1:         }
1:         stmt.close();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * check if error message generated during soft upgrade is 
1:      * same as privious version.
1:      */
1:     public void testErrorMessage () throws Exception {
1:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 prepareTable();
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 verifyError();
1:                 break;
1:         }
1:     }
commit:5915e88
/////////////////////////////////////////////////////////////////////////
commit:0982847
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
0:      * Verifies error messages priviously generated.
1:      */
0:     private void verifyError() throws SQLException {
0:         Statement stmt = createStatement();
0:         PreparedStatement ps = prepareStatement("select text " +
0:                                     "from errormessage where state = ?");
1:         try {
0:             stmt.execute("alter table t1 alter column i null");
0:             fail ("expected error while setting primary key " +
0:                     "column to nullable");
0:         } catch (SQLException e) {
0:             assertSQLState("expected state 42Z20", "42Z20", e);
0:             ps.setString(1, e.getSQLState());
0:             ResultSet rs = ps.executeQuery();
0:             rs.next();
0:             assertEquals("error message mismatch", rs.getString(1),
0:                                     e.getMessage());
0:             rs.close();
1:         }
1:         try {
0:             stmt.execute("alter table t1 add constraint  uidx " +
0:                     "unique(j)");
0:             fail ("expected error while creating unique constraint " +
0:                     "over nullable column");
1: 
0:         } catch (SQLException e) {
0:             assertSQLState("expected state 42831", "42831", e);
0:             ps.setString(1, e.getSQLState());
0:             ResultSet rs = ps.executeQuery();
0:             rs.next();
0:             assertEquals("error message mismatch", rs.getString(1),
0:                                     e.getMessage());
0:             rs.close();
1:         }
0:         stmt.close();
0:         ps.close();
1:     }
1:     
1:     /**
0:      * Generates error messages and stores in a table.
1:      */
0:     private void prepareTable() throws SQLException {
0:         Statement stmt = createStatement();
0:         stmt.executeUpdate("create table errormessage (state varchar (6), " +
0:                                             "text varchar (200))");
0:         PreparedStatement ps = prepareStatement("insert into errormessage " +
0:                     "(state, text) values (?, ?)");
0:         stmt.executeUpdate("create table t1 (i integer primary key, " +
0:                                                             "j integer)");
1:         try {
0:             stmt.execute("alter table t1 alter column i null");
0:             fail ("expected error while setting primary key " +
0:                     "column to nullable");
0:         } catch (SQLException e) {
0:             assertSQLState("expected state 42Z20", "42Z20", e);
0:             ps.setString(1, e.getSQLState());
0:             ps.setString(2, e.getMessage());
0:             ps.executeUpdate();
1:         }
1:         try {
0:             stmt.execute("alter table t1 add constraint  uidx " +
0:                     "unique(j)");
0:             fail ("expected error while creating unique constraint " +
0:                     "over nullable column");
0:         } catch (SQLException e) {
0:             assertSQLState("expected state 42831", "42831", e);
0:             ps.setString(1, e.getSQLState());
0:             ps.setString(2, e.getMessage());
0:             ps.executeUpdate();
1:         }
0:         stmt.close();
0:         ps.close();
1:     }
1:     
1:     /**
0:      * check if error message generated during soft upgrade is 
0:      * same as privious version.
1:      */
0:     public void testErrorMessage () throws Exception {
1:         switch (getPhase()) {
1:             case PH_CREATE:
0:                 prepareTable();
1:                 break;
1:             case PH_SOFT_UPGRADE:
0:                 verifyError();
1:                 break;
1:         }
1:     }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2f99495
/////////////////////////////////////////////////////////////////////////
1: 
1:         // behavior of unique constraint on non-nullable columns 
1:         // should not change, should match behavior of unique index
1:         // on non-null column.
1:         s.executeUpdate("create table  " + prefix + "_indextest5" +
1:                 "(col1 integer not null)"); 
1:         //try creating index without seting column as not null 
1:         s.executeUpdate("alter table " + prefix + "_indextest5 " +
1:                 "add constraint " + 
1:                 prefix + "_cons1 unique(col1)");
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph_create_indextest5", 1, false, false);
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph_create_indextest5", 2, false, false);
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph__soft_upg_indextest5", 2, false, false);
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph_create_indextest5", 3, false, false);
1:                 testIndexes(s, "ph__soft_upg_indextest5", 3, false, false);
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph_create_indextest5", 4, false, false);
1:                 testIndexes(s, "ph__soft_upg_indextest5", 5, false, false);
/////////////////////////////////////////////////////////////////////////
1:                 testIndexes(s, "ph_upgrade_indextest5", 4, false, false);
/////////////////////////////////////////////////////////////////////////
1:      * upgrade run should work fine when running under previous version.
/////////////////////////////////////////////////////////////////////////
1:                 s.executeUpdate(
1:                     "create table constraintest1 (i integer not null" +
1:                     ", j integer, k integer, constraint ucon unique (i))");
/////////////////////////////////////////////////////////////////////////
1:                 assertStatementError("42831", s, "alter table constraintest2 " +
commit:a52a206
/////////////////////////////////////////////////////////////////////////
1:                 //should able to drop nullablity
1:                 s.executeUpdate("alter table constraintest1 " +
1:                         "alter column i null");
1:                 //try creating index without seting column as not null
1:                 s.executeUpdate("alter table constraintest2 " +
1:                         "add constraint ucon1 unique(i, j)");
1:                 //test null values in unique constraint
1:                 s.executeUpdate ("insert into constraintest1 (j) values (1)");
1:                 s.executeUpdate ("insert into constraintest1 (j) values (1)");
1:                 //test null values in new index
1:                 s.executeUpdate ("insert into constraintest2 (j) values (1)");
1:                 s.executeUpdate ("insert into constraintest2 (j) values (1)");
1:                 break;
commit:62af56f
/////////////////////////////////////////////////////////////////////////
1:     
1: 
1:     /**
1:      * Tests whether or not indexes are exibiting their expected behaviour.
1:      *
1:      * @param s         Statement 
1:      * @param tableName table name to be used for testing
1:      * @param val       value to be used for insertion
1:      * @param nulls     if nulls are allowed 
1:      * @param duplicate if duplicates are allowed
1:      */
1:     private void testIndexes (Statement s, String tableName, int val,
1:             boolean nulls, boolean duplicate) throws Exception {
1: 
1:         //clean table first
1:         s.executeUpdate("delete from " + tableName);
1:         s.executeUpdate("insert into " + tableName + " values (" + val +")");
1: 
1:         // verify insert of input value results in expected duplicate behavior
0:         try {
1:             s.executeUpdate(
1:                 "insert into " + tableName + " values (" + val +")");
1: 
1:             if (!duplicate)
1:                 fail("no duplicates allowed");
1:         }
1:         catch (SQLException e) {
1:             //throw 23505
1:             if (!duplicate) {
1:                 assertSQLState("duplicate record", "23505", e);
1:             }
1:             else {
1:                 throw e;
1:             }
1:         }
1: 
1:         // verify insert of a null value results in expected behavior
0:         try {
1:             s.executeUpdate("insert into " + tableName + " values (null)");
1:             if (!nulls)
1:                 fail("null in a not null column");
1:         }
1:         catch (SQLException e) {
1:             if (!nulls) { //23502
1:                 assertSQLState("null in not null column", "23502", e);
1:             }
1:             else {
1:                 throw e;
1:             }
1:         }
1: 
1:         // if nulls are allowed, verify expected behavior of 2nd null insert.
1:         if (!nulls)
1:             return;
0:         try {
1:             s.executeUpdate("insert into " + tableName + " values (null)");
1:             if (!duplicate)
1:                 fail("no duplicates allowed");
1:         }
1:         catch (SQLException e) {
1:         if (!duplicate) {
1:                 assertSQLState("duplicate record", "23505", e);
1:             }
1:             else {
1:                 throw e;
1:             }
1:         }
1:     }
1:     
1:     /**
1:      * Creates tables to test indexes during and after soft and hard 
1:      * upgrades
1:      * @param s Statement
1:      * @param prefix prefix for table names
1:      */
1:     private void createTablesForIndexTesting (Statement s, String prefix) 
1:                                     throws Exception {
1: 
1:         // unique index on non-null column
1:         s.executeUpdate("create table  " + prefix + "_indextest1" +
1:                 "(col1 integer not null)"); 
1:         s.executeUpdate("create unique index "+ prefix
1:                 + "_uinn on " + prefix + "_indextest1 (col1)");
1: 
1:         // unique index on nullable column
1:         s.executeUpdate("create table  " + prefix + "_indextest2" +
1:                 "(col1 integer)"); 
1:         s.executeUpdate("create unique index "+ prefix
1:                 + "_uin on " + prefix + "_indextest2 (col1)");
1: 
1:         // non-unique index on non-nullable column
1:         s.executeUpdate("create table  " + prefix + "_indextest3" +
1:                 "(col1 integer not null)");     
1:         s.executeUpdate("create index "+ prefix
1:                 + "_nuinn on " + prefix + "_indextest3 (col1)");
1: 
1:         // non-unique index on nullable column
1:         s.executeUpdate("create table  " + prefix + "_indextest4" +
1:                 "(col1 integer)"); 
1:         s.executeUpdate("create index "+ prefix
1:                 + "_nuin on " + prefix + "_indextest4 (col1)");
1:     }
1:     /**
1:      * Test index created before upgrades to insure their behaviour 
1:      * remains same after soft and hard upgrades.  This is an index
1:      * test and does not apply to constraint behavior.
1:      */
1:     public void testIndexes () throws Exception {
1:         Statement s = createStatement();
0:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 //create tables for testing in soft and hard upgrade
1:                 createTablesForIndexTesting (s, "ph_create");
1:                 //test if indexes are created properly
1:                 testIndexes(s, "ph_create_indextest1", 1, false, false);
1:                 testIndexes(s, "ph_create_indextest2", 1, true, false);
1:                 testIndexes(s, "ph_create_indextest3", 1, false, true);
1:                 testIndexes(s, "ph_create_indextest4", 1, true, true);
1:                 break;
1:                 
1:             case PH_SOFT_UPGRADE:
1:                 //test old tables
1:                 testIndexes(s, "ph_create_indextest1", 2, false, false);
1:                 testIndexes(s, "ph_create_indextest2", 2, true, false);
1:                 testIndexes(s, "ph_create_indextest3", 2, false, true);
1:                 testIndexes(s, "ph_create_indextest4", 2, true, true);
1:                 //create one more set of tables
1:                 createTablesForIndexTesting (s, "ph__soft_upg");
1:                 //test newly created tables
1:                 testIndexes(s, "ph__soft_upg_indextest1", 2, false, false);
1:                 testIndexes(s, "ph__soft_upg_indextest2", 2, true, false);
1:                 testIndexes(s, "ph__soft_upg_indextest3", 2, false, true);
1:                 testIndexes(s, "ph__soft_upg_indextest4", 2, true, true);
1:                 break;
1:                 
1:             case PH_POST_SOFT_UPGRADE:
1:                 //test tables created so far
1:                 testIndexes(s, "ph_create_indextest1", 3, false, false);
1:                 testIndexes(s, "ph_create_indextest2", 3, true, false);
1:                 testIndexes(s, "ph_create_indextest3", 3, false, true);
1:                 testIndexes(s, "ph_create_indextest4", 3, true, true);
1: 
1:                 
1:                 testIndexes(s, "ph__soft_upg_indextest1", 3, false, false);
1:                 testIndexes(s, "ph__soft_upg_indextest2", 3, true, false);
1:                 testIndexes(s, "ph__soft_upg_indextest3", 3, false, true);
1:                 testIndexes(s, "ph__soft_upg_indextest4", 3, true, true);
1:                 break;
1:                 
1:             case PH_HARD_UPGRADE:
1:                 //test tables created so far
1:                 testIndexes(s, "ph_create_indextest1", 4, false, false);
1:                 testIndexes(s, "ph_create_indextest2", 4, true, false);
1:                 testIndexes(s, "ph_create_indextest3", 4, false, true);
1:                 testIndexes(s, "ph_create_indextest4", 4, true, true);
1: 
1:                 
1:                 testIndexes(s, "ph__soft_upg_indextest1", 4, false, false);
1:                 testIndexes(s, "ph__soft_upg_indextest2", 4, true, false);
1:                 testIndexes(s, "ph__soft_upg_indextest3", 4, false, true);
1:                 testIndexes(s, "ph__soft_upg_indextest4", 4, true, true);
1:                 
1:                 //create final set of tables
1:                 createTablesForIndexTesting (s, "ph_upgrade");
1:                 //test them
1:                 testIndexes(s, "ph_upgrade_indextest1", 4, false, false);
1:                 testIndexes(s, "ph_upgrade_indextest2", 4, true, false);
1:                 testIndexes(s, "ph_upgrade_indextest3", 4, false, true);
1:                 testIndexes(s, "ph_upgrade_indextest4", 4, true, true);
1:                 break;
1:         }
1:         s.close();
1:     }
1:     /**
1:      * Tests Unique constraint in soft and hard upgrade enviornment. 
1:      * Under soft upgrade environment creation of unique constrant 
1:      * over nullable columns and setting columns from unique constraint
1:      * to null should fail. Also the constraint created during soft 
0:      * upgrade run should work fine when running under privious version.
1:      * @throws SQLException at any unexpected failure.
1:      */
1:     public void testUniqueConstraint () throws SQLException {
1:         Statement s = createStatement();
0:         switch (getPhase()) {
1:             case PH_CREATE:
1:                 //create a table with unique constraint
0:                 s.executeUpdate("create table constraintest1 (i integer not null" +
0:                         ", j integer, k integer, constraint ucon unique (i))");
1:                 //and one without constraint
1:                 s.executeUpdate("create table constraintest2 (i integer" +
1:                         ", j integer, k integer)");
1:                 s.executeUpdate("create table constraintest3 (" +
1:                         "i integer not null, j integer, k integer)");
1:                 break;
1:             case PH_SOFT_UPGRADE:
1:                 //try setting i to nullable 42Z20
1:                 assertStatementError("42Z20", s, "alter table constraintest1 " +
1:                         "alter column i null");
1:                 //try creating index without seting column as not null 
0:                 assertStatementError ("42831", s, "alter table constraintest2 " +
1:                         "add constraint ucon1 unique(i, j)");
1:                 //this should work fine
1:                 s.execute ("alter table constraintest3 add " +
1:                         "constraint ucon2 unique(i)");
1:                 break;
1:             case PH_POST_SOFT_UPGRADE:
1:                 //try violating ucon2
1:                 s.executeUpdate ("insert into constraintest3 (i) values (1)");
1:                 //duplicate key violation 23505
1:                 assertStatementError ("23505", s, 
1:                             "insert into constraintest3 (i) values (1)");
1:                 break;
1:             case PH_HARD_UPGRADE:
1:                 //test unique constraint
1:                 s.executeUpdate ("insert into constraintest1 (i) values (2)");
1:                 //duplicate key violation 23505
1:                 assertStatementError ("23505", s, 
1:                             "insert into constraintest1 (i) values (2)");
1:         }
1:         s.close();
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:35dff7c
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
0: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
0:     
0:     /**
1:      * Test that routine parameters and return types are
1:      * handled correctly with 10.4 creating a procedure
1:      * in soft-upgrade. 10.4 simplified the stored
1:      * format of the types by ensuring the catalog
1:      * type was written. See DERBY-2917 for details.
1:      * 
1:      * @throws SQLException 
1:      *
0:      */
1:     public void testRoutineParameters() throws SQLException
1:     {
0:         
0: 
1:         switch (getPhase())
1:         {
0:         case PH_CREATE:
0:           break;
0:             
0:         case PH_SOFT_UPGRADE:
0:             Statement s = createStatement();
1:             s.execute("CREATE FUNCTION TYPES_10_4" +
1:                     "(A INTEGER) RETURNS CHAR(10) " +
1:                     "LANGUAGE JAVA " +
1:                     "PARAMETER STYLE JAVA " +
1:                     "NO SQL " +
1:                     "EXTERNAL NAME 'java.lang.Integer.toHexString'");
1:            // fall through to test it
0:             
1:         case PH_HARD_UPGRADE:
1:         case PH_POST_SOFT_UPGRADE:
1:             PreparedStatement ps = prepareStatement(
1:                     "VALUES TYPES_10_4(?)");
1:             ps.setInt(1, 48879);
1:             // Don't use the single value check method here
1:             // because we want to check the returned value
1:             // was converted to its correct type of CHAR(10)
1:             // (so no trimming of values)
1:             JDBC.assertFullResultSet(ps.executeQuery(),
1:                     new Object[][] {{"beef      "}}, false);
0:             break;
0:         }
0:     }
commit:42aa1d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e9ff7be
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:     /**
1:      * Check that you must be hard-upgraded to 10.4 or later in order to declare
1:      * table functions.
0:      * @throws SQLException 
0:      *
0:      */
1:     public void testTableFunctionDeclaration() throws SQLException
1:     {
1:         Statement       s = createStatement();
1:         String          createTableFunctionText =
1:             "create function svnLogReader( logFileName varchar( 32672 ) )\n" +
1:             "returns TABLE\n" +
1:             "  (\n" +
1:             "     XID varchar( 15 ),\n" +
1:             "     committer    varchar( 20 ),\n" +
1:             "     commit_time  timestamp,\n" +
1:             "     line_count   varchar( 10 ),\n" +
1:             "     description  varchar( 32672 )\n" +
1:             "  )\n" +
1:             "language java\n" +
1:             "parameter style DERBY_JDBC_RESULT_SET\n" +
1:             "no sql\n" +
1:             "external name 'org.apache.derbyDemo.vtis.example.SubversionLogVTI.subversionLogVTI'\n"
1:             ;
0: 
1:         switch (getPhase())
1:         {
0:         case PH_CREATE:
1:             assertStatementError("42X01", s, createTableFunctionText );
0:             break;
0:             
0:         case PH_SOFT_UPGRADE:
1:             assertStatementError("XCL47", s, createTableFunctionText );
0:             break;
0:             
0:         case PH_POST_SOFT_UPGRADE:
1:             assertStatementError("42X01", s, createTableFunctionText );
0:             break;
0:             
0:         case PH_HARD_UPGRADE:
0:         case PH_POST_HARD_UPGRADE:
1:             s.execute( createTableFunctionText );
0:             break;
0:         }
0: 
1:         s.close();
0:     }
0: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ea5ca3f
/////////////////////////////////////////////////////////////////////////
1:     <UL>
1:     <LI> testMetaDataQueryRunInSYScompilationSchema - DERBY-2946 
1:     Make sure that metadata queries get run with SYS schema as the current 
1:     compilation schema rather than a user schema as the current compilation 
1:     schema. This is because if the user is inside a user schema in a collated 
1:     database and if the meta data query gets run inside the user schema, then 
1:     we will run into collation mismatch errors for a subclause like following 
1:     in the WHERE clause.
1:     P.SELECTPRIV = 'Y' 
1:     The reason for error is that the left hand side of the = operation will 
1:     have collation type of UCS_BASIC because that column belongs to a table 
1:     from system schema. But the collation type of the right hand will be 
1:     territory based if the current compilation schema is user schema. But if 
1:     the current compilation schema is set to SYS schema, then right hand side 
1:     will also have collation of UCS_BASIC and hence there won't be any 
1:     collation mismatch. 
1:     Background info : character string constants pick up the collation of the
1:     current compilation schema. 
1:     </UL>
0: 
/////////////////////////////////////////////////////////////////////////
1:      * Check that even though we have set schema to a user schema, the 
1:      * metadata queries get run with compilation schema as SYS.
1:      * DERBY-2946
1:      * Test added for 10.4.
1:     public void testMetaDataQueryRunInSYScompilationSchema() throws SQLException
1:     	//This test is for databases with territory based collation. That
1:     	//feature was added in 10.3 codeline and hence there is no point in
1:     	//doing any testing with pre-10.3 databases.
1:         if (!oldAtLeast(10, 3))
1:         	return;
0: 
1:         DataSource ds = JDBCDataSource.getDataSourceLogical("COLLATED_DB_10_3");
0:         
0:         switch (getPhase())
0:         {
0:         case PH_CREATE:
1:             // create the database if it was not already created. Note the
1:         	// JDBC url attributes.
0:             JDBCDataSource.setBeanProperty(
0:                     ds, "ConnectionAttributes", "create=true;territory=no;collation=TERRITORY_BASED");
1:             ds.getConnection().close();
0:             break;
0:             
0:         case PH_SOFT_UPGRADE:
0:         case PH_POST_SOFT_UPGRADE:
0:         case PH_HARD_UPGRADE:
0:         case PH_POST_HARD_UPGRADE:
1:             Connection con = ds.getConnection();
1:         	//First make the current schema as a user schema. And then run a 
1:         	//metadata query to make sure that it runs fine. If it does (which
1:         	//is the expected behavior), then it will mean that the metadata
1:         	//query is getting run with SYS as the compilation schema rather
1:         	//than the current schema which is APP.
1:             Statement s = con.createStatement();
1:             s.execute("SET SCHEMA APP");
0: 
1:             DatabaseMetaData dmd = con.getMetaData();
1:             ResultSet rs = dmd.getTables(null,"APP",null,null);
1:             JDBC.assertDrainResults(rs);
0:             s.close();
0:             break;
0:         }
commit:29e9328
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_4
0: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
0: 
1:    http://www.apache.org/licenses/LICENSE-2.0
0: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
0: 
0: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
0: 
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.JDBCDataSource;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: 
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: 
1: import javax.sql.DataSource;
0: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: 
0: /**
1:  * Upgrade test cases for 10.4.
1:  * If the old version is 10.4 or later then these tests
1:  * will not be run.
1:  * <BR>
1:     10.4 Upgrade issues
0: 
0:  */
1: public class Changes10_4 extends UpgradeChange {
0: 
1:     public Changes10_4(String name) {
1:         super(name);
0:     }
0:     
0:     /**
1:      * Return the suite of tests to test the changes made in 10.4.
1:      * @param phase an integer that indicates the current phase in
1:      *              the upgrade test.
1:      * @return the test suite created.
0:      */   
1:     public static Test suite(int phase) {
0:         TestSuite suite = new TestSuite("Upgrade test for 10.4");
0:         
1:         suite.addTestSuite(Changes10_4.class);
1:         return new SupportFilesSetup((Test) suite);
0:     }
0:     
0:     /**
0:      * Just a place holder until we add actual tests.
0:      * @throws SQLException 
0:      *
0:      */
0:     public void testRemoveMeAfterRealTestIsAdded() throws SQLException
0:     {
0:     }
0: }
============================================================================