1:166e695: /*
4:166e695: 
1:166e695:    Derby - Class org.apache.derbyTesting.unitTests.junit.SystemPrivilegesPermissionTest
1:166e695: 
1:166e695:    Licensed to the Apache Software Foundation (ASF) under one or more
1:166e695:    contributor license agreements.  See the NOTICE file distributed with
1:166e695:    this work for additional information regarding copyright ownership.
1:166e695:    The ASF licenses this file to you under the Apache License, Version 2.0
1:166e695:    (the "License"); you may not use this file except in compliance with
1:166e695:    the License.  You may obtain a copy of the License at
1:166e695: 
1:166e695:       http://www.apache.org/licenses/LICENSE-2.0
1:166e695: 
1:166e695:    Unless required by applicable law or agreed to in writing, software
1:166e695:    distributed under the License is distributed on an "AS IS" BASIS,
1:166e695:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:166e695:    See the License for the specific language governing permissions and
1:166e695:    limitations under the License.
1:166e695: 
3:166e695:  */
1:166e695: 
1:166e695: package org.apache.derbyTesting.unitTests.junit;
1:166e695: 
1:f5ac375: import java.io.ByteArrayInputStream;
1:f5ac375: import java.io.ByteArrayOutputStream;
1:166e695: import java.io.IOException;
1:f5ac375: import java.io.ObjectInputStream;
1:f5ac375: import java.io.ObjectOutputStream;
1:f5ac375: import java.lang.reflect.Field;
1:f5ac375: import java.lang.reflect.Modifier;
1:166e695: import java.security.AccessControlException;
1:1ae02c9: import java.security.AccessController;
1:281f903: import java.security.AllPermission;
1:166e695: import java.security.Permission;
1:281f903: import java.security.PermissionCollection;
1:281f903: import java.security.Permissions;
1:1ae02c9: import java.security.PrivilegedAction;
1:1ae02c9: import java.util.HashSet;
1:3c23476: import java.util.Arrays;
1:281f903: import java.util.Collections;
1:281f903: import java.util.HashMap;
1:f5ac375: import java.util.Locale;
1:1ae02c9: import java.util.Set;
1:166e695: import javax.security.auth.Subject;
1:1ae02c9: import junit.framework.Test;
1:c0052e0: import org.apache.derby.authentication.SystemPrincipal;
1:c0052e0: import org.apache.derby.iapi.error.StandardException;
1:1ae02c9: import org.apache.derby.iapi.util.IdUtil;
1:1ae02c9: import org.apache.derby.security.DatabasePermission;
1:1ae02c9: import org.apache.derby.security.SystemPermission;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:166e695: 
2:166e695: /**
1:166e695:  * This class tests the basic permission classes for system privileges.
1:166e695:  */
1:166e695: public class SystemPrivilegesPermissionTest extends BaseTestCase {
1:166e695: 
1:166e695:     /**
1:09c890c:      * The policy file name for the subject authorization tests.
1:166e695:      */
1:b32256d:     private static final String POLICY_FILE_NAME
1:166e695:         = "org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.policy";
1:166e695: 
1:166e695:     /**
1:09c890c:      * The policy file name for the DatabasePermission API test.
1:09c890c:      */
1:b32256d:     private static final String POLICY_FILE_NAME1
1:09c890c:         = "org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest1.policy";
1:09c890c: 
1:09c890c:     /**
1:166e695:      * Some directory paths for testing DatabasePermissions.
1:166e695:      */
1:166e695:     static private final String[] dirPaths = {
1:166e695:         "-",
1:166e695:         "*",
1:166e695:         "level0",
1:166e695:         "level0a",
1:166e695:         "level0/-",
1:166e695:         "level0/*",
1:166e695:         "level0/level1",
1:166e695:         "level0/level1/level2"
1:166e695:     };
1:166e695: 
1:166e695:     /**
1:166e695:      * Some relative directory paths for testing DatabasePermissions.
1:166e695:      */
1:166e695:     static private final String[] relDirPaths
1:166e695:         = new String[dirPaths.length];
1:166e695:     static {
1:166e695:         for (int i = 0; i < relDirPaths.length; i++) {
1:166e695:             relDirPaths[i] = "directory:" + dirPaths[i];
1:166e695:         }
1:166e695:     };
1:f5ac375: 
1:09c890c:     /**
1:166e695:      * Some relative directory path aliases for testing DatabasePermissions.
1:127ff35:      */
1:166e695:     static private final String[] relDirPathAliases
1:166e695:         = new String[dirPaths.length];
1:166e695:     static {
1:166e695:         for (int i = 0; i < relDirPaths.length; i++) {
1:166e695:             relDirPathAliases[i] = "directory:./" + dirPaths[i];
1:166e695:         }
1:166e695:     };
1:166e695: 
1:166e695:     /**
1:166e695:      * Some absolute directory paths for testing DatabasePermissions.
1:166e695:      */
1:166e695:     static private final String[] absDirPaths
1:166e695:         = new String[dirPaths.length];
1:166e695:     static {
1:166e695:         for (int i = 0; i < relDirPaths.length; i++) {
1:166e695:             absDirPaths[i] = "directory:/" + dirPaths[i];
1:166e695:         }
1:166e695:     };
1:166e695: 
1:166e695:     /**
1:166e695:      * Some absolute directory path aliases for testing DatabasePermissions.
1:166e695:      */
1:166e695:     static private final String[] absDirPathAliases
1:166e695:         = new String[dirPaths.length];
1:166e695:     static {
1:166e695:         for (int i = 0; i < relDirPaths.length; i++) {
1:166e695:             absDirPathAliases[i] = "directory:/dummy/../" + dirPaths[i];
1:166e695:         }
1:166e695:     };
1:166e695: 
1:166e695:     /**
1:166e695:      * The matrix defining which of the above directory paths imply each other.
1:166e695:      *
1:c0052e0:      * For instance, dirPathImpls[1][2] shows the expected value for:
1:166e695:      * <ul>
1:166e695:      * <li> DP("directory:*").implies(DP(directory:level0"))
1:166e695:      * <li> DP("directory:./*").implies(DP(directory:./level0"))
1:166e695:      * <li> DP("directory:/*").implies(DP(directory:/level0"))
1:166e695:      * <li> DP("directory:/dummy/..*").implies(DP(directory:/dummy/..level0"))
1:166e695:      * </ul>
1:166e695:      */
1:c0052e0:     static private final boolean[][] dirPathImpls = {
1:166e695:         { true, true, true, true, true, true, true, true }, 
1:166e695:         { false, true, true, true, false, false, false, false },
1:166e695:         { false, false, true, false, false, false, false, false },
1:166e695:         { false, false, false, true, false, false, false, false },
1:166e695:         { false, false, false, false, true, true, true, true },
1:166e695:         { false, false, false, false, false, true, true, false },
1:166e695:         { false, false, false, false, false, false, true, false },
1:166e695:         { false, false, false, false, false, false, false, true }
1:166e695:     };    
1:166e695: 
1:f5ac375:     /** The valid names of a SystemPermission. */
1:f5ac375:     private static final String[] VALID_SYSPERM_NAMES = {
1:f5ac375:         "server", "engine", "jmx"
1:f5ac375:     };
1:f5ac375: 
1:f5ac375:     /** The valid actions of a SystemPermission. */
1:f5ac375:     private static final String[] VALID_SYSPERM_ACTIONS = {
1:f5ac375:         "shutdown", "control", "monitor"
1:f5ac375:     };
1:f5ac375: 
1:166e695:     /**
1:166e695:      * Create a test with the given name.
1:166e695:      *
1:166e695:      * @param name name of the test
1:166e695:      */
1:166e695:     public SystemPrivilegesPermissionTest(String name) {
1:166e695:         super(name);
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Return a suite with all tests in this class (default suite)
1:166e695:      */
1:166e695:     public static Test suite() {
1:09c890c:         // this suite cannot be constructed with automatic test extraction
1:09c890c:         // (by passing a class argument); instead, the tests need to be added
1:09c890c:         // manually since some of them require their own policy file
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("SystemPrivilegesPermissionTest");
1:09c890c: 
1:09c890c:         // add API tests for the basic security framework classes
1:09c890c:         suite.addTest(
1:09c890c:             new SystemPrivilegesPermissionTest("testSystemPrincipal"));
1:09c890c:         suite.addTest(
1:09c890c:             new SystemPrivilegesPermissionTest("testSystemPermission"));
1:281f903:         suite.addTest(
1:281f903:             new SystemPrivilegesPermissionTest(
1:281f903:                     "testSystemPermissionCollections"));
1:281f903: 
1:09c890c:         // the DatabasePermission test attempts to canonicalize various
1:09c890c:         // directory path names and requires an all-files-read-permission,
1:09c890c:         // which is not granted by default derby_tests.policy
1:09c890c:         suite.addTest(new SecurityManagerSetup(
1:09c890c:             new SystemPrivilegesPermissionTest("testDatabasePermission"),
1:09c890c:             POLICY_FILE_NAME1));
1:09c890c: 
1:09c890c:         // add authorization tests for security permissions; requires
1:09c890c:         // class javax.security.auth.Subject, which is not available
1:09c890c:         // on all JVM platforms
1:09c890c:         if (SecurityManagerSetup.JVM_HAS_SUBJECT_AUTHORIZATION) {
1:ce9c46e:             suite.addTest(new SecurityManagerSetup(
1:09c890c:                 new SystemPrivilegesPermissionTest("policyTestSystemPermissionGrants"),
1:09c890c:                      POLICY_FILE_NAME));
1:09c890c:             suite.addTest(new SecurityManagerSetup(
1:09c890c:                 new SystemPrivilegesPermissionTest("policyTestDatabasePermissionGrants"),
1:09c890c:                      POLICY_FILE_NAME));
1:166e695:         }
1:09c890c: 
1:f5ac375:         // We need to manipulate private and final fields in order to test
1:f5ac375:         // deserialization of invalid objects. Disable the security manager
1:f5ac375:         // for this test case to allow that.
1:f5ac375:         suite.addTest(SecurityManagerSetup.noSecurityManager(
1:f5ac375:                 new SystemPrivilegesPermissionTest("testSerialization")));
1:f5ac375: 
1:ce9c46e:         return suite;
1:166e695:     }
1:09c890c: 
1:166e695:     /**
1:c0052e0:      * Tests SystemPrincipal.
1:166e695:      */
1:13b0113:     public void testSystemPrincipal() {
1:44ea8af:         // test a valid SystemPrincipal
1:44ea8af:         SystemPrincipal p = new SystemPrincipal("superuser");
1:44ea8af:         assertEquals("superuser", p.getName());
1:44ea8af: 
1:c0052e0:         // test SystemPrincipal with null name argument
1:127ff35:         try {
1:c0052e0:             new SystemPrincipal(null);
1:127ff35:             fail("expected NullPointerException");
1:127ff35:         } catch (NullPointerException ex) {
1:127ff35:             // expected exception
1:127ff35:         }
1:f5ac375: 
1:c0052e0:         // test SystemPrincipal with empty name argument
1:127ff35:         try {
1:c0052e0:             new SystemPrincipal("");
1:127ff35:             fail("expected IllegalArgumentException");
1:127ff35:         } catch (IllegalArgumentException ex) {
1:127ff35:             // expected exception
1:127ff35:         }
1:3c23476: 
1:f5ac375:         // DERBY-3476: The SystemPrincipal class should be final.
1:f5ac375:         assertTrue(Modifier.isFinal(SystemPrincipal.class.getModifiers()));
1:127ff35:     }
1:f5ac375:     
1:127ff35:     /**
1:166e695:      * Tests SystemPermission.
1:166e695:      */
1:13b0113:     public void testSystemPermission() {
1:166e695:         // test SystemPermission with null name argument
1:127ff35:         try {
1:5917694:             new SystemPermission(null, null);
1:166e695:             fail("expected NullPointerException");
1:166e695:         } catch (NullPointerException ex) {
1:127ff35:             // expected exception
1:127ff35:         }
1:127ff35: 
1:166e695:         // test SystemPermission with empty name argument
1:127ff35:         try {
1:5917694:             new SystemPermission("", null);
1:127ff35:             fail("expected IllegalArgumentException");
1:127ff35:         } catch (IllegalArgumentException ex) {
1:127ff35:             // expected exception
1:127ff35:         }
1:127ff35:         
1:166e695:         // test SystemPermission with illegal name argument
3:166e695:         try {
1:5917694:             new SystemPermission("illegal_name", null);
1:127ff35:             fail("expected IllegalArgumentException");
1:127ff35:         } catch (IllegalArgumentException ex) {
4:166e695:             // expected exception
1:166e695:         }
1:127ff35: 
1:f5ac375:         // actions cannot be null
1:f5ac375:         try {
1:f5ac375:             new SystemPermission("server", null);
1:f5ac375:             fail("expected NullPointerException");
1:f5ac375:         } catch (NullPointerException ex) {
1:f5ac375:             // expected exception
1:f5ac375:         }
1:f5ac375: 
1:f5ac375:         // Illegal and duplicate actions are ignored.
1:f5ac375:         assertEquals("", new SystemPermission("server", "").getActions());
1:f5ac375:         assertEquals("", new SystemPermission("server", ",,").getActions());
1:f5ac375:         assertEquals("",
1:f5ac375:                      new SystemPermission("server", "illegal_action")
1:f5ac375:                              .getActions());
1:f5ac375:         assertEquals("control",
1:f5ac375:                      new SystemPermission("server", "control,").getActions());
1:f5ac375:         assertEquals("control",
1:f5ac375:                      new SystemPermission("server", "control,illegal_action")
1:f5ac375:                              .getActions());
1:f5ac375:         assertEquals("control",
1:f5ac375:                      new SystemPermission("server", "control,control")
1:f5ac375:                              .getActions());
1:f5ac375:         assertEquals("control,monitor",
1:f5ac375:                      new SystemPermission("server", "control, monitor, control")
1:f5ac375:                              .getActions());
1:3c23476:         assertEquals("control,monitor",
1:3c23476:                      new SystemPermission("server", "monitor, control, monitor")
1:3c23476:                              .getActions());
1:f5ac375:         assertEquals("control",
1:f5ac375:                      new SystemPermission("server", "CoNtRoL")
1:f5ac375:                              .getActions());
1:f5ac375:         assertEquals("control",
1:f5ac375:                      new SystemPermission("server", "CoNtRoL,control")
1:f5ac375:                              .getActions());
1:f5ac375: 
1:356ff6f:         String[] validNames = {
1:356ff6f:             SystemPermission.ENGINE,
1:356ff6f:             SystemPermission.JMX,
1:356ff6f:             SystemPermission.SERVER
1:356ff6f:         };
1:127ff35:         
1:356ff6f:         // In order of the canonical actions expected
1:356ff6f:         String[] validActions = {
1:356ff6f:             SystemPermission.CONTROL,
1:356ff6f:             SystemPermission.MONITOR,
1:356ff6f:             SystemPermission.SHUTDOWN,
1:356ff6f:         };
1:127ff35:         
1:356ff6f:         // Check all valid combinations (which is all) with
1:356ff6f:         // a single action
1:356ff6f:         Permission[] all = new Permission[
1:356ff6f:                         validNames.length * validActions.length];
1:166e695:         
1:356ff6f:         int c = 0;
1:356ff6f:         for (int tn = 0; tn < validNames.length; tn++)
1:ce9c46e:         {
1:356ff6f:             for (int a = 0; a < validActions.length; a++) {
1:356ff6f:                 Permission p = new SystemPermission(
1:356ff6f:                         validNames[tn], validActions[a]);
1:166e695:                 
1:356ff6f:                 assertEquals(validNames[tn], p.getName());
1:356ff6f:                 assertEquals(validActions[a], p.getActions());
1:166e695:                 
1:166e695:                 // test SystemPermission.equals()
1:356ff6f:                 assertFalse(p.equals(null));
1:356ff6f:                 assertFalse(p.equals(new Object()));
1:166e695:                 
1:356ff6f:                 this.assertEquivalentPermissions(p, p);
1:166e695: 
1:356ff6f:                 all[c++] = p;
1:166e695:             }
1:166e695:         }
1:356ff6f:         // All the permissions are different.
1:356ff6f:         checkDistinctPermissions(all);
1:166e695:         
1:356ff6f:         // Check two actions
1:356ff6f:         for (int n = 0; n < validNames.length; n++)
1:356ff6f:         {
1:356ff6f:             for (int a = 0; a < validActions.length; a++)
1:356ff6f:             {
1:356ff6f:                 Permission base = new SystemPermission(
1:356ff6f:                         validNames[n], validActions[a]);
1:166e695:                 
1:356ff6f:                 // Two actions
1:356ff6f:                 for (int oa = 0; oa < validActions.length; oa++)
1:356ff6f:                 {
1:356ff6f:                     Permission p = new SystemPermission(
1:356ff6f:                             validNames[n],                           
1:356ff6f:                             validActions[a] + "," + validActions[oa]);
1:166e695:                     
1:356ff6f:                     if (oa == a)
1:356ff6f:                     {
1:356ff6f:                         // Same action added twice
1:356ff6f:                         assertEquivalentPermissions(base, p);
1:356ff6f:                         // Canonical form should collapse into a single action
1:356ff6f:                         assertEquals(validActions[a], p.getActions());
1:166e695:                     }
1:356ff6f:                     else
1:356ff6f:                     {
1:356ff6f:                         // Implies logic, the one with one permission
1:356ff6f:                         // is implied by the other but not vice-versa.
1:356ff6f:                         assertTrue(p.implies(base));
1:356ff6f:                         assertFalse(base.implies(p));
1:166e695:                         
1:356ff6f:                         // Names in canonical form
1:356ff6f:                         int f;
1:356ff6f:                         int s;
2:356ff6f:                         if (oa < a)
1:356ff6f:                         {
1:356ff6f:                             f = oa;
1:356ff6f:                             s = a;
1:166e695:                         }
1:356ff6f:                         else
1:356ff6f:                         {
1:356ff6f:                             f = a;
1:356ff6f:                             s = oa;
1:166e695:                         }
1:356ff6f:                         assertEquals(validActions[f] + "," + validActions[s],
1:356ff6f:                                 p.getActions());
1:166e695:                     }
1:ce9c46e:                 }
1:ce9c46e:             }
1:356ff6f:         }
1:166e695: 
1:f5ac375:         // DERBY-3476: The SystemPermission class should be final.
1:f5ac375:         assertTrue(Modifier.isFinal(SystemPermission.class.getModifiers()));
1:356ff6f:     }
1:281f903: 
1:281f903:     /**
1:281f903:      * Test that collections of SystemPermissions behave as expected.
1:281f903:      * Before DERBY-6717, adding multiple single-action permissions with
1:281f903:      * the same name didn't work.
1:281f903:      */
1:281f903:     public void testSystemPermissionCollections() {
1:281f903:         Permissions allPerms = new Permissions();
1:281f903:         for (String name : VALID_SYSPERM_NAMES) {
1:281f903:             for (String action : VALID_SYSPERM_ACTIONS) {
1:281f903:                 allPerms.add(new SystemPermission(name, action));
1:281f903:             }
1:281f903:         }
1:281f903: 
1:281f903:         assertEquals(VALID_SYSPERM_NAMES.length,
1:281f903:                      Collections.list(allPerms.elements()).size());
1:281f903: 
1:281f903:         // Check that the collection of all system permissions also implies
1:281f903:         // all system permissions.
1:281f903:         for (String name : VALID_SYSPERM_NAMES) {
1:281f903:             for (String a1 : VALID_SYSPERM_ACTIONS) {
1:281f903:                 // allPerms should imply any valid (name, action) pair.
1:281f903:                 assertTrue(allPerms.implies(new SystemPermission(name, a1)));
1:281f903: 
1:281f903:                 // allPerms should also imply any valid multi-action
1:281f903:                 // system permission.
1:281f903:                 for (String a2 : VALID_SYSPERM_ACTIONS) {
1:281f903:                     assertTrue(allPerms.implies(
1:281f903:                             new SystemPermission(name, a1 + ',' + a2)));
1:281f903:                 }
1:281f903:             }
1:281f903:         }
1:281f903: 
1:d09cda8:         Permissions onePerm = new Permissions();
1:d09cda8:         onePerm.add(new SystemPermission("server", "shutdown"));
1:d09cda8: 
1:d09cda8:         // onePerm implies server shutdown and nothing else
1:d09cda8:         assertTrue(onePerm.implies(new SystemPermission("server", "shutdown")));
1:d09cda8:         assertFalse(onePerm.implies(
1:d09cda8:                         new SystemPermission("engine", "shutdown")));
1:d09cda8:         assertFalse(onePerm.implies(
1:d09cda8:                         new SystemPermission("server", "shutdown,monitor")));
1:d09cda8: 
1:281f903:         Permissions somePerms = new Permissions();
1:281f903:         somePerms.add(new SystemPermission("server", "shutdown"));
1:281f903:         somePerms.add(new SystemPermission("jmx", "shutdown,monitor"));
1:281f903:         somePerms.add(new SystemPermission("engine", "shutdown,control"));
1:281f903:         somePerms.add(new SystemPermission("engine", "control,monitor"));
1:281f903: 
1:281f903:         // somePerms implies the shutdown action for server
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("server", "shutdown")));
1:281f903:         assertFalse(somePerms.implies(
1:281f903:                 new SystemPermission("server", "control")));
1:281f903:         assertFalse(somePerms.implies(
1:281f903:                 new SystemPermission("server", "monitor")));
1:281f903:         assertFalse(somePerms.implies(
1:281f903:                 new SystemPermission("server", "shutdown,monitor")));
1:281f903: 
1:281f903:         // somePerms implies the shutdown and monitor actions for jmx
1:281f903:         assertTrue(somePerms.implies(new SystemPermission("jmx", "shutdown")));
1:281f903:         assertTrue(somePerms.implies(new SystemPermission("jmx", "monitor")));
1:281f903:         assertFalse(somePerms.implies(new SystemPermission("jmx", "control")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("jmx", "shutdown,monitor")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("jmx", "monitor,shutdown")));
1:281f903:         assertFalse(somePerms.implies(
1:281f903:                 new SystemPermission("jmx", "monitor,shutdown,control")));
1:281f903: 
1:281f903:         // somePerms implies shutdown, control and monitor for engine
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("engine", "shutdown")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("engine", "control")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("engine", "monitor")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("engine", "shutdown,monitor")));
1:281f903:         assertTrue(somePerms.implies(
1:281f903:                 new SystemPermission("engine", "shutdown,monitor,control")));
1:281f903: 
1:281f903:         // A SystemPermission collection should not accept other permissions.
1:281f903:         SystemPermission sp = new SystemPermission("engine", "monitor");
1:281f903:         PermissionCollection collection = sp.newPermissionCollection();
1:281f903:         try {
1:281f903:             collection.add(new AllPermission());
1:281f903:             fail();
1:281f903:         } catch (IllegalArgumentException iae) {
1:281f903:             // expected
1:281f903:         }
1:281f903: 
1:281f903:         // Read-only collections cannot be added to.
1:281f903:         collection.setReadOnly();
1:281f903:         try {
1:281f903:             collection.add(sp);
1:281f903:             fail();
1:281f903:         } catch (SecurityException se) {
1:281f903:             // expected
1:281f903:         }
1:d09cda8: 
1:d09cda8:         // The collection does not imply other permission types.
1:d09cda8:         assertFalse(collection.implies(new AllPermission()));
1:281f903:     }
1:166e695:     
1:166e695:     /**
1:09c890c:      * Tests SystemPermissions against the Policy.
1:09c890c:      */
1:09c890c:     public void policyTestSystemPermissionGrants() {
1:09c890c:         final Permission shutdown
1:09c890c:             = new SystemPermission(
1:356ff6f:                 SystemPermission.SERVER,
1:356ff6f:                 SystemPermission.SHUTDOWN);
1:166e695:         
1:09c890c:         // test SystemPermission for authorized user
1:c0052e0:         final SystemPrincipal authorizedUser
1:c0052e0:             = new SystemPrincipal("authorizedSystemUser");
1:356ff6f:         execute(authorizedUser, new ShutdownAction(shutdown), true);
1:166e695:         
1:09c890c:         // test SystemPermission for unauthorized user
1:c0052e0:         final SystemPrincipal unAuthorizedUser
1:c0052e0:             = new SystemPrincipal("unAuthorizedSystemUser");
1:356ff6f:         execute(unAuthorizedUser, new ShutdownAction(shutdown), false);
1:356ff6f:     }
1:166e695:     
1:166e695:     /**
1:166e695:      * Tests DatabasePermission.
1:09c890c:      */   
1:09c890c:     public void testDatabasePermission() throws IOException {
1:166e695:         // test DatabasePermission with null url
1:166e695:         try {
1:166e695:             new DatabasePermission(null, DatabasePermission.CREATE);
1:166e695:             fail("expected NullPointerException");
1:166e695:         } catch (NullPointerException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695: 
1:166e695:         // test DatabasePermission with empty url
1:166e695:         try {
1:166e695:             new DatabasePermission("", DatabasePermission.CREATE);
3:166e695:             fail("expected IllegalArgumentException");
3:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695:         
1:166e695:         // test DatabasePermission with illegal url
1:166e695:         try {
1:166e695:             new DatabasePermission("no_url", DatabasePermission.CREATE);
1:166e695:             fail("expected IllegalArgumentException");
1:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695: 
1:3c23476:         // test DatabasePermission with unsupported protocol
1:3c23476:         try {
1:3c23476:             new DatabasePermission("unknown:test", DatabasePermission.CREATE);
1:3c23476:             fail("expected IllegalArgumentException");
1:3c23476:         } catch (IllegalArgumentException ex) {
1:3c23476:             // expected exception
1:3c23476:         }
1:3c23476: 
1:c0052e0:         // this test's commented out because it's platform-dependent
1:c0052e0:         // (no reliable way to make it pass on Unix)
1:166e695:         // test DatabasePermission with non-canonicalizable URL
1:c0052e0:         //try {
1:c0052e0:         //    //new DatabasePermission("directory:.*/\\:///../",
1:c0052e0:         //    //                       DatabasePermission.CREATE);
1:c0052e0:         //    new DatabasePermission("directory:\n/../../../.*/\\:///../",
1:c0052e0:         //                           DatabasePermission.CREATE);
1:c0052e0:         //    fail("expected IOException");
1:c0052e0:         //} catch (IOException ex) {
1:c0052e0:         //    // expected exception
1:c0052e0:         //}
1:09c890c: 
1:166e695:         // test DatabasePermission with null actions
1:166e695:         try {
1:166e695:             new DatabasePermission("directory:dir", null);
1:166e695:             fail("expected NullPointerException");
1:166e695:         } catch (NullPointerException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695: 
1:166e695:         // test DatabasePermission with empty actions
1:166e695:         try {
1:166e695:             new DatabasePermission("directory:dir", "");
1:166e695:             fail("expected IllegalArgumentException");
1:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695:         
1:3c23476:         // test DatabasePermission with illegal action list
1:3c23476:         try {
1:166e695:             new DatabasePermission("directory:dir", "illegal_action");
1:166e695:             fail("expected IllegalArgumentException");
1:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695: 
1:3c23476:         // test DatabasePermission with illegal action list
1:3c23476:         try {
1:166e695:             new DatabasePermission("directory:dir", "illegal,action");
1:166e695:             fail("expected IllegalArgumentException");
1:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695:     
1:166e695:         // test DatabasePermission with illegal action list
1:166e695:         try {
1:3c23476:             new DatabasePermission("directory:dir", "illegal,create,action");
1:3c23476:             fail("expected IllegalArgumentException");
1:3c23476:         } catch (IllegalArgumentException ex) {
1:3c23476:             // expected exception
1:3c23476:         }
1:3c23476: 
1:166e695:         // test DatabasePermission on illegal action list
1:166e695:         try {
1:166e695:             new DatabasePermission("directory:dir", "illegal;action");
1:166e695:             fail("expected IllegalArgumentException");
1:166e695:         } catch (IllegalArgumentException ex) {
1:166e695:             // expected exception
1:166e695:         }
1:166e695: 
1:166e695:         // test DatabasePermission with illegal action list
1:166e695:         try {
1:3c23476:             new DatabasePermission("directory:dir", ",");
1:3c23476:             fail("expected IllegalArgumentException");
1:3c23476:         } catch (IllegalArgumentException ex) {
1:3c23476:             // expected exception
1:3c23476:         }
1:3c23476: 
1:3c23476:         // test DatabasePermission with illegal action list
1:3c23476:         try {
1:3c23476:             new DatabasePermission("directory:dir", " ");
1:3c23476:             fail("expected IllegalArgumentException");
1:3c23476:         } catch (IllegalArgumentException ex) {
1:3c23476:             // expected exception
1:3c23476:         }
1:3c23476: 
1:3c23476:         // test DatabasePermission with illegal action list
1:3c23476:         try {
1:3c23476:             new DatabasePermission("directory:dir", "create,");
1:3c23476:             fail("expected IllegalArgumentException");
1:3c23476:         } catch (IllegalArgumentException ex) {
1:3c23476:             // expected exception
1:3c23476:         }
1:3c23476: 
1:166e695:         // test DatabasePermission on relative directory paths
1:c0052e0:         final DatabasePermission[] relDirPathPerms
1:166e695:             = new DatabasePermission[relDirPaths.length];
1:166e695:         for (int i = 0; i < relDirPaths.length; i++) {
1:c0052e0:             relDirPathPerms[i]
1:166e695:                 = new DatabasePermission(relDirPaths[i],
2:166e695:                                          DatabasePermission.CREATE);
1:166e695:         }
1:c0052e0:         checkNameAndActions(relDirPathPerms, relDirPaths);
1:c0052e0:         checkHashCodeAndEquals(relDirPathPerms, relDirPathPerms);
1:c0052e0:         checkImplies(relDirPathPerms, relDirPathPerms, dirPathImpls);
1:166e695: 
1:166e695:         // test DatabasePermission on relative directory path aliases
1:c0052e0:         final DatabasePermission[] relDirPathAliasPerms
1:166e695:             = new DatabasePermission[relDirPathAliases.length];
1:166e695:         for (int i = 0; i < relDirPathAliases.length; i++) {
1:c0052e0:             relDirPathAliasPerms[i]
1:166e695:                 = new DatabasePermission(relDirPathAliases[i],
1:166e695:                                          DatabasePermission.CREATE);
1:166e695:         }
1:c0052e0:         checkNameAndActions(relDirPathAliasPerms, relDirPathAliases);
1:c0052e0:         checkHashCodeAndEquals(relDirPathPerms, relDirPathAliasPerms);
1:c0052e0:         checkImplies(relDirPathPerms, relDirPathAliasPerms, dirPathImpls);
1:c0052e0:         checkImplies(relDirPathAliasPerms, relDirPathPerms, dirPathImpls);
1:166e695: 
1:166e695:         // test DatabasePermission on absolute directory paths
1:c0052e0:         final DatabasePermission[] absDirPathPerms
1:166e695:             = new DatabasePermission[absDirPaths.length];
1:166e695:         for (int i = 0; i < absDirPaths.length; i++) {
1:c0052e0:             absDirPathPerms[i]
1:166e695:                 = new DatabasePermission(absDirPaths[i],
1:166e695:                                          DatabasePermission.CREATE);
1:166e695:         }
1:c0052e0:         checkNameAndActions(absDirPathPerms, absDirPaths);
1:c0052e0:         checkHashCodeAndEquals(absDirPathPerms, absDirPathPerms);
1:c0052e0:         checkImplies(absDirPathPerms, absDirPathPerms, dirPathImpls);
1:166e695: 
1:166e695:         // test DatabasePermission on absolute directory path aliases
1:c0052e0:         final DatabasePermission[] absDirPathAliasPerms
1:166e695:             = new DatabasePermission[absDirPathAliases.length];
1:166e695:         for (int i = 0; i < absDirPathAliases.length; i++) {
1:c0052e0:             absDirPathAliasPerms[i]
1:166e695:                 = new DatabasePermission(absDirPathAliases[i],
1:166e695:                                          DatabasePermission.CREATE);
1:166e695:         }
1:c0052e0:         checkNameAndActions(absDirPathAliasPerms, absDirPathAliases);
1:c0052e0:         checkHashCodeAndEquals(absDirPathPerms, absDirPathAliasPerms);
1:c0052e0:         checkImplies(absDirPathPerms, absDirPathAliasPerms, dirPathImpls);
1:c0052e0:         checkImplies(absDirPathAliasPerms, absDirPathPerms, dirPathImpls);
1:166e695:         
1:c0052e0:         // test DatabasePermission for the inclusive path specification
1:c0052e0:         final String inclPermissionUrl = "directory:<<ALL FILES>>";
1:c0052e0:         final DatabasePermission[] inclPerms
1:c0052e0:             = { new DatabasePermission(inclPermissionUrl,
1:c0052e0:                                        DatabasePermission.CREATE) };
1:c0052e0:         checkNameAndActions(inclPerms,
1:c0052e0:                             new String[]{ inclPermissionUrl });
1:c0052e0:         final DatabasePermission[] inclPerms1
1:c0052e0:             = { new DatabasePermission(inclPermissionUrl,
1:c0052e0:                                        DatabasePermission.CREATE) };
1:c0052e0:         checkHashCodeAndEquals(inclPerms, inclPerms1);
1:c0052e0:         checkImplies(inclPerms, inclPerms1, new boolean[][]{ { true } });
1:c0052e0:         final boolean[][] allTrue = new boolean[1][dirPaths.length];
1:c0052e0:         for (int j = 0; j < dirPaths.length; j++) {
1:c0052e0:             allTrue[0][j] = true;
1:356ff6f:         }
1:c0052e0:         final boolean[][] allFalse = new boolean[dirPaths.length][1];
1:c0052e0:         for (int i = 0; i < dirPaths.length; i++) {
1:c0052e0:             allFalse[i][0] = false;
1:356ff6f:         }
1:c0052e0:         checkImplies(inclPerms, relDirPathPerms, allTrue);
1:c0052e0:         checkImplies(relDirPathPerms, inclPerms, allFalse);
1:c0052e0:         checkImplies(inclPerms, relDirPathAliasPerms, allTrue);
1:c0052e0:         checkImplies(relDirPathAliasPerms, inclPerms, allFalse);
1:c0052e0:         checkImplies(inclPerms, absDirPathPerms, allTrue);
1:c0052e0:         checkImplies(absDirPathPerms, inclPerms, allFalse);
1:c0052e0:         checkImplies(inclPerms, absDirPathAliasPerms, allTrue);
1:c0052e0:         checkImplies(absDirPathAliasPerms, inclPerms, allFalse);
1:f5ac375: 
1:3c23476:         // Actions string is washed (lower-cased, trimmed) and duplicates
1:3c23476:         // are removed.
1:3c23476:         DatabasePermission perm =
1:3c23476:                 new DatabasePermission("directory:dir", "create, create");
1:3c23476:         assertEquals("create", perm.getActions());
1:3c23476:         perm = new DatabasePermission("directory:dir", "  CrEaTe  ");
1:3c23476:         assertEquals("create", perm.getActions());
1:3c23476: 
1:f5ac375:         // DERBY-3476: The DatabasePermission class should be final.
1:f5ac375:         assertTrue(Modifier.isFinal(DatabasePermission.class.getModifiers()));
1:09c890c:     }
1:09c890c: 
1:09c890c:     /**
1:09c890c:      * Tests DatabasePermissions against the Policy.
1:09c890c:      */
1:09c890c:     public void policyTestDatabasePermissionGrants() throws IOException {
1:09c890c:         final DatabasePermission[] relDirPathPerms
1:09c890c:             = new DatabasePermission[relDirPaths.length];
1:09c890c:         for (int i = 0; i < relDirPaths.length; i++) {
1:09c890c:             relDirPathPerms[i]
1:09c890c:                 = new DatabasePermission(relDirPaths[i],
1:09c890c:                                          DatabasePermission.CREATE);
1:09c890c:         }
1:166e695: 
1:c0052e0:         // test DatabasePermission for unauthorized, authorized, and
1:09c890c:         // all-authorized users
1:c0052e0:         final int[] singleLocPaths = { 2, 3, 6, 7 };
1:c0052e0:         final SystemPrincipal authorizedUser
1:c0052e0:             = new SystemPrincipal("authorizedSystemUser");
1:c0052e0:         final SystemPrincipal unAuthorizedUser
1:c0052e0:             = new SystemPrincipal("unAuthorizedSystemUser");
1:c0052e0:         final SystemPrincipal superUser
1:c0052e0:             = new SystemPrincipal("superUser");
1:c0052e0:         for (int i = 0; i < singleLocPaths.length; i++) {
1:c0052e0:             final int j = singleLocPaths[i];
4:166e695:             execute(unAuthorizedUser,
1:c0052e0:                     new CreateDatabaseAction(relDirPathPerms[j]), false);
4:166e695:             execute(authorizedUser,
1:c0052e0:                     new CreateDatabaseAction(relDirPathPerms[j]), (j != 6));
1:c0052e0:             execute(superUser,
1:c0052e0:                     new CreateDatabaseAction(relDirPathPerms[j]), true);
1:166e695:         }
1:127ff35: 
1:09c890c:         // test DatabasePermission for any user
1:c0052e0:         final SystemPrincipal anyUser
1:c0052e0:             = new SystemPrincipal("anyUser");
1:127ff35:         final DatabasePermission dbPerm
1:127ff35:             = new DatabasePermission("directory:dir",
1:127ff35:                                      DatabasePermission.CREATE);
1:127ff35:         execute(anyUser,
1:127ff35:                 new CreateDatabaseAction(dbPerm), true);
1:356ff6f:     }
1:166e695: 
1:166e695:     /**
1:f5ac375:      * Test serialization of permissions. In particular, test that
1:f5ac375:      * deserialization of invalid objects fails.
1:f5ac375:      */
1:f5ac375:     public void testSerialization() throws IOException {
1:3c23476:         testDatabasePermissionSerialization();
1:3c23476:         testSystemPermissionSerialization();
1:44ea8af:         testSystemPrincipalSerialization();
1:3c23476:     }
1:f5ac375: 
1:3c23476:     /**
1:3c23476:      * Test serialization and deserialization of DatabasePermission objects.
1:3c23476:      */
1:3c23476:     private void testDatabasePermissionSerialization() throws IOException {
1:3c23476:         // Simple test of serialization/deserialization of a valid object
1:3c23476:         DatabasePermission perm =
1:3c23476:                 new DatabasePermission("directory:dir", "create");
1:3c23476:         assertEquals(perm, serializeDeserialize(perm, null));
1:3c23476: 
1:3c23476:         // Test of relative paths
1:3c23476:         for (String url : relDirPaths) {
1:3c23476:             perm = new DatabasePermission(url, "create");
1:3c23476:             assertEquals(perm, serializeDeserialize(perm, null));
1:3c23476:         }
1:3c23476: 
1:3c23476:         // Test of relative path aliases
1:3c23476:         for (String url : relDirPathAliases) {
1:3c23476:             perm = new DatabasePermission(url, "create");
1:3c23476:             assertEquals(perm, serializeDeserialize(perm, null));
1:3c23476:         }
1:3c23476: 
1:3c23476:         // Test of absolute paths
1:3c23476:         for (String url : absDirPaths) {
1:3c23476:             perm = new DatabasePermission(url, "create");
1:3c23476:             assertEquals(perm, serializeDeserialize(perm, null));
1:3c23476:         }
1:3c23476: 
1:3c23476:         // Test of absolute path aliases
1:3c23476:         for (String url : absDirPathAliases) {
1:3c23476:             perm = new DatabasePermission(url, "create");
1:3c23476:             assertEquals(perm, serializeDeserialize(perm, null));
1:3c23476:         }
1:3c23476: 
1:3c23476:         // Actions should be normalized when read from the stream.
1:3c23476:         for (String actions :
1:3c23476:                 Arrays.asList("create", "CrEaTe", " create ,  create")) {
1:3c23476:             perm = serializeDeserialize(
1:3c23476:                     createDBPermNoCheck("directory:dir", actions),
1:3c23476:                     null);
1:3c23476:             assertEquals("create", perm.getActions());
1:3c23476:         }
1:3c23476: 
1:3c23476:         // Null URL should fail on deserialization (didn't before DERBY-3476)
1:3c23476:         perm = createDBPermNoCheck(null, "create");
1:3c23476:         serializeDeserialize(perm, NullPointerException.class);
1:3c23476: 
1:3c23476:         // Empty URL should fail on deserialization (didn't before DERBY-3476)
1:3c23476:         perm = createDBPermNoCheck("", "create");
1:3c23476:         serializeDeserialize(perm, IllegalArgumentException.class);
1:3c23476: 
1:3c23476:         // Unsupported protocol should fail on deserialization (didn't before
1:3c23476:         // DERBY-3476)
1:3c23476:         perm = createDBPermNoCheck("unknown:test", "create");
1:3c23476:         serializeDeserialize(perm, IllegalArgumentException.class);
1:3c23476: 
1:3c23476:         // Null actions should fail on deserialization
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", null),
1:3c23476:                              NullPointerException.class);
1:3c23476: 
1:3c23476:         // Empty and invalid actions should fail on deserialization
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", ""),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", " "),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", ","),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", "create,"),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir", "invalid"),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:         serializeDeserialize(createDBPermNoCheck("directory:dir",
1:3c23476:                                                  "create,invalid"),
1:3c23476:                              IllegalArgumentException.class);
1:3c23476:     }
1:3c23476: 
1:3c23476:     /**
1:3c23476:      * Test serialization and deserialization of SystemPermission objects.
1:3c23476:      */
1:3c23476:     private void testSystemPermissionSerialization() throws IOException {
1:f5ac375:         // Test all valid name/action combinations. All should succeed to
1:f5ac375:         // serialize and deserialize.
1:f5ac375:         for (String name : VALID_SYSPERM_NAMES) {
1:f5ac375:             for (String action : VALID_SYSPERM_ACTIONS) {
1:f5ac375:                 // Actions are case-insensitive, so test both lower-case
1:f5ac375:                 // and upper-case.
1:f5ac375:                 SystemPermission pl =
1:f5ac375:                     new SystemPermission(name, action.toLowerCase(Locale.US));
1:f5ac375:                 SystemPermission pu =
1:f5ac375:                     new SystemPermission(name, action.toUpperCase(Locale.US));
1:f5ac375:                 assertEquals(pl, serializeDeserialize(pl, null));
1:f5ac375:                 assertEquals(pu, serializeDeserialize(pu, null));
1:f5ac375:             }
1:f5ac375:         }
1:f5ac375: 
1:f5ac375:         // A permission can specify multiple actions ...
1:f5ac375:         SystemPermission sp = new SystemPermission(
1:f5ac375:                 "server", "control,monitor,shutdown");
1:f5ac375:         assertEquals(sp, serializeDeserialize(sp, null));
1:f5ac375: 
1:f5ac375:         // ... but only a single name, so this should fail.
1:f5ac375:         // (Did not fail before DERBY-3476.)
1:f5ac375:         serializeDeserialize(
1:f5ac375:                 createSyspermNoCheck("server,jmx", "control"),
1:f5ac375:                 IllegalArgumentException.class);
1:f5ac375: 
1:f5ac375:         // Invalid and duplicate actions should be ignored.
1:f5ac375:         sp = serializeDeserialize(createSyspermNoCheck(
1:f5ac375:                     VALID_SYSPERM_NAMES[0],
1:f5ac375:                     "control,invalid,control,,shutdown"),
1:f5ac375:                 null);
1:f5ac375:         // The next assert failed before DERBY-3476.
1:f5ac375:         assertEquals("control,shutdown", sp.getActions());
1:f5ac375: 
1:f5ac375:         // Empty action is allowed.
1:f5ac375:         sp = new SystemPermission(VALID_SYSPERM_NAMES[0], "");
1:f5ac375:         assertEquals(sp, serializeDeserialize(sp, null));
1:f5ac375: 
1:f5ac375:         // Name is case-sensitive, so this should fail.
1:f5ac375:         // (Did not fail before DERBY-3476.)
1:f5ac375:         serializeDeserialize(createSyspermNoCheck(
1:f5ac375:                 VALID_SYSPERM_NAMES[0].toUpperCase(Locale.US),
1:f5ac375:                 VALID_SYSPERM_ACTIONS[0]),
1:f5ac375:             IllegalArgumentException.class);
1:f5ac375: 
1:f5ac375:         // Empty name is not allowed.
1:f5ac375:         serializeDeserialize(createSyspermNoCheck(
1:f5ac375:                 "",
1:f5ac375:                 VALID_SYSPERM_ACTIONS[0]),
1:f5ac375:                 IllegalArgumentException.class);
1:f5ac375: 
1:f5ac375:         // Null name is not allowed.
1:f5ac375:         serializeDeserialize(createSyspermNoCheck(
1:f5ac375:                 null,
1:f5ac375:                 VALID_SYSPERM_ACTIONS[0]),
1:f5ac375:             NullPointerException.class);
1:f5ac375: 
1:f5ac375:         // Null action is not allowed.
1:f5ac375:         // (Did not fail before DERBY-3476.)
1:f5ac375:         serializeDeserialize(createSyspermNoCheck(
1:f5ac375:                 VALID_SYSPERM_NAMES[0],
1:f5ac375:                 null),
1:f5ac375:             NullPointerException.class);
1:281f903: 
1:281f903:         // Test serialization of SystemPermission collections.
1:281f903: 
1:281f903:         // Serialization should work on empty collection.
1:281f903:         PermissionCollection collection = sp.newPermissionCollection();
1:281f903:         PermissionCollection readCollection =
1:281f903:                 serializeDeserialize(collection, null);
1:281f903:         assertFalse(readCollection.elements().hasMoreElements());
1:281f903: 
1:281f903:         // Serialization should work on non-empty collection.
1:281f903:         sp = new SystemPermission(
1:281f903:                 VALID_SYSPERM_NAMES[0], VALID_SYSPERM_ACTIONS[0]);
1:281f903:         collection = sp.newPermissionCollection();
1:281f903:         collection.add(sp);
1:281f903:         readCollection = serializeDeserialize(collection, null);
1:281f903:         assertEquals(Arrays.asList(sp),
1:281f903:                      Collections.list(readCollection.elements()));
1:281f903: 
1:281f903:         // Deserialization should fail if the collection contains a
1:281f903:         // permission with invalid name.
1:281f903:         collection.add(createSyspermNoCheck("invalid_name", "control"));
1:281f903:         serializeDeserialize(collection, IllegalArgumentException.class);
1:281f903: 
1:281f903:         // Deserialization should fail if the collection contains a
1:281f903:         // permission that is not a SystemPermission.
1:281f903:         collection = sp.newPermissionCollection();
1:281f903:         HashMap<String, Permission> permissions =
1:281f903:                 new HashMap<String, Permission>();
1:281f903:         permissions.put("engine", new AllPermission());
1:281f903:         setField(collection.getClass(), "permissions", collection, permissions);
1:281f903:         serializeDeserialize(collection, ClassCastException.class);
1:f5ac375:     }
1:f5ac375: 
1:f5ac375:     /**
1:44ea8af:      * Test serialization of SystemPrincipal objects.
1:44ea8af:      */
1:44ea8af:     private void testSystemPrincipalSerialization() throws IOException {
1:44ea8af:         // Serialize and deserialize a valid object.
1:44ea8af:         SystemPrincipal p = new SystemPrincipal("superuser");
1:44ea8af:         assertEquals(p, serializeDeserialize(p, null));
1:44ea8af: 
1:44ea8af:         // Deserialize a SystemPrincipal whose name is null. Should fail.
1:44ea8af:         setField(SystemPrincipal.class, "name", p, null);
1:44ea8af:         serializeDeserialize(p, NullPointerException.class);
1:44ea8af: 
1:44ea8af:         // Deserialize a SystemPrincipal whose name is empty. Should fail.
1:44ea8af:         setField(SystemPrincipal.class, "name", p, "");
1:44ea8af:         serializeDeserialize(p, IllegalArgumentException.class);
1:44ea8af:     }
1:44ea8af: 
1:44ea8af:     /**
1:3c23476:      * Create a DatabasePermission object without checking that the URL
1:3c23476:      * and the actions are valid.
1:3c23476:      *
1:3c23476:      * @param url the URL of the permission
1:3c23476:      * @param actions the actions of the permission
1:3c23476:      * @return a DatabasePermission instance
1:3c23476:      */
1:3c23476:     private static DatabasePermission createDBPermNoCheck(
1:3c23476:             String url, String actions) throws IOException {
1:3c23476:         // First create a valid permission object, so that the checks in
1:3c23476:         // the constructor are happy.
1:3c23476:         DatabasePermission perm =
1:3c23476:                 new DatabasePermission("directory:dir", "create");
1:3c23476: 
1:3c23476:         // Then use reflection to override the values of the fields with
1:3c23476:         // potentially invalid values.
1:3c23476:         setField(Permission.class, "name", perm, url);
1:3c23476:         setField(DatabasePermission.class, "actions", perm, actions);
1:3c23476: 
1:3c23476:         return perm;
1:3c23476:     }
1:3c23476: 
1:3c23476:     /**
1:f5ac375:      * Create a new SystemPermission object without checking that the name
1:f5ac375:      * and actions are valid.
1:f5ac375:      *
1:f5ac375:      * @param name the name of the permission
1:f5ac375:      * @param actions the actions of the permission
1:f5ac375:      * @return a SystemPermission instance
1:f5ac375:      */
1:f5ac375:     private static SystemPermission
1:f5ac375:                         createSyspermNoCheck(String name, String actions) {
1:f5ac375:         // First create a valid permission object, so that the checks in
1:f5ac375:         // the constructor are happy.
1:f5ac375:         SystemPermission sysperm = new SystemPermission("server", "control");
1:f5ac375: 
1:f5ac375:         // Then use reflection to override the values of the fields with
1:f5ac375:         // potentially invalid values.
1:f5ac375:         setField(Permission.class, "name", sysperm, name);
1:f5ac375:         setField(SystemPermission.class, "actions", sysperm, actions);
1:f5ac375: 
1:f5ac375:         return sysperm;
1:f5ac375:     }
1:f5ac375: 
1:f5ac375:     /**
1:f5ac375:      * Forcefully set the value of a field, ignoring access checks such as
1:f5ac375:      * final and private.
1:f5ac375:      *
1:f5ac375:      * @param klass the class in which the field lives
1:f5ac375:      * @param name the name of the field
1:f5ac375:      * @param object the object to change
1:f5ac375:      * @param value the new value of the field
1:f5ac375:      */
1:f5ac375:     private static void setField(
1:f5ac375:             Class<?> klass, String name, Object object, Object value) {
1:f5ac375:         try {
1:f5ac375:             Field f = klass.getDeclaredField(name);
1:f5ac375:             f.setAccessible(true);
1:f5ac375:             f.set(object, value);
1:f5ac375:         } catch (NoSuchFieldException ex) {
1:f5ac375:             fail("Cannot find field " + name, ex);
1:f5ac375:         } catch (IllegalAccessException ex) {
1:f5ac375:             fail("Cannot access field " + name, ex);
1:f5ac375:         }
1:f5ac375:     }
1:f5ac375: 
1:f5ac375:     /**
1:f5ac375:      * Serialize an object, then deserialize it from where it's stored, and
1:f5ac375:      * finally return the deserialized object.
1:f5ac375:      *
1:f5ac375:      * @param <T> the type of the object being serialized
1:f5ac375:      * @param object the object to serialize
1:f5ac375:      * @param expectedException the type of exception being expected during
1:f5ac375:      *   deserialization, or {@code null} if deserialization is expected to
1:f5ac375:      *   be successful
1:f5ac375:      * @return the deserialized object, or {@code null} if deserialization
1:f5ac375:      *   failed as expected
1:f5ac375:      * @throws IOException if an I/O error occurred
1:f5ac375:      */
1:f5ac375:     // We actually do check the type before we cast the result to T, but the
1:f5ac375:     // compiler doesn't understand it because we're using a JUnit assert.
1:f5ac375:     // Ignore the warning.
1:f5ac375:     @SuppressWarnings("unchecked")
1:f5ac375:     private static <T> T serializeDeserialize(
1:f5ac375:                 T object,
1:f5ac375:                 Class<? extends Exception> expectedException)
1:f5ac375:             throws IOException {
1:f5ac375:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:f5ac375:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:f5ac375:         oos.writeObject(object);
1:f5ac375:         oos.close();
1:f5ac375: 
1:f5ac375:         ObjectInputStream ois = new ObjectInputStream(
1:f5ac375:                 new ByteArrayInputStream(baos.toByteArray()));
1:f5ac375:         try {
1:f5ac375:             Object deserialized = ois.readObject();
1:f5ac375:             assertNull("should have failed", expectedException);
1:f5ac375:             assertEquals(object.getClass(), deserialized.getClass());
1:f5ac375:             // This generates a compile-time warning because the compiler
1:f5ac375:             // doesn't understand that the deserialized object has to be of
1:f5ac375:             // the correct type when the above assert succeeds. Because of
1:f5ac375:             // this, "unchecked" warnings are suppressed in this method.
1:f5ac375:             return (T) deserialized;
1:f5ac375:         } catch (Exception e) {
1:f5ac375:             if (expectedException == null ||
1:f5ac375:                     !expectedException.isAssignableFrom(e.getClass())) {
1:f5ac375:                 fail("unexpected exception", e);
1:f5ac375:             }
1:f5ac375:             return null;
1:f5ac375:         } finally {
1:f5ac375:             ois.close();
1:f5ac375:         }
1:f5ac375:     }
1:f5ac375: 
1:f5ac375:     /**
1:c0052e0:      * Runs a privileged user action for a given principal.
1:166e695:      */
1:3f5c48a:     private <T> void execute(SystemPrincipal principal,
1:3f5c48a:                          PrivilegedAction<T> action,
1:166e695:                          boolean isGrantExpected) {
1:c0052e0:         //println();
1:c0052e0:         //println("    testing action " + action);
1:166e695:         
1:3f5c48a:         final RunAsPrivilegedUserAction<T> runAsPrivilegedUserAction
1:3f5c48a:             = new RunAsPrivilegedUserAction<T>(principal, action);
1:166e695:         try {
1:166e695:             AccessController.doPrivileged(runAsPrivilegedUserAction);
1:c0052e0:             //println("    Congrats! access granted " + action);
1:166e695:             if (!isGrantExpected) {
1:166e695:                 fail("expected AccessControlException");
1:166e695:             }
1:166e695:         } catch (AccessControlException ace) {
1:c0052e0:             //println("    Yikes! " + ace.getMessage());
1:166e695:             if (isGrantExpected) {
1:c0052e0:                 //fail("caught AccessControlException");
1:c0052e0:                 throw ace;
1:166e695:             }
1:166e695:         }
1:166e695:     }
1:166e695:     
1:166e695:     /**
1:166e695:      * Tests DatabasePermission.getName() and .getActions().
1:166e695:      */
1:166e695:     private void checkNameAndActions(DatabasePermission[] dbperm,
1:166e695:                                      String[] dbpath)
1:166e695:         throws IOException {
1:166e695:         //assert(dpperm.length == dbpath.length)
1:166e695:         for (int i = 0; i < dbperm.length; i++) {
1:166e695:             final DatabasePermission dbp = dbperm[i];
1:166e695:             assertEquals("test: " + dbp + ".getName()",
1:166e695:                          dbpath[i], dbp.getName());
1:166e695:             assertEquals("test: " + dbp + ".getActions()",
1:166e695:                          DatabasePermission.CREATE, dbp.getActions());
1:166e695:         }
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Tests DatabasePermission.hashCode() and .equals().
1:166e695:      */
1:13b0113:     private void checkHashCodeAndEquals(Permission[] dbp0,
1:13b0113:                                         Permission[] dbp1)
1:166e695:         throws IOException {
2:166e695:         //assert(dbp0.length == dbp1.length)
1:166e695:         for (int i = 0; i < dbp0.length; i++) {
1:13b0113:             final Permission p0 = dbp0[i];
2:166e695:             for (int j = 0; j < dbp0.length; j++) {
1:13b0113:                 final Permission p1 = dbp1[j];
1:166e695:                 if (i == j) {
1:166e695:                     assertTrue(p0.hashCode() == p1.hashCode());
1:166e695:                     assertTrue(p0.equals(p1));
1:166e695:                 } else {
1:166e695:                     assertTrue(p0.hashCode() != p1.hashCode());
1:166e695:                     assertTrue(!p0.equals(p1));
1:166e695:                 }
1:166e695:             }
1:166e695:         }
1:166e695:     }
1:166e695:     
1:166e695:     /**
1:166e695:      * Tests DatabasePermission.implies().
1:166e695:      */
1:13b0113:     private void checkImplies(Permission[] dbp0,
1:13b0113:                               Permission[] dbp1,
1:c0052e0:                               boolean[][] impls)
1:166e695:         throws IOException {
1:166e695:         for (int i = 0; i < dbp0.length; i++) {
1:13b0113:             final Permission p0 = dbp0[i];
1:c0052e0:             for (int j = 0; j < dbp1.length; j++) {
1:13b0113:                 final Permission p1 = dbp1[j];
1:166e695:                 assertEquals("test: " + p0 + ".implies" + p1,
1:c0052e0:                              impls[i][j], p0.implies(p1));
1:c0052e0:                 //assertEquals("test: " + p1 + ".implies" + p0,
1:c0052e0:                 //             impls[j][i], p1.implies(p0));
1:166e695:             }
1:166e695:         }
1:166e695:     }
1:166e695:     
1:166e695:     /**
1:356ff6f:      * Check thet a set of Permission objects are distinct,
1:356ff6f:      * do not equal or imply each other.
1:166e695:      */
1:356ff6f:     private void checkDistinctPermissions(Permission[] set)
1:356ff6f:     {
1:356ff6f:         for (int i = 0; i < set.length; i++)
2:356ff6f:         {
1:356ff6f:             Permission pi = set[i];
1:356ff6f:             for (int j = 0; j < set.length; j++) {
1:166e695:                 
1:356ff6f:                 Permission pj = set[j];
1:166e695:                 
1:356ff6f:                 if (i == j)
1:356ff6f:                 {
1:356ff6f:                     // Permission is itself
1:356ff6f:                     assertEquivalentPermissions(pi, pj);
1:356ff6f:                     continue;
1:356ff6f:                 }
1:166e695:                 
1:356ff6f:                 assertFalse(pi.equals(pj));
1:356ff6f:                 assertFalse(pj.equals(pi));
1:166e695:                 
1:356ff6f:                 assertFalse(pi.implies(pj));
1:356ff6f:                 assertFalse(pj.implies(pi));
1:356ff6f:             }
1:356ff6f:         }
1:356ff6f:     }
1:166e695:     
1:356ff6f:     private void assertEquivalentPermissions(Permission p1,
1:356ff6f:             Permission p2) {
1:356ff6f:         assertTrue(p1.equals(p2));
1:356ff6f:         assertTrue(p2.equals(p1));
1:166e695:         
1:166e695:         
1:356ff6f:         assertEquals(p1.hashCode(), p2.hashCode());
1:166e695:         
2:356ff6f:         assertTrue(p1.implies(p2));
1:132bd11:         assertTrue(p2.implies(p1));
1:356ff6f:     }
1:166e695:     
1:166e695:     /**
1:c0052e0:      * Represents a Shutdown server and engine action.
1:166e695:      */
1:c0052e0:     public class ShutdownAction
1:3f5c48a:         implements PrivilegedAction<Void> {
1:166e695:         protected final Permission permission;
1:166e695: 
1:c0052e0:         public ShutdownAction(Permission permission) {
1:166e695:             this.permission = permission;
1:166e695:         }
1:166e695:     
1:3f5c48a:         public Void run() {
1:c0052e0:             //println("    checking access " + permission + "...");
1:166e695:             AccessController.checkPermission(permission);
1:c0052e0:             //println("    granted access " + this);
2:166e695:             return null;
1:166e695:         }
1:166e695: 
1:166e695:         public String toString() {
1:166e695:             return permission.toString();
1:166e695:         }
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Represents a Create Database action.
1:166e695:      */
1:166e695:     public class CreateDatabaseAction
1:3f5c48a:         implements PrivilegedAction<Void> {
1:166e695:         protected final Permission permission;
1:166e695: 
1:c0052e0:         public CreateDatabaseAction(Permission permission) {
1:166e695:             this.permission = permission;
1:166e695:         }
1:166e695: 
1:3f5c48a:         public Void run() {
1:c0052e0:             //println("    checking access " + permission + "...");
1:166e695:             AccessController.checkPermission(permission);
1:c0052e0:             //println("    granted access " + this);
1:166e695:             return null;
1:166e695:         }
1:166e695: 
1:166e695:         public String toString() {
1:166e695:             return permission.toString();
1:166e695:         }
1:166e695:     }
1:166e695: 
1:166e695:     /**
1:c0052e0:      * Returns the Authorization Identifier for a principal name.
1:166e695:      *
1:c0052e0:      * @param name the name of the principal
1:c0052e0:      * @return the authorization identifier for this principal
1:166e695:      */
1:c0052e0:     static private String getAuthorizationId(String name) {
1:c0052e0:         // RuntimeException messages not localized
1:c0052e0:         if (name == null) {
1:c0052e0:             throw new NullPointerException("name can't be null");
1:166e695:         }
1:c0052e0:         if (name.length() == 0) {
1:c0052e0:             throw new IllegalArgumentException("name can't be empty");
1:356ff6f:         }
1:166e695:         try {
1:c0052e0:             return IdUtil.getUserAuthorizationId(name);
1:c0052e0:         } catch (StandardException se) {
1:c0052e0:             throw new IllegalArgumentException(se.getMessage());
1:09c890c:         }
1:356ff6f:     }
1:166e695: 
1:166e695:     /**
1:166e695:      * Represents a Privileged User action.
1:166e695:      */
1:3f5c48a:     static public class RunAsPrivilegedUserAction<T>
1:3f5c48a:         implements PrivilegedAction<T> {
1:c0052e0:         final private SystemPrincipal principal;
1:3f5c48a:         final private PrivilegedAction<? extends T> action;
1:166e695: 
1:c0052e0:         public RunAsPrivilegedUserAction(SystemPrincipal principal,
1:3f5c48a:                                          PrivilegedAction<? extends T> action) {
1:166e695:             this.principal = principal;
1:166e695:             this.action = action;
1:166e695:         }
1:166e695:         
1:3f5c48a:         public T run() {
1:c0052e0:             final boolean readOnly = true;
1:3f5c48a:             final Set<SystemPrincipal> principals =
1:3f5c48a:                     new HashSet<SystemPrincipal>();
1:c0052e0:             final Set publicCredentials = new HashSet();
1:c0052e0:             final Set privateCredentials = new HashSet();
1:127ff35:             // add the given principal
1:c0052e0:             principals.add(principal);
1:c0052e0:             // also add a principal with the "normalized" name for testing
1:c0052e0:             // authorization ids
1:c0052e0:             final String normalized = getAuthorizationId(principal.getName());
1:c0052e0:             principals.add(new SystemPrincipal(normalized));
1:c0052e0:             final Subject subject = new Subject(readOnly,
1:c0052e0:                                                 principals,
1:c0052e0:                                                 publicCredentials,
1:c0052e0:                                                 privateCredentials);
1:166e695: 
1:c0052e0:             // check subject's permission with a fresh AccessControlContext,
1:c0052e0:             // not the thread's current one (Subject.doAs(subject, action))
1:c0052e0:             // println("    run doAsPrivileged() as " + principal + "...");
1:c0052e0:             // The alternative approach to use Subject.doAs(subject, action)
1:c0052e0:             // instead of Subject.doAsPrivileged(subject, action, null) has
1:c0052e0:             // issues: there are subtile differences between these methods
1:c0052e0:             // regarding the checking of the caller's protection domain.  To
1:c0052e0:             // make doAs() work, the shutdown/createDatabase permissions must
1:c0052e0:             // be granted to the codebase (class RunAsPrivilegedUserAction).
1:c0052e0:             // This, however, defeats the purpose since everyone now's granted
1:c0052e0:             // permission.  In contrast, doAsPrivileged() with a null ACC
1:c0052e0:             // seems to effectively ignore the caller's protection domain, so
1:c0052e0:             // the check now only depends on the principal's permissions.
1:3f5c48a:             return Subject.doAsPrivileged(subject, action, null);
1:c0052e0:             //Subject.doAs(subject, action);
1:166e695:         }
1:166e695:     }
1:356ff6f: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d09cda8
/////////////////////////////////////////////////////////////////////////
1:         Permissions onePerm = new Permissions();
1:         onePerm.add(new SystemPermission("server", "shutdown"));
1: 
1:         // onePerm implies server shutdown and nothing else
1:         assertTrue(onePerm.implies(new SystemPermission("server", "shutdown")));
1:         assertFalse(onePerm.implies(
1:                         new SystemPermission("engine", "shutdown")));
1:         assertFalse(onePerm.implies(
1:                         new SystemPermission("server", "shutdown,monitor")));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The collection does not imply other permission types.
1:         assertFalse(collection.implies(new AllPermission()));
commit:281f903
/////////////////////////////////////////////////////////////////////////
1: import java.security.AllPermission;
1: import java.security.PermissionCollection;
1: import java.security.Permissions;
1: import java.util.Collections;
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(
1:             new SystemPrivilegesPermissionTest(
1:                     "testSystemPermissionCollections"));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that collections of SystemPermissions behave as expected.
1:      * Before DERBY-6717, adding multiple single-action permissions with
1:      * the same name didn't work.
1:      */
1:     public void testSystemPermissionCollections() {
1:         Permissions allPerms = new Permissions();
1:         for (String name : VALID_SYSPERM_NAMES) {
1:             for (String action : VALID_SYSPERM_ACTIONS) {
1:                 allPerms.add(new SystemPermission(name, action));
1:             }
1:         }
1: 
1:         assertEquals(VALID_SYSPERM_NAMES.length,
1:                      Collections.list(allPerms.elements()).size());
1: 
1:         // Check that the collection of all system permissions also implies
1:         // all system permissions.
1:         for (String name : VALID_SYSPERM_NAMES) {
1:             for (String a1 : VALID_SYSPERM_ACTIONS) {
1:                 // allPerms should imply any valid (name, action) pair.
1:                 assertTrue(allPerms.implies(new SystemPermission(name, a1)));
1: 
1:                 // allPerms should also imply any valid multi-action
1:                 // system permission.
1:                 for (String a2 : VALID_SYSPERM_ACTIONS) {
1:                     assertTrue(allPerms.implies(
1:                             new SystemPermission(name, a1 + ',' + a2)));
1:                 }
1:             }
1:         }
1: 
1:         Permissions somePerms = new Permissions();
1:         somePerms.add(new SystemPermission("server", "shutdown"));
1:         somePerms.add(new SystemPermission("jmx", "shutdown,monitor"));
1:         somePerms.add(new SystemPermission("engine", "shutdown,control"));
1:         somePerms.add(new SystemPermission("engine", "control,monitor"));
1: 
1:         // somePerms implies the shutdown action for server
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("server", "shutdown")));
1:         assertFalse(somePerms.implies(
1:                 new SystemPermission("server", "control")));
1:         assertFalse(somePerms.implies(
1:                 new SystemPermission("server", "monitor")));
1:         assertFalse(somePerms.implies(
1:                 new SystemPermission("server", "shutdown,monitor")));
1: 
1:         // somePerms implies the shutdown and monitor actions for jmx
1:         assertTrue(somePerms.implies(new SystemPermission("jmx", "shutdown")));
1:         assertTrue(somePerms.implies(new SystemPermission("jmx", "monitor")));
1:         assertFalse(somePerms.implies(new SystemPermission("jmx", "control")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("jmx", "shutdown,monitor")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("jmx", "monitor,shutdown")));
1:         assertFalse(somePerms.implies(
1:                 new SystemPermission("jmx", "monitor,shutdown,control")));
1: 
1:         // somePerms implies shutdown, control and monitor for engine
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("engine", "shutdown")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("engine", "control")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("engine", "monitor")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("engine", "shutdown,monitor")));
1:         assertTrue(somePerms.implies(
1:                 new SystemPermission("engine", "shutdown,monitor,control")));
1: 
1:         // A SystemPermission collection should not accept other permissions.
1:         SystemPermission sp = new SystemPermission("engine", "monitor");
1:         PermissionCollection collection = sp.newPermissionCollection();
1:         try {
1:             collection.add(new AllPermission());
1:             fail();
1:         } catch (IllegalArgumentException iae) {
1:             // expected
1:         }
1: 
1:         // Read-only collections cannot be added to.
1:         collection.setReadOnly();
1:         try {
1:             collection.add(sp);
1:             fail();
1:         } catch (SecurityException se) {
1:             // expected
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Test serialization of SystemPermission collections.
1: 
1:         // Serialization should work on empty collection.
1:         PermissionCollection collection = sp.newPermissionCollection();
1:         PermissionCollection readCollection =
1:                 serializeDeserialize(collection, null);
1:         assertFalse(readCollection.elements().hasMoreElements());
1: 
1:         // Serialization should work on non-empty collection.
1:         sp = new SystemPermission(
1:                 VALID_SYSPERM_NAMES[0], VALID_SYSPERM_ACTIONS[0]);
1:         collection = sp.newPermissionCollection();
1:         collection.add(sp);
1:         readCollection = serializeDeserialize(collection, null);
1:         assertEquals(Arrays.asList(sp),
1:                      Collections.list(readCollection.elements()));
1: 
1:         // Deserialization should fail if the collection contains a
1:         // permission with invalid name.
1:         collection.add(createSyspermNoCheck("invalid_name", "control"));
1:         serializeDeserialize(collection, IllegalArgumentException.class);
1: 
1:         // Deserialization should fail if the collection contains a
1:         // permission that is not a SystemPermission.
1:         collection = sp.newPermissionCollection();
1:         HashMap<String, Permission> permissions =
1:                 new HashMap<String, Permission>();
1:         permissions.put("engine", new AllPermission());
1:         setField(collection.getClass(), "permissions", collection, permissions);
1:         serializeDeserialize(collection, ClassCastException.class);
commit:132bd11
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertTrue(p2.implies(p1));
commit:44ea8af
/////////////////////////////////////////////////////////////////////////
1:         // test a valid SystemPrincipal
1:         SystemPrincipal p = new SystemPrincipal("superuser");
1:         assertEquals("superuser", p.getName());
1: 
/////////////////////////////////////////////////////////////////////////
1:         testSystemPrincipalSerialization();
/////////////////////////////////////////////////////////////////////////
1:      * Test serialization of SystemPrincipal objects.
1:      */
1:     private void testSystemPrincipalSerialization() throws IOException {
1:         // Serialize and deserialize a valid object.
1:         SystemPrincipal p = new SystemPrincipal("superuser");
1:         assertEquals(p, serializeDeserialize(p, null));
1: 
1:         // Deserialize a SystemPrincipal whose name is null. Should fail.
1:         setField(SystemPrincipal.class, "name", p, null);
1:         serializeDeserialize(p, NullPointerException.class);
1: 
1:         // Deserialize a SystemPrincipal whose name is empty. Should fail.
1:         setField(SystemPrincipal.class, "name", p, "");
1:         serializeDeserialize(p, IllegalArgumentException.class);
1:     }
1: 
1:     /**
commit:3c23476
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("control,monitor",
1:                      new SystemPermission("server", "monitor, control, monitor")
1:                              .getActions());
/////////////////////////////////////////////////////////////////////////
1: 
1:         // test DatabasePermission with unsupported protocol
1:         try {
1:             new DatabasePermission("unknown:test", DatabasePermission.CREATE);
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", "illegal,create,action");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", ",");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", " ");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", "create,");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Actions string is washed (lower-cased, trimmed) and duplicates
1:         // are removed.
1:         DatabasePermission perm =
1:                 new DatabasePermission("directory:dir", "create, create");
1:         assertEquals("create", perm.getActions());
1:         perm = new DatabasePermission("directory:dir", "  CrEaTe  ");
1:         assertEquals("create", perm.getActions());
1: 
/////////////////////////////////////////////////////////////////////////
1:         testDatabasePermissionSerialization();
1:         testSystemPermissionSerialization();
1:     }
1:     /**
1:      * Test serialization and deserialization of DatabasePermission objects.
1:      */
1:     private void testDatabasePermissionSerialization() throws IOException {
1:         // Simple test of serialization/deserialization of a valid object
1:         DatabasePermission perm =
1:                 new DatabasePermission("directory:dir", "create");
1:         assertEquals(perm, serializeDeserialize(perm, null));
1: 
1:         // Test of relative paths
1:         for (String url : relDirPaths) {
1:             perm = new DatabasePermission(url, "create");
1:             assertEquals(perm, serializeDeserialize(perm, null));
1:         }
1: 
1:         // Test of relative path aliases
1:         for (String url : relDirPathAliases) {
1:             perm = new DatabasePermission(url, "create");
1:             assertEquals(perm, serializeDeserialize(perm, null));
1:         }
1: 
1:         // Test of absolute paths
1:         for (String url : absDirPaths) {
1:             perm = new DatabasePermission(url, "create");
1:             assertEquals(perm, serializeDeserialize(perm, null));
1:         }
1: 
1:         // Test of absolute path aliases
1:         for (String url : absDirPathAliases) {
1:             perm = new DatabasePermission(url, "create");
1:             assertEquals(perm, serializeDeserialize(perm, null));
1:         }
1: 
1:         // Actions should be normalized when read from the stream.
1:         for (String actions :
1:                 Arrays.asList("create", "CrEaTe", " create ,  create")) {
1:             perm = serializeDeserialize(
1:                     createDBPermNoCheck("directory:dir", actions),
1:                     null);
1:             assertEquals("create", perm.getActions());
1:         }
1: 
1:         // Null URL should fail on deserialization (didn't before DERBY-3476)
1:         perm = createDBPermNoCheck(null, "create");
1:         serializeDeserialize(perm, NullPointerException.class);
1: 
1:         // Empty URL should fail on deserialization (didn't before DERBY-3476)
1:         perm = createDBPermNoCheck("", "create");
1:         serializeDeserialize(perm, IllegalArgumentException.class);
1: 
1:         // Unsupported protocol should fail on deserialization (didn't before
1:         // DERBY-3476)
1:         perm = createDBPermNoCheck("unknown:test", "create");
1:         serializeDeserialize(perm, IllegalArgumentException.class);
1: 
1:         // Null actions should fail on deserialization
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", null),
1:                              NullPointerException.class);
1: 
1:         // Empty and invalid actions should fail on deserialization
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", ""),
1:                              IllegalArgumentException.class);
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", " "),
1:                              IllegalArgumentException.class);
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", ","),
1:                              IllegalArgumentException.class);
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", "create,"),
1:                              IllegalArgumentException.class);
1:         serializeDeserialize(createDBPermNoCheck("directory:dir", "invalid"),
1:                              IllegalArgumentException.class);
1:         serializeDeserialize(createDBPermNoCheck("directory:dir",
1:                                                  "create,invalid"),
1:                              IllegalArgumentException.class);
1:     }
1: 
1:     /**
1:      * Test serialization and deserialization of SystemPermission objects.
1:      */
1:     private void testSystemPermissionSerialization() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:      * Create a DatabasePermission object without checking that the URL
1:      * and the actions are valid.
1:      *
1:      * @param url the URL of the permission
1:      * @param actions the actions of the permission
1:      * @return a DatabasePermission instance
1:      */
1:     private static DatabasePermission createDBPermNoCheck(
1:             String url, String actions) throws IOException {
1:         // First create a valid permission object, so that the checks in
1:         // the constructor are happy.
1:         DatabasePermission perm =
1:                 new DatabasePermission("directory:dir", "create");
1: 
1:         // Then use reflection to override the values of the fields with
1:         // potentially invalid values.
1:         setField(Permission.class, "name", perm, url);
1:         setField(DatabasePermission.class, "actions", perm, actions);
1: 
1:         return perm;
1:     }
1: 
1:     /**
commit:f5ac375
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ByteArrayOutputStream;
1: import java.io.ObjectInputStream;
1: import java.io.ObjectOutputStream;
1: import java.lang.reflect.Field;
1: import java.lang.reflect.Modifier;
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:     /** The valid names of a SystemPermission. */
1:     private static final String[] VALID_SYSPERM_NAMES = {
1:         "server", "engine", "jmx"
1:     };
1: 
1:     /** The valid actions of a SystemPermission. */
1:     private static final String[] VALID_SYSPERM_ACTIONS = {
1:         "shutdown", "control", "monitor"
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // We need to manipulate private and final fields in order to test
1:         // deserialization of invalid objects. Disable the security manager
1:         // for this test case to allow that.
1:         suite.addTest(SecurityManagerSetup.noSecurityManager(
1:                 new SystemPrivilegesPermissionTest("testSerialization")));
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-3476: The SystemPrincipal class should be final.
1:         assertTrue(Modifier.isFinal(SystemPrincipal.class.getModifiers()));
/////////////////////////////////////////////////////////////////////////
1: 
1:         // actions cannot be null
1:         try {
1:             new SystemPermission("server", null);
1:             fail("expected NullPointerException");
1:         } catch (NullPointerException ex) {
1:             // expected exception
1:         }
1: 
1:         // Illegal and duplicate actions are ignored.
1:         assertEquals("", new SystemPermission("server", "").getActions());
1:         assertEquals("", new SystemPermission("server", ",,").getActions());
1:         assertEquals("",
1:                      new SystemPermission("server", "illegal_action")
1:                              .getActions());
1:         assertEquals("control",
1:                      new SystemPermission("server", "control,").getActions());
1:         assertEquals("control",
1:                      new SystemPermission("server", "control,illegal_action")
1:                              .getActions());
1:         assertEquals("control",
1:                      new SystemPermission("server", "control,control")
1:                              .getActions());
1:         assertEquals("control,monitor",
1:                      new SystemPermission("server", "control, monitor, control")
1:                              .getActions());
1:         assertEquals("control",
1:                      new SystemPermission("server", "CoNtRoL")
1:                              .getActions());
1:         assertEquals("control",
1:                      new SystemPermission("server", "CoNtRoL,control")
1:                              .getActions());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-3476: The SystemPermission class should be final.
1:         assertTrue(Modifier.isFinal(SystemPermission.class.getModifiers()));
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-3476: The DatabasePermission class should be final.
1:         assertTrue(Modifier.isFinal(DatabasePermission.class.getModifiers()));
/////////////////////////////////////////////////////////////////////////
1:      * Test serialization of permissions. In particular, test that
1:      * deserialization of invalid objects fails.
1:      */
1:     public void testSerialization() throws IOException {
1: 
1:         // Test all valid name/action combinations. All should succeed to
1:         // serialize and deserialize.
1:         for (String name : VALID_SYSPERM_NAMES) {
1:             for (String action : VALID_SYSPERM_ACTIONS) {
1:                 // Actions are case-insensitive, so test both lower-case
1:                 // and upper-case.
1:                 SystemPermission pl =
1:                     new SystemPermission(name, action.toLowerCase(Locale.US));
1:                 SystemPermission pu =
1:                     new SystemPermission(name, action.toUpperCase(Locale.US));
1:                 assertEquals(pl, serializeDeserialize(pl, null));
1:                 assertEquals(pu, serializeDeserialize(pu, null));
1:             }
1:         }
1: 
1:         // A permission can specify multiple actions ...
1:         SystemPermission sp = new SystemPermission(
1:                 "server", "control,monitor,shutdown");
1:         assertEquals(sp, serializeDeserialize(sp, null));
1: 
1:         // ... but only a single name, so this should fail.
1:         // (Did not fail before DERBY-3476.)
1:         serializeDeserialize(
1:                 createSyspermNoCheck("server,jmx", "control"),
1:                 IllegalArgumentException.class);
1: 
1:         // Invalid and duplicate actions should be ignored.
1:         sp = serializeDeserialize(createSyspermNoCheck(
1:                     VALID_SYSPERM_NAMES[0],
1:                     "control,invalid,control,,shutdown"),
1:                 null);
1:         // The next assert failed before DERBY-3476.
1:         assertEquals("control,shutdown", sp.getActions());
1: 
1:         // Empty action is allowed.
1:         sp = new SystemPermission(VALID_SYSPERM_NAMES[0], "");
1:         assertEquals(sp, serializeDeserialize(sp, null));
1: 
1:         // Name is case-sensitive, so this should fail.
1:         // (Did not fail before DERBY-3476.)
1:         serializeDeserialize(createSyspermNoCheck(
1:                 VALID_SYSPERM_NAMES[0].toUpperCase(Locale.US),
1:                 VALID_SYSPERM_ACTIONS[0]),
1:             IllegalArgumentException.class);
1: 
1:         // Empty name is not allowed.
1:         serializeDeserialize(createSyspermNoCheck(
1:                 "",
1:                 VALID_SYSPERM_ACTIONS[0]),
1:                 IllegalArgumentException.class);
1: 
1:         // Null name is not allowed.
1:         serializeDeserialize(createSyspermNoCheck(
1:                 null,
1:                 VALID_SYSPERM_ACTIONS[0]),
1:             NullPointerException.class);
1: 
1:         // Null action is not allowed.
1:         // (Did not fail before DERBY-3476.)
1:         serializeDeserialize(createSyspermNoCheck(
1:                 VALID_SYSPERM_NAMES[0],
1:                 null),
1:             NullPointerException.class);
1:     }
1: 
1:     /**
1:      * Create a new SystemPermission object without checking that the name
1:      * and actions are valid.
1:      *
1:      * @param name the name of the permission
1:      * @param actions the actions of the permission
1:      * @return a SystemPermission instance
1:      */
1:     private static SystemPermission
1:                         createSyspermNoCheck(String name, String actions) {
1:         // First create a valid permission object, so that the checks in
1:         // the constructor are happy.
1:         SystemPermission sysperm = new SystemPermission("server", "control");
1: 
1:         // Then use reflection to override the values of the fields with
1:         // potentially invalid values.
1:         setField(Permission.class, "name", sysperm, name);
1:         setField(SystemPermission.class, "actions", sysperm, actions);
1: 
1:         return sysperm;
1:     }
1: 
1:     /**
1:      * Forcefully set the value of a field, ignoring access checks such as
1:      * final and private.
1:      *
1:      * @param klass the class in which the field lives
1:      * @param name the name of the field
1:      * @param object the object to change
1:      * @param value the new value of the field
1:      */
1:     private static void setField(
1:             Class<?> klass, String name, Object object, Object value) {
1:         try {
1:             Field f = klass.getDeclaredField(name);
1:             f.setAccessible(true);
1:             f.set(object, value);
1:         } catch (NoSuchFieldException ex) {
1:             fail("Cannot find field " + name, ex);
1:         } catch (IllegalAccessException ex) {
1:             fail("Cannot access field " + name, ex);
1:         }
1:     }
1: 
1:     /**
1:      * Serialize an object, then deserialize it from where it's stored, and
1:      * finally return the deserialized object.
1:      *
1:      * @param <T> the type of the object being serialized
1:      * @param object the object to serialize
1:      * @param expectedException the type of exception being expected during
1:      *   deserialization, or {@code null} if deserialization is expected to
1:      *   be successful
1:      * @return the deserialized object, or {@code null} if deserialization
1:      *   failed as expected
1:      * @throws IOException if an I/O error occurred
1:      */
1:     // We actually do check the type before we cast the result to T, but the
1:     // compiler doesn't understand it because we're using a JUnit assert.
1:     // Ignore the warning.
1:     @SuppressWarnings("unchecked")
1:     private static <T> T serializeDeserialize(
1:                 T object,
1:                 Class<? extends Exception> expectedException)
1:             throws IOException {
1:         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1:         ObjectOutputStream oos = new ObjectOutputStream(baos);
1:         oos.writeObject(object);
1:         oos.close();
1: 
1:         ObjectInputStream ois = new ObjectInputStream(
1:                 new ByteArrayInputStream(baos.toByteArray()));
1:         try {
1:             Object deserialized = ois.readObject();
1:             assertNull("should have failed", expectedException);
1:             assertEquals(object.getClass(), deserialized.getClass());
1:             // This generates a compile-time warning because the compiler
1:             // doesn't understand that the deserialized object has to be of
1:             // the correct type when the above assert succeeds. Because of
1:             // this, "unchecked" warnings are suppressed in this method.
1:             return (T) deserialized;
1:         } catch (Exception e) {
1:             if (expectedException == null ||
1:                     !expectedException.isAssignableFrom(e.getClass())) {
1:                 fail("unexpected exception", e);
1:             }
1:             return null;
1:         } finally {
1:             ois.close();
1:         }
1:     }
1: 
1:     /**
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:     private <T> void execute(SystemPrincipal principal,
1:                          PrivilegedAction<T> action,
1:         final RunAsPrivilegedUserAction<T> runAsPrivilegedUserAction
1:             = new RunAsPrivilegedUserAction<T>(principal, action);
/////////////////////////////////////////////////////////////////////////
1:         implements PrivilegedAction<Void> {
1:         public Void run() {
/////////////////////////////////////////////////////////////////////////
1:         implements PrivilegedAction<Void> {
1:         public Void run() {
/////////////////////////////////////////////////////////////////////////
1:     static public class RunAsPrivilegedUserAction<T>
1:         implements PrivilegedAction<T> {
1:         final private PrivilegedAction<? extends T> action;
1:                                          PrivilegedAction<? extends T> action) {
1:         public T run() {
1:             final Set<SystemPrincipal> principals =
1:                     new HashSet<SystemPrincipal>();
/////////////////////////////////////////////////////////////////////////
1:             return Subject.doAsPrivileged(subject, action, null);
commit:b32256d
/////////////////////////////////////////////////////////////////////////
1:     private static final String POLICY_FILE_NAME
1:     private static final String POLICY_FILE_NAME1
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.HashSet;
1: import java.util.Set;
1: import junit.framework.Test;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.security.DatabasePermission;
1: import org.apache.derby.security.SystemPermission;
1: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("SystemPrivilegesPermissionTest");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:09c890c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.security.DatabasePermission;
/////////////////////////////////////////////////////////////////////////
1:      * The policy file name for the subject authorization tests.
1:      * The policy file name for the DatabasePermission API test.
1:      */
0:     static private String POLICY_FILE_NAME1
1:         = "org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest1.policy";
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         // this suite cannot be constructed with automatic test extraction
1:         // (by passing a class argument); instead, the tests need to be added
1:         // manually since some of them require their own policy file
0:         TestSuite suite = new TestSuite("SystemPrivilegesPermissionTest");
1: 
1:         // add API tests for the basic security framework classes
1:         suite.addTest(
1:             new SystemPrivilegesPermissionTest("testSystemPrincipal"));
1:         suite.addTest(
1:             new SystemPrivilegesPermissionTest("testSystemPermission"));
1:         // the DatabasePermission test attempts to canonicalize various
1:         // directory path names and requires an all-files-read-permission,
1:         // which is not granted by default derby_tests.policy
1:         suite.addTest(new SecurityManagerSetup(
1:             new SystemPrivilegesPermissionTest("testDatabasePermission"),
1:             POLICY_FILE_NAME1));
1: 
1:         // add authorization tests for security permissions; requires
1:         // class javax.security.auth.Subject, which is not available
1:         // on all JVM platforms
1:         if (SecurityManagerSetup.JVM_HAS_SUBJECT_AUTHORIZATION) {
1:                 new SystemPrivilegesPermissionTest("policyTestSystemPermissionGrants"),
1:                      POLICY_FILE_NAME));
1:             suite.addTest(new SecurityManagerSetup(
1:                 new SystemPrivilegesPermissionTest("policyTestDatabasePermissionGrants"),
1:                      POLICY_FILE_NAME));
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests SystemPermissions against the Policy.
1:      */
1:     public void policyTestSystemPermissionGrants() {
1:         final Permission shutdown
1:             = new SystemPermission(
1:         // test SystemPermission for authorized user
1:         // test SystemPermission for unauthorized user
/////////////////////////////////////////////////////////////////////////
1:      */   
1:     public void testDatabasePermission() throws IOException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Tests DatabasePermissions against the Policy.
1:      */
1:     public void policyTestDatabasePermissionGrants() throws IOException {
1:         final DatabasePermission[] relDirPathPerms
1:             = new DatabasePermission[relDirPaths.length];
1:         for (int i = 0; i < relDirPaths.length; i++) {
1:             relDirPathPerms[i]
1:                 = new DatabasePermission(relDirPaths[i],
1:                                          DatabasePermission.CREATE);
1:         }
1:         // all-authorized users
/////////////////////////////////////////////////////////////////////////
1:         // test DatabasePermission for any user
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         }
commit:127ff35
/////////////////////////////////////////////////////////////////////////
0:         checkDatabasePrincipal();
0:      * Tests DatabasePrincipal.
1:      */
0:     private void checkDatabasePrincipal() throws IOException {
0:         // test DatabasePrincipal with null name argument
1:         try {
0:             new DatabasePrincipal(null);
1:             fail("expected NullPointerException");
1:         } catch (NullPointerException ex) {
1:             // expected exception
1:         }
1: 
0:         // test DatabasePrincipal with empty name argument
1:         try {
0:             new DatabasePrincipal("");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1:         
0:         // test DatabasePrincipal with illegal name argument
1:         try {
0:             new DatabasePrincipal("disallowed: unescaped *");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
0:         // test DatabasePrincipal with illegal name argument
1:         try {
0:             new DatabasePrincipal("not yet supported: userName@databaseName");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
0:         // test DatabasePrincipal with legal name argument
0:         new DatabasePrincipal("supported: userNameWith\\\\character");
0:         new DatabasePrincipal("supported: userNameWith\\*character");
0:         new DatabasePrincipal("supported: userNameWith\\@character");
0:         new DatabasePrincipal("*");
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         final DatabasePrincipal authorizedUser
0:             = new DatabasePrincipal("authorizedSystemUser");
0:         final DatabasePrincipal unAuthorizedUser
0:             = new DatabasePrincipal("unAuthorizedSystemUser");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         final DatabasePrincipal authorizedUser
0:             = new DatabasePrincipal("authorizedSystemUser");
/////////////////////////////////////////////////////////////////////////
0:         final DatabasePrincipal unAuthorizedUser
0:             = new DatabasePrincipal("unAuthorizedSystemUser");
/////////////////////////////////////////////////////////////////////////
1: 
0:         // test DatabasePermission for authorized user against policy file
0:         final DatabasePrincipal anyUser
0:             = new DatabasePrincipal("anyUser");
1:         final DatabasePermission dbPerm
1:             = new DatabasePermission("directory:dir",
1:                                      DatabasePermission.CREATE);
1:         execute(anyUser,
1:                 new CreateDatabaseAction(dbPerm), true);
/////////////////////////////////////////////////////////////////////////
1:             // add the given principal
0:             // add a principal that matches an "all user names" grant
0:             principalSet.add(DatabasePrincipal.ANY_DATABASE_PRINCIPAL);
commit:166e695
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.junit.SystemPrivilegesPermissionTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.junit;
1: 
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseTestCase;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: 
0: import java.util.Set;
0: import java.util.HashSet;
1: 
1: import java.io.IOException;
1: 
0: import java.security.PrivilegedAction;
0: import java.security.PrivilegedExceptionAction;
0: import java.security.PrivilegedActionException;
0: import java.security.AccessController;
1: import java.security.AccessControlException;
1: import java.security.Permission;
1: import javax.security.auth.Subject;
1: 
0: import org.apache.derby.authentication.DatabasePrincipal;
0: import org.apache.derby.security.SystemPermission;
0: import org.apache.derby.security.DatabasePermission;
1: 
1: 
1: /**
1:  * This class tests the basic permission classes for system privileges.
1:  */
1: public class SystemPrivilegesPermissionTest extends BaseTestCase {
1: 
1:     /**
0:      * This test's policy file.
1:      */
0:     static private String POLICY_FILE_NAME
1:         = "org/apache/derbyTesting/unitTests/junit/SystemPrivilegesPermissionTest.policy";
1: 
1:     /**
1:      * Some directory paths for testing DatabasePermissions.
1:      */
1:     static private final String[] dirPaths = {
1:         "-",
1:         "*",
1:         "level0",
1:         "level0a",
1:         "level0/-",
1:         "level0/*",
1:         "level0/level1",
1:         "level0/level1/level2"
1:     };
1: 
1:     /**
1:      * Some relative directory paths for testing DatabasePermissions.
1:      */
1:     static private final String[] relDirPaths
1:         = new String[dirPaths.length];
1:     static {
1:         for (int i = 0; i < relDirPaths.length; i++) {
1:             relDirPaths[i] = "directory:" + dirPaths[i];
1:         }
1:     };
1: 
1:     /**
1:      * Some relative directory path aliases for testing DatabasePermissions.
1:      */
1:     static private final String[] relDirPathAliases
1:         = new String[dirPaths.length];
1:     static {
1:         for (int i = 0; i < relDirPaths.length; i++) {
1:             relDirPathAliases[i] = "directory:./" + dirPaths[i];
1:         }
1:     };
1: 
1:     /**
1:      * Some absolute directory paths for testing DatabasePermissions.
1:      */
1:     static private final String[] absDirPaths
1:         = new String[dirPaths.length];
1:     static {
1:         for (int i = 0; i < relDirPaths.length; i++) {
1:             absDirPaths[i] = "directory:/" + dirPaths[i];
1:         }
1:     };
1: 
1:     /**
1:      * Some absolute directory path aliases for testing DatabasePermissions.
1:      */
1:     static private final String[] absDirPathAliases
1:         = new String[dirPaths.length];
1:     static {
1:         for (int i = 0; i < relDirPaths.length; i++) {
1:             absDirPathAliases[i] = "directory:/dummy/../" + dirPaths[i];
1:         }
1:     };
1: 
1:     /**
1:      * The matrix defining which of the above directory paths imply each other.
1:      *
0:      * For instance, dirPathImplications[1][2] shows the expected value for:
1:      * <ul>
1:      * <li> DP("directory:*").implies(DP(directory:level0"))
1:      * <li> DP("directory:./*").implies(DP(directory:./level0"))
1:      * <li> DP("directory:/*").implies(DP(directory:/level0"))
1:      * <li> DP("directory:/dummy/..*").implies(DP(directory:/dummy/..level0"))
1:      * </ul>
1:      */
0:     static private final boolean[][] dirPathImplications = {
1:         { true, true, true, true, true, true, true, true }, 
1:         { false, true, true, true, false, false, false, false },
1:         { false, false, true, false, false, false, false, false },
1:         { false, false, false, true, false, false, false, false },
1:         { false, false, false, false, true, true, true, true },
1:         { false, false, false, false, false, true, true, false },
1:         { false, false, false, false, false, false, true, false },
1:         { false, false, false, false, false, false, false, true }
1:     };    
1:     
1:     /**
0:      * Add decorators to a test run to establish a security manager
0:      * with this test's policy file.
1:      */
0:     static private Test decorateTest(String method) {
0:         final SystemPrivilegesPermissionTest undecoratedTest
0:             = new SystemPrivilegesPermissionTest(method);
1: 
0:         // install a security manager using this test's policy file
0:         return new SecurityManagerSetup(undecoratedTest, POLICY_FILE_NAME);
1:     }
1:     
1: 
1:     /**
1:      * Create a test with the given name.
1:      *
1:      * @param name name of the test
1:      */
1:     public SystemPrivilegesPermissionTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Return a suite with all tests in this class (default suite)
1:      *
0:      * @throws Exception
1:      */
1:     public static Test suite() {
0:         //final TestSuite ts
0:         //    = new TestSuite("SystemPrivilegesPermissionTest suite");
0:         //ts.addTest(decorateTest("testSystemPrivileges"));
0:         //return ts;
0:         return decorateTest("testSystemPrivileges");
1:     }
1: 
1:     /**
0:      * Test case that does a check of the XXX
1:      */
0:     public void testSystemPrivileges() throws IOException {
0:         //System.out.println("--> testSystemPrivileges()");
0:         //System.out.println("    java.security.policy = "
0:         //                   + System.getProperty("java.security.policy"));
0:         //System.out.println("    System.getSecurityManager() = "
0:         //                   + System.getSecurityManager());
0:         assertSecurityManager();
0:         execute();
0:         //System.out.println("<-- testSystemPrivileges()");
1:     }
1: 
1:     /**
0:      * Tests SystemPermissions.
1:      */
0:     public void execute() throws IOException {
0:         checkSystemPermission();
0:         checkDatabasePermission();
1:     }
1:     
1:     /**
1:      * Tests SystemPermission.
1:      */
0:     private void checkSystemPermission() throws IOException {
0:         final DatabasePrincipal authorizedUser
0:             = new DatabasePrincipal("authorizedSystemUser");
0:         final DatabasePrincipal unAuthorizedUser
0:             = new DatabasePrincipal("unAuthorizedSystemUser");
1: 
1:         // test SystemPermission with null name argument
1:         try {
0:             new SystemPermission(null);
1:             fail("expected NullPointerException");
1:         } catch (NullPointerException ex) {
1:             // expected exception
1:         }
1: 
1:         // test SystemPermission with empty name argument
1:         try {
0:             new SystemPermission("");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1:         
1:         // test SystemPermission with illegal name argument
1:         try {
0:             new SystemPermission("illegal_name");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
0:         // test SystemPermission with legal name argument
0:         final Permission sp0 = new SystemPermission(SystemPermission.SHUTDOWN);
0:         final Permission sp1 = new SystemPermission(SystemPermission.SHUTDOWN);
1: 
0:         // test SystemPermission.getName()
0:         assertEquals(sp0.getName(), SystemPermission.SHUTDOWN);
1: 
0:         // test SystemPermission.getActions()
0:         assertEquals(sp0.getActions(), "");
1: 
0:         // test SystemPermission.hashCode()
0:         assertTrue(sp0.hashCode() == sp1.hashCode());
1: 
1:         // test SystemPermission.equals()
0:         assertTrue(sp0.equals(sp1));
0:         assertTrue(!sp0.equals(null));
0:         assertTrue(!sp0.equals(new Object()));
1: 
0:         // test SystemPermission.implies()
0:         assertTrue(sp0.implies(sp1));
0:         assertTrue(sp1.implies(sp0));
1: 
0:         // test SystemPermission for authorized user against policy file
0:         execute(authorizedUser, new ShutdownEngineAction(sp0), true);
1:         
0:         // test SystemPermission for unauthorized user against policy file
0:         execute(unAuthorizedUser, new ShutdownEngineAction(sp0), false);
1:     }
1:     
1:     /**
1:      * Tests DatabasePermission.
1:      */
0:     private void checkDatabasePermission() throws IOException {
0:         final DatabasePrincipal authorizedUser
0:             = new DatabasePrincipal("authorizedSystemUser");
0:         final DatabasePrincipal unAuthorizedUser
0:             = new DatabasePrincipal("unAuthorizedSystemUser");
1: 
1:         // test DatabasePermission with null url
1:         try {
1:             new DatabasePermission(null, DatabasePermission.CREATE);
1:             fail("expected NullPointerException");
1:         } catch (NullPointerException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with empty url
1:         try {
1:             new DatabasePermission("", DatabasePermission.CREATE);
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1:         
1:         // test DatabasePermission with illegal url
1:         try {
1:             new DatabasePermission("no_url", DatabasePermission.CREATE);
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with non-canonicalizable URL
1:         try {
0:             new DatabasePermission("directory:.*/\\:///../",
1:                                    DatabasePermission.CREATE);
0:             fail("expected IOException");
0:         } catch (IOException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with null actions
1:         try {
1:             new DatabasePermission("directory:dir", null);
1:             fail("expected NullPointerException");
1:         } catch (NullPointerException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with empty actions
1:         try {
1:             new DatabasePermission("directory:dir", "");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1:         
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", "illegal_action");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission with illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", "illegal,action");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1:     
1:         // test DatabasePermission on illegal action list
1:         try {
1:             new DatabasePermission("directory:dir", "illegal;action");
1:             fail("expected IllegalArgumentException");
1:         } catch (IllegalArgumentException ex) {
1:             // expected exception
1:         }
1: 
1:         // test DatabasePermission on relative directory paths
0:         final DatabasePermission[] relDirPathPermissions
1:             = new DatabasePermission[relDirPaths.length];
1:         for (int i = 0; i < relDirPaths.length; i++) {
0:             relDirPathPermissions[i]
1:                 = new DatabasePermission(relDirPaths[i],
1:                                          DatabasePermission.CREATE);
1:         }
0:         checkNameAndActions(relDirPathPermissions,
0:                             relDirPaths);
0:         checkHashCodeAndEquals(relDirPathPermissions,
0:                                relDirPathPermissions);
0:         checkImplies(relDirPathPermissions,
0:                      relDirPathPermissions);
1: 
1:         // test DatabasePermission on relative directory path aliases
0:         final DatabasePermission[] relDirPathAliasPermissions
1:             = new DatabasePermission[relDirPathAliases.length];
1:         for (int i = 0; i < relDirPathAliases.length; i++) {
0:             relDirPathAliasPermissions[i]
1:                 = new DatabasePermission(relDirPathAliases[i],
1:                                          DatabasePermission.CREATE);
1:         }
0:         checkNameAndActions(relDirPathAliasPermissions,
0:                             relDirPathAliases);
0:         checkHashCodeAndEquals(relDirPathPermissions,
0:                                relDirPathAliasPermissions);
0:         checkImplies(relDirPathPermissions,
0:                      relDirPathAliasPermissions);
1: 
1:         // test DatabasePermission on absolute directory paths
0:         final DatabasePermission[] absDirPathPermissions
1:             = new DatabasePermission[absDirPaths.length];
1:         for (int i = 0; i < absDirPaths.length; i++) {
0:             absDirPathPermissions[i]
1:                 = new DatabasePermission(absDirPaths[i],
1:                                          DatabasePermission.CREATE);
1:         }
0:         checkNameAndActions(absDirPathPermissions,
0:                             absDirPaths);
0:         checkHashCodeAndEquals(absDirPathPermissions,
0:                                absDirPathPermissions);
0:         checkImplies(absDirPathPermissions,
0:                      absDirPathPermissions);
1: 
1:         // test DatabasePermission on absolute directory path aliases
0:         final DatabasePermission[] absDirPathAliasPermissions
1:             = new DatabasePermission[absDirPathAliases.length];
1:         for (int i = 0; i < absDirPathAliases.length; i++) {
0:             absDirPathAliasPermissions[i]
1:                 = new DatabasePermission(absDirPathAliases[i],
1:                                          DatabasePermission.CREATE);
1:         }
0:         checkNameAndActions(absDirPathAliasPermissions,
0:                             absDirPathAliases);
0:         checkHashCodeAndEquals(absDirPathPermissions,
0:                                absDirPathAliasPermissions);
0:         checkImplies(absDirPathPermissions,
0:                      absDirPathAliasPermissions);
1:         
1: 
0:         // test DatabasePermission for authorized user against policy file
1:         execute(authorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[2]), true);
1:         execute(authorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[3]), true);
1:         execute(authorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[6]), false);
1:         execute(authorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[7]), true);
1: 
0:         // test DatabasePermission for unauthorized user against policy file
1:         execute(unAuthorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[2]), false);
1:         execute(unAuthorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[3]), false);
1:         execute(unAuthorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[6]), false);
1:         execute(unAuthorizedUser,
0:                 new CreateDatabaseAction(relDirPathPermissions[7]), false);
1:     }
1: 
1:     /**
0:      * Runs a privileges user action for a given principal.
1:      */
0:     private void execute(DatabasePrincipal principal,
0:                          PrivilegedExceptionAction action,
1:                          boolean isGrantExpected) {
0:         //System.out.println();
0:         //System.out.println("    testing action " + action);
0:         final RunAsPrivilegedUserAction runAsPrivilegedUserAction
0:             = new RunAsPrivilegedUserAction(principal, action);
1:         try {
1:             AccessController.doPrivileged(runAsPrivilegedUserAction);
0:             //System.out.println("    Congrats! access granted " + action);
1:             if (!isGrantExpected) {
1:                 fail("expected AccessControlException");
1:             }
0:         } catch (PrivilegedActionException pae) {
0:             //System.out.println("    Error: " + pae.getMessage());
0:             throw new RuntimeException(pae);
1:         } catch (AccessControlException ace) {
1:             if (isGrantExpected) {
0:                 fail("caught AccessControlException");
1:             }
0:             //System.out.println("    Yikes! " + ace.getMessage());
1:         }
1:     }
1:     
1:     /**
1:      * Tests DatabasePermission.getName() and .getActions().
1:      */
1:     private void checkNameAndActions(DatabasePermission[] dbperm,
1:                                      String[] dbpath)
1:         throws IOException {
1:         //assert(dpperm.length == dbpath.length)
1:         for (int i = 0; i < dbperm.length; i++) {
1:             final DatabasePermission dbp = dbperm[i];
1:             assertEquals("test: " + dbp + ".getName()",
1:                          dbpath[i], dbp.getName());
1:             assertEquals("test: " + dbp + ".getActions()",
1:                          DatabasePermission.CREATE, dbp.getActions());
1:         }
1:     }
1: 
1:     /**
1:      * Tests DatabasePermission.hashCode() and .equals().
1:      */
0:     private void checkHashCodeAndEquals(DatabasePermission[] dbp0,
0:                                         DatabasePermission[] dbp1)
1:         throws IOException {
1:         //assert(dbp0.length == dbp1.length)
1:         for (int i = 0; i < dbp0.length; i++) {
0:             final DatabasePermission p0 = dbp0[i];
1:             for (int j = 0; j < dbp0.length; j++) {
0:                 final DatabasePermission p1 = dbp1[j];
1:                 if (i == j) {
1:                     assertTrue(p0.hashCode() == p1.hashCode());
1:                     assertTrue(p0.equals(p1));
1:                 } else {
1:                     assertTrue(p0.hashCode() != p1.hashCode());
1:                     assertTrue(!p0.equals(p1));
1:                 }
1:             }
1:         }
1:     }
1:     
1:     /**
1:      * Tests DatabasePermission.implies().
1:      */
0:     private void checkImplies(DatabasePermission[] dbp0,
0:                               DatabasePermission[] dbp1)
1:         throws IOException {
1:         //assert(dbp0.length == dbp1.length)
1:         for (int i = 0; i < dbp0.length; i++) {
0:             final DatabasePermission p0 = dbp0[i];
1:             for (int j = 0; j < dbp0.length; j++) {
0:                 final DatabasePermission p1 = dbp1[j];
1:                 assertEquals("test: " + p0 + ".implies" + p1,
0:                              dirPathImplications[i][j], p0.implies(p1));
0:                 assertEquals("test: " + p1 + ".implies" + p0,
0:                              dirPathImplications[j][i], p1.implies(p0));
1:             }
1:         }
1:     }
1:     
1:     /**
0:      * Represents a Shutdown Engine action.
1:      */
0:     public class ShutdownEngineAction
0:         implements PrivilegedExceptionAction {
1:         protected final Permission permission;
1: 
0:         public ShutdownEngineAction(Permission permission) {
1:             this.permission = permission;
1:         }
1:     
0:         public Object run() throws Exception {
0:             //System.out.println("    checking access " + permission + "...");
1:             AccessController.checkPermission(permission);
0:             //System.out.println("    granted access " + this);
1:             return null;
1:         }
1: 
1:         public String toString() {
1:             return permission.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Represents a Create Database action.
1:      */
1:     public class CreateDatabaseAction
0:         implements PrivilegedExceptionAction {
1:         protected final Permission permission;
1: 
0:         public CreateDatabaseAction(Permission permission) throws IOException {
1:             this.permission = permission;
1:         }
1:     
0:         public Object run() throws Exception {
0:             //System.out.println("    checking access " + permission + "...");
1:             AccessController.checkPermission(permission);
0:             //System.out.println("    granted access " + this);
1:             return null;
1:         }
1: 
1:         public String toString() {
1:             return permission.toString();
1:         }
1:     }
1: 
1:     /**
1:      * Represents a Privileged User action.
1:      */
0:     public class RunAsPrivilegedUserAction
0:         implements PrivilegedExceptionAction {
0:         final private DatabasePrincipal principal;
0:         final private PrivilegedExceptionAction action;
1: 
0:         public RunAsPrivilegedUserAction(DatabasePrincipal principal,
0:                                          PrivilegedExceptionAction action) {
1:             this.principal = principal;
1:             this.action = action;
1:         }
1:         
0:         public Object run() throws PrivilegedActionException {
0:             final Set principalSet = new HashSet();
0:             final Set noPublicCredentials = new HashSet();
0:             final Set noPrivateCredentials = new HashSet();
0:             principalSet.add(principal);
0:             final Subject subject = new Subject(true, principalSet,
0:                                                 noPublicCredentials,
0:                                                 noPrivateCredentials);
1:         
0:             // Subject.doAs(subject, action) not strong enough
0:             //System.out.println("    run doAsPrivileged() as " + principal
0:             //                   + "...");
0:             Subject.doAsPrivileged(subject, action, null);
1:             return null;
1:         }
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ce9c46e
/////////////////////////////////////////////////////////////////////////
0:         
0:         if (SecurityManagerSetup.JVM_HAS_SUBJECT_AUTHORIZATION)
1:         {
1:             suite.addTest(new SecurityManagerSetup(
0:                 new SystemPrivilegesPermissionTest("policyTestSystemGrants"),
0:                 POLICY_FILE_NAME));
1:         }
1:         return suite;
/////////////////////////////////////////////////////////////////////////
1:     }
0:     
0:     public void policyTestSystemGrants() {
commit:356ff6f
/////////////////////////////////////////////////////////////////////////
0:         
1:         String[] validNames = {
1:             SystemPermission.ENGINE,
1:             SystemPermission.JMX,
1:             SystemPermission.SERVER
1:         };
0:         
1:         // In order of the canonical actions expected
1:         String[] validActions = {
1:             SystemPermission.CONTROL,
1:             SystemPermission.MONITOR,
1:             SystemPermission.SHUTDOWN,
1:         };
0:         
1:         // Check all valid combinations (which is all) with
1:         // a single action
1:         Permission[] all = new Permission[
1:                         validNames.length * validActions.length];
0:         
1:         int c = 0;
1:         for (int tn = 0; tn < validNames.length; tn++)
1:         {
1:             for (int a = 0; a < validActions.length; a++) {
1:                 Permission p = new SystemPermission(
1:                         validNames[tn], validActions[a]);
0:                 
1:                 assertEquals(validNames[tn], p.getName());
1:                 assertEquals(validActions[a], p.getActions());
0:                 
0:                 // test SystemPermission.equals()
1:                 assertFalse(p.equals(null));
1:                 assertFalse(p.equals(new Object()));
0:                 
1:                 this.assertEquivalentPermissions(p, p);
1:                 all[c++] = p;
1:             }
1:         }
1:         // All the permissions are different.
1:         checkDistinctPermissions(all);
0:         
1:         // Check two actions
1:         for (int n = 0; n < validNames.length; n++)
1:         {
1:             for (int a = 0; a < validActions.length; a++)
1:             {
1:                 Permission base = new SystemPermission(
1:                         validNames[n], validActions[a]);
0:                 
1:                 // Two actions
1:                 for (int oa = 0; oa < validActions.length; oa++)
1:                 {
1:                     Permission p = new SystemPermission(
1:                             validNames[n],                           
1:                             validActions[a] + "," + validActions[oa]);
0:                     
1:                     if (oa == a)
1:                     {
1:                         // Same action added twice
1:                         assertEquivalentPermissions(base, p);
1:                         // Canonical form should collapse into a single action
1:                         assertEquals(validActions[a], p.getActions());
1:                     }
1:                     else
1:                     {
1:                         // Implies logic, the one with one permission
1:                         // is implied by the other but not vice-versa.
1:                         assertTrue(p.implies(base));
1:                         assertFalse(base.implies(p));
0:                         
1:                         // Names in canonical form
1:                         int f;
1:                         int s;
1:                         if (oa < a)
1:                         {
1:                             f = oa;
1:                             s = a;
1:                         }
1:                         else
1:                         {
1:                             f = a;
1:                             s = oa;
1:                         }
1:                         if (oa < a)
1:                         assertEquals(validActions[f] + "," + validActions[s],
1:                                 p.getActions());
1:                     }
1:                 }
0:                 
0:                 
0:                 
1:             }
1:         }
0:         
0:         Permission shutdown = new SystemPermission(
1:                 SystemPermission.SERVER,
1:                 SystemPermission.SHUTDOWN);
0:         
1:         execute(authorizedUser, new ShutdownAction(shutdown), true);
1:         execute(unAuthorizedUser, new ShutdownAction(shutdown), false);
/////////////////////////////////////////////////////////////////////////
1:      * Check thet a set of Permission objects are distinct,
1:      * do not equal or imply each other.
0:      */
1:     private void checkDistinctPermissions(Permission[] set)
1:     {
1:         for (int i = 0; i < set.length; i++)
1:         {
1:             Permission pi = set[i];
1:             for (int j = 0; j < set.length; j++) {
0:                 
1:                 Permission pj = set[j];
0:                 
1:                 if (i == j)
1:                 {
1:                     // Permission is itself
1:                     assertEquivalentPermissions(pi, pj);
1:                     continue;
1:                 }
0:                 
1:                 assertFalse(pi.equals(pj));
1:                 assertFalse(pj.equals(pi));
0:                 
1:                 assertFalse(pi.implies(pj));
1:                 assertFalse(pj.implies(pi));
1:             }
1:         }
1:     }
0:     
1:     private void assertEquivalentPermissions(Permission p1,
1:             Permission p2) {
1:         assertTrue(p1.equals(p2));
1:         assertTrue(p2.equals(p1));
0:         
0:         
1:         assertEquals(p1.hashCode(), p2.hashCode());
0:         
1:         assertTrue(p1.implies(p2));
1:         assertTrue(p1.implies(p2));
1:     }
0:     
0:     /**
commit:13b0113
/////////////////////////////////////////////////////////////////////////
0: //import org.apache.derby.security.DatabasePermission;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite(
0:                 SystemPrivilegesPermissionTest.class,
0:                 "SystemPrivilegesPermissionTest");
0:          return new SecurityManagerSetup(suite, POLICY_FILE_NAME);
0:     public void testIsSecurityManager() {
0:      }
1:     public void testSystemPrincipal() {
/////////////////////////////////////////////////////////////////////////
1:     public void testSystemPermission() {
/////////////////////////////////////////////////////////////////////////
0:    
0:     public void XXtestDatabasePermission() throws IOException {
0:  /*********************************************
/////////////////////////////////////////////////////////////////////////
0: ***********************************************/
0:         
/////////////////////////////////////////////////////////////////////////
0: /**********************************************
/////////////////////////////////////////////////////////////////////////
0: ***********************************************/
/////////////////////////////////////////////////////////////////////////
0: /************88
/////////////////////////////////////////////////////////////////////////
0: ***************/
1:     private void checkHashCodeAndEquals(Permission[] dbp0,
1:                                         Permission[] dbp1)
1:             final Permission p0 = dbp0[i];
1:                 final Permission p1 = dbp1[j];
/////////////////////////////////////////////////////////////////////////
1:     private void checkImplies(Permission[] dbp0,
1:                               Permission[] dbp1,
1:             final Permission p0 = dbp0[i];
1:                 final Permission p1 = dbp1[j];
commit:5917694
/////////////////////////////////////////////////////////////////////////
1:             new SystemPermission(null, null);
/////////////////////////////////////////////////////////////////////////
1:             new SystemPermission("", null);
/////////////////////////////////////////////////////////////////////////
1:             new SystemPermission("illegal_name", null);
0:         final Permission sp0 = new SystemPermission(
0:                 SystemPermission.SERVER, SystemPermission.SHUTDOWN);
0:         final Permission sp1 = new SystemPermission(
0:                 SystemPermission.SERVER, SystemPermission.SHUTDOWN);
0:         assertEquals(sp0.getName(), SystemPermission.SERVER);
0:         assertEquals(sp0.getActions(), SystemPermission.SHUTDOWN);
commit:c0052e0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.authentication.SystemPrincipal;
0: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.error.StandardException;
/////////////////////////////////////////////////////////////////////////
1:      * For instance, dirPathImpls[1][2] shows the expected value for:
/////////////////////////////////////////////////////////////////////////
1:     static private final boolean[][] dirPathImpls = {
/////////////////////////////////////////////////////////////////////////
0:         final Test undecorated = new SystemPrivilegesPermissionTest(method);
0:         return new SecurityManagerSetup(undecorated, POLICY_FILE_NAME);
/////////////////////////////////////////////////////////////////////////
0:         println("");
0:         println("testing System Privileges ...");
0:         println("testing System Privileges: done.");
0:         println("");
0:         checkSystemPrincipal();
1:      * Tests SystemPrincipal.
0:     private void checkSystemPrincipal() throws IOException {
1:         // test SystemPrincipal with null name argument
1:             new SystemPrincipal(null);
1:         // test SystemPrincipal with empty name argument
1:             new SystemPrincipal("");
/////////////////////////////////////////////////////////////////////////
1:         final SystemPrincipal authorizedUser
1:             = new SystemPrincipal("authorizedSystemUser");
0:         execute(authorizedUser, new ShutdownAction(sp0), true);
1:         final SystemPrincipal unAuthorizedUser
1:             = new SystemPrincipal("unAuthorizedSystemUser");
0:         execute(unAuthorizedUser, new ShutdownAction(sp0), false);
/////////////////////////////////////////////////////////////////////////
1:         // this test's commented out because it's platform-dependent
1:         // (no reliable way to make it pass on Unix)
1:         //try {
1:         //    //new DatabasePermission("directory:.*/\\:///../",
1:         //    //                       DatabasePermission.CREATE);
1:         //    new DatabasePermission("directory:\n/../../../.*/\\:///../",
1:         //                           DatabasePermission.CREATE);
1:         //    fail("expected IOException");
1:         //} catch (IOException ex) {
1:         //    // expected exception
1:         //}
/////////////////////////////////////////////////////////////////////////
1:         final DatabasePermission[] relDirPathPerms
1:             relDirPathPerms[i]
1:         checkNameAndActions(relDirPathPerms, relDirPaths);
1:         checkHashCodeAndEquals(relDirPathPerms, relDirPathPerms);
1:         checkImplies(relDirPathPerms, relDirPathPerms, dirPathImpls);
1:         final DatabasePermission[] relDirPathAliasPerms
1:             relDirPathAliasPerms[i]
1:         checkNameAndActions(relDirPathAliasPerms, relDirPathAliases);
1:         checkHashCodeAndEquals(relDirPathPerms, relDirPathAliasPerms);
1:         checkImplies(relDirPathPerms, relDirPathAliasPerms, dirPathImpls);
1:         checkImplies(relDirPathAliasPerms, relDirPathPerms, dirPathImpls);
1:         final DatabasePermission[] absDirPathPerms
1:             absDirPathPerms[i]
1:         checkNameAndActions(absDirPathPerms, absDirPaths);
1:         checkHashCodeAndEquals(absDirPathPerms, absDirPathPerms);
1:         checkImplies(absDirPathPerms, absDirPathPerms, dirPathImpls);
1:         final DatabasePermission[] absDirPathAliasPerms
1:             absDirPathAliasPerms[i]
1:         checkNameAndActions(absDirPathAliasPerms, absDirPathAliases);
1:         checkHashCodeAndEquals(absDirPathPerms, absDirPathAliasPerms);
1:         checkImplies(absDirPathPerms, absDirPathAliasPerms, dirPathImpls);
1:         checkImplies(absDirPathAliasPerms, absDirPathPerms, dirPathImpls);
1:         // test DatabasePermission for the inclusive path specification
1:         final String inclPermissionUrl = "directory:<<ALL FILES>>";
1:         final DatabasePermission[] inclPerms
1:             = { new DatabasePermission(inclPermissionUrl,
1:                                        DatabasePermission.CREATE) };
1:         checkNameAndActions(inclPerms,
1:                             new String[]{ inclPermissionUrl });
1:         final DatabasePermission[] inclPerms1
1:             = { new DatabasePermission(inclPermissionUrl,
1:                                        DatabasePermission.CREATE) };
1:         checkHashCodeAndEquals(inclPerms, inclPerms1);
1:         checkImplies(inclPerms, inclPerms1, new boolean[][]{ { true } });
1:         final boolean[][] allTrue = new boolean[1][dirPaths.length];
1:         for (int j = 0; j < dirPaths.length; j++) {
1:             allTrue[0][j] = true;
0:         }
1:         final boolean[][] allFalse = new boolean[dirPaths.length][1];
1:         for (int i = 0; i < dirPaths.length; i++) {
1:             allFalse[i][0] = false;
0:         }
1:         checkImplies(inclPerms, relDirPathPerms, allTrue);
1:         checkImplies(relDirPathPerms, inclPerms, allFalse);
1:         checkImplies(inclPerms, relDirPathAliasPerms, allTrue);
1:         checkImplies(relDirPathAliasPerms, inclPerms, allFalse);
1:         checkImplies(inclPerms, absDirPathPerms, allTrue);
1:         checkImplies(absDirPathPerms, inclPerms, allFalse);
1:         checkImplies(inclPerms, absDirPathAliasPerms, allTrue);
1:         checkImplies(absDirPathAliasPerms, inclPerms, allFalse);
1:         // test DatabasePermission for unauthorized, authorized, and
0:         // all-authorized users against policy file
1:         final int[] singleLocPaths = { 2, 3, 6, 7 };
1:         final SystemPrincipal authorizedUser
1:             = new SystemPrincipal("authorizedSystemUser");
1:         final SystemPrincipal unAuthorizedUser
1:             = new SystemPrincipal("unAuthorizedSystemUser");
1:         final SystemPrincipal superUser
1:             = new SystemPrincipal("superUser");
1:         for (int i = 0; i < singleLocPaths.length; i++) {
1:             final int j = singleLocPaths[i];
0:             execute(unAuthorizedUser,
1:                     new CreateDatabaseAction(relDirPathPerms[j]), false);
0:             execute(authorizedUser,
1:                     new CreateDatabaseAction(relDirPathPerms[j]), (j != 6));
1:             execute(superUser,
1:                     new CreateDatabaseAction(relDirPathPerms[j]), true);
0:         }
0:         // test DatabasePermission for any user against policy file
1:         final SystemPrincipal anyUser
1:             = new SystemPrincipal("anyUser");
/////////////////////////////////////////////////////////////////////////
1:      * Runs a privileged user action for a given principal.
0:     private void execute(SystemPrincipal principal,
0:                          PrivilegedAction action,
1:         //println();
1:         //println("    testing action " + action);
0:         
1:             //println("    Congrats! access granted " + action);
1:             //println("    Yikes! " + ace.getMessage());
1:                 //fail("caught AccessControlException");
1:                 throw ace;
/////////////////////////////////////////////////////////////////////////
0:                               DatabasePermission[] dbp1,
1:                               boolean[][] impls)
1:             for (int j = 0; j < dbp1.length; j++) {
1:                              impls[i][j], p0.implies(p1));
1:                 //assertEquals("test: " + p1 + ".implies" + p0,
1:                 //             impls[j][i], p1.implies(p0));
1:      * Represents a Shutdown server and engine action.
1:     public class ShutdownAction
0:         implements PrivilegedAction {
1:         public ShutdownAction(Permission permission) {
0:         public Object run() {
1:             //println("    checking access " + permission + "...");
1:             //println("    granted access " + this);
/////////////////////////////////////////////////////////////////////////
0:         implements PrivilegedAction {
1:         public CreateDatabaseAction(Permission permission) {
0: 
0:         public Object run() {
1:             //println("    checking access " + permission + "...");
1:             //println("    granted access " + this);
/////////////////////////////////////////////////////////////////////////
1:      * Returns the Authorization Identifier for a principal name.
0:      *
1:      * @param name the name of the principal
1:      * @return the authorization identifier for this principal
0:      */
1:     static private String getAuthorizationId(String name) {
1:         // RuntimeException messages not localized
1:         if (name == null) {
1:             throw new NullPointerException("name can't be null");
0:         }
1:         if (name.length() == 0) {
1:             throw new IllegalArgumentException("name can't be empty");
0:         }
0:         try {
1:             return IdUtil.getUserAuthorizationId(name);
1:         } catch (StandardException se) {
1:             throw new IllegalArgumentException(se.getMessage());
0: 		}
0:     }
0: 
0:     /**
0:     static public class RunAsPrivilegedUserAction
0:         implements PrivilegedAction {
1:         final private SystemPrincipal principal;
0:         final private PrivilegedAction action;
1:         public RunAsPrivilegedUserAction(SystemPrincipal principal,
0:                                          PrivilegedAction action) {
0:         public Object run() {
1:             final boolean readOnly = true;
0:             final Set principals = new HashSet();
1:             final Set publicCredentials = new HashSet();
1:             final Set privateCredentials = new HashSet();
1:             principals.add(principal);
1:             // also add a principal with the "normalized" name for testing
1:             // authorization ids
1:             final String normalized = getAuthorizationId(principal.getName());
1:             principals.add(new SystemPrincipal(normalized));
1:             final Subject subject = new Subject(readOnly,
1:                                                 principals,
1:                                                 publicCredentials,
1:                                                 privateCredentials);
0: 
1:             // check subject's permission with a fresh AccessControlContext,
1:             // not the thread's current one (Subject.doAs(subject, action))
1:             // println("    run doAsPrivileged() as " + principal + "...");
1:             // The alternative approach to use Subject.doAs(subject, action)
1:             // instead of Subject.doAsPrivileged(subject, action, null) has
1:             // issues: there are subtile differences between these methods
1:             // regarding the checking of the caller's protection domain.  To
1:             // make doAs() work, the shutdown/createDatabase permissions must
1:             // be granted to the codebase (class RunAsPrivilegedUserAction).
1:             // This, however, defeats the purpose since everyone now's granted
1:             // permission.  In contrast, doAsPrivileged() with a null ACC
1:             // seems to effectively ignore the caller's protection domain, so
1:             // the check now only depends on the principal's permissions.
1:             //Subject.doAs(subject, action);
============================================================================