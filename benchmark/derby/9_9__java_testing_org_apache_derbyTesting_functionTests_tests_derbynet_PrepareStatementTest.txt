1:433b42c: /*
1:433b42c: 
1:433b42c:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.PrepareStatementTest
1:433b42c: 
1:433b42c:    Licensed to the Apache Software Foundation (ASF) under one or more
1:433b42c:    contributor license agreements.  See the NOTICE file distributed with
1:433b42c:    this work for additional information regarding copyright ownership.
1:433b42c:    The ASF licenses this file to You under the Apache License, Version 2.0
1:433b42c:    (the "License"); you may not use this file except in compliance with
1:433b42c:    the License.  You may obtain a copy of the License at
1:433b42c: 
1:433b42c:       http://www.apache.org/licenses/LICENSE-2.0
1:433b42c: 
1:433b42c:    Unless required by applicable law or agreed to in writing, software
1:433b42c:    distributed under the License is distributed on an "AS IS" BASIS,
1:433b42c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:433b42c:    See the License for the specific language governing permissions and
1:433b42c:    limitations under the License.
1:433b42c: 
1:433b42c:  */
1:433b42c: 
1:433b42c: package org.apache.derbyTesting.functionTests.tests.derbynet;
1:433b42c: 
1:1ae02c9: import java.io.ByteArrayInputStream;
1:1ae02c9: import java.io.DataInputStream;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.io.InputStreamReader;
1:1ae02c9: import java.math.BigDecimal;
1:4469400: import java.math.RoundingMode;
1:433b42c: import java.sql.BatchUpdateException;
1:b850119: import java.sql.CallableStatement;
1:b850119: import java.sql.DataTruncation;
1:433b42c: import java.sql.Date;
1:433b42c: import java.sql.PreparedStatement;
1:433b42c: import java.sql.ResultSet;
1:433b42c: import java.sql.SQLException;
1:b850119: import java.sql.SQLWarning;
1:433b42c: import java.sql.Statement;
1:433b42c: import java.sql.Time;
1:433b42c: import java.sql.Timestamp;
1:b850119: import java.sql.Types;
1:433b42c: import java.util.Arrays;
1:433b42c: import junit.framework.Test;
1:ecef2eb: import org.apache.derbyTesting.functionTests.util.Formatters;
1:7062abe: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:433b42c: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:0cfef0d: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:433b42c: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:433b42c: 
1:433b42c: /**
1:4769df5:  * This Junit test class tests the JDBC PreparedStatement.  This test
1:4769df5:  * is a Junit version of the old prepStmt.java test.  That test tested
1:4769df5:  * prepared statements in client/server context, and many of the test
1:4769df5:  * cases is specifically testing corner cases in client/server
1:4769df5:  * communication.  However, this Junit test is set up to run as part
1:4769df5:  * of both the embedded and client/server test suites.
1:433b42c:  */
1:433b42c: 
1:433b42c: public class PrepareStatementTest extends BaseJDBCTestCase
3:433b42c: {
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Creates a new instance of PrepareStatementTest
1:433b42c:      *
1:433b42c:      * @param name name of the test.
1:433b42c:      */
1:433b42c:     public PrepareStatementTest(String name)
1:433b42c:     {
1:433b42c:         super(name);
1:433b42c:     }
1:7062abe: 
1:433b42c: 
1:7062abe:     /**
1:433b42c:      * Adds this class to the default suite.  That is, all test cases will be
1:433b42c:      * run in both embedded and client/server.
1:433b42c:      */
1:433b42c:     public static Test suite()
1:0cfef0d:     {
1:4ea33cf:         if ( JDBC.vmSupportsJSR169())
1:4ea33cf:             // see DERBY-2233 for details
1:1ae02c9:                         return new BaseTestSuite(
1:1ae02c9:                 "empty PrepareStatementTest - client not supported on JSR169");
1:53d6497:         else
1:0cfef0d:         {
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite("PrepareStatementTest");
1:0cfef0d:             suite.addTest(TestConfiguration.defaultSuite(PrepareStatementTest.class));
1:0cfef0d:             suite.addTest(TestConfiguration.clientServerDecorator(
1:0cfef0d:                 TestConfiguration.connectionCPDecorator(new CleanDatabaseTestSetup(
1:1ae02c9:                     new BaseTestSuite(PrepareStatementTest.class)))));
1:0cfef0d:             return suite;
1:0cfef0d:         }
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test basic prepare mechanism with executeUpdate and executeQuery with
1:433b42c:      * and without simple parameters.
1:433b42c:      */
1:433b42c:     public void testBasicPrepare() throws Exception
1:433b42c:     {
1:433b42c:         // executeUpdate() without parameters
1:433b42c:         PreparedStatement pSt
1:433b42c:             = prepareStatement("create table t1(c1 int, c2 int, c3 int)");
1:433b42c:         assertUpdateCount(pSt, 0);
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // Rows to be inserted in table t1 for this test
1:433b42c:         final Integer[][] t1_rows = {
1:39b3237:             {99, 5, 9},
1:39b3237:             {2, 6, 10},
1:39b3237:             {7, 5, 8}
1:433b42c:         };
1:433b42c: 
1:433b42c:         // executeUpdate() with parameters
1:433b42c:         pSt = prepareStatement("insert into t1 values (?, " + t1_rows[0][1]
1:433b42c:                                + ", ?)");
1:433b42c:         pSt.setInt(1, t1_rows[0][0].intValue());
1:433b42c:         pSt.setInt(2, t1_rows[0][2].intValue());
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // execute() with parameters, no result set returned
1:433b42c:         pSt = prepareStatement("insert into t1 values (" + t1_rows[1][0] + ", "
1:433b42c:                                + t1_rows[1][1] + ", ?), (?, " + t1_rows[2][1]
1:433b42c:                                + ", " + t1_rows[2][2] + ")");
1:433b42c:         pSt.setInt(1, t1_rows[1][2].intValue());
1:433b42c:         pSt.setInt(2, t1_rows[2][0].intValue());
1:433b42c:         boolean hasResultSet = pSt.execute();
1:433b42c:         while (hasResultSet)
1:433b42c:         {
1:433b42c:             ResultSet rs = pSt.getResultSet();
1:433b42c:             assertFalse(rs.next());
1:433b42c:             rs.close();
1:433b42c:             hasResultSet = pSt.getMoreResults();
1:433b42c:         }
1:433b42c:         assertEquals(2, pSt.getUpdateCount());
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // executeQuery() without parameters
1:433b42c:         pSt = prepareStatement("select * from t1");
1:433b42c:         ResultSet rs = pSt.executeQuery();
1:433b42c:         JDBC.assertFullResultSet(rs, t1_rows, false);
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // Create table with subset of rows to be selected in query below
1:433b42c:         Integer[][] t1filter_rows = new Integer[2][];
1:433b42c:         for (int i=0, j=0; i < t1_rows.length; ++i) {
1:433b42c:             if (t1_rows[i][1].intValue() == 5) {
1:433b42c:                 t1filter_rows[j++] = t1_rows[i];
1:433b42c:             }
1:433b42c:         }
1:433b42c: 
1:433b42c:         // executeQuery() with parameters
1:433b42c:         pSt = prepareStatement("select * from t1 where c2 = ?");
1:433b42c:         pSt.setInt(1, 5);
1:433b42c:         rs = pSt.executeQuery();
1:433b42c:         JDBC.assertFullResultSet(rs, t1filter_rows, false);
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // execute() with parameters, with result set returned
1:433b42c:         pSt = prepareStatement("select * from t1 where c2 = ?");
1:433b42c:         pSt.setInt(1, 5);
1:433b42c:         assertTrue(pSt.execute());
1:433b42c:         rs = pSt.getResultSet();
1:433b42c:         JDBC.assertFullResultSet(rs, t1filter_rows, false);
1:433b42c:         rs.close();
1:433b42c:         assertFalse(pSt.getMoreResults());
1:433b42c:         assertEquals(-1, pSt.getUpdateCount());
1:433b42c:         pSt.close();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:c6e4294:     /**
1:433b42c:      * Tests different data types for input parameters of a PreparedStatement.
1:433b42c:      */
1:433b42c:     public void testParameterTypes() throws Exception
1:433b42c:     {
1:433b42c:         PreparedStatement pSt = prepareStatement(
1:433b42c:             "create table t2(si smallint,i int, bi bigint, r real, f float, "
1:433b42c:             + "d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), "
1:433b42c:             + "ch20 char(20),vc varchar(20), lvc long varchar, "
1:433b42c:             + "b20 char(23) for bit data, vb varchar(23) for bit data, "
1:433b42c:             + "lvb long varchar for bit data,  dt date, tm time, "
1:433b42c:             + "ts timestamp not null)");
1:433b42c:         assertUpdateCount(pSt, 0);
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // byte array for binary values.
1:433b42c:         byte[] ba = new byte[] { 0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,
1:433b42c:                                  0xb,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13 };
1:433b42c: 
1:433b42c:         byte[] bapad = new byte[23];  // For padded byte data
1:433b42c:         System.arraycopy(ba, 0, bapad, 0, ba.length);
1:433b42c:         // Pad with space!!!
1:433b42c:         Arrays.fill(bapad, ba.length, bapad.length, (byte )0x20);
1:433b42c: 
1:433b42c:         // Values to be inserted
1:433b42c:         Object[][] t2_rows = {
1:39b3237:             {1, 2, 3L, 4.0F,
1:39b3237:              5.0, 6.0, new BigDecimal("77.77"),
1:433b42c:              new BigDecimal("8.100"), "column9string       ",
1:433b42c:              "column10vcstring", "column11lvcstring", bapad, ba, ba,
1:433b42c:              Date.valueOf("2002-04-12"), Time.valueOf("11:44:30"),
1:433b42c:              Timestamp.valueOf("2002-04-12 11:44:30.000000000")},
1:39b3237:             {1, 2, 3L, 4.0F,
1:39b3237:              5.0, 6.0, new BigDecimal("77.77"),
1:433b42c:              new BigDecimal("8.100"), "column11string      ",
1:433b42c:              "column10vcstring", "column11lvcstring", bapad, ba, ba,
1:433b42c:              Date.valueOf("2002-04-12"), Time.valueOf("11:44:30"),
1:433b42c:              Timestamp.valueOf("2002-04-12 11:44:30.000000000")},
1:433b42c:             {null, null, null, null, null, null, null, null, null, null, null,
1:433b42c:              null, null, null, null, null,
1:433b42c:              Timestamp.valueOf("2002-04-12 11:44:31.000000000")}
1:433b42c:         };
1:433b42c: 
1:433b42c: 
1:433b42c:         pSt = prepareStatement(
1:433b42c:             "insert into t2 values (?, ?, ?, ?,  ?, ?, ?, ?, ?, ?, ?, ?, ?, "
1:433b42c:             + "?, ? ,? , ?)");
1:433b42c:         pSt.setShort(1, ((Integer )t2_rows[0][0]).shortValue());
1:433b42c:         pSt.setInt(2, ((Integer )t2_rows[0][1]).intValue());
1:39b3237:         pSt.setLong(3, ((Long)t2_rows[0][2]).longValue());
1:433b42c:         pSt.setFloat(4, ((Float )t2_rows[0][3]).floatValue());
1:433b42c:         pSt.setDouble(5, ((Double )t2_rows[0][4]).doubleValue());
1:433b42c:         pSt.setDouble(6, ((Double )t2_rows[0][5]).doubleValue());
1:433b42c:         pSt.setBigDecimal(7, (BigDecimal )t2_rows[0][6]);
1:433b42c:         pSt.setBigDecimal(8, new BigDecimal("8.1")); // Diff. precision
1:433b42c:         pSt.setString(9, "column9string");  // Without padding
1:433b42c:         byte[] c10ba = ((String )t2_rows[0][9]).getBytes("UTF-8");
1:433b42c:         int len = c10ba.length;
1:433b42c:         pSt.setAsciiStream(10, new ByteArrayInputStream(c10ba), len);
1:433b42c:         byte[] c11ba = ((String )t2_rows[0][10]).getBytes("UTF-8");
1:433b42c:         len = c11ba.length;
1:433b42c:         pSt.setCharacterStream(11, new InputStreamReader
1:433b42c:                                (new ByteArrayInputStream(c11ba),"UTF-8"),len);
1:433b42c:         pSt.setBytes(12, ba);
1:433b42c:         pSt.setBinaryStream(13, new ByteArrayInputStream(ba), ba.length);
1:433b42c:         pSt.setBytes(14, ba);
1:433b42c:         pSt.setDate(15, ((Date )t2_rows[0][14]));
1:433b42c:         pSt.setTime(16, ((Time )t2_rows[0][15]));
1:433b42c:         pSt.setTimestamp(17, ((Timestamp )t2_rows[0][16]));
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c: 
1:433b42c:         // test setObject on different datatypes of the input parameters of
1:433b42c:         // PreparedStatement
1:433b42c:         for (int i=0; i<17; ++i) {
1:433b42c:             pSt.setObject(i+1, t2_rows[1][i]);
1:433b42c:         }
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c: 
1:433b42c:         // test setNull on different datatypes of the input parameters of
1:433b42c:         // PreparedStatement
1:433b42c:         pSt.setNull(1, java.sql.Types.SMALLINT);
1:433b42c:         pSt.setNull(2, java.sql.Types.INTEGER);
1:433b42c:         pSt.setNull(3, java.sql.Types.BIGINT);
1:433b42c:         pSt.setNull(4, java.sql.Types.REAL);
1:433b42c:         pSt.setNull(5, java.sql.Types.FLOAT);
1:433b42c:         pSt.setNull(6, java.sql.Types.DOUBLE);
1:433b42c:         pSt.setNull(7, java.sql.Types.NUMERIC);
1:433b42c:         pSt.setNull(8, java.sql.Types.DECIMAL);
1:433b42c:         pSt.setNull(9, java.sql.Types.CHAR);
1:433b42c:         pSt.setNull(10, java.sql.Types.VARCHAR);
1:433b42c:         pSt.setNull(11, java.sql.Types.LONGVARCHAR);
1:433b42c:         pSt.setNull(12, java.sql.Types.BINARY);
1:433b42c:         pSt.setNull(13, java.sql.Types.VARBINARY);
1:433b42c:         pSt.setNull(14, java.sql.Types.LONGVARBINARY);
1:433b42c:         pSt.setNull(15, java.sql.Types.DATE);
1:433b42c:         pSt.setNull(16, java.sql.Types.TIME);
1:433b42c: 
1:433b42c:         pSt.setTimestamp(17, ((Timestamp )t2_rows[2][16]));
1:433b42c:         assertFalse(pSt.execute());
1:433b42c:         assertEquals(1, pSt.getUpdateCount());
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         pSt = prepareStatement("select * from t2");
1:433b42c:         ResultSet rs = pSt.executeQuery();
1:433b42c:         JDBC.assertFullResultSet(rs, t2_rows, false);
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         // negative test cases with no parameters set
1:433b42c:         try {
1:433b42c:             pSt = prepareStatement("select * from t2 where i = ?");
1:433b42c:             rs = pSt.executeQuery();
1:433b42c:             fail("Exception expected above!");
1:433b42c:         } catch (SQLException e) {
1:433b42c:             assertSQLState("07000", e);
1:433b42c:         }
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c: 
1:433b42c:         try {
1:433b42c:             pSt = prepareStatement(
1:433b42c:                 "insert into t2 values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, "
1:433b42c:                 + "?, ?, ?, ?, ?)");
1:433b42c:             pSt.executeUpdate();
1:433b42c:             fail("Exception expected above!");
1:433b42c:         } catch (SQLException e) {
1:433b42c:             assertSQLState("07000", e);
1:433b42c:         }
1:433b42c:         pSt.close();
1:433b42c: 
1:5e3c874:         // Some test cases for DERBY-2558, involving validation of the
1:5e3c874:         // parameterIndex argument to the 4-argument overload of setObject
1:5e3c874:         //
1:5e3c874:         pSt = prepareStatement("create table d2558 (i int)");
1:5e3c874:         assertUpdateCount(pSt, 0);
1:5e3c874:         pSt.close();
1:5e3c874:         pSt = prepareStatement("insert into d2558 values (3), (4)");
1:5e3c874:         assertUpdateCount(pSt, 2);
1:5e3c874:         pSt.close();
1:5e3c874:         pSt = prepareStatement("select * from d2558 where i = ?");
1:39b3237:         pSt.setObject(1,3,java.sql.Types.INTEGER,0);
1:5e3c874:         try {
1:5e3c874:             // There's only 1 parameter marker, so this should fail:
1:39b3237:             pSt.setObject(2,4, java.sql.Types.INTEGER,0);
1:5e3c874:             rs = pSt.executeQuery();
1:5e3c874:             rs.close();
1:5e3c874:             fail("Exception expected above!");
1:5e3c874:         } catch (SQLException e) {
1:53d6497:             assertSQLState("XCL13", e);
1:433b42c:         }
1:5e3c874:         pSt.close();
1:433b42c: 
2:53d6497:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test prepared statements with a large number of input parameters.
1:433b42c:      */
1:433b42c:     public void testBigTable() throws Exception
1:433b42c:     {
1:433b42c:         int tabSize = 1000;
1:433b42c:         StringBuffer createBigTabSql
1:433b42c:             = new StringBuffer("create table bigtab (");
1:433b42c:         for (int i = 1; i <= tabSize; ++i) {
1:433b42c:             createBigTabSql.append("c");
1:433b42c:             createBigTabSql.append(i);
1:433b42c:             createBigTabSql.append(" int");
1:433b42c:             createBigTabSql.append((i != tabSize) ? ", " : " )");
1:433b42c:         }
1:433b42c: 
1:433b42c:         PreparedStatement pSt = prepareStatement(createBigTabSql.toString());
1:433b42c:         assertUpdateCount(pSt, 0);
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         insertTab("bigtab", 50);
1:433b42c:         insertTab("bigtab", 200);
1:433b42c:         insertTab("bigtab", 300);
1:433b42c:         insertTab("bigtab", 500);
1:433b42c:         // prepared Statement with many  params (bug 4863)
1:433b42c:         insertTab("bigtab", 1000);
1:433b42c:         selectFromBigTab();
1:433b42c: 
1:433b42c:         // Negative Cases
1:433b42c:         try {
1:433b42c:             insertTab("bigtab", 1001);
1:433b42c:             fail("Exception expected above!");
1:433b42c:         } catch (SQLException e) {
1:433b42c:             assertSQLState("42X14", e);
1:433b42c:         }
1:433b42c:         // this one will give a sytax error
1:433b42c:         try {
1:433b42c:             insertTab("bigtab", 0);
1:433b42c:             fail("Exception expected above!");
1:433b42c:         } catch (SQLException e) {
1:433b42c:             assertSQLState("42X01", e);
1:433b42c:         }
1:433b42c:         // table doesn't exist
1:433b42c:         try {
1:433b42c:             insertTab("wrongtab",1000);
1:433b42c:             fail("Exception expected above!");
1:433b42c:         } catch (SQLException e) {
1:433b42c:             assertSQLState("42X05", e);
1:433b42c:         }
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Insert 1 row with the given number of columns into the given table.
1:433b42c:      * It is assumed that the table has numCols, named c1, c2, ...
1:433b42c:      * This is a helper method for the testBigTable test case.
1:433b42c:      *
1:433b42c:      * @param tabName Table name
1:433b42c:      * @param numCols Number of columns in table.
1:433b42c:      */
1:433b42c:     private void insertTab(String tabName, int numCols)
1:433b42c:         throws SQLException
1:433b42c:     {
1:433b42c:         StringBuffer insertSql
1:433b42c:             = new StringBuffer("insert into " + tabName + "(");
1:433b42c:         for (int i = 1; i <= numCols; ++i)
1:433b42c:         {
1:433b42c:             insertSql.append(" c");
1:4769df5:             insertSql.append(i);
1:433b42c:             insertSql.append((i != numCols) ? ", " : ")");
1:433b42c:         }
1:433b42c:         insertSql.append("  values (");
1:433b42c:         for (int i = 1; i <= numCols; ++i)
1:433b42c:         {
1:433b42c:             insertSql.append("?");
1:433b42c:             insertSql.append((i != numCols) ? ", " : " )");
1:433b42c:         }
1:433b42c: 
1:433b42c:         PreparedStatement pSt = prepareStatement(insertSql.toString());
1:433b42c:         for (int i = 1; i <= numCols; ++i) {
1:433b42c:             pSt.setInt(i, i);
1:433b42c:         }
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c:         pSt.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test that the table bigtab contains the expected tuples for the test
1:433b42c:      * case testBigTable.
1:433b42c:      */
1:433b42c:     private void selectFromBigTab() throws SQLException
1:433b42c:     {
1:433b42c:         String selectSQL = "select * from bigtab";
1:433b42c:         PreparedStatement pSt = prepareStatement(selectSQL);
1:433b42c:         ResultSet rs = pSt.executeQuery();
1:433b42c: 
1:433b42c:         int i = 0;
1:433b42c:         while (rs.next())
1:433b42c:         {
1:433b42c:             switch(++i) {
1:433b42c:                 case 1:
1:433b42c:                 case 2:
1:433b42c:                 case 3:
1:433b42c:                     assertNull(rs.getObject(500));
1:433b42c:                     assertNull(rs.getObject(1000));
1:433b42c:                     break;
1:433b42c:                 case 4:
1:433b42c:                     assertEquals(rs.getInt(500), 500);
1:433b42c:                     assertNull(rs.getObject(1000));
1:433b42c:                     break;
1:433b42c:                 case 5:
1:433b42c:                     assertEquals(rs.getInt(500), 500);
1:433b42c:                     assertEquals(rs.getInt(1000), 1000);
1:433b42c:                     break;
1:433b42c:                 default:
1:433b42c:                     fail("Too many rows in bigTab");
1:433b42c:             }
1:433b42c:         }
1:433b42c:         assertEquals(i, 5);
1:433b42c: 
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Check that values are preserved when BigDecimal values
1:433b42c:      * which have more than 31 digits are converted to Double
1:433b42c:      * with setObject.
1:433b42c:      */
1:433b42c:     public void testBigDecimalSetObject() throws SQLException
1:433b42c:     {
1:433b42c:         getConnection().setAutoCommit(false);
1:433b42c:         String sql = "CREATE TABLE doubletab (i int, doubleVal DOUBLE)";
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         assertUpdateCount(stmt, 0, sql);
1:433b42c:         stmt.close();
1:433b42c:         commit();
1:433b42c: 
1:433b42c:         // Insert various double values
1:433b42c:         double[] doubleVals = {1.0E-130, 1.0E125, 0, -1.0E124};
1:433b42c:         BigDecimal[] bigDecimalVals =
1:433b42c:             { new BigDecimal(1.0E-130),
1:433b42c:               new BigDecimal(1.0E125),
1:433b42c:               new BigDecimal(-1.0E124),
1:433b42c:               new BigDecimal("12345678901234567890123456789012"),
1:433b42c:               new BigDecimal("1.2345678901234567890123456789012")
1:433b42c:         };
1:433b42c: 
1:433b42c:         String isql = "INSERT INTO doubletab VALUES (?, ?)";
1:433b42c:         PreparedStatement insPs = prepareStatement(isql);
1:433b42c:         String ssql = "SELECT doubleVal FROM doubletab";
1:433b42c:         PreparedStatement selPs = prepareStatement(ssql);
1:433b42c:         String dsql = "DELETE FROM doubletab";
1:433b42c:         PreparedStatement delPs = prepareStatement(dsql);
1:433b42c:         for (int i = 0; i < bigDecimalVals.length; ++i)
1:433b42c:         {
1:433b42c:             BigDecimal bd = bigDecimalVals[i];
1:433b42c:             insPs.setInt(1,i);
1:433b42c:             insPs.setObject(2,bd,java.sql.Types.DOUBLE);
1:433b42c:             assertUpdateCount(insPs, 1);
1:433b42c:             // Check Value
1:433b42c:             ResultSet rs = selPs.executeQuery();
1:433b42c:             rs.next();
1:433b42c:             assertEquals(bd.doubleValue(), rs.getDouble(1), 0.0);
1:433b42c:             rs.close();
1:433b42c:             // Clear out the table;
1:433b42c:             assertUpdateCount(delPs, 1);
1:433b42c:         }
1:433b42c:         insPs.close();
1:433b42c:         selPs.close();
1:433b42c:         delPs.close();
1:433b42c:         commit();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test BigDecimal with scale as parameter.
1:433b42c:      */
1:433b42c:     public void testBigDecimalSetObjectWithScale() throws Exception
1:433b42c:     {
1:433b42c:         getConnection().setAutoCommit(false);
1:433b42c:         String sql = "CREATE TABLE numtab (num NUMERIC(10,6))";
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         assertUpdateCount(stmt, 0, sql);
1:433b42c:         stmt.close();
1:433b42c:         commit();
1:433b42c: 
1:433b42c:         // make a big decimal from string
1:433b42c:         BigDecimal bdFromString = new BigDecimal("2.33333333");
1:433b42c: 
1:433b42c:         sql = "INSERT INTO  numtab  VALUES(?)";
1:433b42c:         PreparedStatement ps =  prepareStatement(sql);
1:433b42c:         // setObject using the big decimal value
1:433b42c:         int scale = 2;
1:433b42c:         ps.setObject(1, bdFromString, java.sql.Types.DECIMAL, scale);
1:433b42c:         assertUpdateCount(ps, 1);
1:433b42c:         ps.close();
1:433b42c:         // check the value
1:433b42c:         sql = "SELECT num FROM numtab";
1:433b42c:         stmt = createStatement();
1:433b42c:         ResultSet rs = stmt.executeQuery(sql);
1:433b42c:         rs.next();
1:433b42c:         // Check that the correct scale was set
1:433b42c:         BigDecimal expected
1:4469400:             = bdFromString.setScale(scale, RoundingMode.DOWN);
1:433b42c:         BigDecimal actual = (BigDecimal)rs.getObject(1);
1:433b42c:         assertEquals("Actual value: " + actual
1:433b42c:                      + "does not match expected value: " + expected,
1:433b42c:                      expected.compareTo(actual), 0);
1:433b42c:         rs.close();
1:433b42c:         stmt.close();
1:433b42c: 
1:433b42c:         commit();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test execution of batch update where the type of
1:433b42c:      * a parameter varies for difference entries in the batch.
1:433b42c:      */
1:433b42c:      public void testVaryingClientParameterTypeBatch() throws Exception
1:433b42c:      {
1:433b42c:          Statement stmt = createStatement();
1:433b42c:          String createSql
1:433b42c:              = "create table varcharclobtab (c1 varchar(100), c2 clob)";
1:433b42c:          assertUpdateCount(stmt, 0, createSql);
1:433b42c:          stmt.close();
1:433b42c: 
1:433b42c:          PreparedStatement pStmt
1:433b42c:              = prepareStatement("insert into varcharclobtab VALUES(?,?)");
1:433b42c: 
1:433b42c:          pStmt.setNull(1, java.sql.Types.VARCHAR);
1:433b42c:          pStmt.setString(2, "clob");
1:433b42c:          pStmt.addBatch();
1:433b42c: 
1:433b42c:          pStmt.setString(1, "varchar");
1:433b42c:          pStmt.setNull(2, java.sql.Types.CLOB);
1:433b42c:          pStmt.addBatch();
1:433b42c: 
1:433b42c:          // The following statement should not throw an exception.
1:433b42c:          pStmt.executeBatch();
1:433b42c: 
1:433b42c:          pStmt.close();
1:433b42c:      }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test small (close to 0) BigDecimal parameters.
1:433b42c:      */
1:433b42c:     public void testSmallBigDecimal() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         String createTableSQL
1:433b42c:             = "create table Numeric_Tab (MAX_VAL NUMERIC(30,15), MIN_VAL "
1:433b42c:             + "NUMERIC(30,15), NULL_VAL NUMERIC(30,15) DEFAULT NULL)";
1:433b42c:         // to create the Numeric Table
1:433b42c:         assertUpdateCount(stmt, 0, createTableSQL);
1:433b42c: 
1:433b42c:         String insertSQL
1:433b42c:             = "insert into Numeric_Tab "
1:433b42c:             + "values(999999999999999, 0.000000000000001, null)";
1:433b42c:         assertUpdateCount(stmt, 1, insertSQL);
1:433b42c: 
1:433b42c:         //to extract the Maximum Value of BigDecimal to be Updated
1:433b42c:         String sminBigDecimalVal = "0.000000000000001";
1:433b42c:         BigDecimal minBigDecimalVal = new BigDecimal(sminBigDecimalVal);
1:433b42c: 
1:433b42c:         // to update Null value column with Minimum value
1:433b42c:         String sPrepStmt = "update Numeric_Tab set NULL_VAL=?";
1:433b42c: 
1:433b42c:         // Uncomment and prepare the below statement instead to see JCC bug on
1:433b42c:         // setObject for decimal
1:433b42c:         // String sPrepStmt ="update Numeric_Tab set NULL_VAL="
1:433b42c:         //                    + sminBigDecimalVal +" where 0.0 != ?";
1:433b42c: 
1:433b42c:         // get the PreparedStatement object
1:433b42c:         PreparedStatement pstmt = prepareStatement(sPrepStmt);
1:433b42c:         pstmt.setObject(1, minBigDecimalVal);
1:433b42c:         pstmt.executeUpdate();
1:433b42c:         pstmt.close();
1:433b42c: 
1:433b42c:         //to query from the database to check the call of pstmt.executeUpdate
1:433b42c:         //to get the query string
1:433b42c:         String Null_Val_Query = "Select NULL_VAL from Numeric_Tab";
1:433b42c:         ResultSet rs = stmt.executeQuery(Null_Val_Query);
1:433b42c:         rs.next();
1:433b42c: 
1:433b42c:         BigDecimal rBigDecimalVal = (BigDecimal )rs.getObject(1);
1:433b42c:         assertEquals(rBigDecimalVal, minBigDecimalVal);
1:433b42c:         rs.close();
1:433b42c:         stmt.close();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test creation and execution of many Prepared Statements.
1:433b42c:      * (Beetle 5130).
1:433b42c:      */
1:433b42c:     public void testManyPreparedStatements () throws Exception
1:433b42c:     {
1:433b42c:         int numOfPreparedStatement = 500;
1:433b42c:         PreparedStatement[] tempPreparedStatement
1:433b42c:             = new PreparedStatement[numOfPreparedStatement];
1:433b42c: 
1:433b42c:         for (int i = 0; i < numOfPreparedStatement; ++i) {
1:433b42c:             tempPreparedStatement[i] = getConnection()
1:433b42c:                 .prepareStatement("SELECT COUNT(*) from SYS.SYSTABLES",
1:433b42c:                                    ResultSet.TYPE_SCROLL_INSENSITIVE,
1:433b42c:                                    ResultSet.CONCUR_READ_ONLY);
1:433b42c:             ResultSet rs = tempPreparedStatement[i].executeQuery();
1:433b42c:             rs.close();
1:433b42c:         }
1:433b42c:         for (int i = 0; i < numOfPreparedStatement; ++i) {
1:433b42c:             tempPreparedStatement[i].close();
1:433b42c:         }
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test invalid Timestamp parameters.
1:433b42c:      */
1:433b42c:     public void testInvalidTimestamp() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         assertUpdateCount(stmt, 0,
1:433b42c:                           "CREATE TABLE TSTAB "
1:433b42c:                           + "(I int, STATUS_TS  Timestamp, "
1:433b42c:                           + " PROPERTY_TS Timestamp)" );
1:433b42c:         assertUpdateCount(stmt, 1,
1:433b42c:                           "INSERT INTO TSTAB "
1:433b42c:                           + "VALUES(1 , '2003-08-15 21:20:00',"
1:433b42c:                           + "       '2003-08-15 21:20:00')");
1:433b42c:         assertUpdateCount(stmt, 1,
1:433b42c:                           "INSERT INTO TSTAB "
1:433b42c:                           + "VALUES(2 ,'1969-12-31 16:00:00.0',"
1:433b42c:                           + "       '2003-08-15 21:20:00')");
1:433b42c:         stmt.close();
1:433b42c: 
1:433b42c:         String timestamp = "20";
1:433b42c:         String query =
1:433b42c:             "select STATUS_TS from TSTAB "
1:433b42c:             + "where  (STATUS_TS >= ? or PROPERTY_TS < ?)";
1:433b42c: 
1:433b42c:         PreparedStatement ps = prepareStatement(query);
1:433b42c:         try {
1:433b42c:             // Embedded will fail in setString
1:433b42c:             // Client/server will fail in executeQuery
1:433b42c:             ps.setString(1, timestamp);
1:433b42c:             ps.setString(2, timestamp);
1:433b42c:             ResultSet rs = ps.executeQuery();
1:433b42c:             rs.close();
1:433b42c:             fail("Exception expected above!");
1:433b42c:         }
1:433b42c:         catch (SQLException e) {
1:433b42c:             assertSQLState("22007", e);
1:433b42c:         }
1:433b42c:         ps.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:ecef2eb:      * <p>
1:ecef2eb:      * Regression test for DERBY-614. The test consists of two parts:
1:ecef2eb:      * </p>
1:ecef2eb:      *
1:ecef2eb:      * <p>
1:ecef2eb:      * <b>Part 1:</b>
1:433b42c:      * Test how the server responds when the client closes the statement in
1:433b42c:      * between split QRYDTA blocks. We have to cause a split QRYDTA block,
1:433b42c:      * which we can do by having a bunch of moderately-sized rows which mostly
1:433b42c:      * fill a 32K block followed by a single giant row which overflows the
1:433b42c:      * block. Then, we fetch some of the rows, then close the result set.
1:ecef2eb:      * </p>
1:ecef2eb:      *
1:ecef2eb:      * <p>
1:ecef2eb:      * <b>Part 2:</b>
1:ecef2eb:      * Verifies that the server-side statement state is cleaned up when a
1:ecef2eb:      * statement is re-used. Specifically, we set up a statement which has a
1:ecef2eb:      * non-null splitQRYDTA value, then we close that statement and re-use it
1:ecef2eb:      * for a totally unrelated query. If the splitQRYDTA wasn't cleaned up
1:ecef2eb:      * properly, it comes flooding back as the response to that unrelated
1:ecef2eb:      * query, causing a protocol parsing exception on the client.
1:ecef2eb:      * </p>
1:433b42c:      */
1:433b42c:     public void testSplitQRYDTABlock() throws Exception
1:433b42c:     {
1:ecef2eb:         // Part 1:
1:ecef2eb: 
1:433b42c:         PreparedStatement ps
1:433b42c:             = prepareStatement("create table jira614 (c1 varchar(10000))");
1:433b42c:         assertUpdateCount(ps, 0);
1:433b42c:         ps.close();
1:433b42c: 
1:ecef2eb:         String workString = Formatters.repeatChar("a", 150);
1:433b42c:         ps = prepareStatement("insert into jira614 values (?)");
1:433b42c:         ps.setString(1, workString);
1:433b42c:         for (int row = 0; row < 210; ++row) ps.executeUpdate();
1:433b42c: 
1:ecef2eb:         workString = Formatters.repeatChar("b", 10000);
1:433b42c:         ps.setString(1, workString);
1:433b42c:         ps.executeUpdate();
1:433b42c:         ps.close();
1:433b42c: 
1:433b42c:         ps = prepareStatement("select * from jira614");
1:433b42c:         ResultSet rs = ps.executeQuery();
1:433b42c: 
2:433b42c:         int rowNum = 0;
1:433b42c:         while (rs.next()) {
1:433b42c:             if (++rowNum == 26) break;
1:433b42c:         }
1:433b42c:         rs.close(); // This statement actually triggers the bug.
1:433b42c:         ps.close();
1:433b42c: 
1:ecef2eb:         // Part 2:
1:433b42c: 
1:433b42c:         // 1: set up a second table to use for an unrelated query:
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table jira614_a (c1 int)");
1:433b42c: 
1:ecef2eb:         ps = prepareStatement("insert into jira614_a values (?)");
1:433b42c:         for (int row = 1; row <= 5; ++row)
1:433b42c:         {
1:433b42c:             ps.setInt(1, row);
1:433b42c:             ps.executeUpdate();
1:433b42c:         }
1:433b42c: 
1:433b42c:         // 2: get the first statement into a splitQRYDTA state:
1:ecef2eb:         rs = stmt.executeQuery("select * from jira614");
1:ecef2eb:         rowNum = 0;
1:433b42c:         while (rs.next())
1:433b42c:         {
1:433b42c:             if (++rowNum == 26) break;
1:433b42c:         }
1:433b42c: 
1:433b42c:         // 3: Now re-use the statement for some totally different purpose:
1:433b42c:         stmt.close();
1:433b42c:         stmt = createStatement();
1:433b42c:         rs = stmt.executeQuery("select * from jira614_a");
1:433b42c:         while (rs.next());
1:433b42c:         ps.close();
1:433b42c:         rs.close();
1:433b42c:         stmt.close();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test how the server handles re-synchronization of
1:433b42c:      * the data stream when an enormous parameter value follows a failed
1:433b42c:      * prepare statement. Note that it is deliberate here that we are
1:433b42c:      * preparing a statement referring to a non-existing table.
1:433b42c:      * (This is a test case for Jira-170)
1:433b42c:      */
1:433b42c:     public void testExcpetionWithBigParameter() throws Exception
1:433b42c:     {
1:433b42c:         // Create a huge array of chars to be used as the input parameter
1:433b42c:         char []cData = new char[1000000];
1:433b42c:         for (int i = 0; i < cData.length; ++i) {
1:433b42c:             cData[i] = Character.forDigit(i%10, 10);
1:433b42c:         }
1:433b42c: 
1:433b42c:         // The behavior of this test program depends on how the JDBC driver
1:433b42c:         // handles statement prepares. The DB2 Universal JDBC driver
1:433b42c:         // implements something called "deferred prepares" by default. This
1:433b42c:         // means that it doesn't do the prepare of the statement until the
1:433b42c:         // statement is actually executed. Other drivers, such as the
1:433b42c:         // standard Derby client driver, do the prepare at the time of the
1:433b42c:         // prepare. This means that, depending on which driver we're using
1:433b42c:         // and what the driver's configuration is, we'll get the "table not
1:433b42c:         // found" error either on the prepare or on the execute. It doesn't
1:433b42c:         // really matter for the purposes of the test, because the whole
1:433b42c:         // point is that we *dont* get a DRDA Protocol Exception, but rather
1:433b42c:         // a table-not-found exception.
1:433b42c:         PreparedStatement ps = null ;
1:433b42c:         try {
1:433b42c:             ps = prepareStatement("insert into jira170 values (?)");
1:433b42c:             ps.setString(1, new String(cData));
1:433b42c:             ps.execute();
1:433b42c:             ps.close();
1:433b42c:             fail("No exception when executing a failed prepare with "
1:433b42c:                  + "an enormous parameter");
1:433b42c:         } catch (SQLException e) { // Should get "Table not Found"
1:433b42c:             assertSQLState("42X05", e);
1:433b42c:         }
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test the proper use of continuation headers for very large reply
1:433b42c:      * messages, such as the SQLDARD which is returned for a prepared
1:433b42c:      * statement with an enormous number of parameter markers. This test
1:433b42c:      * generates a multi-segment SQLDARD response message from the server, to
1:433b42c:      * verify that the code in DDMWriter.finalizeDSSLength is executed.
1:433b42c:      *
1:433b42c:      * Repro for DERBY-125 off-by-one error.  This repro runs in
1:433b42c:      * two iterations.  The first iteration, we use a table name
1:433b42c:      * and a column name that are extra long, so that the server-
1:433b42c:      * side buffer has more data in it.  The second iteration, we
1:433b42c:      * use simpler names for the table and column, which take up
1:433b42c:      * less space in the server buffer.  Then, since the server-
1:433b42c:      * side bytes array was previously used for a larger amount of
1:433b42c:      * data, then the unused bytes contain old data.  Since we
1:433b42c:      * intentionally put the "larger amount of data" into the buffer
1:433b42c:      * during the first iteration, we know what the old data bytes
1:433b42c:      * are going to be.  Thus, by using specific lengths for the
1:433b42c:      * table and column names, we can 'shift' the old data until we
1:433b42c:      * reach a point where the off-by-one error manifests itself:
1:433b42c:      * namely, we end up incorrectly leaving a non-zero data byte
1:433b42c:      * in the last position of the current server buffer, which
1:433b42c:      * is wrong.
1:433b42c:      */
1:433b42c:     public void testLargeReplies() throws Exception
1:433b42c:     {
1:433b42c:         jira125Test_a();
1:433b42c:         jira125Test_b();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * First iteration of testLargeReplies test case.
1:433b42c:      */
1:433b42c:     private void jira125Test_a() throws Exception
1:433b42c:     {
1:433b42c:         // Build a column name that is 99 characters long;
1:433b42c:         // the length of the column name and the length of
1:433b42c:         // the table name are important to the repro--so
1:433b42c:         // do not change these unless you can confirm that
1:433b42c:         // the new values will behave in the same way.
1:433b42c:         StringBuffer id = new StringBuffer();
1:433b42c:         for (int i = 0; i < 49; ++i) id.append("id");
1:433b42c:         id.append("i");
1:433b42c: 
1:433b42c:         // Build a table name that is 97 characters long;
1:433b42c:         // the length of the column name and the length of
1:433b42c:         // the table name are important to the repro--so
1:433b42c:         // do not change these unless you can confirm that
1:433b42c:         // the new values will behave in the same way.
1:433b42c:         StringBuffer tabName = new StringBuffer("jira");
1:433b42c:         for (int i = 0; i < 31; ++i) tabName.append("125");
1:433b42c: 
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table " + tabName.toString() + " (" +
1:433b42c:                      id.toString() + " integer)");
1:433b42c:         stmt.execute("insert into " + tabName.toString() + " values 1, 2, 3");
1:433b42c:         stmt.close();
1:433b42c: 
3:433b42c:         StringBuffer buf = new StringBuffer();
1:433b42c:         buf.append("SELECT " + id.toString() + " FROM " +
1:433b42c:                    tabName.toString() + " WHERE " + id.toString() + " IN ( ");
1:433b42c: 
1:433b42c:         // Must have at least 551 columns here, in order to force
1:433b42c:         // server buffer beyond 32k.  NOTE: Changing this number
1:433b42c:         // could cause the test to "pass" even if a regression
1:433b42c:         // occurs--so only change it if needed!
1:433b42c:         int nCols = 554;
1:433b42c:         for (int i = 0; i < nCols; ++i) buf.append("?,");
1:433b42c:         buf.append("?)");
1:433b42c:         PreparedStatement ps = prepareStatement(buf.toString());
1:433b42c:         // Note that we actually have nCols+1 parameter markers
1:433b42c:         for (int i = 0; i <= nCols; i++) ps.setInt(i+1, 1);
1:433b42c:         ResultSet rs = ps.executeQuery();
1:433b42c:         while (rs.next());
1:433b42c:         rs.close();
1:433b42c:         ps.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Second iteration of testLargeReplies test case.
1:433b42c:      */
1:433b42c:     private void jira125Test_b() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table jira125 (id integer)");
1:433b42c:         stmt.execute("insert into jira125 values 1, 2, 3");
1:433b42c: 
1:433b42c:         StringBuffer buf = new StringBuffer();
1:433b42c:         buf.append("SELECT id FROM jira125 WHERE id IN ( ");
1:433b42c: 
1:433b42c:         // Must have at least 551 columns here, in order to force
1:433b42c:         // server buffer beyond 32k.  NOTE: Changing this number
1:433b42c:         // could cause the test to "pass" even if a regression
1:433b42c:         // occurs--so only change it if needed!
1:433b42c:         int nCols = 556;
1:433b42c:         for (int i = 0; i < nCols; i++) buf.append("?,");
1:433b42c:         buf.append("?)");
1:433b42c:         PreparedStatement ps = prepareStatement(buf.toString());
1:433b42c:         // Note that we actually have nCols+1 parameter markers
1:433b42c:         for (int i = 0; i <= nCols; i++) ps.setInt(i+1, 1);
1:433b42c:         ResultSet rs = ps.executeQuery();
1:433b42c:         while (rs.next());
1:433b42c:         rs.close();
1:433b42c:         ps.close();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * This test case ensures that the bug introduced by the first patch for
1:433b42c:      * Jira-815 has not been re-introduced.  The bug resulted in a hang if a
1:433b42c:      * prepared statement was first executed with a lob value, and then
1:433b42c:      * re-executed with a null-value in place of the lob.
1:433b42c:      */
1:433b42c:     public void testAlternatingLobValuesAndNull()  throws Exception
1:433b42c:     {
1:433b42c:         getConnection().setAutoCommit(false);
1:433b42c:         Statement st = createStatement();
1:433b42c:         st.execute("create table tt1 (CLICOL01 smallint not null)");
1:433b42c:         st.execute("alter table tt1 add clicol02 smallint");
1:433b42c:         st.execute("alter table tt1 add clicol03 int not null default 1");
1:433b42c:         st.execute("alter table tt1 add clicol04 int");
1:433b42c:         st.execute("alter table tt1 add clicol05 decimal(10,0) not null default 1");
1:433b42c:         st.execute("alter table tt1 add clicol51 blob(1G)");
1:433b42c:         st.execute("alter table tt1 add clicol52 blob(50)");
1:433b42c:         st.execute("alter table tt1 add clicol53 clob(2G) not null default ''");
1:433b42c:         st.execute("alter table tt1 add clicol54 clob(60)");
1:433b42c:         commit();
1:433b42c: 
1:433b42c:         PreparedStatement pSt =
1:433b42c:             prepareStatement("insert into tt1 values (?,?,?,?,?,?,?,?,?)");
1:433b42c:         pSt.setShort(1, (short)500);
1:433b42c:         pSt.setShort(2, (short)501);
1:433b42c:         pSt.setInt(3, 496);
1:433b42c:         pSt.setInt(4, 497);
1:433b42c:         pSt.setDouble(5, 484);
1:433b42c:         pSt.setBytes(6, "404 bit".getBytes());
1:433b42c:         pSt.setBytes(7, "405 bit".getBytes());
1:433b42c:         pSt.setString(8, "408 bit");
1:433b42c:         pSt.setString(9, "409 bit");
1:433b42c: 
1:433b42c:         // Inserting first row
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c: 
1:433b42c:         pSt.setNull(2, java.sql.Types.SMALLINT);
1:433b42c:         pSt.setNull(4, java.sql.Types.DOUBLE);
1:433b42c:         pSt.setNull(7, java.sql.Types.BLOB);
1:433b42c:         pSt.setNull(9, java.sql.Types.CLOB);
1:433b42c: 
1:433b42c:         // Inserting second row
1:433b42c:         assertUpdateCount(pSt, 1);
1:433b42c: 
1:433b42c:         // Now inserting 3rd row, using lobs from 1st row
1:433b42c:         ResultSet rs = st.executeQuery("select * from tt1");
1:433b42c:         rs.next();
1:433b42c:         pSt.setShort(1, rs.getShort(1));
1:433b42c:         pSt.setShort(2, rs.getShort(2));
1:433b42c:         pSt.setInt(3, rs.getInt(3));
1:433b42c:         pSt.setInt(4, rs.getInt(4));
1:433b42c:         pSt.setDouble(5, rs.getDouble(5));
1:433b42c:         pSt.setBlob(6, rs.getBlob(6));
1:433b42c:         pSt.setBlob(7, rs.getBlob(7));
1:433b42c:         pSt.setClob(8, rs.getClob(8));
1:433b42c:         pSt.setClob(9, rs.getClob(9));
1:433b42c:         pSt.execute();
1:433b42c: 
1:433b42c:         // Now inserting 4th row, using lobs from 2nd row
1:433b42c:         rs.next();
1:433b42c:         pSt.setNull(2, java.sql.Types.SMALLINT);
1:433b42c:         pSt.setNull(4, java.sql.Types.DOUBLE);
1:433b42c:         pSt.setBlob(6, rs.getBlob(6));
1:433b42c:         pSt.setNull(7, java.sql.Types.BLOB);
1:433b42c:         pSt.setClob(8, rs.getClob(8));
1:433b42c:         pSt.setNull(9, java.sql.Types.CLOB);
1:433b42c:         pSt.execute();
1:433b42c: 
1:433b42c:         rs.close();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         commit();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test large batch sizes for Statement.addBatch and
1:433b42c:      * Statement.executeBatch.  (This is a test for Jira 428.) Currently,
1:433b42c:      * there is a hard DRDA limit of 65535 statements per batch (prior to
1:433b42c:      * DERBY-428, the server failed at around 9000 statements). The different
1:433b42c:      * JDBC clients support slightly lower limits: the Network Client supports
1:433b42c:      * 65534 statements in a single batch, the DB2JCC driver v2.4 supports
1:433b42c:      * 65532 statements, the DB2JCC driver v2.6 supports 32765 statements.
1:433b42c:      * This test just verifies that a batch of 32765 statements works, and
1:433b42c:      * that a batch of 100000 statements gets a BatchUpdateException from the
1:433b42c:      * Network Client.
1:433b42c:      */
1:433b42c:     public void testLargeBatch() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table jira428 (i integer)");
1:433b42c:         getConnection().setAutoCommit(false);
1:433b42c: 
1:433b42c:         PreparedStatement ps
1:433b42c:             = prepareStatement("insert into jira428 values (?)");
1:433b42c:         for (int i = 0; i < 32765; ++i) {
1:433b42c:             ps.setInt(1, i);
1:433b42c:             ps.addBatch();
1:433b42c:         }
1:433b42c:         ps.executeBatch();
1:433b42c:         ps.close();
1:433b42c:         commit();
1:433b42c: 
1:433b42c:         // The below cannot be run as part of the test for the JCC client
1:433b42c:         // because the exception forces the connection closed. For
1:433b42c:         // DerbyNetClient, it's a clean exception that we can catch and
1:433b42c:         // recover from, so we test that code path:
1:433b42c:         ps = prepareStatement("insert into jira428 values (?)");
1:433b42c:         for (int i = 0; i < 100000; ++i) {
1:433b42c:             ps.setInt(1, i);
1:433b42c:             ps.addBatch();
1:433b42c:         }
1:433b42c:         try {
1:433b42c:             ps.executeBatch();
1:433b42c:             assertFalse("Expected exception when >65534 statements per batch",
1:433b42c:                         usingDerbyNetClient());
1:433b42c:         } catch (BatchUpdateException bue) {
1:433b42c:             assertSQLState("XJ116", bue);
1:433b42c:             assertFalse("Unexpected exception in embedded framework",
1:433b42c:                         usingEmbedded());
1:433b42c:         }
1:433b42c:         ps.close();
1:433b42c:         commit();
1:433b42c:     }
1:433b42c: 
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test for an off-by-one bug in the splitQRYDTA processing in the Network
1:433b42c:      * Server writeQRYDTA code (Jira-1454), and is related to previous bugs
1:433b42c:      * 614, 170, 491, and 492. The issue is that if the DSS block is exactly
1:433b42c:      * the maximum DSS length (32767), then the writeQRYDTA code erroneously
1:433b42c:      * thinks the DSS needs to be split when in fact it doesn't.
1:433b42c:      *
1:433b42c:      * The repro case sets up the boundary scenario; we run the case three
1:433b42c:      * times, once with the value 1 less than the max DSS, once with the
1:433b42c:      * value 1 greater than the max DSS, and once with the exact DSS length.
1:433b42c:      * Only the third case triggers the JIRA-1454 bug; the other two tests
1:433b42c:      * are for completeness.
1:433b42c:      */
1:433b42c:     public void testDSSLength() throws Exception
1:433b42c:     {
1:433b42c:         // Create table to be used in this test case
1:433b42c:         Statement st = createStatement();
1:433b42c:         st.execute(
1:433b42c:             "create table jira1454(c1 varchar(20000), c2 varchar(30000))");
1:433b42c:         st.close();
1:433b42c: 
1:433b42c:         tickleDSSLength(12748);
1:433b42c:         tickleDSSLength(12750);
1:433b42c:         tickleDSSLength(12749);
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Helper method for testDSSLength test case.  Inserts a record into a
1:433b42c:      * table, and reads the content of the table before the content is
1:433b42c:      * deleted.  (I.e., the table will empty when the method returns.  Use the
1:433b42c:      * given length for the second parameter to the insert statement to test
1:433b42c:      * different sizes for DSS blocks.
1:433b42c:      *
1:433b42c:      * @param c2Len Length to be used for the second
1:433b42c:      */
1:433b42c:     private void tickleDSSLength(int c2Len) throws Exception
1:433b42c:     {
1:433b42c:         char[] c1 = new char[20000];
1:433b42c:         for (int i = 0; i < c1.length; ++i) {
1:433b42c:             c1[i] = Character.forDigit(i%10, 10);
1:433b42c:         }
1:433b42c:         char[] c2 = new char[30000];
1:433b42c:         for (int i = 0; i < c2Len; ++i) {
1:433b42c:             c2[i] = Character.forDigit(i%10, 10);
1:433b42c:         }
1:433b42c: 
1:433b42c:         PreparedStatement pSt =
1:433b42c:             prepareStatement("insert into jira1454 values (?,?)");
1:433b42c:         pSt.setString(1, new String(c1));
1:433b42c:         pSt.setString(2, new String(c2, 0, c2Len));
1:433b42c:         pSt.execute();
1:433b42c:         pSt.close();
1:433b42c: 
1:433b42c:         Statement st = createStatement();
1:433b42c:         ResultSet rs = st.executeQuery("select * from jira1454");
1:433b42c:         while (rs.next()) {
1:433b42c:             assertEquals(rs.getString("c2").length(), c2Len);
1:433b42c:         }
1:433b42c:         rs.close();
1:433b42c: 
1:433b42c:         // Clean up so table can be reused
1:433b42c:         st.execute("delete from jira1454");
1:433b42c:         st.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:53d6497:      * A test case for DERBY-3046
1:53d6497:      * We were running into null pointer exception if the parameter count
1:53d6497:      * for PreparedStatement was 0 and the user tried doing setObject
1:433b42c:      * 
1:53d6497:      * @throws Exception
1:433b42c:      */
1:53d6497:     public void testVariationOfSetObject() throws Exception
1:433b42c:     {
1:53d6497:         Statement stmt = createStatement();
1:53d6497:         String createString = "CREATE TABLE WISH_LIST  "
1:53d6497:         	+  "(WISH_ID INT NOT NULL GENERATED ALWAYS AS IDENTITY " 
1:53d6497:         	+  "   CONSTRAINT WISH_PK PRIMARY KEY, " 
1:53d6497:         	+  " ENTRY_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
1:53d6497:         	+  " WISH_ITEM VARCHAR(32) NOT NULL) " ;
1:433b42c:         
1:53d6497:         stmt.executeUpdate(createString);
1:53d6497:         PreparedStatement ps = prepareStatement("insert into WISH_LIST(WISH_ITEM) values (?)");
1:53d6497:         //this won't raise any errors because there is one parameter in ps
1:53d6497:         ps.setString(1, "aaa");
1:53d6497:         ps.executeUpdate();
1:433b42c:         
1:53d6497:         //Negative test case. There are no parameter in the following ps
1:53d6497:         ps = prepareStatement("insert into WISH_LIST(WISH_ITEM) values ('bb')");
1:53d6497:         //Try setString when no parameters in ps
1:53d6497:         try {
1:53d6497:         	ps.setString(1, "aaa");
1:53d6497:             fail("Exception expected above!");
1:53d6497:         } catch (SQLException e)  {  
2:53d6497:         	if (usingDerbyNetClient())
1:53d6497:         		//note that SQLState is XCL14. For setObject below, the 
1:53d6497:         		//SQLState is XCL13. I have entered DERBY-3139 for this
2:53d6497:         		//difference in SQLState.
1:53d6497:         		assertSQLState("XCL14", e);
1:53d6497:         	else
2:53d6497:         		assertSQLState("07009", e);
1:433b42c:         }
1:53d6497:         //Try setObject when no parameters in ps
1:53d6497:         try {
1:53d6497:         	ps.setObject(1,"cc",java.sql.Types.VARCHAR); 
1:53d6497:             fail("Exception expected above!");
1:53d6497:         } catch (SQLException e)  {   
1:7bee3c6:     		assertSQLState("07009", e);
1:433b42c:         }
1:53d6497:     }
1:433b42c: 
1:433b42c:     /**
1:433b42c:      * Test two different bugs regarding the handling of large
1:433b42c:      * amounts of parameter data: first, the Network Server was incorrectly
1:433b42c:      * handling the desegmentation of continued DSS segments, and second,
1:433b42c:      * the Network Server was using the wrong heuristic to determine whether
1:433b42c:      * long string data was being flowed in-line or externalized (Jira 1533).
1:433b42c:      *
1:433b42c:      * Tests "a" and "b" provoke two different forms of this problem, one
1:433b42c:      * with just a single continued segment, and one with several continuations
1:433b42c:      */
1:433b42c:     public void testLargeParameters_a() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table jira1533_a ("
1:433b42c:                      + "aa BIGINT NOT NULL, "
1:433b42c:                      + "bbbbbb BIGINT DEFAULT 0 NOT NULL,"
1:433b42c:                      + "cccc  VARCHAR(40), ddddddddddd BIGINT, "
1:433b42c:                      + "eeeeee VARCHAR(128), ffffffffffffffffff VARCHAR(128),"
1:433b42c:                      + "ggggggggg  BLOB(2G), hhhhhhhhh VARCHAR(128), "
1:433b42c:                      + "iiiiiiii VARCHAR(128), jjjjjjjjjjjjjj BIGINT,"
1:433b42c:                      + "kkkkkkkk CHAR(1) DEFAULT 'f', "
1:433b42c:                      + "llllllll CHAR(1) DEFAULT 'f', "
1:433b42c:                      + "mmmmmmmmmmmmm  CHAR(1) DEFAULT 'f')");
1:433b42c:          stmt.close();
1:433b42c: 
1:433b42c:          PreparedStatement ps = prepareStatement(
1:433b42c:              "INSERT INTO jira1533_a (aa, bbbbbb, cccc, ddddddddddd, eeeeee,"
1:433b42c:              + "                      ffffffffffffffffff,"
1:433b42c:              + "                      ggggggggg, hhhhhhhhh, iiiiiiii, "
1:433b42c:              + "                      jjjjjjjjjjjjjj, kkkkkkkk,"
1:433b42c:              + "                      llllllll,mmmmmmmmmmmmm)"
1:433b42c:              + "          VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?)");
1:433b42c:          String blobStr = makeString(32584);
1:433b42c:          ps.setLong(1, 5);
1:433b42c:          ps.setLong(2, 1);
1:433b42c:          ps.setString(3, "AAAAAAAAAAA");
1:433b42c:          ps.setLong(4, 30000);
1:433b42c:          ps.setString(5, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:          ps.setString(6, "AAAAAAAAAAA");
1:433b42c:          ps.setBytes(7, blobStr.getBytes());
1:433b42c:          ps.setString(8, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:          ps.setString(9, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:          ps.setLong(10, 1);
1:433b42c:          ps.setString(11, "1");
1:433b42c:          ps.setString(12, "1");
1:433b42c:          ps.setString(13, "1");
1:433b42c:          ps.execute();
1:433b42c:          ps.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:df4020d:      *  @see #testLargeParameters_a()
1:433b42c:      */
1:433b42c:     public void testLargeParameters_b() throws Exception
1:433b42c:     {
1:433b42c:         Statement stmt = createStatement();
1:433b42c:         stmt.execute("create table jira1533_b ("
1:433b42c:                      + "aa BIGINT NOT NULL, bbbbbb BIGINT DEFAULT 0 NOT NULL, "
1:433b42c:                      + "cccc VARCHAR(40), ddddddddddd BIGINT, "
1:433b42c:                      + "eeeeee VARCHAR(128), ffffffffffffffffff VARCHAR(128), "
1:433b42c:                      + "g1 BLOB(2G), g2 BLOB(2G), g3 BLOB(2G), g4 BLOB(2G), "
1:433b42c:                      + "ggggggggg  BLOB(2G), hhhhhhhhh VARCHAR(128), "
1:433b42c:                      + "iiiiiiii VARCHAR(128), jjjjjjjjjjjjjj BIGINT,"
1:433b42c:                      + "kkkkkkkk CHAR(1) DEFAULT 'f', "
1:433b42c:                      + "llllllll CHAR(1) DEFAULT 'f', "
1:433b42c:                      + "mmmmmmmmmmmmm  CHAR(1) DEFAULT 'f')");
1:433b42c:         stmt.close();
1:433b42c: 
1:433b42c:         PreparedStatement ps = prepareStatement(
1:433b42c:             "INSERT INTO jira1533_b (aa, bbbbbb, cccc, ddddddddddd, eeeeee,"
1:433b42c:             + "                      ffffffffffffffffff,"
1:433b42c:             + "                      g1, g2, g3, g4,"
1:433b42c:             + "                      ggggggggg, hhhhhhhhh, iiiiiiii,"
1:433b42c:             + "                      jjjjjjjjjjjjjj, kkkkkkkk,"
1:433b42c:             + "                      llllllll,mmmmmmmmmmmmm)"
1:433b42c:             + "          VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
1:433b42c:         String blobStr = makeString(32584);
1:433b42c:         ps.setLong(1, 5);
1:433b42c:         ps.setLong(2, 1);
1:433b42c:         ps.setString(3, "AAAAAAAAAAA");
1:433b42c:         ps.setLong(4, 30000);
1:433b42c:         ps.setString(5, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:         ps.setString(6, "AAAAAAAAAAA");
1:433b42c:         ps.setBytes(7, blobStr.getBytes());
1:433b42c:         ps.setBytes(8, blobStr.getBytes());
1:433b42c:         ps.setBytes(9, blobStr.getBytes());
1:433b42c:         ps.setBytes(10 ,blobStr.getBytes());
1:433b42c:         ps.setBytes(11 ,blobStr.getBytes());
1:433b42c:         ps.setString(12, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:         ps.setString(13, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:433b42c:         ps.setLong(14, 1);
1:433b42c:         ps.setString(15, "1");
1:433b42c:         ps.setString(16, "1");
1:433b42c:         ps.setString(17, "1");
1:433b42c:         ps.execute();
1:433b42c:         ps.close();
1:433b42c:     }
1:433b42c: 
1:433b42c:     /**
1:fca5be5:      * Test fix for protocol error if splitQRYDTA occurs during DRDAConnThread.doneData()
1:fca5be5:      * DERBY-3230
1:fca5be5:      * @throws SQLException
1:433b42c:      */
1:fca5be5:     public void testDerby3230() throws SQLException {
1:fca5be5:         Statement s = createStatement();
1:fca5be5:         s.executeUpdate("CREATE TABLE TAB (col1 varchar(32672) NOT NULL)");
1:fca5be5:         PreparedStatement ps = prepareStatement("INSERT INTO TAB VALUES(?)");
1:fca5be5:         ps.setString(1,makeString(15000));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(7500));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(5000));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(2000));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(1600));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(800));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(400));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(200));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(100));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:         ps.setString(1,makeString(56));
1:fca5be5:         ps.executeUpdate();
1:fca5be5:             
1:fca5be5:         ResultSet rs = s.executeQuery("SELECT * from tab");
1:fca5be5:         // drain the resultset
1:fca5be5:         JDBC.assertDrainResults(rs);
1:fca5be5:                    
1:fca5be5:     }
1:433b42c:     /**
1:433b42c:      * Return a string of the given length.  The string will contain just 'X'
1:433b42c:      * characters.
1:433b42c:      *
1:433b42c:      * @param length Length of string to be returned.
1:433b42c:      * @return String of given length.
1:433b42c:      */
1:433b42c:     private static String makeString(int length)
1:433b42c:     {
1:c6e4294:         return makeString(length, 'X');
1:c6e4294:     }
1:c6e4294: 
1:c6e4294:     /**
1:c6e4294:      * Return a string of the given length filled with the specified character.
1:c6e4294:      */
1:c6e4294:     private static String makeString(int length, char ch) {
1:c6e4294:         char[] buf = new char[length];
1:c6e4294:         Arrays.fill(buf, ch);
1:c6e4294:         return new String(buf);
1:433b42c:     }
2:53d6497: 
1:433b42c:     /**
1:7062abe:      * Test fix for DERBY-4088 where an ArrayIndexOutOfBoundsException was
1:7062abe:      * thrown by DDMReader.readBytes() when reading a BLOB value whose length
1:7062abe:      * was close to the maximum length of a DSS.
1:7062abe:      */
1:7062abe:     public void testReadBlobCloseToMaxDssLength() throws Exception {
1:7062abe:         final int length = 32766; // max DSS length is 32767
1:7062abe: 
1:7062abe:         // Create test data with the requested length
1:7062abe:         DataInputStream stream1 =
1:7062abe:                 new DataInputStream(new LoopingAlphabetStream(length));
1:7062abe:         byte[] bytes = new byte[length];
1:7062abe:         stream1.readFully(bytes);
1:7062abe: 
1:7062abe:         // See if the test data can be sent to the server and back with
1:7062abe:         // no errors.
1:7062abe:         PreparedStatement ps = prepareStatement("values cast(? as blob)");
1:7062abe:         ps.setBytes(1, bytes);
1:7062abe:         ResultSet rs = ps.executeQuery();
1:7062abe:         assertTrue("empty result set", rs.next());
1:7062abe:         InputStream stream2 = rs.getBinaryStream(1);
1:7062abe:         assertEquals(new LoopingAlphabetStream(length), stream2);
1:7062abe:         assertFalse("too many rows", rs.next());
1:7062abe:         rs.close();
1:7062abe:     }
1:7062abe: 
1:433b42c:     /**
1:c6e4294:      * Verify that string values aren't truncated when their UTF-8 encoded
1:c6e4294:      * representation exceeds 32KB. DERBY-5236.
1:c6e4294:      */
1:c6e4294:     public void testLongColumn() throws Exception {
1:c6e4294:         PreparedStatement ps = prepareStatement(
1:c6e4294:                 "values cast(? as varchar(32672))");
1:c6e4294: 
1:c6e4294:         String s1 = makeString(20000, '\u4e10');
1:c6e4294:         ps.setString(1, s1);
1:c6e4294:         JDBC.assertSingleValueResultSet(ps.executeQuery(), s1);
1:c6e4294: 
1:c6e4294:         // 64K-1 bytes, should be OK.
1:c6e4294:         String s2 =
1:c6e4294:                 s1 + makeString(64 * 1024 - s1.getBytes("UTF-8").length - 1);
1:c6e4294:         ps.setString(1, s2);
1:c6e4294:         JDBC.assertSingleValueResultSet(ps.executeQuery(), s2);
1:c6e4294: 
1:c6e4294:         // 64K bytes, will be truncated to 64K-1 by the client driver because
1:c6e4294:         // of limitation in the protocol.
1:c6e4294:         String s3 = s2 + 'X';
1:c6e4294:         ps.setString(1, s3);
1:c6e4294:         if (usingDerbyNetClient()) {
1:c6e4294:             String expected = s3.substring(0, s3.length() - 1);
1:b850119:             ResultSet rs = ps.executeQuery();
1:b850119:             assertTrue("Empty result", rs.next());
1:b850119:             assertDataTruncation(
1:b850119:                     new String[] { expected },
1:b850119:                     new String[] { rs.getString(1) },
1:b850119:                     1, false, true, s3.length(), expected.length(),
1:b850119:                     rs.getWarnings());
1:b850119:             assertFalse("Too many rows", rs.next());
1:b850119:             rs.close();
1:c6e4294:         } else {
1:c6e4294:             // Embedded is OK. No truncation.
1:c6e4294:             JDBC.assertSingleValueResultSet(ps.executeQuery(), s3);
1:c6e4294:         }
1:c6e4294: 
1:c6e4294:         // 64K+1 bytes, will be truncated by the client driver because of
1:c6e4294:         // limitation in the protocol. Should be truncated to to 64K-2 to
1:c6e4294:         // match the character boundary.
1:c6e4294:         String s4 = s3.substring(0, s3.length() - 2) + '\u4e10';
1:c6e4294:         ps.setString(1, s4);
1:c6e4294:         if (usingDerbyNetClient()) {
1:c6e4294:             String expected = s4.substring(0, s4.length() - 1);
1:b850119:             ResultSet rs = ps.executeQuery();
1:b850119:             assertTrue("Empty result", rs.next());
1:b850119:             assertDataTruncation(
1:b850119:                     new String[] { expected },
1:b850119:                     new String[] { rs.getString(1) },
1:b850119:                     1, false, true, s4.length(), expected.length(),
1:b850119:                     rs.getWarnings());
1:b850119:             assertFalse("Too many rows", rs.next());
1:b850119:             rs.close();
1:c6e4294:         } else {
1:c6e4294:             // Embedded is OK. No truncation.
1:c6e4294:             JDBC.assertSingleValueResultSet(ps.executeQuery(), s4);
1:c6e4294:         }
1:c6e4294: 
1:c6e4294:         // Try two columns at 64K+1 bytes. Expect same result as above.
1:c6e4294:         PreparedStatement ps2 = prepareStatement(
1:c6e4294:                 "values (cast(? as varchar(32672)), " +
1:c6e4294:                 "cast(? as varchar(32672)))");
1:c6e4294:         ps2.setString(1, s4);
1:c6e4294:         ps2.setString(2, s4);
1:c6e4294:         if (usingDerbyNetClient()) {
1:c6e4294:             String expected = s4.substring(0, s4.length() - 1);
1:b850119:             ResultSet rs = ps2.executeQuery();
1:b850119:             assertTrue("Empty result", rs.next());
1:b850119:             // We should actually have received two warnings here, but the
1:b850119:             // network client driver currently only supports one warning.
1:b850119:             assertDataTruncation(
1:b850119:                     new String[] { expected, expected },
1:b850119:                     new String[] { rs.getString(1), rs.getString(2) },
1:b850119:                     1, false, true, s4.length(), expected.length(),
1:b850119:                     rs.getWarnings());
1:b850119:             assertFalse("Too many rows", rs.next());
1:b850119:             rs.close();
1:c6e4294:         } else {
1:c6e4294:             String[][] expectedRow = {{s4, s4}};
2:c6e4294:             JDBC.assertFullResultSet(ps2.executeQuery(), expectedRow);
1:c6e4294:         }
1:b850119: 
1:b850119:         // Now test 64KB in a procedure call. Will be truncated to 64KB-1 on
1:b850119:         // the network client.
1:b850119:         Statement s = createStatement();
1:b850119:         s.execute("create procedure derby_5236_proc" +
1:b850119:                   "(in x varchar(32672), out y varchar(32672))" +
1:b850119:                   "language java parameter style java external name '" +
1:b850119:                   getClass().getName() + ".copyString'");
1:b850119:         CallableStatement cs = prepareCall("call derby_5236_proc(?,?)");
1:b850119:         cs.setString(1, s3);
1:b850119:         cs.registerOutParameter(2, Types.VARCHAR);
1:b850119:         cs.execute();
1:b850119:         if (usingDerbyNetClient()) {
1:b850119:             assertDataTruncation(
1:b850119:                     new String[] { s3.substring(0, s3.length() - 1) },
1:b850119:                     new String[] { cs.getString(2) },
1:b850119:                     2, true, true, s3.length(), s3.length() - 1,
1:b850119:                     cs.getWarnings());
1:b850119:         } else {
1:b850119:             assertEquals(s3, cs.getString(2));
1:b850119:         }
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Copy a string value from {@code in} to {@code out[0}}. Used as a
1:b850119:      * stored procedure in {@link #testLongColumn()}.
1:b850119:      *
1:b850119:      * @param in stored procedure input parameter
1:b850119:      * @param out stored procedure output parameter
1:b850119:      */
1:b850119:     public static void copyString(String in, String[] out) {
1:b850119:         out[0] = in;
1:b850119:     }
1:b850119: 
1:b850119:     /**
1:b850119:      * Assert that data returned from the server was truncated, and that the
1:b850119:      * proper warning came with the result.
1:b850119:      *
1:b850119:      * @param expectedRow the expected values
1:b850119:      * @param actualRow   the actual values returned
1:b850119:      * @param index       the expected column/parameter index in the warning
1:b850119:      * @param parameter   whether the values came from a procedure parameter
1:b850119:      * @param read        whether the values came from a read operation
1:b850119:      * @param dataSize    the expected full size of the truncated value
1:b850119:      * @param transferSize the expected size of the value after truncation
1:b850119:      * @param warning     the received warning
1:b850119:      */
1:b850119:     private static void assertDataTruncation(
1:b850119:             String[] expectedRow, String[] actualRow,
1:b850119:             int index, boolean parameter, boolean read,
1:b850119:             int dataSize, int transferSize, SQLWarning warning) {
1:b850119:         assertEquals("Wrong number of columns",
1:b850119:                      expectedRow.length, actualRow.length);
1:b850119:         assertNotNull("Expected data truncation warning", warning);
1:b850119:         for (int i = 0; i < expectedRow.length; i++) {
1:b850119:             assertEquals("column #" + (i + 1), expectedRow[i], actualRow[i]);
1:b850119: 
1:b850119:             if (warning instanceof DataTruncation) {
1:b850119:                 DataTruncation dt = (DataTruncation) warning;
1:b850119:                 assertEquals("index", index, dt.getIndex());
1:b850119:                 assertEquals("parameter", parameter, dt.getParameter());
1:b850119:                 assertEquals("read", read, dt.getRead());
1:b850119:                 assertEquals("dataSize", dataSize, dt.getDataSize());
1:b850119:                 assertEquals("transferSize", transferSize, dt.getTransferSize());
1:b850119:             } else {
1:b850119:                 fail("Unexpected warning", warning);
1:b850119:             }
1:b850119: 
1:b850119:             assertNull("Chained warnings not expected on network client",
1:b850119:                        warning.getNextWarning());
1:b850119:         }
1:c6e4294:     }
1:433b42c: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.math.RoundingMode;
/////////////////////////////////////////////////////////////////////////
1:             = bdFromString.setScale(scale, RoundingMode.DOWN);
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             {99, 5, 9},
1:             {2, 6, 10},
1:             {7, 5, 8}
/////////////////////////////////////////////////////////////////////////
1:             {1, 2, 3L, 4.0F,
1:              5.0, 6.0, new BigDecimal("77.77"),
1:             {1, 2, 3L, 4.0F,
1:              5.0, 6.0, new BigDecimal("77.77"),
/////////////////////////////////////////////////////////////////////////
1:         pSt.setLong(3, ((Long)t2_rows[0][2]).longValue());
/////////////////////////////////////////////////////////////////////////
1:         pSt.setObject(1,3,java.sql.Types.INTEGER,0);
1:             pSt.setObject(2,4, java.sql.Types.INTEGER,0);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.DataInputStream;
1: import java.io.InputStream;
1: import java.io.InputStreamReader;
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:                         return new BaseTestSuite(
1:                 "empty PrepareStatementTest - client not supported on JSR169");
1:             BaseTestSuite suite = new BaseTestSuite("PrepareStatementTest");
1:                     new BaseTestSuite(PrepareStatementTest.class)))));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0cfef0d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     {
1:         {
0:             TestSuite suite = new TestSuite("PrepareStatementTest");
1:             suite.addTest(TestConfiguration.defaultSuite(PrepareStatementTest.class));
1:             suite.addTest(TestConfiguration.clientServerDecorator(
1:                 TestConfiguration.connectionCPDecorator(new CleanDatabaseTestSetup(
0:                     new TestSuite(PrepareStatementTest.class)))));
1:             return suite;
1:         }
commit:b850119
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
1: import java.sql.DataTruncation;
1: import java.sql.SQLWarning;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:             ResultSet rs = ps.executeQuery();
1:             assertTrue("Empty result", rs.next());
1:             assertDataTruncation(
1:                     new String[] { expected },
1:                     new String[] { rs.getString(1) },
1:                     1, false, true, s3.length(), expected.length(),
1:                     rs.getWarnings());
1:             assertFalse("Too many rows", rs.next());
1:             rs.close();
/////////////////////////////////////////////////////////////////////////
1:             ResultSet rs = ps.executeQuery();
1:             assertTrue("Empty result", rs.next());
1:             assertDataTruncation(
1:                     new String[] { expected },
1:                     new String[] { rs.getString(1) },
1:                     1, false, true, s4.length(), expected.length(),
1:                     rs.getWarnings());
1:             assertFalse("Too many rows", rs.next());
1:             rs.close();
/////////////////////////////////////////////////////////////////////////
1:             ResultSet rs = ps2.executeQuery();
1:             assertTrue("Empty result", rs.next());
1:             // We should actually have received two warnings here, but the
1:             // network client driver currently only supports one warning.
1:             assertDataTruncation(
1:                     new String[] { expected, expected },
1:                     new String[] { rs.getString(1), rs.getString(2) },
1:                     1, false, true, s4.length(), expected.length(),
1:                     rs.getWarnings());
1:             assertFalse("Too many rows", rs.next());
1:             rs.close();
1: 
1:         // Now test 64KB in a procedure call. Will be truncated to 64KB-1 on
1:         // the network client.
1:         Statement s = createStatement();
1:         s.execute("create procedure derby_5236_proc" +
1:                   "(in x varchar(32672), out y varchar(32672))" +
1:                   "language java parameter style java external name '" +
1:                   getClass().getName() + ".copyString'");
1:         CallableStatement cs = prepareCall("call derby_5236_proc(?,?)");
1:         cs.setString(1, s3);
1:         cs.registerOutParameter(2, Types.VARCHAR);
1:         cs.execute();
1:         if (usingDerbyNetClient()) {
1:             assertDataTruncation(
1:                     new String[] { s3.substring(0, s3.length() - 1) },
1:                     new String[] { cs.getString(2) },
1:                     2, true, true, s3.length(), s3.length() - 1,
1:                     cs.getWarnings());
1:         } else {
1:             assertEquals(s3, cs.getString(2));
1:         }
1:     }
1: 
1:     /**
1:      * Copy a string value from {@code in} to {@code out[0}}. Used as a
1:      * stored procedure in {@link #testLongColumn()}.
1:      *
1:      * @param in stored procedure input parameter
1:      * @param out stored procedure output parameter
1:      */
1:     public static void copyString(String in, String[] out) {
1:         out[0] = in;
1:     }
1: 
1:     /**
1:      * Assert that data returned from the server was truncated, and that the
1:      * proper warning came with the result.
1:      *
1:      * @param expectedRow the expected values
1:      * @param actualRow   the actual values returned
1:      * @param index       the expected column/parameter index in the warning
1:      * @param parameter   whether the values came from a procedure parameter
1:      * @param read        whether the values came from a read operation
1:      * @param dataSize    the expected full size of the truncated value
1:      * @param transferSize the expected size of the value after truncation
1:      * @param warning     the received warning
1:      */
1:     private static void assertDataTruncation(
1:             String[] expectedRow, String[] actualRow,
1:             int index, boolean parameter, boolean read,
1:             int dataSize, int transferSize, SQLWarning warning) {
1:         assertEquals("Wrong number of columns",
1:                      expectedRow.length, actualRow.length);
1:         assertNotNull("Expected data truncation warning", warning);
1:         for (int i = 0; i < expectedRow.length; i++) {
1:             assertEquals("column #" + (i + 1), expectedRow[i], actualRow[i]);
1: 
1:             if (warning instanceof DataTruncation) {
1:                 DataTruncation dt = (DataTruncation) warning;
1:                 assertEquals("index", index, dt.getIndex());
1:                 assertEquals("parameter", parameter, dt.getParameter());
1:                 assertEquals("read", read, dt.getRead());
1:                 assertEquals("dataSize", dataSize, dt.getDataSize());
1:                 assertEquals("transferSize", transferSize, dt.getTransferSize());
1:             } else {
1:                 fail("Unexpected warning", warning);
1:             }
1: 
1:             assertNull("Chained warnings not expected on network client",
1:                        warning.getNextWarning());
1:         }
commit:c6e4294
/////////////////////////////////////////////////////////////////////////
1:         return makeString(length, 'X');
1:     }
1: 
1:     /**
1:      * Return a string of the given length filled with the specified character.
1:      */
1:     private static String makeString(int length, char ch) {
1:         char[] buf = new char[length];
1:         Arrays.fill(buf, ch);
1:         return new String(buf);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that string values aren't truncated when their UTF-8 encoded
1:      * representation exceeds 32KB. DERBY-5236.
1:      */
1:     public void testLongColumn() throws Exception {
1:         PreparedStatement ps = prepareStatement(
1:                 "values cast(? as varchar(32672))");
1: 
1:         String s1 = makeString(20000, '\u4e10');
1:         ps.setString(1, s1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), s1);
1: 
1:         // 64K-1 bytes, should be OK.
1:         String s2 =
1:                 s1 + makeString(64 * 1024 - s1.getBytes("UTF-8").length - 1);
1:         ps.setString(1, s2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), s2);
1: 
1:         // 64K bytes, will be truncated to 64K-1 by the client driver because
1:         // of limitation in the protocol.
1:         String s3 = s2 + 'X';
1:         ps.setString(1, s3);
1:         if (usingDerbyNetClient()) {
1:             String expected = s3.substring(0, s3.length() - 1);
0:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1:         } else {
1:             // Embedded is OK. No truncation.
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), s3);
1:         }
1: 
1:         // 64K+1 bytes, will be truncated by the client driver because of
1:         // limitation in the protocol. Should be truncated to to 64K-2 to
1:         // match the character boundary.
1:         String s4 = s3.substring(0, s3.length() - 2) + '\u4e10';
1:         ps.setString(1, s4);
1:         if (usingDerbyNetClient()) {
1:             String expected = s4.substring(0, s4.length() - 1);
0:             JDBC.assertSingleValueResultSet(ps.executeQuery(), expected);
1:         } else {
1:             // Embedded is OK. No truncation.
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), s4);
1:         }
1: 
1:         // Try two columns at 64K+1 bytes. Expect same result as above.
1:         PreparedStatement ps2 = prepareStatement(
1:                 "values (cast(? as varchar(32672)), " +
1:                 "cast(? as varchar(32672)))");
1:         ps2.setString(1, s4);
1:         ps2.setString(2, s4);
1:         if (usingDerbyNetClient()) {
1:             String expected = s4.substring(0, s4.length() - 1);
0:             String[][] expectedRow = {{expected, expected}};
1:             JDBC.assertFullResultSet(ps2.executeQuery(), expectedRow);
1:         } else {
1:             String[][] expectedRow = {{s4, s4}};
1:             JDBC.assertFullResultSet(ps2.executeQuery(), expectedRow);
1:         }
1:     }
commit:ecef2eb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.Formatters;
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Regression test for DERBY-614. The test consists of two parts:
1:      * </p>
1:      *
1:      * <p>
1:      * <b>Part 1:</b>
1:      * </p>
1:      *
1:      * <p>
1:      * <b>Part 2:</b>
1:      * Verifies that the server-side statement state is cleaned up when a
1:      * statement is re-used. Specifically, we set up a statement which has a
1:      * non-null splitQRYDTA value, then we close that statement and re-use it
1:      * for a totally unrelated query. If the splitQRYDTA wasn't cleaned up
1:      * properly, it comes flooding back as the response to that unrelated
1:      * query, causing a protocol parsing exception on the client.
1:      * </p>
1:         // Part 1:
1: 
1:         String workString = Formatters.repeatChar("a", 150);
1:         workString = Formatters.repeatChar("b", 10000);
/////////////////////////////////////////////////////////////////////////
1:         // Part 2:
1:         ps = prepareStatement("insert into jira614_a values (?)");
/////////////////////////////////////////////////////////////////////////
1:         rs = stmt.executeQuery("select * from jira614");
1:         rowNum = 0;
commit:7062abe
/////////////////////////////////////////////////////////////////////////
0: import java.io.DataInputStream;
0: import java.io.InputStream;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test fix for DERBY-4088 where an ArrayIndexOutOfBoundsException was
1:      * thrown by DDMReader.readBytes() when reading a BLOB value whose length
1:      * was close to the maximum length of a DSS.
1:      */
1:     public void testReadBlobCloseToMaxDssLength() throws Exception {
1:         final int length = 32766; // max DSS length is 32767
1: 
1:         // Create test data with the requested length
1:         DataInputStream stream1 =
1:                 new DataInputStream(new LoopingAlphabetStream(length));
1:         byte[] bytes = new byte[length];
1:         stream1.readFully(bytes);
1: 
1:         // See if the test data can be sent to the server and back with
1:         // no errors.
1:         PreparedStatement ps = prepareStatement("values cast(? as blob)");
1:         ps.setBytes(1, bytes);
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue("empty result set", rs.next());
1:         InputStream stream2 = rs.getBinaryStream(1);
1:         assertEquals(new LoopingAlphabetStream(length), stream2);
1:         assertFalse("too many rows", rs.next());
1:         rs.close();
1:     }
1: 
commit:433b42c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.PrepareStatementTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.derbynet;
1: 
1: import java.sql.BatchUpdateException;
1: import java.sql.Date;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
0: import java.math.BigDecimal;
0: import java.io.ByteArrayInputStream;
0: import java.io.InputStreamReader;
1: import java.util.Arrays;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: /**
0:  * This Junit test class tests the JDBC PreparedStatement.  This test is a
0:  * Junit of the old prepStmt.java test.  This test tested prepared statements
0:  * in client/server context, and many of the test cases is specifically
0:  * testing corner cases in client/server communication.  However, this Junit
0:  * test is set up to run as part of both the embedded and client/server test
0:  * suites.
1:  */
1: 
1: public class PrepareStatementTest extends BaseJDBCTestCase
1: {
1: 
1:     /**
1:      * Creates a new instance of PrepareStatementTest
1:      *
1:      * @param name name of the test.
1:      */
1:     public PrepareStatementTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1: 
1:     /**
1:      * Adds this class to the default suite.  That is, all test cases will be
1:      * run in both embedded and client/server.
1:      */
1:     public static Test suite()
1:     {
0:         return TestConfiguration.defaultSuite(PrepareStatementTest.class);
1:     }
1: 
1: 
1:     /**
1:      * Test basic prepare mechanism with executeUpdate and executeQuery with
1:      * and without simple parameters.
1:      */
1:     public void testBasicPrepare() throws Exception
1:     {
1:         // executeUpdate() without parameters
1:         PreparedStatement pSt
1:             = prepareStatement("create table t1(c1 int, c2 int, c3 int)");
1:         assertUpdateCount(pSt, 0);
1:         pSt.close();
1: 
1:         // Rows to be inserted in table t1 for this test
1:         final Integer[][] t1_rows = {
0:             {new Integer(99), new Integer(5), new Integer(9)},
0:             {new Integer(2), new Integer(6), new Integer(10)},
0:             {new Integer(7), new Integer(5), new Integer(8)}
1:         };
1: 
1:         // executeUpdate() with parameters
1:         pSt = prepareStatement("insert into t1 values (?, " + t1_rows[0][1]
1:                                + ", ?)");
1:         pSt.setInt(1, t1_rows[0][0].intValue());
1:         pSt.setInt(2, t1_rows[0][2].intValue());
1:         assertUpdateCount(pSt, 1);
1:         pSt.close();
1: 
1:         // execute() with parameters, no result set returned
1:         pSt = prepareStatement("insert into t1 values (" + t1_rows[1][0] + ", "
1:                                + t1_rows[1][1] + ", ?), (?, " + t1_rows[2][1]
1:                                + ", " + t1_rows[2][2] + ")");
1:         pSt.setInt(1, t1_rows[1][2].intValue());
1:         pSt.setInt(2, t1_rows[2][0].intValue());
1:         boolean hasResultSet = pSt.execute();
1:         while (hasResultSet)
1:         {
1:             ResultSet rs = pSt.getResultSet();
1:             assertFalse(rs.next());
1:             rs.close();
1:             hasResultSet = pSt.getMoreResults();
1:         }
1:         assertEquals(2, pSt.getUpdateCount());
1:         pSt.close();
1: 
1:         // executeQuery() without parameters
1:         pSt = prepareStatement("select * from t1");
1:         ResultSet rs = pSt.executeQuery();
1:         JDBC.assertFullResultSet(rs, t1_rows, false);
1:         rs.close();
1:         pSt.close();
1: 
1:         // Create table with subset of rows to be selected in query below
1:         Integer[][] t1filter_rows = new Integer[2][];
1:         for (int i=0, j=0; i < t1_rows.length; ++i) {
1:             if (t1_rows[i][1].intValue() == 5) {
1:                 t1filter_rows[j++] = t1_rows[i];
1:             }
1:         }
1: 
1:         // executeQuery() with parameters
1:         pSt = prepareStatement("select * from t1 where c2 = ?");
1:         pSt.setInt(1, 5);
1:         rs = pSt.executeQuery();
1:         JDBC.assertFullResultSet(rs, t1filter_rows, false);
1:         rs.close();
1:         pSt.close();
1: 
1:         // execute() with parameters, with result set returned
1:         pSt = prepareStatement("select * from t1 where c2 = ?");
1:         pSt.setInt(1, 5);
1:         assertTrue(pSt.execute());
1:         rs = pSt.getResultSet();
1:         JDBC.assertFullResultSet(rs, t1filter_rows, false);
1:         rs.close();
1:         assertFalse(pSt.getMoreResults());
1:         assertEquals(-1, pSt.getUpdateCount());
1:         pSt.close();
1:     }
1: 
1: 
1:     /**
1:      * Tests different data types for input parameters of a PreparedStatement.
1:      */
1:     public void testParameterTypes() throws Exception
1:     {
1:         PreparedStatement pSt = prepareStatement(
1:             "create table t2(si smallint,i int, bi bigint, r real, f float, "
1:             + "d double precision, n5_2 numeric(5,2), dec10_3 decimal(10,3), "
1:             + "ch20 char(20),vc varchar(20), lvc long varchar, "
1:             + "b20 char(23) for bit data, vb varchar(23) for bit data, "
1:             + "lvb long varchar for bit data,  dt date, tm time, "
1:             + "ts timestamp not null)");
1:         assertUpdateCount(pSt, 0);
1:         pSt.close();
1: 
1:         // byte array for binary values.
1:         byte[] ba = new byte[] { 0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,
1:                                  0xb,0xc,0xd,0xe,0xf,0x10,0x11,0x12,0x13 };
1: 
1:         byte[] bapad = new byte[23];  // For padded byte data
1:         System.arraycopy(ba, 0, bapad, 0, ba.length);
1:         // Pad with space!!!
1:         Arrays.fill(bapad, ba.length, bapad.length, (byte )0x20);
1: 
1:         // Values to be inserted
1:         Object[][] t2_rows = {
0:             {new Integer(1), new Integer(2), new Long(3), new Float(4.0),
0:              new Double(5.0), new Double(6.0), new BigDecimal("77.77"),
1:              new BigDecimal("8.100"), "column9string       ",
1:              "column10vcstring", "column11lvcstring", bapad, ba, ba,
1:              Date.valueOf("2002-04-12"), Time.valueOf("11:44:30"),
1:              Timestamp.valueOf("2002-04-12 11:44:30.000000000")},
0:             {new Integer(1), new Integer(2), new Long(3), new Float(4.0),
0:              new Double(5.0), new Double(6.0), new BigDecimal("77.77"),
1:              new BigDecimal("8.100"), "column11string      ",
1:              "column10vcstring", "column11lvcstring", bapad, ba, ba,
1:              Date.valueOf("2002-04-12"), Time.valueOf("11:44:30"),
1:              Timestamp.valueOf("2002-04-12 11:44:30.000000000")},
1:             {null, null, null, null, null, null, null, null, null, null, null,
1:              null, null, null, null, null,
1:              Timestamp.valueOf("2002-04-12 11:44:31.000000000")}
1:         };
1: 
1: 
1:         pSt = prepareStatement(
1:             "insert into t2 values (?, ?, ?, ?,  ?, ?, ?, ?, ?, ?, ?, ?, ?, "
1:             + "?, ? ,? , ?)");
1:         pSt.setShort(1, ((Integer )t2_rows[0][0]).shortValue());
1:         pSt.setInt(2, ((Integer )t2_rows[0][1]).intValue());
0:         pSt.setLong(3, ((Long )t2_rows[0][2]).longValue());
1:         pSt.setFloat(4, ((Float )t2_rows[0][3]).floatValue());
1:         pSt.setDouble(5, ((Double )t2_rows[0][4]).doubleValue());
1:         pSt.setDouble(6, ((Double )t2_rows[0][5]).doubleValue());
1:         pSt.setBigDecimal(7, (BigDecimal )t2_rows[0][6]);
1:         pSt.setBigDecimal(8, new BigDecimal("8.1")); // Diff. precision
1:         pSt.setString(9, "column9string");  // Without padding
1:         byte[] c10ba = ((String )t2_rows[0][9]).getBytes("UTF-8");
1:         int len = c10ba.length;
1:         pSt.setAsciiStream(10, new ByteArrayInputStream(c10ba), len);
1:         byte[] c11ba = ((String )t2_rows[0][10]).getBytes("UTF-8");
1:         len = c11ba.length;
1:         pSt.setCharacterStream(11, new InputStreamReader
1:                                (new ByteArrayInputStream(c11ba),"UTF-8"),len);
1:         pSt.setBytes(12, ba);
1:         pSt.setBinaryStream(13, new ByteArrayInputStream(ba), ba.length);
1:         pSt.setBytes(14, ba);
1:         pSt.setDate(15, ((Date )t2_rows[0][14]));
1:         pSt.setTime(16, ((Time )t2_rows[0][15]));
1:         pSt.setTimestamp(17, ((Timestamp )t2_rows[0][16]));
1:         assertUpdateCount(pSt, 1);
1: 
1:         // test setObject on different datatypes of the input parameters of
1:         // PreparedStatement
1:         for (int i=0; i<17; ++i) {
1:             pSt.setObject(i+1, t2_rows[1][i]);
1:         }
1:         assertUpdateCount(pSt, 1);
1: 
1:         // test setNull on different datatypes of the input parameters of
1:         // PreparedStatement
1:         pSt.setNull(1, java.sql.Types.SMALLINT);
1:         pSt.setNull(2, java.sql.Types.INTEGER);
1:         pSt.setNull(3, java.sql.Types.BIGINT);
1:         pSt.setNull(4, java.sql.Types.REAL);
1:         pSt.setNull(5, java.sql.Types.FLOAT);
1:         pSt.setNull(6, java.sql.Types.DOUBLE);
1:         pSt.setNull(7, java.sql.Types.NUMERIC);
1:         pSt.setNull(8, java.sql.Types.DECIMAL);
1:         pSt.setNull(9, java.sql.Types.CHAR);
1:         pSt.setNull(10, java.sql.Types.VARCHAR);
1:         pSt.setNull(11, java.sql.Types.LONGVARCHAR);
1:         pSt.setNull(12, java.sql.Types.BINARY);
1:         pSt.setNull(13, java.sql.Types.VARBINARY);
1:         pSt.setNull(14, java.sql.Types.LONGVARBINARY);
1:         pSt.setNull(15, java.sql.Types.DATE);
1:         pSt.setNull(16, java.sql.Types.TIME);
1: 
1:         pSt.setTimestamp(17, ((Timestamp )t2_rows[2][16]));
1:         assertFalse(pSt.execute());
1:         assertEquals(1, pSt.getUpdateCount());
1:         pSt.close();
1: 
1:         pSt = prepareStatement("select * from t2");
1:         ResultSet rs = pSt.executeQuery();
1:         JDBC.assertFullResultSet(rs, t2_rows, false);
1:         rs.close();
1:         pSt.close();
1: 
1:         // negative test cases with no parameters set
1:         try {
1:             pSt = prepareStatement("select * from t2 where i = ?");
1:             rs = pSt.executeQuery();
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
1:             assertSQLState("07000", e);
1:         }
1:         rs.close();
1:         pSt.close();
1: 
1: 
1:         try {
1:             pSt = prepareStatement(
1:                 "insert into t2 values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, "
1:                 + "?, ?, ?, ?, ?)");
1:             pSt.executeUpdate();
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
1:             assertSQLState("07000", e);
1:         }
1:         pSt.close();
1:     }
1: 
1: 
1:     /**
1:      * Test prepared statements with a large number of input parameters.
1:      */
1:     public void testBigTable() throws Exception
1:     {
1:         int tabSize = 1000;
1:         StringBuffer createBigTabSql
1:             = new StringBuffer("create table bigtab (");
1:         for (int i = 1; i <= tabSize; ++i) {
1:             createBigTabSql.append("c");
1:             createBigTabSql.append(i);
1:             createBigTabSql.append(" int");
1:             createBigTabSql.append((i != tabSize) ? ", " : " )");
1:         }
1: 
1:         PreparedStatement pSt = prepareStatement(createBigTabSql.toString());
1:         assertUpdateCount(pSt, 0);
1:         pSt.close();
1: 
1:         insertTab("bigtab", 50);
1:         insertTab("bigtab", 200);
1:         insertTab("bigtab", 300);
1:         insertTab("bigtab", 500);
1:         // prepared Statement with many  params (bug 4863)
1:         insertTab("bigtab", 1000);
1:         selectFromBigTab();
1: 
1:         // Negative Cases
1:         try {
1:             insertTab("bigtab", 1001);
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
1:             assertSQLState("42X14", e);
1:         }
1:         // this one will give a sytax error
1:         try {
1:             insertTab("bigtab", 0);
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
1:             assertSQLState("42X01", e);
1:         }
1:         // table doesn't exist
1:         try {
1:             insertTab("wrongtab",1000);
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
1:             assertSQLState("42X05", e);
1:         }
1:     }
1: 
1:     /**
1:      * Insert 1 row with the given number of columns into the given table.
1:      * It is assumed that the table has numCols, named c1, c2, ...
1:      * This is a helper method for the testBigTable test case.
1:      *
1:      * @param tabName Table name
1:      * @param numCols Number of columns in table.
1:      */
1:     private void insertTab(String tabName, int numCols)
1:         throws SQLException
1:     {
1:         StringBuffer insertSql
1:             = new StringBuffer("insert into " + tabName + "(");
1:         for (int i = 1; i <= numCols; ++i)
1:         {
1:             insertSql.append(" c");
0:             insertSql.append(i);;
1:             insertSql.append((i != numCols) ? ", " : ")");
1:         }
1:         insertSql.append("  values (");
1:         for (int i = 1; i <= numCols; ++i)
1:         {
1:             insertSql.append("?");
1:             insertSql.append((i != numCols) ? ", " : " )");
1:         }
1: 
1:         PreparedStatement pSt = prepareStatement(insertSql.toString());
1:         for (int i = 1; i <= numCols; ++i) {
1:             pSt.setInt(i, i);
1:         }
1:         assertUpdateCount(pSt, 1);
1:         pSt.close();
1:     }
1: 
1:     /**
1:      * Test that the table bigtab contains the expected tuples for the test
1:      * case testBigTable.
1:      */
1:     private void selectFromBigTab() throws SQLException
1:     {
1:         String selectSQL = "select * from bigtab";
1:         PreparedStatement pSt = prepareStatement(selectSQL);
1:         ResultSet rs = pSt.executeQuery();
1: 
1:         int i = 0;
1:         while (rs.next())
1:         {
1:             switch(++i) {
1:                 case 1:
1:                 case 2:
1:                 case 3:
1:                     assertNull(rs.getObject(500));
1:                     assertNull(rs.getObject(1000));
1:                     break;
1:                 case 4:
1:                     assertEquals(rs.getInt(500), 500);
1:                     assertNull(rs.getObject(1000));
1:                     break;
1:                 case 5:
1:                     assertEquals(rs.getInt(500), 500);
1:                     assertEquals(rs.getInt(1000), 1000);
1:                     break;
1:                 default:
1:                     fail("Too many rows in bigTab");
1:             }
1:         }
1:         assertEquals(i, 5);
1: 
1:         rs.close();
1:         pSt.close();
1: 
1:     }
1: 
1: 
1:     /**
1:      * Check that values are preserved when BigDecimal values
1:      * which have more than 31 digits are converted to Double
1:      * with setObject.
1:      */
1:     public void testBigDecimalSetObject() throws SQLException
1:     {
1:         getConnection().setAutoCommit(false);
1:         String sql = "CREATE TABLE doubletab (i int, doubleVal DOUBLE)";
1:         Statement stmt = createStatement();
1:         assertUpdateCount(stmt, 0, sql);
1:         stmt.close();
1:         commit();
1: 
1:         // Insert various double values
1:         double[] doubleVals = {1.0E-130, 1.0E125, 0, -1.0E124};
1:         BigDecimal[] bigDecimalVals =
1:             { new BigDecimal(1.0E-130),
1:               new BigDecimal(1.0E125),
1:               new BigDecimal(-1.0E124),
1:               new BigDecimal("12345678901234567890123456789012"),
1:               new BigDecimal("1.2345678901234567890123456789012")
1:         };
1: 
1:         String isql = "INSERT INTO doubletab VALUES (?, ?)";
1:         PreparedStatement insPs = prepareStatement(isql);
1:         String ssql = "SELECT doubleVal FROM doubletab";
1:         PreparedStatement selPs = prepareStatement(ssql);
1:         String dsql = "DELETE FROM doubletab";
1:         PreparedStatement delPs = prepareStatement(dsql);
1:         for (int i = 0; i < bigDecimalVals.length; ++i)
1:         {
1:             BigDecimal bd = bigDecimalVals[i];
1:             insPs.setInt(1,i);
1:             insPs.setObject(2,bd,java.sql.Types.DOUBLE);
1:             assertUpdateCount(insPs, 1);
1:             // Check Value
1:             ResultSet rs = selPs.executeQuery();
1:             rs.next();
1:             assertEquals(bd.doubleValue(), rs.getDouble(1), 0.0);
1:             rs.close();
1:             // Clear out the table;
1:             assertUpdateCount(delPs, 1);
1:         }
1:         insPs.close();
1:         selPs.close();
1:         delPs.close();
1:         commit();
1:     }
1: 
1: 
1:     /**
1:      * Test BigDecimal with scale as parameter.
1:      */
1:     public void testBigDecimalSetObjectWithScale() throws Exception
1:     {
1:         getConnection().setAutoCommit(false);
1:         String sql = "CREATE TABLE numtab (num NUMERIC(10,6))";
1:         Statement stmt = createStatement();
1:         assertUpdateCount(stmt, 0, sql);
1:         stmt.close();
1:         commit();
1: 
1:         // make a big decimal from string
1:         BigDecimal bdFromString = new BigDecimal("2.33333333");
1: 
1:         sql = "INSERT INTO  numtab  VALUES(?)";
1:         PreparedStatement ps =  prepareStatement(sql);
1:         // setObject using the big decimal value
1:         int scale = 2;
1:         ps.setObject(1, bdFromString, java.sql.Types.DECIMAL, scale);
1:         assertUpdateCount(ps, 1);
1:         ps.close();
1:         // check the value
1:         sql = "SELECT num FROM numtab";
1:         stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery(sql);
1:         rs.next();
1:         // Check that the correct scale was set
1:         BigDecimal expected
0:             = bdFromString.setScale(scale, BigDecimal.ROUND_DOWN);
1:         BigDecimal actual = (BigDecimal)rs.getObject(1);
1:         assertEquals("Actual value: " + actual
1:                      + "does not match expected value: " + expected,
1:                      expected.compareTo(actual), 0);
1:         rs.close();
1:         stmt.close();
1: 
1:         commit();
1:     }
1: 
1: 
1:     /**
1:      * Test execution of batch update where the type of
1:      * a parameter varies for difference entries in the batch.
1:      */
1:      public void testVaryingClientParameterTypeBatch() throws Exception
1:      {
1:          Statement stmt = createStatement();
1:          String createSql
1:              = "create table varcharclobtab (c1 varchar(100), c2 clob)";
1:          assertUpdateCount(stmt, 0, createSql);
1:          stmt.close();
1: 
1:          PreparedStatement pStmt
1:              = prepareStatement("insert into varcharclobtab VALUES(?,?)");
1: 
1:          pStmt.setNull(1, java.sql.Types.VARCHAR);
1:          pStmt.setString(2, "clob");
1:          pStmt.addBatch();
1: 
1:          pStmt.setString(1, "varchar");
1:          pStmt.setNull(2, java.sql.Types.CLOB);
1:          pStmt.addBatch();
1: 
1:          // The following statement should not throw an exception.
1:          pStmt.executeBatch();
1: 
1:          pStmt.close();
1:      }
1: 
1: 
1:     /**
1:      * Test small (close to 0) BigDecimal parameters.
1:      */
1:     public void testSmallBigDecimal() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         String createTableSQL
1:             = "create table Numeric_Tab (MAX_VAL NUMERIC(30,15), MIN_VAL "
1:             + "NUMERIC(30,15), NULL_VAL NUMERIC(30,15) DEFAULT NULL)";
1:         // to create the Numeric Table
1:         assertUpdateCount(stmt, 0, createTableSQL);
1: 
1:         String insertSQL
1:             = "insert into Numeric_Tab "
1:             + "values(999999999999999, 0.000000000000001, null)";
1:         assertUpdateCount(stmt, 1, insertSQL);
1: 
1:         //to extract the Maximum Value of BigDecimal to be Updated
1:         String sminBigDecimalVal = "0.000000000000001";
1:         BigDecimal minBigDecimalVal = new BigDecimal(sminBigDecimalVal);
1: 
1:         // to update Null value column with Minimum value
1:         String sPrepStmt = "update Numeric_Tab set NULL_VAL=?";
1: 
1:         // Uncomment and prepare the below statement instead to see JCC bug on
1:         // setObject for decimal
1:         // String sPrepStmt ="update Numeric_Tab set NULL_VAL="
1:         //                    + sminBigDecimalVal +" where 0.0 != ?";
1: 
1:         // get the PreparedStatement object
1:         PreparedStatement pstmt = prepareStatement(sPrepStmt);
1:         pstmt.setObject(1, minBigDecimalVal);
1:         pstmt.executeUpdate();
1:         pstmt.close();
1: 
1:         //to query from the database to check the call of pstmt.executeUpdate
1:         //to get the query string
1:         String Null_Val_Query = "Select NULL_VAL from Numeric_Tab";
1:         ResultSet rs = stmt.executeQuery(Null_Val_Query);
1:         rs.next();
1: 
1:         BigDecimal rBigDecimalVal = (BigDecimal )rs.getObject(1);
1:         assertEquals(rBigDecimalVal, minBigDecimalVal);
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1: 
1:     /**
1:      * Test creation and execution of many Prepared Statements.
1:      * (Beetle 5130).
1:      */
1:     public void testManyPreparedStatements () throws Exception
1:     {
1:         int numOfPreparedStatement = 500;
1:         PreparedStatement[] tempPreparedStatement
1:             = new PreparedStatement[numOfPreparedStatement];
1: 
1:         for (int i = 0; i < numOfPreparedStatement; ++i) {
1:             tempPreparedStatement[i] = getConnection()
1:                 .prepareStatement("SELECT COUNT(*) from SYS.SYSTABLES",
1:                                    ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                    ResultSet.CONCUR_READ_ONLY);
1:             ResultSet rs = tempPreparedStatement[i].executeQuery();
1:             rs.close();
1:         }
1:         for (int i = 0; i < numOfPreparedStatement; ++i) {
1:             tempPreparedStatement[i].close();
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Test invalid Timestamp parameters.
1:      */
1:     public void testInvalidTimestamp() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         assertUpdateCount(stmt, 0,
1:                           "CREATE TABLE TSTAB "
1:                           + "(I int, STATUS_TS  Timestamp, "
1:                           + " PROPERTY_TS Timestamp)" );
1:         assertUpdateCount(stmt, 1,
1:                           "INSERT INTO TSTAB "
1:                           + "VALUES(1 , '2003-08-15 21:20:00',"
1:                           + "       '2003-08-15 21:20:00')");
1:         assertUpdateCount(stmt, 1,
1:                           "INSERT INTO TSTAB "
1:                           + "VALUES(2 ,'1969-12-31 16:00:00.0',"
1:                           + "       '2003-08-15 21:20:00')");
1:         stmt.close();
1: 
1:         String timestamp = "20";
1:         String query =
1:             "select STATUS_TS from TSTAB "
1:             + "where  (STATUS_TS >= ? or PROPERTY_TS < ?)";
1: 
1:         PreparedStatement ps = prepareStatement(query);
1:         try {
1:             // Embedded will fail in setString
1:             // Client/server will fail in executeQuery
1:             ps.setString(1, timestamp);
1:             ps.setString(2, timestamp);
1:             ResultSet rs = ps.executeQuery();
1:             rs.close();
1:             fail("Exception expected above!");
1:         }
1:         catch (SQLException e) {
1:             assertSQLState("22007", e);
1:         }
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Test how the server responds when the client closes the statement in
1:      * between split QRYDTA blocks. We have to cause a split QRYDTA block,
1:      * which we can do by having a bunch of moderately-sized rows which mostly
1:      * fill a 32K block followed by a single giant row which overflows the
1:      * block. Then, we fetch some of the rows, then close the result set.
0:      * (This is a test for Derby bug 614.)
1:      */
1:     public void testSplitQRYDTABlock() throws Exception
1:     {
1:         PreparedStatement ps
1:             = prepareStatement("create table jira614 (c1 varchar(10000))");
1:         assertUpdateCount(ps, 0);
1:         ps.close();
1: 
0:         String workString = genString("a", 150);
1:         ps = prepareStatement("insert into jira614 values (?)");
1:         ps.setString(1, workString);
1:         for (int row = 0; row < 210; ++row) ps.executeUpdate();
1: 
0:         workString = genString("b", 10000);
1:         ps.setString(1, workString);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         ps = prepareStatement("select * from jira614");
1:         ResultSet rs = ps.executeQuery();
1: 
1:         int rowNum = 0;
1:         while (rs.next()) {
1:             if (++rowNum == 26) break;
1:         }
1:         rs.close(); // This statement actually triggers the bug.
1:         ps.close();
1:     }
1: 
1:     /**
0:      * Build a string with the given number of repetions of the given pattern.
1:      *
0:      * @param c String pattern to use when building string.
0:      * @param howMany Number of repetions of the given pattern.
0:      * @return String with given number of repetitions of pattern.
1:      */
0:     private static String genString(String c, int howMany)
1:     {
1:         StringBuffer buf = new StringBuffer();
0:         for (int i = 0; i < howMany; ++i) buf.append(c);
0:         return buf.toString();
1:      }
1: 
1: 
1:     /**
0:      * Verifies that the server-side statement state is cleaned up when a
0:      * statement is re-used. Specifically, we set up a statement which has a
0:      * non-null splitQRYDTA value, then we close that statement and re-use it
0:      * for a totally unrelated query. If the splitQRYDTA wasn't cleaned up
0:      * properly, it comes flooding back as the response to that unrelated
0:      * query, causing a protocol parsing exception on the client. (This is
0:      * part two of the regression test for bug 614).
1:      */
0:     public void testServerStatementCleanUp() throws Exception
1:     {
1:         // 1: set up a second table to use for an unrelated query:
1:         Statement stmt = createStatement();
1:         stmt.execute("create table jira614_a (c1 int)");
1: 
0:         PreparedStatement ps =
0:             prepareStatement("insert into jira614_a values (?)");
1:         for (int row = 1; row <= 5; ++row)
1:         {
1:             ps.setInt(1, row);
1:             ps.executeUpdate();
1:         }
1: 
1:         // 2: get the first statement into a splitQRYDTA state:
0:         ResultSet rs = stmt.executeQuery("select * from jira614");
1:         int rowNum = 0;
1:         while (rs.next())
1:         {
1:             if (++rowNum == 26) break;
1:         }
1: 
1:         // 3: Now re-use the statement for some totally different purpose:
1:         stmt.close();
1:         stmt = createStatement();
1:         rs = stmt.executeQuery("select * from jira614_a");
1:         while (rs.next());
1:         ps.close();
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1: 
1:     /**
1:      * Test how the server handles re-synchronization of
1:      * the data stream when an enormous parameter value follows a failed
1:      * prepare statement. Note that it is deliberate here that we are
1:      * preparing a statement referring to a non-existing table.
1:      * (This is a test case for Jira-170)
1:      */
1:     public void testExcpetionWithBigParameter() throws Exception
1:     {
1:         // Create a huge array of chars to be used as the input parameter
1:         char []cData = new char[1000000];
1:         for (int i = 0; i < cData.length; ++i) {
1:             cData[i] = Character.forDigit(i%10, 10);
1:         }
1: 
1:         // The behavior of this test program depends on how the JDBC driver
1:         // handles statement prepares. The DB2 Universal JDBC driver
1:         // implements something called "deferred prepares" by default. This
1:         // means that it doesn't do the prepare of the statement until the
1:         // statement is actually executed. Other drivers, such as the
1:         // standard Derby client driver, do the prepare at the time of the
1:         // prepare. This means that, depending on which driver we're using
1:         // and what the driver's configuration is, we'll get the "table not
1:         // found" error either on the prepare or on the execute. It doesn't
1:         // really matter for the purposes of the test, because the whole
1:         // point is that we *dont* get a DRDA Protocol Exception, but rather
1:         // a table-not-found exception.
1:         PreparedStatement ps = null ;
1:         try {
1:             ps = prepareStatement("insert into jira170 values (?)");
1:             ps.setString(1, new String(cData));
1:             ps.execute();
1:             ps.close();
1:             fail("No exception when executing a failed prepare with "
1:                  + "an enormous parameter");
1:         } catch (SQLException e) { // Should get "Table not Found"
1:             assertSQLState("42X05", e);
1:         }
1:     }
1: 
1:     /**
1:      * Test the proper use of continuation headers for very large reply
1:      * messages, such as the SQLDARD which is returned for a prepared
1:      * statement with an enormous number of parameter markers. This test
1:      * generates a multi-segment SQLDARD response message from the server, to
1:      * verify that the code in DDMWriter.finalizeDSSLength is executed.
1:      *
1:      * Repro for DERBY-125 off-by-one error.  This repro runs in
1:      * two iterations.  The first iteration, we use a table name
1:      * and a column name that are extra long, so that the server-
1:      * side buffer has more data in it.  The second iteration, we
1:      * use simpler names for the table and column, which take up
1:      * less space in the server buffer.  Then, since the server-
1:      * side bytes array was previously used for a larger amount of
1:      * data, then the unused bytes contain old data.  Since we
1:      * intentionally put the "larger amount of data" into the buffer
1:      * during the first iteration, we know what the old data bytes
1:      * are going to be.  Thus, by using specific lengths for the
1:      * table and column names, we can 'shift' the old data until we
1:      * reach a point where the off-by-one error manifests itself:
1:      * namely, we end up incorrectly leaving a non-zero data byte
1:      * in the last position of the current server buffer, which
1:      * is wrong.
1:      */
1:     public void testLargeReplies() throws Exception
1:     {
1:         jira125Test_a();
1:         jira125Test_b();
1:     }
1: 
1:     /**
1:      * First iteration of testLargeReplies test case.
1:      */
1:     private void jira125Test_a() throws Exception
1:     {
1:         // Build a column name that is 99 characters long;
1:         // the length of the column name and the length of
1:         // the table name are important to the repro--so
1:         // do not change these unless you can confirm that
1:         // the new values will behave in the same way.
1:         StringBuffer id = new StringBuffer();
1:         for (int i = 0; i < 49; ++i) id.append("id");
1:         id.append("i");
1: 
1:         // Build a table name that is 97 characters long;
1:         // the length of the column name and the length of
1:         // the table name are important to the repro--so
1:         // do not change these unless you can confirm that
1:         // the new values will behave in the same way.
1:         StringBuffer tabName = new StringBuffer("jira");
1:         for (int i = 0; i < 31; ++i) tabName.append("125");
1: 
1:         Statement stmt = createStatement();
1:         stmt.execute("create table " + tabName.toString() + " (" +
1:                      id.toString() + " integer)");
1:         stmt.execute("insert into " + tabName.toString() + " values 1, 2, 3");
1:         stmt.close();
1: 
1:         StringBuffer buf = new StringBuffer();
1:         buf.append("SELECT " + id.toString() + " FROM " +
1:                    tabName.toString() + " WHERE " + id.toString() + " IN ( ");
1: 
1:         // Must have at least 551 columns here, in order to force
1:         // server buffer beyond 32k.  NOTE: Changing this number
1:         // could cause the test to "pass" even if a regression
1:         // occurs--so only change it if needed!
1:         int nCols = 554;
1:         for (int i = 0; i < nCols; ++i) buf.append("?,");
1:         buf.append("?)");
1:         PreparedStatement ps = prepareStatement(buf.toString());
1:         // Note that we actually have nCols+1 parameter markers
1:         for (int i = 0; i <= nCols; i++) ps.setInt(i+1, 1);
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next());
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Second iteration of testLargeReplies test case.
1:      */
1:     private void jira125Test_b() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         stmt.execute("create table jira125 (id integer)");
1:         stmt.execute("insert into jira125 values 1, 2, 3");
1: 
1:         StringBuffer buf = new StringBuffer();
1:         buf.append("SELECT id FROM jira125 WHERE id IN ( ");
1: 
1:         // Must have at least 551 columns here, in order to force
1:         // server buffer beyond 32k.  NOTE: Changing this number
1:         // could cause the test to "pass" even if a regression
1:         // occurs--so only change it if needed!
1:         int nCols = 556;
1:         for (int i = 0; i < nCols; i++) buf.append("?,");
1:         buf.append("?)");
1:         PreparedStatement ps = prepareStatement(buf.toString());
1:         // Note that we actually have nCols+1 parameter markers
1:         for (int i = 0; i <= nCols; i++) ps.setInt(i+1, 1);
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next());
1:         rs.close();
1:         ps.close();
1:     }
1: 
1: 
1:     /**
1:      * This test case ensures that the bug introduced by the first patch for
1:      * Jira-815 has not been re-introduced.  The bug resulted in a hang if a
1:      * prepared statement was first executed with a lob value, and then
1:      * re-executed with a null-value in place of the lob.
1:      */
1:     public void testAlternatingLobValuesAndNull()  throws Exception
1:     {
1:         getConnection().setAutoCommit(false);
1:         Statement st = createStatement();
1:         st.execute("create table tt1 (CLICOL01 smallint not null)");
1:         st.execute("alter table tt1 add clicol02 smallint");
1:         st.execute("alter table tt1 add clicol03 int not null default 1");
1:         st.execute("alter table tt1 add clicol04 int");
1:         st.execute("alter table tt1 add clicol05 decimal(10,0) not null default 1");
1:         st.execute("alter table tt1 add clicol51 blob(1G)");
1:         st.execute("alter table tt1 add clicol52 blob(50)");
1:         st.execute("alter table tt1 add clicol53 clob(2G) not null default ''");
1:         st.execute("alter table tt1 add clicol54 clob(60)");
1:         commit();
1: 
1:         PreparedStatement pSt =
1:             prepareStatement("insert into tt1 values (?,?,?,?,?,?,?,?,?)");
1:         pSt.setShort(1, (short)500);
1:         pSt.setShort(2, (short)501);
1:         pSt.setInt(3, 496);
1:         pSt.setInt(4, 497);
1:         pSt.setDouble(5, 484);
1:         pSt.setBytes(6, "404 bit".getBytes());
1:         pSt.setBytes(7, "405 bit".getBytes());
1:         pSt.setString(8, "408 bit");
1:         pSt.setString(9, "409 bit");
1: 
1:         // Inserting first row
1:         assertUpdateCount(pSt, 1);
1: 
1:         pSt.setNull(2, java.sql.Types.SMALLINT);
1:         pSt.setNull(4, java.sql.Types.DOUBLE);
1:         pSt.setNull(7, java.sql.Types.BLOB);
1:         pSt.setNull(9, java.sql.Types.CLOB);
1: 
1:         // Inserting second row
1:         assertUpdateCount(pSt, 1);
1: 
1:         // Now inserting 3rd row, using lobs from 1st row
1:         ResultSet rs = st.executeQuery("select * from tt1");
1:         rs.next();
1:         pSt.setShort(1, rs.getShort(1));
1:         pSt.setShort(2, rs.getShort(2));
1:         pSt.setInt(3, rs.getInt(3));
1:         pSt.setInt(4, rs.getInt(4));
1:         pSt.setDouble(5, rs.getDouble(5));
1:         pSt.setBlob(6, rs.getBlob(6));
1:         pSt.setBlob(7, rs.getBlob(7));
1:         pSt.setClob(8, rs.getClob(8));
1:         pSt.setClob(9, rs.getClob(9));
1:         pSt.execute();
1: 
1:         // Now inserting 4th row, using lobs from 2nd row
1:         rs.next();
1:         pSt.setNull(2, java.sql.Types.SMALLINT);
1:         pSt.setNull(4, java.sql.Types.DOUBLE);
1:         pSt.setBlob(6, rs.getBlob(6));
1:         pSt.setNull(7, java.sql.Types.BLOB);
1:         pSt.setClob(8, rs.getClob(8));
1:         pSt.setNull(9, java.sql.Types.CLOB);
1:         pSt.execute();
1: 
1:         rs.close();
1:         pSt.close();
1: 
1:         commit();
1:     }
1: 
1: 
1:     /**
1:      * Test large batch sizes for Statement.addBatch and
1:      * Statement.executeBatch.  (This is a test for Jira 428.) Currently,
1:      * there is a hard DRDA limit of 65535 statements per batch (prior to
1:      * DERBY-428, the server failed at around 9000 statements). The different
1:      * JDBC clients support slightly lower limits: the Network Client supports
1:      * 65534 statements in a single batch, the DB2JCC driver v2.4 supports
1:      * 65532 statements, the DB2JCC driver v2.6 supports 32765 statements.
1:      * This test just verifies that a batch of 32765 statements works, and
1:      * that a batch of 100000 statements gets a BatchUpdateException from the
1:      * Network Client.
1:      */
1:     public void testLargeBatch() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         stmt.execute("create table jira428 (i integer)");
1:         getConnection().setAutoCommit(false);
1: 
1:         PreparedStatement ps
1:             = prepareStatement("insert into jira428 values (?)");
1:         for (int i = 0; i < 32765; ++i) {
1:             ps.setInt(1, i);
1:             ps.addBatch();
1:         }
1:         ps.executeBatch();
1:         ps.close();
1:         commit();
1: 
1:         // The below cannot be run as part of the test for the JCC client
1:         // because the exception forces the connection closed. For
1:         // DerbyNetClient, it's a clean exception that we can catch and
1:         // recover from, so we test that code path:
1:         ps = prepareStatement("insert into jira428 values (?)");
1:         for (int i = 0; i < 100000; ++i) {
1:             ps.setInt(1, i);
1:             ps.addBatch();
1:         }
1:         try {
1:             ps.executeBatch();
1:             assertFalse("Expected exception when >65534 statements per batch",
1:                         usingDerbyNetClient());
1:         } catch (BatchUpdateException bue) {
1:             assertSQLState("XJ116", bue);
1:             assertFalse("Unexpected exception in embedded framework",
1:                         usingEmbedded());
1:         }
1:         ps.close();
1:         commit();
1:     }
1: 
1: 
1:     /**
1:      * Test for an off-by-one bug in the splitQRYDTA processing in the Network
1:      * Server writeQRYDTA code (Jira-1454), and is related to previous bugs
1:      * 614, 170, 491, and 492. The issue is that if the DSS block is exactly
1:      * the maximum DSS length (32767), then the writeQRYDTA code erroneously
1:      * thinks the DSS needs to be split when in fact it doesn't.
1:      *
1:      * The repro case sets up the boundary scenario; we run the case three
1:      * times, once with the value 1 less than the max DSS, once with the
1:      * value 1 greater than the max DSS, and once with the exact DSS length.
1:      * Only the third case triggers the JIRA-1454 bug; the other two tests
1:      * are for completeness.
1:      */
1:     public void testDSSLength() throws Exception
1:     {
1:         // Create table to be used in this test case
1:         Statement st = createStatement();
1:         st.execute(
1:             "create table jira1454(c1 varchar(20000), c2 varchar(30000))");
1:         st.close();
1: 
1:         tickleDSSLength(12748);
1:         tickleDSSLength(12750);
1:         tickleDSSLength(12749);
1:     }
1: 
1:     /**
1:      * Helper method for testDSSLength test case.  Inserts a record into a
1:      * table, and reads the content of the table before the content is
1:      * deleted.  (I.e., the table will empty when the method returns.  Use the
1:      * given length for the second parameter to the insert statement to test
1:      * different sizes for DSS blocks.
1:      *
1:      * @param c2Len Length to be used for the second
1:      */
1:     private void tickleDSSLength(int c2Len) throws Exception
1:     {
1:         char[] c1 = new char[20000];
1:         for (int i = 0; i < c1.length; ++i) {
1:             c1[i] = Character.forDigit(i%10, 10);
1:         }
1:         char[] c2 = new char[30000];
1:         for (int i = 0; i < c2Len; ++i) {
1:             c2[i] = Character.forDigit(i%10, 10);
1:         }
1: 
1:         PreparedStatement pSt =
1:             prepareStatement("insert into jira1454 values (?,?)");
1:         pSt.setString(1, new String(c1));
1:         pSt.setString(2, new String(c2, 0, c2Len));
1:         pSt.execute();
1:         pSt.close();
1: 
1:         Statement st = createStatement();
1:         ResultSet rs = st.executeQuery("select * from jira1454");
1:         while (rs.next()) {
1:             assertEquals(rs.getString("c2").length(), c2Len);
1:         }
1:         rs.close();
1: 
1:         // Clean up so table can be reused
1:         st.execute("delete from jira1454");
1:         st.close();
1:     }
1: 
1: 
1:     /**
1:      * Test two different bugs regarding the handling of large
1:      * amounts of parameter data: first, the Network Server was incorrectly
1:      * handling the desegmentation of continued DSS segments, and second,
1:      * the Network Server was using the wrong heuristic to determine whether
1:      * long string data was being flowed in-line or externalized (Jira 1533).
1:      *
1:      * Tests "a" and "b" provoke two different forms of this problem, one
1:      * with just a single continued segment, and one with several continuations
1:      */
1:     public void testLargeParameters_a() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         stmt.execute("create table jira1533_a ("
1:                      + "aa BIGINT NOT NULL, "
1:                      + "bbbbbb BIGINT DEFAULT 0 NOT NULL,"
1:                      + "cccc  VARCHAR(40), ddddddddddd BIGINT, "
1:                      + "eeeeee VARCHAR(128), ffffffffffffffffff VARCHAR(128),"
1:                      + "ggggggggg  BLOB(2G), hhhhhhhhh VARCHAR(128), "
1:                      + "iiiiiiii VARCHAR(128), jjjjjjjjjjjjjj BIGINT,"
1:                      + "kkkkkkkk CHAR(1) DEFAULT 'f', "
1:                      + "llllllll CHAR(1) DEFAULT 'f', "
1:                      + "mmmmmmmmmmmmm  CHAR(1) DEFAULT 'f')");
1:          stmt.close();
1: 
1:          PreparedStatement ps = prepareStatement(
1:              "INSERT INTO jira1533_a (aa, bbbbbb, cccc, ddddddddddd, eeeeee,"
1:              + "                      ffffffffffffffffff,"
1:              + "                      ggggggggg, hhhhhhhhh, iiiiiiii, "
1:              + "                      jjjjjjjjjjjjjj, kkkkkkkk,"
1:              + "                      llllllll,mmmmmmmmmmmmm)"
1:              + "          VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?)");
1:          String blobStr = makeString(32584);
1:          ps.setLong(1, 5);
1:          ps.setLong(2, 1);
1:          ps.setString(3, "AAAAAAAAAAA");
1:          ps.setLong(4, 30000);
1:          ps.setString(5, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:          ps.setString(6, "AAAAAAAAAAA");
1:          ps.setBytes(7, blobStr.getBytes());
1:          ps.setString(8, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:          ps.setString(9, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:          ps.setLong(10, 1);
1:          ps.setString(11, "1");
1:          ps.setString(12, "1");
1:          ps.setString(13, "1");
1:          ps.execute();
1:          ps.close();
1:     }
1: 
1:     /**
0:      *  @see testLargeParameters_a()
1:      */
1:     public void testLargeParameters_b() throws Exception
1:     {
1:         Statement stmt = createStatement();
1:         stmt.execute("create table jira1533_b ("
1:                      + "aa BIGINT NOT NULL, bbbbbb BIGINT DEFAULT 0 NOT NULL, "
1:                      + "cccc VARCHAR(40), ddddddddddd BIGINT, "
1:                      + "eeeeee VARCHAR(128), ffffffffffffffffff VARCHAR(128), "
1:                      + "g1 BLOB(2G), g2 BLOB(2G), g3 BLOB(2G), g4 BLOB(2G), "
1:                      + "ggggggggg  BLOB(2G), hhhhhhhhh VARCHAR(128), "
1:                      + "iiiiiiii VARCHAR(128), jjjjjjjjjjjjjj BIGINT,"
1:                      + "kkkkkkkk CHAR(1) DEFAULT 'f', "
1:                      + "llllllll CHAR(1) DEFAULT 'f', "
1:                      + "mmmmmmmmmmmmm  CHAR(1) DEFAULT 'f')");
1:         stmt.close();
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "INSERT INTO jira1533_b (aa, bbbbbb, cccc, ddddddddddd, eeeeee,"
1:             + "                      ffffffffffffffffff,"
1:             + "                      g1, g2, g3, g4,"
1:             + "                      ggggggggg, hhhhhhhhh, iiiiiiii,"
1:             + "                      jjjjjjjjjjjjjj, kkkkkkkk,"
1:             + "                      llllllll,mmmmmmmmmmmmm)"
1:             + "          VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
1:         String blobStr = makeString(32584);
1:         ps.setLong(1, 5);
1:         ps.setLong(2, 1);
1:         ps.setString(3, "AAAAAAAAAAA");
1:         ps.setLong(4, 30000);
1:         ps.setString(5, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:         ps.setString(6, "AAAAAAAAAAA");
1:         ps.setBytes(7, blobStr.getBytes());
1:         ps.setBytes(8, blobStr.getBytes());
1:         ps.setBytes(9, blobStr.getBytes());
1:         ps.setBytes(10 ,blobStr.getBytes());
1:         ps.setBytes(11 ,blobStr.getBytes());
1:         ps.setString(12, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:         ps.setString(13, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
1:         ps.setLong(14, 1);
1:         ps.setString(15, "1");
1:         ps.setString(16, "1");
1:         ps.setString(17, "1");
1:         ps.execute();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Return a string of the given length.  The string will contain just 'X'
1:      * characters.
1:      *
1:      * @param length Length of string to be returned.
1:      * @return String of given length.
1:      */
1:     private static String makeString(int length)
1:     {
1:         StringBuffer buf = new StringBuffer();
0:         for (int i = 0; i < length; ++i) buf.append("X");
0:         return buf.toString();
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:fca5be5
/////////////////////////////////////////////////////////////////////////
1:      * Test fix for protocol error if splitQRYDTA occurs during DRDAConnThread.doneData()
1:      * DERBY-3230
1:      * @throws SQLException
0:      */
1:     public void testDerby3230() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("CREATE TABLE TAB (col1 varchar(32672) NOT NULL)");
1:         PreparedStatement ps = prepareStatement("INSERT INTO TAB VALUES(?)");
1:         ps.setString(1,makeString(15000));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(7500));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(5000));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(2000));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(1600));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(800));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(400));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(200));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(100));
1:         ps.executeUpdate();
1:         ps.setString(1,makeString(56));
1:         ps.executeUpdate();
1:             
1:         ResultSet rs = s.executeQuery("SELECT * from tab");
1:         // drain the resultset
1:         JDBC.assertDrainResults(rs);
1:                    
1:     }
0:     /**
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:7bee3c6
/////////////////////////////////////////////////////////////////////////
1:     		assertSQLState("07009", e);
commit:53d6497
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * A test case for DERBY-3046
1:      * We were running into null pointer exception if the parameter count
1:      * for PreparedStatement was 0 and the user tried doing setObject
0:      * 
1:      * @throws Exception
0:      */
1:     public void testVariationOfSetObject() throws Exception
0:     {
1:         Statement stmt = createStatement();
1:         String createString = "CREATE TABLE WISH_LIST  "
1:         	+  "(WISH_ID INT NOT NULL GENERATED ALWAYS AS IDENTITY " 
1:         	+  "   CONSTRAINT WISH_PK PRIMARY KEY, " 
1:         	+  " ENTRY_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP, "
1:         	+  " WISH_ITEM VARCHAR(32) NOT NULL) " ;
1:         
1:         stmt.executeUpdate(createString);
1:         PreparedStatement ps = prepareStatement("insert into WISH_LIST(WISH_ITEM) values (?)");
1:         //this won't raise any errors because there is one parameter in ps
1:         ps.setString(1, "aaa");
1:         ps.executeUpdate();
1:         
1:         //Negative test case. There are no parameter in the following ps
1:         ps = prepareStatement("insert into WISH_LIST(WISH_ITEM) values ('bb')");
1:         //Try setString when no parameters in ps
1:         try {
1:         	ps.setString(1, "aaa");
1:             fail("Exception expected above!");
1:         } catch (SQLException e)  {  
1:         	if (usingDerbyNetClient())
1:         		//note that SQLState is XCL14. For setObject below, the 
1:         		//SQLState is XCL13. I have entered DERBY-3139 for this
1:         		//difference in SQLState.
1:         		assertSQLState("XCL14", e);
1:         	else
1:         		assertSQLState("07009", e);
1:         }
1:         //Try setObject when no parameters in ps
1:         try {
1:         	ps.setObject(1,"cc",java.sql.Types.VARCHAR); 
1:             fail("Exception expected above!");
1:         } catch (SQLException e)  {   
1:         	if (usingDerbyNetClient())
0:         		//note that SQLState is XCL13. For setString above, the 
0:         		//SQLState is XCL14. I have entered DERBY-3139 for this
1:         		//difference in SQLState.
1:         		assertSQLState("XCL13", e);
1:         	else
1:         		assertSQLState("07009", e);
1:         }
1:     }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:4769df5
/////////////////////////////////////////////////////////////////////////
1:  * This Junit test class tests the JDBC PreparedStatement.  This test
1:  * is a Junit version of the old prepStmt.java test.  That test tested
1:  * prepared statements in client/server context, and many of the test
1:  * cases is specifically testing corner cases in client/server
1:  * communication.  However, this Junit test is set up to run as part
1:  * of both the embedded and client/server test suites.
/////////////////////////////////////////////////////////////////////////
1:             insertSql.append(i);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:5e3c874
/////////////////////////////////////////////////////////////////////////
0: 
1:         // Some test cases for DERBY-2558, involving validation of the
1:         // parameterIndex argument to the 4-argument overload of setObject
1:         //
1:         pSt = prepareStatement("create table d2558 (i int)");
1:         assertUpdateCount(pSt, 0);
1:         pSt.close();
1:         pSt = prepareStatement("insert into d2558 values (3), (4)");
1:         assertUpdateCount(pSt, 2);
1:         pSt.close();
1:         pSt = prepareStatement("select * from d2558 where i = ?");
0:         pSt.setObject(1,new Integer(3),java.sql.Types.INTEGER,0);
1:         try {
1:             // There's only 1 parameter marker, so this should fail:
0:             pSt.setObject(2,new Integer(4), java.sql.Types.INTEGER,0);
1:             rs = pSt.executeQuery();
1:             rs.close();
1:             fail("Exception expected above!");
1:         } catch (SQLException e) {
0:             assertSQLState("XCL13", e);
0:         }
1:         pSt.close();
0: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      *  @see #testLargeParameters_a()
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:4ea33cf
/////////////////////////////////////////////////////////////////////////
0:     {	
1:         if ( JDBC.vmSupportsJSR169())
1:             // see DERBY-2233 for details
0:             return new TestSuite("empty PrepareStatementTest - client not supported on JSR169");
0:         else
0:             return TestConfiguration.defaultSuite(PrepareStatementTest.class);
============================================================================