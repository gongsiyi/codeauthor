1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.SingleChildResultSetNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
15:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:47d4a4c: import java.util.List;
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.AccessPath;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * A SingleChildResultSetNode represents a result set with a single child.
7:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: abstract class SingleChildResultSetNode extends FromTable
2:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * ResultSetNode under the SingleChildResultSetNode
1:eac0369: 	 */
1:eac0369: 	ResultSetNode	childResult;
1:eac0369: 
1:eac0369: 	// Does this node have the truly... for the underlying tree
1:eac0369: 	protected boolean hasTrulyTheBestAccessPath;
1:eac0369: 
1:3bb140c:     SingleChildResultSetNode(
1:3bb140c:             ResultSetNode childResult,
1:3bb140c:             Properties tableProperties,
1:3bb140c:             ContextManager cm) {
1:eac0369: 
1:3bb140c:         super(null /* correlationName */, tableProperties, cm);
1:3bb140c:         this.childResult = childResult;
1:eac0369: 
1:3bb140c:         /* Propagate the child's referenced table map, if one exists */
1:3bb140c:         if (childResult.getReferencedTableMap() != null) {
1:11f7ee3:             setReferencedTableMap
1:11f7ee3:                 ( (JBitSet)childResult.getReferencedTableMap().clone() );
1:3bb140c:         }
1:3bb140c:     }
1:eac0369: 
1:eac0369: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1:3bb140c:     @Override
1:eac0369: 	public AccessPath getTrulyTheBestAccessPath()
1:eac0369: 	{
1:eac0369: 		if (hasTrulyTheBestAccessPath)
1:eac0369: 		{
1:eac0369: 			return super.getTrulyTheBestAccessPath();
2:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
1:eac0369: 
1:eac0369: 		return super.getTrulyTheBestAccessPath();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the childResult from this node.
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The childResult from this node.
1:eac0369: 	 */
1:3bb140c:     ResultSetNode getChildResult()
1:eac0369: 	{
1:eac0369: 		return childResult;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the childResult for this node.
1:eac0369: 	 *
1:eac0369: 	 * @param childResult 	The new childResult for this node.
1:eac0369: 	 */
1:eac0369: 	void setChildResult(ResultSetNode childResult)
1:eac0369: 	{
1:eac0369: 		this.childResult = childResult;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#pullOptPredicates
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public void pullOptPredicates(
1:eac0369: 								OptimizablePredicateList optimizablePredicates)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			((Optimizable) childResult).pullOptPredicates(optimizablePredicates);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see Optimizable#forUpdate */
1:3bb140c:     @Override
1:eac0369: 	public boolean forUpdate()
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			return ((Optimizable) childResult).forUpdate();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return super.forUpdate();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#initAccessPaths
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public void initAccessPaths(Optimizer optimizer)
1:eac0369: 	{
1:eac0369: 		super.initAccessPaths(optimizer);
1:eac0369: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:eac0369: 			((Optimizable) childResult).initAccessPaths(optimizer);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:acdff3c: 	 * @see Optimizable#updateBestPlanMap
1:eac0369: 	 *
1:acdff3c: 	 * Makes a call to add/load/remove a plan mapping for this node,
1:62d4560: 	 * and then makes the necessary call to recurse on this node's
1:acdff3c: 	 * child, in order to ensure that we've handled the full plan
1:acdff3c: 	 * all the way down this node's subtree.
1:eac0369: 	 */
1:3bb140c:     @Override
1:acdff3c: 	public void updateBestPlanMap(short action,
1:e07631a: 		Object planKey) throws StandardException
1:eac0369: 	{
1:acdff3c: 		super.updateBestPlanMap(action, planKey);
1:eac0369: 
1:e07631a: 		// Now walk the child.  Note that if the child is not an
1:e07631a: 		// Optimizable and the call to child.getOptimizerImpl()
1:e07631a: 		// returns null, then that means we haven't tried to optimize
1:e07631a: 		// the child yet.  So in that case there's nothing to
1:e07631a: 		// add/load.
1:eac0369: 
1:62d4560: 		if (childResult instanceof Optimizable)
1:eac0369: 		{
1:62d4560: 			((Optimizable)childResult).
1:acdff3c: 				updateBestPlanMap(action, planKey);
1:eac0369: 		}
1:e07631a: 		else if (childResult.getOptimizerImpl() != null)
1:eac0369: 		{
1:62d4560: 			childResult.getOptimizerImpl().
1:acdff3c: 				updateBestPlanMaps(action, planKey);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (childResult != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "childResult: ");
1:eac0369: 				childResult.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Search to see if a query references the specifed table name.
1:eac0369: 	 *
1:eac0369: 	 * @param name		Table name (String) to search for.
1:eac0369: 	 * @param baseTable	Whether or not name is for a base table
1:eac0369: 	 *
1:eac0369: 	 * @return	true if found, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean referencesTarget(String name, boolean baseTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return childResult.referencesTarget(name, baseTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return childResult.referencesSessionSchema();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the (query block) level (0-based) for this FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @param level		The query block level for this FromTable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void setLevel(int level)
1:eac0369: 	{
1:eac0369: 		super.setLevel(level);
1:eac0369: 		if (childResult instanceof FromTable)
1:eac0369: 		{
1:eac0369: 			((FromTable) childResult).setLevel(level);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this ResultSetNode contains a subquery with a
1:eac0369: 	 * reference to the specified target.
1:eac0369: 	 * 
1:eac0369: 	 * @param name	The table name.
1:eac0369: 	 * @param baseTable	Whether or not the name is for a base table.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not a reference to the table was found.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean subqueryReferencesTarget(String name, boolean baseTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return childResult.subqueryReferencesTarget(name, baseTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:eac0369: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:eac0369: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:eac0369: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:eac0369: 	 * which points to the FromTable and the ResultColumn that is the source for
1:eac0369: 	 * the ColumnReference.  
1:eac0369: 	 * (The new PRN will have the original of the ResultColumnList and
1:eac0369: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:eac0369: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:eac0369: 	 * will remain at the FromTable, with the PRN getting a new 
1:eac0369: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:eac0369: 	 * We then project out the non-referenced columns.  If there are no referenced
1:eac0369: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:eac0369: 	 * whose expression is 1.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList) 
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.preprocess(numTables, gbl, fromList);
1:eac0369: 
1:eac0369: 		/* Build the referenced table map */
1:11f7ee3: 		setReferencedTableMap( (JBitSet) childResult.getReferencedTableMap().clone() );
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a new predicate to the list.  This is useful when doing subquery
1:eac0369: 	 * transformations, when we build a new predicate with the left side of
1:eac0369: 	 * the subquery operator and the subquery's result column.
1:eac0369: 	 *
1:eac0369: 	 * @param predicate		The predicate to add
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The new top of the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode addNewPredicate(Predicate predicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.addNewPredicate(predicate);
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push expressions down to the first ResultSetNode which can do expression
1:eac0369: 	 * evaluation and has the same referenced table map.
1:eac0369: 	 * RESOLVE - This means only pushing down single table expressions to
1:eac0369: 	 * DistinctNodes today.  Once we have a better understanding of how
1:eac0369: 	 * the optimizer will work, we can push down join clauses.
1:eac0369: 	 *
1:eac0369: 	 * @param predicateList	The PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void pushExpressions(PredicateList predicateList)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		if (childResult instanceof FromTable)
1:eac0369: 		{
1:eac0369: 			((FromTable) childResult).pushExpressions(predicateList);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1:eac0369: 	 * Currently, a FSqry is flattenable if all of the following are true:
1:eac0369: 	 *		o  Subquery is a SelectNode. 
1:eac0369: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1:eac0369: 	 *		o  It does not contain a group by or having clause
1:eac0369: 	 *		o  It does not contain aggregates.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList	The outer from list
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean flattenableInFromSubquery(FromList fromList)
1:eac0369: 	{
1:eac0369: 		/* Flattening currently involves merging predicates and FromLists.
1:eac0369: 		 * We don't have a FromList, so we can't flatten for now.
1:eac0369: 		 */
1:eac0369: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Ensure that the top of the RSN tree has a PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the query.
1:eac0369: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode ensurePredicateList(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize this SingleChildResultSetNode.  
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:6b50965: 	 * @param predicates		The PredicateList to optimize.  This should
1:eac0369: 	 *							be a join predicate.
1:eac0369: 	 * @param outerRows			The number of outer joining rows
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode	The top of the optimized subtree
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:eac0369: 								  PredicateList predicates,
1:eac0369: 								  double outerRows) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We need to implement this method since a NRSN can appear above a
1:eac0369: 		 * SelectNode in a query tree.
1:eac0369: 		 */
1:eac0369: 		childResult = childResult.optimize(
1:3bb140c: 										dataDictionary,
1:3bb140c: 										predicates,
1:eac0369: 										outerRows);
1:3bb140c: 
1:11f7ee3:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:11f7ee3: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
1:eac0369: 							childResult.getCostEstimate().rowCount(),
1:eac0369: 							childResult.getCostEstimate().singleScanRowCount());
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSetNode#modifyAccessPaths
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode modifyAccessPaths() throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.modifyAccessPaths();
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSetNode#changeAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode changeAccessPath() throws StandardException
1:eac0369: 	{
1:eac0369: 		childResult = childResult.changeAccessPath();
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Determine whether or not the specified name is an exposed name in
1:eac0369: 	 * the current query block.
1:eac0369: 	 *
1:eac0369: 	 * @param name	The specified name to search for as an exposed name.
1:eac0369: 	 * @param schemaName	Schema name, if non-null.
1:eac0369: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:eac0369: 	 *						names or match on table id.
1:eac0369: 	 *
1:eac0369: 	 * @return The FromTable, if any, with the exposed name.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement (query block) level (0-based) for this FromTable.
1:eac0369: 	 * This is useful when flattening a subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param decrement	The amount to decrement by.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void decrementLevel(int decrement)
1:eac0369: 	{
1:eac0369: 		super.decrementLevel(decrement);
1:eac0369: 		childResult.decrementLevel(decrement);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the lock mode for the target of an update statement
1:eac0369: 	 * (a delete or update).  The update mode will always be row for
1:eac0369: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1:eac0369: 	 *
1:eac0369: 	 * @return	The lock mode
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     int updateTargetLockMode()
1:eac0369: 	{
1:eac0369: 		return childResult.updateTargetLockMode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree
1:eac0369: 	 * is ordered on the specified columns.
1:eac0369: 	 * RESOLVE - This method currently only considers the outermost table 
1:eac0369: 	 * of the query block.
1:eac0369: 	 *
1:eac0369: 	 * @param	crs					The specified ColumnReference[]
1:eac0369: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
1:b153b24:      * @param   fbtHolder           List that is to be filled with the FromBaseTable
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether the underlying ResultSet tree
1:eac0369: 	 * is ordered on the specified column.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:71c8e86:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List<FromBaseTable> fbtHolder)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:b153b24:         return childResult.isOrderedOn(crs, permuteOrdering, fbtHolder);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree will return
1:eac0369: 	 * a single row, at most.
1:eac0369: 	 * This is important for join nodes where we can save the extra next
1:eac0369: 	 * on the right side if we know that it will return at most 1 row.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isOneRowResultSet() throws StandardException
1:eac0369: 	{
1:eac0369: 		// Default is false
1:eac0369: 		return childResult.isOneRowResultSet();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the underlying ResultSet tree is for a NOT EXISTS join.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the underlying ResultSet tree is for a NOT EXISTS.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isNotExists()
1:eac0369: 	{
1:eac0369: 		return childResult.isNotExists();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether we need to do reflection in order to do the projection.  
1:eac0369: 	 * Reflection is only needed if there is at least 1 column which is not
1:eac0369: 	 * simply selecting the source column.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not we need to do reflection in order to do
1:eac0369: 	 *			the projection.
1:eac0369: 	 */
1:eac0369: 	protected boolean reflectionNeededForProjection()
1:eac0369: 	{
1:11f7ee3: 		return ! (getResultColumns().allExpressionsAreColumns(childResult));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:20bd3c0: 	 * @see ResultSetNode#adjustForSortElimination
1:20bd3c0: 	 */
1:3bb140c:     @Override
1:cf530d5: 	void adjustForSortElimination()
1:eac0369: 	{
1:cf530d5: 		childResult.adjustForSortElimination();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cf530d5: 	 * @see ResultSetNode#adjustForSortElimination
1:eac0369: 	 */
1:3bb140c:     @Override
1:20bd3c0: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1:20bd3c0: 		throws StandardException
1:20bd3c0: 	{
1:20bd3c0: 		childResult.adjustForSortElimination(rowOrdering);
1:20bd3c0: 	}
1:20bd3c0: 
1:20bd3c0: 	/**
1:eac0369: 	 * Get the final CostEstimate for this node.
1:eac0369: 	 *
1:eac0369: 	 * @return	The final CostEstimate for this node, which is
1:eac0369: 	 * 			the final cost estimate for the child node.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     CostEstimate getFinalCostEstimate()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** The cost estimate will be set here if either optimize() or
1:eac0369: 		** optimizeIt() was called on this node.  It's also possible
1:eac0369: 		** that optimization was done directly on the child node,
1:eac0369: 		** in which case the cost estimate will be null here.
1:eac0369: 		*/
1:11f7ee3: 		if (getCostEstimate() == null)
1:11f7ee3:         {
1:eac0369: 			return childResult.getFinalCostEstimate();
1:11f7ee3:         }
1:eac0369: 		else
1:eac0369: 		{
1:11f7ee3: 			return getCostEstimate();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (childResult != null)
1:eac0369: 		{
1:eac0369: 			childResult = (ResultSetNode)childResult.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:             setReferencedTableMap
1:                 ( (JBitSet)childResult.getReferencedTableMap().clone() );
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( (JBitSet) childResult.getReferencedTableMap().clone() );
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		getCostEstimate().setCost(childResult.getCostEstimate().getEstimatedCost(),
/////////////////////////////////////////////////////////////////////////
1: 		return ! (getResultColumns().allExpressionsAreColumns(childResult));
/////////////////////////////////////////////////////////////////////////
1: 		if (getCostEstimate() == null)
1:         {
1:         }
1: 			return getCostEstimate();
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0:         costEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
0:                 (RequiredRowOrdering) null,
0:                 null );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List<FromBaseTable> fbtHolder)
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1:     SingleChildResultSetNode(
1:             ResultSetNode childResult,
1:             Properties tableProperties,
1:             ContextManager cm) {
1:         super(null /* correlationName */, tableProperties, cm);
1:         this.childResult = childResult;
1:         /* Propagate the child's referenced table map, if one exists */
1:         if (childResult.getReferencedTableMap() != null) {
0:             referencedTableMap =
0:                 (JBitSet)childResult.getReferencedTableMap().clone();
1:         }
1:     }
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     ResultSetNode getChildResult()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean referencesTarget(String name, boolean baseTable)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void setLevel(int level)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode addNewPredicate(Predicate predicate)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void pushExpressions(PredicateList predicateList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean flattenableInFromSubquery(FromList fromList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode ensurePredicateList(int numTables)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
0:         Optimizer opt = getOptimizer(
0:                 new FromList(getOptimizerFactory().doJoinOrderOptimization(),
0:                              getContextManager()),
1:                 predicates,
1:                 dataDictionary,
0:                 (RequiredRowOrdering) null);
1: 
0:         costEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode modifyAccessPaths() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode changeAccessPath() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     int updateTargetLockMode()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isOneRowResultSet() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isNotExists()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     CostEstimate getFinalCostEstimate()
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:b153b24
/////////////////////////////////////////////////////////////////////////
1:      * @param   fbtHolder           List that is to be filled with the FromBaseTable
0:     boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List fbtHolder)
1:         return childResult.isOrderedOn(crs, permuteOrdering, fbtHolder);
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, List fbtVector)
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (childResult != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Army
-------------------------------------------------------------------------------
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	 */
1: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1: 		throws StandardException
1: 	{
1: 		childResult.adjustForSortElimination(rowOrdering);
1: 	}
1: 
1: 	/**
commit:cf530d5
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	void adjustForSortElimination()
1: 		childResult.adjustForSortElimination();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:acdff3c
/////////////////////////////////////////////////////////////////////////
1: 	 * @see Optimizable#updateBestPlanMap
1: 	 * Makes a call to add/load/remove a plan mapping for this node,
1: 	 * child, in order to ensure that we've handled the full plan
1: 	 * all the way down this node's subtree.
1: 	public void updateBestPlanMap(short action,
1: 		super.updateBestPlanMap(action, planKey);
/////////////////////////////////////////////////////////////////////////
1: 				updateBestPlanMap(action, planKey);
1: 				updateBestPlanMaps(action, planKey);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.SingleChildResultSetNode
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * A SingleChildResultSetNode represents a result set with a single child.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
1: abstract class SingleChildResultSetNode extends FromTable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/**
1: 	 * ResultSetNode under the SingleChildResultSetNode
1: 	 */
1: 	ResultSetNode	childResult;
1: 
1: 	// Does this node have the truly... for the underlying tree
1: 	protected boolean hasTrulyTheBestAccessPath;
1: 
1: 
1: 	/**
0: 	 * Initialilzer for a SingleChildResultSetNode.
1: 	 *
0: 	 * @param childResult	The child ResultSetNode
0: 	 * @param tableProperties	Properties list associated with the table
1: 	 */
1: 
0: 	public void init(Object childResult, Object tableProperties)
1: 	{
0: 		/* correlationName is always null */
0: 		super.init(null, tableProperties);
0: 		this.childResult = (ResultSetNode) childResult;
1: 
0: 		/* Propagate the child's referenced table map, if one exists */
0: 		if (this.childResult.getReferencedTableMap() != null)
1: 		{
0: 			referencedTableMap =
0: 				(JBitSet) this.childResult.getReferencedTableMap().clone();
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#getTrulyTheBestAccessPath */
1: 	public AccessPath getTrulyTheBestAccessPath()
1: 	{
1: 		if (hasTrulyTheBestAccessPath)
1: 		{
1: 			return super.getTrulyTheBestAccessPath();
1: 		}
1: 
1: 		if (childResult instanceof Optimizable)
1: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
1: 
1: 		return super.getTrulyTheBestAccessPath();
1: 	}
1: 
1: 	/**
1: 	 * Return the childResult from this node.
1: 	 *
1: 	 * @return ResultSetNode	The childResult from this node.
1: 	 */
0: 	public ResultSetNode getChildResult()
1: 	{
1: 		return childResult;
1: 	}
1: 
1: 	/**
1: 	 * Set the childResult for this node.
1: 	 *
1: 	 * @param childResult 	The new childResult for this node.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setChildResult(ResultSetNode childResult)
1: 	{
1: 		this.childResult = childResult;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#pullOptPredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void pullOptPredicates(
1: 								OptimizablePredicateList optimizablePredicates)
1: 			throws StandardException
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			((Optimizable) childResult).pullOptPredicates(optimizablePredicates);
1: 		}
1: 	}
1: 
1: 	/** @see Optimizable#forUpdate */
1: 	public boolean forUpdate()
1: 	{
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			return ((Optimizable) childResult).forUpdate();
1: 		}
1: 		else
1: 		{
1: 			return super.forUpdate();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#initAccessPaths
1: 	 */
1: 	public void initAccessPaths(Optimizer optimizer)
1: 	{
1: 		super.initAccessPaths(optimizer);
1: 		if (childResult instanceof Optimizable)
1: 		{
1: 			((Optimizable) childResult).initAccessPaths(optimizer);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (childResult != null)
1: 			{
1: 				printLabel(depth, "childResult: ");
1: 				childResult.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Search to see if a query references the specifed table name.
1: 	 *
1: 	 * @param name		Table name (String) to search for.
1: 	 * @param baseTable	Whether or not name is for a base table
1: 	 *
1: 	 * @return	true if found, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
1: 		throws StandardException
1: 	{
1: 		return childResult.referencesTarget(name, baseTable);
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		return childResult.referencesSessionSchema();
1: 	}
1: 
1: 	/**
1: 	 * Set the (query block) level (0-based) for this FromTable.
1: 	 *
1: 	 * @param level		The query block level for this FromTable.
1: 	 *
0: 	 * @return Nothing
1: 	 */
0: 	public void setLevel(int level)
1: 	{
1: 		super.setLevel(level);
1: 		if (childResult instanceof FromTable)
1: 		{
1: 			((FromTable) childResult).setLevel(level);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this ResultSetNode contains a subquery with a
1: 	 * reference to the specified target.
1: 	 * 
1: 	 * @param name	The table name.
1: 	 * @param baseTable	Whether or not the name is for a base table.
1: 	 *
1: 	 * @return boolean	Whether or not a reference to the table was found.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean subqueryReferencesTarget(String name, boolean baseTable)
1: 		throws StandardException
1: 	{
1: 		return childResult.subqueryReferencesTarget(name, baseTable);
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList) 
1: 								throws StandardException
1: 	{
1: 		childResult = childResult.preprocess(numTables, gbl, fromList);
1: 
1: 		/* Build the referenced table map */
0: 		referencedTableMap = (JBitSet) childResult.getReferencedTableMap().clone();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Add a new predicate to the list.  This is useful when doing subquery
1: 	 * transformations, when we build a new predicate with the left side of
1: 	 * the subquery operator and the subquery's result column.
1: 	 *
1: 	 * @param predicate		The predicate to add
1: 	 *
1: 	 * @return ResultSetNode	The new top of the tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
1: 			throws StandardException
1: 	{
1: 		childResult = childResult.addNewPredicate(predicate);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Push expressions down to the first ResultSetNode which can do expression
1: 	 * evaluation and has the same referenced table map.
1: 	 * RESOLVE - This means only pushing down single table expressions to
1: 	 * DistinctNodes today.  Once we have a better understanding of how
1: 	 * the optimizer will work, we can push down join clauses.
1: 	 *
1: 	 * @param predicateList	The PredicateList.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void pushExpressions(PredicateList predicateList)
1: 					throws StandardException
1: 	{
1: 		if (childResult instanceof FromTable)
1: 		{
1: 			((FromTable) childResult).pushExpressions(predicateList);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1: 	 * Currently, a FSqry is flattenable if all of the following are true:
1: 	 *		o  Subquery is a SelectNode. 
1: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1: 	 *		o  It does not contain a group by or having clause
1: 	 *		o  It does not contain aggregates.
1: 	 *
1: 	 * @param fromList	The outer from list
1: 	 *
1: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
1: 		/* Flattening currently involves merging predicates and FromLists.
1: 		 * We don't have a FromList, so we can't flatten for now.
1: 		 */
1: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Ensure that the top of the RSN tree has a PredicateList.
1: 	 *
1: 	 * @param numTables			The number of tables in the query.
1: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
1: 		throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Optimize this SingleChildResultSetNode.  
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
1: 	 *							be a join predicate.
1: 	 * @param outerRows			The number of outer joining rows
1: 	 *
1: 	 * @return	ResultSetNode	The top of the optimized subtree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 								  PredicateList predicates,
1: 								  double outerRows) 
1: 					throws StandardException
1: 	{
1: 		/* We need to implement this method since a NRSN can appear above a
1: 		 * SelectNode in a query tree.
1: 		 */
1: 		childResult = childResult.optimize(
0: 										dataDictionary,
0: 										predicates,
1: 										outerRows);
1: 
0: 		Optimizer optimizer =
0: 							getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 							predicates,
0: 							dataDictionary,
0: 							(RequiredRowOrdering) null);
0: 		costEstimate = optimizer.newCostEstimate();
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
1: 							childResult.getCostEstimate().rowCount(),
1: 							childResult.getCostEstimate().singleScanRowCount());
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#modifyAccessPaths
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
1: 	{
1: 		childResult = childResult.modifyAccessPaths();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#changeAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode changeAccessPath() throws StandardException
1: 	{
1: 		childResult = childResult.changeAccessPath();
1: 		return this;
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for this FromTable.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		super.decrementLevel(decrement);
1: 		childResult.decrementLevel(decrement);
1: 	}
1: 
1: 	/**
1: 	 * Get the lock mode for the target of an update statement
1: 	 * (a delete or update).  The update mode will always be row for
1: 	 * CurrentOfNodes.  It will be table if there is no where clause.
1: 	 *
1: 	 * @return	The lock mode
1: 	 */
0: 	public int updateTargetLockMode()
1: 	{
1: 		return childResult.updateTargetLockMode();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree
1: 	 * is ordered on the specified columns.
1: 	 * RESOLVE - This method currently only considers the outermost table 
1: 	 * of the query block.
1: 	 *
1: 	 * @param	crs					The specified ColumnReference[]
1: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
0: 	 * @param	fbtVector			Vector that is to be filled with the FromBaseTable	
1: 	 *
1: 	 * @return	Whether the underlying ResultSet tree
1: 	 * is ordered on the specified column.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, Vector fbtVector)
1: 				throws StandardException
1: 	{
0: 		return childResult.isOrderedOn(crs, permuteOrdering, fbtVector);
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree will return
1: 	 * a single row, at most.
1: 	 * This is important for join nodes where we can save the extra next
1: 	 * on the right side if we know that it will return at most 1 row.
1: 	 *
1: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
1: 	{
1: 		// Default is false
1: 		return childResult.isOneRowResultSet();
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not the underlying ResultSet tree is for a NOT EXISTS join.
1: 	 *
1: 	 * @return Whether or not the underlying ResultSet tree is for a NOT EXISTS.
1: 	 */
0: 	public boolean isNotExists()
1: 	{
1: 		return childResult.isNotExists();
1: 	}
1: 
1: 	/**
1: 	 * Determine whether we need to do reflection in order to do the projection.  
1: 	 * Reflection is only needed if there is at least 1 column which is not
1: 	 * simply selecting the source column.
1: 	 *
1: 	 * @return	Whether or not we need to do reflection in order to do
1: 	 *			the projection.
1: 	 */
1: 	protected boolean reflectionNeededForProjection()
1: 	{
0: 		return ! (resultColumns.allExpressionsAreColumns(childResult));
1: 	}
1: 
1: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
1: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
1: 		throws StandardException
1: 	{
0: 		childResult.replaceDefaults(ttd, tcl);
1: 	}
1: 
1: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void markOrderingDependent()
1: 	{
0: 		childResult.markOrderingDependent();
1: 	}
1: 
1: 	/**
1: 	 * Get the final CostEstimate for this node.
1: 	 *
1: 	 * @return	The final CostEstimate for this node, which is
1: 	 * 			the final cost estimate for the child node.
1: 	 */
0: 	public CostEstimate getFinalCostEstimate()
1: 	{
1: 		/*
1: 		** The cost estimate will be set here if either optimize() or
1: 		** optimizeIt() was called on this node.  It's also possible
1: 		** that optimization was done directly on the child node,
1: 		** in which case the cost estimate will be null here.
1: 		*/
0: 		if (costEstimate == null)
1: 			return childResult.getFinalCostEstimate();
1: 		else
1: 		{
0: 			return costEstimate;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (childResult != null && !v.stopTraversal())
1: 		{
1: 			childResult = (ResultSetNode)childResult.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param predicates		The PredicateList to optimize.  This should
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		Object planKey) throws StandardException
0: 		super.addOrLoadBestPlanMapping(doAdd, planKey);
0: 
1: 		// Now walk the child.  Note that if the child is not an
1: 		// Optimizable and the call to child.getOptimizerImpl()
1: 		// returns null, then that means we haven't tried to optimize
1: 		// the child yet.  So in that case there's nothing to
1: 		// add/load.
0: 
0: 				addOrLoadBestPlanMapping(doAdd, planKey);
1: 		else if (childResult.getOptimizerImpl() != null)
0: 				addOrLoadBestPlanMappings(doAdd, planKey);
commit:ab10884
/////////////////////////////////////////////////////////////////////////
0: 		throws StandardException
commit:62d4560
/////////////////////////////////////////////////////////////////////////
0: 	 * @see Optimizable#addOrLoadBestPlanMapping
0: 	 *
0: 	 * Makes a call to add/load the plan mapping for this node,
1: 	 * and then makes the necessary call to recurse on this node's
0: 	 * child, in order to ensure that we have a full plan mapped.
0: 	 */
0: 	public void addOrLoadBestPlanMapping(boolean doAdd,
0: 		Optimizer optimizer) throws StandardException
0: 	{
0: 		super.addOrLoadBestPlanMapping(doAdd, optimizer);
1: 		if (childResult instanceof Optimizable)
0: 		{
1: 			((Optimizable)childResult).
0: 				addOrLoadBestPlanMapping(doAdd, optimizer);
0: 		}
0: 		else
0: 		{
1: 			childResult.getOptimizerImpl().
0: 				addOrLoadBestPlanMappings(doAdd, optimizer);
0: 		}
0: 	}
0: 
0: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * A SingleChildResultSetNode represents a result set with a single child.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: abstract class SingleChildResultSetNode extends FromTable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/**
0: 	 * ResultSetNode under the SingleChildResultSetNode
0: 	 */
0: 	ResultSetNode	childResult;
0: 
0: 	// Does this node have the truly... for the underlying tree
0: 	protected boolean hasTrulyTheBestAccessPath;
0: 
0: 
0: 	/**
0: 	 * Initialilzer for a SingleChildResultSetNode.
0: 	 *
0: 	 * @param childResult	The child ResultSetNode
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 */
0: 
0: 	public void init(Object childResult, Object tableProperties)
0: 	{
0: 		/* correlationName is always null */
0: 		super.init(null, tableProperties);
0: 		this.childResult = (ResultSetNode) childResult;
0: 
0: 		/* Propagate the child's referenced table map, if one exists */
0: 		if (this.childResult.getReferencedTableMap() != null)
0: 		{
0: 			referencedTableMap =
0: 				(JBitSet) this.childResult.getReferencedTableMap().clone();
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#getTrulyTheBestAccessPath */
0: 	public AccessPath getTrulyTheBestAccessPath()
0: 	{
0: 		if (hasTrulyTheBestAccessPath)
0: 		{
0: 			return super.getTrulyTheBestAccessPath();
0: 		}
0: 
0: 		if (childResult instanceof Optimizable)
0: 			return ((Optimizable) childResult).getTrulyTheBestAccessPath();
0: 
0: 		return super.getTrulyTheBestAccessPath();
0: 	}
0: 
0: 	/**
0: 	 * Return the childResult from this node.
0: 	 *
0: 	 * @return ResultSetNode	The childResult from this node.
0: 	 */
0: 	public ResultSetNode getChildResult()
0: 	{
0: 		return childResult;
0: 	}
0: 
0: 	/**
0: 	 * Set the childResult for this node.
0: 	 *
0: 	 * @param childResult 	The new childResult for this node.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setChildResult(ResultSetNode childResult)
0: 	{
0: 		this.childResult = childResult;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#pullOptPredicates
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pullOptPredicates(
0: 								OptimizablePredicateList optimizablePredicates)
0: 			throws StandardException
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			((Optimizable) childResult).pullOptPredicates(optimizablePredicates);
0: 		}
0: 	}
0: 
0: 	/** @see Optimizable#forUpdate */
0: 	public boolean forUpdate()
0: 	{
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			return ((Optimizable) childResult).forUpdate();
0: 		}
0: 		else
0: 		{
0: 			return super.forUpdate();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#initAccessPaths
0: 	 */
0: 	public void initAccessPaths(Optimizer optimizer)
0: 	{
0: 		super.initAccessPaths(optimizer);
0: 		if (childResult instanceof Optimizable)
0: 		{
0: 			((Optimizable) childResult).initAccessPaths(optimizer);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (childResult != null)
0: 			{
0: 				printLabel(depth, "childResult: ");
0: 				childResult.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Search to see if a query references the specifed table name.
0: 	 *
0: 	 * @param name		Table name (String) to search for.
0: 	 * @param baseTable	Whether or not name is for a base table
0: 	 *
0: 	 * @return	true if found, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
0: 		throws StandardException
0: 	{
0: 		return childResult.referencesTarget(name, baseTable);
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		return childResult.referencesSessionSchema();
0: 	}
0: 
0: 	/**
0: 	 * Set the (query block) level (0-based) for this FromTable.
0: 	 *
0: 	 * @param level		The query block level for this FromTable.
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	public void setLevel(int level)
0: 	{
0: 		super.setLevel(level);
0: 		if (childResult instanceof FromTable)
0: 		{
0: 			((FromTable) childResult).setLevel(level);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this ResultSetNode contains a subquery with a
0: 	 * reference to the specified target.
0: 	 * 
0: 	 * @param name	The table name.
0: 	 * @param baseTable	Whether or not the name is for a base table.
0: 	 *
0: 	 * @return boolean	Whether or not a reference to the table was found.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean subqueryReferencesTarget(String name, boolean baseTable)
0: 		throws StandardException
0: 	{
0: 		return childResult.subqueryReferencesTarget(name, baseTable);
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList) 
0: 								throws StandardException
0: 	{
0: 		childResult = childResult.preprocess(numTables, gbl, fromList);
0: 
0: 		/* Build the referenced table map */
0: 		referencedTableMap = (JBitSet) childResult.getReferencedTableMap().clone();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Add a new predicate to the list.  This is useful when doing subquery
0: 	 * transformations, when we build a new predicate with the left side of
0: 	 * the subquery operator and the subquery's result column.
0: 	 *
0: 	 * @param predicate		The predicate to add
0: 	 *
0: 	 * @return ResultSetNode	The new top of the tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
0: 			throws StandardException
0: 	{
0: 		childResult = childResult.addNewPredicate(predicate);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Push expressions down to the first ResultSetNode which can do expression
0: 	 * evaluation and has the same referenced table map.
0: 	 * RESOLVE - This means only pushing down single table expressions to
0: 	 * DistinctNodes today.  Once we have a better understanding of how
0: 	 * the optimizer will work, we can push down join clauses.
0: 	 *
0: 	 * @param predicateList	The PredicateList.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pushExpressions(PredicateList predicateList)
0: 					throws StandardException
0: 	{
0: 		if (childResult instanceof FromTable)
0: 		{
0: 			((FromTable) childResult).pushExpressions(predicateList);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode. 
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		/* Flattening currently involves merging predicates and FromLists.
0: 		 * We don't have a FromList, so we can't flatten for now.
0: 		 */
0: 		/* RESOLVE - this will introduce yet another unnecessary PRN */
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
0: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
0: 		throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Optimize this SingleChildResultSetNode.  
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to optimize.  This should
0: 	 *							be a join predicate.
0: 	 * @param outerRows			The number of outer joining rows
0: 	 *
0: 	 * @return	ResultSetNode	The top of the optimized subtree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 								  PredicateList predicates,
0: 								  double outerRows) 
0: 					throws StandardException
0: 	{
0: 		/* We need to implement this method since a NRSN can appear above a
0: 		 * SelectNode in a query tree.
0: 		 */
0: 		childResult = childResult.optimize(
0: 										dataDictionary,
0: 										predicates,
0: 										outerRows);
0: 
0: 		Optimizer optimizer =
0: 							getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 							predicates,
0: 							dataDictionary,
0: 							(RequiredRowOrdering) null);
0: 		costEstimate = optimizer.newCostEstimate();
0: 		costEstimate.setCost(childResult.getCostEstimate().getEstimatedCost(),
0: 							childResult.getCostEstimate().rowCount(),
0: 							childResult.getCostEstimate().singleScanRowCount());
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#modifyAccessPaths
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
0: 	{
0: 		childResult = childResult.modifyAccessPaths();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#changeAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode changeAccessPath() throws StandardException
0: 	{
0: 		childResult = childResult.changeAccessPath();
0: 		return this;
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		return childResult.getFromTableByName(name, schemaName, exactMatch);
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for this FromTable.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		super.decrementLevel(decrement);
0: 		childResult.decrementLevel(decrement);
0: 	}
0: 
0: 	/**
0: 	 * Get the lock mode for the target of an update statement
0: 	 * (a delete or update).  The update mode will always be row for
0: 	 * CurrentOfNodes.  It will be table if there is no where clause.
0: 	 *
0: 	 * @return	The lock mode
0: 	 */
0: 	public int updateTargetLockMode()
0: 	{
0: 		return childResult.updateTargetLockMode();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree
0: 	 * is ordered on the specified columns.
0: 	 * RESOLVE - This method currently only considers the outermost table 
0: 	 * of the query block.
0: 	 *
0: 	 * @param	crs					The specified ColumnReference[]
0: 	 * @param	permuteOrdering		Whether or not the order of the CRs in the array can be permuted
0: 	 * @param	fbtVector			Vector that is to be filled with the FromBaseTable	
0: 	 *
0: 	 * @return	Whether the underlying ResultSet tree
0: 	 * is ordered on the specified column.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean isOrderedOn(ColumnReference[] crs, boolean permuteOrdering, Vector fbtVector)
0: 				throws StandardException
0: 	{
0: 		return childResult.isOrderedOn(crs, permuteOrdering, fbtVector);
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree will return
0: 	 * a single row, at most.
0: 	 * This is important for join nodes where we can save the extra next
0: 	 * on the right side if we know that it will return at most 1 row.
0: 	 *
0: 	 * @return Whether or not the underlying ResultSet tree will return a single row.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isOneRowResultSet()	throws StandardException
0: 	{
0: 		// Default is false
0: 		return childResult.isOneRowResultSet();
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the underlying ResultSet tree is for a NOT EXISTS join.
0: 	 *
0: 	 * @return Whether or not the underlying ResultSet tree is for a NOT EXISTS.
0: 	 */
0: 	public boolean isNotExists()
0: 	{
0: 		return childResult.isNotExists();
0: 	}
0: 
0: 	/**
0: 	 * Determine whether we need to do reflection in order to do the projection.  
0: 	 * Reflection is only needed if there is at least 1 column which is not
0: 	 * simply selecting the source column.
0: 	 *
0: 	 * @return	Whether or not we need to do reflection in order to do
0: 	 *			the projection.
0: 	 */
0: 	protected boolean reflectionNeededForProjection()
0: 	{
0: 		return ! (resultColumns.allExpressionsAreColumns(childResult));
0: 	}
0: 
0: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
0: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
0: 		throws StandardException
0: 	{
0: 		childResult.replaceDefaults(ttd, tcl);
0: 	}
0: 
0: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markOrderingDependent()
0: 	{
0: 		childResult.markOrderingDependent();
0: 	}
0: 
0: 	/**
0: 	 * Get the final CostEstimate for this node.
0: 	 *
0: 	 * @return	The final CostEstimate for this node, which is
0: 	 * 			the final cost estimate for the child node.
0: 	 */
0: 	public CostEstimate getFinalCostEstimate()
0: 	{
0: 		/*
0: 		** The cost estimate will be set here if either optimize() or
0: 		** optimizeIt() was called on this node.  It's also possible
0: 		** that optimization was done directly on the child node,
0: 		** in which case the cost estimate will be null here.
0: 		*/
0: 		if (costEstimate == null)
0: 			return childResult.getFinalCostEstimate();
0: 		else
0: 		{
0: 			return costEstimate;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (childResult != null && !v.stopTraversal())
0: 		{
0: 			childResult = (ResultSetNode)childResult.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================