1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.NumericConstantNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
23:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:5465561: import java.math.BigDecimal;
1:3bb140c: import java.sql.Types;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeUtilities;
1:3bb140c: import org.apache.derby.iapi.types.NumberDataValue;
1:5465561: import org.apache.derby.iapi.types.SQLDecimal;
1:4309044: import org.apache.derby.iapi.types.SQLDouble;
1:c8c1551: import org.apache.derby.iapi.types.SQLInteger;
1:4309044: import org.apache.derby.iapi.types.SQLLongint;
1:4309044: import org.apache.derby.iapi.types.SQLReal;
1:4309044: import org.apache.derby.iapi.types.SQLSmallint;
1:4309044: import org.apache.derby.iapi.types.SQLTinyint;
1:eac0369: import org.apache.derby.iapi.types.TypeId;
1:eac0369: 
1:eac0369: public final class NumericConstantNode extends ConstantNode
16:eac0369: {
1:2706d1f: 
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_TINYINT = 0;
1:2706d1f:     final static int K_SMALLINT = 1;
1:2706d1f:     final static int K_INT = 2;
1:2706d1f:     final static int K_BIGINT = 3;
1:2706d1f:     final static int K_DECIMAL = 4;
1:2706d1f:     final static int K_DOUBLE = 5;
1:2706d1f:     final static int K_REAL = 6;
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a typed null node
1:3bb140c:      * @param t type
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     NumericConstantNode(TypeId t, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(cm);
1:3bb140c:         setType(t,
1:3bb140c:                 getPrecision(t, null),
1:3bb140c:                 getScale(t, null),
1:3bb140c:                 true,
1:3bb140c:                 getMaxWidth(t, null));
1:2706d1f:         kind = getKind(t);
1:3bb140c:     }
1:2706d1f: 
1:3bb140c:     /**
1:3bb140c:      * @param value An object containing the value of the constant.
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:5465561:     NumericConstantNode(TypeId t, Number value, ContextManager cm)
1:3bb140c:             throws StandardException {
1:3bb140c:         super(cm);
1:2706d1f:         kind = getKind(t);
1:3bb140c:         setType(t,
1:3bb140c:                 getPrecision(t, value),
1:3bb140c:                 getScale(t, value),
1:3bb140c:                 false,
1:3bb140c:                 getMaxWidth(t, value));
1:3bb140c:         setValue(t, value);
1:3bb140c:     }
1:3bb140c: 
1:5465561:     private int getPrecision(TypeId t, Number val) throws StandardException {
1:509ccb9: 
1:2706d1f:         switch (t.getJDBCTypeId()) {
1:2706d1f: 
1:2706d1f:         case Types.TINYINT:
1:2706d1f:             return TypeId.SMALLINT_PRECISION; // FIXME
1:2706d1f:         case Types.INTEGER:
1:2706d1f:             return TypeId.INT_PRECISION;
1:2706d1f:         case Types.SMALLINT:
1:2706d1f:             return TypeId.SMALLINT_PRECISION;
1:2706d1f:         case Types.BIGINT:
1:2706d1f:             return TypeId.LONGINT_PRECISION;
1:2706d1f:         case Types.DECIMAL:
1:3bb140c:             if (val != null) {
1:5465561:                 SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
1:2706d1f:                 return constantDecimal.getDecimalValuePrecision();
1:3bb140c:             } else {
1:3bb140c:                 return TypeId.DECIMAL_PRECISION;
1:3bb140c:             }
1:2706d1f:         case Types.DOUBLE:
1:2706d1f:             return TypeId.DOUBLE_PRECISION;
1:2706d1f:         case Types.REAL:
1:2706d1f:             return TypeId.REAL_PRECISION;
1:2706d1f:         default:
1:2706d1f:             if (SanityManager.DEBUG) {
1:3bb140c:                 SanityManager.NOTREACHED();
1:2706d1f:             }
1:2706d1f:             return 0;
1:3bb140c: 		}
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     private int getScale(TypeId t, Object val) throws StandardException {
1:2706d1f:         switch (t.getJDBCTypeId()) {
1:2706d1f:         case Types.TINYINT:
1:2706d1f:             return TypeId.SMALLINT_SCALE; // FIXME
1:2706d1f:         case Types.INTEGER:
1:2706d1f:             return TypeId.INT_SCALE;
1:2706d1f:         case Types.SMALLINT:
1:2706d1f:             return TypeId.SMALLINT_SCALE;
1:2706d1f:         case Types.BIGINT:
1:2706d1f:             return TypeId.LONGINT_SCALE;
1:2706d1f:         case Types.DECIMAL:
1:3bb140c:             if (val != null) {
1:5465561:                 SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
1:2706d1f:                 return constantDecimal.getDecimalValueScale();
1:3bb140c:             } else {
1:3bb140c:                 return TypeId.DECIMAL_SCALE;
1:3bb140c:             }
1:2706d1f:         case Types.DOUBLE:
1:3bb140c:             return TypeId.DOUBLE_SCALE;
1:2706d1f:         case Types.REAL:
1:2706d1f:             return TypeId.REAL_SCALE;
1:2706d1f:         default:
1:2706d1f:             if (SanityManager.DEBUG) {
1:3bb140c:                 SanityManager.NOTREACHED();
1:2706d1f:             }
1:2706d1f:             return 0;
1:3bb140c:         }
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     private int getMaxWidth(TypeId t, Object val) throws StandardException {
2:3bb140c:        switch (t.getJDBCTypeId()) {
3:3bb140c:        case Types.TINYINT:
1:3bb140c:            return val != null ? TypeId.SMALLINT_MAXWIDTH : 0; // FIXME
3:3bb140c:        case Types.INTEGER:
1:3bb140c:            return val != null ? TypeId.INT_MAXWIDTH : 0;
3:3bb140c:        case Types.SMALLINT:
1:3bb140c:            return val != null ? TypeId.SMALLINT_MAXWIDTH : 0;
3:3bb140c:        case Types.BIGINT:
1:3bb140c:            return val != null ? TypeId.LONGINT_MAXWIDTH: 0;
3:3bb140c:        case Types.DECIMAL:
1:3bb140c:             if (val != null) {
1:5465561:                SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
1:3bb140c:                int precision = constantDecimal.getDecimalValuePrecision();
1:3bb140c:                int scal = constantDecimal.getDecimalValueScale();
1:3bb140c:                /* be consistent with our convention on maxwidth, see also
1:3bb140c:                 * exactNumericType(), otherwise we get format problem, b 3923
1:3bb140c:                 */
1:3bb140c:                return DataTypeUtilities.computeMaxWidth(precision, scal);
1:3bb140c:             } else {
1:3bb140c:                 return TypeId.DECIMAL_MAXWIDTH;
1:3bb140c:             }
3:3bb140c:        case Types.DOUBLE:
1:3bb140c:            return val != null ? TypeId.DOUBLE_MAXWIDTH : 0;
3:3bb140c:        case Types.REAL:
1:3bb140c:            return val != null ? TypeId.REAL_MAXWIDTH : 0;
2:3bb140c:        default:
3:3bb140c:            if (SanityManager.DEBUG) {
1:3bb140c:                 SanityManager.NOTREACHED();
1:3bb140c:            }
4:3bb140c:            return 0;
1:3bb140c:        }
1:3bb140c:     }
1:eac0369: 
1:2706d1f:     private int getKind(TypeId t) {
1:3bb140c:        switch (t.getJDBCTypeId()) {
1:3bb140c:        case Types.TINYINT:
1:2706d1f:            return K_TINYINT;
1:3bb140c:        case Types.INTEGER:
1:2706d1f:            return K_INT;
1:3bb140c:        case Types.SMALLINT:
1:2706d1f:            return K_SMALLINT;
1:3bb140c:        case Types.BIGINT:
1:2706d1f:            return K_BIGINT;
1:3bb140c:        case Types.DECIMAL:
1:2706d1f:             return K_DECIMAL;
1:3bb140c:        case Types.DOUBLE:
1:2706d1f:            return K_DOUBLE;
1:3bb140c:        case Types.REAL:
1:2706d1f:            return K_REAL;
1:3bb140c:        default:
1:3bb140c:            if (SanityManager.DEBUG) {
1:3bb140c:                 SanityManager.NOTREACHED();
1:3bb140c:            }
1:2706d1f:            return -1;
1:3bb140c:        }
1:3bb140c:     }
1:eac0369: 
1:5465561:     private void setValue(TypeId t, Number value ) throws StandardException {
1:3bb140c:        switch (t.getJDBCTypeId()) {
1:3bb140c:        case Types.TINYINT:
1:3bb140c:            setValue(new SQLTinyint((Byte)value));
1:3bb140c:             break;
1:3bb140c:        case Types.INTEGER:
1:3bb140c:            setValue(new SQLInteger((Integer)value));
1:3bb140c:             break;
1:3bb140c:        case Types.SMALLINT:
1:3bb140c:            setValue(new SQLSmallint((Short)value));
1:3bb140c:             break;
1:3bb140c:        case Types.BIGINT:
1:3bb140c:            setValue(new SQLLongint((Long)value));
1:3bb140c:             break;
1:3bb140c:        case Types.DECIMAL:
1:5465561:            setValue(new SQLDecimal((BigDecimal)value));
1:3bb140c:             break;
1:3bb140c:        case Types.DOUBLE:
1:3bb140c:            setValue(new SQLDouble((Double)value));
1:3bb140c:             break;
1:3bb140c:        case Types.REAL:
1:3bb140c:            setValue(new SQLReal((Float)value));
1:3bb140c:             break;
1:3bb140c:        default:
1:3bb140c:            if (SanityManager.DEBUG) {
1:3bb140c:                 SanityManager.NOTREACHED();
1:3bb140c:            }
1:3bb140c:        }
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     /**
1:eac0369: 	 * Return an Object representing the bind time value of this
1:eac0369: 	 * expression tree.  If the expression tree does not evaluate to
1:eac0369: 	 * a constant at bind time then we return null.
1:eac0369: 	 * This is useful for bind time resolution of VTIs.
1:eac0369: 	 * RESOLVE: What do we do for primitives?
8:eac0369: 	 *
1:eac0369: 	 * @return	An Object representing the bind time value of this expression tree.
1:eac0369: 	 *			(null if not a bind time constant.)
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	Object getConstantValueAsObject()
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return value.getObject();
1:3bb140c: 	}
1:eac0369: 
5:eac0369: 		/**
1:eac0369: 	 * This generates the proper constant.  It is implemented
1:eac0369: 	 * by every specific constant node (e.g. IntConstantNode).
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:2706d1f:         switch (kind)
1:eac0369: 		{
1:2706d1f:         case K_INT:
1:eac0369: 			mb.push(value.getInt());
9:eac0369: 			break;
1:2706d1f:         case K_TINYINT:
1:eac0369: 			mb.push(value.getByte());
1:eac0369: 			break;
1:2706d1f:         case K_SMALLINT:
1:eac0369: 			mb.push(value.getShort());
1:eac0369: 			break;
1:2706d1f:         case K_DECIMAL:
1:38c638d:             mb.pushNewStart("java.math.BigDecimal");
1:b69c0b7: 			mb.push(value.getString());
1:38c638d:             mb.pushNewComplete(1);
1:eac0369: 			break;
1:2706d1f:         case K_DOUBLE:
1:509ccb9: 			mb.push(value.getDouble());
1:eac0369: 			break;
1:2706d1f:         case K_REAL:
1:eac0369: 			mb.push(value.getFloat());
1:eac0369: 			break;
1:2706d1f:         case K_BIGINT:
1:509ccb9: 			mb.push(value.getLong());
1:eac0369: 			break;
1:3bb140c: 		default:
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
2:eac0369: 				// we should never really come here-- when the class is created
2:eac0369: 				// it should have the correct nodeType set.
2:eac0369: 				SanityManager.THROWASSERT(
1:2706d1f:                           "Unexpected numeric type = " + kind);
18:eac0369: 			}
1:eac0369: 		}	
1:eac0369: 	}
1:2706d1f: 
1:2706d1f:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) && ((NumericConstantNode)o).kind == kind;
1:2706d1f:     }}
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLDecimal;
/////////////////////////////////////////////////////////////////////////
1:     NumericConstantNode(TypeId t, Number value, ContextManager cm)
/////////////////////////////////////////////////////////////////////////
1:     private int getPrecision(TypeId t, Number val) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:                 SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
/////////////////////////////////////////////////////////////////////////
1:                 SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
/////////////////////////////////////////////////////////////////////////
1:                SQLDecimal constantDecimal = new SQLDecimal((BigDecimal) val);
/////////////////////////////////////////////////////////////////////////
1:     private void setValue(TypeId t, Number value ) throws StandardException {
/////////////////////////////////////////////////////////////////////////
1:            setValue(new SQLDecimal((BigDecimal)value));
commit:38c638d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             mb.pushNewStart("java.math.BigDecimal");
1:             mb.pushNewComplete(1);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:4309044
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLDouble;
1: import org.apache.derby.iapi.types.SQLLongint;
1: import org.apache.derby.iapi.types.SQLReal;
1: import org.apache.derby.iapi.types.SQLSmallint;
1: import org.apache.derby.iapi.types.SQLTinyint;
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLTinyint((Byte) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLSmallint((Short) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLLongint((Long) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLDouble((Double) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLReal((Float) arg1));
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     // Allowed kinds
1:     final static int K_TINYINT = 0;
1:     final static int K_SMALLINT = 1;
1:     final static int K_INT = 2;
1:     final static int K_BIGINT = 3;
1:     final static int K_DECIMAL = 4;
1:     final static int K_DOUBLE = 5;
1:     final static int K_REAL = 6;
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
/////////////////////////////////////////////////////////////////////////
1:         kind = getKind(t);
/////////////////////////////////////////////////////////////////////////
1:         kind = getKind(t);
/////////////////////////////////////////////////////////////////////////
1: 
1:         switch (t.getJDBCTypeId()) {
1: 
1:         case Types.TINYINT:
1:             return TypeId.SMALLINT_PRECISION; // FIXME
1:         case Types.INTEGER:
1:             return TypeId.INT_PRECISION;
1:         case Types.SMALLINT:
1:             return TypeId.SMALLINT_PRECISION;
1:         case Types.BIGINT:
1:             return TypeId.LONGINT_PRECISION;
1:         case Types.DECIMAL:
0:                 NumberDataValue constantDecimal =
1:                 return constantDecimal.getDecimalValuePrecision();
1:         case Types.DOUBLE:
1:             return TypeId.DOUBLE_PRECISION;
1:         case Types.REAL:
1:             return TypeId.REAL_PRECISION;
1:         default:
1:             if (SanityManager.DEBUG) {
1:             }
1:             return 0;
1:         switch (t.getJDBCTypeId()) {
1:         case Types.TINYINT:
1:             return TypeId.SMALLINT_SCALE; // FIXME
1:         case Types.INTEGER:
1:             return TypeId.INT_SCALE;
1:         case Types.SMALLINT:
1:             return TypeId.SMALLINT_SCALE;
1:         case Types.BIGINT:
1:             return TypeId.LONGINT_SCALE;
1:         case Types.DECIMAL:
0:                 NumberDataValue constantDecimal =
0:                     getDataValueFactory().getDecimalDataValue((String)val);
1:                 return constantDecimal.getDecimalValueScale();
1:         case Types.DOUBLE:
1:         case Types.REAL:
1:             return TypeId.REAL_SCALE;
1:         default:
1:             if (SanityManager.DEBUG) {
1:             }
1:             return 0;
/////////////////////////////////////////////////////////////////////////
1:     private int getKind(TypeId t) {
1:            return K_TINYINT;
1:            return K_INT;
1:            return K_SMALLINT;
1:            return K_BIGINT;
1:             return K_DECIMAL;
1:            return K_DOUBLE;
1:            return K_REAL;
1:            return -1;
/////////////////////////////////////////////////////////////////////////
1:         switch (kind)
1:         case K_INT:
1:         case K_TINYINT:
1:         case K_SMALLINT:
1:         case K_DECIMAL:
1:         case K_DOUBLE:
1:         case K_REAL:
1:         case K_BIGINT:
/////////////////////////////////////////////////////////////////////////
1:                           "Unexpected numeric type = " + kind);
1: 
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) && ((NumericConstantNode)o).kind == kind;
1:     }}
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.types.DataTypeUtilities;
1: import org.apache.derby.iapi.types.NumberDataValue;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constructor for a typed null node
1:      * @param t type
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     NumericConstantNode(TypeId t, ContextManager cm)
1:             throws StandardException {
1:         super(cm);
1:         setType(t,
1:                 getPrecision(t, null),
1:                 getScale(t, null),
1:                 true,
1:                 getMaxWidth(t, null));
0:         setNodeType(getNodeType(t));
1:     }
1:     /**
1:      * @param value An object containing the value of the constant.
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
0:     NumericConstantNode(TypeId t, Object value, ContextManager cm)
1:             throws StandardException {
1:         super(cm);
0:         setNodeType(getNodeType(t));
1:         setType(t,
1:                 getPrecision(t, value),
1:                 getScale(t, value),
1:                 false,
1:                 getMaxWidth(t, value));
1:         setValue(t, value);
1:     }
1: 
0:     private int getPrecision(TypeId t, Object val) throws StandardException {
0:         int foo = t.getJDBCTypeId();
0:        //switch (t.getJDBCTypeId()) {
0:         switch (foo) {
1:        case Types.TINYINT:
0:            return TypeId.SMALLINT_PRECISION; // FIXME
1:        case Types.INTEGER:
0:            return TypeId.INT_PRECISION;
1:        case Types.SMALLINT:
0:            return TypeId.SMALLINT_PRECISION;
1:        case Types.BIGINT:
0:            return TypeId.LONGINT_PRECISION;
1:        case Types.DECIMAL:
1:             if (val != null) {
0:                NumberDataValue constantDecimal =
0:                     getDataValueFactory().getDecimalDataValue((String)val);
0:                return constantDecimal.getDecimalValuePrecision();
1:             } else {
1:                 return TypeId.DECIMAL_PRECISION;
1:             }
1:        case Types.DOUBLE:
0:            return TypeId.DOUBLE_PRECISION;
1:        case Types.REAL:
0:            return TypeId.REAL_PRECISION;
1:        default:
1:            if (SanityManager.DEBUG) {
1:                 SanityManager.NOTREACHED();
1:            }
1:            return 0;
1:     }
1:     private int getScale(TypeId t, Object val) throws StandardException {
1:        switch (t.getJDBCTypeId()) {
1:        case Types.TINYINT:
0:            return TypeId.SMALLINT_SCALE; // FIXME
1:        case Types.INTEGER:
0:            return TypeId.INT_SCALE;
1:        case Types.SMALLINT:
0:            return TypeId.SMALLINT_SCALE;
1:        case Types.BIGINT:
0:            return TypeId.LONGINT_SCALE;
1:        case Types.DECIMAL:
1:             if (val != null) {
0:                NumberDataValue constantDecimal =
0:                         getDataValueFactory().getDecimalDataValue((String)val);
0:                return constantDecimal.getDecimalValueScale();
1:             } else {
1:                 return TypeId.DECIMAL_SCALE;
1:             }
1:        case Types.DOUBLE:
1:             return TypeId.DOUBLE_SCALE;
1:        case Types.REAL:
0:            return TypeId.REAL_SCALE;
1:        default:
1:            if (SanityManager.DEBUG) {
1:                 SanityManager.NOTREACHED();
1:            }
1:            return 0;
1:         }
1:     }
1:     private int getMaxWidth(TypeId t, Object val) throws StandardException {
1:        switch (t.getJDBCTypeId()) {
1:        case Types.TINYINT:
1:            return val != null ? TypeId.SMALLINT_MAXWIDTH : 0; // FIXME
1:        case Types.INTEGER:
1:            return val != null ? TypeId.INT_MAXWIDTH : 0;
1:        case Types.SMALLINT:
1:            return val != null ? TypeId.SMALLINT_MAXWIDTH : 0;
1:        case Types.BIGINT:
1:            return val != null ? TypeId.LONGINT_MAXWIDTH: 0;
1:        case Types.DECIMAL:
1:             if (val != null) {
0:                NumberDataValue constantDecimal =
0:                         getDataValueFactory().getDecimalDataValue((String) val);
1:                int precision = constantDecimal.getDecimalValuePrecision();
1:                int scal = constantDecimal.getDecimalValueScale();
1:                /* be consistent with our convention on maxwidth, see also
1:                 * exactNumericType(), otherwise we get format problem, b 3923
1:                 */
1:                return DataTypeUtilities.computeMaxWidth(precision, scal);
1:             } else {
1:                 return TypeId.DECIMAL_MAXWIDTH;
1:             }
1:        case Types.DOUBLE:
1:            return val != null ? TypeId.DOUBLE_MAXWIDTH : 0;
1:        case Types.REAL:
1:            return val != null ? TypeId.REAL_MAXWIDTH : 0;
1:        default:
1:            if (SanityManager.DEBUG) {
1:                 SanityManager.NOTREACHED();
1:            }
1:            return 0;
1:        }
1:     }
0:     private int getNodeType(TypeId t) {
1:        switch (t.getJDBCTypeId()) {
1:        case Types.TINYINT:
0:            return C_NodeTypes.TINYINT_CONSTANT_NODE;
1:        case Types.INTEGER:
0:            return C_NodeTypes.INT_CONSTANT_NODE;
1:        case Types.SMALLINT:
0:            return C_NodeTypes.SMALLINT_CONSTANT_NODE;
1:        case Types.BIGINT:
0:            return C_NodeTypes.BIGINT_CONSTANT_NODE;
1:        case Types.DECIMAL:
0:             return C_NodeTypes.DECIMAL_CONSTANT_NODE;
1:        case Types.DOUBLE:
0:            return C_NodeTypes.DOUBLE_CONSTANT_NODE;
1:        case Types.REAL:
0:            return C_NodeTypes.REAL_CONSTANT_NODE;
1:        default:
1:            if (SanityManager.DEBUG) {
1:                 SanityManager.NOTREACHED();
1:            }
1:            return 0;
1:        }
1:     }
0:     private void setValue(TypeId t, Object value ) throws StandardException {
1:        switch (t.getJDBCTypeId()) {
1:        case Types.TINYINT:
1:            setValue(new SQLTinyint((Byte)value));
1:             break;
1:        case Types.INTEGER:
1:            setValue(new SQLInteger((Integer)value));
1:             break;
1:        case Types.SMALLINT:
1:            setValue(new SQLSmallint((Short)value));
1:             break;
1:        case Types.BIGINT:
1:            setValue(new SQLLongint((Long)value));
1:             break;
1:        case Types.DECIMAL:
0:             NumberDataValue constantDecimal =
0:                     getDataValueFactory().getDecimalDataValue((String)value);
0:             setValue(constantDecimal);
1:             break;
1:        case Types.DOUBLE:
1:            setValue(new SQLDouble((Double)value));
1:             break;
1:        case Types.REAL:
1:            setValue(new SQLReal((Float)value));
1:             break;
1:        default:
1:            if (SanityManager.DEBUG) {
1:                 SanityManager.NOTREACHED();
1:            }
1:        }
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:         case C_NodeTypes.REAL_CONSTANT_NODE:
0:         case C_NodeTypes.BIGINT_CONSTANT_NODE:
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
0: 		setType(
0: 				   precision, 
0: 				   scal, 
0: 				   isNullable.booleanValue(), 
0: 				   maxwidth);
commit:c8c1551
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLInteger;
/////////////////////////////////////////////////////////////////////////
0: 				setValue(new SQLInteger((Integer) arg1));
commit:19138a9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0: 			// No java.math.BigDecimal class in J2ME so the constant
0: 			// from the input SQL is handled directly as a String.
0: 			if (!JVMInfo.J2ME)
0: 				mb.pushNewStart("java.math.BigDecimal");
0: 			if (!JVMInfo.J2ME)
0: 				mb.pushNewComplete(1);
commit:b69c0b7
/////////////////////////////////////////////////////////////////////////
1: 			mb.push(value.getString());
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.NumberDataValue;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				setValue(getDataValueFactory().getDataValue((Byte) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(getDataValueFactory().getDataValue((Integer) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(getDataValueFactory().getDataValue((Short) arg1));
/////////////////////////////////////////////////////////////////////////
0: 				setValue(getDataValueFactory().getDataValue((Long) arg1));
1: 
0: 				NumberDataValue constantDecimal = getDataValueFactory().getDecimalDataValue((String) arg1);
0: 				precision = constantDecimal.getDecimalValuePrecision();
0: 				scal = constantDecimal.getDecimalValueScale();
0: 				maxwidth = DataTypeUtilities.computeMaxWidth(precision, scal);
0: 				setValue(constantDecimal);
/////////////////////////////////////////////////////////////////////////
0: 				setValue(getDataValueFactory().getDataValue((Double) arg1));
/////////////////////////////////////////////////////////////////////////
0: 					getDataValueFactory().getDataValue((Float) arg1));
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			mb.push(value.getDouble());
1: 			mb.push(value.getLong());
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.NumericConstantNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeUtilities;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
0: import java.sql.Types;
0: import java.math.BigDecimal;
1: 
1: public final class NumericConstantNode extends ConstantNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/**
0: 	 * Initializer for a typed null node
1: 	 *
0: 	 * @param arg1	The TypeId for the type of node
1: 	 *
0: 	 * - OR -
1: 	 *
0: 	 * @param arg1	An object containing the value of the constant.
1: 	 *
0: 	 * @exception StandardException
1: 	 */
0: 	public void init(Object arg1)
1: 		throws StandardException
1: 	{
0: 		int precision = 0, scal = 0, maxwidth = 0;
0: 		Boolean isNullable;
0: 		boolean valueInP; // value in Predicate-- if TRUE a value was passed in
0: 		TypeId  typeId = null;
0: 		int typeid = 0;
0: 		Object val = null;	
1: 
0: 		if (arg1 instanceof TypeId)
1: 		{
0: 			typeId = (TypeId)arg1;
0: 			isNullable = Boolean.TRUE;
0: 			valueInP = false;
0: 			maxwidth = 0;
1: 		}
1: 
0: 		else	
1: 		{
0: 			isNullable = Boolean.FALSE;
0: 			val = arg1;
0: 			valueInP = true;
1: 		}
1: 
1: 		
0: 		switch (getNodeType())
1: 		{
0: 		case C_NodeTypes.TINYINT_CONSTANT_NODE:
0: 			precision = TypeId.SMALLINT_PRECISION;
0: 			scal = TypeId.SMALLINT_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.SMALLINT_MAXWIDTH;
0: 				typeid = Types.TINYINT;
0: 				setValue(getDataValueFactory().getDataValue(
0: 														((Byte)val).byteValue()));
1: 			} 
1: 			break;
1: 
0: 		case C_NodeTypes.INT_CONSTANT_NODE:
0: 			precision = TypeId.INT_PRECISION;
0: 			scal = TypeId.INT_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.INT_MAXWIDTH;
0: 				typeid = Types.INTEGER;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 												((Integer) val).intValue()));
1: 			}
1: 			break;
1: 
0: 		case C_NodeTypes.SMALLINT_CONSTANT_NODE:
0: 			precision = TypeId.SMALLINT_PRECISION;
0: 			scal = TypeId.SMALLINT_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.SMALLINT_MAXWIDTH;
0: 				typeid = Types.SMALLINT;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 												((Short) val).shortValue()));
1: 			}
1: 			break;
1: 
0: 		case C_NodeTypes.LONGINT_CONSTANT_NODE:
0: 			precision = TypeId.LONGINT_PRECISION;
0: 			scal = TypeId.LONGINT_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.LONGINT_MAXWIDTH;
0: 				typeid = Types.BIGINT;
0: 				setValue(getDataValueFactory().getDataValue(((Long) arg1).longValue()));
1: 			}
1: 			break;
1: 			
0: 		case C_NodeTypes.DECIMAL_CONSTANT_NODE:
0: 			if (valueInP)
1: 			{
0: 				BigDecimal dVal = (BigDecimal)val;
1: 
0: 				typeid = Types.DECIMAL;
0: 				precision = org.apache.derby.iapi.types.SQLDecimal.getPrecision(dVal);
0: 				scal = (dVal == null) ? 0 : dVal.scale();
0: 				/* be consistent with our convention on maxwidth, see also
0: 				 * exactNumericType(), otherwise we get format problem, b 3923
1: 				 */
0: 				maxwidth = DataTypeUtilities.computeMaxWidth( precision, scal);
0: 				setValue(getDataValueFactory().getDataValue(dVal));
1: 			}
0: 			else
1: 			{
0: 				precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;
0: 				scal = TypeCompiler.DEFAULT_DECIMAL_SCALE;
0: 				maxwidth = TypeId.DECIMAL_MAXWIDTH;
1: 			}
1: 			break;
1: 												   
0: 		case C_NodeTypes.DOUBLE_CONSTANT_NODE:
0: 			precision = TypeId.DOUBLE_PRECISION;
0: 			scal = TypeId.DOUBLE_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.DOUBLE_MAXWIDTH;
0: 				typeid = Types.DOUBLE;
0: 				setValue(getDataValueFactory().getDataValue(
0: 											((Double) arg1).doubleValue()));
1: 			}
1: 			break;
1: 
0: 		case C_NodeTypes.FLOAT_CONSTANT_NODE:
0: 			precision = TypeId.REAL_PRECISION;
0: 			scal = TypeId.REAL_SCALE;
0: 			if (valueInP)
1: 			{
0: 				maxwidth = TypeId.REAL_MAXWIDTH;
0: 				typeid = Types.REAL;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 											((Float) arg1).floatValue()));
1: 			}
1: 			break;
1: 			
0: 		default:
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				// we should never really come here-- when the class is created
1: 				// it should have the correct nodeType set.
1: 				SanityManager.THROWASSERT(
0: 								"Unexpected nodeType = " + getNodeType());
1: 			}
1: 			break;
1: 		}
1: 		
0: 		super.init(
0: 				   (typeId != null) ?  typeId :
0: 				     TypeId.getBuiltInTypeId(typeid),
1: 
0: 				   ReuseFactory.getInteger(precision), 
0: 				   ReuseFactory.getInteger(scal), 
0: 				   isNullable, 
0: 				   ReuseFactory.getInteger(maxwidth));
1: 	}
1: 	
0: 	long	getLong() throws StandardException
1: 	{
0: 		return value.getLong();
1: 	}
1: 
1: 	/**
0: 	 * Return the value from this DoubleConstantNode
1: 	 *
0: 	 * @return	The value of this DoubleConstantNode.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	double	getDouble() throws StandardException
1: 	{
0: 		return value.getDouble();
1: 	}
1: 
1: 	/**
1: 	 * Return an Object representing the bind time value of this
1: 	 * expression tree.  If the expression tree does not evaluate to
1: 	 * a constant at bind time then we return null.
1: 	 * This is useful for bind time resolution of VTIs.
1: 	 * RESOLVE: What do we do for primitives?
1: 	 *
1: 	 * @return	An Object representing the bind time value of this expression tree.
1: 	 *			(null if not a bind time constant.)
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	Object getConstantValueAsObject()
1: 		throws StandardException
1: 	{
1: 		return value.getObject();
1: 	}
1: 
1: 		/**
1: 	 * This generates the proper constant.  It is implemented
1: 	 * by every specific constant node (e.g. IntConstantNode).
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb	The method the expression will go into
1: 	 *
0: 	 * @return		The compiled Expression, 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb)
1: 		throws StandardException
1: 	{
0: 		switch (getNodeType())
1: 		{
0: 		case C_NodeTypes.INT_CONSTANT_NODE:
1: 			mb.push(value.getInt());
1: 			break;
0: 		case C_NodeTypes.TINYINT_CONSTANT_NODE:
1: 			mb.push(value.getByte());
1: 			break;
0: 		case C_NodeTypes.SMALLINT_CONSTANT_NODE:
1: 			mb.push(value.getShort());
1: 			break;
0: 		case C_NodeTypes.DECIMAL_CONSTANT_NODE:
0: 			mb.pushNewStart("java.math.BigDecimal");
0: 			mb.push(value.toString());
0: 			mb.pushNewComplete(1);
1: 			break;
0: 		case C_NodeTypes.DOUBLE_CONSTANT_NODE:
0: 			mb.push(getDouble());
1: 			break;
0: 		case C_NodeTypes.FLOAT_CONSTANT_NODE:
1: 			mb.push(value.getFloat());
1: 			break;
0: 		case C_NodeTypes.LONGINT_CONSTANT_NODE:
0: 			mb.push(getLong());
1: 			break;
0: 		default:
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				// we should never really come here-- when the class is created
1: 				// it should have the correct nodeType set.
1: 				SanityManager.THROWASSERT(
0: 						  "Unexpected nodeType = " + getNodeType());
1: 			}
1: 		}	
1: 	}
1: }		
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * @param arg1	The TypeId for the type of node OR An object containing the value of the constant.
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataTypeUtilities;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: import java.sql.Types;
0: import java.math.BigDecimal;
0: 
0: public final class NumericConstantNode extends ConstantNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/**
0: 	 * Initializer for a typed null node
0: 	 *
0: 	 * @param arg1	The TypeId for the type of node
0: 	 *
0: 	 * - OR -
0: 	 *
0: 	 * @param arg1	An object containing the value of the constant.
0: 	 *
0: 	 * @exception StandardException
0: 	 */
0: 	public void init(Object arg1)
0: 		throws StandardException
0: 	{
0: 		int precision = 0, scal = 0, maxwidth = 0;
0: 		Boolean isNullable;
0: 		boolean valueInP; // value in Predicate-- if TRUE a value was passed in
0: 		TypeId  typeId = null;
0: 		int typeid = 0;
0: 		Object val = null;	
0: 
0: 		if (arg1 instanceof TypeId)
0: 		{
0: 			typeId = (TypeId)arg1;
0: 			isNullable = Boolean.TRUE;
0: 			valueInP = false;
0: 			maxwidth = 0;
0: 		}
0: 
0: 		else	
0: 		{
0: 			isNullable = Boolean.FALSE;
0: 			val = arg1;
0: 			valueInP = true;
0: 		}
0: 
0: 		
0: 		switch (getNodeType())
0: 		{
0: 		case C_NodeTypes.TINYINT_CONSTANT_NODE:
0: 			precision = TypeId.SMALLINT_PRECISION;
0: 			scal = TypeId.SMALLINT_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.SMALLINT_MAXWIDTH;
0: 				typeid = Types.TINYINT;
0: 				setValue(getDataValueFactory().getDataValue(
0: 														((Byte)val).byteValue()));
0: 			} 
0: 			break;
0: 
0: 		case C_NodeTypes.INT_CONSTANT_NODE:
0: 			precision = TypeId.INT_PRECISION;
0: 			scal = TypeId.INT_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.INT_MAXWIDTH;
0: 				typeid = Types.INTEGER;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 												((Integer) val).intValue()));
0: 			}
0: 			break;
0: 
0: 		case C_NodeTypes.SMALLINT_CONSTANT_NODE:
0: 			precision = TypeId.SMALLINT_PRECISION;
0: 			scal = TypeId.SMALLINT_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.SMALLINT_MAXWIDTH;
0: 				typeid = Types.SMALLINT;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 												((Short) val).shortValue()));
0: 			}
0: 			break;
0: 
0: 		case C_NodeTypes.LONGINT_CONSTANT_NODE:
0: 			precision = TypeId.LONGINT_PRECISION;
0: 			scal = TypeId.LONGINT_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.LONGINT_MAXWIDTH;
0: 				typeid = Types.BIGINT;
0: 				setValue(getDataValueFactory().getDataValue(((Long) arg1).longValue()));
0: 			}
0: 			break;
0: 			
0: 		case C_NodeTypes.DECIMAL_CONSTANT_NODE:
0: 			if (valueInP)
0: 			{
0: 				BigDecimal dVal = (BigDecimal)val;
0: 
0: 				typeid = Types.DECIMAL;
0: 				precision = org.apache.derby.iapi.types.SQLDecimal.getPrecision(dVal);
0: 				scal = (dVal == null) ? 0 : dVal.scale();
0: 				/* be consistent with our convention on maxwidth, see also
0: 				 * exactNumericType(), otherwise we get format problem, b 3923
0: 				 */
0: 				maxwidth = DataTypeUtilities.computeMaxWidth( precision, scal);
0: 				setValue(getDataValueFactory().getDataValue(dVal));
0: 			}
0: 			else
0: 			{
0: 				precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;
0: 				scal = TypeCompiler.DEFAULT_DECIMAL_SCALE;
0: 				maxwidth = TypeId.DECIMAL_MAXWIDTH;
0: 			}
0: 			break;
0: 												   
0: 		case C_NodeTypes.DOUBLE_CONSTANT_NODE:
0: 			precision = TypeId.DOUBLE_PRECISION;
0: 			scal = TypeId.DOUBLE_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.DOUBLE_MAXWIDTH;
0: 				typeid = Types.DOUBLE;
0: 				setValue(getDataValueFactory().getDataValue(
0: 											((Double) arg1).doubleValue()));
0: 			}
0: 			break;
0: 
0: 		case C_NodeTypes.FLOAT_CONSTANT_NODE:
0: 			precision = TypeId.REAL_PRECISION;
0: 			scal = TypeId.REAL_SCALE;
0: 			if (valueInP)
0: 			{
0: 				maxwidth = TypeId.REAL_MAXWIDTH;
0: 				typeid = Types.REAL;
0: 				setValue(
0: 					getDataValueFactory().getDataValue(
0: 											((Float) arg1).floatValue()));
0: 			}
0: 			break;
0: 			
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				// we should never really come here-- when the class is created
0: 				// it should have the correct nodeType set.
0: 				SanityManager.THROWASSERT(
0: 								"Unexpected nodeType = " + getNodeType());
0: 			}
0: 			break;
0: 		}
0: 		
0: 		super.init(
0: 				   (typeId != null) ?  typeId :
0: 				     TypeId.getBuiltInTypeId(typeid),
0: 
0: 				   ReuseFactory.getInteger(precision), 
0: 				   ReuseFactory.getInteger(scal), 
0: 				   isNullable, 
0: 				   ReuseFactory.getInteger(maxwidth));
0: 	}
0: 	
0: 	long	getLong() throws StandardException
0: 	{
0: 		return value.getLong();
0: 	}
0: 
0: 	/**
0: 	 * Return the value from this DoubleConstantNode
0: 	 *
0: 	 * @return	The value of this DoubleConstantNode.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	double	getDouble() throws StandardException
0: 	{
0: 		return value.getDouble();
0: 	}
0: 
0: 	/**
0: 	 * Return an Object representing the bind time value of this
0: 	 * expression tree.  If the expression tree does not evaluate to
0: 	 * a constant at bind time then we return null.
0: 	 * This is useful for bind time resolution of VTIs.
0: 	 * RESOLVE: What do we do for primitives?
0: 	 *
0: 	 * @return	An Object representing the bind time value of this expression tree.
0: 	 *			(null if not a bind time constant.)
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	Object getConstantValueAsObject()
0: 		throws StandardException
0: 	{
0: 		return value.getObject();
0: 	}
0: 
0: 		/**
0: 	 * This generates the proper constant.  It is implemented
0: 	 * by every specific constant node (e.g. IntConstantNode).
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @return		The compiled Expression, 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		switch (getNodeType())
0: 		{
0: 		case C_NodeTypes.INT_CONSTANT_NODE:
0: 			mb.push(value.getInt());
0: 			break;
0: 		case C_NodeTypes.TINYINT_CONSTANT_NODE:
0: 			mb.push(value.getByte());
0: 			break;
0: 		case C_NodeTypes.SMALLINT_CONSTANT_NODE:
0: 			mb.push(value.getShort());
0: 			break;
0: 		case C_NodeTypes.DECIMAL_CONSTANT_NODE:
0: 			mb.pushNewStart("java.math.BigDecimal");
0: 			mb.push(value.toString());
0: 			mb.pushNewComplete(1);
0: 			break;
0: 		case C_NodeTypes.DOUBLE_CONSTANT_NODE:
0: 			mb.push(getDouble());
0: 			break;
0: 		case C_NodeTypes.FLOAT_CONSTANT_NODE:
0: 			mb.push(value.getFloat());
0: 			break;
0: 		case C_NodeTypes.LONGINT_CONSTANT_NODE:
0: 			mb.push(getLong());
0: 			break;
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				// we should never really come here-- when the class is created
0: 				// it should have the correct nodeType set.
0: 				SanityManager.THROWASSERT(
0: 						  "Unexpected nodeType = " + getNodeType());
0: 			}
0: 		}	
0: 	}
0: }		
============================================================================