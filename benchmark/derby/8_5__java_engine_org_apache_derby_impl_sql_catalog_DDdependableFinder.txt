2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.catalog.DDdependableFinder
1:345de35: 
1:f739ad1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f739ad1:    contributor license agreements.  See the NOTICE file distributed with
1:f739ad1:    this work for additional information regarding copyright ownership.
1:f739ad1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f739ad1:    (the "License"); you may not use this file except in compliance with
1:f739ad1:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
38:eac0369: 
9:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.catalog;
1:eac0369: 
1:2bb479f: import java.io.IOException;
1:2bb479f: import java.io.ObjectInput;
1:2bb479f: import java.io.ObjectOutput;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.Dependable;
1:eac0369: import org.apache.derby.catalog.DependableFinder;
1:2bb479f: import org.apache.derby.catalog.UUID;
1:2bb479f: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:2bb479f: import org.apache.derby.iapi.services.io.Formatable;
1:2bb479f: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bb479f: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:2bb479f: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:2bb479f: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1:eac0369: 
8:eac0369: /**
1:2bb479f:  *	Class for most DependableFinders in the core DataDictionary.
1:2bb479f:  * This class is stored in SYSDEPENDS for the finders for
1:2bb479f:  * the provider and dependent. It stores no state, its functionality
1:2bb479f:  * is driven off its format identifier.
10:eac0369:  *
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public class DDdependableFinder implements	DependableFinder, Formatable
14:eac0369: {
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	STATE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	private final int formatId;
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTRUCTORS
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Public constructor for Formatable hoo-hah.
1:eac0369: 	  */
1:eac0369: 	public	DDdependableFinder(int formatId)
1:eac0369: 	{
1:eac0369: 		this.formatId = formatId;
16:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	OBJECT SUPPORT
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	public	String	toString()
1:eac0369: 	{
1:eac0369: 		return	getSQLObjectType();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	VACUOUS FORMATABLE INTERFACE. ALL THAT A VACUOUSDEPENDABLEFINDER
1:eac0369: 	//	NEEDS TO DO IS STAMP ITS FORMAT ID ONTO THE OUTPUT STREAM.
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects. Nothing to
1:eac0369: 	 * do. Our persistent representation is just a 2-byte format id.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 */
1:eac0369:     public void readExternal( ObjectInput in )
1:eac0369: 			throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects. Again, nothing
1:eac0369: 	 * to do. We just stamp the output stream with our Format id.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 */
1:eac0369:     public void writeExternal( ObjectOutput out )
1:eac0369: 			throws IOException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:eac0369: 	public	final int	getTypeFormatId()	
1:eac0369: 	{
1:eac0369: 		return formatId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	DDdependable METHODS
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  * @see DependableFinder#getSQLObjectType
1:eac0369: 	  */
1:eac0369: 	public	String	getSQLObjectType()
1:eac0369: 	{
2:eac0369: 		switch (formatId)
1:eac0369: 		{
2:eac0369: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.ALIAS;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.CONGLOMERATE;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.CONSTRAINT;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.DEFAULT;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
1:eac0369: 				return Dependable.FILE;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.SCHEMA;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.STORED_PREPARED_STATEMENT;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.TABLE;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.COLUMNS_IN_TABLE;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.TRIGGER;
1:eac0369: 
2:eac0369: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				return Dependable.VIEW;
1:eac0369: 
1:2d2e717: 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:
1:2d2e717: 				return Dependable.TABLE_PERMISSION;
1:2d2e717: 			
1:ac100d6: 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
1:2d2e717: 				return Dependable.COLUMNS_PERMISSION;
1:ac100d6: 
1:2d2e717: 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:
1:2d2e717: 				return Dependable.ROUTINE_PERMISSION;
1:2d2e717: 
1:7e729b6: 			case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:
1:7e729b6: 				return Dependable.ROLE_GRANT;
1:7e729b6: 
1:98c7520: 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:
1:98c7520: 				return Dependable.SEQUENCE;
1:98c7520: 
1:98c7520: 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:
1:98c7520: 				return Dependable.PERM;
1:98c7520: 
3:eac0369: 			default:
2:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
2:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"getSQLObjectType() called with unexpeced formatId = " + formatId);
1:eac0369: 				}
3:eac0369: 				return null;
1:eac0369: 		}
1:eac0369: 	}
1:2d2e717: 
1:eac0369: 	/**
1:eac0369: 		Get the dependable for the given UUID
2:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	*/
1:2bb479f: 	public final Dependable getDependable(DataDictionary dd, UUID dependableObjectID)
3:eac0369: 		throws StandardException
1:eac0369: 	{
1:2bb479f:         Dependable dependable = findDependable(dd, dependableObjectID);
1:2bb479f:         if (dependable == null)
1:2bb479f:             throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND,
1:2bb479f:                     getSQLObjectType(), dependableObjectID);
1:2bb479f:         return dependable;
1:2bb479f:     }
1:2bb479f:         
1:2bb479f:        
1:2bb479f:     /**
1:2bb479f:      * Find the dependable for getDependable.
1:2bb479f:      * Can return a null references, in which case getDependable()
1:2bb479f:      * will thrown an exception.
1:2bb479f:      */
1:2bb479f:     Dependable findDependable(DataDictionary dd, UUID dependableObjectID)
1:2bb479f:         throws StandardException
1:2bb479f:     {     
1:eac0369: 		switch (formatId)
1:eac0369: 		{
1:eac0369: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getAliasDescriptor(dependableObjectID);
1:2d2e717: 
1:eac0369: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getConglomerateDescriptor(dependableObjectID);
1:2d2e717: 
1:eac0369: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getConstraintDescriptor(dependableObjectID);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
1:eac0369: 				ColumnDescriptor	cd = dd.getColumnDescriptorByDefaultId(dependableObjectID);
1:2bb479f:                 if (cd != null)
1:2bb479f:                     return new DefaultDescriptor(
1:eac0369: 												dd, 
1:eac0369: 												cd.getDefaultUUID(), cd.getReferencingUUID(), 
1:eac0369: 												cd.getPosition());
1:2bb479f:                 return null;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
1:2bb479f:                 return dd.getFileInfoDescriptor(dependableObjectID);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getSchemaDescriptor(dependableObjectID, null);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getSPSDescriptor(dependableObjectID);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getTableDescriptor(dependableObjectID);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getTriggerDescriptor(dependableObjectID);
1:2bb479f:  
1:eac0369: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
1:2bb479f:                 return dd.getViewDescriptor(dependableObjectID);
1:2d2e717: 
1:2bb479f:             case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
1:2bb479f:                 return dd.getColumnPermissions(dependableObjectID);
1:ac100d6: 
1:2d2e717: 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:
1:2bb479f:                 return dd.getTablePermissions(dependableObjectID);
1:2d2e717: 
1:2d2e717: 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:
1:2bb479f:                 return dd.getRoutinePermissions(dependableObjectID);
1:7e729b6: 
1:7e729b6: 		    case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:
1:4e3ddd7: 				return dd.getRoleGrantDescriptor(dependableObjectID);
1:eac0369: 
1:98c7520: 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:
1:98c7520:                 return dd.getSequenceDescriptor(dependableObjectID);
1:98c7520: 
1:98c7520: 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:
1:98c7520:                 return dd.getGenericPermissions(dependableObjectID);
1:98c7520: 
1:4e3ddd7: 		default:
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 				{
1:eac0369: 					SanityManager.THROWASSERT(
1:eac0369: 						"getDependable() called with unexpeced formatId = " + formatId);
1:2bb479f: 				}
1:2bb479f:                 return null;
1:eac0369: 		}
1:eac0369:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.SEQUENCE;
1: 
1: 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.PERM;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.SEQUENCE_DESCRIPTOR_FINDER_V01_ID:
1:                 return dd.getSequenceDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID:
1:                 return dd.getGenericPermissions(dependableObjectID);
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:4e3ddd7
/////////////////////////////////////////////////////////////////////////
1: 				return dd.getRoleGrantDescriptor(dependableObjectID);
1: 		default:
commit:7e729b6
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:
1: 				return Dependable.ROLE_GRANT;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		    case StoredFormatIds.ROLE_GRANT_FINDER_V01_ID:
0: 				return dd.getRoleDescriptor(dependableObjectID);
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2bb479f
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
1:  *	Class for most DependableFinders in the core DataDictionary.
1:  * This class is stored in SYSDEPENDS for the finders for
1:  * the provider and dependent. It stores no state, its functionality
1:  * is driven off its format identifier.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public final Dependable getDependable(DataDictionary dd, UUID dependableObjectID)
1:         Dependable dependable = findDependable(dd, dependableObjectID);
1:         if (dependable == null)
1:             throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND,
1:                     getSQLObjectType(), dependableObjectID);
1:         return dependable;
1:     }
1:         
1:        
1:     /**
1:      * Find the dependable for getDependable.
1:      * Can return a null references, in which case getDependable()
1:      * will thrown an exception.
1:      */
1:     Dependable findDependable(DataDictionary dd, UUID dependableObjectID)
1:         throws StandardException
1:     {     
1:                 return dd.getAliasDescriptor(dependableObjectID);
1:                 return dd.getConglomerateDescriptor(dependableObjectID);
1:                 return dd.getConstraintDescriptor(dependableObjectID);
1:                 if (cd != null)
1:                     return new DefaultDescriptor(
1:                 return null;
1:                 return dd.getFileInfoDescriptor(dependableObjectID);
1:                 return dd.getSchemaDescriptor(dependableObjectID, null);
1:                 return dd.getSPSDescriptor(dependableObjectID);
1:                 return dd.getTableDescriptor(dependableObjectID);
1:                 return dd.getTriggerDescriptor(dependableObjectID);
1:  
1:                 return dd.getViewDescriptor(dependableObjectID);
1:             case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
1:                 return dd.getColumnPermissions(dependableObjectID);
1:                 return dd.getTablePermissions(dependableObjectID);
1:                 return dd.getRoutinePermissions(dependableObjectID);
/////////////////////////////////////////////////////////////////////////
1:                 return null;
1:     }
commit:cacb73f
/////////////////////////////////////////////////////////////////////////
commit:ac100d6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
0: 				return dd.getColumnPermissions(dependableObjectID);
1: 
0: 				return dd.getTablePermissions(dependableObjectID);
0: 				return dd.getRoutinePermissions(dependableObjectID);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
0: 				return dd.getColumnPermissions(dependableObjectID).getObjectName();
1: 
0: 				return dd.getTablePermissions(dependableObjectID).getObjectName();
0: 				return dd.getRoutinePermissions(dependableObjectID).getObjectName();
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:
1: 				return Dependable.TABLE_PERMISSION;
1: 			
0: 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
1: 				return Dependable.COLUMNS_PERMISSION;
1: 
1: 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:
1: 				return Dependable.ROUTINE_PERMISSION;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		LanguageConnectionContext lcc;
/////////////////////////////////////////////////////////////////////////
1: 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:
0: 				lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 				return dd.getTablePermissions(dependableObjectID,
0: 						lcc.getAuthorizationId());
1: 
1: 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:
0: 				lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 				return dd.getRoutinePermissions(dependableObjectID,
0: 						lcc.getAuthorizationId());
1: 
/////////////////////////////////////////////////////////////////////////
0: 		LanguageConnectionContext lcc;
/////////////////////////////////////////////////////////////////////////
0: 			case StoredFormatIds.COLUMNS_PERMISSION_FINDER_V01_ID:
/////////////////////////////////////////////////////////////////////////
0: 			case StoredFormatIds.TABLE_PERMISSION_FINDER_V01_ID:
0: 				lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 				return dd.getTablePermissions(dependableObjectID,
0: 						lcc.getAuthorizationId()).getObjectName();
1: 
0: 			case StoredFormatIds.ROUTINE_PERMISSION_FINDER_V01_ID:
0: 				lcc = (LanguageConnectionContext)
0: 				ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 				return dd.getRoutinePermissions(dependableObjectID,
0: 						lcc.getAuthorizationId()).getObjectName();
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.catalog.DDdependableFinder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.catalog;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.error.PublicAPI;
1: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
0: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.catalog.Dependable;
1: import org.apache.derby.catalog.DependableFinder;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
1: 
1: /**
0:  *	Class for all DependableFinders in the core DataDictionary
1:  *
1:  *
0:  * @author Rick
1:  */
1: 
1: public class DDdependableFinder implements	DependableFinder, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	STATE
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
0: 	private transient DataDictionary			dataDictionary;
0: 	private transient UUIDFactory				uuidFactory;
1: 
1: 	private final int formatId;
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTRUCTORS
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Public constructor for Formatable hoo-hah.
1: 	  */
1: 	public	DDdependableFinder(int formatId)
1: 	{
1: 		this.formatId = formatId;
1: 	}
1: 
1: 	//////////////////////////////////////////////////////////////////
1: 	//
1: 	//	OBJECT SUPPORT
1: 	//
1: 	//////////////////////////////////////////////////////////////////
1: 
1: 	public	String	toString()
1: 	{
1: 		return	getSQLObjectType();
1: 	}
1: 
1: 	//////////////////////////////////////////////////////////////////
1: 	//
1: 	//	VACUOUS FORMATABLE INTERFACE. ALL THAT A VACUOUSDEPENDABLEFINDER
1: 	//	NEEDS TO DO IS STAMP ITS FORMAT ID ONTO THE OUTPUT STREAM.
1: 	//
1: 	//////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects. Nothing to
1: 	 * do. Our persistent representation is just a 2-byte format id.
1: 	 *
1: 	 * @param in read this.
1: 	 */
1:     public void readExternal( ObjectInput in )
1: 			throws IOException, ClassNotFoundException
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects. Again, nothing
1: 	 * to do. We just stamp the output stream with our Format id.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 */
1:     public void writeExternal( ObjectOutput out )
1: 			throws IOException
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
1: 	public	final int	getTypeFormatId()	
1: 	{
1: 		return formatId;
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	DDdependable METHODS
1: 	//
1: 	////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	/**
0: 	 * Gets the in-memory object associated with the passed-in object ID.
1: 	 *
0: 	 * @param	dependableObjectID the UUID of the Dependable as a String.
0: 	 * 			Used to locate that Dependable
1: 	 *
0: 	 * @return	the associated Dependable
1: 	 *
0: 	 * @exception java.sql.SQLException		thrown on error
1: 	 */
0: 	public	final Dependable	getDependable(String dependableObjectID) throws java.sql.SQLException
1: 	{
1: 		/*
0: 		** Call the specific implementation of getDependable
0: 		** to do the work
1: 		*/
0: 		return getDependable(recreateUUID(dependableObjectID));
1: 	}
1: 
1: 	/**
0: 	  *	Gets the AliasDescriptor associated with the passed-in object ID.
1: 	  *
0: 	  *	@param	the object ID of an Alias. Used to locate its AliasDescriptor
1: 	  *
0: 	  *	@return	the associated AliasDescriptor
0: 	  * @exception java.sql.SQLException		thrown on error
1: 	  */
0: 	public final Dependable	getDependable(UUID dependableObjectID)
0: 		 throws java.sql.SQLException
1: 	{
0: 		try 
1: 		{
0: 			return getDependable(getDataDictionary(),dependableObjectID);
1: 		} 
0: 		catch (StandardException se) 
1: 		{
0: 			throw PublicAPI.wrapStandardException(se);
1: 		}
1: 	}
1: 
1: 	/**
0: 	  * @see DependableFinder#getSQLObjectName
0: 	  * @exception java.sql.SQLException		thrown on error
1: 	  */
0: 	public final String	getSQLObjectName(String idString) throws java.sql.SQLException
1: 	{
1: 
0: 		try {
1: 
0: 			// This should really be getDependable(idString).getObjectName()
0: 			// and then the sub-classes would not have to provide a getSQLObjectName
0: 			// method. Currently getDependable(idString).getObjectName() would
0: 			// not always return the same result - fix in main.
1: 
0: 			return getSQLObjectName(getDataDictionary(), recreateUUID(idString));
1: 		} 
0: 		catch (StandardException se) 
1: 		{
0: 			throw PublicAPI.wrapStandardException( se );
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	  * @see DependableFinder#getSQLObjectType
1: 	  */
1: 	public	String	getSQLObjectType()
1: 	{
1: 		switch (formatId)
1: 		{
1: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.ALIAS;
1: 
1: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.CONGLOMERATE;
1: 
1: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.CONSTRAINT;
1: 
1: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.DEFAULT;
1: 
1: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
1: 				return Dependable.FILE;
1: 
1: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.SCHEMA;
1: 
1: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.STORED_PREPARED_STATEMENT;
1: 
1: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.TABLE;
1: 
1: 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.COLUMNS_IN_TABLE;
1: 
1: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.TRIGGER;
1: 
1: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
1: 				return Dependable.VIEW;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"getSQLObjectType() called with unexpeced formatId = " + formatId);
1: 				}
1: 				return null;
1: 		}
1: 	}
1: 
1: 	/**
0: 	  *	Gets the datadictionary for this connection.
1: 	  *
0: 	  *	@return	the data dictionary for this connection
1: 	  *
0: 	  * @exception StandardException		Thrown on failure
1: 	  */
0: 	private	DataDictionary	getDataDictionary()
1: 						throws StandardException
1: 	{
0: 		if ( dataDictionary == null )
1: 	    {
0: 			ContextManager				cm  = ContextService.getFactory().getCurrentContextManager();
0: 			DataDictionaryContext		ddc = (DataDictionaryContext)
0: 			                              (cm.getContext(DataDictionaryContext.CONTEXT_ID));
0: 			dataDictionary = ddc.getDataDictionary();
1: 		}
0: 		return	dataDictionary;
1: 	}
1: 
1: 	/**
0: 	 * Get the UUID for the given string
1: 	 *
0: 	 * @param the string
1: 	 *
0: 	 * @return the UUID
1: 	 */
0: 	private UUID recreateUUID(String idString)
1: 	{
0: 		if (uuidFactory == null)
1: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
1: 		}
0: 		return uuidFactory.recreateUUID(idString);
1: 	}
1: 
1: 	/**
1: 		Get the dependable for the given UUID
1: 		@exception StandardException thrown on error
1: 	*/
0: 	protected Dependable getDependable(DataDictionary dd, UUID dependableObjectID)
1: 		throws StandardException
1: 	{
1: 		switch (formatId)
1: 		{
1: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getAliasDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConglomerateDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConstraintDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
1: 				ColumnDescriptor	cd = dd.getColumnDescriptorByDefaultId(dependableObjectID);
0: 				DefaultDescriptor ddi = new DefaultDescriptor(
1: 												dd, 
1: 												cd.getDefaultUUID(), cd.getReferencingUUID(), 
1: 												cd.getPosition());
0: 				return ddi;
1: 
1: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
0: 				return dd.getFileInfoDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSchemaDescriptor(dependableObjectID, null);
1: 
1: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSPSDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTableDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTriggerDescriptor(dependableObjectID);
1: 
1: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getViewDescriptor(dependableObjectID);
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"getDependable() called with unexpeced formatId = " + formatId);
1: 				}
1: 				return null;
1: 		}
1: 	}
1: 
1: 	/**
0: 		Get the SQL object name for the given UUID
1: 		@exception StandardException thrown on error
1: 	*/
0: 	protected String getSQLObjectName(DataDictionary dd, UUID dependableObjectID)
1: 		throws StandardException
1: 	{
1: 		switch (formatId)
1: 		{
1: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getAliasDescriptor(dependableObjectID).getDescriptorName();
1: 
1: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConglomerateDescriptor(dependableObjectID).getConglomerateName();
1: 
1: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConstraintDescriptor(dependableObjectID).getConstraintName();
1: 
1: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
0: 				ColumnDescriptor columnDescriptor = dd.getColumnDescriptorByDefaultId( dependableObjectID );
0: 				TableDescriptor tableDescriptor = dd.getTableDescriptor(
0: 										columnDescriptor.getReferencingUUID());
1: 
0: 				return	MessageService.getTextMessage(
0: 							SQLState.LANG_COLUMN_DEFAULT,
0: 							tableDescriptor.getQualifiedName() + "." +
0: 							columnDescriptor.getColumnName());
1: 
1: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
0: 				return dd.getFileInfoDescriptor(dependableObjectID).getName();
1: 
1: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSchemaDescriptor(dependableObjectID, null).getSchemaName();
1: 
1: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSPSDescriptor(dependableObjectID).getName();
1: 
1: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
1: 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:
0: 				return getDependable(dd, dependableObjectID).getObjectName();
1: 
1: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTriggerDescriptor(dependableObjectID).getName();
1: 
1: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTableDescriptor(dependableObjectID).getName();
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT(
0: 						"getSQLObjectName() called with unexpeced formatId = " + formatId);
1: 				}
1: 				return null;
1: 		}
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f739ad1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	  *	@param	dependableObjectID	the object ID of an Alias. Used to locate its AliasDescriptor
/////////////////////////////////////////////////////////////////////////
0: 	 * @param idString the string
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.catalog;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DefaultDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.error.PublicAPI;
0: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.catalog.Dependable;
0: import org.apache.derby.catalog.DependableFinder;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: /**
0:  *	Class for all DependableFinders in the core DataDictionary
0:  *
0:  *
0:  * @author Rick
0:  */
0: 
0: public class DDdependableFinder implements	DependableFinder, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	STATE
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	private transient DataDictionary			dataDictionary;
0: 	private transient UUIDFactory				uuidFactory;
0: 
0: 	private final int formatId;
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTRUCTORS
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Public constructor for Formatable hoo-hah.
0: 	  */
0: 	public	DDdependableFinder(int formatId)
0: 	{
0: 		this.formatId = formatId;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////////////////
0: 	//
0: 	//	OBJECT SUPPORT
0: 	//
0: 	//////////////////////////////////////////////////////////////////
0: 
0: 	public	String	toString()
0: 	{
0: 		return	getSQLObjectType();
0: 	}
0: 
0: 	//////////////////////////////////////////////////////////////////
0: 	//
0: 	//	VACUOUS FORMATABLE INTERFACE. ALL THAT A VACUOUSDEPENDABLEFINDER
0: 	//	NEEDS TO DO IS STAMP ITS FORMAT ID ONTO THE OUTPUT STREAM.
0: 	//
0: 	//////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects. Nothing to
0: 	 * do. Our persistent representation is just a 2-byte format id.
0: 	 *
0: 	 * @param in read this.
0: 	 */
0:     public void readExternal( ObjectInput in )
0: 			throws IOException, ClassNotFoundException
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects. Again, nothing
0: 	 * to do. We just stamp the output stream with our Format id.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 */
0:     public void writeExternal( ObjectOutput out )
0: 			throws IOException
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	final int	getTypeFormatId()	
0: 	{
0: 		return formatId;
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	DDdependable METHODS
0: 	//
0: 	////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 	/**
0: 	 * Gets the in-memory object associated with the passed-in object ID.
0: 	 *
0: 	 * @param	dependableObjectID the UUID of the Dependable as a String.
0: 	 * 			Used to locate that Dependable
0: 	 *
0: 	 * @return	the associated Dependable
0: 	 *
0: 	 * @exception java.sql.SQLException		thrown on error
0: 	 */
0: 	public	final Dependable	getDependable(String dependableObjectID) throws java.sql.SQLException
0: 	{
0: 		/*
0: 		** Call the specific implementation of getDependable
0: 		** to do the work
0: 		*/
0: 		return getDependable(recreateUUID(dependableObjectID));
0: 	}
0: 
0: 	/**
0: 	  *	Gets the AliasDescriptor associated with the passed-in object ID.
0: 	  *
0: 	  *	@param	the object ID of an Alias. Used to locate its AliasDescriptor
0: 	  *
0: 	  *	@return	the associated AliasDescriptor
0: 	  * @exception java.sql.SQLException		thrown on error
0: 	  */
0: 	public final Dependable	getDependable(UUID dependableObjectID)
0: 		 throws java.sql.SQLException
0: 	{
0: 		try 
0: 		{
0: 			return getDependable(getDataDictionary(),dependableObjectID);
0: 		} 
0: 		catch (StandardException se) 
0: 		{
0: 			throw PublicAPI.wrapStandardException(se);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  * @see DependableFinder#getSQLObjectName
0: 	  * @exception java.sql.SQLException		thrown on error
0: 	  */
0: 	public final String	getSQLObjectName(String idString) throws java.sql.SQLException
0: 	{
0: 
0: 		try {
0: 
0: 			// This should really be getDependable(idString).getObjectName()
0: 			// and then the sub-classes would not have to provide a getSQLObjectName
0: 			// method. Currently getDependable(idString).getObjectName() would
0: 			// not always return the same result - fix in main.
0: 
0: 			return getSQLObjectName(getDataDictionary(), recreateUUID(idString));
0: 		} 
0: 		catch (StandardException se) 
0: 		{
0: 			throw PublicAPI.wrapStandardException( se );
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	  * @see DependableFinder#getSQLObjectType
0: 	  */
0: 	public	String	getSQLObjectType()
0: 	{
0: 		switch (formatId)
0: 		{
0: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.ALIAS;
0: 
0: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.CONGLOMERATE;
0: 
0: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.CONSTRAINT;
0: 
0: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.DEFAULT;
0: 
0: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
0: 				return Dependable.FILE;
0: 
0: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.SCHEMA;
0: 
0: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.STORED_PREPARED_STATEMENT;
0: 
0: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.TABLE;
0: 
0: 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.COLUMNS_IN_TABLE;
0: 
0: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.TRIGGER;
0: 
0: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
0: 				return Dependable.VIEW;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"getSQLObjectType() called with unexpeced formatId = " + formatId);
0: 				}
0: 				return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	Gets the datadictionary for this connection.
0: 	  *
0: 	  *	@return	the data dictionary for this connection
0: 	  *
0: 	  * @exception StandardException		Thrown on failure
0: 	  */
0: 	private	DataDictionary	getDataDictionary()
0: 						throws StandardException
0: 	{
0: 		if ( dataDictionary == null )
0: 	    {
0: 			ContextManager				cm  = ContextService.getFactory().getCurrentContextManager();
0: 			DataDictionaryContext		ddc = (DataDictionaryContext)
0: 			                              (cm.getContext(DataDictionaryContext.CONTEXT_ID));
0: 			dataDictionary = ddc.getDataDictionary();
0: 		}
0: 		return	dataDictionary;
0: 	}
0: 
0: 	/**
0: 	 * Get the UUID for the given string
0: 	 *
0: 	 * @param the string
0: 	 *
0: 	 * @return the UUID
0: 	 */
0: 	private UUID recreateUUID(String idString)
0: 	{
0: 		if (uuidFactory == null)
0: 		{
0: 			uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 		}
0: 		return uuidFactory.recreateUUID(idString);
0: 	}
0: 
0: 	/**
0: 		Get the dependable for the given UUID
0: 		@exception StandardException thrown on error
0: 	*/
0: 	protected Dependable getDependable(DataDictionary dd, UUID dependableObjectID)
0: 		throws StandardException
0: 	{
0: 		switch (formatId)
0: 		{
0: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getAliasDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConglomerateDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConstraintDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
0: 				ColumnDescriptor	cd = dd.getColumnDescriptorByDefaultId(dependableObjectID);
0: 				DefaultDescriptor ddi = new DefaultDescriptor(
0: 												dd, 
0: 												cd.getDefaultUUID(), cd.getReferencingUUID(), 
0: 												cd.getPosition());
0: 				return ddi;
0: 
0: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
0: 				return dd.getFileInfoDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSchemaDescriptor(dependableObjectID, null);
0: 
0: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSPSDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTableDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTriggerDescriptor(dependableObjectID);
0: 
0: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getViewDescriptor(dependableObjectID);
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"getDependable() called with unexpeced formatId = " + formatId);
0: 				}
0: 				return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Get the SQL object name for the given UUID
0: 		@exception StandardException thrown on error
0: 	*/
0: 	protected String getSQLObjectName(DataDictionary dd, UUID dependableObjectID)
0: 		throws StandardException
0: 	{
0: 		switch (formatId)
0: 		{
0: 			case StoredFormatIds.ALIAS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getAliasDescriptor(dependableObjectID).getDescriptorName();
0: 
0: 			case StoredFormatIds.CONGLOMERATE_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConglomerateDescriptor(dependableObjectID).getConglomerateName();
0: 
0: 			case StoredFormatIds.CONSTRAINT_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getConstraintDescriptor(dependableObjectID).getConstraintName();
0: 
0: 			case StoredFormatIds.DEFAULT_DESCRIPTOR_FINDER_V01_ID:
0: 				ColumnDescriptor columnDescriptor = dd.getColumnDescriptorByDefaultId( dependableObjectID );
0: 				TableDescriptor tableDescriptor = dd.getTableDescriptor(
0: 										columnDescriptor.getReferencingUUID());
0: 
0: 				return	MessageService.getTextMessage(
0: 							SQLState.LANG_COLUMN_DEFAULT,
0: 							tableDescriptor.getQualifiedName() + "." +
0: 							columnDescriptor.getColumnName());
0: 
0: 			case StoredFormatIds.FILE_INFO_FINDER_V01_ID:
0: 				return dd.getFileInfoDescriptor(dependableObjectID).getName();
0: 
0: 			case StoredFormatIds.SCHEMA_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSchemaDescriptor(dependableObjectID, null).getSchemaName();
0: 
0: 			case StoredFormatIds.SPS_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getSPSDescriptor(dependableObjectID).getName();
0: 
0: 			case StoredFormatIds.TABLE_DESCRIPTOR_FINDER_V01_ID:
0: 			case StoredFormatIds.COLUMN_DESCRIPTOR_FINDER_V01_ID:
0: 				return getDependable(dd, dependableObjectID).getObjectName();
0: 
0: 			case StoredFormatIds.TRIGGER_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTriggerDescriptor(dependableObjectID).getName();
0: 
0: 			case StoredFormatIds.VIEW_DESCRIPTOR_FINDER_V01_ID:
0: 				return dd.getTableDescriptor(dependableObjectID).getName();
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"getSQLObjectName() called with unexpeced formatId = " + formatId);
0: 				}
0: 				return null;
0: 		}
0: 	}
0: }
============================================================================