1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.compile.CompilerContext
1:7ecc1f2: 
1:d4580ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d4580ab:    contributor license agreements.  See the NOTICE file distributed with
1:d4580ab:    this work for additional information regarding copyright ownership.
1:d4580ab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d4580ab:    (the "License"); you may not use this file except in compliance with
1:d4580ab:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
14:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.compile;
1:eac0369: 
1:3bb140c: import java.sql.SQLWarning;
1:3bb140c: import java.util.List;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.compiler.JavaFactory;
1:3bb140c: import org.apache.derby.iapi.services.context.Context;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassFactory;
1:eac0369: import org.apache.derby.iapi.sql.depend.Dependent;
1:eac0369: import org.apache.derby.iapi.sql.depend.Provider;
1:eac0369: import org.apache.derby.iapi.sql.depend.ProviderList;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:98c7520: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:e671fc7: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
1:71c8e86: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.SortCostController;
1:3bb140c: import org.apache.derby.iapi.store.access.StoreCostController;
1:3bb140c: import org.apache.derby.impl.sql.compile.ParameterNode;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * CompilerContext stores the parser and type id factory to be used by
1:eac0369:  * the compiler.  Stack compiler contexts when a new, local parser is needed
1:eac0369:  * (if calling the compiler recursively from within the compiler,
1:eac0369:  * for example).
1:d387dac:  * CompilerContext objects are private to a LanguageConnectionContext.
1:d0c5d9c:  *
14:eac0369:  *
1:eac0369:  * History:
1:eac0369:  *	5/22/97 Moved getExternalInterfaceFactory() to LanguageConnectionContext
1:eac0369:  *			because it had to be used at execution. - Jeff
1:d0c5d9c:  */
1:eac0369: public interface CompilerContext extends Context
1:eac0369: {
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	CONSTANTS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * this is the ID we expect compiler contexts
1:eac0369: 	 * to be stored into a context manager under.
1:eac0369: 	 */
1:eac0369: 	String CONTEXT_ID = "CompilerContext";
1:eac0369: 
1:eac0369: 	// bit masks for query fragments which are potentially unreliable. these are used
1:eac0369: 	// by setReliability() and checkReliability().
1:eac0369: 
1:eac0369: 	public	static	final	int			DATETIME_ILLEGAL			=	0x00000001;	
1:eac0369: 	// NOTE: getCurrentConnection() is currently legal everywhere
1:eac0369: 	public	static	final	int			CURRENT_CONNECTION_ILLEGAL	=	0x00000002;	
1:eac0369: 	public	static	final	int			FUNCTION_CALL_ILLEGAL		=	0x00000004;	
1:eac0369: 	public	static	final	int			UNNAMED_PARAMETER_ILLEGAL	=	0x00000008;	
1:eac0369: 	public	static	final	int			DIAGNOSTICS_ILLEGAL			=	0x00000010;	
1:eac0369: 	public	static	final	int			SUBQUERY_ILLEGAL			=	0x00000020;	
1:eac0369: 	public	static	final	int			USER_ILLEGAL				=	0x00000040;	
1:eac0369: 	public	static	final	int			COLUMN_REFERENCE_ILLEGAL	=	0x00000080;
1:eac0369: 	public	static	final	int			IGNORE_MISSING_CLASSES		=	0x00000100;
1:eac0369: 	public	static	final	int			SCHEMA_ILLEGAL				=	0x00000200;
1:eac0369: 	public  static  final   int			INTERNAL_SQL_ILLEGAL		=	0x00000400;
1:3b1291b: 	
1:3b1291b: 	/**
1:3b1291b: 	 * Calling procedures that modify sql data from before triggers is illegal. 
1:3b1291b: 	 * 
1:3b1291b: 	 */
1:3b1291b: 	public  static  final   int			MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL	=	0x00000800;
1:eac0369: 
1:95a483d: 	public  static  final   int			NON_DETERMINISTIC_ILLEGAL		=	0x00001000;
1:5a0cfa2: 	public  static  final   int			SQL_IN_ROUTINES_ILLEGAL		=	0x00002000;
1:95a483d: 
1:e671fc7: 	public  static  final   int			NEXT_VALUE_FOR_ILLEGAL		=	0x00004000;
1:e671fc7: 
1:eac0369: 	/** Standard SQL is legal */
1:eac0369: 	public	static	final	int			SQL_LEGAL					=	(INTERNAL_SQL_ILLEGAL);
1:eac0369: 
1:eac0369: 	/** Any SQL we support is legal */
1:eac0369: 	public	static	final	int			INTERNAL_SQL_LEGAL			=	0;
1:eac0369: 
1:eac0369: 	public	static	final	int			CHECK_CONSTRAINT		= (
1:eac0369: 		                                                                    DATETIME_ILLEGAL |
1:eac0369: 																		    UNNAMED_PARAMETER_ILLEGAL |
1:eac0369: 																		    DIAGNOSTICS_ILLEGAL |
1:eac0369: 																		    SUBQUERY_ILLEGAL |
1:eac0369: 																			USER_ILLEGAL |
1:eac0369: 																			SCHEMA_ILLEGAL |
1:e671fc7: 																			INTERNAL_SQL_ILLEGAL |
1:e671fc7:                                                                             NEXT_VALUE_FOR_ILLEGAL
1:eac0369: 																		  );
1:eac0369: 
1:eac0369: 	public	static	final	int			DEFAULT_RESTRICTION		= (
1:eac0369: 		                                                                    SUBQUERY_ILLEGAL |
1:eac0369: 																			UNNAMED_PARAMETER_ILLEGAL |
1:eac0369: 																			COLUMN_REFERENCE_ILLEGAL |
2:eac0369: 																			INTERNAL_SQL_ILLEGAL
1:eac0369: 																			);
1:eac0369: 
1:95a483d: 	public	static	final	int			GENERATION_CLAUSE_RESTRICTION		= (
1:95a483d: 		                                                                    CHECK_CONSTRAINT |
1:5a0cfa2: 																			NON_DETERMINISTIC_ILLEGAL |
1:e671fc7:                                                                             SQL_IN_ROUTINES_ILLEGAL |
1:e671fc7:                                                                             NEXT_VALUE_FOR_ILLEGAL
1:95a483d: 																			);
1:95a483d: 
1:e671fc7: 	public	static	final	int			WHERE_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7: 	public	static	final	int			HAVING_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7: 	public	static	final	int			ON_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7: 	public	static	final	int			AGGREGATE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7: 	public	static	final	int			CONDITIONAL_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7: 	public	static	final	int			GROUP_BY_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1:eac0369: 
1:2455f1a:     public static final int CASE_OPERAND_RESTRICTION =
1:2455f1a:             CONDITIONAL_RESTRICTION | NON_DETERMINISTIC_ILLEGAL |
1:2455f1a:             MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL;
1:2455f1a: 
1:fc9fd0d:     public  static  final   String  WHERE_SCOPE = "whereScope";
1:fc9fd0d:     
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	BEHAVIOR
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Parser from this CompilerContext.
1:eac0369: 	 *	 *
1:eac0369: 	 * @return	The parser associated with this CompilerContext
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	Parser getParser();
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Get the OptimizerFactory from this CompilerContext.
1:eac0369: 	 *
1:3bb140c:      * @return  The OptimizerFactory associated with this CompilerContext
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     OptimizerFactory getOptimizerFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the TypeCompilerFactory from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return	The TypeCompilerFactory associated with this CompilerContext
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	TypeCompilerFactory getTypeCompilerFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the class factory to use in this compilation.
1:eac0369: 	*/
1:eac0369: 	ClassFactory getClassFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the JavaFactory from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return	The JavaFactory associated with this CompilerContext
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	JavaFactory getJavaFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current next column number (for generated column names)
1:eac0369: 	 * from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The next column number for the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNextColumnNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Reset compiler context (as for instance, when we recycle a context for
1:eac0369: 	  *	use by another compilation.
1:eac0369: 	  */
1:eac0369: 	void	resetContext();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current next table number from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The next table number for the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNextTableNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of tables in the current statement from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The number of tables in the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNumTables();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current next subquery number from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The next subquery number for the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNextSubqueryNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of subquerys in the current statement from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The number of subquerys in the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNumSubquerys();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current next ResultSet number from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return int	The next ResultSet number for the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNextResultSetNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Reset the next ResultSet number from this CompilerContext.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void resetNextResultSetNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of Results in the current statement from this CompilerContext.
1:eac0369: 	 *
1:6b50965: 	 * @return The number of ResultSets in the current statement.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	int getNumResultSets();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a unique Class name from this CompilerContext.
1:eac0369: 	 * Ensures it is globally unique for this JVM.
1:eac0369: 	 *
1:eac0369: 	 * @return String	A unique-enough class name.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	String getUniqueClassName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the current dependent from this CompilerContext.
1:eac0369: 	 * This should be called at the start of a compile to
1:eac0369: 	 * register who has the dependencies needed for the compilation.
1:eac0369: 	 *
1:eac0369: 	 * @param d	The Dependent currently being compiled.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void setCurrentDependent(Dependent d);
1:d0c5d9c: 
1:d0c5d9c: 	/**
1:eac0369: 	 * Get the current auxiliary provider list from this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @return	The current AuxiliaryProviderList.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	ProviderList getCurrentAuxiliaryProviderList();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the current auxiliary provider list for this CompilerContext.
1:eac0369: 	 *
1:eac0369: 	 * @param apl	The new current AuxiliaryProviderList.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void setCurrentAuxiliaryProviderList(ProviderList apl);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a dependency for the current dependent.
1:eac0369: 	 *
1:eac0369: 	 * @param p	The Provider of the dependency.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void createDependency(Provider p) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a dependency between two objects.
1:eac0369: 	 *
1:eac0369: 	 * @param d	The Dependent object.
1:eac0369: 	 * @param p	The Provider of the dependency.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 *
1:eac0369: 	 */
1:e1f49ca:     void createDependency(Dependent d, Provider p) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add an object to the pool that is created at compile time
1:eac0369: 	 * and used at execution time.  Use the integer to reference it
1:eac0369: 	 * in execution constructs.  Execution code will have to generate:
1:eac0369: 	 *	<pre>
1:eac0369: 	 *	(#objectType) (this.getPreparedStatement().getSavedObject(#int))
1:dbed020: 	 *  </pre>
1:eac0369: 	 *
1:6b50965: 	 * @param o object to add to the pool of saved objects
1:eac0369: 	 * @return the entry # for the object
1:eac0369: 	 */
1:eac0369: 	int	addSavedObject(Object o);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Get the saved object pool (for putting into the prepared statement).
1:eac0369: 	 *  This turns it into its storable form, an array of objects.
1:eac0369: 	 *
1:eac0369: 	 * @return the saved object pool.
1:eac0369: 	 */
1:eac0369: 	Object[] getSavedObjects(); 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Set the saved object pool (for putting into the prepared statement).
1:eac0369: 	 *
1:eac0369: 	 * @param objs	 The new saved objects
1:554386c:      * @throws NullPointerException if {@code objs} is null
1:eac0369: 	 */
1:71c8e86:     void setSavedObjects(List<Object> objs);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the in use state for the compiler context.
1:eac0369: 	 *
1:eac0369: 	 * @param inUse	 The new inUse state for the compiler context.
1:eac0369: 	 */
1:e1f49ca:     void setInUse(boolean inUse);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the in use state for the compiler context.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	The in use state for the compiler context.
1:eac0369: 	 */
1:e1f49ca:     boolean getInUse();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this CompilerContext as the first on the stack, so we can avoid
1:eac0369: 	 * continually popping and pushing a CompilerContext.
1:eac0369: 	 */
1:e1f49ca:     void firstOnStack();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this the first CompilerContext on the stack?
1:eac0369: 	 */
1:e1f49ca:     boolean isFirstOnStack();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets which kind of query fragments are NOT allowed. Basically,
1:eac0369: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
1:eac0369: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
1:eac0369: 	 *
1:eac0369: 	 * @param reliability	bitmask of types of query fragments to be forbidden
1:eac0369: 	 *						see the reliability bitmasks above
1:eac0369: 	 *
1:eac0369: 	 */
1:e1f49ca:     void    setReliability(int reliability);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the reliability requirements of this clause. See setReliability()
1:eac0369: 	 * for a definition of clause reliability.
1:eac0369: 	 *
1:eac0369: 	 * @return a bitmask of which types of query fragments are to be forbidden
1:eac0369: 	 */
1:e1f49ca:     int getReliability();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the compilation schema descriptor for this compilation context.
1:eac0369: 	   Will be null if no default schema lookups have occured. Ie.
1:eac0369: 	   the statement is independent of the current schema.
1:eac0369: 	 * 
1:eac0369: 	 * @return the compilation schema descirptor
1:eac0369: 	 */
1:e1f49ca:     SchemaDescriptor getCompilationSchema();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the compilation schema descriptor for this compilation context.
1:eac0369: 	 *
1:6b50965: 	 * @param newDefault compilation schema
1:eac0369: 	 * 
1:eac0369: 	 * @return the previous compilation schema descirptor
1:eac0369: 	 */
1:e1f49ca:     SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault);
1:eac0369: 
1:eac0369: 	/**
1:392ac57: 	 * Push a default schema to use when compiling.
1:392ac57: 	 * <p>
1:392ac57: 	 * Sometimes, we need to temporarily change the default schema, for example
1:392ac57: 	 * when recompiling a view, since the execution time default schema may
1:392ac57: 	 * differ from the required default schema when the view was defined.
1:392ac57: 	 * Another case is when compiling generated columns which reference
1:392ac57: 	 * unqualified user functions.
1:392ac57: 	 * </p>
1:392ac57: 	 * @param sd schema to use
1:392ac57: 	 */
1:e1f49ca:     void pushCompilationSchema(SchemaDescriptor sd);
1:392ac57: 
1:392ac57: 
1:392ac57: 	/**
1:392ac57: 	 * Pop the default schema to use when compiling.
1:392ac57: 	 */
1:e1f49ca:     void popCompilationSchema();
1:392ac57: 
1:392ac57: 	/**
1:eac0369: 	 * Get a StoreCostController for the given conglomerate.
1:eac0369: 	 *
1:eac0369: 	 * @param conglomerateNumber	The conglomerate for which to get a
1:eac0369: 	 *								StoreCostController.
1:eac0369: 	 *
1:eac0369: 	 * @return	The appropriate StoreCostController.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     StoreCostController getStoreCostController(long conglomerateNumber)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a SortCostController.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     SortCostController getSortCostController() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the parameter list.
1:eac0369: 	 *
1:eac0369: 	 * @param parameterList	The parameter list.
1:eac0369: 	 */
1:e1f49ca:     void setParameterList(List<ParameterNode> parameterList);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the parameter list.
1:eac0369: 	 *
1:eac0369: 	 * @return	The parameter list.
1:eac0369: 	 */
1:e1f49ca:     List<ParameterNode> getParameterList();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If callable statement uses ? = form
1:eac0369: 	 */
1:e1f49ca:     void setReturnParameterFlag();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is the callable statement uses ? for return parameter.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if ? = call else false
1:eac0369: 	 */
1:e1f49ca:     boolean getReturnParameterFlag();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the cursor info stored in the context.
1:eac0369: 	 *
1:eac0369: 	 * @return the cursor info
1:eac0369: 	 */
1:e1f49ca:     Object getCursorInfo();
1:eac0369: 	
1:eac0369: 	/**
2:eac0369: 	 * Set params
1:eac0369: 	 *
1:eac0369: 	 * @param cursorInfo the cursor info
1:eac0369: 	 */
1:e1f49ca:     void setCursorInfo(Object cursorInfo);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the isolation level for the scans in this query.
1:eac0369: 	 *
1:eac0369: 	 * @param isolationLevel	The isolation level to use.
1:eac0369: 	 */
1:e1f49ca:     void setScanIsolationLevel(int isolationLevel);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the isolation level for the scans in this query.
1:eac0369: 	 *
1:eac0369: 	 * @return	The isolation level for the scans in this query.
1:eac0369: 	 */
1:e1f49ca:     int getScanIsolationLevel();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the next equivalence class for equijoin clauses.
1:eac0369: 	 *
1:eac0369: 	 * @return The next equivalence class for equijoin clauses.
1:eac0369: 	 */
1:e1f49ca:     int getNextEquivalenceClass();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a compile time warning.
1:eac0369: 	*/
1:e1f49ca:     void addWarning(SQLWarning warning);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the chain of compile time warnings.
1:eac0369: 	*/
1:e1f49ca:     SQLWarning getWarnings();
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Sets the current privilege type context and pushes the previous on onto a stack.
1:b7730e4: 	 * Column and table nodes do not know how they are
1:b7730e4: 	 * being used. Higher level nodes in the query tree do not know what is being
1:b7730e4: 	 * referenced. Keeping the context allows the two to come together.
1:eac0369: 	 *
1:b7730e4: 	 * @param privType One of the privilege types in 
1:b7730e4: 	 *						org.apache.derby.iapi.sql.conn.Authorizer.
1:eac0369: 	 */
1:e1f49ca:     void pushCurrentPrivType( int privType);
1:eac0369: 	
1:e1f49ca:     void popCurrentPrivType();
1:eac0369:     
1:eac0369: 	/**
1:b7730e4: 	 * Add a column privilege to the list of used column privileges.
1:eac0369: 	 *
1:b7730e4: 	 * @param column
1:eac0369: 	 */
1:e1f49ca:     void addRequiredColumnPriv( ColumnDescriptor column);
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Add a table or view privilege to the list of used table privileges.
1:eac0369: 	 *
1:b7730e4: 	 * @param table
1:eac0369: 	 */
1:e1f49ca:     void addRequiredTablePriv( TableDescriptor table);
1:eac0369: 
1:eac0369: 	/**
1:c45f5b1: 	 * Add a schema privilege to the list of used privileges.
1:eac0369: 	 *
1:e1987c6: 	 * @param schema	Schema name of the object that is being accessed
1:e1987c6: 	 * @param aid		Requested authorizationId for new schema
1:28c633d: 	 * @param privType	CREATE_SCHEMA_PRIV, MODIFY_SCHEMA_PRIV or DROP_SCHEMA_PRIV
1:eac0369: 	 */
1:e1f49ca:     void addRequiredSchemaPriv(String schema, String aid, int privType);
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	 * Add a routine execute privilege to the list of used routine privileges.
1:eac0369: 	 *
1:b7730e4: 	 * @param routine
1:eac0369: 	 */
1:e1f49ca:     void addRequiredRoutinePriv( AliasDescriptor routine);
1:eac0369: 
1:eac0369: 	/**
1:98c7520: 	 * Add a usage privilege to the list of required privileges.
1:98c7520: 	 *
1:98c7520: 	 * @param usableObject
1:98c7520: 	 */
1:e1f49ca:     void addRequiredUsagePriv( PrivilegedSQLObject usableObject );
1:98c7520: 
1:98c7520: 	/**
1:ee59de8: 	 * Add a required role privilege to the list of privileges.
1:ee59de8: 	 *
1:ee59de8: 	 * @see CompilerContext#addRequiredRolePriv
1:ee59de8: 	 */
1:e1f49ca:     void addRequiredRolePriv(String roleName, int privType);
1:ee59de8: 
1:ee59de8: 	/**
1:b7730e4: 	 * @return The list of required privileges.
1:eac0369: 	 */
1:801cf0d:     List<StatementPermission> getRequiredPermissionsList();
1:e671fc7:     
1:e671fc7: 	/**
1:e671fc7: 	 * Add a sequence descriptor to the list of referenced sequences.
1:e671fc7: 	 */
1:e1f49ca:     void addReferencedSequence( SequenceDescriptor sd );
1:e671fc7: 
1:e671fc7: 	/**
1:e671fc7: 	 * Report whether the given sequence has been referenced already.
1:e671fc7: 	 */
1:e1f49ca:     boolean isReferenced( SequenceDescriptor sd );
1:e671fc7: 
1:070d37e:     /**
1:070d37e:      * Add a filter for determining which QueryTreeNodes give rise to privilege checks
1:070d37e:      * at run time. The null filter (the default) says that all QueryTreeNodes potentially give
1:070d37e:      * rise to privilege checks.
1:070d37e:      */
1:070d37e:     public  void    addPrivilegeFilter( VisitableFilter vf );
1:070d37e: 
1:070d37e:     /**
1:070d37e:      * Remove a filter for determining which QueryTreeNodes give rise to privilege
1:070d37e:      * checks at run time.
1:070d37e:      */
1:070d37e:     public  void    removePrivilegeFilter( VisitableFilter vf );
1:070d37e:     
1:070d37e:     /**
1:070d37e:      * Return true if a QueryTreeNode passes all of the filters which determine whether
1:070d37e:      * the QueryTreeNode gives rise to run time privilege checks.
1:070d37e:      */
1:070d37e:     public  boolean passesPrivilegeFilters( Visitable visitable )
1:070d37e:         throws StandardException;
1:fc9fd0d: 
1:fc9fd0d:     /**
1:fc9fd0d:      * Record that the compiler is entering a named scope. Increment the
1:fc9fd0d:      * depth counter for that scope.
1:fc9fd0d:      */
1:fc9fd0d:     public  void    beginScope( String scopeName );
1:fc9fd0d:     
1:fc9fd0d:     /**
1:fc9fd0d:      * Record that the compiler is exiting a named scope. Decrement the
1:fc9fd0d:      * depth counter for that scope.
1:fc9fd0d:      */
1:fc9fd0d:     public  void    endScope( String scopeName );
1:fc9fd0d: 
1:fc9fd0d:     /**
1:fc9fd0d:      * Get the current depth for the named scope. For instance, if
1:fc9fd0d:      * we are processing a WHERE clause inside a subquery which is
1:fc9fd0d:      * invoked inside an outer WHERE clause, the depth of the whereScope
1:fc9fd0d:      * would be 2. Returns 0 if the compiler isn't inside any such scope.
1:fc9fd0d:      */
1:fc9fd0d:     public  int     scopeDepth( String scopeName );
1:b93f9db: 
1:b93f9db:     /**
1:b93f9db:      * Set whether we should skip adding USAGE privileges for user-defined types.
1:b93f9db:      * Returns the previous setting of this variable.
1:b93f9db:      */
1:b93f9db:     public  boolean    skipTypePrivileges( boolean skip );
1:b93f9db: 
1:b93f9db:     /** Return whether we are skipping USAGE privileges for user-defined types */
1:b93f9db:     public  boolean skippingTypePrivileges();
1:070d37e:     
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *  </pre>
commit:b93f9db
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set whether we should skip adding USAGE privileges for user-defined types.
1:      * Returns the previous setting of this variable.
1:      */
1:     public  boolean    skipTypePrivileges( boolean skip );
1: 
1:     /** Return whether we are skipping USAGE privileges for user-defined types */
1:     public  boolean skippingTypePrivileges();
commit:fc9fd0d
/////////////////////////////////////////////////////////////////////////
1:     public  static  final   String  WHERE_SCOPE = "whereScope";
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Record that the compiler is entering a named scope. Increment the
1:      * depth counter for that scope.
1:      */
1:     public  void    beginScope( String scopeName );
1:     
1:     /**
1:      * Record that the compiler is exiting a named scope. Decrement the
1:      * depth counter for that scope.
1:      */
1:     public  void    endScope( String scopeName );
1: 
1:     /**
1:      * Get the current depth for the named scope. For instance, if
1:      * we are processing a WHERE clause inside a subquery which is
1:      * invoked inside an outer WHERE clause, the depth of the whereScope
1:      * would be 2. Returns 0 if the compiler isn't inside any such scope.
1:      */
1:     public  int     scopeDepth( String scopeName );
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Add a filter for determining which QueryTreeNodes give rise to privilege checks
1:      * at run time. The null filter (the default) says that all QueryTreeNodes potentially give
1:      * rise to privilege checks.
1:      */
1:     public  void    addPrivilegeFilter( VisitableFilter vf );
1: 
1:     /**
1:      * Remove a filter for determining which QueryTreeNodes give rise to privilege
1:      * checks at run time.
1:      */
1:     public  void    removePrivilegeFilter( VisitableFilter vf );
1:     
1:     /**
1:      * Return true if a QueryTreeNode passes all of the filters which determine whether
1:      * the QueryTreeNode gives rise to run time privilege checks.
1:      */
1:     public  boolean passesPrivilegeFilters( Visitable visitable )
1:         throws StandardException;
1:     
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
/////////////////////////////////////////////////////////////////////////
1:     void setSavedObjects(List<Object> objs);
/////////////////////////////////////////////////////////////////////////
0: 	public List<StatementPermission>getRequiredPermissionsList();
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	public  static  final   int			NEXT_VALUE_FOR_ILLEGAL		=	0x00004000;
1: 
/////////////////////////////////////////////////////////////////////////
1: 																			INTERNAL_SQL_ILLEGAL |
1:                                                                             NEXT_VALUE_FOR_ILLEGAL
/////////////////////////////////////////////////////////////////////////
1:                                                                             SQL_IN_ROUTINES_ILLEGAL |
1:                                                                             NEXT_VALUE_FOR_ILLEGAL
1: 	public	static	final	int			WHERE_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1: 	public	static	final	int			HAVING_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1: 	public	static	final	int			ON_CLAUSE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1: 	public	static	final	int			AGGREGATE_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1: 	public	static	final	int			CONDITIONAL_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
1: 	public	static	final	int			GROUP_BY_RESTRICTION		= NEXT_VALUE_FOR_ILLEGAL;
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * Add a sequence descriptor to the list of referenced sequences.
1: 	 */
0: 	public void addReferencedSequence( SequenceDescriptor sd );
1: 
1: 	/**
1: 	 * Report whether the given sequence has been referenced already.
1: 	 */
0:     public boolean isReferenced( SequenceDescriptor sd );
1: 
commit:98c7520
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
/////////////////////////////////////////////////////////////////////////
1: 	 * Add a usage privilege to the list of required privileges.
1: 	 *
1: 	 * @param usableObject
1: 	 */
0: 	public void addRequiredUsagePriv( PrivilegedSQLObject usableObject );
1: 
1: 	/**
commit:5a0cfa2
/////////////////////////////////////////////////////////////////////////
1: 	public  static  final   int			SQL_IN_ROUTINES_ILLEGAL		=	0x00002000;
/////////////////////////////////////////////////////////////////////////
1: 																			NON_DETERMINISTIC_ILLEGAL |
0:                                                                             SQL_IN_ROUTINES_ILLEGAL
commit:95a483d
/////////////////////////////////////////////////////////////////////////
1: 	public  static  final   int			NON_DETERMINISTIC_ILLEGAL		=	0x00001000;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public	static	final	int			GENERATION_CLAUSE_RESTRICTION		= (
1: 		                                                                    CHECK_CONSTRAINT |
0: 																			NON_DETERMINISTIC_ILLEGAL
1: 																			);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2455f1a
/////////////////////////////////////////////////////////////////////////
1:     public static final int CASE_OPERAND_RESTRICTION =
1:             CONDITIONAL_RESTRICTION | NON_DETERMINISTIC_ILLEGAL |
1:             MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL;
1: 
commit:b49cc55
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:554386c
/////////////////////////////////////////////////////////////////////////
1:      * @throws NullPointerException if {@code objs} is null
0:     void setSavedObjects(List objs);
commit:38b5979
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public void setParameterList(List parameterList);
0: 	public List getParameterList();
commit:878e211
/////////////////////////////////////////////////////////////////////////
commit:d0c5d9c
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Get the current dependent from this {@code CompilerContext}.
1:      *
0:      * @return the dependent currently being compiled
1:      */
0:     Dependent getCurrentDependent();
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1:     List<StatementPermission> getRequiredPermissionsList();
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     void createDependency(Dependent d, Provider p) throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:     void setInUse(boolean inUse);
1:     boolean getInUse();
1:     void firstOnStack();
1:     boolean isFirstOnStack();
/////////////////////////////////////////////////////////////////////////
1:     void    setReliability(int reliability);
/////////////////////////////////////////////////////////////////////////
1:     int getReliability();
/////////////////////////////////////////////////////////////////////////
1:     SchemaDescriptor getCompilationSchema();
/////////////////////////////////////////////////////////////////////////
1:     SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault);
/////////////////////////////////////////////////////////////////////////
1:     void pushCompilationSchema(SchemaDescriptor sd);
1:     void popCompilationSchema();
/////////////////////////////////////////////////////////////////////////
1:     StoreCostController getStoreCostController(long conglomerateNumber)
/////////////////////////////////////////////////////////////////////////
1:     SortCostController getSortCostController() throws StandardException;
1:     void setParameterList(List<ParameterNode> parameterList);
1:     List<ParameterNode> getParameterList();
1:     void setReturnParameterFlag();
1:     boolean getReturnParameterFlag();
1:     Object getCursorInfo();
1:     void setCursorInfo(Object cursorInfo);
1:     void setScanIsolationLevel(int isolationLevel);
1:     int getScanIsolationLevel();
1:     int getNextEquivalenceClass();
1:     void addWarning(SQLWarning warning);
1:     SQLWarning getWarnings();
/////////////////////////////////////////////////////////////////////////
1:     void pushCurrentPrivType( int privType);
1:     void popCurrentPrivType();
1:     void addRequiredColumnPriv( ColumnDescriptor column);
1:     void addRequiredTablePriv( TableDescriptor table);
/////////////////////////////////////////////////////////////////////////
1:     void addRequiredSchemaPriv(String schema, String aid, int privType);
1:     void addRequiredRoutinePriv( AliasDescriptor routine);
1:     void addRequiredUsagePriv( PrivilegedSQLObject usableObject );
1:     void addRequiredRolePriv(String roleName, int privType);
0:     List<StatementPermission>getRequiredPermissionsList();
1:     void addReferencedSequence( SequenceDescriptor sd );
1:     boolean isReferenced( SequenceDescriptor sd );
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
1: import java.util.List;
1: import org.apache.derby.iapi.services.compiler.JavaFactory;
1: import org.apache.derby.iapi.services.context.Context;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.PrivilegedSQLObject;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.impl.sql.compile.ParameterNode;
/////////////////////////////////////////////////////////////////////////
1:      * Get the OptimizerFactory from this CompilerContext.
1:      * @return  The OptimizerFactory associated with this CompilerContext
1:     OptimizerFactory getOptimizerFactory();
/////////////////////////////////////////////////////////////////////////
0:     public void setParameterList(List<ParameterNode> parameterList);
0:     public List<ParameterNode> getParameterList();
commit:392ac57
/////////////////////////////////////////////////////////////////////////
1: 	 * Push a default schema to use when compiling.
1: 	 * <p>
1: 	 * Sometimes, we need to temporarily change the default schema, for example
1: 	 * when recompiling a view, since the execution time default schema may
1: 	 * differ from the required default schema when the view was defined.
1: 	 * Another case is when compiling generated columns which reference
1: 	 * unqualified user functions.
1: 	 * </p>
1: 	 * @param sd schema to use
1: 	 */
0: 	public void pushCompilationSchema(SchemaDescriptor sd);
1: 
1: 
1: 	/**
1: 	 * Pop the default schema to use when compiling.
1: 	 */
0: 	public void popCompilationSchema();
1: 
1: 	/**
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
1: 	 * Add a required role privilege to the list of privileges.
1: 	 *
1: 	 * @see CompilerContext#addRequiredRolePriv
1: 	 */
0: 	public void addRequiredRolePriv(String roleName, int privType);
1: 
1: 	/**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:58f22ba
/////////////////////////////////////////////////////////////////////////
commit:3b1291b
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Calling procedures that modify sql data from before triggers is illegal. 
1: 	 * 
1: 	 */
1: 	public  static  final   int			MODIFIES_SQL_DATA_PROCEDURE_ILLEGAL	=	0x00000800;
commit:d387dac
/////////////////////////////////////////////////////////////////////////
1:  * CompilerContext objects are private to a LanguageConnectionContext.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	public StoreCostController getStoreCostController(long conglomerateNumber)
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.compile.CompilerContext
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
1: import org.apache.derby.iapi.sql.depend.Dependent;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.ProviderList;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.SortCostController;
1: 
0: import java.util.Vector;
0: import java.sql.SQLWarning;
1: 
1: /**
1:  * CompilerContext stores the parser and type id factory to be used by
1:  * the compiler.  Stack compiler contexts when a new, local parser is needed
1:  * (if calling the compiler recursively from within the compiler,
1:  * for example).
1:  *
0:  * @author ames
1:  *
1:  * History:
1:  *	5/22/97 Moved getExternalInterfaceFactory() to LanguageConnectionContext
1:  *			because it had to be used at execution. - Jeff
1:  */
1: public interface CompilerContext extends Context
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/////////////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	CONSTANTS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * this is the ID we expect compiler contexts
1: 	 * to be stored into a context manager under.
1: 	 */
1: 	String CONTEXT_ID = "CompilerContext";
1: 
1: 	// bit masks for query fragments which are potentially unreliable. these are used
1: 	// by setReliability() and checkReliability().
1: 
1: 	public	static	final	int			DATETIME_ILLEGAL			=	0x00000001;	
1: 	// NOTE: getCurrentConnection() is currently legal everywhere
1: 	public	static	final	int			CURRENT_CONNECTION_ILLEGAL	=	0x00000002;	
1: 	public	static	final	int			FUNCTION_CALL_ILLEGAL		=	0x00000004;	
1: 	public	static	final	int			UNNAMED_PARAMETER_ILLEGAL	=	0x00000008;	
1: 	public	static	final	int			DIAGNOSTICS_ILLEGAL			=	0x00000010;	
1: 	public	static	final	int			SUBQUERY_ILLEGAL			=	0x00000020;	
1: 	public	static	final	int			USER_ILLEGAL				=	0x00000040;	
1: 	public	static	final	int			COLUMN_REFERENCE_ILLEGAL	=	0x00000080;
1: 	public	static	final	int			IGNORE_MISSING_CLASSES		=	0x00000100;
1: 	public	static	final	int			SCHEMA_ILLEGAL				=	0x00000200;
1: 	public  static  final   int			INTERNAL_SQL_ILLEGAL		=	0x00000400;
1: 
1: 	/** Standard SQL is legal */
1: 	public	static	final	int			SQL_LEGAL					=	(INTERNAL_SQL_ILLEGAL);
1: 
1: 	/** Any SQL we support is legal */
1: 	public	static	final	int			INTERNAL_SQL_LEGAL			=	0;
1: 
1: 	public	static	final	int			CHECK_CONSTRAINT		= (
1: 		                                                                    DATETIME_ILLEGAL |
1: 																		    UNNAMED_PARAMETER_ILLEGAL |
1: 																		    DIAGNOSTICS_ILLEGAL |
1: 																		    SUBQUERY_ILLEGAL |
1: 																			USER_ILLEGAL |
1: 																			SCHEMA_ILLEGAL |
1: 																			INTERNAL_SQL_ILLEGAL
1: 																		  );
1: 
1: 	public	static	final	int			DEFAULT_RESTRICTION		= (
1: 		                                                                    SUBQUERY_ILLEGAL |
1: 																			UNNAMED_PARAMETER_ILLEGAL |
1: 																			COLUMN_REFERENCE_ILLEGAL |
1: 																			INTERNAL_SQL_ILLEGAL
1: 																			);
1: 
1: 
1: 	/////////////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	BEHAVIOR
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get the Parser from this CompilerContext.
1: 	 *	 *
1: 	 * @return	The parser associated with this CompilerContext
1: 	 *
1: 	 */
1: 
1: 	Parser getParser();
1: 
1: 	/**
0: 	 * Get the NodeFactory from this CompilerContext.
1: 	 *
0: 	 * @return	The NodeFactory associated with this CompilerContext
1: 	 *
1: 	 */
1: 
0: 	NodeFactory getNodeFactory();
1: 
1: 	/**
1: 	 * Get the TypeCompilerFactory from this CompilerContext.
1: 	 *
1: 	 * @return	The TypeCompilerFactory associated with this CompilerContext
1: 	 *
1: 	 */
1: 	TypeCompilerFactory getTypeCompilerFactory();
1: 
1: 	/**
1: 		Return the class factory to use in this compilation.
1: 	*/
1: 	ClassFactory getClassFactory();
1: 
1: 	/**
1: 	 * Get the JavaFactory from this CompilerContext.
1: 	 *
1: 	 * @return	The JavaFactory associated with this CompilerContext
1: 	 *
1: 	 */
1: 
1: 	JavaFactory getJavaFactory();
1: 
1: 	/**
1: 	 * Get the current next column number (for generated column names)
1: 	 * from this CompilerContext.
1: 	 *
1: 	 * @return int	The next column number for the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNextColumnNumber();
1: 
1: 	/**
1: 	  *	Reset compiler context (as for instance, when we recycle a context for
1: 	  *	use by another compilation.
1: 	  */
1: 	void	resetContext();
1: 
1: 	/**
1: 	 * Get the current next table number from this CompilerContext.
1: 	 *
1: 	 * @return int	The next table number for the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNextTableNumber();
1: 
1: 	/**
1: 	 * Get the number of tables in the current statement from this CompilerContext.
1: 	 *
1: 	 * @return int	The number of tables in the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNumTables();
1: 
1: 	/**
1: 	 * Get the current next subquery number from this CompilerContext.
1: 	 *
1: 	 * @return int	The next subquery number for the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNextSubqueryNumber();
1: 
1: 	/**
1: 	 * Get the number of subquerys in the current statement from this CompilerContext.
1: 	 *
1: 	 * @return int	The number of subquerys in the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNumSubquerys();
1: 
1: 	/**
1: 	 * Get the current next ResultSet number from this CompilerContext.
1: 	 *
1: 	 * @return int	The next ResultSet number for the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNextResultSetNumber();
1: 
1: 	/**
1: 	 * Reset the next ResultSet number from this CompilerContext.
1: 	 *
0: 	 * @return None.
1: 	 *
1: 	 */
1: 
1: 	void resetNextResultSetNumber();
1: 
1: 	/**
1: 	 * Get the number of Results in the current statement from this CompilerContext.
1: 	 *
0: 	 * @return int	The number of ResultSets in the current statement.
1: 	 *
1: 	 */
1: 
1: 	int getNumResultSets();
1: 
1: 	/**
1: 	 * Get a unique Class name from this CompilerContext.
1: 	 * Ensures it is globally unique for this JVM.
1: 	 *
1: 	 * @return String	A unique-enough class name.
1: 	 *
1: 	 */
1: 
1: 	String getUniqueClassName();
1: 
1: 	/**
0: 	 * Get the current dependent from this CompilerContext.
1: 	 *
0: 	 * @return	The Dependent currently being compiled.
1: 	 *
1: 	 */
1: 
0: 	Dependent getCurrentDependent();
1: 
1: 	/**
1: 	 * Set the current dependent from this CompilerContext.
1: 	 * This should be called at the start of a compile to
1: 	 * register who has the dependencies needed for the compilation.
1: 	 *
1: 	 * @param d	The Dependent currently being compiled.
1: 	 *
1: 	 */
1: 
1: 	void setCurrentDependent(Dependent d);
1: 
1: 	/**
1: 	 * Get the current auxiliary provider list from this CompilerContext.
1: 	 *
1: 	 * @return	The current AuxiliaryProviderList.
1: 	 *
1: 	 */
1: 
1: 	ProviderList getCurrentAuxiliaryProviderList();
1: 
1: 	/**
1: 	 * Set the current auxiliary provider list for this CompilerContext.
1: 	 *
1: 	 * @param apl	The new current AuxiliaryProviderList.
1: 	 *
1: 	 */
1: 
1: 	void setCurrentAuxiliaryProviderList(ProviderList apl);
1: 
1: 	/**
1: 	 * Add a dependency for the current dependent.
1: 	 *
1: 	 * @param p	The Provider of the dependency.
1: 	 * @exception StandardException thrown on failure.
1: 	 *
1: 	 */
1: 	void createDependency(Provider p) throws StandardException;
1: 
1: 	/**
1: 	 * Add a dependency between two objects.
1: 	 *
1: 	 * @param d	The Dependent object.
1: 	 * @param p	The Provider of the dependency.
1: 	 * @exception StandardException thrown on failure.
1: 	 *
1: 	 */
0: 	public	void createDependency(Dependent d, Provider p) throws StandardException;
1: 
1: 	/**
1: 	 * Add an object to the pool that is created at compile time
1: 	 * and used at execution time.  Use the integer to reference it
1: 	 * in execution constructs.  Execution code will have to generate:
1: 	 *	<pre>
1: 	 *	(#objectType) (this.getPreparedStatement().getSavedObject(#int))
0: 	 *  <\pre>
1: 	 *
0: 	 * @param the object to add to the pool of saved objects
1: 	 * @return the entry # for the object
1: 	 */
1: 	int	addSavedObject(Object o);
1: 
1: 	/**
1: 	 *	Get the saved object pool (for putting into the prepared statement).
1: 	 *  This turns it into its storable form, an array of objects.
1: 	 *
1: 	 * @return the saved object pool.
1: 	 */
1: 	Object[] getSavedObjects(); 
1: 
1: 	/**
1: 	 *	Set the saved object pool (for putting into the prepared statement).
1: 	 *
1: 	 * @param objs	 The new saved objects
1: 	 */
0: 	public void setSavedObjects(Object[] objs); 
1: 
1: 	/**
1: 	 * Set the in use state for the compiler context.
1: 	 *
1: 	 * @param inUse	 The new inUse state for the compiler context.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 */
0: 	public void setInUse(boolean inUse);
1: 
1: 	/**
1: 	 * Return the in use state for the compiler context.
1: 	 *
1: 	 * @return boolean	The in use state for the compiler context.
1: 	 */
0: 	public boolean getInUse();
1: 
1: 	/**
1: 	 * Mark this CompilerContext as the first on the stack, so we can avoid
1: 	 * continually popping and pushing a CompilerContext.
1: 	 */
0: 	public void firstOnStack();
1: 
1: 	/**
1: 	 * Is this the first CompilerContext on the stack?
1: 	 */
0: 	public boolean isFirstOnStack();
1: 
1: 	/**
1: 	 * Sets which kind of query fragments are NOT allowed. Basically,
1: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
1: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
1: 	 *
1: 	 * @param reliability	bitmask of types of query fragments to be forbidden
1: 	 *						see the reliability bitmasks above
1: 	 *
1: 	 */
0: 	public void	setReliability(int reliability);
1: 
1: 	/**
1: 	 * Return the reliability requirements of this clause. See setReliability()
1: 	 * for a definition of clause reliability.
1: 	 *
1: 	 * @return a bitmask of which types of query fragments are to be forbidden
1: 	 */
0: 	public int getReliability();
1: 
1: 	/**
1: 	 * Get the compilation schema descriptor for this compilation context.
1: 	   Will be null if no default schema lookups have occured. Ie.
1: 	   the statement is independent of the current schema.
1: 	 * 
1: 	 * @return the compilation schema descirptor
1: 	 */
0: 	public SchemaDescriptor getCompilationSchema();
1: 
1: 	/**
1: 	 * Set the compilation schema descriptor for this compilation context.
1: 	 *
0: 	 * @param the compilation schema
1: 	 * 
1: 	 * @return the previous compilation schema descirptor
1: 	 */
0: 	public SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault);
1: 
1: 	/**
1: 	 * Get a StoreCostController for the given conglomerate.
1: 	 *
1: 	 * @param conglomerateNumber	The conglomerate for which to get a
1: 	 *								StoreCostController.
0: 	 * @param lcc					Current LanguageConnectionContext.
1: 	 *
1: 	 * @return	The appropriate StoreCostController.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public StoreCostController getStoreCostController(long conglomerateNumber,
0: 													  LanguageConnectionContext lcc)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Get a SortCostController.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public SortCostController getSortCostController() throws StandardException;
1: 
1: 	/**
1: 	 * Set the parameter list.
1: 	 *
1: 	 * @param parameterList	The parameter list.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setParameterList(Vector parameterList);
1: 
1: 	/**
1: 	 * Get the parameter list.
1: 	 *
1: 	 * @return	The parameter list.
1: 	 */
0: 	public Vector getParameterList();
1: 
1: 	/**
1: 	 * If callable statement uses ? = form
1: 	 *
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setReturnParameterFlag();
1: 
1: 	/**
1: 	 * Is the callable statement uses ? for return parameter.
1: 	 *
1: 	 * @return	true if ? = call else false
1: 	 */
0: 	public boolean getReturnParameterFlag();
1: 
1: 	/**
0: 	 * Get the array of DataTypeDescriptor representing the types of
0: 	 * the ? parameters.
1: 	 *
0: 	 * @return	The parameter descriptors
1: 	 */
1: 
0: 	public DataTypeDescriptor[] getParameterTypes();
1: 
1: 	/**
0: 	 * Get the next parameter number.
0: 	 * Useful when generating "associated" 
0: 	 * parameters.
1: 	 *
0: 	 * @return The next parameter number for the statement.
1: 	 */
0: 	public int getNextParameterNumber();
1: 
1: 	/**
0: 	 * Get the params stored vai setParams.
0: 	 * WARNING: nulls out the params value before
0: 	 * returning it, so a subsequent get will
0: 	 * get a null.
1: 	 *
0: 	 * @return the parameters
1: 	 */
0: 	public ParameterValueSet getParams();
1: 	
1: 	/**
1: 	 * Set params
1: 	 *
0: 	 * @param params the params
1: 	 */
0: 	public void setParams(ParameterValueSet params);
1: 
1: 	/**
1: 	 * Get the cursor info stored in the context.
1: 	 *
1: 	 * @return the cursor info
1: 	 */
0: 	public Object getCursorInfo();
1: 	
1: 	/**
1: 	 * Set params
1: 	 *
1: 	 * @param cursorInfo the cursor info
1: 	 */
0: 	public void setCursorInfo(Object cursorInfo);
1: 
1: 	/**
1: 	 * Set the isolation level for the scans in this query.
1: 	 *
1: 	 * @param isolationLevel	The isolation level to use.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setScanIsolationLevel(int isolationLevel);
1: 
1: 	/**
1: 	 * Get the isolation level for the scans in this query.
1: 	 *
1: 	 * @return	The isolation level for the scans in this query.
1: 	 */
0: 	public int getScanIsolationLevel();
1: 
1: 	/**
0: 	 * Set the isolation level on entry to this CC so that it can be restored on exit.
1: 	 *
0: 	 * @param isolationLevel	The isolation level on entry.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setEntryIsolationLevel(int isolationLevel);
1: 
1: 	/**
0: 	 * Get the entry isolation level from this CC.
1: 	 *
0: 	 * @return	The entry isolation level.
1: 	 */
0: 	public int getEntryIsolationLevel();
1: 
1: 	/**
1: 	 * Get the next equivalence class for equijoin clauses.
1: 	 *
1: 	 * @return The next equivalence class for equijoin clauses.
1: 	 */
0: 	public int getNextEquivalenceClass();
1: 
1: 	/**
1: 		Add a compile time warning.
1: 	*/
0: 	public void addWarning(SQLWarning warning);
1: 
1: 	/**
1: 		Get the chain of compile time warnings.
1: 	*/
0: 	public SQLWarning getWarnings();
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28c633d
/////////////////////////////////////////////////////////////////////////
1: 	 * @param privType	CREATE_SCHEMA_PRIV, MODIFY_SCHEMA_PRIV or DROP_SCHEMA_PRIV
0: 	public void addRequiredSchemaPriv(String schema, String aid, int privType);
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d4580ab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @return The number of ResultSets in the current statement.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param o object to add to the pool of saved objects
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param newDefault compilation schema
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e1987c6
/////////////////////////////////////////////////////////////////////////
1: 	 * @param schema	Schema name of the object that is being accessed
1: 	 * @param aid		Requested authorizationId for new schema
0: 	 * @param privType	Either CREATE_SCHEMA_PRIV or MODIFY_SCHEMA_PRIV
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
0: 	public void addRequiredSchemaPriv(String schema, String aid, boolean privType);
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
1: 	 * Add a schema privilege to the list of used privileges.
0: 	 *
0: 	 * @param schemaDescriptor
0: 	 */
0: 	public void addRequiredSchemaPriv( SchemaDescriptor sd);
0: 
0: 	/**
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Sets the current privilege type context and pushes the previous on onto a stack.
1: 	 * Column and table nodes do not know how they are
1: 	 * being used. Higher level nodes in the query tree do not know what is being
1: 	 * referenced. Keeping the context allows the two to come together.
0: 	 *
1: 	 * @param privType One of the privilege types in 
1: 	 *						org.apache.derby.iapi.sql.conn.Authorizer.
0: 	 */
0: 	public void pushCurrentPrivType( int privType);
0: 	
0: 	public void popCurrentPrivType();
0:     
0: 	/**
1: 	 * Add a column privilege to the list of used column privileges.
0: 	 *
1: 	 * @param column
0: 	 */
0: 	public void addRequiredColumnPriv( ColumnDescriptor column);
0: 
0: 	/**
1: 	 * Add a table or view privilege to the list of used table privileges.
0: 	 *
1: 	 * @param table
0: 	 */
0: 	public void addRequiredTablePriv( TableDescriptor table);
0: 
0: 	/**
1: 	 * Add a routine execute privilege to the list of used routine privileges.
0: 	 *
1: 	 * @param routine
0: 	 */
0: 	public void addRequiredRoutinePriv( AliasDescriptor routine);
0: 
0: 	/**
1: 	 * @return The list of required privileges.
0: 	 */
0: 	public List getRequiredPermissionsList();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.Dependent;
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.depend.ProviderList;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.SortCostController;
0: 
0: import java.util.Vector;
0: import java.sql.SQLWarning;
0: 
0: /**
0:  * CompilerContext stores the parser and type id factory to be used by
0:  * the compiler.  Stack compiler contexts when a new, local parser is needed
0:  * (if calling the compiler recursively from within the compiler,
0:  * for example).
0:  *
0:  * @author ames
0:  *
0:  * History:
0:  *	5/22/97 Moved getExternalInterfaceFactory() to LanguageConnectionContext
0:  *			because it had to be used at execution. - Jeff
0:  */
0: public interface CompilerContext extends Context
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	CONSTANTS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * this is the ID we expect compiler contexts
0: 	 * to be stored into a context manager under.
0: 	 */
0: 	String CONTEXT_ID = "CompilerContext";
0: 
0: 	// bit masks for query fragments which are potentially unreliable. these are used
0: 	// by setReliability() and checkReliability().
0: 
0: 	public	static	final	int			DATETIME_ILLEGAL			=	0x00000001;	
0: 	// NOTE: getCurrentConnection() is currently legal everywhere
0: 	public	static	final	int			CURRENT_CONNECTION_ILLEGAL	=	0x00000002;	
0: 	public	static	final	int			FUNCTION_CALL_ILLEGAL		=	0x00000004;	
0: 	public	static	final	int			UNNAMED_PARAMETER_ILLEGAL	=	0x00000008;	
0: 	public	static	final	int			DIAGNOSTICS_ILLEGAL			=	0x00000010;	
0: 	public	static	final	int			SUBQUERY_ILLEGAL			=	0x00000020;	
0: 	public	static	final	int			USER_ILLEGAL				=	0x00000040;	
0: 	public	static	final	int			COLUMN_REFERENCE_ILLEGAL	=	0x00000080;
0: 	public	static	final	int			IGNORE_MISSING_CLASSES		=	0x00000100;
0: 	public	static	final	int			SCHEMA_ILLEGAL				=	0x00000200;
0: 	public  static  final   int			INTERNAL_SQL_ILLEGAL		=	0x00000400;
0: 
0: 	/** Standard SQL is legal */
0: 	public	static	final	int			SQL_LEGAL					=	(INTERNAL_SQL_ILLEGAL);
0: 
0: 	/** Any SQL we support is legal */
0: 	public	static	final	int			INTERNAL_SQL_LEGAL			=	0;
0: 
0: 	public	static	final	int			CHECK_CONSTRAINT		= (
0: 		                                                                    DATETIME_ILLEGAL |
0: 																		    UNNAMED_PARAMETER_ILLEGAL |
0: 																		    DIAGNOSTICS_ILLEGAL |
0: 																		    SUBQUERY_ILLEGAL |
0: 																			USER_ILLEGAL |
0: 																			SCHEMA_ILLEGAL |
0: 																			INTERNAL_SQL_ILLEGAL
0: 																		  );
0: 
0: 	public	static	final	int			DEFAULT_RESTRICTION		= (
0: 		                                                                    SUBQUERY_ILLEGAL |
0: 																			UNNAMED_PARAMETER_ILLEGAL |
0: 																			COLUMN_REFERENCE_ILLEGAL |
0: 																			INTERNAL_SQL_ILLEGAL
0: 																			);
0: 
0: 
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	BEHAVIOR
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Get the Parser from this CompilerContext.
0: 	 *	 *
0: 	 * @return	The parser associated with this CompilerContext
0: 	 *
0: 	 */
0: 
0: 	Parser getParser();
0: 
0: 	/**
0: 	 * Get the NodeFactory from this CompilerContext.
0: 	 *
0: 	 * @return	The NodeFactory associated with this CompilerContext
0: 	 *
0: 	 */
0: 
0: 	NodeFactory getNodeFactory();
0: 
0: 	/**
0: 	 * Get the TypeCompilerFactory from this CompilerContext.
0: 	 *
0: 	 * @return	The TypeCompilerFactory associated with this CompilerContext
0: 	 *
0: 	 */
0: 	TypeCompilerFactory getTypeCompilerFactory();
0: 
0: 	/**
0: 		Return the class factory to use in this compilation.
0: 	*/
0: 	ClassFactory getClassFactory();
0: 
0: 	/**
0: 	 * Get the JavaFactory from this CompilerContext.
0: 	 *
0: 	 * @return	The JavaFactory associated with this CompilerContext
0: 	 *
0: 	 */
0: 
0: 	JavaFactory getJavaFactory();
0: 
0: 	/**
0: 	 * Get the current next column number (for generated column names)
0: 	 * from this CompilerContext.
0: 	 *
0: 	 * @return int	The next column number for the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNextColumnNumber();
0: 
0: 	/**
0: 	  *	Reset compiler context (as for instance, when we recycle a context for
0: 	  *	use by another compilation.
0: 	  */
0: 	void	resetContext();
0: 
0: 	/**
0: 	 * Get the current next table number from this CompilerContext.
0: 	 *
0: 	 * @return int	The next table number for the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNextTableNumber();
0: 
0: 	/**
0: 	 * Get the number of tables in the current statement from this CompilerContext.
0: 	 *
0: 	 * @return int	The number of tables in the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNumTables();
0: 
0: 	/**
0: 	 * Get the current next subquery number from this CompilerContext.
0: 	 *
0: 	 * @return int	The next subquery number for the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNextSubqueryNumber();
0: 
0: 	/**
0: 	 * Get the number of subquerys in the current statement from this CompilerContext.
0: 	 *
0: 	 * @return int	The number of subquerys in the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNumSubquerys();
0: 
0: 	/**
0: 	 * Get the current next ResultSet number from this CompilerContext.
0: 	 *
0: 	 * @return int	The next ResultSet number for the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNextResultSetNumber();
0: 
0: 	/**
0: 	 * Reset the next ResultSet number from this CompilerContext.
0: 	 *
0: 	 * @return None.
0: 	 *
0: 	 */
0: 
0: 	void resetNextResultSetNumber();
0: 
0: 	/**
0: 	 * Get the number of Results in the current statement from this CompilerContext.
0: 	 *
0: 	 * @return int	The number of ResultSets in the current statement.
0: 	 *
0: 	 */
0: 
0: 	int getNumResultSets();
0: 
0: 	/**
0: 	 * Get a unique Class name from this CompilerContext.
0: 	 * Ensures it is globally unique for this JVM.
0: 	 *
0: 	 * @return String	A unique-enough class name.
0: 	 *
0: 	 */
0: 
0: 	String getUniqueClassName();
0: 
0: 	/**
0: 	 * Get the current dependent from this CompilerContext.
0: 	 *
0: 	 * @return	The Dependent currently being compiled.
0: 	 *
0: 	 */
0: 
0: 	Dependent getCurrentDependent();
0: 
0: 	/**
0: 	 * Set the current dependent from this CompilerContext.
0: 	 * This should be called at the start of a compile to
0: 	 * register who has the dependencies needed for the compilation.
0: 	 *
0: 	 * @param d	The Dependent currently being compiled.
0: 	 *
0: 	 */
0: 
0: 	void setCurrentDependent(Dependent d);
0: 
0: 	/**
0: 	 * Get the current auxiliary provider list from this CompilerContext.
0: 	 *
0: 	 * @return	The current AuxiliaryProviderList.
0: 	 *
0: 	 */
0: 
0: 	ProviderList getCurrentAuxiliaryProviderList();
0: 
0: 	/**
0: 	 * Set the current auxiliary provider list for this CompilerContext.
0: 	 *
0: 	 * @param apl	The new current AuxiliaryProviderList.
0: 	 *
0: 	 */
0: 
0: 	void setCurrentAuxiliaryProviderList(ProviderList apl);
0: 
0: 	/**
0: 	 * Add a dependency for the current dependent.
0: 	 *
0: 	 * @param p	The Provider of the dependency.
0: 	 * @exception StandardException thrown on failure.
0: 	 *
0: 	 */
0: 	void createDependency(Provider p) throws StandardException;
0: 
0: 	/**
0: 	 * Add a dependency between two objects.
0: 	 *
0: 	 * @param d	The Dependent object.
0: 	 * @param p	The Provider of the dependency.
0: 	 * @exception StandardException thrown on failure.
0: 	 *
0: 	 */
0: 	public	void createDependency(Dependent d, Provider p) throws StandardException;
0: 
0: 	/**
0: 	 * Add an object to the pool that is created at compile time
0: 	 * and used at execution time.  Use the integer to reference it
0: 	 * in execution constructs.  Execution code will have to generate:
0: 	 *	<pre>
0: 	 *	(#objectType) (this.getPreparedStatement().getSavedObject(#int))
0: 	 *  <\pre>
0: 	 *
0: 	 * @param the object to add to the pool of saved objects
0: 	 * @return the entry # for the object
0: 	 */
0: 	int	addSavedObject(Object o);
0: 
0: 	/**
0: 	 *	Get the saved object pool (for putting into the prepared statement).
0: 	 *  This turns it into its storable form, an array of objects.
0: 	 *
0: 	 * @return the saved object pool.
0: 	 */
0: 	Object[] getSavedObjects(); 
0: 
0: 	/**
0: 	 *	Set the saved object pool (for putting into the prepared statement).
0: 	 *
0: 	 * @param objs	 The new saved objects
0: 	 */
0: 	public void setSavedObjects(Object[] objs); 
0: 
0: 	/**
0: 	 * Set the in use state for the compiler context.
0: 	 *
0: 	 * @param inUse	 The new inUse state for the compiler context.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 */
0: 	public void setInUse(boolean inUse);
0: 
0: 	/**
0: 	 * Return the in use state for the compiler context.
0: 	 *
0: 	 * @return boolean	The in use state for the compiler context.
0: 	 */
0: 	public boolean getInUse();
0: 
0: 	/**
0: 	 * Mark this CompilerContext as the first on the stack, so we can avoid
0: 	 * continually popping and pushing a CompilerContext.
0: 	 */
0: 	public void firstOnStack();
0: 
0: 	/**
0: 	 * Is this the first CompilerContext on the stack?
0: 	 */
0: 	public boolean isFirstOnStack();
0: 
0: 	/**
0: 	 * Sets which kind of query fragments are NOT allowed. Basically,
0: 	 * these are fragments which return unstable results. CHECK CONSTRAINTS
0: 	 * and CREATE PUBLICATION want to forbid certain kinds of fragments.
0: 	 *
0: 	 * @param reliability	bitmask of types of query fragments to be forbidden
0: 	 *						see the reliability bitmasks above
0: 	 *
0: 	 */
0: 	public void	setReliability(int reliability);
0: 
0: 	/**
0: 	 * Return the reliability requirements of this clause. See setReliability()
0: 	 * for a definition of clause reliability.
0: 	 *
0: 	 * @return a bitmask of which types of query fragments are to be forbidden
0: 	 */
0: 	public int getReliability();
0: 
0: 	/**
0: 	 * Get the compilation schema descriptor for this compilation context.
0: 	   Will be null if no default schema lookups have occured. Ie.
0: 	   the statement is independent of the current schema.
0: 	 * 
0: 	 * @return the compilation schema descirptor
0: 	 */
0: 	public SchemaDescriptor getCompilationSchema();
0: 
0: 	/**
0: 	 * Set the compilation schema descriptor for this compilation context.
0: 	 *
0: 	 * @param the compilation schema
0: 	 * 
0: 	 * @return the previous compilation schema descirptor
0: 	 */
0: 	public SchemaDescriptor setCompilationSchema(SchemaDescriptor newDefault);
0: 
0: 	/**
0: 	 * Get a StoreCostController for the given conglomerate.
0: 	 *
0: 	 * @param conglomerateNumber	The conglomerate for which to get a
0: 	 *								StoreCostController.
0: 	 * @param lcc					Current LanguageConnectionContext.
0: 	 *
0: 	 * @return	The appropriate StoreCostController.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public StoreCostController getStoreCostController(long conglomerateNumber,
0: 													  LanguageConnectionContext lcc)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Get a SortCostController.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public SortCostController getSortCostController() throws StandardException;
0: 
0: 	/**
0: 	 * Set the parameter list.
0: 	 *
0: 	 * @param parameterList	The parameter list.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setParameterList(Vector parameterList);
0: 
0: 	/**
0: 	 * Get the parameter list.
0: 	 *
0: 	 * @return	The parameter list.
0: 	 */
0: 	public Vector getParameterList();
0: 
0: 	/**
0: 	 * If callable statement uses ? = form
0: 	 *
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setReturnParameterFlag();
0: 
0: 	/**
0: 	 * Is the callable statement uses ? for return parameter.
0: 	 *
0: 	 * @return	true if ? = call else false
0: 	 */
0: 	public boolean getReturnParameterFlag();
0: 
0: 	/**
0: 	 * Get the array of DataTypeDescriptor representing the types of
0: 	 * the ? parameters.
0: 	 *
0: 	 * @return	The parameter descriptors
0: 	 */
0: 
0: 	public DataTypeDescriptor[] getParameterTypes();
0: 
0: 	/**
0: 	 * Get the next parameter number.
0: 	 * Useful when generating "associated" 
0: 	 * parameters.
0: 	 *
0: 	 * @return The next parameter number for the statement.
0: 	 */
0: 	public int getNextParameterNumber();
0: 
0: 	/**
0: 	 * Get the params stored vai setParams.
0: 	 * WARNING: nulls out the params value before
0: 	 * returning it, so a subsequent get will
0: 	 * get a null.
0: 	 *
0: 	 * @return the parameters
0: 	 */
0: 	public ParameterValueSet getParams();
0: 	
0: 	/**
0: 	 * Set params
0: 	 *
0: 	 * @param params the params
0: 	 */
0: 	public void setParams(ParameterValueSet params);
0: 
0: 	/**
0: 	 * Get the cursor info stored in the context.
0: 	 *
0: 	 * @return the cursor info
0: 	 */
0: 	public Object getCursorInfo();
0: 	
0: 	/**
0: 	 * Set params
0: 	 *
0: 	 * @param cursorInfo the cursor info
0: 	 */
0: 	public void setCursorInfo(Object cursorInfo);
0: 
0: 	/**
0: 	 * Set the isolation level for the scans in this query.
0: 	 *
0: 	 * @param isolationLevel	The isolation level to use.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setScanIsolationLevel(int isolationLevel);
0: 
0: 	/**
0: 	 * Get the isolation level for the scans in this query.
0: 	 *
0: 	 * @return	The isolation level for the scans in this query.
0: 	 */
0: 	public int getScanIsolationLevel();
0: 
0: 	/**
0: 	 * Set the isolation level on entry to this CC so that it can be restored on exit.
0: 	 *
0: 	 * @param isolationLevel	The isolation level on entry.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setEntryIsolationLevel(int isolationLevel);
0: 
0: 	/**
0: 	 * Get the entry isolation level from this CC.
0: 	 *
0: 	 * @return	The entry isolation level.
0: 	 */
0: 	public int getEntryIsolationLevel();
0: 
0: 	/**
0: 	 * Get the next equivalence class for equijoin clauses.
0: 	 *
0: 	 * @return The next equivalence class for equijoin clauses.
0: 	 */
0: 	public int getNextEquivalenceClass();
0: 
0: 	/**
0: 		Add a compile time warning.
0: 	*/
0: 	public void addWarning(SQLWarning warning);
0: 
0: 	/**
0: 		Get the chain of compile time warnings.
0: 	*/
0: 	public SQLWarning getWarnings();
0: }
============================================================================