1:ecd42d9: /*
9:ecd42d9: 
1:ecd42d9:    Derby - Class org.apache.derbyTesting.functionTests.tests.engine.ErrorStreamTest
1:ecd42d9: 
1:ecd42d9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ecd42d9:    contributor license agreements.  See the NOTICE file distributed with
1:ecd42d9:    this work for additional information regarding copyright ownership.
1:ecd42d9:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ecd42d9:    (the "License"); you may not use this file except in compliance with
1:ecd42d9:    the License.  You may obtain a copy of the License at
1:ecd42d9: 
1:ecd42d9:       http://www.apache.org/licenses/LICENSE-2.0
1:ecd42d9: 
1:ecd42d9:    Unless required by applicable law or agreed to in writing, software
1:ecd42d9:    distributed under the License is distributed on an "AS IS" BASIS,
1:ecd42d9:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ecd42d9:    See the License for the specific language governing permissions and
1:ecd42d9:    limitations under the License.
1:ecd42d9: 
1:ecd42d9:  */
1:ecd42d9: 
1:ecd42d9: package org.apache.derbyTesting.functionTests.tests.engine;
1:ecd42d9: 
1:ecd42d9: import java.io.File;
1:cda55ef: import java.io.FileInputStream;
1:ecd42d9: import java.io.FileNotFoundException;
1:ecd42d9: import java.io.FileOutputStream;
1:ecd42d9: import java.io.IOException;
1:ecd42d9: import java.io.OutputStream;
1:ecd42d9: import java.io.PrintStream;
1:ccf120c: import java.io.PrintWriter;
1:ecd42d9: import java.security.AccessController;
1:ecd42d9: import java.security.PrivilegedAction;
1:ecd42d9: import java.security.PrivilegedActionException;
1:ecd42d9: import java.security.PrivilegedExceptionAction;
1:ecd42d9: import java.sql.SQLException;
1:ecd42d9: import junit.framework.Test;
1:c393694: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:ecd42d9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:ccf120c: import org.apache.derbyTesting.junit.BaseTestCase;
1:ecd42d9: import org.apache.derbyTesting.junit.TestConfiguration;
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9: /**
1:ecd42d9:  * Tests related to the Derby error stream.
1:ecd42d9:  *
1:ecd42d9:  * This test has been converted to junit from the old harness tests
1:ecd42d9:  * logStream.java and errorStream.java. The testDefault method is based on
1:ecd42d9:  * logStream.java, the other test* methods are from errorStream.java.
1:ecd42d9:  */
1:ecd42d9: public class ErrorStreamTest extends BaseJDBCTestCase {
1:ecd42d9:     private static final String FILE_PROP   = "derby.stream.error.file";
1:ecd42d9:     private static final String METHOD_PROP = "derby.stream.error.method";
1:ecd42d9:     private static final String FIELD_PROP  = "derby.stream.error.field";
1:24d620a:     private static final String STYLE_PROP = "derby.stream.error.style";
1:ecd42d9: 
1:24d620a:     private static final String ROLLING_FILE_STYLE = "rollingFile";
1:24d620a:     private static final String ROLLING_FILE_COUNT_PROP = "derby.stream.error.rollingFile.count";
1:24d620a:     private static final String ROLLING_FILE_LIMIT_PROP = "derby.stream.error.rollingFile.limit";
1:24d620a:     private static final String ROLLING_FILE_PATTERN_PROP = "derby.stream.error.rollingFile.pattern";
1:24d620a:     private static final String DERBY_0_LOG = "derby-0.log";
1:24d620a:     private static final String DERBYLANGUAGELOG_QUERY_PLAN = "derby.language.logQueryPlan";
1:24d620a:     
1:ccf120c:     private static final String LOGFILESDIR = "logfilesdir";
1:ccf120c:     
1:ecd42d9:     /**
1:ecd42d9:      * runNo keeps track of which run we are in to generate unique (within a
1:ecd42d9:      * JUnit run) names for files that are used in the test. Has to be static.
1:ecd42d9:      */
1:ecd42d9:     private static int runNo = 0;
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * File used when FILE_PROP is set, it maps to file
1:ecd42d9:      * <database>-file-<runNo>.log
1:ecd42d9:      */
1:ecd42d9:     private File fileStreamFile;
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * See doc for getStream() below. Has to be static.
1:ecd42d9:      */
1:ecd42d9:     private static OutputStream methodStream;
1:ecd42d9:     private File methodStreamFile;
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Field fieldStream used by Derby when FIELD_PROP is set,
1:ecd42d9:      * so it needs to be public and static.
1:ecd42d9:      * Maps to file <database>-field-<runNo>.log
1:ecd42d9:      */
1:ecd42d9:     public static OutputStream fieldStream;
1:ecd42d9:     private File fieldStreamFile;
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Field errStream used as redirection for System.err to be able
1:ecd42d9:      * to checks its (non-)use in the scenarios. We first tried to
1:ecd42d9:      * merge it with System.out and let the harness compare outputs,
1:ecd42d9:      * but this gave intermittent merging differences, so abandoned.
1:ecd42d9:      * Maps to file <database>-err-<runNo>.log
1:ecd42d9:      */
1:ecd42d9:     private OutputStream errStream;
1:ecd42d9:     private File errStreamFile;
1:24d620a:     
1:ecd42d9:     public ErrorStreamTest(String name) {
1:ecd42d9:         super(name);
14:ecd42d9:     }
1:24d620a: 
1:ecd42d9:     public static Test suite() {
1:ecd42d9:         return TestConfiguration.embeddedSuite(ErrorStreamTest.class);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     public void setUp() throws Exception {
1:cda55ef:         bootDerby();
1:cda55ef:         // Shutdown engine so we can change properties for error stream
1:cda55ef:         getTestConfiguration().shutdownEngine();
1:ecd42d9:         openStreams();
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     public void tearDown() throws Exception {
1:ecd42d9:         resetProps();
1:ccf120c:         closeStreams();
1:ecd42d9:         nullFields();
1:cf6e807:         super.tearDown();
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test that the error stream file (derby.log) is created at database boot
1:ecd42d9:      * and not deleted when the database is shut down, but can be deleted
1:ecd42d9:      * afterwards.
1:ecd42d9:      */
1:ecd42d9:     public void testDefault() throws IOException, SQLException {
1:ecd42d9:         File derbyLog = new File(getSystemProperty("derby.system.home"),
1:ecd42d9:               "derby.log");
1:ecd42d9:         bootDerby();
1:ecd42d9:         assertIsExisting(derbyLog);
1:ecd42d9:         assertNotDirectory(derbyLog);
1:ecd42d9:         assertNotEmpty(derbyLog);
1:ecd42d9: 
1:ecd42d9:         println("Shutdown database");
1:ecd42d9:         getTestConfiguration().shutdownDatabase();
1:ecd42d9: 
1:ecd42d9:         assertIsExisting(derbyLog);
1:ecd42d9:         assertNotDirectory(derbyLog);
1:ecd42d9:         assertNotEmpty(derbyLog);
1:ecd42d9: 
1:ecd42d9:         println("Shutdown engine");
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:57964be: 
1:57964be:         boolean deleted = deleteFile(derbyLog);
1:57964be:         assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:24d620a:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.file property.
1:ecd42d9:      */
1:ecd42d9:     public void testFile() throws IOException, SQLException {
1:57964be:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotEmpty(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:65aba97: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.file property with wrong input.
1:ecd42d9:      */
1:ecd42d9:     public void testWrongFile() throws IOException, SQLException {
1:57964be:         setSystemProperty(FILE_PROP, getCanonicalPath(new File(
1:57964be:               new File(getSystemProperty("derby.system.home"), "foo"),
1:57964be:               makeStreamFilename("file")))); // erroneous path
1:65aba97: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertNotEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.method property.
1:ecd42d9:      */
1:ecd42d9:     public void testMethod() throws IOException, SQLException  {
1:ecd42d9:         setSystemProperty(METHOD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.getStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertNotEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.method property with wrong input.
1:ecd42d9:      */
1:ecd42d9:     public void testWrongMethod() throws IOException, SQLException {
1:ecd42d9:         setSystemProperty(METHOD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.nonExistingGetStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertNotEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.field property.
1:ecd42d9:      */
1:ecd42d9:     public void testField() throws IOException, SQLException {
1:ecd42d9:         setSystemProperty(FIELD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.fieldStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertNotEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test the derby.stream.error.field property with wrong input.
1:ecd42d9:      */
1:ecd42d9:     public void testWrongField() throws IOException, SQLException {
1:ecd42d9:         setSystemProperty(FIELD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.nonExistingFieldStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertNotEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test that the derby.stream.error.file property overrides the
1:ecd42d9:      * derby.stream.error.method property.
1:ecd42d9:      */
1:ecd42d9:     public void testFileOverMethod() throws IOException, SQLException {
1:57964be:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1:ecd42d9:         setSystemProperty(METHOD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.getStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotEmpty(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test that the derby.stream.error.file property overrides the
1:ecd42d9:      * derby.stream.error.field property.
1:ecd42d9:      */
1:ecd42d9:     public void testFileOverField() throws IOException, SQLException {
1:57964be:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1:ecd42d9:         setSystemProperty(FIELD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.fieldStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotEmpty(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test that the derby.stream.error.file property overrides the
1:ecd42d9:      * derby.stream.error.method and the derby.stream.error.field property.
1:ecd42d9:      */
1:ecd42d9:     public void testFileOverMethodAndField() throws IOException, SQLException {
1:57964be:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1:ecd42d9:         setSystemProperty(METHOD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.getStream");
1:ecd42d9:         setSystemProperty(FIELD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.fieldStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotEmpty(fileStreamFile);
1:ecd42d9:         assertIsEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:ecd42d9:      * Test that the derby.stream.error.field property overrides the
1:ecd42d9:      * derby.stream.error.method property.
1:ecd42d9:      */
1:ecd42d9:     public void testMethodOverField() throws IOException, SQLException {
1:ecd42d9: 
1:ecd42d9:         setSystemProperty(METHOD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.getStream");
1:ecd42d9:         setSystemProperty(FIELD_PROP,
1:ecd42d9:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:ecd42d9:               "ErrorStreamTest.fieldStream");
1:ecd42d9: 
1:ecd42d9:         bootDerby();
1:ecd42d9:         getTestConfiguration().shutdownEngine();
1:ecd42d9: 
1:ecd42d9:         closeStreams();
1:ecd42d9: 
1:ecd42d9:         assertNotExisting(fileStreamFile);
1:ecd42d9:         assertNotEmpty(methodStreamFile);
1:ecd42d9:         assertIsEmpty(fieldStreamFile);
1:ecd42d9:         assertIsEmpty(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     /**
1:24d620a:      * Test the derby.stream.error.style=rollingFile property.
1:24d620a:      */
1:24d620a:     public void testStyleRollingFile() throws IOException, SQLException  {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         
1:24d620a:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:24d620a:         
1:24d620a:         File derby0lck = new File(getSystemProperty("derby.system.home"),
1:24d620a:               "derby-0.log.lck");
1:24d620a:         
1:24d620a:         bootDerby();
1:24d620a:         
1:24d620a:         assertIsExisting(derby0log);
1:24d620a:         assertNotDirectory(derby0log);
1:24d620a:         assertNotEmpty(derby0log);
1:24d620a: 
1:24d620a:         assertIsExisting(derby0lck);
1:24d620a:         assertNotDirectory(derby0lck);
1:24d620a:         assertIsEmpty(derby0lck);
1:24d620a: 
1:24d620a:         println("Shutdown database");
1:24d620a:         getTestConfiguration().shutdownDatabase();
1:24d620a: 
1:24d620a:         assertIsExisting(derby0log);
1:24d620a:         assertNotDirectory(derby0log);
1:24d620a:         assertNotEmpty(derby0log);
1:24d620a: 
1:24d620a:         assertIsExisting(derby0lck);
1:24d620a:         assertNotDirectory(derby0lck);
1:24d620a:         assertIsEmpty(derby0lck);
1:24d620a: 
1:24d620a:         println("Shutdown engine");
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a: 
1:24d620a:         assertNotExisting(derby0lck);
1:1850f64: 
1:65aba97:         boolean deleted = deleteFile(derby0log);
1:ccf120c:         assertTrue("File " + derby0log + " could not be deleted", deleted);
1:65aba97:     }
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test the derby.stream.error.style property with wrong style.
1:24d620a:      */
1:24d620a:     public void testWrongStyle() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, "unknownStyle");
1:24d620a:         
1:24d620a:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:24d620a:         
1:24d620a:         bootDerby();
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a: 
1:24d620a:         closeStreams();
1:24d620a: 
1:24d620a:         assertNotExisting(derby0log);
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertNotEmpty(errStreamFile);
1:24d620a:     }
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test the derby.stream.error.style=rollingFile property with default config
1:24d620a:      */
1:24d620a:     public void testDefaultRollingDefaultConfig() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         
1:24d620a:         // This is set so that we can get enough output into the log files
1:24d620a:         setSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN, "true");
1:24d620a:                 
1:24d620a:         bootDerby();
1:24d620a:         
2:24d620a:         // This will generate enough output to roll through all 10 log files
1:24d620a:         for (int i = 0; i < 3699; i++) {
1:24d620a:             checkAllConsistency(getConnection());
1:24d620a:         }
1:24d620a:         // Make sure we remove the system property that is logging the query plan
1:24d620a:         removeSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN);
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a:         
1:24d620a:         closeStreams();
1:24d620a:         
1:24d620a:         // There should be derb-0.log .. derby-9.log files present
1:24d620a:         for (int i = 0; i < 10; i++) {
1:24d620a:             File derbyLog = new File(getSystemProperty("derby.system.home"),
1:24d620a:                 "derby-" + i + ".log");
1:24d620a:             assertIsExisting(derbyLog);
1:24d620a:             assertNotDirectory(derbyLog);
1:24d620a:             assertNotEmpty(derbyLog);
1:24d620a:             
1:24d620a:             // Check the last log file to make sure that it has the default
1:24d620a:             //  limit 
1:24d620a:             if (i == 9) {
1:24d620a:                 assertFileSize(derbyLog, 1024000);
1:24d620a:             }
1:24d620a:             
1:24d620a:             boolean deleted = deleteFile(derbyLog);
1:24d620a:             assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:24d620a:         }
1:24d620a:         
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertIsEmpty(errStreamFile);
1:24d620a:     }   
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test the derby.stream.error.style=rollingFile property with user configuration.
1:24d620a:      */
1:24d620a:     public void testDefaultRollingUserConfig() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         setSystemProperty(ROLLING_FILE_PATTERN_PROP, "%d/db-%g.log");
1:24d620a:         setSystemProperty(ROLLING_FILE_COUNT_PROP, "3");
1:24d620a:         setSystemProperty(ROLLING_FILE_LIMIT_PROP, "10000");
1:24d620a:         
1:24d620a:         // This is set so that we can get enough output into the log files
1:24d620a:         setSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN, "true");
1:24d620a:                 
1:24d620a:         bootDerby();
1:24d620a:         
1:1850f64:         // This will generate enough output to roll through all 3 log files
1:24d620a:         for (int i = 0; i < 10; i++) {
1:24d620a:             checkAllConsistency(getConnection());
1:24d620a:         }
1:24d620a:         // Make sure we remove the system property that is logging the query plan
1:24d620a:         removeSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN);
1:24d620a:         removeSystemProperty(ROLLING_FILE_PATTERN_PROP);
1:24d620a:         removeSystemProperty(ROLLING_FILE_COUNT_PROP);
1:24d620a:         removeSystemProperty(ROLLING_FILE_LIMIT_PROP);
1:24d620a: 
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a:         
1:24d620a:         closeStreams();
1:24d620a:         
1:24d620a:         // There should be derb-0.log .. derby-3.log files present
1:24d620a:         for (int i = 0; i < 3; i++) {
1:24d620a:             File derbyLog = new File(getSystemProperty("derby.system.home"),
1:24d620a:                 "db-" + i + ".log");
1:24d620a:             assertIsExisting(derbyLog);
1:24d620a:             assertNotDirectory(derbyLog);
1:24d620a:             assertNotEmpty(derbyLog);
1:24d620a:             
1:24d620a:             // Check the last log file to make sure that it has the correct
1:24d620a:             //  limit 
1:24d620a:             if (i == 2) {
1:24d620a:                 assertFileSize(derbyLog, 10000);
1:24d620a:             }
1:1850f64: 
1:24d620a:             boolean deleted = deleteFile(derbyLog);
1:24d620a:             assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:24d620a:         }
1:24d620a:         
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertIsEmpty(errStreamFile);
1:24d620a:     }   
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test that the derby.stream.error.style property overrides the
1:24d620a:      * derby.stream.error.file property.
1:24d620a:      */
1:24d620a:     public void testRollingFileStyleOverFile() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         
1:24d620a:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:24d620a:         
1:24d620a:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1:24d620a: 
1:24d620a:         bootDerby();
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a: 
1:24d620a:         closeStreams();
1:24d620a: 
1:24d620a:         assertNotEmpty(derby0log);
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertIsEmpty(errStreamFile);
1:24d620a:     }
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test that the derby.stream.error.style property overrides the
1:24d620a:      * derby.stream.error.method property.
1:24d620a:      */
1:24d620a:     public void testRollingFileStyleOverMethod() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         
1:24d620a:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:24d620a:         
1:24d620a:         setSystemProperty(METHOD_PROP,
1:24d620a:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:24d620a:               "ErrorStreamTest.getStream");
1:24d620a: 
1:24d620a:         bootDerby();
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a: 
1:24d620a:         closeStreams();
1:24d620a: 
1:24d620a:         assertNotEmpty(derby0log);
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertIsEmpty(errStreamFile);
1:24d620a: 
1:65aba97:         boolean deleted = deleteFile(derby0log);
1:65aba97:         assertTrue("File " + derby0log + " could not be deleted", deleted);    
1:24d620a:      }
1:24d620a: 
1:24d620a:     /**
1:24d620a:      * Test that the derby.stream.error.style property overrides the
1:24d620a:      * derby.stream.error.field property.
1:24d620a:      */
1:24d620a:     public void testRollingFileStyleOverField() throws IOException, SQLException {
1:24d620a:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:24d620a:         
1:24d620a:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:24d620a:         
1:24d620a:         setSystemProperty(FIELD_PROP,
1:24d620a:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:24d620a:               "ErrorStreamTest.fieldStream");
1:24d620a: 
1:24d620a:         bootDerby();
1:24d620a:         getTestConfiguration().shutdownEngine();
1:24d620a: 
1:24d620a:         closeStreams();
1:24d620a: 
1:24d620a:         assertNotEmpty(derby0log);
1:24d620a:         assertNotExisting(fileStreamFile);
1:24d620a:         assertIsEmpty(methodStreamFile);
1:24d620a:         assertIsEmpty(fieldStreamFile);
1:24d620a:         assertIsEmpty(errStreamFile);
1:24d620a: 
1:24d620a:         boolean deleted = deleteFile(derby0log);
1:65aba97:         assertTrue("File " + derby0log + " could not be deleted", deleted);
1:24d620a:     }
1:ecd42d9: 
1:24d620a:     /**
1:ecd42d9:      * Method getStream used by Derby when derby.stream.error.method
1:ecd42d9:      * is set.  Maps to file <database>-method-<runNo>.log
1:ecd42d9:      * This method has to be static.
1:ecd42d9:      */
1:ecd42d9:     public static OutputStream getStream() {
1:ecd42d9:         return methodStream;
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private static String makeStreamFilename(String type) {
1:ecd42d9:         return type + "-" + runNo + ".log";
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private void openStreams() throws IOException{
1:ecd42d9:         String systemHome = getSystemProperty("derby.system.home");
1:ccf120c:         String logFilesHome=systemHome + File.separatorChar + LOGFILESDIR;
1:ecd42d9:         makeDirIfNotExisting(systemHome);
1:ccf120c:         makeDirIfNotExisting(logFilesHome);
1:ecd42d9: 
1:ecd42d9:         runNo += 1;
1:ecd42d9: 
1:ccf120c:         methodStreamFile = new File(logFilesHome, makeStreamFilename("method"));
1:ccf120c:         fileStreamFile = new File(logFilesHome, makeStreamFilename("file"));
1:ccf120c:         fieldStreamFile = new File(logFilesHome, makeStreamFilename("field"));
1:ccf120c:         errStreamFile = new File(logFilesHome, makeStreamFilename("err"));
1:ecd42d9: 
1:ecd42d9:         methodStream = newFileOutputStream(methodStreamFile);
1:ecd42d9:         fieldStream = newFileOutputStream(fieldStreamFile);
1:ecd42d9:         errStream = newFileOutputStream(errStreamFile);
1:ecd42d9: 
1:ecd42d9:         setSystemErr(new PrintStream(errStream));
1:ecd42d9: 
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9:     private void closeStreams() throws IOException {
5:ecd42d9:         try {
1:ecd42d9:             methodStream.close();
1:ecd42d9:             fieldStream.close();
1:ecd42d9:             errStream.close();
1:ecd42d9: 
1:ecd42d9:             // reset until next scenario, no expected output
1:ecd42d9:             setSystemErr(System.out);
1:ecd42d9:         } catch (IOException e) {
1:ecd42d9:             println("Could not close stream files");
1:ecd42d9:             throw e;
1:57964be:         }
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private static void assertNotDirectory(final File f) throws IOException {
1:ecd42d9:         try {
1:c393694:             AccessController.doPrivileged(
1:c393694:                     new PrivilegedExceptionAction<Void>() {
1:c393694:                 public Void run() throws IOException {
1:ecd42d9:                     assertFalse("assertNotDirectory failed: " +
2:ecd42d9:                           f.getCanonicalPath(), f.isDirectory());
6:ecd42d9:                     return null;
1:ecd42d9:                 }
7:ecd42d9:             });
5:ecd42d9:         } catch (PrivilegedActionException e) {
6:ecd42d9:             // e.getException() should be an instance of IOException.
5:ecd42d9:             throw (IOException) e.getException();
1:ecd42d9:         }
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private static void assertIsEmpty(final File f) throws IOException {
1:c393694:         String path = getCanonicalPath(f);
1:c393694:         assertTrue(path + " doesn't exist",
1:c393694:                 PrivilegedFileOpsForTests.exists(f));
1:c393694:         assertEquals(path + " is not empty",
1:c393694:                 0, PrivilegedFileOpsForTests.length(f));
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9:     private static void assertNotEmpty(final File f) throws IOException {
1:ecd42d9:         try {
1:c393694:             AccessController.doPrivileged(
1:c393694:                     new PrivilegedExceptionAction<Void>() {
1:c393694:                 public Void run() throws IOException {
1:cda55ef:                     assertTrue("assertNotEmpty failed: " + f.getCanonicalPath()
1:cda55ef:                           + " does not exist.", f.exists());
1:cda55ef:                     FileInputStream fis = new FileInputStream(f);
1:cda55ef:                     int result = fis.read();
1:cda55ef:                     fis.close();
1:cda55ef:                     assertTrue("assertNotEmpty failed: " + f.getCanonicalPath()
1:cda55ef:                           + " is empty.", -1 != result);
1:ecd42d9:                     return null;
1:ecd42d9:                 }
1:ecd42d9:             });
1:ecd42d9:         } catch (PrivilegedActionException e) {
1:ecd42d9:             // e.getException() should be an instance of IOException.
1:ecd42d9:             throw (IOException) e.getException();
1:ecd42d9:         }
1:ecd42d9:     }
1:ecd42d9: 
1:24d620a:     private static void assertFileSize(final File f, final int size) throws IOException {
1:24d620a:         try {
1:24d620a:             AccessController.doPrivileged(
1:24d620a:                     new PrivilegedExceptionAction<Void>() {
1:24d620a:                 public Void run() throws IOException {
1:24d620a:                     assertEquals("assertFileEize failed for file " + f.getName() + ": ", size, f.length());
1:24d620a:                     return null;
1:24d620a:                 }
1:24d620a:             });
1:24d620a:         } catch (PrivilegedActionException e) {
1:24d620a:             // e.getException() should be an instance of IOException.
1:24d620a:             throw (IOException) e.getException();
1:24d620a:         }
1:24d620a:     }
1:24d620a: 
1:ecd42d9:     private static void assertIsExisting(final File f) throws IOException {
1:c393694:         String path = getCanonicalPath(f);
1:c393694:         assertTrue(path + " doesn't exist",
1:c393694:                 PrivilegedFileOpsForTests.exists(f));
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9:     private static void assertNotExisting(final File f) throws IOException {
1:c393694:         String path = getCanonicalPath(f);
1:c393694:         assertFalse(path + " exists",
1:c393694:                 PrivilegedFileOpsForTests.exists(f));
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private static boolean deleteFile(final File f) {
1:c393694:         return PrivilegedFileOpsForTests.delete(f);
1:ecd42d9:     }
1:ecd42d9: 
1:57964be:     private static String getCanonicalPath(final File f) throws IOException {
1:57964be:         try {
1:c393694:             return AccessController.doPrivileged(
1:c393694:                   new PrivilegedExceptionAction<String>() {
1:c393694:                 public String run() throws IOException {
1:57964be:                     return f.getCanonicalPath();
1:57964be:                 }
1:57964be:             });
1:57964be:         } catch (PrivilegedActionException e) {
1:57964be:             // e.getException() should be an instance of IOException.
1:57964be:             throw (IOException) e.getException();
1:57964be:         }
1:ecd42d9:     }
1:57964be: 
1:ecd42d9:     private static void makeDirIfNotExisting(final String filename) {
1:c393694:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:c393694:             public Void run() {
1:ecd42d9:                 File f = new File(filename);
1:ecd42d9:                 if(!f.exists()) {
1:ecd42d9:                     f.mkdir();
1:ecd42d9:                 }
1:ecd42d9:                 return null;
1:ecd42d9:             }
1:ecd42d9:         });
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private static FileOutputStream newFileOutputStream(final File f)
1:ecd42d9:     throws FileNotFoundException {
1:ecd42d9:         try {
1:c393694:             return AccessController.doPrivileged(
1:c393694:                   new PrivilegedExceptionAction<FileOutputStream>() {
1:c393694:                 public FileOutputStream run() throws FileNotFoundException {
1:ecd42d9:                     return new FileOutputStream(f);
1:ecd42d9:                 }
1:ecd42d9:             });
1:ecd42d9:             } catch (PrivilegedActionException e) {
1:57964be:                 // e.getException() should be a FileNotFoundException.
1:ecd42d9:                 throw (FileNotFoundException) e.getException();
1:ecd42d9:             }
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9:     private static void resetProps() {
1:ecd42d9:         removeSystemProperty(FILE_PROP);
1:ecd42d9:         removeSystemProperty(METHOD_PROP);
1:ecd42d9:         removeSystemProperty(FIELD_PROP);
1:24d620a:         removeSystemProperty(STYLE_PROP);        
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private void deleteStreamFiles() {
1:ecd42d9:         deleteFile(fileStreamFile);
1:ecd42d9:         deleteFile(methodStreamFile);
1:ecd42d9:         deleteFile(fieldStreamFile);
1:ecd42d9:         deleteFile(errStreamFile);
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9:     private void nullFields() {
1:ecd42d9:         // Nulling fields to let objects be gc'd
1:ecd42d9:         fileStreamFile = null;
1:ecd42d9:         methodStreamFile = null;
1:ecd42d9:         fieldStreamFile = null;
1:ecd42d9:         errStreamFile = null;
1:ecd42d9:         methodStream = null;
1:ecd42d9:         fieldStream = null;
1:ecd42d9:         errStream = null;
1:ecd42d9:     }
1:ecd42d9: 
1:ecd42d9: 
1:ecd42d9:     private void bootDerby() throws SQLException {
1:ecd42d9:         /* Connect to the database to make sure that the
1:ecd42d9:          * JDBC Driver class is loaded
1:ecd42d9:          */
1:ecd42d9:         getConnection();
1:ecd42d9:         getConnection().close();
1:ecd42d9:     }
1:ecd42d9: 
1:ccf120c:     /**
1:ccf120c:      * <p>
1:ccf120c:      * Run the bare test, including {@code setUp()} and {@code tearDown()}.
1:ccf120c:      * </p>
1:ccf120c:      *
1:ccf120c:      * <p>
1:ccf120c:      * This is overriding BaseJDBCTestCase.runBareOverridable and thereby
1:ccf120c:      * BaseJDBCTestCase.runBare(), so we can copy any log files created by this
1:ccf120c:      * test if any of the fixtures fail. 
1:ccf120c:      * </p>
1:ccf120c:      */
1:ccf120c:     public void runBareOverridable() throws Throwable {
1:ccf120c:         PrintStream out = System.out;
1:ccf120c:         TestConfiguration config = getTestConfiguration();
1:ccf120c:         boolean stopAfterFirstFail = config.stopAfterFirstFail();
1:ccf120c:         try {
1:ccf120c:             super.runBareOverridable();   
1:ccf120c:         }
1:ccf120c:         // To log the exception to file, copy the derby.log file and copy
1:ccf120c:         // the database of the failed test.
1:ccf120c:         catch (Throwable running) {
1:ccf120c:             PrintWriter stackOut = null;
1:ccf120c:             try{
1:1850f64:                 copyFileToFail(LOGFILESDIR);
1:ccf120c:                 nullFields();
1:1850f64:                 deleteFile(LOGFILESDIR);
1:1850f64:                 // copy files from testStyleRollingFile:
1:1850f64:                 copyFileToFail("derby-0.log");
1:1850f64:                 copyFileToFail("derby-0.log.lck");
1:1850f64:                 // copy files from the testDefaultRollingUserConfig test
1:1850f64:                 for (int i = 0; i < 3; i++) {
1:1850f64:                     copyFileToFail("db-" + i + ".log");
1:1850f64:                     deleteFile("db-" + i + ".log");
1:1850f64:                 }
1:ccf120c:            }
1:ccf120c:             catch (IOException ioe) {
1:ccf120c:                 // We need to throw the original exception so if there
1:ccf120c:                 // is an exception saving the db or derby.log we will print it
1:ccf120c:                 // and additionally try to log it to file.
1:ccf120c:                 BaseTestCase.printStackTrace(ioe);
1:ccf120c:                 if (stackOut != null) {
1:ccf120c:                     stackOut.println("Copying derby.log or database failed:");
1:ccf120c:                     ioe.printStackTrace(stackOut);
1:ccf120c:                     stackOut.println();
1:ccf120c:                 }
1:ccf120c:             }
1:ccf120c:             finally {
1:ccf120c:                 if (stackOut != null) {
1:ccf120c:                     stackOut.close();
1:ccf120c:                 }
1:ccf120c:                 if (stopAfterFirstFail) {
1:ccf120c:                     // if run with -Dderby.tests.stopAfterFirstFail=true
1:ccf120c:                     // exit after reporting failure. Useful for debugging
1:ccf120c:                     // cascading failures or errors that lead to hang.
1:ccf120c:                     running.printStackTrace(out);
1:ccf120c:                     System.exit(1);
1:ccf120c:                 }
1:ccf120c:                 else
1:ccf120c:                     throw running;
1:ccf120c:             }
1:ccf120c:         }
1:ccf120c:         finally{
1:1850f64:             // attempt to clean up
1:1850f64:             // first ensure we have the engine shutdown, or some
1:1850f64:             // files cannot be cleaned up.
1:1850f64:             getTestConfiguration().shutdownEngine();
2:ccf120c:             File origLogFilesDir = new File(DEFAULT_DB_DIR, LOGFILESDIR);
1:ccf120c:             nullFields();
2:ccf120c:             removeDirectory(origLogFilesDir);
1:1850f64:             deleteFile("derby-0.log.lck");
1:1850f64:             deleteFile("derby-0.log");
1:1850f64:             deleteFile("derby.log");
1:ccf120c:         }
1:ccf120c:     }
1:1850f64:     
1:1850f64:     private void copyFileToFail(String origFileName) throws IOException {
1:1850f64:         String failPath = PrivilegedFileOpsForTests.getAbsolutePath(getFailureFolder());
1:1850f64:         File origFile = new File (DEFAULT_DB_DIR, origFileName); 
1:1850f64:         File newFile = new File (failPath, origFileName);
1:1850f64:         PrivilegedFileOpsForTests.copy(origFile,newFile);
1:1850f64:     }
1:1850f64:     
1:1850f64:     // delete a file - used in cleanup when we don't care about the result
1:1850f64:     private void deleteFile(String origFileName) throws IOException {
1:1850f64:         File origFile = new File (DEFAULT_DB_DIR, origFileName);
1:1850f64:         PrivilegedFileOpsForTests.delete(origFile);                
1:1850f64:     }
1:ecd42d9: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:1850f64
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         // This will generate enough output to roll through all 3 log files
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 copyFileToFail(LOGFILESDIR);
1:                 deleteFile(LOGFILESDIR);
1:                 // copy files from testStyleRollingFile:
1:                 copyFileToFail("derby-0.log");
1:                 copyFileToFail("derby-0.log.lck");
1:                 // copy files from the testDefaultRollingUserConfig test
1:                 for (int i = 0; i < 3; i++) {
1:                     copyFileToFail("db-" + i + ".log");
1:                     deleteFile("db-" + i + ".log");
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             // attempt to clean up
1:             // first ensure we have the engine shutdown, or some
1:             // files cannot be cleaned up.
1:             getTestConfiguration().shutdownEngine();
1:             deleteFile("derby-0.log.lck");
1:             deleteFile("derby-0.log");
1:             deleteFile("derby.log");
1:     
1:     private void copyFileToFail(String origFileName) throws IOException {
1:         String failPath = PrivilegedFileOpsForTests.getAbsolutePath(getFailureFolder());
1:         File origFile = new File (DEFAULT_DB_DIR, origFileName); 
1:         File newFile = new File (failPath, origFileName);
1:         PrivilegedFileOpsForTests.copy(origFile,newFile);
1:     }
1:     
1:     // delete a file - used in cleanup when we don't care about the result
1:     private void deleteFile(String origFileName) throws IOException {
1:         File origFile = new File (DEFAULT_DB_DIR, origFileName);
1:         PrivilegedFileOpsForTests.delete(origFile);                
1:     }
commit:ccf120c
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestCase;
0: import org.apache.derbyTesting.junit.Utilities;
/////////////////////////////////////////////////////////////////////////
1:     private static final String LOGFILESDIR = "logfilesdir";
1:     
/////////////////////////////////////////////////////////////////////////
1:         closeStreams();
/////////////////////////////////////////////////////////////////////////
1:         assertTrue("File " + derby0log + " could not be deleted", deleted);
/////////////////////////////////////////////////////////////////////////
1:         String logFilesHome=systemHome + File.separatorChar + LOGFILESDIR;
1:         makeDirIfNotExisting(logFilesHome);
1:         methodStreamFile = new File(logFilesHome, makeStreamFilename("method"));
1:         fileStreamFile = new File(logFilesHome, makeStreamFilename("file"));
1:         fieldStreamFile = new File(logFilesHome, makeStreamFilename("field"));
1:         errStreamFile = new File(logFilesHome, makeStreamFilename("err"));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Run the bare test, including {@code setUp()} and {@code tearDown()}.
1:      * </p>
1:      *
1:      * <p>
1:      * This is overriding BaseJDBCTestCase.runBareOverridable and thereby
1:      * BaseJDBCTestCase.runBare(), so we can copy any log files created by this
1:      * test if any of the fixtures fail. 
1:      * </p>
1:      */
1:     public void runBareOverridable() throws Throwable {
1:         PrintStream out = System.out;
1:         TestConfiguration config = getTestConfiguration();
1:         boolean stopAfterFirstFail = config.stopAfterFirstFail();
1:         try {
1:             super.runBareOverridable();   
1:         }
1:         // To log the exception to file, copy the derby.log file and copy
1:         // the database of the failed test.
1:         catch (Throwable running) {
1:             PrintWriter stackOut = null;
1:             try{
0:                 String failPath = PrivilegedFileOpsForTests.getAbsolutePath(getFailureFolder());
0:                 // Copy the logfiles dir
1:                 File origLogFilesDir = new File(DEFAULT_DB_DIR, LOGFILESDIR);
0:                 File newLogFilesDir = new File (failPath, LOGFILESDIR);
0:                 PrivilegedFileOpsForTests.copy(origLogFilesDir,newLogFilesDir);
1:                 nullFields();
1:                 removeDirectory(origLogFilesDir);
1:            }
1:             catch (IOException ioe) {
1:                 // We need to throw the original exception so if there
1:                 // is an exception saving the db or derby.log we will print it
1:                 // and additionally try to log it to file.
1:                 BaseTestCase.printStackTrace(ioe);
1:                 if (stackOut != null) {
1:                     stackOut.println("Copying derby.log or database failed:");
1:                     ioe.printStackTrace(stackOut);
1:                     stackOut.println();
1:                 }
1:             }
1:             finally {
1:                 if (stackOut != null) {
1:                     stackOut.close();
1:                 }
1:                 if (stopAfterFirstFail) {
1:                     // if run with -Dderby.tests.stopAfterFirstFail=true
1:                     // exit after reporting failure. Useful for debugging
1:                     // cascading failures or errors that lead to hang.
1:                     running.printStackTrace(out);
1:                     System.exit(1);
1:                 }
1:                 else
1:                     throw running;
1:             }
1:         }
1:         finally{
1:             File origLogFilesDir = new File(DEFAULT_DB_DIR, LOGFILESDIR);
1:             nullFields();
1:             removeDirectory(origLogFilesDir);
1:         }
1:     }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:65aba97
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean deleted = deleteFile(derby0log);
1:         assertTrue("File " + derby0log + " could not be deleted", deleted);    
1:      }
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean deleted = deleteFile(derby0log);
1:         assertTrue("File " + derby0log + " could not be deleted", deleted);    
commit:24d620a
/////////////////////////////////////////////////////////////////////////
1:     private static final String STYLE_PROP = "derby.stream.error.style";
1:     private static final String ROLLING_FILE_STYLE = "rollingFile";
1:     private static final String ROLLING_FILE_COUNT_PROP = "derby.stream.error.rollingFile.count";
1:     private static final String ROLLING_FILE_LIMIT_PROP = "derby.stream.error.rollingFile.limit";
1:     private static final String ROLLING_FILE_PATTERN_PROP = "derby.stream.error.rollingFile.pattern";
1:     private static final String DERBY_0_LOG = "derby-0.log";
1:     private static final String DERBYLANGUAGELOG_QUERY_PLAN = "derby.language.logQueryPlan";
1:     
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:      * Test the derby.stream.error.style=rollingFile property.
1:      */
1:     public void testStyleRollingFile() throws IOException, SQLException  {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         
1:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:         
1:         File derby0lck = new File(getSystemProperty("derby.system.home"),
1:               "derby-0.log.lck");
1:         
1:         bootDerby();
1:         
1:         assertIsExisting(derby0log);
1:         assertNotDirectory(derby0log);
1:         assertNotEmpty(derby0log);
1: 
1:         assertIsExisting(derby0lck);
1:         assertNotDirectory(derby0lck);
1:         assertIsEmpty(derby0lck);
1: 
1:         println("Shutdown database");
1:         getTestConfiguration().shutdownDatabase();
1: 
1:         assertIsExisting(derby0log);
1:         assertNotDirectory(derby0log);
1:         assertNotEmpty(derby0log);
1: 
1:         assertIsExisting(derby0lck);
1:         assertNotDirectory(derby0lck);
1:         assertIsEmpty(derby0lck);
1: 
1:         println("Shutdown engine");
1:         getTestConfiguration().shutdownEngine();
1: 
1:         assertNotExisting(derby0lck);
1:         
1:         boolean deleted = deleteFile(derby0log);
0:         assertTrue("File " + derby0log + " could not be deleted", deleted);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.style property with wrong style.
1:      */
1:     public void testWrongStyle() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, "unknownStyle");
1:         
1:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:         
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(derby0log);
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertNotEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.style=rollingFile property with default config
1:      */
1:     public void testDefaultRollingDefaultConfig() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         
1:         // This is set so that we can get enough output into the log files
1:         setSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN, "true");
1:                 
1:         bootDerby();
1:         
1:         // This will generate enough output to roll through all 10 log files
1:         for (int i = 0; i < 3699; i++) {
1:             checkAllConsistency(getConnection());
1:         }
1:         // Make sure we remove the system property that is logging the query plan
1:         removeSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN);
1:         getTestConfiguration().shutdownEngine();
1:         
1:         closeStreams();
1:         
1:         // There should be derb-0.log .. derby-9.log files present
1:         for (int i = 0; i < 10; i++) {
1:             File derbyLog = new File(getSystemProperty("derby.system.home"),
1:                 "derby-" + i + ".log");
1:             assertIsExisting(derbyLog);
1:             assertNotDirectory(derbyLog);
1:             assertNotEmpty(derbyLog);
1:             
1:             // Check the last log file to make sure that it has the default
1:             //  limit 
1:             if (i == 9) {
1:                 assertFileSize(derbyLog, 1024000);
1:             }
1:             
1:             boolean deleted = deleteFile(derbyLog);
1:             assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:         }
1:         
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }   
1: 
1:     /**
1:      * Test the derby.stream.error.style=rollingFile property with user configuration.
1:      */
1:     public void testDefaultRollingUserConfig() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         setSystemProperty(ROLLING_FILE_PATTERN_PROP, "%d/db-%g.log");
1:         setSystemProperty(ROLLING_FILE_COUNT_PROP, "3");
1:         setSystemProperty(ROLLING_FILE_LIMIT_PROP, "10000");
1:         
1:         // This is set so that we can get enough output into the log files
1:         setSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN, "true");
1:                 
1:         bootDerby();
1:         
1:         // This will generate enough output to roll through all 10 log files
1:         for (int i = 0; i < 10; i++) {
1:             checkAllConsistency(getConnection());
1:         }
1:         // Make sure we remove the system property that is logging the query plan
1:         removeSystemProperty(DERBYLANGUAGELOG_QUERY_PLAN);
1:         removeSystemProperty(ROLLING_FILE_PATTERN_PROP);
1:         removeSystemProperty(ROLLING_FILE_COUNT_PROP);
1:         removeSystemProperty(ROLLING_FILE_LIMIT_PROP);
1: 
1:         getTestConfiguration().shutdownEngine();
1:         
1:         closeStreams();
1:         
1:         // There should be derb-0.log .. derby-3.log files present
1:         for (int i = 0; i < 3; i++) {
1:             File derbyLog = new File(getSystemProperty("derby.system.home"),
1:                 "db-" + i + ".log");
1:             assertIsExisting(derbyLog);
1:             assertNotDirectory(derbyLog);
1:             assertNotEmpty(derbyLog);
1:             
1:             // Check the last log file to make sure that it has the correct
1:             //  limit 
1:             if (i == 2) {
1:                 assertFileSize(derbyLog, 10000);
1:             }
1:             
1:             boolean deleted = deleteFile(derbyLog);
1:             assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:         }
1:         
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }   
1: 
1:     /**
1:      * Test that the derby.stream.error.style property overrides the
1:      * derby.stream.error.file property.
1:      */
1:     public void testRollingFileStyleOverFile() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         
1:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:         
1:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(derby0log);
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.style property overrides the
1:      * derby.stream.error.method property.
1:      */
1:     public void testRollingFileStyleOverMethod() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         
1:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:         
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.getStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(derby0log);
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.style property overrides the
1:      * derby.stream.error.field property.
1:      */
1:     public void testRollingFileStyleOverField() throws IOException, SQLException {
1:         setSystemProperty(STYLE_PROP, ROLLING_FILE_STYLE);
1:         
1:         File derby0log = new File(getSystemProperty("derby.system.home"), DERBY_0_LOG);
1:         
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.fieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(derby0log);
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     private static void assertFileSize(final File f, final int size) throws IOException {
1:         try {
1:             AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws IOException {
1:                     assertEquals("assertFileEize failed for file " + f.getName() + ": ", size, f.length());
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         removeSystemProperty(STYLE_PROP);        
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c393694
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         String path = getCanonicalPath(f);
1:         assertTrue(path + " doesn't exist",
1:                 PrivilegedFileOpsForTests.exists(f));
1:         assertEquals(path + " is not empty",
1:                 0, PrivilegedFileOpsForTests.length(f));
1:             AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         String path = getCanonicalPath(f);
1:         assertTrue(path + " doesn't exist",
1:                 PrivilegedFileOpsForTests.exists(f));
1:         String path = getCanonicalPath(f);
1:         assertFalse(path + " exists",
1:                 PrivilegedFileOpsForTests.exists(f));
1:         return PrivilegedFileOpsForTests.delete(f);
1:             return AccessController.doPrivileged(
1:                   new PrivilegedExceptionAction<String>() {
1:                 public String run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:         AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:             public Void run() {
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged(
1:                   new PrivilegedExceptionAction<FileOutputStream>() {
1:                 public FileOutputStream run() throws FileNotFoundException {
/////////////////////////////////////////////////////////////////////////
commit:cf6e807
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();
commit:cda55ef
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
/////////////////////////////////////////////////////////////////////////
1:         bootDerby();
1:         // Shutdown engine so we can change properties for error stream
1:         getTestConfiguration().shutdownEngine();
/////////////////////////////////////////////////////////////////////////
1:                     assertTrue("assertNotEmpty failed: " + f.getCanonicalPath()
1:                           + " does not exist.", f.exists());
1:                     FileInputStream fis = new FileInputStream(f);
1:                     int result = fis.read();
1:                     fis.close();
1:                     assertTrue("assertNotEmpty failed: " + f.getCanonicalPath()
1:                           + " is empty.", -1 != result);
commit:57964be
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean deleted = deleteFile(derbyLog);
1:         assertTrue("File " + derbyLog + " could not be deleted", deleted);
1:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty(FILE_PROP, getCanonicalPath(new File(
1:               new File(getSystemProperty("derby.system.home"), "foo"),
1:               makeStreamFilename("file")))); // erroneous path
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty(FILE_PROP, getCanonicalPath(fileStreamFile));
/////////////////////////////////////////////////////////////////////////
1:     private static String getCanonicalPath(final File f) throws IOException {
0:         String path = null;
1:         try {
0:             path = (String) AccessController.doPrivileged(
0:                   new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
1:                     return f.getCanonicalPath();
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
0:         return path;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // e.getException() should be a FileNotFoundException.
commit:ecd42d9
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.engine.ErrorStreamTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.engine;
1: 
1: import java.io.File;
1: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.OutputStream;
1: import java.io.PrintStream;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import java.sql.SQLException;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
0: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
1:  * Tests related to the Derby error stream.
1:  *
1:  * This test has been converted to junit from the old harness tests
1:  * logStream.java and errorStream.java. The testDefault method is based on
1:  * logStream.java, the other test* methods are from errorStream.java.
1:  */
1: public class ErrorStreamTest extends BaseJDBCTestCase {
1: 
1:     private static final String FILE_PROP   = "derby.stream.error.file";
1:     private static final String METHOD_PROP = "derby.stream.error.method";
1:     private static final String FIELD_PROP  = "derby.stream.error.field";
1: 
1:     /**
1:      * runNo keeps track of which run we are in to generate unique (within a
1:      * JUnit run) names for files that are used in the test. Has to be static.
1:      */
1:     private static int runNo = 0;
1: 
1:     /**
1:      * File used when FILE_PROP is set, it maps to file
1:      * <database>-file-<runNo>.log
1:      */
1:     private File fileStreamFile;
1: 
1:     /**
1:      * See doc for getStream() below. Has to be static.
1:      */
1:     private static OutputStream methodStream;
1:     private File methodStreamFile;
1: 
1:     /**
1:      * Field fieldStream used by Derby when FIELD_PROP is set,
1:      * so it needs to be public and static.
1:      * Maps to file <database>-field-<runNo>.log
1:      */
1:     public static OutputStream fieldStream;
1:     private File fieldStreamFile;
1: 
1:     /**
1:      * Field errStream used as redirection for System.err to be able
1:      * to checks its (non-)use in the scenarios. We first tried to
1:      * merge it with System.out and let the harness compare outputs,
1:      * but this gave intermittent merging differences, so abandoned.
1:      * Maps to file <database>-err-<runNo>.log
1:      */
1:     private OutputStream errStream;
1:     private File errStreamFile;
1: 
1:     public ErrorStreamTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
1:         return TestConfiguration.embeddedSuite(ErrorStreamTest.class);
1:     }
1: 
1:     public void setUp() throws Exception {
1:         openStreams();
1:     }
1: 
1:     public void tearDown() throws Exception {
1:         resetProps();
0:         deleteStreamFiles();
1:         nullFields();
1:     }
1: 
1:     /**
1:      * Test that the error stream file (derby.log) is created at database boot
1:      * and not deleted when the database is shut down, but can be deleted
1:      * afterwards.
1:      */
1:     public void testDefault() throws IOException, SQLException {
1:         File derbyLog = new File(getSystemProperty("derby.system.home"),
1:               "derby.log");
1:         bootDerby();
1:         assertIsExisting(derbyLog);
1:         assertNotDirectory(derbyLog);
1:         assertNotEmpty(derbyLog);
1: 
1:         println("Shutdown database");
1:         getTestConfiguration().shutdownDatabase();
1: 
1:         assertIsExisting(derbyLog);
1:         assertNotDirectory(derbyLog);
1:         assertNotEmpty(derbyLog);
1: 
0:         boolean deleted = deleteFile(derbyLog);
0:         assertTrue("File " + derbyLog + " could not be deleted", deleted);
1: 
1:         println("Shutdown engine");
1:         getTestConfiguration().shutdownEngine();
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.file property.
1:      */
1:     public void testFile() throws IOException, SQLException {
0:         setSystemProperty(FILE_PROP, fileStreamFile.getCanonicalPath());
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.file property with wrong input.
1:      */
1:     public void testWrongFile() throws IOException, SQLException {
0:         setSystemProperty(FILE_PROP,
0:               new File(new File(getSystemProperty("derby.system.home"), "foo"),
0:               makeStreamFilename("file")).getCanonicalPath()); // erroneous path
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertNotEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.method property.
1:      */
1:     public void testMethod() throws IOException, SQLException  {
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.getStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertNotEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.method property with wrong input.
1:      */
1:     public void testWrongMethod() throws IOException, SQLException {
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.nonExistingGetStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertNotEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.field property.
1:      */
1:     public void testField() throws IOException, SQLException {
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.fieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertNotEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test the derby.stream.error.field property with wrong input.
1:      */
1:     public void testWrongField() throws IOException, SQLException {
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.nonExistingFieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertNotEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.file property overrides the
1:      * derby.stream.error.method property.
1:      */
1:     public void testFileOverMethod() throws IOException, SQLException {
0:         setSystemProperty(FILE_PROP, fileStreamFile.getCanonicalPath());
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.getStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.file property overrides the
1:      * derby.stream.error.field property.
1:      */
1:     public void testFileOverField() throws IOException, SQLException {
0:         setSystemProperty(FILE_PROP, fileStreamFile.getCanonicalPath());
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.fieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.file property overrides the
1:      * derby.stream.error.method and the derby.stream.error.field property.
1:      */
1:     public void testFileOverMethodAndField() throws IOException, SQLException {
0:         setSystemProperty(FILE_PROP, fileStreamFile.getCanonicalPath());
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.getStream");
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.fieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotEmpty(fileStreamFile);
1:         assertIsEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Test that the derby.stream.error.field property overrides the
1:      * derby.stream.error.method property.
1:      */
1:     public void testMethodOverField() throws IOException, SQLException {
1: 
1:         setSystemProperty(METHOD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.getStream");
1:         setSystemProperty(FIELD_PROP,
1:               "org.apache.derbyTesting.functionTests.tests.engine."+
1:               "ErrorStreamTest.fieldStream");
1: 
1:         bootDerby();
1:         getTestConfiguration().shutdownEngine();
1: 
1:         closeStreams();
1: 
1:         assertNotExisting(fileStreamFile);
1:         assertNotEmpty(methodStreamFile);
1:         assertIsEmpty(fieldStreamFile);
1:         assertIsEmpty(errStreamFile);
1:     }
1: 
1:     /**
1:      * Method getStream used by Derby when derby.stream.error.method
1:      * is set.  Maps to file <database>-method-<runNo>.log
1:      * This method has to be static.
1:      */
1:     public static OutputStream getStream() {
1:         return methodStream;
1:     }
1: 
1:     private static String makeStreamFilename(String type) {
1:         return type + "-" + runNo + ".log";
1:     }
1: 
1:     private void openStreams() throws IOException{
1:         String systemHome = getSystemProperty("derby.system.home");
1:         makeDirIfNotExisting(systemHome);
1: 
1:         runNo += 1;
1: 
0:         methodStreamFile = new File(systemHome, makeStreamFilename("method"));
0:         fileStreamFile = new File(systemHome, makeStreamFilename("file"));
0:         fieldStreamFile = new File(systemHome, makeStreamFilename("field"));
0:         errStreamFile = new File(systemHome, makeStreamFilename("err"));
1: 
1:         methodStream = newFileOutputStream(methodStreamFile);
1:         fieldStream = newFileOutputStream(fieldStreamFile);
1:         errStream = newFileOutputStream(errStreamFile);
1: 
1:         setSystemErr(new PrintStream(errStream));
1: 
1:     }
1: 
1: 
1:     private void closeStreams() throws IOException {
1:         try {
1:             methodStream.close();
1:             fieldStream.close();
1:             errStream.close();
1: 
1:             // reset until next scenario, no expected output
1:             setSystemErr(System.out);
1:         } catch (IOException e) {
1:             println("Could not close stream files");
1:             throw e;
1:         }
1:     }
1: 
1: 
0:     private static void assertIsDirectory(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     assertTrue("assertIsDirectory failed: " +
1:                           f.getCanonicalPath(), f.isDirectory());
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1:     private static void assertNotDirectory(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
1:                     assertFalse("assertNotDirectory failed: " +
1:                           f.getCanonicalPath(), f.isDirectory());
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1:     private static void assertIsEmpty(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     assertTrue("assertIsEmpty failed: " + f.getCanonicalPath(),
0:                           (f.exists() && (f.length() == 0)));
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1: 
1:     private static void assertNotEmpty(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     assertTrue("assertNotEmpty failed:" + f.getCanonicalPath(),
0:                           f.exists() && (f.length() != 0));
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1:     private static void assertIsExisting(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     assertTrue("assertIsExisting failed: " +
0:                           f.getCanonicalPath(), f.exists());
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1: 
1:     private static void assertNotExisting(final File f) throws IOException {
1:         try {
0:             AccessController.doPrivileged (new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
0:                     assertFalse("assertNotExisting failed: " +
0:                           f.getCanonicalPath(), f.exists());
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             // e.getException() should be an instance of IOException.
1:             throw (IOException) e.getException();
1:         }
1:     }
1: 
1:     private static boolean deleteFile(final File f) {
0:         Boolean deleted = (Boolean) AccessController.doPrivileged(
0:               new PrivilegedAction() {
0:             public Object run() {
0:                 return new Boolean(f.delete());
1:             }
1:         });
0:         return deleted.booleanValue();
1:     }
1: 
1:     private static void makeDirIfNotExisting(final String filename) {
0:         AccessController.doPrivileged(new PrivilegedAction() {
0:             public Object run() {
1:                 File f = new File(filename);
1:                 if(!f.exists()) {
1:                     f.mkdir();
1:                 }
1:                 return null;
1:             }
1:         });
1:     }
1: 
0:     private static void setSystemErr(final PrintStream err) {
0:         AccessController.doPrivileged(new PrivilegedAction() {
0:             public Object run() {
0:                 System.setErr(err);
1:                 return null;
1:             }
1:         });
1:     }
1: 
1:     private static FileOutputStream newFileOutputStream(final File f)
1:     throws FileNotFoundException {
0:         FileOutputStream outStream = null;
1:         try {
0:             outStream = (FileOutputStream) AccessController.doPrivileged(
0:                   new PrivilegedExceptionAction() {
0:                 public Object run() throws FileNotFoundException {
1:                     return new FileOutputStream(f);
1:                 }
1:             });
1:             } catch (PrivilegedActionException e) {
1:                 // e.getException() should be an instance of IOException.
1:                 throw (FileNotFoundException) e.getException();
1:             }
0:         return outStream;
1:     }
1: 
1: 
1:     private static void resetProps() {
1:         removeSystemProperty(FILE_PROP);
1:         removeSystemProperty(METHOD_PROP);
1:         removeSystemProperty(FIELD_PROP);
1:     }
1: 
1:     private void deleteStreamFiles() {
1:         deleteFile(fileStreamFile);
1:         deleteFile(methodStreamFile);
1:         deleteFile(fieldStreamFile);
1:         deleteFile(errStreamFile);
1:     }
1: 
1:     private void nullFields() {
1:         // Nulling fields to let objects be gc'd
1:         fileStreamFile = null;
1:         methodStreamFile = null;
1:         fieldStreamFile = null;
1:         errStreamFile = null;
1:         methodStream = null;
1:         fieldStream = null;
1:         errStream = null;
1:     }
1: 
1: 
1:     private void bootDerby() throws SQLException {
1:         /* Connect to the database to make sure that the
1:          * JDBC Driver class is loaded
1:          */
1:         getConnection();
1:         getConnection().close();
1:     }
1: 
1: }
============================================================================