1:166e695: /*
1:166e695: 
1:166e695:    Derby - Class org.apache.derby.security.SystemPermission
1:166e695: 
1:166e695:    Licensed to the Apache Software Foundation (ASF) under one or more
1:166e695:    contributor license agreements.  See the NOTICE file distributed with
1:166e695:    this work for additional information regarding copyright ownership.
1:166e695:    The ASF licenses this file to You under the Apache License, Version 2.0
1:166e695:    (the "License"); you may not use this file except in compliance with
1:166e695:    the License.  You may obtain a copy of the License at
1:166e695: 
1:166e695:       http://www.apache.org/licenses/LICENSE-2.0
1:166e695: 
1:166e695:    Unless required by applicable law or agreed to in writing, software
1:166e695:    distributed under the License is distributed on an "AS IS" BASIS,
1:166e695:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:166e695:    See the License for the specific language governing permissions and
1:166e695:    limitations under the License.
1:166e695: 
1:166e695:  */
1:166e695: 
1:166e695: package org.apache.derby.security;
1:166e695: 
1:f5ac375: import java.io.IOException;
1:f5ac375: import java.io.ObjectInputStream;
1:281f903: import java.io.ObjectOutputStream;
1:166e695: import java.security.BasicPermission;
1:5917694: import java.security.Permission;
1:281f903: import java.security.PermissionCollection;
1:5917694: import java.util.ArrayList;
1:281f903: import java.util.Collections;
1:281f903: import java.util.Enumeration;
1:281f903: import java.util.HashMap;
1:166e695: import java.util.HashSet;
1:5917694: import java.util.List;
1:5917694: import java.util.Locale;
1:166e695: import java.util.Set;
1:5917694: import java.util.StringTokenizer;
1:166e695: 
1:166e695: /**
1:166e695:  * This class represents access to system-wide Derby privileges.
1:6e37f5c:  * <P>
1:6e37f5c:   <table border = "1">
1:6e37f5c:   <tr> <th>Permission <th>Description <th>Risk </tr>
1:6e37f5c:   <tr> <th> "jmx" "control" <td> Controls the ability of JMX clients to control
1:6e37f5c:   Derby and view security sensitive attributes through Derby's MBeans.
1:6e37f5c:      <td> JMX clients may be able to change the state of the running system </tr>
1:6e37f5c:   <tr> <th> "jmx" "monitor" <td> Controls the ability of JMX clients to
1:6e37f5c:       monitor Derby through Derby's MBeans, such as viewing number of current connections and
1:6e37f5c:       configuration settings. <em> Note: security related settings require</em> <code>control</code>
1:6e37f5c:       <em>action on</em> <code>jmx</code> <td> JMX clients can see information about a runing system
1:6e37f5c:       including software versions. </tr>
1:6e37f5c:  </table>
1:166e695:  */
1:c0052e0: final public class SystemPermission extends BasicPermission {
1:166e695:     
1:6e37f5c:     private static final long serialVersionUID = 1965420504091489898L;
1:166e695:     
1:166e695:     /**
1:6e37f5c:      * Permission target name (<code>"server"</code>) for actions applicable
1:5917694:      * to the network server.
1:166e695:      */
1:5917694:     public static final String SERVER = "server";
1:166e695:     /**
1:6e37f5c:      * Permission target name (<code>"engine"</code>) for actions applicable
1:5917694:      * to the core database engine.
1:5917694:      */
1:5917694:     public static final String ENGINE = "engine";
1:5917694:     /**
1:6e37f5c:      * Permission target name (<code>"jmx"</code>) for actions applicable
1:5917694:      * to management of Derby's JMX MBeans.
1:5917694:      */
1:5917694:     public static final String JMX = "jmx";
1:6e37f5c: 
1:5917694:     /**
1:6e37f5c:      * The server and engine shutdown action (<code>"shutdown"</code>).
1:5917694:      */
1:c0052e0:     static public final String SHUTDOWN = "shutdown";
1:5917694:     
1:5917694:     /**
1:6e37f5c:      * Action (<code>"control"</code>) to perform control actions through JMX
1:5917694:      * on engine, server or jmx.
1:6e37f5c:      * <P>
1:6e37f5c:      * For JMX control permission is required to get
1:6e37f5c:      * attributes that are deemed sensiive from a security
1:6e37f5c:      * aspect, such as the network server's port number,
1:6e37f5c:      * security mechanisms and any information about the
1:6e37f5c:      * file system.
1:5917694:      */
1:5917694:     public static final String CONTROL = "control";
1:5917694:     
1:5917694:     /**
1:6e37f5c:      * Action (<code>"monitor"</code>) to perform monitoring actions through JMX
1:5917694:      * on engine and server.
1:5917694:      */
1:5917694:     public static final String MONITOR = "monitor";
1:5917694: 
1:5917694:     /**
1:a0dbbd7:      * Action (<code>"useDerbyInternals"</code>) by the engine to lookup Derby contexts.
1:a0dbbd7:      */
1:a0dbbd7:     public static final String USE_DERBY_INTERNALS = "usederbyinternals";
1:a0dbbd7: 
1:a0dbbd7:     /**
1:166e695:      * The legal system permission names.
1:166e695:      */
1:400f6eb:     static private final Set<String> LEGAL_NAMES = new HashSet<String>();    
1:166e695:     static {
1:166e695:         // when adding new permissions, check whether to override inherited
1:166e695:         // method: implies(Permission)
1:5917694:         LEGAL_NAMES.add(SERVER);
1:5917694:         LEGAL_NAMES.add(ENGINE);
1:5917694:         LEGAL_NAMES.add(JMX);
1:166e695:     };
1:166e695:     
1:166e695:     /**
1:5917694:      * Set of legal actions in their canonical form.
1:166e695:      */
1:400f6eb:     static private final List<String> LEGAL_ACTIONS = new ArrayList<String>();
1:5917694:     static {
1:5917694:         LEGAL_ACTIONS.add(CONTROL);
1:5917694:         LEGAL_ACTIONS.add(MONITOR);
1:5917694:         LEGAL_ACTIONS.add(SHUTDOWN);
1:a0dbbd7:         LEGAL_ACTIONS.add( USE_DERBY_INTERNALS );
2:5917694:     }
1:a0dbbd7:     
1:86ee0a0:     /** Constant representing {@code SystemPermission("engine, "monitor")}. */
1:86ee0a0:     public static final SystemPermission ENGINE_MONITOR =
1:86ee0a0:             new SystemPermission(ENGINE, MONITOR);
1:86ee0a0: 
1:5917694:     /**
1:5917694:      * Actions for this permission.
1:5917694:      */
1:f5ac375:     private String actions;
1:281f903: 
1:281f903:     /**
1:281f903:      * Bit mask representing the actions. It is not serialized, and has
1:281f903:      * to be recalculated when the object is deserialized.
1:281f903:      */
1:281f903:     private transient int actionMask;
1:5917694:     
1:5917694:     /**
1:166e695:      * Creates a new SystemPermission with the specified name.
1:166e695:      *
1:166e695:      * @param name the name of the SystemPermission
1:f5ac375:      * @throws NullPointerException if name or actions is null
1:166e695:      * @throws IllegalArgumentException if name is empty or not a legal SystemPermission
1:a469215:      * @see BasicPermission#BasicPermission(String)
1:5917694:      */
1:5917694:     public SystemPermission(String name, String actions) {
1:a0dbbd7:         super( name );
1:f5ac375:         validateNameAndActions(name, actions);
1:f5ac375:     }
1:f5ac375: 
1:f5ac375:     /**
1:281f903:      * Check if name and actions are valid, normalize the actions string,
1:281f903:      * and calculate the actions mask.
1:3c23476:      *
1:f5ac375:      * @param name the name of the permission
1:f5ac375:      * @param actions the actions of the permission
1:3a2ad96:      * @throws NullPointerException if actions is null
1:166e695:      * @throws IllegalArgumentException if name is not a legal SystemPermission
1:f5ac375:      */
1:f5ac375:     private void validateNameAndActions(String name, String actions) {
1:166e695:         // superclass BasicPermission has checked that name isn't null
1:166e695:         // (NullPointerException) or empty (IllegalArgumentException)
1:166e695: 
1:5917694:         if (!LEGAL_NAMES.contains(name) ) {
1:166e695:             throw new IllegalArgumentException("Unknown permission " + name);
1:166e695:         }
1:166e695:       
1:281f903:         this.actions = getCanonicalForm(actions);
1:281f903:         this.actionMask = getActionMask(this.actions);
1:166e695:     }
1:5917694:     
1:166e695:     /**
1:5917694:      * Return the permission's actions in a canonical form.
1:166e695:      */
1:5917694:     public String getActions() {
1:5917694:         return actions;
1:166e695:     }
1:281f903: 
1:281f903:     // DERBY-6717: Must override newPermissionCollection() since
1:281f903:     // BasicPermission's implementation ignores actions.
1:a0dbbd7:     @Override
1:281f903:     public PermissionCollection newPermissionCollection() {
1:281f903:         return new SystemPermissionCollection();
1:166e695:     }
12:5917694:     
1:5917694:     /**
1:5917694:      * Return a canonical form of the passed in actions.
1:5917694:      * Actions are lower-cased, in the order of LEGAL_ACTIONS
1:3c23476:      * and only appear once.
1:5917694:      */
1:5917694:     private static String getCanonicalForm(String actions) {
1:3c23476:         Set<String> actionSet = parseActions(actions);
1:3c23476: 
1:3c23476:         // Get all the legal actions that are in actionSet, in the order
1:3c23476:         // of LEGAL_ACTIONS.
1:3c23476:         List<String> legalActions = new ArrayList<String>(LEGAL_ACTIONS);
1:a0dbbd7: 
1:3c23476:         legalActions.retainAll(actionSet);
1:3c23476: 
1:3c23476:         return buildActionsString(legalActions);
1:281f903:     }
1:3c23476: 
1:3c23476:     /**
1:3c23476:      * Get a set of all actions specified in a string. Actions are transformed
1:3c23476:      * to lower-case, and leading and trailing blanks are stripped off.
1:166e695:      *
1:3c23476:      * @param actions the specified actions string
1:3c23476:      * @return a set of all the specified actions
1:3c23476:      */
1:3c23476:     static Set<String> parseActions(String actions) {
1:3c23476:         HashSet<String> actionSet = new HashSet<String>();
1:3c23476:         for (String s : actions.split(",", -1)) {
1:3c23476:             actionSet.add(s.trim().toLowerCase(Locale.ENGLISH));
1:3c23476:         }
1:3c23476:         return actionSet;
1:3c23476:     }
1:3c23476: 
1:3c23476:     /**
1:3c23476:      * Build a comma-separated actions string suitable for returning from
1:3c23476:      * {@code getActions()}.
1:3c23476:      *
1:3c23476:      * @param actions the list of actions
1:3c23476:      * @return comma-separated string with the actions
1:3c23476:      */
1:3c23476:     static String buildActionsString(Iterable<String> actions) {
1:3c23476:         StringBuilder sb = new StringBuilder();
1:3c23476: 
1:3c23476:         for (String action : actions) {
1:3c23476:             if (sb.length() > 0) {
1:3c23476:                 sb.append(',');
1:5917694:             }
1:3c23476:             sb.append(action);
1:5917694:         }
1:3c23476: 
1:5917694:         return sb.toString();
1:5917694:     }
1:5917694: 
1:5917694:     /**
1:5917694:      * Does this permission equal another object.
1:5917694:      * True if its and identical class with same
1:5917694:      * name and (canonical) actions.
1:5917694:      */
1:5917694:     public boolean equals(Object other) {
1:281f903:         // Check if the types and names match.
1:5917694:         if (!super.equals(other))
1:5917694:             return false;
1:281f903: 
1:281f903:         // Check if the actions match.
1:5917694:         SystemPermission osp = (SystemPermission) other;
1:281f903:         return actionMask == osp.actionMask;
1:5917694:     }
1:5917694:     
1:5917694:     /**
1:5917694:      * Does this permission imply another. Only true
1:5917694:      * if the other permission is a SystemPermission
1:5917694:      * with the same name and all the actions
1:5917694:      * of the permission are present in this.
1:5917694:      * Note that none of the actions imply any other
1:5917694:      * with this SystemPermission.
1:5917694:      */
1:5917694:     public boolean implies(Permission permission)
2:5917694:     {
1:281f903:         // Check if the types and names match.
1:5917694:         if (!super.implies(permission))
1:5917694:             return false;
1:281f903: 
1:281f903:         // Check if the actions match.
1:281f903:         int myActionMask = actionMask;
1:281f903:         int permissionMask = ((SystemPermission) permission).actionMask;
1:5917694:         
1:5917694:         return
1:5917694:             (myActionMask & permissionMask) == permissionMask;
1:5917694:     }
1:5917694:     
1:5917694:     /**
1:5917694:      * Get a mask of bits that represents the actions
1:5917694:      * and can be used for the implies method.
1:5917694:      */
1:5917694:     private static int getActionMask(String actions) {
1:5917694:         
1:5917694:         int mask = 0;
1:356ff6f:         StringTokenizer st = new StringTokenizer(actions, ",");
2:5917694:         while (st.hasMoreTokens()) {
2:5917694:             int validAction = LEGAL_ACTIONS.indexOf(st.nextElement());
2:5917694:             if (validAction != -1)
1:5917694:                 mask |= 1 << validAction;
1:5917694:         }
1:5917694:         
1:5917694:         return mask;
1:5917694:     }
1:f5ac375: 
1:f5ac375:     /**
1:f5ac375:      * Called upon deserialization for restoring the state of this
1:f5ac375:      * SystemPermission from a stream.
1:f5ac375:      */
1:f5ac375:     private void readObject(ObjectInputStream s)
1:f5ac375:          throws IOException, ClassNotFoundException {
1:f5ac375:         // Read the fields from the stream.
1:f5ac375:         s.defaultReadObject();
1:f5ac375: 
1:f5ac375:         // Make sure the name and actions fields contain legal values.
1:f5ac375:         validateNameAndActions(getName(), getActions());
1:f5ac375:     }
1:281f903: 
1:281f903:     /**
1:281f903:      * A collection of {@code SystemPermission} objects. Instances of this
1:281f903:      * class must be thread-safe and serializable, per the specification of
1:281f903:      * {@code java.security.PermissionCollection}.
1:281f903:      */
1:281f903:     private static class SystemPermissionCollection
1:281f903:                                 extends PermissionCollection {
1:281f903:         private static final long serialVersionUID = 0L;
1:281f903: 
1:281f903:         private HashMap<String, Permission> permissions
1:281f903:                 = new HashMap<String, Permission>();
1:281f903: 
1:281f903:         @Override
1:281f903:         public void add(Permission permission) {
1:281f903:             // The contract of PermissionCollection.add() requires
1:281f903:             // IllegalArgumentException if permission is not SystemPermission.
1:281f903:             if (!(permission instanceof SystemPermission)) {
1:281f903:                 throw new IllegalArgumentException();
1:281f903:             }
1:281f903: 
1:281f903:             // The contract of PermissionCollection.add() requires
1:281f903:             // SecurityException if the collection is read-only.
1:281f903:             if (isReadOnly()) {
1:281f903:                 throw new SecurityException();
1:281f903:             }
1:281f903: 
1:281f903:             String name = permission.getName();
1:281f903: 
1:281f903:             synchronized (this) {
1:281f903:                 Permission existing = permissions.get(name);
1:281f903:                 if (existing == null) {
1:281f903:                     permissions.put(name, permission);
1:281f903:                 } else {
1:281f903:                     String actions = existing.getActions() + ','
1:281f903:                                         + permission.getActions();
1:281f903:                     permissions.put(name, new SystemPermission(name, actions));
1:281f903:                 }
1:281f903:             }
1:281f903:         }
1:281f903: 
1:281f903:         @Override
1:281f903:         public boolean implies(Permission permission) {
1:281f903:             if (!(permission instanceof SystemPermission)) {
1:281f903:                 return false;
1:281f903:             }
1:281f903: 
1:281f903:             String name = permission.getName();
1:281f903:             Permission perm;
1:281f903: 
1:281f903:             synchronized (this) {
1:281f903:                 perm = permissions.get(name);
1:281f903:             }
1:281f903: 
1:281f903:             return (perm != null) && perm.implies(permission);
1:281f903:         }
1:281f903: 
1:281f903:         @Override
1:281f903:         public synchronized Enumeration<Permission> elements() {
1:281f903:             return Collections.enumeration(permissions.values());
1:281f903:         }
1:281f903: 
1:281f903:         /**
1:281f903:          * Called upon Serialization for saving the state of this
1:281f903:          * SystemPermissionCollection to a stream.
1:281f903:          */
1:281f903:         private void writeObject(ObjectOutputStream s)
1:281f903:                 throws IOException {
1:281f903:             // Only the values of the HashMap need to be serialized.
1:281f903:             // The keys can be reconstructed from the values during
1:281f903:             // deserialization.
1:281f903:             ArrayList<Permission> perms;
1:281f903:             synchronized (this) {
1:281f903:                 perms = new ArrayList<Permission>(permissions.values());
1:281f903:             }
1:281f903: 
1:281f903:             ObjectOutputStream.PutField fields = s.putFields();
1:281f903:             fields.put("permissions", perms);
1:281f903:             s.writeFields();
1:281f903:         }
1:281f903: 
1:281f903:         /**
1:281f903:          * Called upon deserialization for restoring the state of this
1:281f903:          * SystemPermissionCollection from a stream.
1:281f903:          */
1:281f903:         private void readObject(ObjectInputStream s)
1:281f903:                 throws IOException, ClassNotFoundException {
1:281f903:             ObjectInputStream.GetField fields = s.readFields();
1:281f903:             List perms = (List) fields.get("permissions", null);
1:281f903: 
1:281f903:             permissions = new HashMap<String, Permission>();
1:281f903: 
1:281f903:             // Insert the permissions one at a time, and verify that they
1:281f903:             // in fact are SystemPermissions by doing an explicit cast. If
1:281f903:             // a corrupted stream contains other kinds of permissions, a
1:281f903:             // ClassCastException is raised instead of returning an invalid
1:281f903:             // collection.
1:281f903:             for (Object p : perms) {
1:281f903:                 SystemPermission sp = (SystemPermission) p;
1:281f903:                 permissions.put(sp.getName(), sp);
1:281f903:             }
1:281f903:         }
1:281f903:     }
1:5917694: 
1:281f903:     @Override
1:a0dbbd7:     public String toString()
1:a0dbbd7:     {
1:a0dbbd7:         return getClass().getName() +
1:a0dbbd7:             "( " +
1:a0dbbd7:             doubleQuote( getName() ) +
1:a0dbbd7:             ", " +
1:a0dbbd7:             doubleQuote( actions ) +
1:a0dbbd7:             " )";
1:a0dbbd7:     }
1:a0dbbd7:     private String  doubleQuote( String raw )
1:a0dbbd7:     {
1:a0dbbd7:         return "\"" + raw + "\"";
1:a0dbbd7:     }
1:5917694: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:      * Action (<code>"useDerbyInternals"</code>) by the engine to lookup Derby contexts.
1:      */
1:     public static final String USE_DERBY_INTERNALS = "usederbyinternals";
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         LEGAL_ACTIONS.add( USE_DERBY_INTERNALS );
/////////////////////////////////////////////////////////////////////////
1:         super( name );
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     @Override
1:     public String toString()
1:     {
1:         return getClass().getName() +
1:             "( " +
1:             doubleQuote( getName() ) +
1:             ", " +
1:             doubleQuote( actions ) +
1:             " )";
1:     }
1:     private String  doubleQuote( String raw )
1:     {
1:         return "\"" + raw + "\"";
1:     }
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
1:     static private final Set<String> LEGAL_NAMES = new HashSet<String>();    
/////////////////////////////////////////////////////////////////////////
1:     static private final List<String> LEGAL_ACTIONS = new ArrayList<String>();
commit:166e695
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.security.SystemPermission
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.security;
1: 
1: import java.security.BasicPermission;
1: import java.util.Set;
1: import java.util.HashSet;
1: 
1: /**
1:  * This class represents access to system-wide Derby privileges.
1:  */
0: public class SystemPermission extends BasicPermission {
1: 
1:     /**
0:      * The engine shutdown permission.
1:      */
0:     static public final String SHUTDOWN = "shutdownEngine";
1: 
1:     /**
1:      * The legal system permission names.
1:      */
0:     static protected final Set LEGAL_PERMISSIONS = new HashSet();    
1:     static {
1:         // when adding new permissions, check whether to override inherited
1:         // method: implies(Permission)
0:         LEGAL_PERMISSIONS.add(SHUTDOWN);
1:     };
1: 
1:     /**
0:      * Checks a name for denoting a legal SystemPermission.
1:      *
0:      * @param name the name of a SystemPermission
1:      * @throws IllegalArgumentException if name is not a legal SystemPermission
1:      */
0:     static protected void checkPermission(String name) {
1:         // superclass BasicPermission has checked that name isn't null
1:         // (NullPointerException) or empty (IllegalArgumentException)
0:         //assert(name != null);
0:         //assert(!name.equals(""));
1: 
0:         // note that exception messages on the name aren't localized,
0:         // as is the general rule with runtime exceptions indicating
0:         // internal coding errors
0:         if (!LEGAL_PERMISSIONS.contains(name)) {
1:             throw new IllegalArgumentException("Unknown permission " + name);
1:         }
1:     }
1:     
1:     /**
1:      * Creates a new SystemPermission with the specified name.
1:      *
1:      * @param name the name of the SystemPermission
0:      * @throws NullPointerException if name is null
1:      * @throws IllegalArgumentException if name is empty or not a legal SystemPermission
0:      * @see BasicPermission(String)
1:      */
0:     public SystemPermission(String name) {
0:         super(name);
0:         checkPermission(name);
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86ee0a0
/////////////////////////////////////////////////////////////////////////
1:     /** Constant representing {@code SystemPermission("engine, "monitor")}. */
1:     public static final SystemPermission ENGINE_MONITOR =
1:             new SystemPermission(ENGINE, MONITOR);
1: 
commit:281f903
/////////////////////////////////////////////////////////////////////////
1: import java.io.ObjectOutputStream;
1: import java.security.PermissionCollection;
1: import java.util.Collections;
1: import java.util.Enumeration;
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Bit mask representing the actions. It is not serialized, and has
1:      * to be recalculated when the object is deserialized.
1:      */
1:     private transient int actionMask;
/////////////////////////////////////////////////////////////////////////
1:      * Check if name and actions are valid, normalize the actions string,
1:      * and calculate the actions mask.
/////////////////////////////////////////////////////////////////////////
1:         this.actions = getCanonicalForm(actions);
1:         this.actionMask = getActionMask(this.actions);
/////////////////////////////////////////////////////////////////////////
1: 
1:     // DERBY-6717: Must override newPermissionCollection() since
1:     // BasicPermission's implementation ignores actions.
1:     @Override
1:     public PermissionCollection newPermissionCollection() {
1:         return new SystemPermissionCollection();
1:     }
/////////////////////////////////////////////////////////////////////////
1:         // Check if the types and names match.
1: 
1:         // Check if the actions match.
1:         return actionMask == osp.actionMask;
/////////////////////////////////////////////////////////////////////////
1:         // Check if the types and names match.
1: 
1:         // Check if the actions match.
1:         int myActionMask = actionMask;
1:         int permissionMask = ((SystemPermission) permission).actionMask;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * A collection of {@code SystemPermission} objects. Instances of this
1:      * class must be thread-safe and serializable, per the specification of
1:      * {@code java.security.PermissionCollection}.
1:      */
1:     private static class SystemPermissionCollection
1:                                 extends PermissionCollection {
1:         private static final long serialVersionUID = 0L;
1: 
1:         private HashMap<String, Permission> permissions
1:                 = new HashMap<String, Permission>();
1: 
1:         @Override
1:         public void add(Permission permission) {
1:             // The contract of PermissionCollection.add() requires
1:             // IllegalArgumentException if permission is not SystemPermission.
1:             if (!(permission instanceof SystemPermission)) {
1:                 throw new IllegalArgumentException();
1:             }
1: 
1:             // The contract of PermissionCollection.add() requires
1:             // SecurityException if the collection is read-only.
1:             if (isReadOnly()) {
1:                 throw new SecurityException();
1:             }
1: 
1:             String name = permission.getName();
1: 
1:             synchronized (this) {
1:                 Permission existing = permissions.get(name);
1:                 if (existing == null) {
1:                     permissions.put(name, permission);
1:                 } else {
1:                     String actions = existing.getActions() + ','
1:                                         + permission.getActions();
1:                     permissions.put(name, new SystemPermission(name, actions));
1:                 }
1:             }
1:         }
1: 
1:         @Override
1:         public boolean implies(Permission permission) {
1:             if (!(permission instanceof SystemPermission)) {
1:                 return false;
1:             }
1: 
1:             String name = permission.getName();
1:             Permission perm;
1: 
1:             synchronized (this) {
1:                 perm = permissions.get(name);
1:             }
1: 
1:             return (perm != null) && perm.implies(permission);
1:         }
1: 
1:         @Override
1:         public synchronized Enumeration<Permission> elements() {
1:             return Collections.enumeration(permissions.values());
1:         }
1: 
1:         /**
1:          * Called upon Serialization for saving the state of this
1:          * SystemPermissionCollection to a stream.
1:          */
1:         private void writeObject(ObjectOutputStream s)
1:                 throws IOException {
1:             // Only the values of the HashMap need to be serialized.
1:             // The keys can be reconstructed from the values during
1:             // deserialization.
1:             ArrayList<Permission> perms;
1:             synchronized (this) {
1:                 perms = new ArrayList<Permission>(permissions.values());
1:             }
1: 
1:             ObjectOutputStream.PutField fields = s.putFields();
1:             fields.put("permissions", perms);
1:             s.writeFields();
1:         }
1: 
1:         /**
1:          * Called upon deserialization for restoring the state of this
1:          * SystemPermissionCollection from a stream.
1:          */
1:         private void readObject(ObjectInputStream s)
1:                 throws IOException, ClassNotFoundException {
1:             ObjectInputStream.GetField fields = s.readFields();
1:             List perms = (List) fields.get("permissions", null);
1: 
1:             permissions = new HashMap<String, Permission>();
1: 
1:             // Insert the permissions one at a time, and verify that they
1:             // in fact are SystemPermissions by doing an explicit cast. If
1:             // a corrupted stream contains other kinds of permissions, a
1:             // ClassCastException is raised instead of returning an invalid
1:             // collection.
1:             for (Object p : perms) {
1:                 SystemPermission sp = (SystemPermission) p;
1:                 permissions.put(sp.getName(), sp);
1:             }
1:         }
1:     }
commit:3c23476
/////////////////////////////////////////////////////////////////////////
1:      * and only appear once.
1:         Set<String> actionSet = parseActions(actions);
1: 
1:         // Get all the legal actions that are in actionSet, in the order
1:         // of LEGAL_ACTIONS.
1:         List<String> legalActions = new ArrayList<String>(LEGAL_ACTIONS);
1:         legalActions.retainAll(actionSet);
1: 
1:         return buildActionsString(legalActions);
1:     }
1: 
1:     /**
1:      * Get a set of all actions specified in a string. Actions are transformed
1:      * to lower-case, and leading and trailing blanks are stripped off.
1:      *
1:      * @param actions the specified actions string
1:      * @return a set of all the specified actions
1:      */
1:     static Set<String> parseActions(String actions) {
1:         HashSet<String> actionSet = new HashSet<String>();
1:         for (String s : actions.split(",", -1)) {
1:             actionSet.add(s.trim().toLowerCase(Locale.ENGLISH));
1:         return actionSet;
1:     }
1: 
1:     /**
1:      * Build a comma-separated actions string suitable for returning from
1:      * {@code getActions()}.
1:      *
1:      * @param actions the list of actions
1:      * @return comma-separated string with the actions
1:      */
1:     static String buildActionsString(Iterable<String> actions) {
1:         StringBuilder sb = new StringBuilder();
1: 
1:         for (String action : actions) {
1:             if (sb.length() > 0) {
1:                 sb.append(',');
1:             sb.append(action);
1: 
commit:3a2ad96
/////////////////////////////////////////////////////////////////////////
1:      * @throws NullPointerException if actions is null
0:      * @throws IllegalArgumentException if name is not a legal SystemPermission
commit:f5ac375
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInputStream;
/////////////////////////////////////////////////////////////////////////
1:     private String actions;
1:      * @throws NullPointerException if name or actions is null
1:         validateNameAndActions(name, actions);
1:     }
1: 
1:     /**
0:      * Check if name and actions are valid, and normalize the actions
0:      * string.
0:      *
1:      * @param name the name of the permission
1:      * @param actions the actions of the permission
0:      * @param NullPointerException if actions is null
0:      * @param IllegalArgumentException if name is not a legal SystemPermission
1:      */
1:     private void validateNameAndActions(String name, String actions) {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Called upon deserialization for restoring the state of this
1:      * SystemPermission from a stream.
1:      */
1:     private void readObject(ObjectInputStream s)
1:          throws IOException, ClassNotFoundException {
1:         // Read the fields from the stream.
1:         s.defaultReadObject();
1: 
1:         // Make sure the name and actions fields contain legal values.
1:         validateNameAndActions(getName(), getActions());
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6e37f5c
/////////////////////////////////////////////////////////////////////////
1:  * <P>
1:   <table border = "1">
1:   <tr> <th>Permission <th>Description <th>Risk </tr>
1:   <tr> <th> "jmx" "control" <td> Controls the ability of JMX clients to control
1:   Derby and view security sensitive attributes through Derby's MBeans.
1:      <td> JMX clients may be able to change the state of the running system </tr>
1:   <tr> <th> "jmx" "monitor" <td> Controls the ability of JMX clients to
1:       monitor Derby through Derby's MBeans, such as viewing number of current connections and
1:       configuration settings. <em> Note: security related settings require</em> <code>control</code>
1:       <em>action on</em> <code>jmx</code> <td> JMX clients can see information about a runing system
1:       including software versions. </tr>
1:  </table>
1:     private static final long serialVersionUID = 1965420504091489898L;
1:     
1:      * Permission target name (<code>"server"</code>) for actions applicable
1:      * Permission target name (<code>"engine"</code>) for actions applicable
1:      * Permission target name (<code>"jmx"</code>) for actions applicable
1:      * The server and engine shutdown action (<code>"shutdown"</code>).
1:      * Action (<code>"control"</code>) to perform control actions through JMX
1:      * <P>
1:      * For JMX control permission is required to get
1:      * attributes that are deemed sensiive from a security
1:      * aspect, such as the network server's port number,
1:      * security mechanisms and any information about the
1:      * file system.
1:      * Action (<code>"monitor"</code>) to perform monitoring actions through JMX
commit:356ff6f
/////////////////////////////////////////////////////////////////////////
1:         StringTokenizer st = new StringTokenizer(actions, ",");
0:             String action = st.nextToken().trim().toLowerCase(Locale.ENGLISH);
0:             int validAction = LEGAL_ACTIONS.indexOf(action);
/////////////////////////////////////////////////////////////////////////
0:         StringTokenizer st = new StringTokenizer(actions, ",");
commit:5917694
/////////////////////////////////////////////////////////////////////////
1: import java.security.Permission;
1: import java.util.ArrayList;
1: import java.util.List;
1: import java.util.Locale;
0: import java.util.Set;
1: import java.util.StringTokenizer;
1:     
1:     /**
0:      * Permission target name for actions applicable
1:      * to the network server.
1:      */
1:     public static final String SERVER = "server";
1:     /**
0:      * Permission target name for actions applicable
1:      * to the core database engine.
1:      */
1:     public static final String ENGINE = "engine";
1:     /**
0:      * Permission target name for actions applicable
1:      * to management of Derby's JMX MBeans.
1:      */
1:     public static final String JMX = "jmx";
0:      * The server and engine shutdown action.
1:     
1:     /**
0:      * Permission to perform control actions through JMX
1:      * on engine, server or jmx.
1:      */
1:     public static final String CONTROL = "control";
1:     
1:     /**
0:      * Permission to perform monitoring actions through JMX
1:      * on engine and server.
1:      */
1:     public static final String MONITOR = "monitor";
0:     static private final Set LEGAL_NAMES = new HashSet();    
1:         LEGAL_NAMES.add(SERVER);
1:         LEGAL_NAMES.add(ENGINE);
1:         LEGAL_NAMES.add(JMX);
1:     
1:      * Set of legal actions in their canonical form.
0:     static private final List LEGAL_ACTIONS = new ArrayList();
1:     static {
1:         LEGAL_ACTIONS.add(CONTROL);
1:         LEGAL_ACTIONS.add(MONITOR);
1:         LEGAL_ACTIONS.add(SHUTDOWN);
1:      * Actions for this permission.
1:      */
0:     private final String actions;
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public SystemPermission(String name, String actions) {
1:             
0:         // superclass BasicPermission has checked that name isn't null
0:         // (NullPointerException) or empty (IllegalArgumentException)
1: 
1:         if (!LEGAL_NAMES.contains(name) ) {
0:             throw new IllegalArgumentException("Unknown permission " + name);
1:         }
1:       
0:         this.actions = getCanonicalForm(actions);   
1:     
1:     /**
1:      * Return the permission's actions in a canonical form.
1:      */
1:     public String getActions() {
1:         return actions;
1:     }
1:     
1:     /**
1:      * Return a canonical form of the passed in actions.
1:      * Actions are lower-cased, in the order of LEGAL_ACTIONS
0:      * and on;ly appear once.
1:      */
1:     private static String getCanonicalForm(String actions) {
0:         actions = actions.trim().toLowerCase(Locale.ENGLISH);
1:         
0:         boolean[] seenAction = new boolean[LEGAL_ACTIONS.size()];
0:         StringTokenizer st = new StringTokenizer(actions);
1:         while (st.hasMoreTokens()) {
1:             int validAction = LEGAL_ACTIONS.indexOf(st.nextElement());
1:             if (validAction != -1)
0:                 seenAction[validAction] = true;
1:         }
1:         
0:         StringBuffer sb = new StringBuffer();
0:         for (int sa = 0; sa < seenAction.length; sa++)
1:         {
0:             if (seenAction[sa]) {
0:                 if (sb.length() != 0)
0:                     sb.append(",");
0:                 sb.append(LEGAL_ACTIONS.get(sa));
1:             }
1:         }
1:         
1:         return sb.toString();
1:     }
1: 
1:     /**
1:      * Does this permission equal another object.
1:      * True if its and identical class with same
1:      * name and (canonical) actions.
1:      */
1:     public boolean equals(Object other) {
1:         
1:         if (!super.equals(other))
1:             return false;
1:         
1:         SystemPermission osp = (SystemPermission) other;
0:         return getActions().equals(osp.getActions());
1:     }
1:     
1:     /**
1:      * Does this permission imply another. Only true
1:      * if the other permission is a SystemPermission
1:      * with the same name and all the actions
1:      * of the permission are present in this.
1:      * Note that none of the actions imply any other
1:      * with this SystemPermission.
1:      */
1:     public boolean implies(Permission permission)
1:     {
1:         if (!super.implies(permission))
1:             return false;
1:         
0:         int myActionMask = getActionMask(getActions());
0:         int permissionMask = getActionMask(permission.getActions());
1:         
1:         return
1:             (myActionMask & permissionMask) == permissionMask;
1:     }
1:     
1:     /**
1:      * Get a mask of bits that represents the actions
1:      * and can be used for the implies method.
1:      */
1:     private static int getActionMask(String actions) {
0:         actions = actions.trim().toLowerCase(Locale.ENGLISH);
1:         
1:         int mask = 0;
0:         StringTokenizer st = new StringTokenizer(actions);
1:         while (st.hasMoreTokens()) {
1:             int validAction = LEGAL_ACTIONS.indexOf(st.nextElement());
1:             if (validAction != -1)
1:                 mask |= 1 << validAction;
1:         }
1:         
1:         return mask;
1:     }
1:     
1:     
commit:c0052e0
/////////////////////////////////////////////////////////////////////////
1: final public class SystemPermission extends BasicPermission {
0:      * The server and engine shutdown permission.
1:     static public final String SHUTDOWN = "shutdown";
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a469215
/////////////////////////////////////////////////////////////////////////
1:      * @see BasicPermission#BasicPermission(String)
============================================================================