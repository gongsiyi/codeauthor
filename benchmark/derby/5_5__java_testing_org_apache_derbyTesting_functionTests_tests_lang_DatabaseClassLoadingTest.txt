1:bb0c274: /*
1:bb0c274: 
1:bb0c274:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DatabaseClassLoadingTest
1:c0440b1: 
1:bb0c274:    Licensed to the Apache Software Foundation (ASF) under one
1:bb0c274:    or more contributor license agreements.  See the NOTICE file
1:bb0c274:    distributed with this work for additional information
1:bb0c274:    regarding copyright ownership.  The ASF licenses this file
1:bb0c274:    to you under the Apache License, Version 2.0 (the
1:bb0c274:    "License"); you may not use this file except in compliance
1:bb0c274:    with the License.  You may obtain a copy of the License at
1:bb0c274: 
1:bb0c274:      http://www.apache.org/licenses/LICENSE-2.0
1:bb0c274: 
1:bb0c274:    Unless required by applicable law or agreed to in writing,
1:bb0c274:    software distributed under the License is distributed on an
1:bb0c274:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:bb0c274:    KIND, either express or implied.  See the License for the
1:bb0c274:    specific language governing permissions and limitations
1:bb0c274:    under the License.
1:bb0c274: 
1:bb0c274:  */
1:36d1b35: package org.apache.derbyTesting.functionTests.tests.lang;
1:bb0c274: 
1:0298580: import java.io.BufferedInputStream;
1:0298580: import java.io.File;
1:0298580: import java.io.FileInputStream;
1:0298580: import java.io.FileOutputStream;
1:0298580: import java.io.IOException;
1:3cfc857: import java.net.MalformedURLException;
1:36d1b35: import java.net.URL;
1:0298580: import java.security.AccessController;
1:36d1b35: import java.sql.CallableStatement;
1:0298580: import java.sql.Connection;
1:36d1b35: import java.sql.PreparedStatement;
1:36d1b35: import java.sql.ResultSet;
1:36d1b35: import java.sql.SQLException;
1:36d1b35: import java.sql.Statement;
1:0298580: import java.util.zip.ZipEntry;
1:0298580: import java.util.zip.ZipOutputStream;
1:0298580: import javax.sql.DataSource;
1:36d1b35: import junit.framework.Test;
1:9f1b314: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:36d1b35: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:4a08a15: import org.apache.derbyTesting.junit.ClasspathSetup;
1:36d1b35: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:36d1b35: import org.apache.derbyTesting.junit.JDBC;
1:0298580: import org.apache.derbyTesting.junit.JDBCDataSource;
1:f40e25a: import org.apache.derbyTesting.junit.LoginTimeoutTestSetup;
1:36d1b35: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:c722b36: 
1:36d1b35: /**
1:36d1b35:  * Test database class loading, executing routines from the
1:e1e7492:  * installed jars including accessing resources. Replacing
1:e1e7492:  * jars and handling signed jars is also tested.
1:36d1b35:  *
2:36d1b35:  */
1:36d1b35: public class DatabaseClassLoadingTest extends BaseJDBCTestCase {
1:46ecfcf:     
1:36d1b35:     public DatabaseClassLoadingTest(String name)
5:36d1b35:     {
1:36d1b35:         super(name);
8:36d1b35:     }
1:4d0fc78: 
1:4d0fc78:     /**
1:36d1b35:      * Run the tests only in embedded since this is testing
1:36d1b35:      * server side behaviour. Due to DERBY-537 and DERBY-2040
1:0298580:      * most of the tests are run without a security manager.
1:36d1b35:      * Ordering is important here so the fixtures are added
1:36d1b35:      * explicitly.
1:0298580:      */
1:4a08a15:     public static Test suite() throws Exception
1:0298580:     {
1:1ae02c9:         final BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("DatabaseClassLoadingTest");
1:4d0fc78:         
1:9528482:         // Need DriverManager to execute the add contact procedure
1:9528482:         // as it uses server side jdbc.
1:3cfc857:         Test test = suite;
1:9528482:         if (JDBC.vmSupportsJDBC3()) {
1:6fc71fb:             
1:6fc71fb:             String[] orderedTests = {
1:6fc71fb:                 "testJarHandling",
1:6fc71fb:                 "testWithNoInstalledJars",
1:6fc71fb:                 "testWithNoClasspath",
1:6fc71fb:                 "testSetClasspath",
1:6fc71fb:                 "testAddContact",
1:6fc71fb:                 "testGetResource",          
1:6fc71fb:                 "testAlterTable",
1:6fc71fb:                 "testClassPathRollback",
1:6fc71fb:                 "testReplaceJar",      
1:6fc71fb:                 "testReplacedClass",
1:6fc71fb:                 "testSecondJar",
1:6fc71fb:                 "testSignedJar",
1:6fc71fb:                 "testCreateDatabaseJar",
1:6fc71fb:                 "testHackedJarReplacedClass",
1:6fc71fb:                 "testInvalidJar",
1:6fc71fb:                 "testRemoveJar",
1:6fc71fb:                 "testLoadJavaClassIndirectly",
1:6fc71fb:                 "testLoadJavaClassDirectly",
1:6fc71fb:                 "testLoadJavaClassDirectly2",
1:6fc71fb:                 "testLoadJavaClassDirectly3",
1:6fc71fb:                 "testLoadDerbyClassIndirectly",
1:01ab42f:                 "testIndirectLoading",
1:4d0fc78:                 "testTableFunctionInJar",
1:b3834d3:                 "testUDAInJar",
1:a7016bf:                 "test_5352",
1:6fc71fb:             };
1:f40e25a:             
1:6fc71fb:             for (int i = 0; i < orderedTests.length; i++)
1:6fc71fb:             {
1:6fc71fb:                 suite.addTest(new DatabaseClassLoadingTest(orderedTests[i]));
1:6fc71fb:             }
1:6fc71fb:        
1:9f1b314:             suite.addTest(new DatabaseClassLoadingTest("testDatabaseInJar"));
1:66f66a1: 
1:4a08a15:             // DERBY-2162: Only run this test case on platforms that support
1:4a08a15:             // the URLClassLoader.close() method. Otherwise, we won't be able
1:4a08a15:             // to delete the jar file afterwards.
1:4a08a15:             if (ClasspathSetup.supportsClose()) {
1:9f1b314:                 suite.addTest(new ClasspathSetup(
1:4a08a15:                         new DatabaseClassLoadingTest("testDatabaseInClasspath"),
1:9f1b314:                         SupportFilesSetup.getReadOnlyURL("dclt.jar")));
1:0298580:             }
1:55ffdfb:            
1:c722b36:            // No security manager because the test uses getClass().getClassLoader()
1:c722b36:            // in an installed jar to ensure that the class loader for
1:c722b36:            // specific classes is correct. This operation is not allowed in general.
1:4a08a15:            suite.addTest(SecurityManagerSetup.noSecurityManager(
1:c722b36:                    new DatabaseClassLoadingTest("testClassLoadOrdering")));
1:f40e25a: 
1:f40e25a:            // Add test cases accessing a classpath database when a login
1:f40e25a:            // timeout has been specified.
1:f40e25a:            suite.addTest(loginTimeoutSuite());
1:c722b36: 
1:3cfc857:            test = new SupportFilesSetup(suite,
1:3cfc857:                    new String[] {
1:3cfc857:                    "functionTests/tests/lang/dcl_emc1.jar",
1:3cfc857:                    "functionTests/tests/lang/dcl_emcaddon.jar",
1:3cfc857:                    "functionTests/tests/lang/dcl_emc2.jar",
1:3cfc857:                    "functionTests/tests/lang/dcl_emc2s.jar",
1:3cfc857:                    "functionTests/tests/lang/dcl_emc2sm.jar",
1:46ecfcf:                    "functionTests/tests/lang/dcl_emc2l.jar",
1:46ecfcf:                    "functionTests/tests/lang/dcl_java.jar",
1:c722b36:                    "functionTests/tests/lang/dcl_ot1.jar",
1:c722b36:                    "functionTests/tests/lang/dcl_ot2.jar",
1:c722b36:                    "functionTests/tests/lang/dcl_ot3.jar",
1:01ab42f:                    "functionTests/tests/lang/dcl_id.jar",
1:4d0fc78:                    "functionTests/tests/lang/dummy_vti.jar",
1:b3834d3:                    "functionTests/tests/lang/median_uda.jar",
1:0298580:                    });
1:0298580:            
1:e1e7492:            }
1:0298580:         
1:3cfc857:         return new CleanDatabaseTestSetup(test) {
1:36d1b35:             protected void decorateSQL(Statement s) throws SQLException
1:36d1b35:             {
1:36d1b35:                 s.executeUpdate("create schema emc");
1:e1e7492:                 s.executeUpdate("create schema \"emcAddOn\"");
1:36d1b35:                 s.executeUpdate("create table emc.contacts " +
1:36d1b35:                         "(id int primary key, e_mail varchar(30))");
1:36d1b35:                 s.executeUpdate(
1:36d1b35:                   "create procedure EMC.ADDCONTACT(id INT, e_mail VARCHAR(30)) " +
1:36d1b35:                   "MODIFIES SQL DATA " +
1:36d1b35:                   "external name 'org.apache.derbyTesting.databaseclassloader.emc.addContact' " +
1:36d1b35:                   "language java parameter style java");
1:0298580: 
1:36d1b35:                 s.executeUpdate(
1:eff9169:                   "create function EMC.GETARTICLE(path VARCHAR(60)) " +
1:36d1b35:                   "RETURNS VARCHAR(256) " +
1:36d1b35:                   "NO SQL " +
1:36d1b35:                   "external name 'org.apache.derbyTesting.databaseclassloader.emc.getArticle' " +
1:36d1b35:                   "language java parameter style java");
1:0298580:                 
1:e1e7492:                 // function that gets the signers of the class (loaded from the jar)
1:e1e7492:                 s.executeUpdate("CREATE FUNCTION EMC.GETSIGNERS(" +
1:e1e7492:                   "CLASS_NAME VARCHAR(256)) RETURNS VARCHAR(60) "+
1:e1e7492:                   "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:e1e7492:                   "EXTERNAL NAME 'org.apache.derbyTesting.databaseclassloader.emc.getSigners'");
1:0298580:                 
1:e1e7492:                 s.executeUpdate("CREATE FUNCTION \"emcAddOn\".VALIDCONTACT(E_MAIL VARCHAR(30)) "+
1:e1e7492:                   "RETURNS SMALLINT "+
1:e1e7492:                   "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:e1e7492:                   "EXTERNAL NAME 'org.apache.derbyTesting.databaseclassloader.addon.vendor.util.valid'");
1:9528482:                 }
1:36d1b35:         };
1:36d1b35:     }
1:0298580: 
1:f40e25a:     /**
1:f40e25a:      * Create a test suite that verifies the fix for DERBY-6107. Connection
1:f40e25a:      * attempts used to fail when trying to access a classpath database that
1:f40e25a:      * lived in the context class loader, if a login timeout was used and a
1:f40e25a:      * previous connection attempt had been made from a thread that did not
1:f40e25a:      * have the database in its context class loader.
1:f40e25a:      */
1:f40e25a:     private static Test loginTimeoutSuite() throws Exception {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("Class loading with login timeout");
1:f40e25a: 
1:f40e25a:         // First run a test when the database is not in the classpath.
1:f40e25a:         // Expect the connection attempt to fail.
1:f40e25a:         suite.addTest(
1:f40e25a:             new DatabaseClassLoadingTest("testLoginTimeoutNotInClasspath"));
1:f40e25a: 
1:f40e25a:         // Then try again with the database in the classpath. Should succeed.
1:f40e25a:         // Failed before DERBY-6107.
1:f40e25a:         //
1:f40e25a:         // Only add this test case if we can close the URLClassLoader when
1:f40e25a:         // we're done. Otherwise, we won't be able to delete the jar file
1:f40e25a:         // afterwards. (DERBY-2162)
1:f40e25a:         if (ClasspathSetup.supportsClose()) {
1:f40e25a:             suite.addTest(
1:f40e25a:                 new ClasspathSetup(
1:f40e25a:                     new DatabaseClassLoadingTest("testLoginTimeoutInClasspath"),
1:f40e25a:                     SupportFilesSetup.getReadOnlyURL("dclt.jar")));
1:f40e25a:         }
1:f40e25a: 
1:f40e25a:         // Finally, check that the database cannot be found anymore after
1:f40e25a:         // it has been removed from the classpath.
1:f40e25a:         suite.addTest(
1:f40e25a:             new DatabaseClassLoadingTest("testLoginTimeoutNotInClasspath"));
1:f40e25a: 
1:f40e25a:         // All of this should be done with a login timeout. Set the timeout
1:f40e25a:         // to a high value, so that the connection attempts don't actually
1:f40e25a:         // time out.
1:f40e25a:         return new LoginTimeoutTestSetup(suite, 100);
1:f40e25a:     }
1:f40e25a: 
1:c722b36:     /**
1:36d1b35:      * Test the routines fail before the jars that contain their
1:36d1b35:      * code have been installed and/or set in the classpath.
1:36d1b35:      * @throws SQLException
1:0298580:      */
1:36d1b35:     public void testWithNoInstalledJars() throws SQLException {
1:e1e7492:         try {
1:36d1b35:             prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:36d1b35:             fail("prepareCall on procedure with path to class");
2:36d1b35:         } catch (SQLException e) {
1:36d1b35:             assertSQLState("42X51", e);
1:4a08a15:         }
1:e1e7492:         try {
1:36d1b35:             prepareStatement("VALUES EMC.GETARTICLE(?)");
1:36d1b35:             fail("prepareCall on function with path to class");
1:36d1b35:         } catch (SQLException e) {
1:36d1b35:             assertSQLState("42X51", e);
1:cef7d1e:         }
1:36d1b35:     }
1:0298580:     
1:0298580:     /**
1:66f66a1:      * Test the sqlj procedures without setting any database
1:66f66a1:      * classpath. This allows testing with the security manager
1:66f66a1:      * without hitting the bugs that exist when the database class path
1:66f66a1:      * is set with the security manager.
1:66f66a1:      */
1:66f66a1:     public void testJarHandling() throws SQLException, MalformedURLException
1:66f66a1:     {       
1:66f66a1:         installJar("dcl_emc1.jar", "EMC.MAIL_APP_JHT");
1:66f66a1:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP_JHT");
1:66f66a1:         removeJar("EMC.MAIL_APP_JHT");
1:66f66a1:     }
1:66f66a1:     
1:66f66a1:     /**
1:36d1b35:      * Install the jar, but don't set the classpath.
1:36d1b35:      * @throws SQLException
1:3cfc857:      * @throws MalformedURLException 
1:36d1b35:      */
1:3cfc857:     public void testWithNoClasspath() throws SQLException, MalformedURLException
1:36d1b35:     {       
1:e1e7492:         installJar("dcl_emc1.jar", "EMC.MAIL_APP");
1:36d1b35:         testWithNoInstalledJars();
1:36d1b35:     }
1:0298580:     
1:cef7d1e:     /**
1:36d1b35:      * Set the classpath to include the MAIL_APP jar.
1:36d1b35:      * @throws SQLException
1:36d1b35:      */
1:36d1b35:     public void testSetClasspath() throws SQLException
1:36d1b35:     {
1:36d1b35:         setDBClasspath("EMC.MAIL_APP");
1:3cfc857:         
1:36d1b35:         // Test we don't need a re-boot to see the new classes.
1:36d1b35:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:36d1b35:         cs.setInt(1, 0);
1:36d1b35:         cs.setString(2, "now@classpathchange.com");
2:36d1b35:         cs.executeUpdate();
2:36d1b35:         cs.close();
1:66f66a1:         
1:36d1b35:         derby2035Workaround();
1:0298580:     }
1:66f66a1:     
1:0298580:     /**
1:36d1b35:      * Test that a new connection successfully sees the changes.
1:36d1b35:      * @throws SQLException
1:36d1b35:      */
1:36d1b35:     public void testAddContact() throws SQLException
1:0298580:     {
1:36d1b35:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:36d1b35:         cs.setInt(1, 1);
1:36d1b35:         cs.setString(2, "bill@ruletheworld.com");
1:36d1b35:         cs.executeUpdate();
1:66f66a1:         
1:36d1b35:         cs.setInt(1, 2);
1:36d1b35:         cs.setString(2, "penguin@antartic.com");
1:36d1b35:         cs.executeUpdate();
1:0298580:         
1:36d1b35:         cs.close();
1:0298580:         
1:36d1b35:         Statement s = createStatement();
1:36d1b35:         ResultSet rs = s.executeQuery(
1:36d1b35:                 "SELECT id, e_mail from EMC.CONTACTS ORDER BY 1");
1:0298580:         
1:36d1b35:         JDBC.assertFullResultSet(rs,
1:36d1b35:                 new String[][] {
1:36d1b35:                 {"0", "now@classpathchange.com"},
1:36d1b35:                 {"1", "bill@ruletheworld.com"},
1:36d1b35:                 {"2", "penguin@antartic.com"},
1:3cfc857:                 });
1:0298580:         
1:c722b36:         s.close();
1:0298580:     }
1:f40e25a:     
1:36d1b35:     public void testGetResource() throws SQLException
1:36d1b35:     {
1:0298580:         getResourceTests(getConnection());
1:0298580:     }
1:0298580:     
1:0298580:     private static void getResourceTests(Connection conn) throws SQLException
1:0298580:     {
1:0298580:         PreparedStatement ps = conn.prepareStatement("VALUES EMC.GETARTICLE(?)");
1:0298580:         
1:36d1b35:         // Simple path should be prepended with the package name
1:36d1b35:         // of the class executing the code to find
1:36d1b35:         // /org/apache/derbyTesting/databaseclassloader/graduate.txt
1:36d1b35:         ps.setString(1, "graduate.txt");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:36d1b35:                 "The Apache Foundation has released the first version of " +
1:36d1b35:                 "the open-source Derby database, which also gained support " +
1:36d1b35:                 "from Sun Microsystems.");
1:3cfc857:         
1:e1e7492: 
1:36d1b35:         // absolute path within the jar.
1:36d1b35:         ps.setString(1, "/article/release.txt");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:36d1b35:                 "The Apache Derby development community is pleased to announce " +
1:36d1b35:                 "its first release after graduating from the Apache Incubator, " +
1:36d1b35:                 "Apache Derby 10.1.1.0.");
1:e1e7492:         
1:e1e7492:         
1:36d1b35:         // Resources that don't exist, returns NULL.
1:36d1b35:         ps.setString(1, "barney.txt");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:36d1b35:         ps.setString(1, "/article/fred.txt");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:e1e7492:     
1:36d1b35:         // Accessing the class file is disallowed as well by
1:36d1b35:         // returning a NULL
1:36d1b35:         ps.setString(1, "emc.class");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:36d1b35:         ps.setString(1, "/org/apache/derbyTesting/databaseclassloader/emc.class");
1:36d1b35:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:e1e7492:         
1:36d1b35:         ps.close();
1:36d1b35:     }
1:e1e7492:     
1:f40e25a:     /**
1:cef7d1e:      * Alter the table to add a column, the add contact procedure
1:cef7d1e:      * should still work.
1:cef7d1e:      * @throws SQLException
1:cef7d1e:      */
1:cef7d1e:     public void testAlterTable() throws SQLException
1:cef7d1e:     {
1:cef7d1e:         Statement s = createStatement();
1:cef7d1e:         s.executeUpdate("ALTER TABLE EMC.CONTACTS ADD COLUMN OK SMALLINT");
1:cef7d1e:         JDBC.assertFullResultSet(
1:cef7d1e:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:cef7d1e:                 new String[][] {
1:cef7d1e:                     {"0", "now@classpathchange.com", null},
1:cef7d1e:                     {"1", "bill@ruletheworld.com", null},
1:cef7d1e:                     {"2", "penguin@antartic.com", null},
1:cef7d1e:                     });
1:cef7d1e:         
1:cef7d1e:         // well written application, INSERT used explicit column names
1:cef7d1e:         // ok defaults to NULL
1:cef7d1e:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:cef7d1e:         cs.setInt(1, 3);
1:cef7d1e:         cs.setString(2, "big@blue.com");
1:cef7d1e:         cs.executeUpdate();
1:cef7d1e:         cs.close();
1:cef7d1e: 
1:cef7d1e:         JDBC.assertFullResultSet(
1:cef7d1e:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:cef7d1e:                 new String[][] {
1:cef7d1e:                     {"0", "now@classpathchange.com", null},
1:cef7d1e:                     {"1", "bill@ruletheworld.com", null},
1:cef7d1e:                     {"2", "penguin@antartic.com", null},
1:cef7d1e:                     {"3", "big@blue.com", null},
1:cef7d1e:                     });
1:cef7d1e:       
1:cef7d1e:         s.close();
1:cef7d1e:     }
1:cef7d1e:     
1:e1e7492:     /**
1:e1e7492:      * check the roll back of class loading.
1:e1e7492:      * install a new jar in a transaction, see
1:e1e7492:      * that the new class is used and then rollback
1:e1e7492:      * the old class should be used after the rollback.
1:e1e7492:      * @throws SQLException
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testClassPathRollback() throws SQLException, MalformedURLException
1:e1e7492:     {        
1:e1e7492:         getConnection().setAutoCommit(false);
1:e1e7492:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP");
1:e1e7492: 
1:e1e7492:         
1:e1e7492:         // This version checks the e-mail address.
1:e1e7492:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:e1e7492:         cs.setInt(1, 99);
1:e1e7492:         cs.setString(2, "wormspam@soil.com");
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         
1:e1e7492:         Statement s = createStatement();
1:e1e7492:         
1:e1e7492:         JDBC.assertFullResultSet(
1:e1e7492:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS WHERE ID = 99"),
1:e1e7492:                 new String[][] {
1:e1e7492:                     {"99", "wormspam@soil.com", "0"},
1:e1e7492:                     });
1:e1e7492:         
1:e1e7492:         rollback();
1:e1e7492:         getConnection().setAutoCommit(true);
1:e1e7492:         
1:e1e7492:         // execute again but reverted to the version that does not
1:e1e7492:         // check the email address.
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         cs.close();
1:e1e7492: 
1:e1e7492:          JDBC.assertFullResultSet(
1:e1e7492:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS WHERE ID = 99"),
1:e1e7492:                 new String[][] {
1:e1e7492:                     {"99", "wormspam@soil.com", null},
1:e1e7492:                     });
1:e1e7492:          
1:e1e7492:          s.executeUpdate("DELETE FROM EMC.CONTACTS WHERE ID = 99");
1:e1e7492:          s.close();
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * Replace the jar to later test the prepare from a different
1:e1e7492:      * connection picks up the new version.
1:e1e7492:      * @throws SQLException
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testReplaceJar() throws SQLException, MalformedURLException
1:e1e7492:     {
1:e1e7492:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP");
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * Change of class due to testReplaceJar that
1:e1e7492:      * changes the application to run checks on the e-mail
1:e1e7492:      * to ensure it is valid (in this case by seeing if
1:e1e7492:      *  it simply includes 'spam' in the title).
1:e1e7492:      * @throws SQLException
1:e1e7492:      */
1:e1e7492:     public void testReplacedClass() throws SQLException {
1:e1e7492:         // This version checks the e-mail address.
1:e1e7492:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:e1e7492:         cs.setInt(1, 4);
1:e1e7492:         cs.setString(2, "spammer@ripoff.com");
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         cs.setInt(1, 5);
1:e1e7492:         cs.setString(2, "open@source.org");
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         
1:e1e7492:         Statement s = createStatement();
1:e1e7492:         JDBC.assertFullResultSet(
1:e1e7492:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:e1e7492:                 new String[][] {
1:e1e7492:                     {"0", "now@classpathchange.com", null},
1:e1e7492:                     {"1", "bill@ruletheworld.com", null},
1:e1e7492:                     {"2", "penguin@antartic.com", null},
1:e1e7492:                     {"3", "big@blue.com", null},
1:e1e7492:                     {"4", "spammer@ripoff.com", "0"},
1:e1e7492:                     {"5", "open@source.org", "1"},
1:e1e7492:                     });
1:e1e7492:       
1:e1e7492:         s.close();
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * now add another jar in to test two jars and
1:e1e7492:      * a quoted identifer for the jar names.
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testSecondJar() throws SQLException, MalformedURLException {
1:e1e7492:         
1:e1e7492:         installJar("dcl_emcaddon.jar", "\"emcAddOn\".\"MailAddOn\"");
1:e1e7492: 
1:e1e7492:         setDBClasspath("EMC.MAIL_APP:\"emcAddOn\".\"MailAddOn\"");
1:e1e7492:         Statement s = createStatement();
1:e1e7492:         JDBC.assertFullResultSet(
1:e1e7492:                 s.executeQuery("SELECT E_MAIL, \"emcAddOn\".VALIDCONTACT(E_MAIL) FROM EMC.CONTACTS ORDER BY 1"),
1:e1e7492:                 new String[][] {
1:e1e7492:                     {"big@blue.com", "0"},
1:e1e7492:                     {"bill@ruletheworld.com", "0"},
1:e1e7492:                     {"now@classpathchange.com", "0"},
1:e1e7492:                     {"open@source.org", "1"},
1:e1e7492:                     {"penguin@antartic.com", "0"},
1:e1e7492:                     {"spammer@ripoff.com", "0"},
1:e1e7492:                     });
1:e1e7492:       
1:e1e7492:         s.close();
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * Test to see if the jar signatures can be obtained from the jar file.
1:e1e7492:      * The jar was signed with a self signed certificate
1:e1e7492:      * <code>
1:e1e7492:         keytool -delete -alias emccto -keystore emcks -storepass ab987c
1:e1e7492:         keytool -genkey -dname "cn=EMC CTO, ou=EMC APP, o=Easy Mail Company, c=US" -alias emccto -keypass kpi135 -keystore emcks -storepass ab987c
1:e1e7492:         keytool -selfcert -alias emccto -keypass kpi135 -validity 36500 -keystore emcks -storepass ab987c
1:e1e7492:         keytool -keystore emcks -storepass ab987c -list -v
1:e1e7492:         jarsigner -keystore emcks -storepass ab987c -keypass kpi135 -signedjar dcl_emc2s.jar dcl_emc2.jar emccto
1:e1e7492:         keytool -delete -alias emccto -keystore emcks -storepass ab987c
1:e1e7492:         </code>
1:e1e7492:      * @throws SQLException
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testSignedJar() throws SQLException, MalformedURLException
1:e1e7492:     {
1:e1e7492:         // Statement to get the signers for a class loaded from a jar file
1:e1e7492:         PreparedStatement ps = prepareStatement("VALUES EMC.GETSIGNERS(?)");
1:e1e7492:         
1:e1e7492:         // current jar is unsigned.
1:e1e7492:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.emc");      
1:e1e7492:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:e1e7492:         
1:e1e7492:         // replace with a signed jar
1:e1e7492:         replaceJar("dcl_emc2s.jar", "EMC.MAIL_APP");
1:0298580:         
1:e1e7492:         ps.close();
1:e1e7492:         
1:0298580:         signersTests(getConnection());
1:0298580:         
1:0298580:     }
1:0298580:     
1:0298580:     private static void signersTests(Connection conn) throws SQLException
1:0298580:     {
1:0298580:         PreparedStatement ps = conn.prepareStatement("VALUES EMC.GETSIGNERS(?)");
1:e1e7492:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.emc");    
1:e1e7492:         
1:e1e7492:         // now class is signed
1:e1e7492:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:e1e7492:                 "CN=EMC CTO, OU=EMC APP, O=Easy Mail Company, C=US");
1:e1e7492:         
1:e1e7492:         // verify the other jar is still not signed
1:e1e7492:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.addon.vendor.util");
1:e1e7492:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:e1e7492: 
1:e1e7492:         ps.close();
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * Replace the signed jar with a hacked jar. emc.class modified to diable
1:e1e7492:      * valid e-mail address check but using same signatures within jar.
1:e1e7492:      * Class loader should reject.
1:e1e7492:      * 
1:e1e7492:      * rejects it.
1:e1e7492:      * @throws SQLException
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testHackedJarReplacedClass() throws SQLException, MalformedURLException {
1:e1e7492: 
1:e1e7492:         replaceJar("dcl_emc2sm.jar", "EMC.MAIL_APP");
1:e1e7492:         
1:0298580:         try {
1:e1e7492:             CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:e1e7492:             cs.setInt(1, 99);
1:e1e7492:             cs.setString(2, "spamking@cracker.org");
1:e1e7492:             cs.executeUpdate();
1:e1e7492:             cs.close();
1:e1e7492:             fail("procedure call worked on hacked jar");
1:e1e7492:         } catch (SQLException e) {
1:e1e7492:             assertSQLState("Class load should fail due to invalid signature", "42X51", e);
1:e1e7492:         }
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     /**
1:e1e7492:      * replace with a hacked jar file, emc.class modified to 
1:e1e7492:      be an invalid class (no signing on this jar).
1:3cfc857:      * @throws MalformedURLException 
1:e1e7492:      */
1:3cfc857:     public void testInvalidJar() throws SQLException, MalformedURLException
1:e1e7492:     {
1:e1e7492:         replaceJar("dcl_emc2l.jar", "EMC.MAIL_APP");
1:e1e7492:         
1:0298580:         try {
1:e1e7492:             CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:e1e7492:             cs.setInt(1, 999);
1:e1e7492:             cs.setString(2, "spamking2@cracker.org");
1:e1e7492:             cs.executeUpdate();
1:e1e7492:             cs.close();
1:e1e7492:             fail("procedure call worked on invalid jar");
1:e1e7492:         } catch (SQLException e) {
1:e1e7492:             assertSQLState("Class load should fail due to invalid jar", "42X51", e);
1:e1e7492: 
1:e1e7492:         }        
1:e1e7492:     }
1:e1e7492:     
1:e1e7492:     public void testRemoveJar() throws SQLException
1:e1e7492:     {
1:e1e7492:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");
1:e1e7492:         
1:e1e7492:         cs.setString(1, "EMC.MAIL_APP");
1:e1e7492:         
1:e1e7492:         // fail if jar is on classpath
1:e1e7492:         try {
1:e1e7492:             cs.executeUpdate();
1:e1e7492:             fail("REMOVE_JAR on jar in derby.database.classpath worked");
1:e1e7492:         } catch (SQLException e) {
1:e1e7492:             assertSQLState("X0X07", e);
1:e1e7492:         }
1:e1e7492:         
1:e1e7492:         // remove from classpath 
1:e1e7492:         setDBClasspath("\"emcAddOn\".\"MailAddOn\"");
1:e1e7492:         testWithNoInstalledJars();
1:e1e7492:         cs.executeUpdate();      
1:e1e7492:         testWithNoInstalledJars();
1:e1e7492:         
1:e1e7492:         // remove the second jar
1:e1e7492:         setDBClasspath(null);
1:e1e7492:         cs.setString(1, "\"emcAddOn\".\"MailAddOn\"");
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         
1:e1e7492:         cs.close();
1:e1e7492:     }
1:e1e7492:     
1:36d1b35:     /**
1:0298580:      * Create a Jar of the current database.
1:0298580:      * @throws Exception 
1:0298580:      *
1:0298580:      */
1:0298580:     public void testCreateDatabaseJar() throws Exception
1:0298580:     {
1:0298580:         CallableStatement cs = prepareCall(
1:0298580:                 "CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:0298580:         cs.executeUpdate();
1:0298580:         cs.close();
1:0298580:         
1:0298580:         cs = prepareCall(
1:0298580:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT(?)");
1:0298580:         
1:0298580:         final File backupDir = SupportFilesSetup.getReadWrite("dbreadonly");
1:0298580:         
1:0298580:         cs.setString(1, backupDir.getPath());
1:0298580:         cs.executeUpdate();
1:0298580: 
1:0298580:         cs.close();
1:0298580:         
1:3df869c:         final String db = getTestConfiguration().getDefaultDatabaseName();
1:0298580:         AccessController.doPrivileged
1:3f5c48a:         (new java.security.PrivilegedExceptionAction<Void>() {
1:3f5c48a:             public Void run() throws Exception {
1:0298580:                 createArchive("dclt.jar", new File(backupDir, db), "dbro");;
1:0298580:               return null;
1:0298580:             }
1:0298580:         });
1:0298580:         
1:0298580:     }
1:0298580:     
1:0298580:     /**
1:0298580:      * Test the jar'ed up database created by testCreateDatabaseJar
1:0298580:      * accessing the database using the jar(path to archive)db form
1:0298580:      * of database name.
1:0298580:      */
1:0298580:     public void testDatabaseInJar() throws SQLException
1:0298580:     {
1:0298580:         File jarFile = SupportFilesSetup.getReadOnly("dclt.jar");
1:9f1b314:         String dbName = "jar:(" +
1:9f1b314:                 PrivilegedFileOpsForTests.getAbsolutePath(jarFile) + ")dbro";
1:0298580:         
1:0298580:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:0298580:         
2:0298580:         readOnlyTest(ds);
1:0298580:     }
1:0298580:     
1:4a08a15:     public void testDatabaseInClasspath() throws SQLException
1:0298580:     {
1:0298580:         String dbName = "classpath:dbro";
1:0298580:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:4a08a15:         readOnlyTest(ds);
1:0298580:     }
1:0298580:     
1:0298580:     /**
1:46ecfcf:      * Load a java.sql class indirectly (ie. through a valid class
1:46ecfcf:      * in the installed jar file) from the jar file.
1:46ecfcf:      */
1:46ecfcf:     public void testLoadJavaClassIndirectly() throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         loadJavaClass(
1:46ecfcf:                 "org.apache.derbyTesting.databaseclassloader.cracker.C1.simple",
1:46ecfcf:                 "38000");
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:46ecfcf:      * Load a java.sql class directly (ie. through a direct procedure call)
1:46ecfcf:      * from the jar file.
1:46ecfcf:      */    
1:46ecfcf:     public void testLoadJavaClassDirectly() throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         loadJavaClass("java.sql.J1.simple", "XJ001");
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:46ecfcf:      * Load a java.derby99 class directly (ie. through a direct procedure call)
1:46ecfcf:      * from the jar file. This is to see if additional non-standard java.* packages
1:46ecfcf:      * can be added into the JVM
1:46ecfcf:      */    
1:46ecfcf:     public void testLoadJavaClassDirectly2() throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         loadJavaClass("java.derby99.J2.simple", "XJ001");
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:46ecfcf:      * Load a javax.derby99 class directly (ie. through a direct procedure call)
1:46ecfcf:      * from the jar file. This is to see if additional non-standard javax.* packages
1:46ecfcf:      * can be added into the JVM. As an implementation note this is blocked
1:46ecfcf:      * by Derby's class loader, not the JVM's security mechanism.
1:46ecfcf:      */    
1:46ecfcf:     public void testLoadJavaClassDirectly3() throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         loadJavaClass("javax.derby99.J3.simple", "XJ001");
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:46ecfcf:      * Load a org.apache.derby class directly (ie. through a direct procedure call)
1:46ecfcf:      * from the jar file. As an implementation note this is blocked
1:46ecfcf:      * by Derby's class loader, not the JVM's security mechanism.
1:46ecfcf:      */    
1:46ecfcf:     public void testLoadDerbyClassIndirectly() throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         loadJavaClass(
1:46ecfcf:                 "org.apache.derbyTesting.databaseclassloader.cracker.C1.derby",
1:46ecfcf:                 "38000");
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:46ecfcf:      * Test loading classes in the java. and javax. namespaces
1:46ecfcf:      * from a jar, it should be disallowed or be ignored. These tests
1:46ecfcf:      * are run as separate fixtures to ensure the failed loading
1:46ecfcf:      * does not affect subsequent attempts to load.
1:46ecfcf:      * @throws MalformedURLException 
1:46ecfcf:      */
1:46ecfcf:     private void loadJavaClass(String method, String expectedSQLState)
1:46ecfcf:         throws SQLException, MalformedURLException
1:46ecfcf:     {
1:46ecfcf:         String jarName = "EMC.MY_JAVA";
1:46ecfcf:         
1:46ecfcf:         installJar("dcl_java.jar", jarName);
1:46ecfcf:         setDBClasspath(jarName);
1:46ecfcf:         
1:46ecfcf:         Statement s = createStatement();
1:46ecfcf:         s.execute("CREATE PROCEDURE C1() LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:46ecfcf:                 "NO SQL EXTERNAL NAME " +
1:46ecfcf:                 "'" + method + "'");
1:46ecfcf:        
1:46ecfcf:         try {
1:46ecfcf:             s.execute("CALL C1()");
1:46ecfcf:             fail("Call to procedure loading java class from installed jar");
1:46ecfcf:         } catch (SQLException sqle)
1:46ecfcf:         {
1:46ecfcf:             assertSQLState(expectedSQLState, sqle);
1:46ecfcf:         }
1:46ecfcf:         
1:46ecfcf:         s.execute("DROP PROCEDURE C1");
1:46ecfcf:         s.close();
1:46ecfcf:         setDBClasspath(null);
1:46ecfcf:         removeJar(jarName);
1:46ecfcf: 
1:46ecfcf:     }
1:46ecfcf:     
1:46ecfcf:     /**
1:0298580:      * Run an number of statements against a jar'ed database to
1:0298580:      * ensure it is read-only and that class loading works from
1:0298580:      * jar files embedded in jar'ed up databases.
1:0298580:      */
1:0298580:     private static void readOnlyTest(DataSource ds) throws SQLException
1:0298580:     {
1:0298580:         try {
1:0298580:             Connection conn = ds.getConnection();
1:0298580:             Statement s = conn.createStatement();
1:0298580:             
1:0298580:             JDBC.assertFullResultSet(
1:0298580:                     s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:0298580:                     new String[][] {
1:0298580:                         {"0", "now@classpathchange.com", null},
1:0298580:                         {"1", "bill@ruletheworld.com", null},
1:0298580:                         {"2", "penguin@antartic.com", null},
1:0298580:                         {"3", "big@blue.com", null},
1:0298580:                         {"4", "spammer@ripoff.com", "0"},
1:0298580:                         {"5", "open@source.org", "1"},
1:0298580:                         });
1:0298580:             
1:0298580:             JDBC.assertFullResultSet(
1:0298580:                     s.executeQuery("SELECT id, e_mail, \"emcAddOn\".VALIDCONTACT(e_mail) from EMC.CONTACTS ORDER BY 1"),
1:0298580:                     new String[][] {
1:0298580:                         {"0", "now@classpathchange.com", "0"},
1:0298580:                         {"1", "bill@ruletheworld.com", "0"},
1:0298580:                         {"2", "penguin@antartic.com", "0"},
1:0298580:                         {"3", "big@blue.com", "0"},
1:0298580:                         {"4", "spammer@ripoff.com", "0"},
1:0298580:                         {"5", "open@source.org", "1"},
1:0298580:                         });
1:0298580:                        
1:0298580:             assertStatementError("25502", s,
1:0298580:                     "INSERT INTO EMC.CONTACTS values(3, 'no@is_read_only.gov', NULL)");
1:0298580:             assertStatementError("25502", s,
1:0298580:                     "CALL EMC.ADDCONTACT(3, 'really@is_read_only.gov')");
1:0298580: 
1:5a15941:             getResourceTests(conn);
1:0298580:             
1:6819612:             // DERBY-553: Disabled on Java 5 due to JVM bug
1:6819612:             // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6284489
1:6819612:             if (!isJava5()) {
1:6819612:                 signersTests(conn);
1:6819612:             }
1:0298580:             
1:0298580:             // ensure that a read-only database automatically gets table locking
1:0298580:             conn.setAutoCommit(false);
1:0298580:             JDBC.assertDrainResults(
1:0298580:                     s.executeQuery("select * from EMC.CONTACTS WITH RR"));
1:0298580:             
1:0298580:             JDBC.assertFullResultSet(
1:0298580:                     s.executeQuery(
1:0298580:                          "select TYPE, MODE, TABLENAME from syscs_diag.lock_table"),
1:0298580:                     new String[][] {
1:0298580:                         {"TABLE", "S", "CONTACTS"},
1:0298580:                         });
1:0298580:  
1:0298580:             s.close();
1:0298580:             conn.rollback();
1:0298580:             conn.setAutoCommit(true);
1:0298580:             conn.close();
2:0298580:         } finally {
1:0298580:             JDBCDataSource.shutdownDatabase(ds);
1:0298580:         }
1:0298580:     }
1:0298580:     
1:36d1b35:     /**
1:c722b36:      * Test ordering of class loading.
1:c722b36:      * @throws MalformedURLException 
1:c722b36:      */
1:c722b36:     public void testClassLoadOrdering() throws SQLException, MalformedURLException
1:c722b36:     {
1:c722b36:         Statement s = createStatement();
1:c722b36:         
1:c722b36:         s.executeUpdate("CREATE SCHEMA OT");
1:c722b36:         
1:c722b36:         // Functions to get the class loader of a specific class.
1:c722b36:         // Thre variants that are loaded out of each installed jar
1:c722b36:         // file to ensure that loading is delegated from one jar
1:c722b36:         // to another correctly.
1:c722b36:         // We use the added feature that the toString() of the
1:c722b36:         // ClassLoader for installed jars returns the jar name
1:c722b36:         // first. The RETURNS VARCHAR(10) trims the string to
1:c722b36:         // the correct length for our compare purposes, ie. the
1:c722b36:         // length of "OT"."OT{1,2,3}"
1:c722b36:         s.execute("create function OT.WHICH_LOADER1(classname VARCHAR(256)) " +
1:c722b36:         "RETURNS VARCHAR(10) " +
1:c722b36:         "NO SQL " +
1:c722b36:         "external name " +
1:c722b36:         "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest1.whichLoader' " +
1:c722b36:         "language java parameter style java");
1:c722b36:         
1:c722b36:         s.execute("create function OT.WHICH_LOADER2(classname VARCHAR(256)) " +
1:c722b36:                 "RETURNS VARCHAR(10) " +
1:c722b36:                 "NO SQL " +
1:c722b36:                 "external name " +
1:c722b36:                 "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest2.whichLoader' " +
1:c722b36:                 "language java parameter style java");
1:c722b36: 
1:c722b36:         s.execute("create function OT.WHICH_LOADER3(classname VARCHAR(256)) " +
1:c722b36:                 "RETURNS VARCHAR(10) " +
1:c722b36:                 "NO SQL " +
1:c722b36:                 "external name " +
1:c722b36:                 "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest3.whichLoader' " +
1:c722b36:                 "language java parameter style java");
1:c722b36: 
1:c722b36: 
1:c722b36:         installJar("dcl_ot1.jar", "OT.OT1");
1:c722b36:         installJar("dcl_ot2.jar", "OT.OT2");
1:c722b36:         installJar("dcl_ot3.jar", "OT.OT3");
1:31d9b6f:               
1:31d9b6f:         checkLoading("123");
1:31d9b6f:         checkLoading("132");
1:31d9b6f:         checkLoading("213");
1:31d9b6f:         checkLoading("231");
1:31d9b6f:         checkLoading("321");
1:31d9b6f:         checkLoading("312");
1:31d9b6f: 
1:31d9b6f:         s.close();
1:31d9b6f:         
1:31d9b6f:     }
1:c722b36:     
1:31d9b6f:     /**
1:31d9b6f:      * Run a number of tests to ensure classes are loaded
1:31d9b6f:      * from the correct class loader. The order of loading
1:31d9b6f:      * the entry point classes is set by order. 123 will
1:31d9b6f:      * load the entry point classes in order OrderTest1, OrderTest2,
1:31d9b6f:      * OrderTest3. Since loading these entry point classes and
1:31d9b6f:      * the order of execution will determine the loading order
1:31d9b6f:      * of the other classes, we change the order to ensure
1:31d9b6f:      * that classes are loaded from the correct jar regardless
1:31d9b6f:      * of which class loaded it. Ie. Loading OrderTest2 first, which
1:31d9b6f:      * loads indirectly OrderObject1,2,3 ensures that even though
1:31d9b6f:      * OrderTest2 is loaded from OT2 that the others are loaded
1:31d9b6f:      * from their correct jar.
1:31d9b6f:      * 
1:31d9b6f:      * @param order Order the entry point classes will be loaded.
1:31d9b6f:      * 
1:31d9b6f:      */
1:31d9b6f:     private void checkLoading(String order) throws SQLException
1:31d9b6f:     {
1:c722b36:         setDBClasspath("OT.OT1:OT.OT2:OT.OT3");
1:c722b36:         
1:c722b36:         PreparedStatement ps1 = prepareStatement(
1:31d9b6f:             "VALUES OT.WHICH_LOADER" + order.charAt(0) +"(?)");
1:c722b36:         PreparedStatement ps2 = prepareStatement(
1:31d9b6f:                 "VALUES OT.WHICH_LOADER" + order.charAt(1) +"(?)");
1:c722b36:         PreparedStatement ps3 = prepareStatement(
1:31d9b6f:                 "VALUES OT.WHICH_LOADER" + order.charAt(2) +"(?)");
1:c722b36:         
1:c722b36:         // Tests the classes loaded as a direct entry point for a routine
1:c722b36:         checkCorrectLoader("OrderTest1", ps1, ps2, ps3);
1:c722b36:         checkCorrectLoader("OrderTest2", ps1, ps2, ps3);
1:c722b36:         checkCorrectLoader("OrderTest3", ps1, ps2, ps3);
1:c722b36:         
1:c722b36:         // Tests the classes loaded directly (Class.forName()) by
1:c722b36:         // code in an installed jar file.
1:c722b36:         checkCorrectLoader("OrderLoad1", ps1, ps2, ps3);
1:c722b36:         checkCorrectLoader("OrderLoad2", ps1, ps2, ps3);
1:c722b36:         checkCorrectLoader("OrderLoad3", ps1, ps2, ps3);
1:31d9b6f:         
1:31d9b6f:         // Tests the classes loaded indirectly by
1:31d9b6f:         // code in an installed jar file.
1:31d9b6f:         checkCorrectLoader("OrderObject1", ps1, ps2, ps3);
1:31d9b6f:         checkCorrectLoader("OrderObject2", ps1, ps2, ps3);
1:31d9b6f:         checkCorrectLoader("OrderObject3", ps1, ps2, ps3);
1:31d9b6f:                 
1:c722b36:         ps1.close();
1:c722b36:         ps2.close();
1:c722b36:         ps3.close();
1:c722b36:         
1:31d9b6f:         // reset the classpath to enforce the classes are loaded again
1:31d9b6f:         // on the next attempt.
1:31d9b6f:         setDBClasspath(null);
1:c722b36:     }
1:c722b36:     
1:c722b36:     private void checkCorrectLoader(String className,
1:c722b36:             PreparedStatement ps1,
1:c722b36:             PreparedStatement ps2,
1:c722b36:             PreparedStatement ps3)
1:c722b36:        throws SQLException
1:c722b36:     {
1:c722b36:         className = "org.apache.derbyTesting.databaseclassloader.ot." + className;
1:c722b36:         String expectedLoader = 
1:c722b36:             "\"OT\".\"OT" + className.charAt(className.length() -1) + "\"";
1:c722b36:         
1:c722b36:         ps1.setString(1, className);
1:c722b36:         JDBC.assertSingleValueResultSet(ps1.executeQuery(), expectedLoader);
1:c722b36:         
1:c722b36:         ps2.setString(1, className);
1:c722b36:         JDBC.assertSingleValueResultSet(ps2.executeQuery(), expectedLoader);
1:c722b36: 
1:c722b36:         ps3.setString(1, className);
1:c722b36:         JDBC.assertSingleValueResultSet(ps3.executeQuery(), expectedLoader);
1:c722b36:     }
1:01ab42f:     
1:01ab42f:     /**
1:01ab42f:      * Test that loading of Derby's internal classes from
1:01ab42f:      * an installed jar file is disallowed.
1:01ab42f:      */
1:01ab42f:     public void testIndirectLoading() throws SQLException, MalformedURLException
1:01ab42f:     {
1:01ab42f:         Statement s = createStatement();
1:01ab42f:         
1:01ab42f:         s.executeUpdate("CREATE SCHEMA ID");
1:01ab42f:  /*       
1:01ab42f:         s.execute("create function OT.WHICH_LOADER1(classname VARCHAR(256)) " +
1:01ab42f:         "RETURNS VARCHAR(10) " +
1:01ab42f:         "NO SQL " +
1:01ab42f:         "external name " +
1:01ab42f:         "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest1.whichLoader' " +
1:01ab42f:         "language java parameter style java");
1:01ab42f: */
1:01ab42f:         installJar("dcl_id.jar", "ID.IDCODE");
1:01ab42f:         
1:01ab42f:         setDBClasspath("ID.IDCODE");
1:01ab42f:         
1:01ab42f:         // Create a procedure that is a method in an installed jar file
1:01ab42f:         // that calls the internal static method to set a database property.
1:01ab42f:         // If a user could do this then they bypass the grant/revoke on
1:01ab42f:         // the system procedure and instead are able to control the database
1:01ab42f:         // as they please.
1:01ab42f:         s.execute("CREATE PROCEDURE ID.SETDB(pkey VARCHAR(256), pvalue VARCHAR(256)) " +
1:01ab42f:                 "NO SQL " +
1:01ab42f:                 "external name " +
1:01ab42f:                 "'org.apache.derbyTesting.databaseclassloader.id.IndirectLoad.setDB' " +
1:01ab42f:                 "language java parameter style java");
1:01ab42f:         
1:01ab42f:         PreparedStatement ps = prepareCall("CALL ID.SETDB(?, ?)");
1:01ab42f: 
1:01ab42f:         ps.close();
1:01ab42f: 
1:01ab42f:         
1:01ab42f:         setDBClasspath(null);
1:01ab42f: 
1:01ab42f:               
1:01ab42f: 
1:01ab42f:         s.close();
1:01ab42f:         
1:01ab42f:     }
1:01ab42f: 
1:36d1b35:     /**
1:4d0fc78:      * Test that table functions can be invoked from inside jar files stored in
1:4d0fc78:      * the database.
1:4d0fc78:      */
1:4d0fc78:     public void testTableFunctionInJar() throws SQLException, MalformedURLException
1:4d0fc78:     {
1:4d0fc78:         String jarName = "EMC.DUMMY_VTI";
1:4d0fc78: 
1:4d0fc78:         installJar("dummy_vti.jar", jarName );
1:4d0fc78: 
1:4d0fc78:         setDBClasspath( jarName );
1:b3834d3: 
1:4d0fc78:         Statement s = createStatement();
1:4d0fc78: 
1:4d0fc78:         // register a scalar function
1:4d0fc78:         s.executeUpdate
1:4d0fc78:             (
1:4d0fc78:              "create function reciprocal( original double ) returns double\n" +
1:4d0fc78:              "language java\n" +
1:4d0fc78:              "parameter style java\n" +
1:4d0fc78:              "no sql\n" +
1:4d0fc78:              "external name 'DummyVTI.reciprocal'"
1:4d0fc78:              );
1:4d0fc78: 
1:4d0fc78:         // register the table function
1:4d0fc78:         s.executeUpdate
1:4d0fc78:             (
1:4d0fc78:              "create function dummyVTI()\n" +
1:4d0fc78:              "returns table( tablename varchar( 128 ) )\n" +
1:4d0fc78:              "language java\n" +
1:4d0fc78:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:4d0fc78:              "reads sql data\n" +
1:4d0fc78:              "external name 'DummyVTI.dummyVTI'\n"
1:4d0fc78:              );
1:4d0fc78: 
1:4d0fc78:         // register another table function in a class which doesn't exist
1:4d0fc78:         s.executeUpdate
1:4d0fc78:             (
1:4d0fc78:              "create function dummyVTI2()\n" +
1:4d0fc78:              "returns table( tablename varchar( 128 ) )\n" +
1:4d0fc78:              "language java\n" +
1:4d0fc78:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:4d0fc78:              "reads sql data\n" +
1:a7016bf:              "external name 'MissingClass.dummyVTI'\n"
1:4d0fc78:              );
1:4d0fc78: 
1:4d0fc78:         // invoke the scalar function
1:4d0fc78:         JDBC.assertFullResultSet(
1:4d0fc78:                 s.executeQuery
1:4d0fc78:                 (
1:4d0fc78:                  "values ( reciprocal( 2.0 ) )"
1:4d0fc78:                  ),
1:4d0fc78:                 new String[][] {
1:4d0fc78:                     {"0.5"},
1:4d0fc78:                     });
1:4d0fc78: 
1:4d0fc78:         
1:4d0fc78:         // invoke the table function
1:4d0fc78:         JDBC.assertFullResultSet(
1:4d0fc78:                 s.executeQuery
1:4d0fc78:                 (
1:4d0fc78:                  "select * from table( dummyVTI() ) s where tablename='SYSTABLES'"
1:4d0fc78:                  ),
1:4d0fc78:                 new String[][] {
1:4d0fc78:                     {"SYSTABLES"},
1:4d0fc78:                     });
1:4d0fc78: 
1:4d0fc78:         // verify that a missing class raises an exception
1:4d0fc78:         try {
1:4d0fc78:             s.executeQuery
1:4d0fc78:                 (
1:4d0fc78:                  "select * from table( dummyVTI2() ) s where tablename='SYSTABLES'"
1:4d0fc78:                  );
1:4d0fc78:             fail( "Should have seen a ClassNotFoundException." );
1:4d0fc78:         } catch (SQLException e) {
1:4d0fc78:             assertSQLState("XJ001", e);
1:4d0fc78:         }
1:a7016bf: 
1:a7016bf:         // drop the useless function
1:a7016bf:         s.executeUpdate( "drop function dummyVTI2\n" );
1:a7016bf: 
1:a7016bf:         setDBClasspath(null);
1:a7016bf:         
1:a7016bf:         s.close();
1:a7016bf:     }
1:a7016bf:     
1:a7016bf:     /**
1:b3834d3:      * Test that user-defined aggregates can be invoked from inside jar files stored in
1:b3834d3:      * the database.
1:b3834d3:      */
1:b3834d3:     public void testUDAInJar() throws SQLException, MalformedURLException
1:b3834d3:     {
1:b3834d3:         String jarName = "EMC.MEDIAN_UDA";
1:b3834d3: 
1:b3834d3:         installJar( "median_uda.jar", jarName );
1:b3834d3: 
1:b3834d3:         setDBClasspath( jarName );
1:b3834d3: 
1:b3834d3:         Statement s = createStatement();
1:b3834d3: 
1:b3834d3:         // register the user-defined aggregate
1:b3834d3:         s.executeUpdate
1:b3834d3:             ( "create derby aggregate intMedian for int external name 'Median'\n" );
1:b3834d3: 
1:b3834d3:         // register another user-defined aggregate in a class which doesn't exist
1:b3834d3:         s.executeUpdate
1:b3834d3:             (
1:b3834d3:              "create derby aggregate missingAggregate for int external name 'MissingAggregate'\n"
1:b3834d3:              );
1:b3834d3: 
1:b3834d3:         // create a table with some values
1:b3834d3:         s.execute( "create table intValues( a int, b int )" );
1:b3834d3:         s.execute( "insert into intValues values ( 1, 1 ), ( 1, 10 ), ( 1, 100 ), ( 1, 1000 ), ( 2, 5 ), ( 2, 50 ), ( 2, 500 ), ( 2, 5000 )" );
1:b3834d3: 
1:b3834d3:         // invoke the user-defined aggregate
1:b3834d3:         JDBC.assertFullResultSet
1:b3834d3:             (
1:b3834d3:              s.executeQuery
1:b3834d3:              (
1:b3834d3:               "select intMedian( b ) from intValues"
1:b3834d3:               ),
1:b3834d3:              new String[][]
1:b3834d3:              {
1:b3834d3:                  { "100" },
1:b3834d3:              }
1:b3834d3:              );
1:b3834d3:         JDBC.assertFullResultSet
1:b3834d3:             (
1:b3834d3:              s.executeQuery
1:b3834d3:              (
1:b3834d3:               "select a, intMedian( b ) from intValues group by a"
1:b3834d3:               ),
1:b3834d3:              new String[][]
1:b3834d3:              {
1:b3834d3:                  { "1", "100" },
1:b3834d3:                  { "2", "500" },
1:b3834d3:              }
1:b3834d3:              );
1:b3834d3: 
1:b3834d3:         // verify that a missing class raises an exception
1:b3834d3:         try {
1:b3834d3:             s.executeQuery
1:b3834d3:                 (
1:b3834d3:                  "select missingAggregate( b ) from intValues"
1:b3834d3:                  );
1:b3834d3:             fail( "Should have seen a ClassNotFoundException." );
1:b3834d3:         } catch (SQLException e) {
1:b3834d3:             assertSQLState("XJ001", e);
1:b3834d3:         }
1:b3834d3: 
1:b3834d3:         // drop the useless aggregate
1:b3834d3:         s.executeUpdate( "drop derby aggregate missingAggregate restrict" );
1:b3834d3: 
1:b3834d3:         setDBClasspath(null);
1:b3834d3:         
1:b3834d3:         s.close();
1:b3834d3:     }
1:b3834d3:     
1:b3834d3:     /**
1:a7016bf:      * Test that restricted table functions can be invoked from inside jar files stored in
1:a7016bf:      * the database.
1:a7016bf:      */
1:a7016bf:     public void test_5352() throws SQLException, MalformedURLException
1:a7016bf:     {
1:a7016bf:         String jarName = "EMC.DUMMY_VTI2";
1:a7016bf: 
1:a7016bf:         installJar("dummy_vti.jar", jarName );
1:a7016bf: 
1:a7016bf:         setDBClasspath( jarName );
1:a7016bf: 
1:a7016bf:         Statement s = createStatement();
1:a7016bf: 
1:a7016bf:         // register the table function
1:a7016bf:         s.executeUpdate
1:a7016bf:             (
1:a7016bf:              "create function dummyVTI2( allowsRestriction boolean )\n" +
1:a7016bf:              "returns table( a int )\n" +
1:a7016bf:              "language java\n" +
1:a7016bf:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:a7016bf:              "no sql\n" +
1:a7016bf:              "external name 'DummyVTI2.dummyVTI2'\n"
1:a7016bf:              );
1:a7016bf:         
1:a7016bf:         // invoke the table function
1:a7016bf:         JDBC.assertFullResultSet
1:a7016bf:             (
1:a7016bf:                 s.executeQuery
1:a7016bf:                 (
1:a7016bf:                  "select * from table( dummyVTI2( true ) ) s where a = 1"
1:a7016bf:                  ),
1:a7016bf:                 new String[][]
1:a7016bf:                 {
1:a7016bf:                     { "1" }
1:a7016bf:                 }
1:a7016bf:              );
1:a7016bf: 
1:a7016bf:         // verify that the RestrictedVTI machinery is really invoked
1:a7016bf:         assertStatementError( "XYZZY", s, "select * from table( dummyVTI2( false ) ) s where a = 1" );
1:a7016bf:         
1:a7016bf:         s.executeUpdate( "drop function dummyVTI2\n" );
1:a7016bf: 
1:4d0fc78:         setDBClasspath(null);
1:4d0fc78:         
1:4d0fc78:         s.close();
1:4d0fc78:     }
1:4d0fc78: 
1:36d1b35:     /**
1:f40e25a:      * Test that a classpath database is not found when it's not in the
1:f40e25a:      * classpath and there is a login timeout.
1:f40e25a:      * @see #loginTimeoutSuite()
1:f40e25a:      */
1:f40e25a:     public void testLoginTimeoutNotInClasspath() throws SQLException {
1:f40e25a:         checkConnectionToClasspathDB(false);
1:f40e25a:     }
1:f40e25a: 
1:f40e25a:     /**
1:f40e25a:      * Test that a classpath database is found when it's in the
1:f40e25a:      * classpath and there is a login timeout.
1:f40e25a:      * @see #loginTimeoutSuite()
1:f40e25a:      */
1:f40e25a:     public void testLoginTimeoutInClasspath() throws SQLException {
1:f40e25a:         checkConnectionToClasspathDB(true);
1:f40e25a:     }
1:f40e25a: 
1:f40e25a:     /**
1:f40e25a:      * Check if it is possible to connect to a classpath database.
1:f40e25a:      *
1:f40e25a:      * @param databaseInClasspath if {@code true}, expect that the database
1:f40e25a:      * can be connected to; otherwise, expect that the database cannot be
1:f40e25a:      * found.
1:f40e25a:      */
1:f40e25a:     private void checkConnectionToClasspathDB(boolean databaseInClasspath) {
1:f40e25a:         String dbName = "classpath:dbro";
1:f40e25a:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:f40e25a:         try {
1:f40e25a:             ds.getConnection().close();
1:f40e25a:             // We should only be able to get a connection if the database is
1:f40e25a:             // in the classpath.
1:f40e25a:             assertTrue(
1:f40e25a:                 "Could connect to database when it was not in the classpath",
1:f40e25a:                 databaseInClasspath);
1:f40e25a:         } catch (SQLException sqle) {
1:f40e25a:             // If the database is not in the classpath, we expect
1:f40e25a:             // ERROR XJ004: Database 'classpath:dbro' not found.
1:f40e25a:             if (databaseInClasspath) {
1:f40e25a:                 fail("Could not connect to the database", sqle);
1:f40e25a:             } else {
1:f40e25a:                 assertSQLState("XJ004", sqle);
1:f40e25a:             }
1:f40e25a:         }
1:f40e25a: 
1:f40e25a:         // If we managed to boot the database, shut it down again.
1:f40e25a:         if (databaseInClasspath) {
1:f40e25a:             JDBCDataSource.shutdownDatabase(ds);
1:f40e25a:         }
1:f40e25a:     }
1:f40e25a: 
1:3cfc857:     private void installJar(String resource, String jarName) throws SQLException, MalformedURLException
1:3cfc857:     {        
1:3cfc857:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:4d0fc78:         
1:e1e7492:         assertNotNull(resource, jar);
1:c722b36:         
1:e1e7492:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:e1e7492:         cs.setString(1, jar.toExternalForm());
1:e1e7492:         cs.setString(2, jarName);
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         cs.close();
1:e1e7492:     }
1:c722b36:     
1:3cfc857:     private void replaceJar(String resource, String jarName) throws SQLException, MalformedURLException
1:3cfc857:     {        
1:3cfc857:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
1:e1e7492:         assertNotNull(resource, jar);
1:e1e7492:         
1:e1e7492:         CallableStatement cs = prepareCall("CALL SQLJ.REPLACE_JAR(?, ?)");
1:e1e7492:         cs.setString(1, jar.toExternalForm());
1:e1e7492:         cs.setString(2, jarName);
1:e1e7492:         cs.executeUpdate();
1:e1e7492:         cs.close();
1:e1e7492:     }
1:e1e7492:     
1:66f66a1:     private void removeJar(String jarName) throws SQLException
1:66f66a1:     {
1:66f66a1:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");       
1:66f66a1:         cs.setString(1, jarName);       
1:66f66a1:         cs.executeUpdate();        
1:66f66a1:         cs.close();
1:66f66a1:     }
1:66f66a1:     
1:36d1b35:     private void setDBClasspath(String cp) throws SQLException
1:e1e7492:     {
1:36d1b35:         CallableStatement cs = prepareCall(
1:36d1b35:           "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.database.classpath', ?)");
1:e1e7492: 
1:36d1b35:         cs.setString(1, cp);
1:36d1b35:         cs.executeUpdate();
1:36d1b35:         cs.close();
1:36d1b35:     }
1:e1e7492:     
1:e1e7492:     
1:e1e7492:     
1:cef7d1e:     
1:36d1b35:     private void derby2035Workaround() throws SQLException
1:e1e7492:     {
1:36d1b35:         // DERBY-2035 Other connections, e.g. the next fixture
1:36d1b35:         // do not see the changes related to the new class path
1:36d1b35:         // until the database is shutdown. However, the connection
1:36d1b35:         // setting the change does see it!
1:36d1b35:         // 
1:36d1b35:         getConnection().close();
1:9528482:         getTestConfiguration().shutdownDatabase(); 
1:36d1b35:     }
4:cef7d1e:     
1:36d1b35:     /**
1:0298580:      * jarname - jarname to use path - path to database dbname - database name
1:0298580:      * in archive
1:36d1b35:      */
1:0298580:     private static void createArchive(String jarName, File dbDir, String dbName)
1:0298580:             throws Exception {
1:0298580: 
1:0298580:         assertTrue(dbDir.isDirectory());
1:0298580: 
1:0298580:         // jar file paths in the JDBC URL are relative to the root
1:0298580:         // derby.system.home or user.dir, so need to create the jar there.
1:0298580:         File jarFile = SupportFilesSetup.getReadOnly(jarName);
1:0298580:         
1:0298580:         
1:0298580:         ZipOutputStream zos = new ZipOutputStream(
1:0298580:                 new FileOutputStream(jarFile));
1:0298580: 
1:0298580:         addEntries(zos, dbDir, dbName, dbDir.getPath().length());
1:0298580: 
1:0298580:         zos.close();
1:0298580:     }
1:0298580: 
1:0298580:     static void addEntries(ZipOutputStream zos, File dir, String dbName, int old)
1:0298580:             throws Exception {
1:0298580: 
1:0298580:         String[] list = dir.list();
1:0298580: 
1:0298580:         for (int i = 0; i < list.length; i++) {
1:0298580: 
1:0298580:             File f = new File(dir, list[i]);
1:0298580:             if (f.isDirectory()) {
1:0298580:                 addEntries(zos, f, dbName, old);
1:0298580:             } else {
1:0298580:                 addFile(zos, f, dbName, old);
1:0298580:             }
1:0298580: 
1:0298580:         }
1:0298580:     }
1:0298580: 
1:0298580:     private static void addFile(ZipOutputStream zos, File f, String dbName, int old)
1:0298580:             throws IOException {
1:0298580: 
1:0298580:         String s = f.getPath().replace(File.separatorChar, '/');
1:0298580: 
1:0298580:         s = s.substring(old);
1:0298580: 
1:0298580:         s = dbName.concat(s);
1:0298580: 
1:0298580:         // jar has forward slashes!
1:0298580:         ZipEntry ze = new ZipEntry(s);
1:0298580:         ze.setTime(f.lastModified());
1:0298580: 
1:0298580:         zos.putNextEntry(ze);
1:0298580: 
1:0298580:         byte[] buf = new byte[4096];
1:0298580:         BufferedInputStream in = new BufferedInputStream(
1:0298580:                 (new FileInputStream(f)));
1:0298580:         while (true) {
1:0298580:             int read = in.read(buf);
1:0298580:             if (read == -1) {
1:0298580:                 break;
1:0298580:             }
1:0298580:             zos.write(buf, 0, read);
1:0298580:         }
1:0298580: 
1:0298580:         in.close();
1:0298580:         zos.closeEntry();
1:0298580:     }
1:0298580: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1:         final BaseTestSuite suite =
1:             new BaseTestSuite("DatabaseClassLoadingTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("Class loading with login timeout");
commit:eff9169
/////////////////////////////////////////////////////////////////////////
1:                   "create function EMC.GETARTICLE(path VARCHAR(60)) " +
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f40e25a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.LoginTimeoutTestSetup;
/////////////////////////////////////////////////////////////////////////
1: 
1:            // Add test cases accessing a classpath database when a login
1:            // timeout has been specified.
1:            suite.addTest(loginTimeoutSuite());
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a test suite that verifies the fix for DERBY-6107. Connection
1:      * attempts used to fail when trying to access a classpath database that
1:      * lived in the context class loader, if a login timeout was used and a
1:      * previous connection attempt had been made from a thread that did not
1:      * have the database in its context class loader.
1:      */
1:     private static Test loginTimeoutSuite() throws Exception {
0:         TestSuite suite = new TestSuite("Class loading with login timeout");
1: 
1:         // First run a test when the database is not in the classpath.
1:         // Expect the connection attempt to fail.
1:         suite.addTest(
1:             new DatabaseClassLoadingTest("testLoginTimeoutNotInClasspath"));
1: 
1:         // Then try again with the database in the classpath. Should succeed.
1:         // Failed before DERBY-6107.
1:         //
1:         // Only add this test case if we can close the URLClassLoader when
1:         // we're done. Otherwise, we won't be able to delete the jar file
1:         // afterwards. (DERBY-2162)
1:         if (ClasspathSetup.supportsClose()) {
1:             suite.addTest(
1:                 new ClasspathSetup(
1:                     new DatabaseClassLoadingTest("testLoginTimeoutInClasspath"),
1:                     SupportFilesSetup.getReadOnlyURL("dclt.jar")));
1:         }
1: 
1:         // Finally, check that the database cannot be found anymore after
1:         // it has been removed from the classpath.
1:         suite.addTest(
1:             new DatabaseClassLoadingTest("testLoginTimeoutNotInClasspath"));
1: 
1:         // All of this should be done with a login timeout. Set the timeout
1:         // to a high value, so that the connection attempts don't actually
1:         // time out.
1:         return new LoginTimeoutTestSetup(suite, 100);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that a classpath database is not found when it's not in the
1:      * classpath and there is a login timeout.
1:      * @see #loginTimeoutSuite()
1:      */
1:     public void testLoginTimeoutNotInClasspath() throws SQLException {
1:         checkConnectionToClasspathDB(false);
1:     }
1: 
1:     /**
1:      * Test that a classpath database is found when it's in the
1:      * classpath and there is a login timeout.
1:      * @see #loginTimeoutSuite()
1:      */
1:     public void testLoginTimeoutInClasspath() throws SQLException {
1:         checkConnectionToClasspathDB(true);
1:     }
1: 
1:     /**
1:      * Check if it is possible to connect to a classpath database.
1:      *
1:      * @param databaseInClasspath if {@code true}, expect that the database
1:      * can be connected to; otherwise, expect that the database cannot be
1:      * found.
1:      */
1:     private void checkConnectionToClasspathDB(boolean databaseInClasspath) {
1:         String dbName = "classpath:dbro";
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         try {
1:             ds.getConnection().close();
1:             // We should only be able to get a connection if the database is
1:             // in the classpath.
1:             assertTrue(
1:                 "Could connect to database when it was not in the classpath",
1:                 databaseInClasspath);
1:         } catch (SQLException sqle) {
1:             // If the database is not in the classpath, we expect
1:             // ERROR XJ004: Database 'classpath:dbro' not found.
1:             if (databaseInClasspath) {
1:                 fail("Could not connect to the database", sqle);
1:             } else {
1:                 assertSQLState("XJ004", sqle);
1:             }
1:         }
1: 
1:         // If we managed to boot the database, shut it down again.
1:         if (databaseInClasspath) {
1:             JDBCDataSource.shutdownDatabase(ds);
1:         }
1:     }
1: 
commit:9f1b314
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:             suite.addTest(new DatabaseClassLoadingTest("testDatabaseInJar"));
1:                 suite.addTest(new ClasspathSetup(
1:                         SupportFilesSetup.getReadOnlyURL("dclt.jar")));
/////////////////////////////////////////////////////////////////////////
1:         String dbName = "jar:(" +
1:                 PrivilegedFileOpsForTests.getAbsolutePath(jarFile) + ")dbro";
commit:4a08a15
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.ClasspathSetup;
/////////////////////////////////////////////////////////////////////////
1:     public static Test suite() throws Exception
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-2162: Only run this test case on platforms that support
1:             // the URLClassLoader.close() method. Otherwise, we won't be able
1:             // to delete the jar file afterwards.
1:             if (ClasspathSetup.supportsClose()) {
1:                 suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                     new ClasspathSetup(
1:                         new DatabaseClassLoadingTest("testDatabaseInClasspath"),
0:                         SupportFilesSetup.getReadOnlyURL("dclt.jar"))));
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public void testDatabaseInClasspath() throws SQLException
1:         readOnlyTest(ds);
/////////////////////////////////////////////////////////////////////////
commit:38c638d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         (new java.security.PrivilegedExceptionAction<Void>() {
1:             public Void run() throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         (new java.security.PrivilegedAction<Void>() {
0:             public Void run()  {
commit:6819612
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-553: Disabled on Java 5 due to JVM bug
1:             // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6284489
1:             if (!isJava5()) {
1:                 signersTests(conn);
1:             }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b3834d3
/////////////////////////////////////////////////////////////////////////
1:                 "testUDAInJar",
/////////////////////////////////////////////////////////////////////////
1:                    "functionTests/tests/lang/median_uda.jar",
/////////////////////////////////////////////////////////////////////////
1:      * Test that user-defined aggregates can be invoked from inside jar files stored in
1:      * the database.
1:      */
1:     public void testUDAInJar() throws SQLException, MalformedURLException
1:     {
0:         // skip this test if vm is pre Java 6. This is because the jar file was
0:         // compiled by a modern compiler and the jar file won't load on
0:         // old vms.
0:         if ( JVMInfo.J2ME || (JVMInfo.JDK_ID < JVMInfo.J2SE_16 ) ) { return; }
1:         
1:         String jarName = "EMC.MEDIAN_UDA";
1: 
1:         installJar( "median_uda.jar", jarName );
1: 
1:         setDBClasspath( jarName );
1: 
1:         Statement s = createStatement();
1: 
1:         // register the user-defined aggregate
1:         s.executeUpdate
1:             ( "create derby aggregate intMedian for int external name 'Median'\n" );
1: 
1:         // register another user-defined aggregate in a class which doesn't exist
1:         s.executeUpdate
1:             (
1:              "create derby aggregate missingAggregate for int external name 'MissingAggregate'\n"
1:              );
1: 
1:         // create a table with some values
1:         s.execute( "create table intValues( a int, b int )" );
1:         s.execute( "insert into intValues values ( 1, 1 ), ( 1, 10 ), ( 1, 100 ), ( 1, 1000 ), ( 2, 5 ), ( 2, 50 ), ( 2, 500 ), ( 2, 5000 )" );
1: 
1:         // invoke the user-defined aggregate
1:         JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
1:               "select intMedian( b ) from intValues"
1:               ),
1:              new String[][]
1:              {
1:                  { "100" },
1:              }
1:              );
1:         JDBC.assertFullResultSet
1:             (
1:              s.executeQuery
1:              (
1:               "select a, intMedian( b ) from intValues group by a"
1:               ),
1:              new String[][]
1:              {
1:                  { "1", "100" },
1:                  { "2", "500" },
1:              }
1:              );
1: 
1:         // verify that a missing class raises an exception
1:         try {
1:             s.executeQuery
1:                 (
1:                  "select missingAggregate( b ) from intValues"
1:                  );
1:             fail( "Should have seen a ClassNotFoundException." );
1:         } catch (SQLException e) {
1:             assertSQLState("XJ001", e);
1:         }
1: 
1:         // drop the useless aggregate
1:         s.executeUpdate( "drop derby aggregate missingAggregate restrict" );
1: 
1:         setDBClasspath(null);
1:         
1:         s.close();
1:     }
1:     
1:     /**
commit:a7016bf
/////////////////////////////////////////////////////////////////////////
1:                 "test_5352",
/////////////////////////////////////////////////////////////////////////
1:              "external name 'MissingClass.dummyVTI'\n"
/////////////////////////////////////////////////////////////////////////
1: 
1:         // drop the useless function
1:         s.executeUpdate( "drop function dummyVTI2\n" );
1: 
1:         setDBClasspath(null);
1:         s.close();
1:     }
1:     
1:     /**
1:      * Test that restricted table functions can be invoked from inside jar files stored in
1:      * the database.
1:      */
1:     public void test_5352() throws SQLException, MalformedURLException
1:     {
0:         // skip this test if vm is pre Java 5. This is because the jar file was
0:         // compiled by a modern compiler and the jar file won't load on
0:         // old vms.
0:         if ( JVMInfo.J2ME || (JVMInfo.JDK_ID < JVMInfo.J2SE_15 ) ) { return; }
1:         
1:         String jarName = "EMC.DUMMY_VTI2";
1: 
1:         installJar("dummy_vti.jar", jarName );
1: 
1:         setDBClasspath( jarName );
1: 
1:         Statement s = createStatement();
1: 
1:         // register the table function
1:         s.executeUpdate
1:             (
1:              "create function dummyVTI2( allowsRestriction boolean )\n" +
1:              "returns table( a int )\n" +
1:              "language java\n" +
1:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:              "no sql\n" +
1:              "external name 'DummyVTI2.dummyVTI2'\n"
1:              );
1:         
1:         // invoke the table function
1:         JDBC.assertFullResultSet
1:             (
1:                 s.executeQuery
1:                 (
1:                  "select * from table( dummyVTI2( true ) ) s where a = 1"
1:                  ),
1:                 new String[][]
1:                 {
1:                     { "1" }
1:                 }
1:              );
1: 
1:         // verify that the RestrictedVTI machinery is really invoked
1:         assertStatementError( "XYZZY", s, "select * from table( dummyVTI2( false ) ) s where a = 1" );
1:         
1:         s.executeUpdate( "drop function dummyVTI2\n" );
1: 
commit:c0440b1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: 
/////////////////////////////////////////////////////////////////////////
0:         // skip this test if vm is pre Java 5. This is because the jar file was
0:         // compiled by a modern compiler and the jar file won't load on
0:         // old vms.
0:         if ( JVMInfo.J2ME || (JVMInfo.JDK_ID < JVMInfo.J2SE_15 ) ) { return; }
commit:4d0fc78
/////////////////////////////////////////////////////////////////////////
1:                 "testTableFunctionInJar",
/////////////////////////////////////////////////////////////////////////
1:                    "functionTests/tests/lang/dummy_vti.jar",
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that table functions can be invoked from inside jar files stored in
1:      * the database.
1:      */
1:     public void testTableFunctionInJar() throws SQLException, MalformedURLException
1:     {
1:         
1:         String jarName = "EMC.DUMMY_VTI";
1: 
1:         installJar("dummy_vti.jar", jarName );
1: 
1:         setDBClasspath( jarName );
1: 
1:         Statement s = createStatement();
1: 
1:         // register a scalar function
1:         s.executeUpdate
1:             (
1:              "create function reciprocal( original double ) returns double\n" +
1:              "language java\n" +
1:              "parameter style java\n" +
1:              "no sql\n" +
1:              "external name 'DummyVTI.reciprocal'"
1:              );
1: 
1:         // register the table function
1:         s.executeUpdate
1:             (
1:              "create function dummyVTI()\n" +
1:              "returns table( tablename varchar( 128 ) )\n" +
1:              "language java\n" +
1:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:              "reads sql data\n" +
1:              "external name 'DummyVTI.dummyVTI'\n"
1:              );
1: 
1:         // register another table function in a class which doesn't exist
1:         s.executeUpdate
1:             (
1:              "create function dummyVTI2()\n" +
1:              "returns table( tablename varchar( 128 ) )\n" +
1:              "language java\n" +
1:              "parameter style DERBY_JDBC_RESULT_SET\n" +
1:              "reads sql data\n" +
0:              "external name 'DummyVTI2.dummyVTI'\n"
1:              );
1: 
1:         // invoke the scalar function
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery
1:                 (
1:                  "values ( reciprocal( 2.0 ) )"
1:                  ),
1:                 new String[][] {
1:                     {"0.5"},
1:                     });
1: 
1:         
1:         // invoke the table function
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery
1:                 (
1:                  "select * from table( dummyVTI() ) s where tablename='SYSTABLES'"
1:                  ),
1:                 new String[][] {
1:                     {"SYSTABLES"},
1:                     });
1: 
1:         // verify that a missing class raises an exception
1:         try {
1:             s.executeQuery
1:                 (
1:                  "select * from table( dummyVTI2() ) s where tablename='SYSTABLES'"
1:                  );
1:             fail( "Should have seen a ClassNotFoundException." );
1:         } catch (SQLException e) {
1:             assertSQLState("XJ001", e);
1:         }
1:         
1:         setDBClasspath(null);
1:         
1:         s.close();
1:     }
1:     
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7fe51c3
/////////////////////////////////////////////////////////////////////////
commit:9cf3fb5
/////////////////////////////////////////////////////////////////////////
0:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "false");
commit:bb0c274
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DatabaseClassLoadingTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: 
1:  */
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01ab42f
/////////////////////////////////////////////////////////////////////////
1:                 "testIndirectLoading",
/////////////////////////////////////////////////////////////////////////
1:                    "functionTests/tests/lang/dcl_id.jar",
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test that loading of Derby's internal classes from
1:      * an installed jar file is disallowed.
1:      */
1:     public void testIndirectLoading() throws SQLException, MalformedURLException
1:     {
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("CREATE SCHEMA ID");
1:  /*       
1:         s.execute("create function OT.WHICH_LOADER1(classname VARCHAR(256)) " +
1:         "RETURNS VARCHAR(10) " +
1:         "NO SQL " +
1:         "external name " +
1:         "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest1.whichLoader' " +
1:         "language java parameter style java");
1: */
1:         installJar("dcl_id.jar", "ID.IDCODE");
1:         
1:         setDBClasspath("ID.IDCODE");
1:         
1:         // Create a procedure that is a method in an installed jar file
1:         // that calls the internal static method to set a database property.
1:         // If a user could do this then they bypass the grant/revoke on
1:         // the system procedure and instead are able to control the database
1:         // as they please.
1:         s.execute("CREATE PROCEDURE ID.SETDB(pkey VARCHAR(256), pvalue VARCHAR(256)) " +
1:                 "NO SQL " +
1:                 "external name " +
1:                 "'org.apache.derbyTesting.databaseclassloader.id.IndirectLoad.setDB' " +
1:                 "language java parameter style java");
1:         
1:         PreparedStatement ps = prepareCall("CALL ID.SETDB(?, ?)");
1: 
1:         ps.close();
1: 
1:         
1:         setDBClasspath(null);
1: 
1:               
1: 
1:         s.close();
1:         
1:     }
1: 
commit:31d9b6f
/////////////////////////////////////////////////////////////////////////
1:               
1:         checkLoading("123");
1:         checkLoading("132");
1:         checkLoading("213");
1:         checkLoading("231");
1:         checkLoading("321");
1:         checkLoading("312");
1: 
1:         s.close();
1:     }
1:     
1:     /**
1:      * Run a number of tests to ensure classes are loaded
1:      * from the correct class loader. The order of loading
1:      * the entry point classes is set by order. 123 will
1:      * load the entry point classes in order OrderTest1, OrderTest2,
1:      * OrderTest3. Since loading these entry point classes and
1:      * the order of execution will determine the loading order
1:      * of the other classes, we change the order to ensure
1:      * that classes are loaded from the correct jar regardless
1:      * of which class loaded it. Ie. Loading OrderTest2 first, which
1:      * loads indirectly OrderObject1,2,3 ensures that even though
1:      * OrderTest2 is loaded from OT2 that the others are loaded
1:      * from their correct jar.
1:      * 
1:      * @param order Order the entry point classes will be loaded.
1:      * 
1:      */
1:     private void checkLoading(String order) throws SQLException
1:     {
1:             "VALUES OT.WHICH_LOADER" + order.charAt(0) +"(?)");
1:                 "VALUES OT.WHICH_LOADER" + order.charAt(1) +"(?)");
1:                 "VALUES OT.WHICH_LOADER" + order.charAt(2) +"(?)");
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Tests the classes loaded indirectly by
1:         // code in an installed jar file.
1:         checkCorrectLoader("OrderObject1", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderObject2", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderObject3", ps1, ps2, ps3);
1:                 
1:         // reset the classpath to enforce the classes are loaded again
1:         // on the next attempt.
1:         setDBClasspath(null);
commit:c722b36
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                    new DatabaseClassLoadingTest("testDatabaseInClasspath")));
1:            
1:            // No security manager because the test uses getClass().getClassLoader()
1:            // in an installed jar to ensure that the class loader for
1:            // specific classes is correct. This operation is not allowed in general.
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
1:                    new DatabaseClassLoadingTest("testClassLoadOrdering")));
1:            
/////////////////////////////////////////////////////////////////////////
1:                    "functionTests/tests/lang/dcl_ot1.jar",
1:                    "functionTests/tests/lang/dcl_ot2.jar",
1:                    "functionTests/tests/lang/dcl_ot3.jar",
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test ordering of class loading.
1:      * @throws MalformedURLException 
1:      */
1:     public void testClassLoadOrdering() throws SQLException, MalformedURLException
1:     {
1:         Statement s = createStatement();
1:         
1:         s.executeUpdate("CREATE SCHEMA OT");
1:         
1:         // Functions to get the class loader of a specific class.
1:         // Thre variants that are loaded out of each installed jar
1:         // file to ensure that loading is delegated from one jar
1:         // to another correctly.
1:         // We use the added feature that the toString() of the
1:         // ClassLoader for installed jars returns the jar name
1:         // first. The RETURNS VARCHAR(10) trims the string to
1:         // the correct length for our compare purposes, ie. the
1:         // length of "OT"."OT{1,2,3}"
1:         s.execute("create function OT.WHICH_LOADER1(classname VARCHAR(256)) " +
1:         "RETURNS VARCHAR(10) " +
1:         "NO SQL " +
1:         "external name " +
1:         "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest1.whichLoader' " +
1:         "language java parameter style java");
1:         
1:         s.execute("create function OT.WHICH_LOADER2(classname VARCHAR(256)) " +
1:                 "RETURNS VARCHAR(10) " +
1:                 "NO SQL " +
1:                 "external name " +
1:                 "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest2.whichLoader' " +
1:                 "language java parameter style java");
1: 
1:         s.execute("create function OT.WHICH_LOADER3(classname VARCHAR(256)) " +
1:                 "RETURNS VARCHAR(10) " +
1:                 "NO SQL " +
1:                 "external name " +
1:                 "'org.apache.derbyTesting.databaseclassloader.ot.OrderTest3.whichLoader' " +
1:                 "language java parameter style java");
1: 
1: 
1:         installJar("dcl_ot1.jar", "OT.OT1");
1:         installJar("dcl_ot2.jar", "OT.OT2");
1:         installJar("dcl_ot3.jar", "OT.OT3");
1:         
1:         setDBClasspath("OT.OT1:OT.OT2:OT.OT3");
1:         
1:         PreparedStatement ps1 = prepareStatement(
0:             "VALUES OT.WHICH_LOADER1(?)");
1:         PreparedStatement ps2 = prepareStatement(
0:             "VALUES OT.WHICH_LOADER2(?)");
1:         PreparedStatement ps3 = prepareStatement(
0:             "VALUES OT.WHICH_LOADER3(?)");
1:         
1:         // Tests the classes loaded as a direct entry point for a routine
1:         checkCorrectLoader("OrderTest1", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderTest2", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderTest3", ps1, ps2, ps3);
1:         
1:         // Tests the classes loaded directly (Class.forName()) by
1:         // code in an installed jar file.
1:         checkCorrectLoader("OrderLoad1", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderLoad2", ps1, ps2, ps3);
1:         checkCorrectLoader("OrderLoad3", ps1, ps2, ps3);
1:                
1:         ps1.close();
1:         ps2.close();
1:         ps3.close();
1:         s.close();
1:         
1:     }
1:     
1:     private void checkCorrectLoader(String className,
1:             PreparedStatement ps1,
1:             PreparedStatement ps2,
1:             PreparedStatement ps3)
1:        throws SQLException
1:     {
1:         className = "org.apache.derbyTesting.databaseclassloader.ot." + className;
1:         String expectedLoader = 
1:             "\"OT\".\"OT" + className.charAt(className.length() -1) + "\"";
1:         
1:         ps1.setString(1, className);
1:         JDBC.assertSingleValueResultSet(ps1.executeQuery(), expectedLoader);
1:         
1:         ps2.setString(1, className);
1:         JDBC.assertSingleValueResultSet(ps2.executeQuery(), expectedLoader);
1: 
1:         ps3.setString(1, className);
1:         JDBC.assertSingleValueResultSet(ps3.executeQuery(), expectedLoader);
1:     }
1:             
commit:6fc71fb
/////////////////////////////////////////////////////////////////////////
1:             
1:             String[] orderedTests = {
1:                 "testJarHandling",
1:                 "testWithNoInstalledJars",
1:                 "testWithNoClasspath",
1:                 "testSetClasspath",
1:                 "testAddContact",
1:                 "testGetResource",          
1:                 "testAlterTable",
1:                 "testClassPathRollback",
1:                 "testReplaceJar",      
1:                 "testReplacedClass",
1:                 "testSecondJar",
1:                 "testSignedJar",
1:                 "testCreateDatabaseJar",
1:                 "testHackedJarReplacedClass",
1:                 "testInvalidJar",
1:                 "testRemoveJar",
1:                 "testLoadJavaClassIndirectly",
1:                 "testLoadJavaClassDirectly",
1:                 "testLoadJavaClassDirectly2",
1:                 "testLoadJavaClassDirectly3",
1:                 "testLoadDerbyClassIndirectly",
1:             };
1:             
1:             for (int i = 0; i < orderedTests.length; i++)
1:             {
1:                 suite.addTest(new DatabaseClassLoadingTest(orderedTests[i]));
1:             }
commit:46ecfcf
/////////////////////////////////////////////////////////////////////////
1:            
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testLoadJavaClassIndirectly"))); 
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testLoadJavaClassDirectly")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testLoadJavaClassDirectly2")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testLoadJavaClassDirectly3")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testLoadDerbyClassIndirectly")));
/////////////////////////////////////////////////////////////////////////
1:                    "functionTests/tests/lang/dcl_emc2l.jar",
1:                    "functionTests/tests/lang/dcl_java.jar",
/////////////////////////////////////////////////////////////////////////
1:      * Load a java.sql class indirectly (ie. through a valid class
1:      * in the installed jar file) from the jar file.
1:      */
1:     public void testLoadJavaClassIndirectly() throws SQLException, MalformedURLException
1:     {
1:         loadJavaClass(
1:                 "org.apache.derbyTesting.databaseclassloader.cracker.C1.simple",
1:                 "38000");
1:     }
1:     
1:     /**
1:      * Load a java.sql class directly (ie. through a direct procedure call)
1:      * from the jar file.
1:      */    
1:     public void testLoadJavaClassDirectly() throws SQLException, MalformedURLException
1:     {
1:         loadJavaClass("java.sql.J1.simple", "XJ001");
1:     }
1:     
1:     /**
1:      * Load a java.derby99 class directly (ie. through a direct procedure call)
1:      * from the jar file. This is to see if additional non-standard java.* packages
1:      * can be added into the JVM
1:      */    
1:     public void testLoadJavaClassDirectly2() throws SQLException, MalformedURLException
1:     {
1:         loadJavaClass("java.derby99.J2.simple", "XJ001");
1:     }
1:     
1:     /**
1:      * Load a javax.derby99 class directly (ie. through a direct procedure call)
1:      * from the jar file. This is to see if additional non-standard javax.* packages
1:      * can be added into the JVM. As an implementation note this is blocked
1:      * by Derby's class loader, not the JVM's security mechanism.
1:      */    
1:     public void testLoadJavaClassDirectly3() throws SQLException, MalformedURLException
1:     {
1:         loadJavaClass("javax.derby99.J3.simple", "XJ001");
1:     }
1:     
1:     /**
1:      * Load a org.apache.derby class directly (ie. through a direct procedure call)
1:      * from the jar file. As an implementation note this is blocked
1:      * by Derby's class loader, not the JVM's security mechanism.
1:      */    
1:     public void testLoadDerbyClassIndirectly() throws SQLException, MalformedURLException
1:     {
1:         loadJavaClass(
1:                 "org.apache.derbyTesting.databaseclassloader.cracker.C1.derby",
1:                 "38000");
1:     }
1:     
1:     /**
1:      * Test loading classes in the java. and javax. namespaces
1:      * from a jar, it should be disallowed or be ignored. These tests
1:      * are run as separate fixtures to ensure the failed loading
1:      * does not affect subsequent attempts to load.
1:      * @throws MalformedURLException 
1:      */
1:     private void loadJavaClass(String method, String expectedSQLState)
1:         throws SQLException, MalformedURLException
1:     {
1:         String jarName = "EMC.MY_JAVA";
1:         
1:         installJar("dcl_java.jar", jarName);
1:         setDBClasspath(jarName);
1:         
1:         Statement s = createStatement();
1:         s.execute("CREATE PROCEDURE C1() LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:                 "NO SQL EXTERNAL NAME " +
1:                 "'" + method + "'");
1:        
1:         try {
1:             s.execute("CALL C1()");
1:             fail("Call to procedure loading java class from installed jar");
1:         } catch (SQLException sqle)
1:         {
1:             assertSQLState(expectedSQLState, sqle);
1:         }
1:         
1:         s.execute("DROP PROCEDURE C1");
1:         s.close();
1:         setDBClasspath(null);
1:         removeJar(jarName);
1: 
1:     }
1:     
1:     /**
commit:3df869c
/////////////////////////////////////////////////////////////////////////
1:         final String db = getTestConfiguration().getDefaultDatabaseName();
commit:312d86c
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-2179 - temp disable using the class loader
0:         // (since due to DERBY-2162) it's not working anyway)
0:         // need to re-write code not to assume there is no
0:         // existing thread context loader.
0:         //setContextClassLoader(jarURL);
0:             //setContextClassLoader(null);
commit:66f66a1
/////////////////////////////////////////////////////////////////////////
0:           suite.addTest(new DatabaseClassLoadingTest("testJarHandling"));
1:  
/////////////////////////////////////////////////////////////////////////
1:      * Test the sqlj procedures without setting any database
1:      * classpath. This allows testing with the security manager
1:      * without hitting the bugs that exist when the database class path
1:      * is set with the security manager.
1:      */
1:     public void testJarHandling() throws SQLException, MalformedURLException
1:     {       
1:         installJar("dcl_emc1.jar", "EMC.MAIL_APP_JHT");
1:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP_JHT");
1:         removeJar("EMC.MAIL_APP_JHT");
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     private void removeJar(String jarName) throws SQLException
1:     {
1:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");       
1:         cs.setString(1, jarName);       
1:         cs.executeUpdate();        
1:         cs.close();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     
commit:5a15941
/////////////////////////////////////////////////////////////////////////
1:             getResourceTests(conn);
commit:55ffdfb
/////////////////////////////////////////////////////////////////////////
1:        
/////////////////////////////////////////////////////////////////////////
0:             // Disabled due to DERBY-2162, running this opens
0:             // the database thus accessing resources and means the
0:             // jar file cannot be cleaned up.
0:             // readOnlyTest(ds);
/////////////////////////////////////////////////////////////////////////
0:             // Disabled due to DERBY-552
commit:0298580
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
1: import java.io.File;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
0: import java.net.URLClassLoader;
1: import java.security.AccessController;
0: import java.security.PrivilegedActionException;
1: import java.sql.Connection;
1: import java.util.zip.ZipEntry;
1: import java.util.zip.ZipOutputStream;
1: 
1: import javax.sql.DataSource;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:      * most of the tests are run without a security manager.
/////////////////////////////////////////////////////////////////////////
0:            suite.addTest(new DatabaseClassLoadingTest("testCreateDatabaseJar"));
1:            
1: 
0: /*  SKIP due to DERBY-2083         
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testDatabaseInJar"))); 
1: 
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testDatabaseInClasspath"))); 
1: */
1: 
/////////////////////////////////////////////////////////////////////////
1:         getResourceTests(getConnection());
1:     }
1:     
1:     private static void getResourceTests(Connection conn) throws SQLException
1:     {
1:         PreparedStatement ps = conn.prepareStatement("VALUES EMC.GETARTICLE(?)");
/////////////////////////////////////////////////////////////////////////
1:         
1:         signersTests(getConnection());
1:         
1:     }
1:     
1:     private static void signersTests(Connection conn) throws SQLException
1:     {
1:         PreparedStatement ps = conn.prepareStatement("VALUES EMC.GETSIGNERS(?)");
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Create a Jar of the current database.
1:      * @throws Exception 
1:      *
1:      */
1:     public void testCreateDatabaseJar() throws Exception
1:     {
1:         CallableStatement cs = prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:         cs.executeUpdate();
1:         cs.close();
1:         
1:         cs = prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE_NOWAIT(?)");
1:         
1:         final File backupDir = SupportFilesSetup.getReadWrite("dbreadonly");
1:         
1:         cs.setString(1, backupDir.getPath());
1:         cs.executeUpdate();
1: 
1:         cs.close();
1:         
0:         final String db = getTestConfiguration().getDatabaseName();
1:         AccessController.doPrivileged
0:         (new java.security.PrivilegedExceptionAction(){
1:             
0:             public Object run() throws Exception { 
1:                 createArchive("dclt.jar", new File(backupDir, db), "dbro");;
1:               return null;
1:             }
1:         });
1:         
1:     }
1:     
1:     /**
1:      * Test the jar'ed up database created by testCreateDatabaseJar
1:      * accessing the database using the jar(path to archive)db form
1:      * of database name.
1:      */
1:     public void testDatabaseInJar() throws SQLException
1:     {
1:         File jarFile = SupportFilesSetup.getReadOnly("dclt.jar");
0:         String dbName = "jar:(" + jarFile.getAbsolutePath() + ")dbro";
1:         
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         
1:         readOnlyTest(ds);
1:     }
1:     
0:     public void testDatabaseInClasspath() throws SQLException, MalformedURLException
1:     {
1:         String dbName = "classpath:dbro";
1:         DataSource ds = JDBCDataSource.getDataSource(dbName);
1:         
1:         try {
0:             ds.getConnection();
0:             fail("opened database before it was on classpath");
0:         } catch (SQLException e)
1:         {
0:            assertSQLState("XJ004", e);
1:         }
1:         
0:         URL jarURL = SupportFilesSetup.getReadOnlyURL("dclt.jar");
1:         
0:         setContextClassLoader(jarURL);
1:         try {
1:             readOnlyTest(ds);
1:         } finally {
0:             setContextClassLoader(null);
1:         } 
1:     }
1:     
1:     /**
1:      * Run an number of statements against a jar'ed database to
1:      * ensure it is read-only and that class loading works from
1:      * jar files embedded in jar'ed up databases.
1:      */
1:     private static void readOnlyTest(DataSource ds) throws SQLException
1:     {
1:         try {
1:             Connection conn = ds.getConnection();
1:             Statement s = conn.createStatement();
1:             
1:             JDBC.assertFullResultSet(
1:                     s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:                     new String[][] {
1:                         {"0", "now@classpathchange.com", null},
1:                         {"1", "bill@ruletheworld.com", null},
1:                         {"2", "penguin@antartic.com", null},
1:                         {"3", "big@blue.com", null},
1:                         {"4", "spammer@ripoff.com", "0"},
1:                         {"5", "open@source.org", "1"},
1:                         });
1:             
1:             JDBC.assertFullResultSet(
1:                     s.executeQuery("SELECT id, e_mail, \"emcAddOn\".VALIDCONTACT(e_mail) from EMC.CONTACTS ORDER BY 1"),
1:                     new String[][] {
1:                         {"0", "now@classpathchange.com", "0"},
1:                         {"1", "bill@ruletheworld.com", "0"},
1:                         {"2", "penguin@antartic.com", "0"},
1:                         {"3", "big@blue.com", "0"},
1:                         {"4", "spammer@ripoff.com", "0"},
1:                         {"5", "open@source.org", "1"},
1:                         });
1:                        
1:             assertStatementError("25502", s,
1:                     "INSERT INTO EMC.CONTACTS values(3, 'no@is_read_only.gov', NULL)");
1:             assertStatementError("25502", s,
1:                     "CALL EMC.ADDCONTACT(3, 'really@is_read_only.gov')");
1: 
0:             // Disabled due to DERBY-522
0:             // getResourceTests(conn);
1:             
0:             // Disabled due to DERBY-553
0:             // signersTests(conn);
1:             
1:             // ensure that a read-only database automatically gets table locking
1:             conn.setAutoCommit(false);
1:             JDBC.assertDrainResults(
1:                     s.executeQuery("select * from EMC.CONTACTS WITH RR"));
1:             
1:             JDBC.assertFullResultSet(
1:                     s.executeQuery(
1:                          "select TYPE, MODE, TABLENAME from syscs_diag.lock_table"),
1:                     new String[][] {
1:                         {"TABLE", "S", "CONTACTS"},
1:                         });
1:  
1:             s.close();
1:             conn.rollback();
1:             conn.setAutoCommit(true);
1:             conn.close();
1:         } finally {
1:             JDBCDataSource.shutdownDatabase(ds);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * jarname - jarname to use path - path to database dbname - database name
1:      * in archive
1:      */
1:     private static void createArchive(String jarName, File dbDir, String dbName)
1:             throws Exception {
1: 
1:         assertTrue(dbDir.isDirectory());
1: 
1:         // jar file paths in the JDBC URL are relative to the root
1:         // derby.system.home or user.dir, so need to create the jar there.
1:         File jarFile = SupportFilesSetup.getReadOnly(jarName);
1:         
1:         
1:         ZipOutputStream zos = new ZipOutputStream(
1:                 new FileOutputStream(jarFile));
1: 
1:         addEntries(zos, dbDir, dbName, dbDir.getPath().length());
1: 
1:         zos.close();
1:     }
1: 
1:     static void addEntries(ZipOutputStream zos, File dir, String dbName, int old)
1:             throws Exception {
1: 
1:         String[] list = dir.list();
1: 
1:         for (int i = 0; i < list.length; i++) {
1: 
1:             File f = new File(dir, list[i]);
1:             if (f.isDirectory()) {
1:                 addEntries(zos, f, dbName, old);
1:             } else {
1:                 addFile(zos, f, dbName, old);
1:             }
1: 
1:         }
1:     }
1: 
1:     private static void addFile(ZipOutputStream zos, File f, String dbName, int old)
1:             throws IOException {
1: 
1:         String s = f.getPath().replace(File.separatorChar, '/');
1: 
1:         s = s.substring(old);
1: 
1:         s = dbName.concat(s);
1: 
1:         // jar has forward slashes!
1:         ZipEntry ze = new ZipEntry(s);
1:         ze.setTime(f.lastModified());
1: 
1:         zos.putNextEntry(ze);
1: 
1:         byte[] buf = new byte[4096];
1:         BufferedInputStream in = new BufferedInputStream(
1:                 (new FileInputStream(f)));
1:         while (true) {
1:             int read = in.read(buf);
1:             if (read == -1) {
1:                 break;
1:             }
1:             zos.write(buf, 0, read);
1:         }
1: 
1:         in.close();
1:         zos.closeEntry();
1:     }
1:     
0:     private static void setContextClassLoader(final URL url)
1:     {
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
1:             
0:             public Object run()  { 
0:                 URLClassLoader cl = 
0:                     url == null ? null : new URLClassLoader(new URL[] {url});
0:                 java.lang.Thread.currentThread().setContextClassLoader(cl);
0:               return null;
1:             }
1:         });
1:     }
commit:9fef639
/////////////////////////////////////////////////////////////////////////
0:           suite.addTest(new DatabaseClassLoadingTest("testWithNoClasspath"));
commit:3cfc857
/////////////////////////////////////////////////////////////////////////
1: import java.net.MalformedURLException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
/////////////////////////////////////////////////////////////////////////
1:         Test test = suite;
/////////////////////////////////////////////////////////////////////////
0:                    new DatabaseClassLoadingTest("testRemoveJar"))); 
1:            
1:            test = new SupportFilesSetup(suite,
1:                    new String[] {
1:                    "functionTests/tests/lang/dcl_emc1.jar",
1:                    "functionTests/tests/lang/dcl_emcaddon.jar",
1:                    "functionTests/tests/lang/dcl_emc2.jar",
1:                    "functionTests/tests/lang/dcl_emc2s.jar",
1:                    "functionTests/tests/lang/dcl_emc2sm.jar",
0:                    "functionTests/tests/lang/dcl_emc2l.jar"
1:                    });
1:            
1:         return new CleanDatabaseTestSetup(test) {
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testWithNoClasspath() throws SQLException, MalformedURLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testClassPathRollback() throws SQLException, MalformedURLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testReplaceJar() throws SQLException, MalformedURLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testSecondJar() throws SQLException, MalformedURLException {
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testSignedJar() throws SQLException, MalformedURLException
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testHackedJarReplacedClass() throws SQLException, MalformedURLException {
/////////////////////////////////////////////////////////////////////////
1:      * @throws MalformedURLException 
1:     public void testInvalidJar() throws SQLException, MalformedURLException
/////////////////////////////////////////////////////////////////////////
1:     private void installJar(String resource, String jarName) throws SQLException, MalformedURLException
1:     {        
1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
/////////////////////////////////////////////////////////////////////////
1:     private void replaceJar(String resource, String jarName) throws SQLException, MalformedURLException
1:     {        
1:         URL jar = SupportFilesSetup.getReadOnlyURL(resource);
commit:e1e7492
/////////////////////////////////////////////////////////////////////////
1:  * installed jars including accessing resources. Replacing
1:  * jars and handling signed jars is also tested.
/////////////////////////////////////////////////////////////////////////
1: 
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testClassPathRollback")));
1:            
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testReplaceJar")));        
1:            
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testReplacedClass")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testSecondJar")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testSignedJar")));
1:            
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testHackedJarReplacedClass")));
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testInvalidJar")));           
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testRemoveJar")));           
1:            }
1:                 s.executeUpdate("create schema \"emcAddOn\"");
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 // function that gets the signers of the class (loaded from the jar)
1:                 s.executeUpdate("CREATE FUNCTION EMC.GETSIGNERS(" +
1:                   "CLASS_NAME VARCHAR(256)) RETURNS VARCHAR(60) "+
1:                   "NO SQL LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:                   "EXTERNAL NAME 'org.apache.derbyTesting.databaseclassloader.emc.getSigners'");
1:                 
1:                 s.executeUpdate("CREATE FUNCTION \"emcAddOn\".VALIDCONTACT(E_MAIL VARCHAR(30)) "+
1:                   "RETURNS SMALLINT "+
1:                   "READS SQL DATA LANGUAGE JAVA PARAMETER STYLE JAVA " +
1:                   "EXTERNAL NAME 'org.apache.derbyTesting.databaseclassloader.addon.vendor.util.valid'");
/////////////////////////////////////////////////////////////////////////
1:         installJar("dcl_emc1.jar", "EMC.MAIL_APP");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * check the roll back of class loading.
1:      * install a new jar in a transaction, see
1:      * that the new class is used and then rollback
1:      * the old class should be used after the rollback.
1:      * @throws SQLException
1:      */
0:     public void testClassPathRollback() throws SQLException
1:     {        
1:         getConnection().setAutoCommit(false);
1:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP");
1: 
1:         
1:         // This version checks the e-mail address.
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 99);
1:         cs.setString(2, "wormspam@soil.com");
1:         cs.executeUpdate();
1:         
1:         Statement s = createStatement();
1:         
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS WHERE ID = 99"),
1:                 new String[][] {
1:                     {"99", "wormspam@soil.com", "0"},
1:                     });
1:         
1:         rollback();
1:         getConnection().setAutoCommit(true);
1:         
1:         // execute again but reverted to the version that does not
1:         // check the email address.
1:         cs.executeUpdate();
1:         cs.close();
1: 
1:          JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS WHERE ID = 99"),
1:                 new String[][] {
1:                     {"99", "wormspam@soil.com", null},
1:                     });
1:          
1:          s.executeUpdate("DELETE FROM EMC.CONTACTS WHERE ID = 99");
1:          s.close();
1:     }
1:     
1:     /**
1:      * Replace the jar to later test the prepare from a different
1:      * connection picks up the new version.
1:      * @throws SQLException
1:      */
0:     public void testReplaceJar() throws SQLException
1:     {
1:         replaceJar("dcl_emc2.jar", "EMC.MAIL_APP");
1:     }
1:     
1:     /**
1:      * Change of class due to testReplaceJar that
1:      * changes the application to run checks on the e-mail
1:      * to ensure it is valid (in this case by seeing if
1:      *  it simply includes 'spam' in the title).
1:      * @throws SQLException
1:      */
1:     public void testReplacedClass() throws SQLException {
1:         // This version checks the e-mail address.
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 4);
1:         cs.setString(2, "spammer@ripoff.com");
1:         cs.executeUpdate();
1:         cs.setInt(1, 5);
1:         cs.setString(2, "open@source.org");
1:         cs.executeUpdate();
1:         
1:         Statement s = createStatement();
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:                 new String[][] {
1:                     {"0", "now@classpathchange.com", null},
1:                     {"1", "bill@ruletheworld.com", null},
1:                     {"2", "penguin@antartic.com", null},
1:                     {"3", "big@blue.com", null},
1:                     {"4", "spammer@ripoff.com", "0"},
1:                     {"5", "open@source.org", "1"},
1:                     });
1:       
1:         s.close();
1:     }
1:     
1:     /**
1:      * now add another jar in to test two jars and
1:      * a quoted identifer for the jar names.
1:      */
0:     public void testSecondJar() throws SQLException {
1:         
1:         installJar("dcl_emcaddon.jar", "\"emcAddOn\".\"MailAddOn\"");
1: 
1:         setDBClasspath("EMC.MAIL_APP:\"emcAddOn\".\"MailAddOn\"");
1:         Statement s = createStatement();
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT E_MAIL, \"emcAddOn\".VALIDCONTACT(E_MAIL) FROM EMC.CONTACTS ORDER BY 1"),
1:                 new String[][] {
1:                     {"big@blue.com", "0"},
1:                     {"bill@ruletheworld.com", "0"},
1:                     {"now@classpathchange.com", "0"},
1:                     {"open@source.org", "1"},
1:                     {"penguin@antartic.com", "0"},
1:                     {"spammer@ripoff.com", "0"},
1:                     });
1:       
1:         s.close();
1:     }
1:     
1:     /**
1:      * Test to see if the jar signatures can be obtained from the jar file.
1:      * The jar was signed with a self signed certificate
1:      * <code>
1:         keytool -delete -alias emccto -keystore emcks -storepass ab987c
1:         keytool -genkey -dname "cn=EMC CTO, ou=EMC APP, o=Easy Mail Company, c=US" -alias emccto -keypass kpi135 -keystore emcks -storepass ab987c
1:         keytool -selfcert -alias emccto -keypass kpi135 -validity 36500 -keystore emcks -storepass ab987c
1:         keytool -keystore emcks -storepass ab987c -list -v
1:         jarsigner -keystore emcks -storepass ab987c -keypass kpi135 -signedjar dcl_emc2s.jar dcl_emc2.jar emccto
1:         keytool -delete -alias emccto -keystore emcks -storepass ab987c
1:         </code>
1:      * @throws SQLException
1:      */
0:     public void testSignedJar() throws SQLException
1:     {
1:         // Statement to get the signers for a class loaded from a jar file
1:         PreparedStatement ps = prepareStatement("VALUES EMC.GETSIGNERS(?)");
1:         
1:         // current jar is unsigned.
1:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.emc");      
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         
1:         // replace with a signed jar
1:         replaceJar("dcl_emc2s.jar", "EMC.MAIL_APP");
1:         
1:         ps.close();
0:         ps = prepareStatement("VALUES EMC.GETSIGNERS(?)");
1:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.emc");    
1:         
1:         // now class is signed
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:                 "CN=EMC CTO, OU=EMC APP, O=Easy Mail Company, C=US");
1:         
1:         // verify the other jar is still not signed
1:         ps.setString(1, "org.apache.derbyTesting.databaseclassloader.addon.vendor.util");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Replace the signed jar with a hacked jar. emc.class modified to diable
1:      * valid e-mail address check but using same signatures within jar.
1:      * Class loader should reject.
1:      * 
1:      * rejects it.
1:      * @throws SQLException
1:      */
0:     public void testHackedJarReplacedClass() throws SQLException {
1: 
1:         replaceJar("dcl_emc2sm.jar", "EMC.MAIL_APP");
1:         
1:         try {
1:             CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:             cs.setInt(1, 99);
1:             cs.setString(2, "spamking@cracker.org");
1:             cs.executeUpdate();
1:             cs.close();
1:             fail("procedure call worked on hacked jar");
1:         } catch (SQLException e) {
1:             assertSQLState("Class load should fail due to invalid signature", "42X51", e);
1:         }
1:     }
1:     
1:     /**
1:      * replace with a hacked jar file, emc.class modified to 
1:      be an invalid class (no signing on this jar).
1:      */
0:     public void testInvalidJar() throws SQLException
1:     {
1:         replaceJar("dcl_emc2l.jar", "EMC.MAIL_APP");
1:         
1:         try {
1:             CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:             cs.setInt(1, 999);
1:             cs.setString(2, "spamking2@cracker.org");
1:             cs.executeUpdate();
1:             cs.close();
1:             fail("procedure call worked on invalid jar");
1:         } catch (SQLException e) {
1:             assertSQLState("Class load should fail due to invalid jar", "42X51", e);
1: 
1:         }        
1:     }
1:     
1:     public void testRemoveJar() throws SQLException
1:     {
1:         CallableStatement cs = prepareCall("CALL SQLJ.REMOVE_JAR(?, 0)");
1:         
1:         cs.setString(1, "EMC.MAIL_APP");
1:         
1:         // fail if jar is on classpath
1:         try {
1:             cs.executeUpdate();
1:             fail("REMOVE_JAR on jar in derby.database.classpath worked");
1:         } catch (SQLException e) {
1:             assertSQLState("X0X07", e);
1:         }
1:         
1:         // remove from classpath 
1:         setDBClasspath("\"emcAddOn\".\"MailAddOn\"");
1:         testWithNoInstalledJars();
1:         cs.executeUpdate();      
1:         testWithNoInstalledJars();
1:         
1:         // remove the second jar
1:         setDBClasspath(null);
1:         cs.setString(1, "\"emcAddOn\".\"MailAddOn\"");
1:         cs.executeUpdate();
1:         
1:         cs.close();
1:     }
1:   
0:     private void installJar(String resource, String jarName) throws SQLException
1:     {
0:         URL jar =
0:             getTestResource(
0:                "org/apache/derbyTesting/functionTests/tests/lang/" + resource);
1:         
1:         assertNotNull(resource, jar);
1:         
1:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, jarName);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1:     
0:     private void replaceJar(String resource, String jarName) throws SQLException
1:     {
0:         URL jar =
0:             getTestResource(
0:                "org/apache/derbyTesting/functionTests/tests/lang/" + resource);
1:         
1:         assertNotNull(resource, jar);
1:         
1:         CallableStatement cs = prepareCall("CALL SQLJ.REPLACE_JAR(?, ?)");
1:         cs.setString(1, jar.toExternalForm());
1:         cs.setString(2, jarName);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
1:     
commit:cef7d1e
/////////////////////////////////////////////////////////////////////////
1:         
1:         
0:           suite.addTest(new DatabaseClassLoadingTest("testWithNoInstalledJars"));
0:           suite.addTest(
0:                 SecurityManagerSetup.noSecurityManager(
0:                 new DatabaseClassLoadingTest("testWithNoClasspath")));
0:           suite.addTest(
0:                 SecurityManagerSetup.noSecurityManager(
0:                         new DatabaseClassLoadingTest("testSetClasspath")));
1:         
1:           
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                 new DatabaseClassLoadingTest("testGetResource")));
1:            
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                    new DatabaseClassLoadingTest("testAlterTable")));
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Alter the table to add a column, the add contact procedure
1:      * should still work.
1:      * @throws SQLException
1:      */
1:     public void testAlterTable() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("ALTER TABLE EMC.CONTACTS ADD COLUMN OK SMALLINT");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:                 new String[][] {
1:                     {"0", "now@classpathchange.com", null},
1:                     {"1", "bill@ruletheworld.com", null},
1:                     {"2", "penguin@antartic.com", null},
1:                     });
1:         
1:         // well written application, INSERT used explicit column names
1:         // ok defaults to NULL
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 3);
1:         cs.setString(2, "big@blue.com");
1:         cs.executeUpdate();
1:         cs.close();
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("SELECT id, e_mail, ok from EMC.CONTACTS ORDER BY 1"),
1:                 new String[][] {
1:                     {"0", "now@classpathchange.com", null},
1:                     {"1", "bill@ruletheworld.com", null},
1:                     {"2", "penguin@antartic.com", null},
1:                     {"3", "big@blue.com", null},
1:                     });
1:       
1:         s.close();
1:     }
1:     
commit:9528482
/////////////////////////////////////////////////////////////////////////
1:         // Need DriverManager to execute the add contact procedure
1:         // as it uses server side jdbc.
1:         if (JDBC.vmSupportsJDBC3()) {
0:            suite.addTest(SecurityManagerSetup.noSecurityManager(
1:         }
/////////////////////////////////////////////////////////////////////////
1:         getTestConfiguration().shutdownDatabase(); 
commit:36d1b35
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.lang;
0: 
1: import java.net.URL;
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: 
1: /**
1:  * Test database class loading, executing routines from the
0:  * installed jars including accessing resources.
1:  *
1:  */
1: public class DatabaseClassLoadingTest extends BaseJDBCTestCase {
0:     
1:     public DatabaseClassLoadingTest(String name)
1:     {
1:         super(name);
1:     }
0: 
1:     /**
1:      * Run the tests only in embedded since this is testing
1:      * server side behaviour. Due to DERBY-537 and DERBY-2040
0:      * most of the tests are run without a secuirty manager.
1:      * Ordering is important here so the fixtures are added
1:      * explicitly.
1:      */
0:     public static Test suite()
1:     {
0:         final TestSuite suite = new TestSuite("DatabaseClassLoadingTest");
0:         
0:         suite.addTest(new DatabaseClassLoadingTest("testWithNoInstalledJars"));
0:         suite.addTest(
0:                 SecurityManagerSetup.noSecurityManager(
0:                 new DatabaseClassLoadingTest("testWithNoClasspath")));
0:         suite.addTest(
0:                 SecurityManagerSetup.noSecurityManager(
0:                         new DatabaseClassLoadingTest("testSetClasspath")));
0:         
0:         suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                 new DatabaseClassLoadingTest("testAddContact")));
0:         
0:         suite.addTest(SecurityManagerSetup.noSecurityManager(
0:                 new DatabaseClassLoadingTest("testGetResource")));        
0:         
0:         return new CleanDatabaseTestSetup(suite) {
1:             protected void decorateSQL(Statement s) throws SQLException
1:             {
1:                 s.executeUpdate("create schema emc");
1:                 s.executeUpdate("create table emc.contacts " +
1:                         "(id int primary key, e_mail varchar(30))");
1:                 s.executeUpdate(
1:                   "create procedure EMC.ADDCONTACT(id INT, e_mail VARCHAR(30)) " +
1:                   "MODIFIES SQL DATA " +
1:                   "external name 'org.apache.derbyTesting.databaseclassloader.emc.addContact' " +
1:                   "language java parameter style java");
0: 
1:                 s.executeUpdate(
0:                   "create function EMC.GETARTICLE(path VARCHAR(40)) " +
1:                   "RETURNS VARCHAR(256) " +
1:                   "NO SQL " +
1:                   "external name 'org.apache.derbyTesting.databaseclassloader.emc.getArticle' " +
1:                   "language java parameter style java");
1:                 }
1:         };
1:     }
0:     
1:     /**
1:      * Test the routines fail before the jars that contain their
1:      * code have been installed and/or set in the classpath.
1:      * @throws SQLException
1:      */
1:     public void testWithNoInstalledJars() throws SQLException {
0:         try {
1:             prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:             fail("prepareCall on procedure with path to class");
1:         } catch (SQLException e) {
1:             assertSQLState("42X51", e);
1:         }
0:         try {
1:             prepareStatement("VALUES EMC.GETARTICLE(?)");
1:             fail("prepareCall on function with path to class");
1:         } catch (SQLException e) {
1:             assertSQLState("42X51", e);
1:         }
1:     }
0:     
1:     /**
1:      * Install the jar, but don't set the classpath.
1:      * @throws SQLException
1:      */
0:     public void testWithNoClasspath() throws SQLException
1:     {       
0:         URL jar =
0:             getTestResource("org/apache/derbyTesting/functionTests/tests/lang/dcl_emc1.jar");
0:         
0:         assertNotNull(jar);
0:         CallableStatement cs = prepareCall("CALL SQLJ.INSTALL_JAR(?, ?, 0)");
0:         
0:         cs.setString(1, jar.toExternalForm());
0:         cs.setString(2, "EMC.MAIL_APP");
1:         cs.executeUpdate();
1:         cs.close();
0: 
1:         testWithNoInstalledJars();
1:     }
0:     
1:     /**
1:      * Set the classpath to include the MAIL_APP jar.
1:      * @throws SQLException
1:      */
1:     public void testSetClasspath() throws SQLException
1:     {
1:         setDBClasspath("EMC.MAIL_APP");
0:         
1:         // Test we don't need a re-boot to see the new classes.
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 0);
1:         cs.setString(2, "now@classpathchange.com");
1:         cs.executeUpdate();
1:         cs.close();
0:         
1:         derby2035Workaround();
1:     }
0:     
1:     /**
1:      * Test that a new connection successfully sees the changes.
1:      * @throws SQLException
1:      */
1:     public void testAddContact() throws SQLException
1:     {
1:         CallableStatement cs = prepareCall("CALL EMC.ADDCONTACT(?, ?)");
1:         cs.setInt(1, 1);
1:         cs.setString(2, "bill@ruletheworld.com");
1:         cs.executeUpdate();
0:         
1:         cs.setInt(1, 2);
1:         cs.setString(2, "penguin@antartic.com");
1:         cs.executeUpdate();
0:         
1:         cs.close();
0:         
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery(
1:                 "SELECT id, e_mail from EMC.CONTACTS ORDER BY 1");
0:         
1:         JDBC.assertFullResultSet(rs,
1:                 new String[][] {
1:                 {"0", "now@classpathchange.com"},
1:                 {"1", "bill@ruletheworld.com"},
1:                 {"2", "penguin@antartic.com"},
0:                 });
0:         
0:         s.close();
1:     }
0:     
1:     public void testGetResource() throws SQLException
1:     {
0:         PreparedStatement ps = prepareStatement("VALUES EMC.GETARTICLE(?)");
0:         
1:         // Simple path should be prepended with the package name
1:         // of the class executing the code to find
1:         // /org/apache/derbyTesting/databaseclassloader/graduate.txt
1:         ps.setString(1, "graduate.txt");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:                 "The Apache Foundation has released the first version of " +
1:                 "the open-source Derby database, which also gained support " +
1:                 "from Sun Microsystems.");
0:         
0: 
1:         // absolute path within the jar.
1:         ps.setString(1, "/article/release.txt");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(),
1:                 "The Apache Derby development community is pleased to announce " +
1:                 "its first release after graduating from the Apache Incubator, " +
1:                 "Apache Derby 10.1.1.0.");
0:         
0:         
1:         // Resources that don't exist, returns NULL.
1:         ps.setString(1, "barney.txt");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setString(1, "/article/fred.txt");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
0:     
1:         // Accessing the class file is disallowed as well by
1:         // returning a NULL
1:         ps.setString(1, "emc.class");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setString(1, "/org/apache/derbyTesting/databaseclassloader/emc.class");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
0:         
1:         ps.close();
1:     }
0:     
1:     private void setDBClasspath(String cp) throws SQLException
1:     {
1:         CallableStatement cs = prepareCall(
1:           "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.database.classpath', ?)");
0: 
1:         cs.setString(1, cp);
1:         cs.executeUpdate();
1:         cs.close();
1:     }
0:     
1:     private void derby2035Workaround() throws SQLException
1:     {
1:         // DERBY-2035 Other connections, e.g. the next fixture
1:         // do not see the changes related to the new class path
1:         // until the database is shutdown. However, the connection
1:         // setting the change does see it!
1:         // 
1:         getConnection().close();
0:         try {
0:             TestConfiguration.getCurrent().getDefaultConnection(
0:                     "shutdown=true");
0:             fail("Database failed to shut down");
1:         } catch (SQLException e) {
0:             assertSQLState("Database shutdown", "08006", e);
1:         }  
1:     }
1: }
============================================================================