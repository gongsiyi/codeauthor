1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.WriteCursorConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
23:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:1e2aae0: import java.io.IOException;
1:1e2aae0: import java.io.ObjectInput;
1:1e2aae0: import java.io.ObjectOutput;
1:1e2aae0: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:1e2aae0: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.services.io.ArrayUtil;
1:1e2aae0: import org.apache.derby.iapi.services.io.Formatable;
1:1e2aae0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:1e2aae0: import org.apache.derby.iapi.sql.Activation;
1:1e2aae0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:1e2aae0: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:1e2aae0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: 
1:eac0369: 
6:eac0369: /**
1:eac0369:  *	This abstract class describes compiled constants that are passed into
1:eac0369:  *	Delete, Insert, and Update ResultSets.
8:eac0369:  *
1:e4fa8cb:  *  This class and its sub-classes are not really implementations
1:e4fa8cb:  *  of ConstantAction, since they are not executed.
1:e4fa8cb:  *  
1:e4fa8cb:  *  A better name for these classes would be 'Constants'.
1:e4fa8cb:  *  E.g. WriteCursorConstants, DeleteConstants.
1:e4fa8cb:  *  
1:e4fa8cb:  *  Ideally one day the split will occur.
1:e4fa8cb:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: abstract	class WriteCursorConstantAction implements ConstantAction, Formatable
4:eac0369: {
1:eac0369: 
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. But it is NOT used
1:eac0369:  	**	across either major or minor releases.  It is only
1:c69c8b0: 	** 	written persistently in stored prepared statements, 
1:c69c8b0: 	**	not in the replication stage.  SO, IT IS OK TO CHANGE
1:c69c8b0: 	**	ITS read/writeExternal.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:eac0369: 
1:5b2f5de: 	long						conglomId;
1:5b2f5de: 	StaticCompiledOpenConglomInfo heapSCOCI;
1:5b2f5de: 	IndexRowGenerator[] 		irgs;
1:5b2f5de: 	long[]						indexCIDS;
1:5b2f5de: 	StaticCompiledOpenConglomInfo[] indexSCOCIs;
1:5b2f5de: 	String[]					indexNames;
1:5b2f5de: 	boolean						deferred;
1:5b2f5de: 	private  Properties			targetProperties;
1:5b2f5de: 	UUID						targetUUID;
1:5b2f5de: 	int							lockMode;
1:eac0369: 	private	FKInfo[]					fkInfo;
1:eac0369: 	private TriggerInfo					triggerInfo;
1:eac0369: 
1:eac0369: 	private FormatableBitSet baseRowReadList;
1:eac0369: 	private int[] baseRowReadMap;
1:eac0369: 	private int[] streamStorableHeapColIds;
1:5b2f5de: 	boolean singleRowSource;
1:eac0369: 
1:01632c2:     /** True if this is an action of a MERGE statement */
1:01632c2:     private boolean underMerge;
1:01632c2: 
1:eac0369: 
1:eac0369: 	// CONSTRUCTORS
1:eac0369: 
1:51572c8: 	/**
1:eac0369: 	 * Public niladic constructor. Needed for Formatable interface to work.
1:eac0369: 	 *
1:51572c8: 	 */
1:eac0369:     public	WriteCursorConstantAction() {}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a DELETE, INSERT, or UPDATE statement.
1:eac0369: 	 *
1:eac0369: 	 *  @param conglomId	Conglomerate ID of heap.
1:eac0369: 	 *	@param heapSCOCI	StaticCompiledOpenConglomInfo for heap.
1:eac0369: 	 *  @param irgs			Index descriptors
1:eac0369: 	 *  @param indexCIDS	Conglomerate IDs of indices
1:eac0369: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
1:eac0369: 	 *  @param indexNames   Names of indices on this table for error reporting.
1:eac0369: 	 *  @param deferred		True means process as a deferred update
1:eac0369: 	 *  @param targetProperties	Properties on the target table
1:eac0369: 	 *	@param targetUUID	UUID of target table
1:eac0369: 	 *	@param lockMode		The lock mode to use on the target table
1:eac0369: 	 *	@param fkInfo	Structure containing foreign key info, if any (may be null)
1:eac0369: 	 *	@param triggerInfo	Structure containing trigger info, if any (may be null)
1:dbed020: 	 *  @param baseRowReadMap	BaseRowReadMap[heapColId]-&gt;ReadRowColumnId. (0 based)
1:eac0369:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
1:eac0369: 	 *  @param singleRowSource		Whether or not source is a single row source
1:01632c2: 	 *  @param underMerge   True if this action is under a MERGE statement
1:eac0369: 	 */
1:eac0369: 	public	WriteCursorConstantAction(
1:eac0369: 								long				conglomId,
1:eac0369: 								StaticCompiledOpenConglomInfo heapSCOCI,
1:eac0369: 								IndexRowGenerator[]	irgs,
1:eac0369: 								long[]				indexCIDS,
1:eac0369: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1:eac0369: 								String[]			indexNames,
1:eac0369: 								boolean				deferred,
1:eac0369: 								Properties			targetProperties,
1:eac0369: 								UUID				targetUUID,
1:eac0369: 								int					lockMode,
1:eac0369: 								FKInfo[]			fkInfo,
1:eac0369: 								TriggerInfo			triggerInfo,
1:eac0369: 								FormatableBitSet				baseRowReadList,
1:eac0369: 								int[]               baseRowReadMap,
1:eac0369: 								int[]               streamStorableHeapColIds,
1:01632c2: 								boolean				singleRowSource,
1:01632c2: 								boolean				underMerge
2:eac0369: 								)
1:eac0369: 	{
1:eac0369: 		this.conglomId = conglomId;
1:eac0369: 		this.heapSCOCI = heapSCOCI;
1:eac0369: 		this.irgs = irgs;
1:eac0369: 		this.indexSCOCIs = indexSCOCIs;
1:eac0369: 		this.indexCIDS = indexCIDS;
1:eac0369: 		this.indexSCOCIs = indexSCOCIs;
1:eac0369: 		this.deferred = deferred;
1:eac0369: 		this.targetProperties = targetProperties;
1:eac0369: 		this.targetUUID = targetUUID;
1:eac0369: 		this.lockMode = lockMode;
1:eac0369: 		this.fkInfo = fkInfo;
1:eac0369: 		this.triggerInfo = triggerInfo;
1:eac0369: 		this.baseRowReadList = baseRowReadList;
1:eac0369: 		this.baseRowReadMap = baseRowReadMap;
1:eac0369: 		this.streamStorableHeapColIds = streamStorableHeapColIds;
1:eac0369: 		this.singleRowSource = singleRowSource;
1:eac0369: 		this.indexNames = indexNames;
1:01632c2:         this.underMerge = underMerge;
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (fkInfo != null)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(fkInfo.length != 0, "fkinfo array has no elements, if there are no foreign keys, then pass in null");
4:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	ACCESSORS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets the foreign key information for this constant action.
1:eac0369: 	  *	A full list of foreign keys was compiled into this constant
1:4119c42: 	  *	action.
1:eac0369: 	  *
1:eac0369: 	  *
1:eac0369: 	  *	@return	the list of foreign keys to enforce for this action
1:eac0369: 	  *
1:eac0369: 	  */
1:4119c42: 	final FKInfo[] getFKInfo()
1:eac0369: 	{
1:4119c42: 		return fkInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Basically, the same as getFKInfo but for triggers.
1:eac0369: 	 *
1:eac0369: 	 * @return	the triggers that should be fired
1:eac0369: 	 *
1:eac0369: 	 */
1:4119c42: 	TriggerInfo getTriggerInfo()
1:eac0369: 	{
1:4119c42: 		return triggerInfo;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// INTERFACE METHODS
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	NOP routine. The work is done in InsertResultSet.
1:eac0369: 	 *
1:eac0369: 	 *	@see ConstantAction#executeConstantAction
1:eac0369: 	 *
3:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:b771bbc: 	public final void	executeConstantAction( Activation activation )
1:eac0369: 		throws StandardException { }
1:eac0369: 
1:eac0369: 	// Formatable methods
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void readExternal( ObjectInput in )
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		conglomId = in.readLong();
1:eac0369: 		heapSCOCI = (StaticCompiledOpenConglomInfo) in.readObject();
1:eac0369: 		irgs = new IndexRowGenerator[ArrayUtil.readArrayLength(in)];
1:eac0369: 		ArrayUtil.readArrayItems(in, irgs);
1:eac0369: 
1:eac0369: 		indexCIDS = ArrayUtil.readLongArray(in);
1:eac0369: 		indexSCOCIs = new StaticCompiledOpenConglomInfo[ArrayUtil.readArrayLength(in)];
1:eac0369: 		ArrayUtil.readArrayItems(in, indexSCOCIs);
1:eac0369: 
1:eac0369: 		deferred = in.readBoolean();
1:eac0369: 		targetProperties = (Properties) in.readObject();
1:eac0369: 		targetUUID = (UUID) in.readObject();
1:eac0369: 		lockMode = in.readInt();
1:eac0369: 
1:eac0369: 		fkInfo = new FKInfo[ArrayUtil.readArrayLength(in)];
1:eac0369: 		ArrayUtil.readArrayItems(in, fkInfo);
1:eac0369: 
1:eac0369: 		triggerInfo = (TriggerInfo)in.readObject();
1:eac0369: 
1:eac0369: 		baseRowReadList = (FormatableBitSet)in.readObject();
1:eac0369: 		baseRowReadMap = ArrayUtil.readIntArray(in);
1:eac0369: 		streamStorableHeapColIds = ArrayUtil.readIntArray(in); 
1:eac0369: 		singleRowSource = in.readBoolean();
1:eac0369: 		indexNames = ArrayUtil.readStringArray(in);
1:01632c2:         underMerge = in.readBoolean();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal( ObjectOutput out )
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		out.writeLong(conglomId);
1:eac0369: 		out.writeObject(heapSCOCI);
1:eac0369: 		ArrayUtil.writeArray(out, irgs);
1:eac0369: 		ArrayUtil.writeLongArray(out, indexCIDS);
1:eac0369: 		ArrayUtil.writeArray(out, indexSCOCIs);
1:eac0369: 		out.writeBoolean(deferred);
1:eac0369: 		out.writeObject(targetProperties);
1:eac0369: 		out.writeObject(targetUUID);
1:eac0369: 		out.writeInt(lockMode);
1:eac0369: 		ArrayUtil.writeArray(out, fkInfo);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Added for Xena.
1:eac0369: 		out.writeObject(triggerInfo);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Moved from super class for Xena.
1:eac0369: 		out.writeObject(baseRowReadList);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Added for Xena
1:eac0369: 		ArrayUtil.writeIntArray(out,baseRowReadMap);
1:eac0369: 		ArrayUtil.writeIntArray(out,streamStorableHeapColIds);
1:eac0369: 
1:eac0369: 		//Added for Buffy
1:eac0369: 		out.writeBoolean(singleRowSource);
1:eac0369: 		
1:eac0369: 		// Added for Mulan (Track Bug# 3322)
1:eac0369: 		ArrayUtil.writeArray(out, indexNames);
1:eac0369: 		
1:01632c2:         out.writeBoolean( underMerge );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// ACCESSORS
1:eac0369: 
1:01632c2:     /** Return true if this is an action of a MERGE statement */
1:01632c2:     public  boolean underMerge() { return underMerge; }
1:01632c2: 
1:eac0369: 	/**
1:eac0369: 	 * Get the conglomerate id for the changed heap.
1:eac0369: 	 * @return the conglomerate id.
1:eac0369: 	 */
1:eac0369: 	public long getConglomerateId() { return conglomId; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the targetProperties from the constant action.
1:eac0369: 	 *
1:eac0369: 	 * @return The targetProperties
1:eac0369: 	 */
1:eac0369: 	public Properties getTargetProperties()
1:eac0369: 	{
1:eac0369: 		return targetProperties;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The the value of the specified key, if it exists, from
1:eac0369: 	 * the targetProperties.
1:eac0369: 	 *
1:eac0369: 	 * @param key		The key to search for
1:eac0369: 	 *
1:eac0369: 	 * @return	The value for the specified key if it exists, otherwise null.
1:eac0369: 	 *			(Return null if targetProperties is null.)
1:eac0369: 	 */
1:eac0369: 	public String getProperty(String key)
1:eac0369: 	{
1:eac0369: 		return (targetProperties == null) ? null : targetProperties.getProperty(key);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public FormatableBitSet getBaseRowReadList() { return baseRowReadList; }
1:eac0369: 	public int[] getBaseRowReadMap() { return baseRowReadMap; }
1:eac0369: 	public int[] getStreamStorableHeapColIds() { return streamStorableHeapColIds; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * get the index name given the conglomerate id of the index.
1:eac0369: 	 * 
1:eac0369: 	 * @param indexCID		conglomerate ID of the index.
1:eac0369: 	 * 
1:eac0369: 	 * @return index name of given index.
1:eac0369: 	 */
1:eac0369: 	public String getIndexNameFromCID(long indexCID)
1:eac0369: 	{
1:eac0369: 		int size = indexCIDS.length;
1:eac0369: 
1:eac0369: 		if (indexNames == null) 
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		} 
1:eac0369: 		
1:eac0369: 		for (int i = 0; i < size; i++)
1:eac0369: 		{
1:eac0369: 			if (indexCIDS[i] == indexCID)
1:eac0369: 				return indexNames[i];
1:eac0369: 		}
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 			
1:eac0369: 	public String[] getIndexNames()
1:eac0369: 	{
1:eac0369: 		return indexNames;
1:eac0369: 	}
1:eac0369: }
1:eac0369:  
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param baseRowReadMap	BaseRowReadMap[heapColId]-&gt;ReadRowColumnId. (0 based)
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1:     /** True if this is an action of a MERGE statement */
1:     private boolean underMerge;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param underMerge   True if this action is under a MERGE statement
/////////////////////////////////////////////////////////////////////////
1: 								boolean				singleRowSource,
1: 								boolean				underMerge
/////////////////////////////////////////////////////////////////////////
1:         this.underMerge = underMerge;
/////////////////////////////////////////////////////////////////////////
1:         underMerge = in.readBoolean();
/////////////////////////////////////////////////////////////////////////
1:         out.writeBoolean( underMerge );
1:     /** Return true if this is an action of a MERGE statement */
1:     public  boolean underMerge() { return underMerge; }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 	** 	written persistently in stored prepared statements, 
1: 	**	not in the replication stage.  SO, IT IS OK TO CHANGE
1: 	**	ITS read/writeExternal.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:51572c8
/////////////////////////////////////////////////////////////////////////
0: 	** 	written persistently in stored prepared statements.
0:     *   SO, IT IS OK TO CHANGE ITS read/writeExternal.
1:     /**
0:      * Heap conglomerate identifier.
1:      */
commit:e5bbea4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			emptyHeapRow = td.getEmptyExecRow();
commit:6f30d2c
/////////////////////////////////////////////////////////////////////////
commit:4119c42
/////////////////////////////////////////////////////////////////////////
1: 	  *	action.
1: 	final FKInfo[] getFKInfo()
1: 		return fkInfo;
/////////////////////////////////////////////////////////////////////////
1: 	TriggerInfo getTriggerInfo()
1: 		return triggerInfo;
commit:e4fa8cb
/////////////////////////////////////////////////////////////////////////
1:  *  This class and its sub-classes are not really implementations
1:  *  of ConstantAction, since they are not executed.
1:  *  
1:  *  A better name for these classes would be 'Constants'.
1:  *  E.g. WriteCursorConstants, DeleteConstants.
1:  *  
1:  *  Ideally one day the split will occur.
1:  *
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.io.ArrayUtil;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
commit:9cd47dc
/////////////////////////////////////////////////////////////////////////
commit:b771bbc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public final void	executeConstantAction( Activation activation )
commit:5b2f5de
/////////////////////////////////////////////////////////////////////////
1: 	long						conglomId;
1: 	StaticCompiledOpenConglomInfo heapSCOCI;
1: 	IndexRowGenerator[] 		irgs;
1: 	long[]						indexCIDS;
1: 	StaticCompiledOpenConglomInfo[] indexSCOCIs;
1: 	String[]					indexNames;
1: 	boolean						deferred;
1: 	private  Properties			targetProperties;
1: 	UUID						targetUUID;
1: 	int							lockMode;
/////////////////////////////////////////////////////////////////////////
1: 	boolean singleRowSource;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.WriteCursorConstantAction
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: 
0: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
1: 
0: import java.util.Properties;
1: 
1: 
1: /**
1:  *	This abstract class describes compiled constants that are passed into
1:  *	Delete, Insert, and Update ResultSets.
1:  *
0:  *	@author Rick Hillegas
1:  */
1: 
1: abstract	class WriteCursorConstantAction implements ConstantAction, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. But it is NOT used
1:  	**	across either major or minor releases.  It is only
0: 	** 	written persistently in stored prepared statements, 
0: 	**	not in the replication stage.  SO, IT IS OK TO CHANGE
0: 	**	ITS read/writeExternal.
1: 	**
1: 	********************************************************/
1: 
0: 	public	long						conglomId;
0: 	public  StaticCompiledOpenConglomInfo heapSCOCI;
0: 	public	IndexRowGenerator[] 		irgs;
0: 	public	long[]						indexCIDS;
0: 	public  StaticCompiledOpenConglomInfo[] indexSCOCIs;
0: 	public  String[]					indexNames;
0: 	public	boolean						deferred;
0: 	public  Properties					targetProperties;
0: 	public	UUID						targetUUID;
0: 	public	int							lockMode;
1: 	private	FKInfo[]					fkInfo;
1: 	private TriggerInfo					triggerInfo;
1: 
0: 	private ExecRow						emptyHeapRow;
1: 	private FormatableBitSet baseRowReadList;
1: 	private int[] baseRowReadMap;
1: 	private int[] streamStorableHeapColIds;
0: 	public boolean singleRowSource;
1: 
1: 
1: 	// CONSTRUCTORS
1: 
1: 	/**
1: 	 * Public niladic constructor. Needed for Formatable interface to work.
1: 	 *
1: 	 */
1:     public	WriteCursorConstantAction() {}
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a DELETE, INSERT, or UPDATE statement.
1: 	 *
1: 	 *  @param conglomId	Conglomerate ID of heap.
1: 	 *	@param heapSCOCI	StaticCompiledOpenConglomInfo for heap.
1: 	 *  @param irgs			Index descriptors
1: 	 *  @param indexCIDS	Conglomerate IDs of indices
1: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
1: 	 *  @param indexNames   Names of indices on this table for error reporting.
1: 	 *  @param deferred		True means process as a deferred update
1: 	 *  @param targetProperties	Properties on the target table
1: 	 *	@param targetUUID	UUID of target table
1: 	 *	@param lockMode		The lock mode to use on the target table
1: 	 *	@param fkInfo	Structure containing foreign key info, if any (may be null)
1: 	 *	@param triggerInfo	Structure containing trigger info, if any (may be null)
0: 	 *  @param emptyHeapRow	an empty heap row
0: 	 *  @param baseRowReadMap	BaseRowReadMap[heapColId]->ReadRowColumnId. (0 based)
1:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *  @param numColumns	Number of columns to read.
1: 	 *  @param singleRowSource		Whether or not source is a single row source
1: 	 */
1: 	public	WriteCursorConstantAction(
1: 								long				conglomId,
1: 								StaticCompiledOpenConglomInfo heapSCOCI,
1: 								IndexRowGenerator[]	irgs,
1: 								long[]				indexCIDS,
1: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
1: 								String[]			indexNames,
1: 								boolean				deferred,
1: 								Properties			targetProperties,
1: 								UUID				targetUUID,
1: 								int					lockMode,
1: 								FKInfo[]			fkInfo,
1: 								TriggerInfo			triggerInfo,
0: 								ExecRow				emptyHeapRow,
1: 								FormatableBitSet				baseRowReadList,
1: 								int[]               baseRowReadMap,
1: 								int[]               streamStorableHeapColIds,
0: 								boolean				singleRowSource
1: 								)
1: 	{
1: 		this.conglomId = conglomId;
1: 		this.heapSCOCI = heapSCOCI;
1: 		this.irgs = irgs;
1: 		this.indexSCOCIs = indexSCOCIs;
1: 		this.indexCIDS = indexCIDS;
1: 		this.indexSCOCIs = indexSCOCIs;
1: 		this.deferred = deferred;
1: 		this.targetProperties = targetProperties;
1: 		this.targetUUID = targetUUID;
1: 		this.lockMode = lockMode;
0: 		this.emptyHeapRow = emptyHeapRow;
1: 		this.fkInfo = fkInfo;
1: 		this.triggerInfo = triggerInfo;
1: 		this.baseRowReadList = baseRowReadList;
1: 		this.baseRowReadMap = baseRowReadMap;
1: 		this.streamStorableHeapColIds = streamStorableHeapColIds;
1: 		this.singleRowSource = singleRowSource;
1: 		this.indexNames = indexNames;
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (fkInfo != null)
1: 			{
1: 				SanityManager.ASSERT(fkInfo.length != 0, "fkinfo array has no elements, if there are no foreign keys, then pass in null");
1: 			}
1: 		}
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////
1: 	//
1: 	//	ACCESSORS
1: 	//
1: 	///////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	  *	Gets the foreign key information for this constant action.
1: 	  *	A full list of foreign keys was compiled into this constant
0: 	  *	action. However, we prune this list at run time so that we
0: 	  *	enforce only the foreign keys that we absolutely must.
1: 	  *
0: 	  *	What's going on here? Well, in certain contexts (REFRESH and
0: 	  *	when intially booting a Target), we don't have to enforce some
0: 	  *	foreign keys. We allow the ExecutionContext to rule on which
0: 	  *	foreign keys are relevant and which aren't.
1: 	  *
0: 	  *	@param	ec	the ExecutionContext
1: 	  *
1: 	  *	@return	the list of foreign keys to enforce for this action
1: 	  *
1: 	  * @exception StandardException		Thrown on failure
1: 	  */
0: 	public	FKInfo[]	getFKInfo
0: 	(
0: 		ExecutionContext	ec
1:     )
0: 		throws StandardException
1: 	{
0: 		FKInfo[]	siftedArray = (FKInfo[]) ec.siftForeignKeys( fkInfo );
1: 
0: 		return siftedArray;
1: 	}
1: 
1: 	/**
1: 	 * Basically, the same as getFKInfo but for triggers.
1: 	 *
1: 	 * @return	the triggers that should be fired
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public TriggerInfo getTriggerInfo(ExecutionContext ec) 
0: 		throws StandardException
1: 	{
0: 		return (TriggerInfo)ec.siftTriggers(triggerInfo);
1: 	}
1: 
1: 
1: 	///////////////////////////////////////////////////////////////////
1: 	//
1: 	// INTERFACE METHODS
1: 	//
1: 	///////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
0: 	  *	Reports whether these constants are up-to-date. This returns true
0: 	  *	for homogenous Cloudscape/Cloudsync. For the Plugin, this may
0: 	  *	return false;
1: 	  *
0: 	  *	@return	true if these constants are up-to-date
0: 	  *			false otherwise
1: 	  */
0: 	public	boolean	upToDate()
0: 	{ return true; }
1: 
1: 	/**
1: 	 *	NOP routine. The work is done in InsertResultSet.
1: 	 *
1: 	 *	@see ConstantAction#executeConstantAction
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public void	executeConstantAction( Activation activation )
1: 		throws StandardException { }
1: 
1: 	// Formatable methods
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal( ObjectInput in )
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		conglomId = in.readLong();
1: 		heapSCOCI = (StaticCompiledOpenConglomInfo) in.readObject();
1: 		irgs = new IndexRowGenerator[ArrayUtil.readArrayLength(in)];
1: 		ArrayUtil.readArrayItems(in, irgs);
1: 
1: 		indexCIDS = ArrayUtil.readLongArray(in);
1: 		indexSCOCIs = new StaticCompiledOpenConglomInfo[ArrayUtil.readArrayLength(in)];
1: 		ArrayUtil.readArrayItems(in, indexSCOCIs);
1: 
1: 		deferred = in.readBoolean();
1: 		targetProperties = (Properties) in.readObject();
1: 		targetUUID = (UUID) in.readObject();
1: 		lockMode = in.readInt();
1: 
1: 		fkInfo = new FKInfo[ArrayUtil.readArrayLength(in)];
1: 		ArrayUtil.readArrayItems(in, fkInfo);
1: 
1: 		triggerInfo = (TriggerInfo)in.readObject();
1: 
1: 		baseRowReadList = (FormatableBitSet)in.readObject();
1: 		baseRowReadMap = ArrayUtil.readIntArray(in);
1: 		streamStorableHeapColIds = ArrayUtil.readIntArray(in); 
1: 		singleRowSource = in.readBoolean();
1: 		indexNames = ArrayUtil.readStringArray(in);
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException		thrown on error
1: 	 */
1: 	public void writeExternal( ObjectOutput out )
1: 		 throws IOException
1: 	{
1: 		out.writeLong(conglomId);
1: 		out.writeObject(heapSCOCI);
1: 		ArrayUtil.writeArray(out, irgs);
1: 		ArrayUtil.writeLongArray(out, indexCIDS);
1: 		ArrayUtil.writeArray(out, indexSCOCIs);
1: 		out.writeBoolean(deferred);
1: 		out.writeObject(targetProperties);
1: 		out.writeObject(targetUUID);
1: 		out.writeInt(lockMode);
1: 		ArrayUtil.writeArray(out, fkInfo);
1: 
1: 		//
1: 		//Added for Xena.
1: 		out.writeObject(triggerInfo);
1: 
1: 		//
1: 		//Moved from super class for Xena.
1: 		out.writeObject(baseRowReadList);
1: 
1: 		//
1: 		//Added for Xena
1: 		ArrayUtil.writeIntArray(out,baseRowReadMap);
1: 		ArrayUtil.writeIntArray(out,streamStorableHeapColIds);
1: 
1: 		//Added for Buffy
1: 		out.writeBoolean(singleRowSource);
1: 		
1: 		// Added for Mulan (Track Bug# 3322)
1: 		ArrayUtil.writeArray(out, indexNames);
1: 		
1: 	}
1: 
1: 	// ACCESSORS
1: 
1: 	/**
1: 	 * Get the conglomerate id for the changed heap.
1: 	 * @return the conglomerate id.
1: 	 */
1: 	public long getConglomerateId() { return conglomId; }
1: 		
1: 	/**
0: 	 *	Get emptyHeapRow
1: 	 *
0: 	 * @param lcc	The LanguageConnectionContext to use.
1: 	 *
0: 	 * @return	an empty base table row for the table being updated.
1: 	 *
0: 	 * @exception StandardException on error
1: 	 */
0: 	public ExecRow getEmptyHeapRow(LanguageConnectionContext lcc) throws StandardException
1: 	{
0: 		DataDictionary dd;
0: 		TableDescriptor td;
1: 
0: 		if (emptyHeapRow == null)
1: 		{
1: 
0: 			dd = lcc.getDataDictionary();
1: 	
0: 			td = dd.getTableDescriptor(targetUUID);
1: 	
0: 			emptyHeapRow = td.getEmptyExecRow(lcc.getContextManager());
1: 		}
1: 
0: 		return emptyHeapRow.getClone();
1: 	}
1: 
1: 	/**
1: 	 * Get the targetProperties from the constant action.
1: 	 *
1: 	 * @return The targetProperties
1: 	 */
1: 	public Properties getTargetProperties()
1: 	{
1: 		return targetProperties;
1: 	}
1: 
1: 	/**
1: 	 * The the value of the specified key, if it exists, from
1: 	 * the targetProperties.
1: 	 *
1: 	 * @param key		The key to search for
1: 	 *
1: 	 * @return	The value for the specified key if it exists, otherwise null.
1: 	 *			(Return null if targetProperties is null.)
1: 	 */
1: 	public String getProperty(String key)
1: 	{
1: 		return (targetProperties == null) ? null : targetProperties.getProperty(key);
1: 	}
1: 
1: 	public FormatableBitSet getBaseRowReadList() { return baseRowReadList; }
1: 	public int[] getBaseRowReadMap() { return baseRowReadMap; }
1: 	public int[] getStreamStorableHeapColIds() { return streamStorableHeapColIds; }
1: 
1: 	/**
1: 	 * get the index name given the conglomerate id of the index.
1: 	 * 
1: 	 * @param indexCID		conglomerate ID of the index.
1: 	 * 
1: 	 * @return index name of given index.
1: 	 */
1: 	public String getIndexNameFromCID(long indexCID)
1: 	{
1: 		int size = indexCIDS.length;
1: 
1: 		if (indexNames == null) 
1: 		{
1: 			return null;
1: 		} 
1: 		
1: 		for (int i = 0; i < size; i++)
1: 		{
1: 			if (indexCIDS[i] == indexCID)
1: 				return indexNames[i];
1: 		}
1: 		return null;
1: 	}
1: 			
1: 	public String[] getIndexNames()
1: 	{
1: 		return indexNames;
1: 	}
1: 
1: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
1: 	 *
0: 	 * @param tableId on error
1: 	 *
1: 	 */
0: 	public boolean modifiesTableId(UUID tableId)
1: 	{
0: 		return ((tableId != null) && (targetUUID != null)) ?
0: 			tableId.equals(targetUUID) :
0: 			false;
1: 	}
1: }
1:  
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: 
0: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.util.Properties;
0: 
0: 
0: /**
0:  *	This abstract class describes compiled constants that are passed into
0:  *	Delete, Insert, and Update ResultSets.
0:  *
0:  *	@author Rick Hillegas
0:  */
0: 
0: abstract	class WriteCursorConstantAction implements ConstantAction, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. But it is NOT used
0:  	**	across either major or minor releases.  It is only
0: 	** 	written persistently in stored prepared statements, 
0: 	**	not in the replication stage.  SO, IT IS OK TO CHANGE
0: 	**	ITS read/writeExternal.
0: 	**
0: 	********************************************************/
0: 
0: 	public	long						conglomId;
0: 	public  StaticCompiledOpenConglomInfo heapSCOCI;
0: 	public	IndexRowGenerator[] 		irgs;
0: 	public	long[]						indexCIDS;
0: 	public  StaticCompiledOpenConglomInfo[] indexSCOCIs;
0: 	public  String[]					indexNames;
0: 	public	boolean						deferred;
0: 	public  Properties					targetProperties;
0: 	public	UUID						targetUUID;
0: 	public	int							lockMode;
0: 	private	FKInfo[]					fkInfo;
0: 	private TriggerInfo					triggerInfo;
0: 
0: 	private ExecRow						emptyHeapRow;
0: 	private FormatableBitSet baseRowReadList;
0: 	private int[] baseRowReadMap;
0: 	private int[] streamStorableHeapColIds;
0: 	public boolean singleRowSource;
0: 
0: 
0: 	// CONSTRUCTORS
0: 
0: 	/**
0: 	 * Public niladic constructor. Needed for Formatable interface to work.
0: 	 *
0: 	 */
0:     public	WriteCursorConstantAction() {}
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a DELETE, INSERT, or UPDATE statement.
0: 	 *
0: 	 *  @param conglomId	Conglomerate ID of heap.
0: 	 *	@param heapSCOCI	StaticCompiledOpenConglomInfo for heap.
0: 	 *  @param irgs			Index descriptors
0: 	 *  @param indexCIDS	Conglomerate IDs of indices
0: 	 *	@param indexSCOCIs	StaticCompiledOpenConglomInfos for indexes.
0: 	 *  @param indexNames   Names of indices on this table for error reporting.
0: 	 *  @param deferred		True means process as a deferred update
0: 	 *  @param targetProperties	Properties on the target table
0: 	 *	@param targetUUID	UUID of target table
0: 	 *	@param lockMode		The lock mode to use on the target table
0: 	 *	@param fkInfo	Structure containing foreign key info, if any (may be null)
0: 	 *	@param triggerInfo	Structure containing trigger info, if any (may be null)
0: 	 *  @param emptyHeapRow	an empty heap row
0: 	 *  @param baseRowReadMap	BaseRowReadMap[heapColId]->ReadRowColumnId. (0 based)
0:      *  @param streamStorableHeapColIds Null for non rep. (0 based)
0: 	 *  @param numColumns	Number of columns to read.
0: 	 *  @param singleRowSource		Whether or not source is a single row source
0: 	 */
0: 	public	WriteCursorConstantAction(
0: 								long				conglomId,
0: 								StaticCompiledOpenConglomInfo heapSCOCI,
0: 								IndexRowGenerator[]	irgs,
0: 								long[]				indexCIDS,
0: 								StaticCompiledOpenConglomInfo[] indexSCOCIs,
0: 								String[]			indexNames,
0: 								boolean				deferred,
0: 								Properties			targetProperties,
0: 								UUID				targetUUID,
0: 								int					lockMode,
0: 								FKInfo[]			fkInfo,
0: 								TriggerInfo			triggerInfo,
0: 								ExecRow				emptyHeapRow,
0: 								FormatableBitSet				baseRowReadList,
0: 								int[]               baseRowReadMap,
0: 								int[]               streamStorableHeapColIds,
0: 								boolean				singleRowSource
0: 								)
0: 	{
0: 		this.conglomId = conglomId;
0: 		this.heapSCOCI = heapSCOCI;
0: 		this.irgs = irgs;
0: 		this.indexSCOCIs = indexSCOCIs;
0: 		this.indexCIDS = indexCIDS;
0: 		this.indexSCOCIs = indexSCOCIs;
0: 		this.deferred = deferred;
0: 		this.targetProperties = targetProperties;
0: 		this.targetUUID = targetUUID;
0: 		this.lockMode = lockMode;
0: 		this.emptyHeapRow = emptyHeapRow;
0: 		this.fkInfo = fkInfo;
0: 		this.triggerInfo = triggerInfo;
0: 		this.baseRowReadList = baseRowReadList;
0: 		this.baseRowReadMap = baseRowReadMap;
0: 		this.streamStorableHeapColIds = streamStorableHeapColIds;
0: 		this.singleRowSource = singleRowSource;
0: 		this.indexNames = indexNames;
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (fkInfo != null)
0: 			{
0: 				SanityManager.ASSERT(fkInfo.length != 0, "fkinfo array has no elements, if there are no foreign keys, then pass in null");
0: 			}
0: 		}
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ACCESSORS
0: 	//
0: 	///////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	  *	Gets the foreign key information for this constant action.
0: 	  *	A full list of foreign keys was compiled into this constant
0: 	  *	action. However, we prune this list at run time so that we
0: 	  *	enforce only the foreign keys that we absolutely must.
0: 	  *
0: 	  *	What's going on here? Well, in certain contexts (REFRESH and
0: 	  *	when intially booting a Target), we don't have to enforce some
0: 	  *	foreign keys. We allow the ExecutionContext to rule on which
0: 	  *	foreign keys are relevant and which aren't.
0: 	  *
0: 	  *	@param	ec	the ExecutionContext
0: 	  *
0: 	  *	@return	the list of foreign keys to enforce for this action
0: 	  *
0: 	  * @exception StandardException		Thrown on failure
0: 	  */
0: 	public	FKInfo[]	getFKInfo
0: 	(
0: 		ExecutionContext	ec
0:     )
0: 		throws StandardException
0: 	{
0: 		FKInfo[]	siftedArray = (FKInfo[]) ec.siftForeignKeys( fkInfo );
0: 
0: 		return siftedArray;
0: 	}
0: 
0: 	/**
0: 	 * Basically, the same as getFKInfo but for triggers.
0: 	 *
0: 	 * @return	the triggers that should be fired
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public TriggerInfo getTriggerInfo(ExecutionContext ec) 
0: 		throws StandardException
0: 	{
0: 		return (TriggerInfo)ec.siftTriggers(triggerInfo);
0: 	}
0: 
0: 
0: 	///////////////////////////////////////////////////////////////////
0: 	//
0: 	// INTERFACE METHODS
0: 	//
0: 	///////////////////////////////////////////////////////////////////
0: 
0: 
0:     /**
0: 	  *	Reports whether these constants are up-to-date. This returns true
0: 	  *	for homogenous Cloudscape/Cloudsync. For the Plugin, this may
0: 	  *	return false;
0: 	  *
0: 	  *	@return	true if these constants are up-to-date
0: 	  *			false otherwise
0: 	  */
0: 	public	boolean	upToDate()
0: 	{ return true; }
0: 
0: 	/**
0: 	 *	NOP routine. The work is done in InsertResultSet.
0: 	 *
0: 	 *	@see ConstantAction#executeConstantAction
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void	executeConstantAction( Activation activation )
0: 		throws StandardException { }
0: 
0: 	// Formatable methods
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal( ObjectInput in )
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		conglomId = in.readLong();
0: 		heapSCOCI = (StaticCompiledOpenConglomInfo) in.readObject();
0: 		irgs = new IndexRowGenerator[ArrayUtil.readArrayLength(in)];
0: 		ArrayUtil.readArrayItems(in, irgs);
0: 
0: 		indexCIDS = ArrayUtil.readLongArray(in);
0: 		indexSCOCIs = new StaticCompiledOpenConglomInfo[ArrayUtil.readArrayLength(in)];
0: 		ArrayUtil.readArrayItems(in, indexSCOCIs);
0: 
0: 		deferred = in.readBoolean();
0: 		targetProperties = (Properties) in.readObject();
0: 		targetUUID = (UUID) in.readObject();
0: 		lockMode = in.readInt();
0: 
0: 		fkInfo = new FKInfo[ArrayUtil.readArrayLength(in)];
0: 		ArrayUtil.readArrayItems(in, fkInfo);
0: 
0: 		triggerInfo = (TriggerInfo)in.readObject();
0: 
0: 		baseRowReadList = (FormatableBitSet)in.readObject();
0: 		baseRowReadMap = ArrayUtil.readIntArray(in);
0: 		streamStorableHeapColIds = ArrayUtil.readIntArray(in); 
0: 		singleRowSource = in.readBoolean();
0: 		indexNames = ArrayUtil.readStringArray(in);
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException		thrown on error
0: 	 */
0: 	public void writeExternal( ObjectOutput out )
0: 		 throws IOException
0: 	{
0: 		out.writeLong(conglomId);
0: 		out.writeObject(heapSCOCI);
0: 		ArrayUtil.writeArray(out, irgs);
0: 		ArrayUtil.writeLongArray(out, indexCIDS);
0: 		ArrayUtil.writeArray(out, indexSCOCIs);
0: 		out.writeBoolean(deferred);
0: 		out.writeObject(targetProperties);
0: 		out.writeObject(targetUUID);
0: 		out.writeInt(lockMode);
0: 		ArrayUtil.writeArray(out, fkInfo);
0: 
0: 		//
0: 		//Added for Xena.
0: 		out.writeObject(triggerInfo);
0: 
0: 		//
0: 		//Moved from super class for Xena.
0: 		out.writeObject(baseRowReadList);
0: 
0: 		//
0: 		//Added for Xena
0: 		ArrayUtil.writeIntArray(out,baseRowReadMap);
0: 		ArrayUtil.writeIntArray(out,streamStorableHeapColIds);
0: 
0: 		//Added for Buffy
0: 		out.writeBoolean(singleRowSource);
0: 		
0: 		// Added for Mulan (Track Bug# 3322)
0: 		ArrayUtil.writeArray(out, indexNames);
0: 		
0: 	}
0: 
0: 	// ACCESSORS
0: 
0: 	/**
0: 	 * Get the conglomerate id for the changed heap.
0: 	 * @return the conglomerate id.
0: 	 */
0: 	public long getConglomerateId() { return conglomId; }
0: 		
0: 	/**
0: 	 *	Get emptyHeapRow
0: 	 *
0: 	 * @param lcc	The LanguageConnectionContext to use.
0: 	 *
0: 	 * @return	an empty base table row for the table being updated.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ExecRow getEmptyHeapRow(LanguageConnectionContext lcc) throws StandardException
0: 	{
0: 		DataDictionary dd;
0: 		TableDescriptor td;
0: 
0: 		if (emptyHeapRow == null)
0: 		{
0: 
0: 			dd = lcc.getDataDictionary();
0: 	
0: 			td = dd.getTableDescriptor(targetUUID);
0: 	
0: 			emptyHeapRow = td.getEmptyExecRow(lcc.getContextManager());
0: 		}
0: 
0: 		return emptyHeapRow.getClone();
0: 	}
0: 
0: 	/**
0: 	 * Get the targetProperties from the constant action.
0: 	 *
0: 	 * @return The targetProperties
0: 	 */
0: 	public Properties getTargetProperties()
0: 	{
0: 		return targetProperties;
0: 	}
0: 
0: 	/**
0: 	 * The the value of the specified key, if it exists, from
0: 	 * the targetProperties.
0: 	 *
0: 	 * @param key		The key to search for
0: 	 *
0: 	 * @return	The value for the specified key if it exists, otherwise null.
0: 	 *			(Return null if targetProperties is null.)
0: 	 */
0: 	public String getProperty(String key)
0: 	{
0: 		return (targetProperties == null) ? null : targetProperties.getProperty(key);
0: 	}
0: 
0: 	public FormatableBitSet getBaseRowReadList() { return baseRowReadList; }
0: 	public int[] getBaseRowReadMap() { return baseRowReadMap; }
0: 	public int[] getStreamStorableHeapColIds() { return streamStorableHeapColIds; }
0: 
0: 	/**
0: 	 * get the index name given the conglomerate id of the index.
0: 	 * 
0: 	 * @param indexCID		conglomerate ID of the index.
0: 	 * 
0: 	 * @return index name of given index.
0: 	 */
0: 	public String getIndexNameFromCID(long indexCID)
0: 	{
0: 		int size = indexCIDS.length;
0: 
0: 		if (indexNames == null) 
0: 		{
0: 			return null;
0: 		} 
0: 		
0: 		for (int i = 0; i < size; i++)
0: 		{
0: 			if (indexCIDS[i] == indexCID)
0: 				return indexNames[i];
0: 		}
0: 		return null;
0: 	}
0: 			
0: 	public String[] getIndexNames()
0: 	{
0: 		return indexNames;
0: 	}
0: 
0: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
0: 	 *
0: 	 * @param tableId on error
0: 	 *
0: 	 */
0: 	public boolean modifiesTableId(UUID tableId)
0: 	{
0: 		return ((tableId != null) && (targetUUID != null)) ?
0: 			tableId.equals(targetUUID) :
0: 			false;
0: 	}
0: }
0:  
============================================================================