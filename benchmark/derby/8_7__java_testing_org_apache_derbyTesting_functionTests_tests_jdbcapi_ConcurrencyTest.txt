1:bc50840: /*
2:bc50840:  *
1:bc50840:  * Derby - Class ConcurrencyTest
1:bc50840:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:bc50840:  *
1:bc50840:  *    http://www.apache.org/licenses/LICENSE-2.0
1:bc50840:  *
1:bc50840:  * Unless required by applicable law or agreed to in writing,
1:bc50840:  * software distributed under the License is distributed on an
1:bc50840:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:bc50840:  * either express or implied. See the License for the specific
1:bc50840:  * language governing permissions and limitations under the License.
1:bc50840:  */
1:bc50840: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:8bc3183: import java.sql.Connection;
1:8bc3183: import java.sql.PreparedStatement;
1:8bc3183: import java.sql.ResultSet;
1:8bc3183: import java.sql.SQLException;
1:8bc3183: import java.sql.Statement;
1:8bc3183: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:8bc3183: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:3bd1dd8: import org.apache.derbyTesting.junit.JDBC;
1:4f37d7c: import org.apache.derbyTesting.junit.TestConfiguration;
1:8bc3183: 
1:bc50840: /**
1:bc50840:  * Testing concurrency behaviour in derby when creating the resultsets with
1:bc50840:  * different parameters.
1:bc50840:  */
1:bc50840: public class ConcurrencyTest extends SURBaseTest {
1:8bc3183:     
1:bc50840:     /** Creates a new instance of ConcurrencyTest */
1:bc50840:     public ConcurrencyTest(String name) {
1:bc50840:         super(name);
1:2fd14fb:     }
1:d038483: 
1:bc50840:     /**
1:bc50840:      * Sets up the connection, then create the data model
1:bc50840:      */
1:bc50840:     public void setUp() 
1:bc50840:         throws Exception 
1:bc50840:     {      
1:bc50840:         // For the concurrency tests, we recreate the model
1:bc50840:         // for each testcase (since we do commits)
1:bc50840:         SURDataModelSetup.createDataModel
1:03a99e2:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getConnection());
1:ff65830:         commit();
7:bc50840:     }
1:d038483:     
1:a6464f2:     public void tearDown() throws Exception 
1:bc50840:     {
1:ddeb000:         rollback();
1:ddeb000:         dropTable("T1");
1:ddeb000:         commit();
1:ddeb000: 
1:a6464f2:         super.tearDown();
1:bc50840:     }
1:2fd14fb:     
1:bc50840:     /**
1:bc50840:      * Test that update locks are downgraded to shared locks
1:bc50840:      * after repositioning.
1:bc50840:      * This test fails with Derby
1:bc50840:      */
1:bc50840:     public void testUpdateLockDownGrade1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:2fd14fb:         
1:bc50840:         // After navigating through the resultset, 
1:bc50840:         // presumably all rows are locked with shared locks
1:bc50840:         while (rs.next());
14:bc50840:         
1:bc50840:         // Now open up a connection
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                             ResultSet.CONCUR_UPDATABLE);
1:bc50840:         
1:bc50840:         ResultSet rs2 = s2.executeQuery("select * from t1 for update");
4:bc50840:         try {
1:bc50840:             rs2.next(); // We should be able to get a update lock here.
3:bc50840:         } catch (SQLException e) {
2:bc50840:             assertEquals("Unexpected SQL state",  LOCK_TIMEOUT_SQL_STATE,
3:bc50840:                          e.getSQLState());
1:bc50840:             return;
3:bc50840:         } finally {
3:bc50840:             con2.rollback();
1:ff65830:         }
1:bc50840:         assertTrue("Expected Derby to hold updatelocks in RR mode", false);
1:ff65830:         
1:ff65830:         s2.close();
1:b9e26f3:         con2.close();
1:ff65830:         
1:ff65830:         s.close();
1:bc50840:     }
1:ff65830:     
1:bc50840:     /**
1:bc50840:      * Test that we can aquire a update lock even if the row is locked with 
1:bc50840:      * a shared lock.
1:bc50840:      */
1:bc50840:     public void testAquireUpdateLock1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement();
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:ff65830:         
1:bc50840:         // After navigating through the resultset, 
1:bc50840:         // presumably all rows are locked with shared locks
1:bc50840:         while (rs.next());
1:bc50840:         
1:bc50840:         // Now open up a connection
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                             ResultSet.CONCUR_UPDATABLE);
1:bc50840:         
1:bc50840:         ResultSet rs2 = s2.executeQuery("select * from t1 for update");
1:bc50840:         try {
1:bc50840:             rs2.next(); // We should be able to get a update lock here.
1:bc50840:         } finally {
1:bc50840:             con2.rollback();
1:bc50840:         }
1:bc50840:         
1:ff65830:         s2.close();
1:ff65830:         con2.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /*
1:bc50840:      * Test that we do not get a concurrency problem when opening two cursors
1:bc50840:      * as readonly.
1:bc50840:      **/
1:bc50840:     public void testSharedLocks1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_READ_ONLY);
1:bc50840:         final ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         scrollForward(rs);
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                             ResultSet.CONCUR_READ_ONLY);
1:bc50840:         try {
1:bc50840:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:bc50840:             scrollForward(rs2);
1:bc50840:         } finally {
1:bc50840:             rs.close();
1:bc50840:             con2.rollback();
1:ff65830:             con2.close();
1:bc50840:         }
1:bc50840:         
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /*
1:bc50840:      * Test that we do not get a concurrency problem when opening two cursors 
1:bc50840:      * reading the same data (no parameters specified to create statement).
1:bc50840:      **/
1:bc50840:     public void testSharedLocks2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement();
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         scrollForward(rs);
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement();
1:bc50840:         try {
1:bc50840:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:bc50840:             scrollForward(rs2);
1:bc50840:         } finally {
1:bc50840:             rs.close();
1:bc50840:             con2.rollback();
1:ff65830:             con2.close();
1:bc50840:         }
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /*
1:bc50840:      * Test that we do not get a concurrency problem when opening one cursor
1:bc50840:      * as updatable (not using "for update"), and another cursor as read only
1:bc50840:      **/
1:bc50840:     public void testSharedAndUpdateLocks1()
1:bc50840:         throws SQLException {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         scrollForward(rs);
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                             ResultSet.CONCUR_READ_ONLY);
1:bc50840:         try {
1:bc50840:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:bc50840:             scrollForward(rs2);
1:bc50840:         } finally {
1:bc50840:             rs.close();
1:bc50840:             con2.rollback();
1:bc50840:             con2.close();
1:bc50840:         }
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /*
1:bc50840:      * Test that we do no get a concurrency problem when opening one cursor
1:bc50840:      * as updatable (using "for update"), and another cursor as read only.
1:bc50840:      *
1:bc50840:      **/
1:bc50840:     public void testSharedAndUpdateLocks2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         scrollForward(rs);
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                             ResultSet.CONCUR_READ_ONLY);
1:bc50840:         try {
1:bc50840:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:bc50840:             scrollForward(rs2);
1:bc50840:         } finally {
1:bc50840:             rs.close();
1:bc50840:             con2.rollback();
1:bc50840:             con2.close();
1:bc50840:         }
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a deleted + purged tuple.
1:bc50840:      * The transaction which deletes the tuple, will also
1:bc50840:      * ensure that the tuple is purged from the table, not only marked
1:bc50840:      * as deleted.
1:bc50840:      **/
1:bc50840:     public void testUpdatePurgedTuple1()
1:bc50840:         throws SQLException
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next();
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         int lastKey = firstKey;
1:bc50840:         while (rs.next()) {
1:bc50840:             lastKey = rs.getInt(1);
1:bc50840:             println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:         }
1:ff65830:         
1:03a99e2:         Connection con2 = openDefaultConnection();
2:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840:         try {
1:4316596:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("delete from t1 where id=? or id=?");
2:bc50840:             ps2.setInt(1, firstKey);
1:bc50840:             ps2.setInt(2, lastKey);
1:bc50840:             assertEquals("Expected two records to be deleted", 
1:bc50840:                          2, ps2.executeUpdate());
1:bc50840:             println("T2: Deleted records with id=" + firstKey + " and id=" + 
1:bc50840:                     lastKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:             ps2 = con2.prepareStatement
1:bc50840:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:bc50840:             ps2.setString(1, "APP"); // schema
1:bc50840:             ps2.setString(2, "T1");  // table name
1:bc50840:             ps2.setInt(3, 1); // purge
1:bc50840:             ps2.setInt(4, 0); // defragment rows
1:bc50840:             ps2.setInt(5, 0); // truncate end
1:bc50840:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:bc50840:             println("T3: purges deleted records");
1:bc50840:             ps2.executeUpdate();
1:bc50840:             con2.commit();
1:bc50840:             println("T3: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
2:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         rs.first(); // Go to first tuple
1:bc50840:         println("T1: Read first Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         println("T1: updateInt(2, 3);");
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updateRow()");
1:bc50840:         rs.last(); // Go to last tuple
1:bc50840:         println("T1: Read last Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         println("T1: updateInt(2, 3);");
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updateRow()");
1:ff65830:         commit();
1:bc50840:         println("T1: commit");
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         println("T3: select * from table");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:4316596:             
1:bc50840:         }
1:ff65830:         
1:b9e26f3:         con2.close();
1:4316596:         s.close();
1:bc50840:     }
1:ff65830:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a deleted tuple using positioned update
1:bc50840:      * (same as testUpdatePurgedTuple1, except here we use positioned updates)
1:bc50840:      **/
1:bc50840:     public void testUpdatePurgedTuple2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next(); // Point to first tuple
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         rs.next(); // Go to next
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840:         try {
3:bc50840:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("delete from t1 where id=?");
1:4316596:             ps2.setInt(1, firstKey);
1:bc50840:             assertEquals("Expected one record to be deleted", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T2: Deleted record with id=" + firstKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
1:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         rs.previous(); // Go back to first tuple
1:bc50840:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("update T1 set a=? where current of " + rs.getCursorName());
1:bc50840:         ps.setInt(1, 3);
1:bc50840:         int updateCount = ps.executeUpdate();
1:bc50840:         println("T1: update table, set a=3 where current of " + 
1:bc50840:                 rs.getCursorName());
1:bc50840:         println("T1: commit");
1:ff65830:         commit();
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T3: Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:             
1:bc50840:         }
1:bc50840:         
1:b9e26f3:         con2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a tuple which is deleted, purged and
1:bc50840:      * reinserted
1:bc50840:      **/
1:bc50840:     public void testUpdatePurgedTuple3()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next(); // Point to first tuple
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         println("T1: read tuple with key " + firstKey);
1:bc50840:         rs.next(); // Go to next
1:bc50840:         println("T1: read next tuple");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:4316596:         try {
1:bc50840:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("delete from t1 where id=?");
1:bc50840:             ps2.setInt(1, firstKey);
1:bc50840:             assertEquals("Expected one record to be deleted", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T2: Deleted record with id=" + firstKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:             
1:bc50840:             // Now purge the table
1:bc50840:             ps2 = con2.prepareStatement
1:bc50840:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:bc50840:             ps2.setString(1, "APP"); // schema
1:bc50840:             ps2.setString(2, "T1");  // table name
1:bc50840:             ps2.setInt(3, 1); // purge
1:bc50840:             ps2.setInt(4, 0); // defragment rows
1:bc50840:             ps2.setInt(5, 0); // truncate end
1:bc50840:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:bc50840:             println("T3: purges deleted records");
1:bc50840:             ps2.executeUpdate();
1:bc50840:             con2.commit();
1:bc50840:             
1:4c9b831:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?,?)");
1:bc50840:             ps2.setInt(1, firstKey);
1:bc50840:             ps2.setInt(2, -1);
1:bc50840:             ps2.setInt(3, -1);
1:bc50840:             ps2.setString(4, "UPDATED TUPLE");
1:4c9b831:             ps2.setString(5, "UPDATED CLOB");
1:bc50840:             assertEquals("Expected one record to be inserted", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T4: Inserted record (" + firstKey + ",-1,-1)" );
1:bc50840:             con2.commit();
1:bc50840:             println("T4: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
1:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         println("T1: read previous tuple");
1:bc50840:         rs.previous(); // Go back to first tuple
1:bc50840:         println("T1: id=" + rs.getInt(1));
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         println("T1: updateInt(2, 3);");
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updated column 2, to value=3");
1:bc50840:         println("T1: commit");
1:ff65830:         commit();
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T5: Read Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:             
1:bc50840:         }
1:bc50840:         
1:b9e26f3:         con2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a tuple which is deleted, purged and 
1:bc50840:      * then reinserted with the exact same values
1:bc50840:      **/
1:bc50840:     public void testUpdatePurgedTuple4()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next(); // Point to first tuple
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         int valA = rs.getInt(2);
1:bc50840:         int valB = rs.getInt(3);
1:bc50840:         
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         
1:bc50840:         rs.next(); // Go to next
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840:         try {
1:bc50840:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("delete from t1 where id=?");
1:bc50840:             ps2.setInt(1, firstKey);
1:bc50840:             assertEquals("Expected one record to be deleted", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T2: Deleted record with id=" + firstKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:             
1:bc50840:             // Now purge the table
1:bc50840:             ps2 = con2.prepareStatement
1:bc50840:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:bc50840:             ps2.setString(1, "APP"); // schema
1:bc50840:             ps2.setString(2, "T1");  // table name
1:bc50840:             ps2.setInt(3, 1); // purge
1:bc50840:             ps2.setInt(4, 0); // defragment rows
1:bc50840:             ps2.setInt(5, 0); // truncate end
1:bc50840:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:bc50840:             println("T3: purges deleted records");
1:bc50840:             ps2.executeUpdate();
1:bc50840:             con2.commit();
1:bc50840:             println("T3: commit");
1:bc50840:             
1:4c9b831:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?,?)");
1:bc50840:             ps2.setInt(1, firstKey);
1:bc50840:             ps2.setInt(2, valA);
1:bc50840:             ps2.setInt(3, valB);
1:bc50840:             ps2.setString(4, "UPDATE TUPLE " + firstKey);
1:4c9b831:             ps2.setString(5, "UPDATED CLOB " + firstKey);
1:bc50840:             assertEquals("Expected one record to be inserted", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T4: Inserted record (" + firstKey + "," + valA + "," + 
1:bc50840:                     valB + ")" );
1:bc50840:             con2.commit();
1:bc50840:             println("T4: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
1:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         rs.previous(); // Go back to first tuple
1:bc50840:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         
1:bc50840:         println("T1: id=" + rs.getInt(1));
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updated column 2, to value=3");
1:bc50840:         println("T1: commit");
1:ff65830:         commit();
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T4: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:             
1:bc50840:         }
1:b9e26f3:         con2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a tuple which has been modified by 
1:bc50840:      * another transaction.
1:bc50840:      **/
1:bc50840:     public void testUpdateModifiedTuple1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next(); // Point to first tuple
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         rs.next(); // Go to next
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840:         try {
1:bc50840:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("update t1 set b=? where id=?");
1:bc50840:             ps2.setInt(1, 999);
1:bc50840:             ps2.setInt(2, firstKey);
1:bc50840:             assertEquals("Expected one record to be updated", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T2: Updated b=999 where id=" + firstKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
1:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         rs.previous(); // Go back to first tuple
1:bc50840:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updated column 2, to value=3");
1:ff65830:         commit();
1:bc50840:         println("T1: commit");
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:             
1:bc50840:         }
1:ff65830:         con2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test what happens if you update a tuple which has been modified by 
1:bc50840:      * another transaction (in this case the same column)
1:bc50840:      **/
1:bc50840:     public void testUpdateModifiedTuple2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next(); // Point to first tuple
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         rs.next(); // Go to next
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840:         try {
1:bc50840:             PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("update t1 set b=? where id=?");
1:bc50840:             ps2.setInt(1, 999);
1:bc50840:             ps2.setInt(2, firstKey);
1:bc50840:             assertEquals("Expected one record to be updated", 1, 
1:bc50840:                          ps2.executeUpdate());
1:bc50840:             println("T2: Updated b=999 where id=" + firstKey);
1:bc50840:             con2.commit();
1:bc50840:             println("T2: commit");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             con2.rollback();
1:bc50840:             throw e;
1:bc50840:         }
1:bc50840:         rs.previous(); // Go back to first tuple
1:bc50840:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(3, 9999);
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updated column 3, to value=9999");
1:ff65830:         commit();
1:bc50840:         println("T1: commit");
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:             
1:bc50840:         }
1:ff65830:         con2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Tests that a ResultSet opened even in read uncommitted, gets a 
1:bc50840:      * table intent lock, and that another transaction then cannot compress 
1:bc50840:      * the table while the ResultSet is open.
1:bc50840:      **/
1:bc50840:     public void testTableIntentLock1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         println("T1: select * from t1");
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:         } // Now the cursor does not point to any tuples
1:bc50840:         
1:bc50840:         // Compressing the table in another transaction:
1:03a99e2:         Connection con2 = openDefaultConnection();
1:4316596:         
1:4316596:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:4316596:         PreparedStatement ps2 = con2.prepareStatement
1:4316596:             ("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?)");
1:4316596:         ps2.setString(1, "APP");
1:4316596:         ps2.setString(2, "T1");
1:4316596:         ps2.setInt(3, 0);
1:4316596:         println("T2: call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(APP, T1, 0)");
1:bc50840:         try {
1:bc50840:             ps2.executeUpdate(); // This will hang
1:4316596:             fail("Expected T2 to hang");
1:bc50840:         } catch (SQLException e) {
1:bc50840:             println("T2: Got exception:" + e.getMessage());
1:bc50840:             
1:4316596:             assertSQLState(LOCK_TIMEOUT_EXPRESSION_SQL_STATE, e);
1:4316596: 
1:bc50840:         }
1:4316596:         ps2.close();
1:4316596:         con2.rollback();
1:ff65830:         con2.close();
1:4316596:         
1:4316596:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that Derby set updatelock on current row when using
1:bc50840:      * read-uncommitted
1:bc50840:      **/
1:bc50840:     public void testUpdateLockInReadUncommitted()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next();
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:03a99e2:         Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:bc50840: 
1:bc50840:         PreparedStatement ps2 = con2.prepareStatement
1:bc50840:                 ("delete from t1 where id=?");
1:bc50840:         ps2.setInt(1, firstKey);
1:bc50840:         try {
1:bc50840:             ps2.executeUpdate();
1:4316596:             fail("expected record with id=" + firstKey + 
1:4316596:                        " to be locked");
1:bc50840:         } catch (SQLException e) {
1:4316596:             assertSQLState(LOCK_TIMEOUT_SQL_STATE, e);
1:bc50840:         }
1:4316596:         
1:4316596:         ps2.close();
1:4316596:         con2.rollback();
1:bc50840:         con2.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that the system cannot defragment any records
1:bc50840:      * as long as an updatable result set is open against the table.
1:bc50840:      **/
1:bc50840:     public void testDefragmentDuringScan() 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         testCompressDuringScan(true, false);
1:bc50840:     }
1:bc50840:     /**
1:bc50840:      * Test that the system cannot truncate any records
1:bc50840:      * as long as an updatable result set is open against the table.
1:bc50840:      **/
1:bc50840:     public void testTruncateDuringScan() 
1:bc50840:         throws SQLException
1:bc50840:     {
1:bc50840:         testCompressDuringScan(false, true);
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that the system does not purge any records
1:bc50840:      * as long as we do either a defragment, or truncate
1:bc50840:      **/
1:bc50840:     private void testCompressDuringScan(boolean testDefragment, 
1:bc50840:                                         boolean testTruncate)
1:bc50840:         throws SQLException 
1:bc50840:     {
1:03a99e2:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:ff65830:         Statement delStatement = createStatement();
1:bc50840:         // First delete all records except the last and first
1:bc50840:         int deleted = delStatement.executeUpdate
1:bc50840:             ("delete from T1 where id>0 and id<" + (recordCount-1));
1:bc50840:         int expectedDeleted = recordCount-2;    
1:bc50840:         println("T1: delete records");
1:bc50840:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:bc50840:                      deleted);
1:4316596:         delStatement.close();
1:ff65830:         commit();
1:bc50840:         println("T1: commit");
1:bc50840:         
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         rs.next();
1:bc50840:         int firstKey = rs.getInt(1);
1:bc50840:         println("T2: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         int lastKey = firstKey;
1:bc50840:         while (rs.next()) {
1:bc50840:             lastKey = rs.getInt(1);
1:bc50840:             println("T2: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:         }
1:bc50840:         
1:03a99e2:         final Connection con2 = openDefaultConnection();
1:bc50840:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:bc50840:         final PreparedStatement ps2 = con2.prepareStatement
1:bc50840:             ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:bc50840:         ps2.setString(1, "APP"); // schema
1:bc50840:         ps2.setString(2, "T1");  // table name
1:bc50840:         ps2.setInt(3, 0); // purge
1:bc50840:         int defragment = testDefragment ? 1 : 0;
1:bc50840:         int truncate = testTruncate ? 1 : 0;
1:bc50840:         ps2.setInt(4, defragment); // defragment rows
1:bc50840:         ps2.setInt(5, truncate); // truncate end
1:bc50840:         
1:bc50840:         println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:bc50840:         println("T3: defragmenting rows");
1:bc50840:         try { 
1:bc50840:             ps2.executeUpdate();
1:bc50840:             con2.commit();
1:bc50840:             println("T3: commit");
1:4316596:             fail("Expected T3 to hang waiting for Table lock");
1:bc50840:         } catch (SQLException e) {            
1:bc50840:             println("T3: got expected exception");
1:bc50840:             con2.rollback();            
1:bc50840:         }
1:4316596:         ps2.close();
1:bc50840:         rs.first(); // Go to first tuple
1:bc50840:         println("T1: Read first Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         println("T1: updateInt(2, 3);");
1:bc50840:         rs.updateRow();        
1:bc50840:         println("T1: updateRow()");
1:bc50840:         rs.last(); // Go to last tuple
1:bc50840:         println("T1: Read last Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                 rs.getInt(2) + "," +
1:bc50840:                 rs.getInt(3) + ")");
1:bc50840:         rs.updateInt(2, 3);
1:bc50840:         println("T1: updateInt(2, 3);");
1:bc50840:         rs.updateRow();
1:bc50840:         println("T1: updateRow()");
1:ff65830:         commit();
1:bc50840:         println("T1: commit");
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         println("T4: select * from table");
1:bc50840:         while (rs.next()) {
1:bc50840:             println("T4: Read next Tuple:(" + rs.getInt(1) + "," +
1:bc50840:                     rs.getInt(2) + "," +
1:bc50840:                     rs.getInt(3) + ")");
1:bc50840:         }
1:bc50840:         con2.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     // By providing a static suite(), you can customize which tests to run.
1:bc50840:     // The default is to run all tests in the TestCase subclass.
1:bc50840:     
1:4f37d7c:     /**
1:4f37d7c:      * Run in embedded and client.
1:4f37d7c:      */
1:4f37d7c:     public static Test suite()
1:4f37d7c:     {
1:1ae02c9:         final BaseTestSuite suite = new BaseTestSuite("ConcurrencyTest");
1:4f37d7c:         suite.addTest(baseSuite("ConcurrencyTest:embedded", true));
1:4f37d7c:         
1:4f37d7c:         suite.addTest(
1:4f37d7c:                 TestConfiguration.clientServerDecorator(
1:4f37d7c:                         baseSuite("ConcurrencyTest:client", false)));
1:4f37d7c:         
1:4f37d7c:         // Since this test relies on lock waiting, setting this property will
1:4f37d7c:         // make it go a lot faster:
1:4f37d7c:         return DatabasePropertyTestSetup.setLockTimeouts(suite, -1, 4);
1:4f37d7c:     }
1:4f37d7c:     
1:4f37d7c:     private static Test baseSuite(String name, boolean embedded) {
1:1ae02c9:         final BaseTestSuite suite = new BaseTestSuite(name);
1:bc50840:         
1:ed153bd:         // This testcase does not require JDBC3/JSR169, since it does not
1:ed153bd:         // specify result set concurrency) in Connection.createStatement().
1:bc50840:         suite.addTest(new ConcurrencyTest("testSharedLocks2"));
1:ed153bd:         
1:ed153bd:         // The following testcases requires JDBC3/JSR169:
1:ed153bd:         if ((JDBC.vmSupportsJDBC3() || JDBC.vmSupportsJSR169())) {
1:ed153bd:             
1:ed153bd:             // The following testcases do not use updatable result sets:
1:ed153bd:             suite.addTest(new ConcurrencyTest("testUpdateLockDownGrade1"));
1:ed153bd:             suite.addTest(new ConcurrencyTest("testAquireUpdateLock1"));
1:ed153bd:             suite.addTest(new ConcurrencyTest("testSharedLocks1"));
1:ed153bd:             suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks1"));
1:ed153bd:             suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks2"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest ("testUpdatePurgedTuple2"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple3"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple4"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple1"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple2"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testTableIntentLock1"));
1:7dc89cf:             suite.addTest
1:7dc89cf:                 (new ConcurrencyTest("testUpdateLockInReadUncommitted"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testDefragmentDuringScan"));
1:7dc89cf:             suite.addTest(new ConcurrencyTest("testTruncateDuringScan"));
1:ed153bd:             
1:7dc89cf:             // This testcase fails in DerbyNetClient framework due to 
1:7dc89cf:             // DERBY-1696
1:7dc89cf:             if (embedded) {
2:ed153bd:                 suite.addTest
1:7dc89cf:                     (new ConcurrencyTest("testUpdatePurgedTuple1"));
1:7dc89cf:             }        
1:ed153bd:         }
1:ed153bd:         
1:4f37d7c:         return suite;
1:ed153bd:     }
1:ed153bd:     
1:ed153bd: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         final BaseTestSuite suite = new BaseTestSuite("ConcurrencyTest");
/////////////////////////////////////////////////////////////////////////
1:         final BaseTestSuite suite = new BaseTestSuite(name);
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:4c9b831
/////////////////////////////////////////////////////////////////////////
1:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?,?)");
1:             ps2.setString(5, "UPDATED CLOB");
/////////////////////////////////////////////////////////////////////////
1:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?,?)");
1:             ps2.setString(5, "UPDATED CLOB " + firstKey);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
1:             suite.addTest(new ConcurrencyTest ("testUpdatePurgedTuple2"));
1:             suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple3"));
1:             suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple4"));
1:             suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple1"));
1:             suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple2"));
1:             suite.addTest(new ConcurrencyTest("testTableIntentLock1"));
1:             suite.addTest
1:                 (new ConcurrencyTest("testUpdateLockInReadUncommitted"));
1:             suite.addTest(new ConcurrencyTest("testDefragmentDuringScan"));
1:             suite.addTest(new ConcurrencyTest("testTruncateDuringScan"));
1:             // This testcase fails in DerbyNetClient framework due to 
1:             // DERBY-1696
1:             if (embedded) {
1:                     (new ConcurrencyTest("testUpdatePurgedTuple1"));
1:             }        
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:             if (!usingDB2Client()) { // DB2 client does not support UR with Derby
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ddeb000
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         dropTable("T1");
1:         commit();
1: 
commit:4316596
/////////////////////////////////////////////////////////////////////////
1:         
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         PreparedStatement ps2 = con2.prepareStatement
1:             ("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?)");
1:         ps2.setString(1, "APP");
1:         ps2.setString(2, "T1");
1:         ps2.setInt(3, 0);
1:         println("T2: call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(APP, T1, 0)");
1:             fail("Expected T2 to hang");
1:             assertSQLState(LOCK_TIMEOUT_EXPRESSION_SQL_STATE, e);
1: 
1:         ps2.close();
1:         con2.rollback();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         PreparedStatement ps2 = con2.prepareStatement
1:         ps2.setInt(1, firstKey);
1:         try {
1:             fail("expected record with id=" + firstKey + 
1:                        " to be locked");
1:             assertSQLState(LOCK_TIMEOUT_SQL_STATE, e);
1:         
1:         ps2.close();
1:         con2.rollback();
/////////////////////////////////////////////////////////////////////////
1:         delStatement.close();
/////////////////////////////////////////////////////////////////////////
1:             fail("Expected T3 to hang waiting for Table lock");
1:         ps2.close();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
commit:b9e26f3
/////////////////////////////////////////////////////////////////////////
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
1:         con2.close();
commit:4f37d7c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run in embedded and client.
1:      */
1:     public static Test suite()
1:     {
1:         suite.addTest(baseSuite("ConcurrencyTest:embedded", true));
1:         
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         baseSuite("ConcurrencyTest:client", false)));
1:         
1:         // Since this test relies on lock waiting, setting this property will
1:         // make it go a lot faster:
1:         return DatabasePropertyTestSetup.setLockTimeouts(suite, -1, 4);
1:     }
1:     
1:     private static Test baseSuite(String name, boolean embedded) {
0:         final TestSuite suite = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
0:                 if (embedded) {
/////////////////////////////////////////////////////////////////////////
1:         return suite;
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         final TestSuite suite = new TestSuite("ConcurrencyTest");
commit:8bc3183
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
0:         return new DatabasePropertyTestSetup(suite, properties);
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getConnection());
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         Connection con2 = openDefaultConnection();
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
/////////////////////////////////////////////////////////////////////////
1:         final Connection con2 = openDefaultConnection();
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
commit:ff65830
/////////////////////////////////////////////////////////////////////////
0:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, getXConnection());
1:         commit();
0:             rollback();
0:             Statement dropStatement = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         
1:         s2.close();
1:         con2.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         
1:         s2.close();
1:         con2.close();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         
1:         con2.close();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         
1:         con2.close();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         }
1:         con2.close();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         Statement delStatement = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
commit:a6464f2
/////////////////////////////////////////////////////////////////////////
1:     public void tearDown() throws Exception 
0:             dropStatement.close();
1:         super.tearDown();
commit:d038483
/////////////////////////////////////////////////////////////////////////
1:         
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
0:             return suite;
1: 
commit:2fd14fb
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.JDBC;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 
0:         // Requires holdability
0:         if (JDBC.vmSupportsJDBC3() || JDBC.vmSupportsJSR169()) {
/////////////////////////////////////////////////////////////////////////
1:         }
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:ed153bd
/////////////////////////////////////////////////////////////////////////
0: import java.util.Properties;
0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
0:         final TestSuite suite = new TestSuite();
1:         // This testcase does not require JDBC3/JSR169, since it does not
1:         // specify result set concurrency) in Connection.createStatement().
1:         // The following testcases requires JDBC3/JSR169:
1:         if ((JDBC.vmSupportsJDBC3() || JDBC.vmSupportsJSR169())) {
1:             // The following testcases do not use updatable result sets:
1:             suite.addTest(new ConcurrencyTest("testUpdateLockDownGrade1"));
1:             suite.addTest(new ConcurrencyTest("testAquireUpdateLock1"));
1:             suite.addTest(new ConcurrencyTest("testSharedLocks1"));
1:             suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks1"));
1:             suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks2"));
1:             
0:             // The following testcases do use updatable result sets.            
0:             if (!usingDerbyNet()) { // DB2 client does not support UR with Derby
0:                 suite.addTest(new ConcurrencyTest ("testUpdatePurgedTuple2"));
0:                 suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple3"));
0:                 suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple4"));
0:                 suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple1"));
0:                 suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple2"));
0:                 suite.addTest(new ConcurrencyTest("testTableIntentLock1"));
1:                 suite.addTest
0:                     (new ConcurrencyTest("testUpdateLockInReadUncommitted"));
0:                 suite.addTest(new ConcurrencyTest("testDefragmentDuringScan"));
0:                 suite.addTest(new ConcurrencyTest("testTruncateDuringScan"));
1:                 
0:                 // This testcase fails in DerbyNetClient framework due to 
0:                 // DERBY-1696
0:                 if (usingEmbedded()) {
1:                     suite.addTest
0:                         (new ConcurrencyTest("testUpdatePurgedTuple1"));
1:                 }
1:                 
1:             }         
1:         }
1:         
0:         // Since this test relies on lock waiting, setting this property will
0:         // make it go a lot faster:
0:         final Properties properties = new Properties();
0:         properties.setProperty("derby.locks.waitTimeout", "4");
1:         
0:         return new SystemPropertyTestSetup(suite, properties);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:bc50840
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class ConcurrencyTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
0: import junit.framework.*;
0: import java.sql.*;
1: 
1: /**
1:  * Testing concurrency behaviour in derby when creating the resultsets with
1:  * different parameters.
0:  * @author Andreas Korneliussen
1:  */
1: public class ConcurrencyTest extends SURBaseTest {
1:     
1:     /** Creates a new instance of ConcurrencyTest */
1:     public ConcurrencyTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Sets up the connection, then create the data model
1:      */
1:     public void setUp() 
1:         throws Exception 
1:     {      
1:         try {
0:             super.setUp();
1:         } catch (SQLException e) {
0:             if (con!=null) tearDown();
1:             throw e;
1:         }
1:         // For the concurrency tests, we recreate the model
1:         // for each testcase (since we do commits)
1:         SURDataModelSetup.createDataModel
0:             (SURDataModelSetup.SURDataModel.MODEL_WITH_PK, con);
0:         con.commit();
1:     }
1:     
0:     public void tearDown() 
1:     {
1:         try {
0:             con.rollback();
0:             Statement dropStatement = con.createStatement();
0:             dropStatement.execute("drop table t1");
0:             con.commit();
0:             con.close();
1:         } catch (SQLException e) {
0:             printStackTrace(e); // Want to propagate the real exception.
1:         }
1:     }
1:     
1:     /**
1:      * Test that update locks are downgraded to shared locks
1:      * after repositioning.
1:      * This test fails with Derby
1:      */
1:     public void testUpdateLockDownGrade1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         
1:         // After navigating through the resultset, 
1:         // presumably all rows are locked with shared locks
1:         while (rs.next());
1:         
1:         // Now open up a connection
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                             ResultSet.CONCUR_UPDATABLE);
1:         
1:         ResultSet rs2 = s2.executeQuery("select * from t1 for update");
1:         try {
1:             rs2.next(); // We should be able to get a update lock here.
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQL state",  LOCK_TIMEOUT_SQL_STATE,
1:                          e.getSQLState());
1:             return;
1:         } finally {
1:             con2.rollback();
1:         }
1:         assertTrue("Expected Derby to hold updatelocks in RR mode", false);
1:     }
1:     
1:     /**
1:      * Test that we can aquire a update lock even if the row is locked with 
1:      * a shared lock.
1:      */
1:     public void testAquireUpdateLock1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         // After navigating through the resultset, 
1:         // presumably all rows are locked with shared locks
1:         while (rs.next());
1:         
1:         // Now open up a connection
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                             ResultSet.CONCUR_UPDATABLE);
1:         
1:         ResultSet rs2 = s2.executeQuery("select * from t1 for update");
1:         try {
1:             rs2.next(); // We should be able to get a update lock here.
1:         } finally {
1:             con2.rollback();
1:         }
1:     }
1:     
1:     /*
1:      * Test that we do not get a concurrency problem when opening two cursors
1:      * as readonly.
1:      **/
1:     public void testSharedLocks1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         final ResultSet rs = s.executeQuery("select * from t1");
1:         scrollForward(rs);
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                             ResultSet.CONCUR_READ_ONLY);
1:         try {
1:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:             scrollForward(rs2);
1:         } finally {
1:             rs.close();
1:             con2.rollback();
1:             con2.close();
1:         }
1:     }
1:     
1:     /*
1:      * Test that we do not get a concurrency problem when opening two cursors 
1:      * reading the same data (no parameters specified to create statement).
1:      **/
1:     public void testSharedLocks2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement();
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         scrollForward(rs);
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement();
1:         try {
1:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:             scrollForward(rs2);
1:         } finally {
1:             rs.close();
1:             con2.rollback();
1:             con2.close();
1:         }
1:     }
1:     
1:     /*
1:      * Test that we do not get a concurrency problem when opening one cursor
1:      * as updatable (not using "for update"), and another cursor as read only
1:      **/
1:     public void testSharedAndUpdateLocks1()
1:         throws SQLException {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         scrollForward(rs);
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                             ResultSet.CONCUR_READ_ONLY);
1:         try {
1:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:             scrollForward(rs2);
1:         } finally {
1:             rs.close();
1:             con2.rollback();
1:             con2.close();
1:         }
1:     }
1:     
1:     /*
1:      * Test that we do no get a concurrency problem when opening one cursor
1:      * as updatable (using "for update"), and another cursor as read only.
1:      *
1:      **/
1:     public void testSharedAndUpdateLocks2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         scrollForward(rs);
0:         Connection con2 = getNewConnection();
1:         Statement s2 = con2.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                             ResultSet.CONCUR_READ_ONLY);
1:         try {
1:             final ResultSet rs2 = s2.executeQuery("select * from t1");
1:             scrollForward(rs2);
1:         } finally {
1:             rs.close();
1:             con2.rollback();
1:             con2.close();
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a deleted + purged tuple.
1:      * The transaction which deletes the tuple, will also
1:      * ensure that the tuple is purged from the table, not only marked
1:      * as deleted.
1:      **/
1:     public void testUpdatePurgedTuple1()
1:         throws SQLException
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next();
1:         int firstKey = rs.getInt(1);
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         int lastKey = firstKey;
1:         while (rs.next()) {
1:             lastKey = rs.getInt(1);
1:             println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:         }
1:         
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("delete from t1 where id=? or id=?");
1:             ps2.setInt(1, firstKey);
1:             ps2.setInt(2, lastKey);
1:             assertEquals("Expected two records to be deleted", 
1:                          2, ps2.executeUpdate());
1:             println("T2: Deleted records with id=" + firstKey + " and id=" + 
1:                     lastKey);
1:             con2.commit();
1:             println("T2: commit");
1:             ps2 = con2.prepareStatement
1:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:             ps2.setString(1, "APP"); // schema
1:             ps2.setString(2, "T1");  // table name
1:             ps2.setInt(3, 1); // purge
1:             ps2.setInt(4, 0); // defragment rows
1:             ps2.setInt(5, 0); // truncate end
1:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:             println("T3: purges deleted records");
1:             ps2.executeUpdate();
1:             con2.commit();
1:             println("T3: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         rs.first(); // Go to first tuple
1:         println("T1: Read first Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(2, 3);
1:         println("T1: updateInt(2, 3);");
1:         rs.updateRow();
1:         println("T1: updateRow()");
1:         rs.last(); // Go to last tuple
1:         println("T1: Read last Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(2, 3);
1:         println("T1: updateInt(2, 3);");
1:         rs.updateRow();
1:         println("T1: updateRow()");
0:         con.commit();
1:         println("T1: commit");
1:         rs = s.executeQuery("select * from t1");
1:         println("T3: select * from table");
1:         while (rs.next()) {
1:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a deleted tuple using positioned update
1:      * (same as testUpdatePurgedTuple1, except here we use positioned updates)
1:      **/
1:     public void testUpdatePurgedTuple2()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next(); // Point to first tuple
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         int firstKey = rs.getInt(1);
1:         rs.next(); // Go to next
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("delete from t1 where id=?");
1:             ps2.setInt(1, firstKey);
1:             assertEquals("Expected one record to be deleted", 1, 
1:                          ps2.executeUpdate());
1:             println("T2: Deleted record with id=" + firstKey);
1:             con2.commit();
1:             println("T2: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         rs.previous(); // Go back to first tuple
1:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         
0:         PreparedStatement ps = con.prepareStatement
1:             ("update T1 set a=? where current of " + rs.getCursorName());
1:         ps.setInt(1, 3);
1:         int updateCount = ps.executeUpdate();
1:         println("T1: update table, set a=3 where current of " + 
1:                 rs.getCursorName());
1:         println("T1: commit");
0:         con.commit();
1:         rs = s.executeQuery("select * from t1");
1:         while (rs.next()) {
1:             println("T3: Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a tuple which is deleted, purged and
1:      * reinserted
1:      **/
1:     public void testUpdatePurgedTuple3()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next(); // Point to first tuple
1:         int firstKey = rs.getInt(1);
1:         println("T1: read tuple with key " + firstKey);
1:         rs.next(); // Go to next
1:         println("T1: read next tuple");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("delete from t1 where id=?");
1:             ps2.setInt(1, firstKey);
1:             assertEquals("Expected one record to be deleted", 1, 
1:                          ps2.executeUpdate());
1:             println("T2: Deleted record with id=" + firstKey);
1:             con2.commit();
1:             println("T2: commit");
1:             
1:             // Now purge the table
1:             ps2 = con2.prepareStatement
1:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:             ps2.setString(1, "APP"); // schema
1:             ps2.setString(2, "T1");  // table name
1:             ps2.setInt(3, 1); // purge
1:             ps2.setInt(4, 0); // defragment rows
1:             ps2.setInt(5, 0); // truncate end
1:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:             println("T3: purges deleted records");
1:             ps2.executeUpdate();
1:             con2.commit();
1:             
0:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?)");
1:             ps2.setInt(1, firstKey);
1:             ps2.setInt(2, -1);
1:             ps2.setInt(3, -1);
1:             ps2.setString(4, "UPDATED TUPLE");
1:             assertEquals("Expected one record to be inserted", 1, 
1:                          ps2.executeUpdate());
1:             println("T4: Inserted record (" + firstKey + ",-1,-1)" );
1:             con2.commit();
1:             println("T4: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         println("T1: read previous tuple");
1:         rs.previous(); // Go back to first tuple
1:         println("T1: id=" + rs.getInt(1));
1:         rs.updateInt(2, 3);
1:         println("T1: updateInt(2, 3);");
1:         rs.updateRow();
1:         println("T1: updated column 2, to value=3");
1:         println("T1: commit");
0:         con.commit();
1:         rs = s.executeQuery("select * from t1");
1:         while (rs.next()) {
1:             println("T5: Read Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a tuple which is deleted, purged and 
1:      * then reinserted with the exact same values
1:      **/
1:     public void testUpdatePurgedTuple4()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next(); // Point to first tuple
1:         int firstKey = rs.getInt(1);
1:         int valA = rs.getInt(2);
1:         int valB = rs.getInt(3);
1:         
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         
1:         rs.next(); // Go to next
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("delete from t1 where id=?");
1:             ps2.setInt(1, firstKey);
1:             assertEquals("Expected one record to be deleted", 1, 
1:                          ps2.executeUpdate());
1:             println("T2: Deleted record with id=" + firstKey);
1:             con2.commit();
1:             println("T2: commit");
1:             
1:             // Now purge the table
1:             ps2 = con2.prepareStatement
1:                 ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:             ps2.setString(1, "APP"); // schema
1:             ps2.setString(2, "T1");  // table name
1:             ps2.setInt(3, 1); // purge
1:             ps2.setInt(4, 0); // defragment rows
1:             ps2.setInt(5, 0); // truncate end
1:             println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:             println("T3: purges deleted records");
1:             ps2.executeUpdate();
1:             con2.commit();
1:             println("T3: commit");
1:             
0:             ps2 = con2.prepareStatement("insert into t1 values(?,?,?,?)");
1:             ps2.setInt(1, firstKey);
1:             ps2.setInt(2, valA);
1:             ps2.setInt(3, valB);
1:             ps2.setString(4, "UPDATE TUPLE " + firstKey);
1:             assertEquals("Expected one record to be inserted", 1, 
1:                          ps2.executeUpdate());
1:             println("T4: Inserted record (" + firstKey + "," + valA + "," + 
1:                     valB + ")" );
1:             con2.commit();
1:             println("T4: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         rs.previous(); // Go back to first tuple
1:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         
1:         println("T1: id=" + rs.getInt(1));
1:         rs.updateInt(2, 3);
1:         rs.updateRow();
1:         println("T1: updated column 2, to value=3");
1:         println("T1: commit");
0:         con.commit();
1:         rs = s.executeQuery("select * from t1");
1:         while (rs.next()) {
1:             println("T4: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a tuple which has been modified by 
1:      * another transaction.
1:      **/
1:     public void testUpdateModifiedTuple1()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next(); // Point to first tuple
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         int firstKey = rs.getInt(1);
1:         rs.next(); // Go to next
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("update t1 set b=? where id=?");
1:             ps2.setInt(1, 999);
1:             ps2.setInt(2, firstKey);
1:             assertEquals("Expected one record to be updated", 1, 
1:                          ps2.executeUpdate());
1:             println("T2: Updated b=999 where id=" + firstKey);
1:             con2.commit();
1:             println("T2: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         rs.previous(); // Go back to first tuple
1:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(2, 3);
1:         rs.updateRow();
1:         println("T1: updated column 2, to value=3");
0:         con.commit();
1:         println("T1: commit");
1:         rs = s.executeQuery("select * from t1");
1:         while (rs.next()) {
1:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Test what happens if you update a tuple which has been modified by 
1:      * another transaction (in this case the same column)
1:      **/
1:     public void testUpdateModifiedTuple2()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next(); // Point to first tuple
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         int firstKey = rs.getInt(1);
1:         rs.next(); // Go to next
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("update t1 set b=? where id=?");
1:             ps2.setInt(1, 999);
1:             ps2.setInt(2, firstKey);
1:             assertEquals("Expected one record to be updated", 1, 
1:                          ps2.executeUpdate());
1:             println("T2: Updated b=999 where id=" + firstKey);
1:             con2.commit();
1:             println("T2: commit");
1:         } catch (SQLException e) {
1:             con2.rollback();
1:             throw e;
1:         }
1:         rs.previous(); // Go back to first tuple
1:         println("T1: Read previous Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(3, 9999);
1:         rs.updateRow();
1:         println("T1: updated column 3, to value=9999");
0:         con.commit();
1:         println("T1: commit");
1:         rs = s.executeQuery("select * from t1");
1:         while (rs.next()) {
1:             println("T3: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:             
1:         }
1:     }
1:     
1:     /**
1:      * Tests that a ResultSet opened even in read uncommitted, gets a 
1:      * table intent lock, and that another transaction then cannot compress 
1:      * the table while the ResultSet is open.
1:      **/
1:     public void testTableIntentLock1()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         println("T1: select * from t1");
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         while (rs.next()) {
1:             println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:         } // Now the cursor does not point to any tuples
1:         
1:         // Compressing the table in another transaction:
0:         Connection con2 = getNewConnection();
1:         try {
1:             con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:             PreparedStatement ps2 = con2.prepareStatement
0:                 ("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(?, ?, ?)");
0:             ps2.setString(1, "APP");
0:             ps2.setString(2, "T1");
0:             ps2.setInt(3, 0);
0:             println("T2: call SYSCS_UTIL.SYSCS_COMPRESS_TABLE(APP, T1, 0)");
1:             ps2.executeUpdate(); // This will hang
0:             assertTrue("Expected T2 to hang", false);
1:         } catch (SQLException e) {
1:             println("T2: Got exception:" + e.getMessage());
1:             
0:             assertEquals("Unexpected SQL state", 
0:                          LOCK_TIMEOUT_EXPRESSION_SQL_STATE,
1:                          e.getSQLState());
1:         } finally {
1:             con2.rollback();
1:         }
1:     }
1:     
1:     /**
1:      * Test that Derby set updatelock on current row when using
1:      * read-uncommitted
1:      **/
1:     public void testUpdateLockInReadUncommitted()
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next();
1:         int firstKey = rs.getInt(1);
1:         println("T1: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
0:         Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:         try {
1:             PreparedStatement ps2 = con2.prepareStatement
1:                 ("delete from t1 where id=?");
1:             ps2.setInt(1, firstKey);
1:             ps2.executeUpdate();
0:             assertTrue("expected record with id=" + firstKey + 
0:                        " to be locked", false);
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQL state",  LOCK_TIMEOUT_SQL_STATE,
1:                          e.getSQLState());
1:         } finally {
1:             con2.rollback();
1:         }          
1:     }
1:     
1:     /**
1:      * Test that the system cannot defragment any records
1:      * as long as an updatable result set is open against the table.
1:      **/
1:     public void testDefragmentDuringScan() 
1:         throws SQLException
1:     {
1:         testCompressDuringScan(true, false);
1:     }
1:     /**
1:      * Test that the system cannot truncate any records
1:      * as long as an updatable result set is open against the table.
1:      **/
1:     public void testTruncateDuringScan() 
1:         throws SQLException
1:     {
1:         testCompressDuringScan(false, true);
1:     }
1:     
1:     /**
1:      * Test that the system does not purge any records
1:      * as long as we do either a defragment, or truncate
1:      **/
1:     private void testCompressDuringScan(boolean testDefragment, 
1:                                         boolean testTruncate)
1:         throws SQLException 
1:     {
0:         con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
0:         Statement delStatement = con.createStatement();
1:         // First delete all records except the last and first
1:         int deleted = delStatement.executeUpdate
1:             ("delete from T1 where id>0 and id<" + (recordCount-1));
1:         int expectedDeleted = recordCount-2;    
1:         println("T1: delete records");
1:         assertEquals("Invalid number of records deleted", expectedDeleted, 
1:                      deleted);
0:         con.commit();
1:         println("T1: commit");
1:         
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next();
1:         int firstKey = rs.getInt(1);
1:         println("T2: Read next Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         int lastKey = firstKey;
1:         while (rs.next()) {
1:             lastKey = rs.getInt(1);
1:             println("T2: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:         }
1:         
0:         final Connection con2 = getNewConnection();
1:         con2.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:         final PreparedStatement ps2 = con2.prepareStatement
1:             ("call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?,?,?,?,?)");
1:         ps2.setString(1, "APP"); // schema
1:         ps2.setString(2, "T1");  // table name
1:         ps2.setInt(3, 0); // purge
1:         int defragment = testDefragment ? 1 : 0;
1:         int truncate = testTruncate ? 1 : 0;
1:         ps2.setInt(4, defragment); // defragment rows
1:         ps2.setInt(5, truncate); // truncate end
1:         
1:         println("T3: call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE");
1:         println("T3: defragmenting rows");
1:         try { 
1:             ps2.executeUpdate();
1:             con2.commit();
1:             println("T3: commit");
0:             assertTrue("Expected T3 to hang waiting for Table lock", false);
1:         } catch (SQLException e) {            
1:             println("T3: got expected exception");
1:             con2.rollback();            
1:         }
1:         rs.first(); // Go to first tuple
1:         println("T1: Read first Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(2, 3);
1:         println("T1: updateInt(2, 3);");
1:         rs.updateRow();        
1:         println("T1: updateRow()");
1:         rs.last(); // Go to last tuple
1:         println("T1: Read last Tuple:(" + rs.getInt(1) + "," +
1:                 rs.getInt(2) + "," +
1:                 rs.getInt(3) + ")");
1:         rs.updateInt(2, 3);
1:         println("T1: updateInt(2, 3);");
1:         rs.updateRow();
1:         println("T1: updateRow()");
0:         con.commit();
1:         println("T1: commit");
1:         rs = s.executeQuery("select * from t1");
1:         println("T4: select * from table");
1:         while (rs.next()) {
1:             println("T4: Read next Tuple:(" + rs.getInt(1) + "," +
1:                     rs.getInt(2) + "," +
1:                     rs.getInt(3) + ")");
1:         }
1:     }
1:     
1:     // By providing a static suite(), you can customize which tests to run.
1:     // The default is to run all tests in the TestCase subclass.
1:     
0:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         
0:         suite.addTest(new ConcurrencyTest("testUpdateLockDownGrade1"));
0:         suite.addTest(new ConcurrencyTest("testAquireUpdateLock1"));
1:                 
0:         suite.addTest(new ConcurrencyTest("testSharedLocks1"));
1:         suite.addTest(new ConcurrencyTest("testSharedLocks2"));
0:         suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks1"));
0:         suite.addTest(new ConcurrencyTest("testSharedAndUpdateLocks2"));
1:         
0:         // The following testcases requires Scrollable Updatable ResultSets:
0: //         suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple1"));
0: //         suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple2"));
0: //         suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple3"));
0: //         suite.addTest(new ConcurrencyTest("testUpdatePurgedTuple4"));
1:         
1:         
0: //         suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple1"));
0: //         suite.addTest(new ConcurrencyTest("testUpdateModifiedTuple2"));
0: //         suite.addTest(new ConcurrencyTest("testTableIntentLock1"));
0: //         suite.addTest(new ConcurrencyTest("testUpdateLockInReadUncommitted"));
0: //         suite.addTest(new ConcurrencyTest("testDefragmentDuringScan"));
0: //         suite.addTest(new ConcurrencyTest("testTruncateDuringScan"));
0:         /// ---------------
1:                 
1:             
0:         return suite;
1:     }
1:     
1: }
============================================================================