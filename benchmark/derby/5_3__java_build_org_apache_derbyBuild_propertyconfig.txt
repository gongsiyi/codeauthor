1:eac0369: /*
1:cd3749b: 
1:cd3749b:    Derby - Class org.apache.derbyBuild.propertyconfig
1:cd3749b: 
1:de243e0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:de243e0:    contributor license agreements.  See the NOTICE file distributed with
1:de243e0:    this work for additional information regarding copyright ownership.
1:de243e0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:de243e0:    (the "License"); you may not use this file except in compliance with
1:de243e0:    the License.  You may obtain a copy of the License at
1:cd3749b: 
1:cd3749b:       http://www.apache.org/licenses/LICENSE-2.0
1:cd3749b: 
1:cd3749b:    Unless required by applicable law or agreed to in writing, software
1:cd3749b:    distributed under the License is distributed on an "AS IS" BASIS,
1:cd3749b:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:cd3749b:    See the License for the specific language governing permissions and
1:cd3749b:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derbyBuild;
1:eac0369: import java.util.Properties;
1:eac0369: import java.io.FileInputStream;
1:eac0369: import java.io.FileOutputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.File;
1:eac0369: 
1:eac0369: import java.util.StringTokenizer;
1:eac0369: import java.util.Properties;
1:eac0369: import java.util.Enumeration;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369:  * 
1:eac0369:  * Usage: 
1:eac0369:  * java propertyConfig <master file> <config> <output file>
1:eac0369:  * <B> e.g., java propertyConfig dbms.properties cloudsync
1:eac0369:  * cloudsync.dbms.properties 
1:eac0369:  *
1:eac0369:  * <P>
1:eac0369:  * This program takes a master property file, and using the configuration
1:eac0369:  * specification, generate an output file that only contains the properties
1:eac0369:  * for that particular configuration.
1:eac0369:  *
1:eac0369:  * <P>
1:eac0369:  * For the different types of legitamite configurations, please see
1:eac0369:  * org.apache.derby.modules.properties
1:eac0369:  *
1:eac0369:  * <P>
1:eac0369:  * PropertySplitter will look at cloudscape.config.<tag> to see which
1:eac0369:  * configuration a particular module belongs to.
1:eac0369:  * <B>E.g., cloudscape.config.dataComm.listen=cloudtarget,cloudsync
1:eac0369:  * <B>this means all properties associated with dataComm.listen will be
1:eac0369:  * in the output properties file only if we are generating for the cloudsync or
1:eac0369:  * cloudtarget configuration.  They will not be in the output properties file
1:eac0369:  * if we are generating for the cloud or cloudscape configuration.
1:eac0369:  * 
1:eac0369:  */
1:eac0369: 
1:50d75f3: public class propertyconfig {
1:eac0369: 
1:5847a28: 	public static final String header =
1:eac0369: 		"######## This is a generated file, do not edit.\n" +
1:eac0369: 		"#\n# This file is generated as by propertyConfig\n" +
1:eac0369: 		"#\n";
1:eac0369: 
1:5847a28: 	public static final String footer =
1:eac0369: 		"\n######## This is a generated file, do not edit.\n";
1:eac0369: 
1:eac0369: 	public static void main(String[] args) throws IOException
1:eac0369: 	{
1:eac0369: 		if (args.length != 3)
1:eac0369: 			printUsageAndExit();
1:eac0369: 
1:eac0369: 		File masterfile = new File(args[0]);
1:eac0369: 		File outputfile = new File(args[2]);
1:eac0369: 
1:eac0369: 		if (!masterfile.exists())
1:eac0369: 			printUsageAndExit();
1:eac0369: 
1:eac0369: 		// OK, got the input cleared up, now do the processing
1:eac0369: 		Properties masterProp = new Properties();
1:eac0369: 		FileInputStream is = new FileInputStream(masterfile);
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			masterProp.load(is);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (is != null)
1:eac0369: 				is.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		process(masterProp, args[1], outputfile);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * For each module with a particular tag in derby.module.<tag>, see if
1:eac0369: 	 * there is any configuration restriction.  If there is no
1:eac0369: 	 * cloudscape.config.<tag> property, then this module should be present in
1:eac0369: 	 * all configurations.  If there is a cloudscape.config.<tag>, then this
1:eac0369: 	 * module should only be present in the configurations listed.
1:eac0369: 	 *
1:eac0369: 	 * <br>If this module should be present or this configuration, then gather
1:eac0369: 	 * up all the properties belong to this module and send it to the output
1:eac0369: 	 * file.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private static void process(Properties moduleList, String config, 
1:eac0369: 								File outputfile)
1:eac0369: 					throws IOException
1:eac0369: 	{
1:eac0369: 		Properties outputProp = new Properties();
1:eac0369: 
1:eac0369: 		// copy this code from
1:eac0369: 		// org.apache.derby.impl.services.monitor.BaseMonitor 
1:eac0369: 		//
1:eac0369: 		for (Enumeration e = moduleList.propertyNames(); e.hasMoreElements(); ) 
1:eac0369: 		{
1:eac0369: 			String key = (String) e.nextElement();
1:eac0369: 			if (key.startsWith("derby.module."))
1:eac0369: 			{
1:eac0369: 				String tag = key.substring("derby.module.".length());
1:eac0369: 
1:eac0369: 				// Check to see if it has any configuration requirements 
1:eac0369: 				String configKey = "cloudscape.config.".concat(tag);
1:eac0369: 				String configProp = moduleList.getProperty(configKey);
1:eac0369: 				
1:eac0369: 				boolean match = false;
1:eac0369: 
1:eac0369: 				if (configProp != null) 
1:eac0369: 				{
1:eac0369: 					StringTokenizer st = new StringTokenizer(configProp, ",");
1:eac0369: 					while(st.hasMoreTokens()) 
1:eac0369: 					{
1:eac0369: 
1:eac0369: 						String s = st.nextToken().trim();
1:eac0369: 
1:eac0369: 						// if config spec says all, it should not have other
1:eac0369: 						// configurations
1:eac0369: 						if (s.equalsIgnoreCase("all") &&
1:eac0369: 							!configProp.trim().equals("all"))
1:eac0369: 						{
1:eac0369: 							System.out.println("illegal config specification "
1:eac0369: 											   + key);
1:eac0369: 							System.exit(3);
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						// if config spec says none, it should not have other
1:eac0369: 						// configurations
1:eac0369: 						if (s.equalsIgnoreCase("none") &&
1:eac0369: 							!configProp.trim().equals("none"))
1:eac0369: 						{
1:eac0369: 							System.out.println("illegal config specification "
1:eac0369: 											   + key);
1:eac0369: 							System.exit(4);
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (s.equalsIgnoreCase(config) ||
1:eac0369: 							s.equalsIgnoreCase("all"))
1:eac0369: 						{
1:eac0369: 							match = true;
1:eac0369: 							break;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					// no config property, this module goes to all configs
1:eac0369: 					System.out.println("Need config specification for " + key);
1:eac0369: 					System.exit(2);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (match)
1:eac0369: 				{
1:eac0369: 					// gather up all relavant properties and put it in
1:eac0369: 					// outputProp
1:eac0369: 
1:eac0369: 					// derby.module.<tag>
1:eac0369: 					outputProp.put(key, moduleList.getProperty(key));
1:eac0369: 
1:eac0369: 					// don't output cloudscape.config.<tag>
1:eac0369: 					// that line only has meaning to this program
1:eac0369: 
1:eac0369: 					// derby.env.classes.<tag>
1:eac0369: 					String envKey = "derby.env.classes.".concat(tag);
1:eac0369: 					if (moduleList.getProperty(envKey) != null)
1:eac0369: 						outputProp.put(envKey, moduleList.getProperty(envKey));
1:eac0369: 
1:eac0369: 					// derby.env.jdk.<tag>
1:eac0369: 					// 
1:eac0369: 					// some of the configs only support one java env.  Some modules
1:eac0369: 					// have alternate implementation for running on java1 and
1:eac0369: 					// java2 platforms.  If we get rid of, say, the java2
1:eac0369: 					// implementation, then the monitor won't load the java1
1:eac0369: 					// implementation if that module specifies that it should
1:eac0369: 					// only be loaded in a java1 environment.  The result is
1:eac0369: 					// that some critical modules will be missing and the
1:eac0369: 					// database won't boot.
1:eac0369: 					//
1:eac0369: 					// the convention is, for modules that have both java1 and
1:eac0369: 					// java2 implementation, they must named the module as
1:eac0369: 					// derby.env.jdk.<name>J1 or
1:eac0369: 					// derby.env.jdk.<name>J2
1:eac0369: 					// in other words, the <tag> must end with J1 or J2.
1:eac0369: 					//
1:eac0369: 					// If a config only use one of the two implementation, then
1:eac0369: 					// this program will not put the one env.jdk line to the
1:eac0369: 					// output properties.  As a result, this one implementation
1:eac0369: 					// will be loaded when run in any environment.
1:eac0369: 					//
1:eac0369: 					// This does not apply to any module that only has one
1:eac0369: 					// implementation that runs on a specific jdk environment.
1:eac0369: 					//
1:eac0369: 					//derby.env.jdk.<tag>
1:eac0369: 					envKey = "derby.env.jdk.".concat(tag);
1:eac0369: 
1:eac0369: 					if (moduleList.getProperty(envKey) != null)
1:eac0369: 					{
1:eac0369: 						// by default keep the jdk env specification with the
1:eac0369: 						// config  
1:eac0369: 						boolean saveEnvKey = true;
1:eac0369: 
1:eac0369: 						// figure out if this is a tag of the form <name>J1 or
1:eac0369: 						// <name>J2.
1:eac0369: 						if (tag.endsWith("J1") || tag.endsWith("J2"))
1:eac0369: 						{
1:eac0369: 							// ok, this is a module with alternate
1:eac0369: 							// implementation for java 1 and java 2.  If this
1:eac0369: 							// config ditches one of them, then do not output
1:eac0369: 							// the env line
1:eac0369: 							int length = tag.length() - 2;
1:eac0369: 							String alternateTag = tag.substring(0, length);
1:eac0369: 							
1:eac0369: 							if (tag.endsWith("J1"))
1:eac0369: 								alternateTag += "J2";
1:eac0369: 							else
1:eac0369: 								alternateTag += "J1";
1:eac0369: 
1:eac0369: 							// see if 
1:eac0369: 							// 1) this module has an alternate impl for the 
1:eac0369: 							// other jdk and 
1:eac0369: 							// 2) this config is not going to pick it up.
1:eac0369: 							//
1:eac0369: 							
1:eac0369: 							String alternateImplKey = 
1:eac0369: 								"derby.module."+ alternateTag;
1:eac0369: 							String alternateJDKEnv = 
1:eac0369: 								"derby.env.jdk."+ alternateTag;
1:eac0369: 							String alternateImplConfigKey =
1:eac0369: 								"cloudscape.config."+alternateTag;
1:eac0369: 
1:eac0369: 							// if any of of these are not present, then we
1:eac0369: 							// don't have a problem because either there is no
1:eac0369: 							// alternate implementation, or the alternate
1:eac0369: 							// implementation is not based on jdk, or the
1:eac0369: 							// alternate jdk based implemenation will also be
1:eac0369: 							// present in this configuration
1:eac0369: 
1:eac0369: 							if ((moduleList.getProperty(alternateImplKey) != null) &&
1:eac0369: 								(moduleList.getProperty(alternateJDKEnv) != null) && 
1:eac0369: 								(moduleList.getProperty(alternateImplConfigKey) != null))
1:eac0369: 							{
1:eac0369: 								// there is an alternate impl that is jdk based
1:eac0369: 								// and it has a config tag.  Let's see if it is
1:eac0369: 								// part of this config.
1:eac0369: 								String alternateConfigProp =
1:eac0369: 									moduleList.getProperty(alternateImplConfigKey);
1:eac0369: 
1:eac0369: 								// we know that there are
1:eac0369: 								// derby.module.<tag>J2 and
1:eac0369: 								// derby.module.<tag>J1 and
1:eac0369: 								// derby.env.jdk.<tag>J2 and
1:eac0369: 								// derby.env.jdk.<tag>J1 and
1:eac0369: 								// cloudscape.config.<tag>J2 and 
1:eac0369: 								// cloudscape.config.<tag>J1
1:eac0369: 								StringTokenizer st2 = new
1:eac0369: 									StringTokenizer(alternateConfigProp, ",");
1:eac0369: 
1:eac0369: 								boolean ok = false;
1:eac0369: 								while(st2.hasMoreTokens()) 
1:eac0369: 								{
1:eac0369: 									String s = st2.nextToken().trim();
1:eac0369: 
1:eac0369: 									if (s.equalsIgnoreCase(config) ||
1:eac0369: 										s.equalsIgnoreCase("all"))
1:eac0369: 									{
1:eac0369: 										ok = true;
1:eac0369: 										break;
1:eac0369: 									}
1:eac0369: 								}
1:eac0369: 								// the alternate module impl is not part of
1:eac0369: 								// this config, do not save the jdk env key
1:eac0369: 								if (!ok) 
1:eac0369: 									saveEnvKey = false;
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 
1:eac0369: 						if (saveEnvKey)
1:eac0369: 							outputProp.put(envKey, moduleList.getProperty(envKey));
1:eac0369: 					}
1:eac0369: 					
1:eac0369: 
1:eac0369: 
1:eac0369: 					// NOTE, if other types of properties are added to
1:eac0369: 					// modules.properties, be sure to add it here too.
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		FileOutputStream os = new FileOutputStream(outputfile);
1:eac0369: 		try
1:eac0369: 		{
1:129b076: 			outputProp.store(os,
1:eac0369: 							header.
1:eac0369: 							concat("# config is ").concat(config).
1:eac0369: 							concat(footer));
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			if (os != null)
1:eac0369: 				os.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private static void printUsageAndExit()
1:eac0369: 	{
1:eac0369: 		StringBuffer buf = new StringBuffer(400);
1:eac0369: 
1:eac0369: 		buf.append("Usage propertyConfig <masterFile> <config> <outputFile>\n")
1:eac0369: 			.append("masterFile must be a pre-existing properties file ")
1:eac0369: 			.append("containing all the modules properites\n")
1:eac0369: 			.append("config must be a configuration defined in ")
1:eac0369: 			.append("org.apache.derby.modules.properties.\n")
1:eac0369: 			.append("outputFile must not be a pre-existing properties file.\n\n")
1:eac0369: 			.append("propertyConfig will generate the outputFile based on")
1:eac0369: 			.append("the masterfile and the configuration specified.")
1:eac0369: 			.append("\n\nE.g., java propertyConfig dbms.properties cloudsync dbms.cloudsync.properties\n");
1:eac0369: 		
1:eac0369: 
1:eac0369: 		System.out.println(buf.toString());
1:eac0369: 		System.exit(1);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5847a28
/////////////////////////////////////////////////////////////////////////
1: 	public static final String header =
1: 	public static final String footer =
commit:129b076
/////////////////////////////////////////////////////////////////////////
1: 			outputProp.store(os,
author:David Van Couvering
-------------------------------------------------------------------------------
commit:de243e0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:cd3749b
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyBuild.propertyconfig
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:50d75f3
/////////////////////////////////////////////////////////////////////////
1: public class propertyconfig {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyBuild
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyBuild;
1: import java.util.Properties;
1: import java.io.FileInputStream;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
1: import java.io.File;
1: 
1: import java.util.StringTokenizer;
1: import java.util.Properties;
1: import java.util.Enumeration;
1: 
1: 
1: /**
1:  * 
1:  * Usage: 
1:  * java propertyConfig <master file> <config> <output file>
1:  * <B> e.g., java propertyConfig dbms.properties cloudsync
1:  * cloudsync.dbms.properties 
1:  *
1:  * <P>
1:  * This program takes a master property file, and using the configuration
1:  * specification, generate an output file that only contains the properties
1:  * for that particular configuration.
1:  *
1:  * <P>
1:  * For the different types of legitamite configurations, please see
1:  * org.apache.derby.modules.properties
1:  *
1:  * <P>
1:  * PropertySplitter will look at cloudscape.config.<tag> to see which
1:  * configuration a particular module belongs to.
1:  * <B>E.g., cloudscape.config.dataComm.listen=cloudtarget,cloudsync
1:  * <B>this means all properties associated with dataComm.listen will be
1:  * in the output properties file only if we are generating for the cloudsync or
1:  * cloudtarget configuration.  They will not be in the output properties file
1:  * if we are generating for the cloud or cloudscape configuration.
1:  * 
1:  */
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
1: 
0: public class propertyconfig { private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
0: 	public static String header = 
1: 		"######## This is a generated file, do not edit.\n" +
1: 		"#\n# This file is generated as by propertyConfig\n" +
1: 		"#\n";
1: 
0: 	public static String footer = 
1: 		"\n######## This is a generated file, do not edit.\n";
1: 
1: 	public static void main(String[] args) throws IOException
1: 	{
1: 		if (args.length != 3)
1: 			printUsageAndExit();
1: 
1: 		File masterfile = new File(args[0]);
1: 		File outputfile = new File(args[2]);
1: 
1: 		if (!masterfile.exists())
1: 			printUsageAndExit();
1: 
1: 		// OK, got the input cleared up, now do the processing
1: 		Properties masterProp = new Properties();
1: 		FileInputStream is = new FileInputStream(masterfile);
1: 
1: 		try
1: 		{
1: 			masterProp.load(is);
1: 		}
1: 		finally
1: 		{
1: 			if (is != null)
1: 				is.close();
1: 		}
1: 
1: 		process(masterProp, args[1], outputfile);
1: 	}
1: 
1: 	/**
1: 	 * For each module with a particular tag in derby.module.<tag>, see if
1: 	 * there is any configuration restriction.  If there is no
1: 	 * cloudscape.config.<tag> property, then this module should be present in
1: 	 * all configurations.  If there is a cloudscape.config.<tag>, then this
1: 	 * module should only be present in the configurations listed.
1: 	 *
1: 	 * <br>If this module should be present or this configuration, then gather
1: 	 * up all the properties belong to this module and send it to the output
1: 	 * file.
1: 	 *
1: 	 */
1: 	private static void process(Properties moduleList, String config, 
1: 								File outputfile)
1: 					throws IOException
1: 	{
1: 		Properties outputProp = new Properties();
1: 
1: 		// copy this code from
1: 		// org.apache.derby.impl.services.monitor.BaseMonitor 
1: 		//
1: 		for (Enumeration e = moduleList.propertyNames(); e.hasMoreElements(); ) 
1: 		{
1: 			String key = (String) e.nextElement();
1: 			if (key.startsWith("derby.module."))
1: 			{
1: 				String tag = key.substring("derby.module.".length());
1: 
1: 				// Check to see if it has any configuration requirements 
1: 				String configKey = "cloudscape.config.".concat(tag);
1: 				String configProp = moduleList.getProperty(configKey);
1: 				
1: 				boolean match = false;
1: 
1: 				if (configProp != null) 
1: 				{
1: 					StringTokenizer st = new StringTokenizer(configProp, ",");
1: 					while(st.hasMoreTokens()) 
1: 					{
1: 
1: 						String s = st.nextToken().trim();
1: 
1: 						// if config spec says all, it should not have other
1: 						// configurations
1: 						if (s.equalsIgnoreCase("all") &&
1: 							!configProp.trim().equals("all"))
1: 						{
1: 							System.out.println("illegal config specification "
1: 											   + key);
1: 							System.exit(3);
1: 						}
1: 
1: 						// if config spec says none, it should not have other
1: 						// configurations
1: 						if (s.equalsIgnoreCase("none") &&
1: 							!configProp.trim().equals("none"))
1: 						{
1: 							System.out.println("illegal config specification "
1: 											   + key);
1: 							System.exit(4);
1: 						}
1: 
1: 						if (s.equalsIgnoreCase(config) ||
1: 							s.equalsIgnoreCase("all"))
1: 						{
1: 							match = true;
1: 							break;
1: 						}
1: 					}
1: 				}
1: 				else
1: 				{
1: 					// no config property, this module goes to all configs
1: 					System.out.println("Need config specification for " + key);
1: 					System.exit(2);
1: 				}
1: 
1: 				if (match)
1: 				{
1: 					// gather up all relavant properties and put it in
1: 					// outputProp
1: 
1: 					// derby.module.<tag>
1: 					outputProp.put(key, moduleList.getProperty(key));
1: 
1: 					// don't output cloudscape.config.<tag>
1: 					// that line only has meaning to this program
1: 
1: 					// derby.env.classes.<tag>
1: 					String envKey = "derby.env.classes.".concat(tag);
1: 					if (moduleList.getProperty(envKey) != null)
1: 						outputProp.put(envKey, moduleList.getProperty(envKey));
1: 
1: 					// derby.env.jdk.<tag>
1: 					// 
1: 					// some of the configs only support one java env.  Some modules
1: 					// have alternate implementation for running on java1 and
1: 					// java2 platforms.  If we get rid of, say, the java2
1: 					// implementation, then the monitor won't load the java1
1: 					// implementation if that module specifies that it should
1: 					// only be loaded in a java1 environment.  The result is
1: 					// that some critical modules will be missing and the
1: 					// database won't boot.
1: 					//
1: 					// the convention is, for modules that have both java1 and
1: 					// java2 implementation, they must named the module as
1: 					// derby.env.jdk.<name>J1 or
1: 					// derby.env.jdk.<name>J2
1: 					// in other words, the <tag> must end with J1 or J2.
1: 					//
1: 					// If a config only use one of the two implementation, then
1: 					// this program will not put the one env.jdk line to the
1: 					// output properties.  As a result, this one implementation
1: 					// will be loaded when run in any environment.
1: 					//
1: 					// This does not apply to any module that only has one
1: 					// implementation that runs on a specific jdk environment.
1: 					//
1: 					//derby.env.jdk.<tag>
1: 					envKey = "derby.env.jdk.".concat(tag);
1: 
1: 					if (moduleList.getProperty(envKey) != null)
1: 					{
1: 						// by default keep the jdk env specification with the
1: 						// config  
1: 						boolean saveEnvKey = true;
1: 
1: 						// figure out if this is a tag of the form <name>J1 or
1: 						// <name>J2.
1: 						if (tag.endsWith("J1") || tag.endsWith("J2"))
1: 						{
1: 							// ok, this is a module with alternate
1: 							// implementation for java 1 and java 2.  If this
1: 							// config ditches one of them, then do not output
1: 							// the env line
1: 							int length = tag.length() - 2;
1: 							String alternateTag = tag.substring(0, length);
1: 							
1: 							if (tag.endsWith("J1"))
1: 								alternateTag += "J2";
1: 							else
1: 								alternateTag += "J1";
1: 
1: 							// see if 
1: 							// 1) this module has an alternate impl for the 
1: 							// other jdk and 
1: 							// 2) this config is not going to pick it up.
1: 							//
1: 							
1: 							String alternateImplKey = 
1: 								"derby.module."+ alternateTag;
1: 							String alternateJDKEnv = 
1: 								"derby.env.jdk."+ alternateTag;
1: 							String alternateImplConfigKey =
1: 								"cloudscape.config."+alternateTag;
1: 
1: 							// if any of of these are not present, then we
1: 							// don't have a problem because either there is no
1: 							// alternate implementation, or the alternate
1: 							// implementation is not based on jdk, or the
1: 							// alternate jdk based implemenation will also be
1: 							// present in this configuration
1: 
1: 							if ((moduleList.getProperty(alternateImplKey) != null) &&
1: 								(moduleList.getProperty(alternateJDKEnv) != null) && 
1: 								(moduleList.getProperty(alternateImplConfigKey) != null))
1: 							{
1: 								// there is an alternate impl that is jdk based
1: 								// and it has a config tag.  Let's see if it is
1: 								// part of this config.
1: 								String alternateConfigProp =
1: 									moduleList.getProperty(alternateImplConfigKey);
1: 
1: 								// we know that there are
1: 								// derby.module.<tag>J2 and
1: 								// derby.module.<tag>J1 and
1: 								// derby.env.jdk.<tag>J2 and
1: 								// derby.env.jdk.<tag>J1 and
1: 								// cloudscape.config.<tag>J2 and 
1: 								// cloudscape.config.<tag>J1
1: 								StringTokenizer st2 = new
1: 									StringTokenizer(alternateConfigProp, ",");
1: 
1: 								boolean ok = false;
1: 								while(st2.hasMoreTokens()) 
1: 								{
1: 									String s = st2.nextToken().trim();
1: 
1: 									if (s.equalsIgnoreCase(config) ||
1: 										s.equalsIgnoreCase("all"))
1: 									{
1: 										ok = true;
1: 										break;
1: 									}
1: 								}
1: 								// the alternate module impl is not part of
1: 								// this config, do not save the jdk env key
1: 								if (!ok) 
1: 									saveEnvKey = false;
1: 							}
1: 						}
1: 
1: 						if (saveEnvKey)
1: 							outputProp.put(envKey, moduleList.getProperty(envKey));
1: 					}
1: 					
1: 
1: 
1: 					// NOTE, if other types of properties are added to
1: 					// modules.properties, be sure to add it here too.
1: 				}
1: 			}
1: 		}
1: 
1: 		FileOutputStream os = new FileOutputStream(outputfile);
1: 		try
1: 		{
0: 			outputProp.save(os, 
1: 							header.
1: 							concat("# config is ").concat(config).
1: 							concat(footer));
1: 		}
1: 		finally
1: 		{
1: 			if (os != null)
1: 				os.close();
1: 		}
1: 	}
1: 
1: 
1: 	private static void printUsageAndExit()
1: 	{
1: 		StringBuffer buf = new StringBuffer(400);
1: 
1: 		buf.append("Usage propertyConfig <masterFile> <config> <outputFile>\n")
1: 			.append("masterFile must be a pre-existing properties file ")
1: 			.append("containing all the modules properites\n")
1: 			.append("config must be a configuration defined in ")
1: 			.append("org.apache.derby.modules.properties.\n")
1: 			.append("outputFile must not be a pre-existing properties file.\n\n")
1: 			.append("propertyConfig will generate the outputFile based on")
1: 			.append("the masterfile and the configuration specified.")
1: 			.append("\n\nE.g., java propertyConfig dbms.properties cloudsync dbms.cloudsync.properties\n");
1: 		
1: 
1: 		System.out.println(buf.toString());
1: 		System.exit(1);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyBuild
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derbyBuild;
0: import java.util.Properties;
0: import java.io.FileInputStream;
0: import java.io.FileOutputStream;
0: import java.io.IOException;
0: import java.io.File;
0: 
0: import java.util.StringTokenizer;
0: import java.util.Properties;
0: import java.util.Enumeration;
0: 
0: 
0: /**
0:  * 
0:  * Usage: 
0:  * java propertyConfig <master file> <config> <output file>
0:  * <B> e.g., java propertyConfig dbms.properties cloudsync
0:  * cloudsync.dbms.properties 
0:  *
0:  * <P>
0:  * This program takes a master property file, and using the configuration
0:  * specification, generate an output file that only contains the properties
0:  * for that particular configuration.
0:  *
0:  * <P>
0:  * For the different types of legitamite configurations, please see
0:  * org.apache.derby.modules.properties
0:  *
0:  * <P>
0:  * PropertySplitter will look at cloudscape.config.<tag> to see which
0:  * configuration a particular module belongs to.
0:  * <B>E.g., cloudscape.config.dataComm.listen=cloudtarget,cloudsync
0:  * <B>this means all properties associated with dataComm.listen will be
0:  * in the output properties file only if we are generating for the cloudsync or
0:  * cloudtarget configuration.  They will not be in the output properties file
0:  * if we are generating for the cloud or cloudscape configuration.
0:  * 
0:  */
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 
0: public class propertyconfig { private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0: 	public static String header = 
0: 		"######## This is a generated file, do not edit.\n" +
0: 		"#\n# This file is generated as by propertyConfig\n" +
0: 		"#\n";
0: 
0: 	public static String footer = 
0: 		"\n######## This is a generated file, do not edit.\n";
0: 
0: 	public static void main(String[] args) throws IOException
0: 	{
0: 		if (args.length != 3)
0: 			printUsageAndExit();
0: 
0: 		File masterfile = new File(args[0]);
0: 		File outputfile = new File(args[2]);
0: 
0: 		if (!masterfile.exists())
0: 			printUsageAndExit();
0: 
0: 		// OK, got the input cleared up, now do the processing
0: 		Properties masterProp = new Properties();
0: 		FileInputStream is = new FileInputStream(masterfile);
0: 
0: 		try
0: 		{
0: 			masterProp.load(is);
0: 		}
0: 		finally
0: 		{
0: 			if (is != null)
0: 				is.close();
0: 		}
0: 
0: 		process(masterProp, args[1], outputfile);
0: 	}
0: 
0: 	/**
0: 	 * For each module with a particular tag in derby.module.<tag>, see if
0: 	 * there is any configuration restriction.  If there is no
0: 	 * cloudscape.config.<tag> property, then this module should be present in
0: 	 * all configurations.  If there is a cloudscape.config.<tag>, then this
0: 	 * module should only be present in the configurations listed.
0: 	 *
0: 	 * <br>If this module should be present or this configuration, then gather
0: 	 * up all the properties belong to this module and send it to the output
0: 	 * file.
0: 	 *
0: 	 */
0: 	private static void process(Properties moduleList, String config, 
0: 								File outputfile)
0: 					throws IOException
0: 	{
0: 		Properties outputProp = new Properties();
0: 
0: 		// copy this code from
0: 		// org.apache.derby.impl.services.monitor.BaseMonitor 
0: 		//
0: 		for (Enumeration e = moduleList.propertyNames(); e.hasMoreElements(); ) 
0: 		{
0: 			String key = (String) e.nextElement();
0: 			if (key.startsWith("derby.module."))
0: 			{
0: 				String tag = key.substring("derby.module.".length());
0: 
0: 				// Check to see if it has any configuration requirements 
0: 				String configKey = "cloudscape.config.".concat(tag);
0: 				String configProp = moduleList.getProperty(configKey);
0: 				
0: 				boolean match = false;
0: 
0: 				if (configProp != null) 
0: 				{
0: 					StringTokenizer st = new StringTokenizer(configProp, ",");
0: 					while(st.hasMoreTokens()) 
0: 					{
0: 
0: 						String s = st.nextToken().trim();
0: 
0: 						// if config spec says all, it should not have other
0: 						// configurations
0: 						if (s.equalsIgnoreCase("all") &&
0: 							!configProp.trim().equals("all"))
0: 						{
0: 							System.out.println("illegal config specification "
0: 											   + key);
0: 							System.exit(3);
0: 						}
0: 
0: 						// if config spec says none, it should not have other
0: 						// configurations
0: 						if (s.equalsIgnoreCase("none") &&
0: 							!configProp.trim().equals("none"))
0: 						{
0: 							System.out.println("illegal config specification "
0: 											   + key);
0: 							System.exit(4);
0: 						}
0: 
0: 						if (s.equalsIgnoreCase(config) ||
0: 							s.equalsIgnoreCase("all"))
0: 						{
0: 							match = true;
0: 							break;
0: 						}
0: 					}
0: 				}
0: 				else
0: 				{
0: 					// no config property, this module goes to all configs
0: 					System.out.println("Need config specification for " + key);
0: 					System.exit(2);
0: 				}
0: 
0: 				if (match)
0: 				{
0: 					// gather up all relavant properties and put it in
0: 					// outputProp
0: 
0: 					// derby.module.<tag>
0: 					outputProp.put(key, moduleList.getProperty(key));
0: 
0: 					// don't output cloudscape.config.<tag>
0: 					// that line only has meaning to this program
0: 
0: 					// derby.env.classes.<tag>
0: 					String envKey = "derby.env.classes.".concat(tag);
0: 					if (moduleList.getProperty(envKey) != null)
0: 						outputProp.put(envKey, moduleList.getProperty(envKey));
0: 
0: 					// derby.env.jdk.<tag>
0: 					// 
0: 					// some of the configs only support one java env.  Some modules
0: 					// have alternate implementation for running on java1 and
0: 					// java2 platforms.  If we get rid of, say, the java2
0: 					// implementation, then the monitor won't load the java1
0: 					// implementation if that module specifies that it should
0: 					// only be loaded in a java1 environment.  The result is
0: 					// that some critical modules will be missing and the
0: 					// database won't boot.
0: 					//
0: 					// the convention is, for modules that have both java1 and
0: 					// java2 implementation, they must named the module as
0: 					// derby.env.jdk.<name>J1 or
0: 					// derby.env.jdk.<name>J2
0: 					// in other words, the <tag> must end with J1 or J2.
0: 					//
0: 					// If a config only use one of the two implementation, then
0: 					// this program will not put the one env.jdk line to the
0: 					// output properties.  As a result, this one implementation
0: 					// will be loaded when run in any environment.
0: 					//
0: 					// This does not apply to any module that only has one
0: 					// implementation that runs on a specific jdk environment.
0: 					//
0: 					//derby.env.jdk.<tag>
0: 					envKey = "derby.env.jdk.".concat(tag);
0: 
0: 					if (moduleList.getProperty(envKey) != null)
0: 					{
0: 						// by default keep the jdk env specification with the
0: 						// config  
0: 						boolean saveEnvKey = true;
0: 
0: 						// figure out if this is a tag of the form <name>J1 or
0: 						// <name>J2.
0: 						if (tag.endsWith("J1") || tag.endsWith("J2"))
0: 						{
0: 							// ok, this is a module with alternate
0: 							// implementation for java 1 and java 2.  If this
0: 							// config ditches one of them, then do not output
0: 							// the env line
0: 							int length = tag.length() - 2;
0: 							String alternateTag = tag.substring(0, length);
0: 							
0: 							if (tag.endsWith("J1"))
0: 								alternateTag += "J2";
0: 							else
0: 								alternateTag += "J1";
0: 
0: 							// see if 
0: 							// 1) this module has an alternate impl for the 
0: 							// other jdk and 
0: 							// 2) this config is not going to pick it up.
0: 							//
0: 							
0: 							String alternateImplKey = 
0: 								"derby.module."+ alternateTag;
0: 							String alternateJDKEnv = 
0: 								"derby.env.jdk."+ alternateTag;
0: 							String alternateImplConfigKey =
0: 								"cloudscape.config."+alternateTag;
0: 
0: 							// if any of of these are not present, then we
0: 							// don't have a problem because either there is no
0: 							// alternate implementation, or the alternate
0: 							// implementation is not based on jdk, or the
0: 							// alternate jdk based implemenation will also be
0: 							// present in this configuration
0: 
0: 							if ((moduleList.getProperty(alternateImplKey) != null) &&
0: 								(moduleList.getProperty(alternateJDKEnv) != null) && 
0: 								(moduleList.getProperty(alternateImplConfigKey) != null))
0: 							{
0: 								// there is an alternate impl that is jdk based
0: 								// and it has a config tag.  Let's see if it is
0: 								// part of this config.
0: 								String alternateConfigProp =
0: 									moduleList.getProperty(alternateImplConfigKey);
0: 
0: 								// we know that there are
0: 								// derby.module.<tag>J2 and
0: 								// derby.module.<tag>J1 and
0: 								// derby.env.jdk.<tag>J2 and
0: 								// derby.env.jdk.<tag>J1 and
0: 								// cloudscape.config.<tag>J2 and 
0: 								// cloudscape.config.<tag>J1
0: 								StringTokenizer st2 = new
0: 									StringTokenizer(alternateConfigProp, ",");
0: 
0: 								boolean ok = false;
0: 								while(st2.hasMoreTokens()) 
0: 								{
0: 									String s = st2.nextToken().trim();
0: 
0: 									if (s.equalsIgnoreCase(config) ||
0: 										s.equalsIgnoreCase("all"))
0: 									{
0: 										ok = true;
0: 										break;
0: 									}
0: 								}
0: 								// the alternate module impl is not part of
0: 								// this config, do not save the jdk env key
0: 								if (!ok) 
0: 									saveEnvKey = false;
0: 							}
0: 						}
0: 
0: 						if (saveEnvKey)
0: 							outputProp.put(envKey, moduleList.getProperty(envKey));
0: 					}
0: 					
0: 
0: 
0: 					// NOTE, if other types of properties are added to
0: 					// modules.properties, be sure to add it here too.
0: 				}
0: 			}
0: 		}
0: 
0: 		FileOutputStream os = new FileOutputStream(outputfile);
0: 		try
0: 		{
0: 			outputProp.save(os, 
0: 							header.
0: 							concat("# config is ").concat(config).
0: 							concat(footer));
0: 		}
0: 		finally
0: 		{
0: 			if (os != null)
0: 				os.close();
0: 		}
0: 	}
0: 
0: 
0: 	private static void printUsageAndExit()
0: 	{
0: 		StringBuffer buf = new StringBuffer(400);
0: 
0: 		buf.append("Usage propertyConfig <masterFile> <config> <outputFile>\n")
0: 			.append("masterFile must be a pre-existing properties file ")
0: 			.append("containing all the modules properites\n")
0: 			.append("config must be a configuration defined in ")
0: 			.append("org.apache.derby.modules.properties.\n")
0: 			.append("outputFile must not be a pre-existing properties file.\n\n")
0: 			.append("propertyConfig will generate the outputFile based on")
0: 			.append("the masterfile and the configuration specified.")
0: 			.append("\n\nE.g., java propertyConfig dbms.properties cloudsync dbms.cloudsync.properties\n");
0: 		
0: 
0: 		System.out.println(buf.toString());
0: 		System.exit(1);
0: 	}
0: }
============================================================================