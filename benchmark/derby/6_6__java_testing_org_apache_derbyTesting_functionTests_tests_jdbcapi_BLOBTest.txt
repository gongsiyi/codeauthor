2:fc02124: /**
2:fc02124:  *
1:fc02124:  * Derby - Class BLOBTest
1:fc02124:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:fc02124:  *
1:fc02124:  *    http://www.apache.org/licenses/LICENSE-2.0
1:fc02124:  *
1:fc02124:  * Unless required by applicable law or agreed to in writing,
1:fc02124:  * software distributed under the License is distributed on an
1:fc02124:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:fc02124:  * either express or implied. See the License for the specific
1:fc02124:  * language governing permissions and limitations under the License.
2:fc02124:  */
1:fc02124: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:1d0c809: 
1:fc02124: import org.apache.derbyTesting.functionTests.util.TestInputStream;
1:1d0c809: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:1d0c809: import org.apache.derbyTesting.functionTests.util.streams.ReadOnceByteArrayInputStream;
1:1d0c809: import org.apache.derbyTesting.functionTests.util.streams.StringReaderWithLength;
1:1d0c809: import org.apache.derbyTesting.junit.JDBC;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:3bd1dd8: 
1:fc02124: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:fc02124: import java.sql.PreparedStatement;
1:fc02124: import java.sql.ResultSet;
1:fc02124: import java.sql.Statement;
1:fc02124: import java.sql.Blob;
1:fc02124: import java.sql.Connection;
1:fc02124: import java.sql.SQLException;
1:1d0c809: import java.sql.Types;
1:8f01b3c: import java.io.EOFException;
1:fc02124: import java.io.IOException;
1:fc02124: import java.io.InputStream;
1:1d0c809: import java.util.Random;
15:fc02124: 
1:fc02124: /**
1:fc02124:  * Tests reading and updating binary large objects (BLOBs).
1:fc02124:  */
1:fc02124: final public class BLOBTest extends BaseJDBCTestCase
2:fc02124: {
1:fc02124:     /** 
1:fc02124:      * Constructor
1:fc02124:      * @param name name of test case (method).
1:fc02124:      */
1:fc02124:     public BLOBTest(String name) 
1:fc02124:     {
1:fc02124:         super(name);
3:fc02124:     }
1:4292752: 
1:fc02124:     
1:8f01b3c:     /**
1:fc02124:      * Tests updating a Blob from a scollable resultset, using
3:fc02124:      * result set update methods.
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     public void testUpdateBlobFromScrollableResultSetUsingResultSetMethods()
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:fc02124:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:fc02124:                                 ResultSet.CONCUR_UPDATABLE);
2:fc02124:         final ResultSet rs = 
1:fc02124:             stmt.executeQuery("SELECT * from " + 
1:fc02124:                               BLOBDataModelSetup.getBlobTableName());
1:fc02124:         println("Last");
1:fc02124:         rs.last();
1:fc02124:         
1:fc02124:         final int newVal = rs.getInt(1) + 11;
1:fc02124:         final int newSize = rs.getInt(2) / 2;
1:fc02124:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:fc02124:         
1:fc02124:         println("Verify updated blob using result set");
1:fc02124:         verifyBlob(newVal, newSize, rs.getBlob(3));
1:fc02124:         
1:fc02124:         rs.close();
1:4292752:         stmt.close();
1:fc02124:     }
1:1d0c809: 
1:1d0c809:     /**
1:fc02124:      * Tests updating a Blob from a forward only resultset, using
1:fc02124:      * result set update methods.
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     public void testUpdateBlobFromForwardOnlyResultSetUsingResultSetMethods()
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:fc02124:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:fc02124:                                 ResultSet.CONCUR_UPDATABLE);
1:fc02124:         final ResultSet rs = 
1:fc02124:             stmt.executeQuery("SELECT * from " + 
1:fc02124:                               BLOBDataModelSetup.getBlobTableName());
1:fc02124:         
1:fc02124:         while (rs.next()) {
1:fc02124:             println("Next");
1:1160146:             final int val = rs.getInt(1);
1:1160146:             if (val == BLOBDataModelSetup.bigVal) break;
1:fc02124:         }
1:fc02124:         
1:fc02124:         final int newVal = rs.getInt(1) + 11;
1:fc02124:         final int newSize = rs.getInt(2) / 2;
1:fc02124:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:fc02124:         
1:fc02124:         rs.close();
1:4292752:         stmt.close();
1:fc02124:     }
1:fc02124: 
1:fc02124:     /**
1:fc02124:      * Tests updating a Blob from a scollable resultset, using
1:1160146:      * positioned updates.
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     public void testUpdateBlobFromScrollableResultSetUsingPositionedUpdates()
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:fc02124:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:fc02124:                                 ResultSet.CONCUR_UPDATABLE);
1:fc02124:         final ResultSet rs = 
1:fc02124:             stmt.executeQuery("SELECT * from " + 
1:fc02124:                               BLOBDataModelSetup.getBlobTableName());
1:fc02124:         println("Last");
1:fc02124:         rs.last();
1:fc02124:         
1:fc02124:         final int newVal = rs.getInt(1) + 11;
1:fc02124:         final int newSize = rs.getInt(2) / 2;
1:fc02124:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:1160146: 
1:fc02124:         rs.relative(0); // Necessary after a positioned update
1:fc02124:         
1:fc02124:         println("Verify updated blob using result set");
1:fc02124:         verifyBlob(newVal, newSize, rs.getBlob(3));
1:fc02124:         
1:1160146:         rs.close();
1:4292752:         stmt.close();
1:1160146:     }
1:fc02124: 
1:1160146:     /**
1:fc02124:      * Tests updating a Blob from a forward only resultset, using
1:1160146:      * methods.
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     public void testUpdateBlobFromForwardOnlyResultSetUsingPositionedUpdates()
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:fc02124:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:fc02124:                                 ResultSet.CONCUR_UPDATABLE);
1:fc02124:         final ResultSet rs = 
1:fc02124:             stmt.executeQuery("SELECT * from " + 
1:fc02124:                               BLOBDataModelSetup.getBlobTableName());
1:fc02124:         while (rs.next()) {
1:fc02124:             println("Next");
1:1160146:             final int val = rs.getInt(1);
1:1160146:             if (val == BLOBDataModelSetup.bigVal) break;
1:fc02124:         }
1:fc02124:         
1:fc02124:         final int newVal = rs.getInt(1) + 11;
1:fc02124:         final int newSize = rs.getInt(2) / 2;
1:fc02124:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:fc02124:         
1:fc02124:         rs.close();
1:4292752:         stmt.close();
1:fc02124:     }
1:fc02124: 
1:fc02124:     /**
1:1160146:      * Tests updating a Blob from a scollable resultset produced by a
1:1160146:      * select query with projection. Updates are made using
1:1160146:      * result set update methods.
1:1160146:      * @exception SQLException causes test to fail with error
1:1160146:      * @exception IOException causes test to fail with error
1:1160146:      */
1:1160146:     public void testUpdateBlobFromScrollableResultSetWithProjectUsingResultSetMethods()
1:1160146:         throws SQLException, IOException
1:1160146:     {
1:1160146:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1160146:                                 ResultSet.CONCUR_UPDATABLE);
1:1160146:         final ResultSet rs = 
1:1160146:             stmt.executeQuery("SELECT data,val,length from " + 
1:1160146:                               BLOBDataModelSetup.getBlobTableName());
1:1160146:         println("Last");
1:1160146:         rs.last();
1:1160146:         
1:1160146:         final int newVal = rs.getInt(2) + 11;
1:1160146:         final int newSize = rs.getInt(3) / 2;
1:1160146:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:1160146:         
1:1160146:         println("Verify updated blob using result set");
1:1160146:         verifyBlob(newVal, newSize, rs.getBlob(1));
1:1160146:         
1:fc02124:         rs.close();
1:4292752:         stmt.close();
1:fc02124:     }
1:fc02124: 
1:1160146:     /**
1:1160146:      * Tests updating a Blob from a forward only resultset, produced by 
1:1160146:      * a select query with projection. Updates are made using
1:1160146:      * result set update methods.
1:1160146:      * @exception SQLException causes test to fail with error
1:1160146:      * @exception IOException causes test to fail with error
1:1160146:      */
1:1160146:     public void testUpdateBlobFromForwardOnlyResultSetWithProjectUsingResultSetMethods()
1:1160146:         throws SQLException, IOException
1:1160146:     {
1:1160146:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:1160146:                                 ResultSet.CONCUR_UPDATABLE);
1:1160146:         final ResultSet rs = 
1:1160146:             stmt.executeQuery("SELECT data,val,length from " + 
1:1160146:                               BLOBDataModelSetup.getBlobTableName());
1:1160146:         
1:1160146:         while (rs.next()) {
1:1160146:             println("Next");
1:1160146:             final int val = rs.getInt("VAL");
1:1160146:             if (val == BLOBDataModelSetup.bigVal) break;
1:1160146:         }
1:1160146:         
1:1160146:         final int newVal = rs.getInt("VAL") + 11;
1:1160146:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:1160146:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:1160146:         
1:1160146:         rs.close();
1:4292752:         stmt.close();
1:1160146:     }
1:1160146: 
1:1160146:     /**
1:1160146:      * Tests updating a Blob from a scollable resultset, produced by 
1:1160146:      * a select query with projection. Updates are made using
1:1160146:      * positioned updates
1:1160146:      * @exception SQLException causes test to fail with error
1:1160146:      * @exception IOException causes test to fail with error
1:1160146:      */
1:1160146:     public void testUpdateBlobFromScrollableResultSetWithProjectUsingPositionedUpdates()
1:1160146:         throws SQLException, IOException
1:1160146:     {
1:1160146:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:1160146:                                 ResultSet.CONCUR_UPDATABLE);
1:1160146:         final ResultSet rs = 
1:1160146:             stmt.executeQuery("SELECT data from " + 
1:1160146:                               BLOBDataModelSetup.getBlobTableName() + 
1:1160146:                               " WHERE val= " + BLOBDataModelSetup.bigVal);
1:1160146:         println("Last");
1:1160146:         rs.last();
1:1160146:         
1:1160146:         final int newVal = BLOBDataModelSetup.bigVal * 2;
1:1160146:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:1160146:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:1160146: 
1:1160146:         rs.relative(0); // Necessary after a positioned update
1:1160146:         
1:1160146:         println("Verify updated blob using result set");
1:1160146:         verifyBlob(newVal, newSize, rs.getBlob("DATA"));
1:1160146:         
1:1160146:         rs.close();
1:4292752:         stmt.close();
1:1160146:     }
1:1160146: 
1:1160146:     /**
1:1160146:      * Tests updating a Blob from a forward only resultset, produced by 
1:1160146:      * a select query with projection. Updates are made using
1:1160146:      * positioned updates.
1:1160146:      * @exception SQLException causes test to fail with error
1:1160146:      * @exception IOException causes test to fail with error
1:1160146:      */
1:1160146:     public void testUpdateBlobFromForwardOnlyResultSetWithProjectUsingPositionedUpdates()
1:1160146:         throws SQLException, IOException
1:1160146:     {
1:1160146:         final Statement stmt = 
1:07fb05a:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:1160146:                                 ResultSet.CONCUR_UPDATABLE);
1:1160146:         final ResultSet rs = 
1:1160146:             stmt.executeQuery("SELECT data from " + 
1:1160146:                               BLOBDataModelSetup.getBlobTableName() + 
1:1160146:                               " WHERE val = " + BLOBDataModelSetup.bigVal);
1:1160146:         rs.next();
1:1160146:         
1:1160146:         final int newVal =  BLOBDataModelSetup.bigVal * 2;
1:1160146:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:1160146:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:1160146:         
1:1160146:         rs.close();
1:b548a53:         stmt.close();
1:1160146:     }
1:1160146:     
1:fc02124:     
1:fc02124:     /**
1:fc02124:      * Tests updating the Blob using result set update methods.
1:fc02124:      * @param rs result set, currently positioned on row to be updated
1:fc02124:      * @param newVal new value in val column and blob data
1:fc02124:      * @param newSize new size of Blob
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     private void testUpdateBlobWithResultSetMethods(final ResultSet rs,
1:fc02124:                                                     final int newVal,
1:fc02124:                                                     final int newSize) 
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:1160146:         int val = rs.getInt("VAL");
1:1160146:         int size = rs.getInt("LENGTH");
1:fc02124:         println("VerifyBlob");
1:1160146:         verifyBlob(val, size, rs.getBlob("DATA"));
1:fc02124:         
1:fc02124:         println("UpdateBlob");
1:fc02124:         final TestInputStream newStream = new TestInputStream(newSize, newVal);
1:fc02124:         
1:1160146:         rs.updateInt("VAL", newVal);
1:1160146:         rs.updateInt("LENGTH", newSize);
1:1160146:         rs.updateBinaryStream("DATA", newStream, newSize);
1:fc02124:         rs.updateRow();
1:fc02124:         
1:fc02124:         println("Verify updated blob with another query");
1:fc02124:         verifyNewValueInTable(newVal, newSize);
1:fc02124:     }
1:fc02124: 
1:e093928:     /**
1:fc02124:      * Tests updating the Blob using positioned updates
1:fc02124:      * @param rs result set, currently positioned on row to be updated
1:fc02124:      * @param newVal new value in val column and blob data
1:fc02124:      * @param newSize new size of Blob
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     private void testUpdateBlobWithPositionedUpdate(final ResultSet rs,
1:fc02124:                                                     final int newVal,
1:fc02124:                                                     final int newSize) 
1:fc02124:         throws SQLException, IOException
1:fc02124:     {
1:b878080:         final PreparedStatement preparedStatement = prepareStatement
1:fc02124:             ("UPDATE " + BLOBDataModelSetup.getBlobTableName() +
1:fc02124:              " SET val=?, length = ?, data = ? WHERE CURRENT OF " +
1:fc02124:              rs.getCursorName());
1:fc02124:         
1:fc02124:         println("UpdateBlob");
1:fc02124:         
1:fc02124:         final TestInputStream newStream = new TestInputStream(newSize, newVal);
1:fc02124:         
1:fc02124:         preparedStatement.setInt(1, newVal);
1:fc02124:         preparedStatement.setInt(2, newSize);
1:fc02124:         preparedStatement.setBinaryStream(3, newStream, newSize);
1:fc02124:         preparedStatement.executeUpdate();
1:fc02124:         
1:fc02124:         println("Verify updated blob with another query");
1:fc02124:         verifyNewValueInTable(newVal, newSize);
1:fc02124:     }
1:fc02124:     
1:fc02124:     /**
1:e093928:      * Tests that a stream value in a values clause can be cast to a BLOB.
1:e093928:      * <p>
1:e093928:      * See DERBY-4102 (test case resulted in a ClassCastException earlier).
1:e093928:      *
1:e093928:      * @throws IOException if something goes wrong
1:e093928:      * @throws SQLException if something goes wrong
1:e093928:      */
1:e093928:     public void testBlobCastInValuesClause()
1:e093928:             throws IOException, SQLException {
1:e093928:         // The length must be at least 32 KB.
1:e093928:         final int length = 38*1024;
1:e093928:         PreparedStatement ps = prepareStatement("values cast(? as blob)");
1:e093928:         ps.setBinaryStream(1, new LoopingAlphabetStream(length), length);
1:e093928:         ResultSet rs = ps.executeQuery();
1:e093928:         assertTrue(rs.next());
1:e093928:         Blob b = rs.getBlob(1);
1:e093928:         assertEquals(length, b.length());
1:e093928:         // Select some parts of the Blob, moving backwards.
1:e093928:         assertEquals(100, b.getBytes(32*1024-27, 100).length);
1:e093928:         assertEquals(1029, b.getBytes(19*1024, 1029).length);
1:e093928:         // Compare a fresh stream with the one from the Blob.
1:e093928:         assertEquals(new LoopingAlphabetStream(length), b.getBinaryStream());
1:e093928:         assertEquals(-1, b.position(new byte[] {(byte)'a', (byte)'A'}, 1));
1:e093928:         assertEquals(length, b.length());
1:e093928:         assertFalse(rs.next());
1:e093928:         rs.close();
1:e093928:     }
1:8f01b3c: 
1:e093928: 
1:fc02124:     /**
1:1d0c809:      * Tests that a lob can be safely occur multiple times in a SQL select.
1:1d0c809:      * <p/>
1:1d0c809:      * See DERBY-4477.
1:55bc97f:      * <p/>
1:55bc97f:      * @see org.apache.derbyTesting.functionTests.tests.memory.BlobMemTest#testDerby4477_3645_3646_Repro_lowmem
1:55bc97f:      * @see org.apache.derbyTesting.functionTests.tests.memory.ClobMemTest#testDerby4477_3645_3646_Repro_lowmem_clob
1:1d0c809:      */
1:1d0c809:     public void testDerby4477_3645_3646_Repro() throws SQLException, IOException {
1:1d0c809:         setAutoCommit(false);
1:1d0c809:         Statement s = createStatement();
1:1d0c809: 
1:1d0c809:         s.executeUpdate(
1:1d0c809:             "CREATE TABLE T_MAIN(" +
1:1d0c809:             "ID INT  GENERATED ALWAYS AS IDENTITY PRIMARY KEY, " +
1:1d0c809:             "V BLOB(590473235) )");
1:1d0c809: 
1:1d0c809:         PreparedStatement ps = prepareStatement(
1:1d0c809:             "INSERT INTO T_MAIN(V) VALUES (?)");
1:1d0c809: 
1:1d0c809:         byte[] bytes = new byte[35000];
1:1d0c809: 
1:1d0c809:         for (int i = 0; i < 35000; i++) {
1:1d0c809:             bytes[i] = (byte)i;
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         ps.setBytes(1, bytes);
1:1d0c809:         ps.executeUpdate();
1:1d0c809:         ps.close();
1:1d0c809: 
1:1d0c809:         s.executeUpdate("CREATE TABLE T_COPY ( V1 BLOB(2M), V2 BLOB(2M))");
1:1d0c809: 
1:1d0c809:         // This failed in the repro for DERBY-3645 solved as part of
1:1d0c809:         // DERBY-4477:
1:1d0c809:         s.executeUpdate("INSERT INTO T_COPY SELECT  V, V FROM T_MAIN");
1:1d0c809: 
1:1d0c809:         // Check that the two results are identical:
1:1d0c809:         ResultSet rs = s.executeQuery("SELECT * FROM T_COPY");
1:1d0c809:         rs.next();
1:1d0c809:         String v1 = rs.getString(1);
1:1d0c809:         String v2 = rs.getString(2);
1:1d0c809:         assertEquals(v1.length(), v2.length());
1:1d0c809: 
1:1d0c809:         for (int i=0; i < v1.length(); i++) {
1:1d0c809:             assertEquals(v1.charAt(i), v2.charAt(i));
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         // Verify against a single select too (both above could be wrong..)
1:1d0c809:         rs = s.executeQuery("SELECT V from T_MAIN");
1:1d0c809:         rs.next();
1:1d0c809:         String v3 = rs.getString(1);
1:1d0c809:         assertEquals(v1.length(), v3.length());
1:1d0c809: 
1:1d0c809:         for (int i=0; i < v1.length(); i++) {
1:1d0c809:             assertEquals(v1.charAt(i), v3.charAt(i));
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         // This failed in the repro for DERBY-3646 solved as part of
1:1d0c809:         // DERBY-4477 (repro slightly rewoked here):
1:1d0c809:         rs = s.executeQuery("SELECT 'I', V, ID, V from T_MAIN");
1:1d0c809:         rs.next();
1:1d0c809: 
1:1d0c809:         InputStream s1 = rs.getBinaryStream(2);
1:1d0c809: 
1:1d0c809:         // JDBC says that the next getBinaryStream will close the s1 stream so
1:1d0c809:         // verify it now. Cf. DERBY-4521.
1:1d0c809: 
1:1d0c809:         for (int i = 0; i < 35000; i++) {
1:1d0c809:             assertEquals((byte)i, (byte)s1.read());
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         assertEquals(-1, s1.read());
1:1d0c809:         s1.close();
1:1d0c809: 
1:1d0c809:         InputStream s2 = rs.getBinaryStream(4);
1:1d0c809: 
1:1d0c809:         for (int i = 0; i < 35000; i++) {
1:1d0c809:             assertEquals((byte)i, (byte)s2.read());
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         assertEquals(-1, s2.read());
1:1d0c809:         s2.close();
1:1d0c809: 
1:1d0c809:         rs.close();
1:1d0c809: 
1:1d0c809:         rollback();
1:1d0c809:     }
1:1d0c809: 
1:1d0c809: 
1:1d0c809:     /**
1:1d0c809:      * Tests that a lob can be safely occur multiple times in a SQL select in
1:1d0c809:      * a trigger context.
1:1d0c809:      * <p/>
1:1d0c809:      * See DERBY-4477.
1:1d0c809:      */
1:1d0c809:     public void testDerby4477_2349_Repro() throws SQLException, IOException {
1:1d0c809: 
1:1d0c809:         setAutoCommit(false);
1:1d0c809: 
1:1d0c809:         Statement s = createStatement();
1:1d0c809: 
1:1d0c809:         s.executeUpdate("CREATE TABLE T_MAIN(" +
1:1d0c809:                 "ID INT  GENERATED ALWAYS AS IDENTITY PRIMARY KEY, " +
1:1d0c809:                 "V BLOB(590473235) )");
1:1d0c809:         s.executeUpdate("CREATE TABLE T_ACTION_ROW(ID INT, A CHAR(1), " +
1:1d0c809:                 "V1 BLOB(590473235), V2 BLOB(590473235) )");
1:1d0c809:         s.executeUpdate("CREATE TABLE T_ACTION_STATEMENT(ID INT, A CHAR(1), " +
1:1d0c809:                 "V1 BLOB(590473235), V2 BLOB(590473235) )");
1:1d0c809: 
1:1d0c809:         // ON INSERT copy the typed value V into the action table.
1:1d0c809:         // Use V twice to ensure there are no issues with values
1:1d0c809:         // that can be streamed.
1:1d0c809:         // Two identical actions,  per row and per statement.
1:1d0c809:         s.executeUpdate(
1:1d0c809:             "CREATE TRIGGER AIR AFTER INSERT ON T_MAIN " +
1:1d0c809:             "    REFERENCING NEW AS N FOR EACH ROW " +
1:1d0c809:             "    INSERT INTO T_ACTION_ROW(A, V1, ID, V2) " +
1:1d0c809:             "        VALUES ('I', N.V, N.ID, N.V)");
1:1d0c809: 
1:1d0c809:         s.executeUpdate(
1:1d0c809:             "CREATE TRIGGER AIS AFTER INSERT ON T_MAIN " +
1:1d0c809:             "    REFERENCING NEW_TABLE AS N FOR EACH STATEMENT " +
1:1d0c809:             "    INSERT INTO T_ACTION_STATEMENT(A, V1, ID, V2) " +
1:1d0c809:             "        SELECT 'I', V, ID, V FROM N");
1:1d0c809: 
1:1d0c809:         s.executeUpdate("INSERT INTO T_MAIN(V) VALUES NULL");
1:1d0c809: 
1:1d0c809:         s.close();
1:1d0c809:         actionTypesCompareMainToAction(1);
1:1d0c809: 
1:1d0c809:         int jdbcType = Types.BLOB;
1:1d0c809:         int precision = 590473235;
1:1d0c809: 
1:1d0c809:         Random r = new Random();
1:1d0c809: 
1:1d0c809:         String ins1 = "INSERT INTO T_MAIN(V) VALUES (?)";
1:1d0c809:         String ins3 = "INSERT INTO T_MAIN(V) VALUES (?), (?), (?)";
1:1d0c809: 
1:1d0c809:         PreparedStatement ps;
1:1d0c809:         ps = prepareStatement(ins1);
1:1d0c809:         setRandomValue(r, ps, 1, jdbcType, precision);
1:1d0c809:         ps.executeUpdate();
1:1d0c809:         ps.close();
1:1d0c809: 
1:1d0c809:         actionTypesCompareMainToAction(2);
1:1d0c809: 
1:1d0c809:         ps = prepareStatement(ins3);
1:1d0c809:         setRandomValue(r, ps, 1, jdbcType, precision);
1:1d0c809:         setRandomValue(r, ps, 2, jdbcType, precision);
1:1d0c809:         setRandomValue(r, ps, 3, jdbcType, precision);
1:1d0c809:         ps.executeUpdate();
1:1d0c809:         ps.close();
1:1d0c809: 
1:1d0c809:         actionTypesCompareMainToAction(5);
1:1d0c809: 
1:1d0c809:         rollback();
1:1d0c809:     }
1:1d0c809: 
1:ec6fcf1:     /**
1:8f01b3c:      * Checks that Derby fails with an exception when a transaction using
1:8f01b3c:      * READ_UNCOMMITTED obtains a stream from a BLOB (reads one byte) and at
1:8f01b3c:      * the same time another connection deletes the BLOB.
1:8f01b3c:      * <p>
1:8f01b3c:      * Earlier only parts of the BLOB was returned, without errors. It was
1:8f01b3c:      * impossible to tell for the user that only parts of the value was
1:8f01b3c:      * retrieved.
1:8f01b3c:      * <p>
1:8f01b3c:      * See DERBY-2992.
1:8f01b3c:      */
1:8f01b3c:     public void testDerby2992_Repro()
1:8f01b3c:             throws IOException, SQLException {
1:8f01b3c:         // Autocommit doesn't seem to be enabled here in all cases.
1:8f01b3c:         setAutoCommit(true);
1:ec6fcf1: 
1:8f01b3c:         final String TBL = "D2992BLOB";
1:8f01b3c:         // Switch to READ UNCOMMITTED.
1:8f01b3c:         getConnection().setTransactionIsolation(
1:8f01b3c:                 Connection.TRANSACTION_READ_UNCOMMITTED);
1:8f01b3c:         Statement stmt = createStatement();
1:8f01b3c:         dropTable(TBL);
1:8f01b3c:         stmt.executeUpdate("create table " + TBL + " (b blob)");
1:8f01b3c:         stmt.close();
1:8f01b3c: 
1:8f01b3c:         PreparedStatement ps = prepareStatement("insert into " + TBL +
1:8f01b3c:                 " values (?)");
1:8f01b3c:         int length = 65*1024*1024; // 65K
1:8f01b3c:         ps.setBinaryStream(1, new LoopingAlphabetStream(length), length);
1:8f01b3c:         ps.executeUpdate();
1:8f01b3c:         ps.close();
1:8f01b3c: 
1:8f01b3c:         stmt = createStatement();
1:8f01b3c:         ResultSet rs = stmt.executeQuery("select B from " + TBL);
1:8f01b3c:         assertTrue(rs.next());
1:8f01b3c: 
1:8f01b3c:         // Read one byte, keep the stream / rs open.
1:8f01b3c:         InputStream is = rs.getBinaryStream(1);
1:8f01b3c:         int i = is.read();
1:8f01b3c:         assertTrue(i != -1);
1:8f01b3c: 
1:8f01b3c:         // Open a second connection and delete the BLOB.
1:8f01b3c:         Connection secondCon = openUserConnection("APP");
1:8f01b3c:         Statement secondStmt = secondCon.createStatement();
1:8f01b3c:         assertEquals(1, secondStmt.executeUpdate("delete from " + TBL));
1:8f01b3c:         secondCon.close();
1:8f01b3c: 
1:8f01b3c:         // Continue reading the BLOB through the stream.
1:8f01b3c:         // The stream has now probably read one page of data, and as we progress
1:8f01b3c:         // it will have to fetch the next page. However, the next page has been
1:8f01b3c:         // deleted.
1:8f01b3c:         byte[] buf = new byte[4096];
1:8f01b3c:         try {
1:8f01b3c:             // Drain the stream.
1:8f01b3c:             while (is.read(buf) != -1) { }
1:8f01b3c:             // Expect the read call above to fail at some point.
1:8f01b3c:             fail("The read should have failed, value has been deleted");
1:8f01b3c:         } catch (EOFException eofe) {
1:8f01b3c:             // As we expected, everything's fine.
1:8f01b3c:         }
1:8f01b3c:     }
1:8f01b3c: 
1:1d0c809:     public static void setRandomValue(
1:1d0c809:         Random r,
1:1d0c809:         PreparedStatement ps,
1:1d0c809:         int column,
1:1d0c809:         int jdbcType,
1:1d0c809:         int precision) throws SQLException, IOException {
1:1d0c809: 
1:1d0c809:         Object val = getRandomValue(r, jdbcType, precision);
1:1d0c809: 
1:1d0c809:         if (val instanceof StringReaderWithLength) {
1:1d0c809:             StringReaderWithLength rd = (StringReaderWithLength) val;
1:1d0c809:             ps.setCharacterStream(column, rd, rd.getLength());
1:1d0c809:         } else if (val instanceof InputStream) {
1:1d0c809:             InputStream in = (InputStream) val;
1:1d0c809:             ps.setBinaryStream(column, in, in.available());
1:1d0c809:         } else {
1:1d0c809:             ps.setObject(column, val, jdbcType);
1:1d0c809:         }
1:1d0c809:     }
1:1d0c809: 
1:1d0c809:     public static Object getRandomValue(
1:1d0c809:         Random r,
1:1d0c809:         int jdbcType,
1:1d0c809:         int precision) throws IOException {
1:1d0c809: 
1:1d0c809:         switch (jdbcType) {
1:1d0c809:         case Types.BLOB:
1:1d0c809:             if (precision > 256*1024)
1:1d0c809:                 precision = 256*1024;
1:1d0c809:             return new ReadOnceByteArrayInputStream(
1:1d0c809:                     randomBinary(r, r.nextInt(precision)));
1:1d0c809:         }
1:1d0c809: 
1:1d0c809:         fail("unexpected JDBC Type " + jdbcType);
1:1d0c809:         return null;
1:1d0c809:     }
1:1d0c809: 
1:1d0c809:     private static byte[] randomBinary(Random r, int len) {
1:1d0c809:         byte[] bb = new byte[len];
1:1d0c809:         for (int i = 0; i < bb.length; i++)
1:1d0c809:             bb[i] = (byte) r.nextInt();
1:1d0c809:         return bb;
1:1d0c809:      }
1:1d0c809: 
1:1d0c809:     private void actionTypesCompareMainToAction(
1:1d0c809:         int actionCount) throws SQLException, IOException {
1:1d0c809: 
1:1d0c809:         Statement s1 = createStatement();
1:1d0c809:         Statement s2 = createStatement();
1:1d0c809: 
1:1d0c809:         String sqlMain =
1:1d0c809:             "SELECT ID, V, V FROM T_MAIN ORDER BY 1";
1:1d0c809:         String sqlActionRow =
1:1d0c809:             "SELECT ID, V1, V2 FROM T_ACTION_ROW ORDER BY 1";
1:1d0c809:         String sqlActionStatement =
1:1d0c809:             "SELECT ID, V1, V2 FROM T_ACTION_STATEMENT ORDER BY 1";
1:1d0c809: 
1:1d0c809:         ResultSet rsMain = s1.executeQuery(sqlMain);
1:1d0c809:         ResultSet rsAction = s2.executeQuery(sqlActionRow);
1:1d0c809:         JDBC.assertSameContents(rsMain, rsAction);
1:1d0c809: 
1:1d0c809:         rsMain = s1.executeQuery(sqlMain);
1:1d0c809:         rsAction = s2.executeQuery(sqlActionStatement);
1:1d0c809:         JDBC.assertSameContents(rsMain, rsAction);
1:1d0c809: 
1:1d0c809: 
1:1d0c809:         assertTableRowCount("T_ACTION_ROW", actionCount);
1:1d0c809:         assertTableRowCount("T_ACTION_STATEMENT", actionCount);
1:1d0c809: 
1:1d0c809:         s1.close();
1:1d0c809:         s2.close();
1:1d0c809:     }
1:1d0c809: 
1:fc02124:     /**
1:ec6fcf1:      * Regression test case for DERBY-1511. Scans of tables with large objects
1:ec6fcf1:      * used to fail if commits were issued during the scans.
1:ec6fcf1:      */
1:ec6fcf1:     public void testDerby1511() throws Exception {
1:ec6fcf1:         setAutoCommit(false);
1:1d0c809: 
1:ec6fcf1:         Statement s = createStatement();
1:ec6fcf1:         s.executeUpdate("create table derby1511(b blob)");
1:ec6fcf1: 
1:ec6fcf1:         PreparedStatement insert = prepareStatement(
1:ec6fcf1:                 "insert into derby1511(b) values (?)");
1:ec6fcf1: 
1:ec6fcf1:         int rows = 20;
1:ec6fcf1:         int length = 40000; // LOB size should be > 32 KB to expose the bug
1:ec6fcf1:                             // (otherwise, materialization happens and a
1:ec6fcf1:                             // different code path is taken)
1:ec6fcf1: 
1:ec6fcf1:         for (int i = 0; i < rows; i++) {
1:ec6fcf1:             insert.setBinaryStream(
1:ec6fcf1:                     1, new LoopingAlphabetStream(length), length);
1:ec6fcf1:             insert.executeUpdate();
1:ec6fcf1:         }
1:ec6fcf1: 
1:ec6fcf1:         commit();
1:ec6fcf1: 
1:ec6fcf1:         ResultSet rs = s.executeQuery("select b from derby1511");
1:ec6fcf1:         for (int i = 0; i < rows; i++) {
1:ec6fcf1:             assertTrue("Too few rows", rs.next());
1:ec6fcf1:             // Second time this was called we used to get an error saying
1:ec6fcf1:             // container has been closed.
1:ec6fcf1:             assertEquals(new LoopingAlphabetStream(length),
1:ec6fcf1:                          rs.getBinaryStream(1));
1:ec6fcf1:             commit();
1:ec6fcf1:         }
1:ec6fcf1: 
1:ec6fcf1:         assertFalse("Too many rows", rs.next());
1:ec6fcf1:         rs.close();
1:ec6fcf1:     }
1:fc02124: 
1:fc02124:     /**
1:fc02124:      * Verifies that the table has row with column val=newVal
1:fc02124:      * and that it its data and size columns are consistent.
1:fc02124:      * @param newVal value expected to be found in the val column of a row
1:fc02124:      * @param newSize expected size of size column and size of blob
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:fc02124:     private void verifyNewValueInTable(final int newVal,
1:fc02124:                                        final int newSize)
1:fc02124:         throws IOException, SQLException
1:fc02124:     {
1:fc02124:         println("Verify new value in table: " + newVal);
1:1d0c809: 
1:1d0c809:         final Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:fc02124:                                                    ResultSet.CONCUR_READ_ONLY);
1:1d0c809: 
1:1d0c809:         final ResultSet rs =
1:1d0c809:             stmt.executeQuery("SELECT * FROM " +
1:fc02124:                               BLOBDataModelSetup.getBlobTableName() +
1:fc02124:                               " WHERE val = " + newVal);
1:1d0c809: 
1:fc02124:         println("Query executed, calling next");
1:1d0c809: 
1:fc02124:         boolean foundVal = false;
1:1d0c809: 
1:fc02124:         while (rs.next()) {
1:fc02124:             println("Next called, verifying row");
1:1d0c809: 
1:1d0c809:             assertEquals("Unexpected value in val column",
1:fc02124:                          newVal, rs.getInt(1));
1:1d0c809: 
1:fc02124:             verifyBlob(newVal, newSize, rs.getBlob(3));
1:fc02124:             foundVal = true;
1:fc02124:         }
1:fc02124:         assertTrue("No column with value= " + newVal + " found ", foundVal);
1:1d0c809: 
1:4292752:         rs.close();
1:4292752:         stmt.close();
1:fc02124:     }
1:1d0c809: 
1:1d0c809: 
1:fc02124:     /**
1:fc02124:      * Verifies that the blob is consistent
1:fc02124:      * @param expectedVal the InputStream for the Blob should return this value
1:fc02124:      *                    for every byte
1:df4020d:      * @param expectedSize the BLOB should have this size
1:df4020d:      * @param blob the BLOB to check
1:fc02124:      * @exception SQLException causes test to fail with error
1:fc02124:      * @exception IOException causes test to fail with error
1:fc02124:      */
1:1d0c809:     private void verifyBlob(final int expectedVal,
1:1d0c809:                             final int expectedSize,
1:1d0c809:                             final Blob blob)
1:fc02124:         throws IOException, SQLException
1:fc02124:     {
1:fc02124:         final InputStream stream = blob.getBinaryStream();
1:fc02124:         int blobSize = 0;
1:fc02124:         for (int val = stream.read(); val!=-1; val = stream.read()) {
1:fc02124:             blobSize++;
1:1d0c809: 
1:fc02124:             // avoid doing a string-concat for every byte in blob
1:fc02124:             if (expectedVal!=val) {
1:1d0c809:                 assertEquals("Unexpected value in stream at position " +
1:fc02124:                              blobSize,
1:fc02124:                              expectedVal, val);
1:fc02124:             }
1:fc02124:         }
1:fc02124:         stream.close();
1:fc02124:         assertEquals("Unexpected size of stream ", expectedSize, blobSize);
1:fc02124:     }
1:fc02124: 
1:fc02124:     /**
1:fc02124:      * The suite decorates the tests of this class with 
1:fc02124:      * a setup which creates and populates the data model.
1:fc02124:      */
1:fc02124:     public static Test suite() 
1:fc02124:     {
1:1ae02c9:         BaseTestSuite mainSuite =
1:1ae02c9:             new BaseTestSuite(BLOBTest.class, "BLOBTest");
1:fc02124:         return new BLOBDataModelSetup(mainSuite);
1:fc02124:     }
1:fc02124: 
1:fc02124:     /**
1:fc02124:      * The setup creates a Connection to the database.
1:fc02124:      * @exception Exception any exception will cause test to fail with error.
1:fc02124:      */
1:fc02124:     public final void setUp() 
2:fc02124:         throws Exception
1:fc02124:     {
1:03a99e2:         getConnection().setAutoCommit(false);
1:fc02124:     }
1:fc02124: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite =
1:             new BaseTestSuite(BLOBTest.class, "BLOBTest");
commit:55bc97f
/////////////////////////////////////////////////////////////////////////
1:      * <p/>
1:      * @see org.apache.derbyTesting.functionTests.tests.memory.BlobMemTest#testDerby4477_3645_3646_Repro_lowmem
1:      * @see org.apache.derbyTesting.functionTests.tests.memory.ClobMemTest#testDerby4477_3645_3646_Repro_lowmem_clob
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.functionTests.util.streams.ReadOnceByteArrayInputStream;
1: import org.apache.derbyTesting.functionTests.util.streams.StringReaderWithLength;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import java.util.Random;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tests that a lob can be safely occur multiple times in a SQL select.
1:      * <p/>
1:      * See DERBY-4477.
1:      */
1:     public void testDerby4477_3645_3646_Repro() throws SQLException, IOException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate(
1:             "CREATE TABLE T_MAIN(" +
1:             "ID INT  GENERATED ALWAYS AS IDENTITY PRIMARY KEY, " +
1:             "V BLOB(590473235) )");
1: 
1:         PreparedStatement ps = prepareStatement(
1:             "INSERT INTO T_MAIN(V) VALUES (?)");
1: 
1:         byte[] bytes = new byte[35000];
1: 
1:         for (int i = 0; i < 35000; i++) {
1:             bytes[i] = (byte)i;
1:         }
1: 
1:         ps.setBytes(1, bytes);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         s.executeUpdate("CREATE TABLE T_COPY ( V1 BLOB(2M), V2 BLOB(2M))");
1: 
1:         // This failed in the repro for DERBY-3645 solved as part of
1:         // DERBY-4477:
1:         s.executeUpdate("INSERT INTO T_COPY SELECT  V, V FROM T_MAIN");
1: 
1:         // Check that the two results are identical:
1:         ResultSet rs = s.executeQuery("SELECT * FROM T_COPY");
1:         rs.next();
1:         String v1 = rs.getString(1);
1:         String v2 = rs.getString(2);
1:         assertEquals(v1.length(), v2.length());
1: 
1:         for (int i=0; i < v1.length(); i++) {
1:             assertEquals(v1.charAt(i), v2.charAt(i));
1:         }
1: 
1:         // Verify against a single select too (both above could be wrong..)
1:         rs = s.executeQuery("SELECT V from T_MAIN");
1:         rs.next();
1:         String v3 = rs.getString(1);
1:         assertEquals(v1.length(), v3.length());
1: 
1:         for (int i=0; i < v1.length(); i++) {
1:             assertEquals(v1.charAt(i), v3.charAt(i));
1:         }
1: 
1:         // This failed in the repro for DERBY-3646 solved as part of
1:         // DERBY-4477 (repro slightly rewoked here):
1:         rs = s.executeQuery("SELECT 'I', V, ID, V from T_MAIN");
1:         rs.next();
1: 
1:         InputStream s1 = rs.getBinaryStream(2);
1: 
1:         // JDBC says that the next getBinaryStream will close the s1 stream so
1:         // verify it now. Cf. DERBY-4521.
1: 
1:         for (int i = 0; i < 35000; i++) {
1:             assertEquals((byte)i, (byte)s1.read());
1:         }
1: 
1:         assertEquals(-1, s1.read());
1:         s1.close();
1: 
1:         InputStream s2 = rs.getBinaryStream(4);
1: 
1:         for (int i = 0; i < 35000; i++) {
1:             assertEquals((byte)i, (byte)s2.read());
1:         }
1: 
1:         assertEquals(-1, s2.read());
1:         s2.close();
1: 
1:         rs.close();
1: 
1:         rollback();
1:     }
1: 
1: 
1:     /**
1:      * Tests that a lob can be safely occur multiple times in a SQL select in
1:      * a trigger context.
1:      * <p/>
1:      * See DERBY-4477.
1:      */
1:     public void testDerby4477_2349_Repro() throws SQLException, IOException {
1: 
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate("CREATE TABLE T_MAIN(" +
1:                 "ID INT  GENERATED ALWAYS AS IDENTITY PRIMARY KEY, " +
1:                 "V BLOB(590473235) )");
1:         s.executeUpdate("CREATE TABLE T_ACTION_ROW(ID INT, A CHAR(1), " +
1:                 "V1 BLOB(590473235), V2 BLOB(590473235) )");
1:         s.executeUpdate("CREATE TABLE T_ACTION_STATEMENT(ID INT, A CHAR(1), " +
1:                 "V1 BLOB(590473235), V2 BLOB(590473235) )");
1: 
1:         // ON INSERT copy the typed value V into the action table.
1:         // Use V twice to ensure there are no issues with values
1:         // that can be streamed.
1:         // Two identical actions,  per row and per statement.
1:         s.executeUpdate(
1:             "CREATE TRIGGER AIR AFTER INSERT ON T_MAIN " +
1:             "    REFERENCING NEW AS N FOR EACH ROW " +
1:             "    INSERT INTO T_ACTION_ROW(A, V1, ID, V2) " +
1:             "        VALUES ('I', N.V, N.ID, N.V)");
1: 
1:         s.executeUpdate(
1:             "CREATE TRIGGER AIS AFTER INSERT ON T_MAIN " +
1:             "    REFERENCING NEW_TABLE AS N FOR EACH STATEMENT " +
1:             "    INSERT INTO T_ACTION_STATEMENT(A, V1, ID, V2) " +
1:             "        SELECT 'I', V, ID, V FROM N");
1: 
1:         s.executeUpdate("INSERT INTO T_MAIN(V) VALUES NULL");
1: 
1:         s.close();
1:         actionTypesCompareMainToAction(1);
1: 
1:         int jdbcType = Types.BLOB;
1:         int precision = 590473235;
1: 
1:         Random r = new Random();
1: 
1:         String ins1 = "INSERT INTO T_MAIN(V) VALUES (?)";
1:         String ins3 = "INSERT INTO T_MAIN(V) VALUES (?), (?), (?)";
1: 
1:         PreparedStatement ps;
1:         ps = prepareStatement(ins1);
1:         setRandomValue(r, ps, 1, jdbcType, precision);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         actionTypesCompareMainToAction(2);
1: 
1:         ps = prepareStatement(ins3);
1:         setRandomValue(r, ps, 1, jdbcType, precision);
1:         setRandomValue(r, ps, 2, jdbcType, precision);
1:         setRandomValue(r, ps, 3, jdbcType, precision);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         actionTypesCompareMainToAction(5);
1: 
1:         rollback();
1:     }
1: 
1:     public static void setRandomValue(
1:         Random r,
1:         PreparedStatement ps,
1:         int column,
1:         int jdbcType,
1:         int precision) throws SQLException, IOException {
1: 
1:         Object val = getRandomValue(r, jdbcType, precision);
1: 
1:         if (val instanceof StringReaderWithLength) {
1:             StringReaderWithLength rd = (StringReaderWithLength) val;
1:             ps.setCharacterStream(column, rd, rd.getLength());
1:         } else if (val instanceof InputStream) {
1:             InputStream in = (InputStream) val;
1:             ps.setBinaryStream(column, in, in.available());
1:         } else {
1:             ps.setObject(column, val, jdbcType);
1:         }
1:     }
1: 
1:     public static Object getRandomValue(
1:         Random r,
1:         int jdbcType,
1:         int precision) throws IOException {
1: 
1:         switch (jdbcType) {
1:         case Types.BLOB:
1:             if (precision > 256*1024)
1:                 precision = 256*1024;
1:             return new ReadOnceByteArrayInputStream(
1:                     randomBinary(r, r.nextInt(precision)));
1:         }
1: 
1:         fail("unexpected JDBC Type " + jdbcType);
1:         return null;
1:     }
1: 
1:     private static byte[] randomBinary(Random r, int len) {
1:         byte[] bb = new byte[len];
1:         for (int i = 0; i < bb.length; i++)
1:             bb[i] = (byte) r.nextInt();
1:         return bb;
1:      }
1: 
1:     private void actionTypesCompareMainToAction(
1:         int actionCount) throws SQLException, IOException {
1: 
1:         Statement s1 = createStatement();
1:         Statement s2 = createStatement();
1: 
1:         String sqlMain =
1:             "SELECT ID, V, V FROM T_MAIN ORDER BY 1";
1:         String sqlActionRow =
1:             "SELECT ID, V1, V2 FROM T_ACTION_ROW ORDER BY 1";
1:         String sqlActionStatement =
1:             "SELECT ID, V1, V2 FROM T_ACTION_STATEMENT ORDER BY 1";
1: 
1:         ResultSet rsMain = s1.executeQuery(sqlMain);
1:         ResultSet rsAction = s2.executeQuery(sqlActionRow);
1:         JDBC.assertSameContents(rsMain, rsAction);
1: 
1:         rsMain = s1.executeQuery(sqlMain);
1:         rsAction = s2.executeQuery(sqlActionStatement);
1:         JDBC.assertSameContents(rsMain, rsAction);
1: 
1: 
1:         assertTableRowCount("T_ACTION_ROW", actionCount);
1:         assertTableRowCount("T_ACTION_STATEMENT", actionCount);
1: 
1:         s1.close();
1:         s2.close();
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         final Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1: 
1:         final ResultSet rs =
1:             stmt.executeQuery("SELECT * FROM " +
1: 
1: 
1: 
1: 
1:             assertEquals("Unexpected value in val column",
1: 
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void verifyBlob(final int expectedVal,
1:                             final int expectedSize,
1:                             final Blob blob)
1: 
1:                 assertEquals("Unexpected value in stream at position " +
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ec6fcf1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-1511. Scans of tables with large objects
1:      * used to fail if commits were issued during the scans.
1:      */
1:     public void testDerby1511() throws Exception {
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.executeUpdate("create table derby1511(b blob)");
1: 
1:         PreparedStatement insert = prepareStatement(
1:                 "insert into derby1511(b) values (?)");
1: 
1:         int rows = 20;
1:         int length = 40000; // LOB size should be > 32 KB to expose the bug
1:                             // (otherwise, materialization happens and a
1:                             // different code path is taken)
1: 
1:         for (int i = 0; i < rows; i++) {
1:             insert.setBinaryStream(
1:                     1, new LoopingAlphabetStream(length), length);
1:             insert.executeUpdate();
1:         }
1: 
1:         commit();
1: 
1:         ResultSet rs = s.executeQuery("select b from derby1511");
1:         for (int i = 0; i < rows; i++) {
1:             assertTrue("Too few rows", rs.next());
1:             // Second time this was called we used to get an error saying
1:             // container has been closed.
1:             assertEquals(new LoopingAlphabetStream(length),
1:                          rs.getBinaryStream(1));
1:             commit();
1:         }
1: 
1:         assertFalse("Too many rows", rs.next());
1:         rs.close();
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8f01b3c
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks that Derby fails with an exception when a transaction using
1:      * READ_UNCOMMITTED obtains a stream from a BLOB (reads one byte) and at
1:      * the same time another connection deletes the BLOB.
1:      * <p>
1:      * Earlier only parts of the BLOB was returned, without errors. It was
1:      * impossible to tell for the user that only parts of the value was
1:      * retrieved.
1:      * <p>
1:      * See DERBY-2992.
1:      */
1:     public void testDerby2992_Repro()
1:             throws IOException, SQLException {
1:         // Autocommit doesn't seem to be enabled here in all cases.
1:         setAutoCommit(true);
1: 
1:         final String TBL = "D2992BLOB";
1:         // Switch to READ UNCOMMITTED.
1:         getConnection().setTransactionIsolation(
1:                 Connection.TRANSACTION_READ_UNCOMMITTED);
1:         Statement stmt = createStatement();
1:         dropTable(TBL);
1:         stmt.executeUpdate("create table " + TBL + " (b blob)");
1:         stmt.close();
1: 
1:         PreparedStatement ps = prepareStatement("insert into " + TBL +
1:                 " values (?)");
1:         int length = 65*1024*1024; // 65K
1:         ps.setBinaryStream(1, new LoopingAlphabetStream(length), length);
1:         ps.executeUpdate();
1:         ps.close();
1: 
1:         stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery("select B from " + TBL);
1:         assertTrue(rs.next());
1: 
1:         // Read one byte, keep the stream / rs open.
1:         InputStream is = rs.getBinaryStream(1);
1:         int i = is.read();
1:         assertTrue(i != -1);
1: 
1:         // Open a second connection and delete the BLOB.
1:         Connection secondCon = openUserConnection("APP");
1:         Statement secondStmt = secondCon.createStatement();
1:         assertEquals(1, secondStmt.executeUpdate("delete from " + TBL));
1:         secondCon.close();
1: 
1:         // Continue reading the BLOB through the stream.
1:         // The stream has now probably read one page of data, and as we progress
1:         // it will have to fetch the next page. However, the next page has been
1:         // deleted.
1:         byte[] buf = new byte[4096];
1:         try {
1:             // Drain the stream.
1:             while (is.read(buf) != -1) { }
1:             // Expect the read call above to fail at some point.
1:             fail("The read should have failed, value has been deleted");
1:         } catch (EOFException eofe) {
1:             // As we expected, everything's fine.
1:         }
1:     }
1: 
commit:e093928
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tests that a stream value in a values clause can be cast to a BLOB.
1:      * <p>
1:      * See DERBY-4102 (test case resulted in a ClassCastException earlier).
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testBlobCastInValuesClause()
1:             throws IOException, SQLException {
1:         // The length must be at least 32 KB.
1:         final int length = 38*1024;
1:         PreparedStatement ps = prepareStatement("values cast(? as blob)");
1:         ps.setBinaryStream(1, new LoopingAlphabetStream(length), length);
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue(rs.next());
1:         Blob b = rs.getBlob(1);
1:         assertEquals(length, b.length());
1:         // Select some parts of the Blob, moving backwards.
1:         assertEquals(100, b.getBytes(32*1024-27, 100).length);
1:         assertEquals(1029, b.getBytes(19*1024, 1029).length);
1:         // Compare a fresh stream with the one from the Blob.
1:         assertEquals(new LoopingAlphabetStream(length), b.getBinaryStream());
1:         assertEquals(-1, b.position(new byte[] {(byte)'a', (byte)'A'}, 1));
1:         assertEquals(length, b.length());
1:         assertFalse(rs.next());
1:         rs.close();
1:     }
1: 
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b878080
/////////////////////////////////////////////////////////////////////////
1:         final PreparedStatement preparedStatement = prepareStatement
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite mainSuite = new TestSuite(BLOBTest.class, "BLOBTest");
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
0:         final PreparedStatement preparedStatement = getConnection().prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         getConnection().setAutoCommit(false);
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
commit:07fb05a
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:             createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
0:         final Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
commit:ffe3f66
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
0:             getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
0:         final PreparedStatement preparedStatement = getXConnection().prepareStatement
/////////////////////////////////////////////////////////////////////////
0:         final Statement stmt = getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
0:         getXConnection().setAutoCommit(false);
commit:4292752
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         
1:         rs.close();
1:         stmt.close();
commit:b548a53
/////////////////////////////////////////////////////////////////////////
1:         stmt.close();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      * @param expectedSize the BLOB should have this size
1:      * @param blob the BLOB to check
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:1160146
/////////////////////////////////////////////////////////////////////////
1:             final int val = rs.getInt(1);
1:             if (val == BLOBDataModelSetup.bigVal) break;
/////////////////////////////////////////////////////////////////////////
1:      * positioned updates.
/////////////////////////////////////////////////////////////////////////
1:      * methods.
/////////////////////////////////////////////////////////////////////////
1:             final int val = rs.getInt(1);
1:             if (val == BLOBDataModelSetup.bigVal) break;
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a scollable resultset produced by a
1:      * select query with projection. Updates are made using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromScrollableResultSetWithProjectUsingResultSetMethods()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT data,val,length from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         println("Last");
1:         rs.last();
1:         
1:         final int newVal = rs.getInt(2) + 11;
1:         final int newSize = rs.getInt(3) / 2;
1:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:         
1:         println("Verify updated blob using result set");
1:         verifyBlob(newVal, newSize, rs.getBlob(1));
1: 
1:     /**
1:      * Tests updating a Blob from a forward only resultset, produced by 
1:      * a select query with projection. Updates are made using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromForwardOnlyResultSetWithProjectUsingResultSetMethods()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT data,val,length from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         
1:         while (rs.next()) {
1:             println("Next");
1:             final int val = rs.getInt("VAL");
1:             if (val == BLOBDataModelSetup.bigVal) break;
1:         }
1:         
1:         final int newVal = rs.getInt("VAL") + 11;
1:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a scollable resultset, produced by 
1:      * a select query with projection. Updates are made using
1:      * positioned updates
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromScrollableResultSetWithProjectUsingPositionedUpdates()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT data from " + 
1:                               BLOBDataModelSetup.getBlobTableName() + 
1:                               " WHERE val= " + BLOBDataModelSetup.bigVal);
1:         println("Last");
1:         rs.last();
1:         
1:         final int newVal = BLOBDataModelSetup.bigVal * 2;
1:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1: 
1:         rs.relative(0); // Necessary after a positioned update
1:         
1:         println("Verify updated blob using result set");
1:         verifyBlob(newVal, newSize, rs.getBlob("DATA"));
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a forward only resultset, produced by 
1:      * a select query with projection. Updates are made using
1:      * positioned updates.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromForwardOnlyResultSetWithProjectUsingPositionedUpdates()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT data from " + 
1:                               BLOBDataModelSetup.getBlobTableName() + 
1:                               " WHERE val = " + BLOBDataModelSetup.bigVal);
1:         rs.next();
1:         
1:         final int newVal =  BLOBDataModelSetup.bigVal * 2;
1:         final int newSize = BLOBDataModelSetup.bigSize / 2;
1:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:         
1:         rs.close();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         int val = rs.getInt("VAL");
1:         int size = rs.getInt("LENGTH");
1:         verifyBlob(val, size, rs.getBlob("DATA"));
1:         rs.updateInt("VAL", newVal);
1:         rs.updateInt("LENGTH", newSize);
1:         rs.updateBinaryStream("DATA", newStream, newSize);
commit:fc02124
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *
1:  * Derby - Class BLOBTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: import org.apache.derbyTesting.functionTests.util.TestInputStream;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import java.sql.Blob;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.io.IOException;
1: import java.io.InputStream;
1: 
1: /**
1:  * Tests reading and updating binary large objects (BLOBs).
0:  * @author Andreas Korneliussen
1:  */
1: final public class BLOBTest extends BaseJDBCTestCase
1: {
1:     /** 
1:      * Constructor
1:      * @param name name of test case (method).
1:      */
1:     public BLOBTest(String name) 
1:     {
1:         super(name);
0:         con = null;
1:     }
1: 
1:     
1:     /**
1:      * Tests updating a Blob from a scollable resultset, using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromScrollableResultSetUsingResultSetMethods()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT * from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         println("Last");
1:         rs.last();
1:         
1:         final int newVal = rs.getInt(1) + 11;
1:         final int newSize = rs.getInt(2) / 2;
1:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:         
1:         println("Verify updated blob using result set");
1:         verifyBlob(newVal, newSize, rs.getBlob(3));
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a forward only resultset, using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromForwardOnlyResultSetUsingResultSetMethods()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT * from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         
1:         while (rs.next()) {
1:             println("Next");
0:             final int size = rs.getInt(2);
0:             if (size>1024*1024) break;
1:         }
1:         
1:         final int newVal = rs.getInt(1) + 11;
1:         final int newSize = rs.getInt(2) / 2;
1:         testUpdateBlobWithResultSetMethods(rs, newVal, newSize);
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a scollable resultset, using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromScrollableResultSetUsingPositionedUpdates()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT * from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         println("Last");
1:         rs.last();
1:         
1:         final int newVal = rs.getInt(1) + 11;
1:         final int newSize = rs.getInt(2) / 2;
1:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1: 
1:         rs.relative(0); // Necessary after a positioned update
1:         
1:         println("Verify updated blob using result set");
1:         verifyBlob(newVal, newSize, rs.getBlob(3));
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Tests updating a Blob from a forward only resultset, using
1:      * result set update methods.
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     public void testUpdateBlobFromForwardOnlyResultSetUsingPositionedUpdates()
1:         throws SQLException, IOException
1:     {
1:         final Statement stmt = 
0:             con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         final ResultSet rs = 
1:             stmt.executeQuery("SELECT * from " + 
1:                               BLOBDataModelSetup.getBlobTableName());
1:         
1:         while (rs.next()) {
1:             println("Next");
0:             final int size = rs.getInt(2);
0:             if (size>1024*1024) break;
1:         }
1:         
1:         final int newVal = rs.getInt(1) + 11;
1:         final int newSize = rs.getInt(2) / 2;
1:         testUpdateBlobWithPositionedUpdate(rs, newVal, newSize);
1:         
1:         
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Tests updating the Blob using result set update methods.
1:      * @param rs result set, currently positioned on row to be updated
1:      * @param newVal new value in val column and blob data
1:      * @param newSize new size of Blob
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     private void testUpdateBlobWithResultSetMethods(final ResultSet rs,
1:                                                     final int newVal,
1:                                                     final int newSize) 
1:         throws SQLException, IOException
1:     {
0:         int val = rs.getInt(1);
0:         int size = rs.getInt(2);
1:         println("VerifyBlob");
0:         verifyBlob(val, size, rs.getBlob(3));
1:         
1:         println("UpdateBlob");
1:         final TestInputStream newStream = new TestInputStream(newSize, newVal);
1:         
0:         rs.updateInt(1, newVal);
0:         rs.updateInt(2, newSize);
0:         rs.updateBinaryStream(3, newStream, newSize);
1:         rs.updateRow();
1:         
1:         println("Verify updated blob with another query");
1:         verifyNewValueInTable(newVal, newSize);
1:     }
1: 
1:     /**
1:      * Tests updating the Blob using positioned updates
1:      * @param rs result set, currently positioned on row to be updated
1:      * @param newVal new value in val column and blob data
1:      * @param newSize new size of Blob
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     private void testUpdateBlobWithPositionedUpdate(final ResultSet rs,
1:                                                     final int newVal,
1:                                                     final int newSize) 
1:         throws SQLException, IOException
1:     {
0:         final PreparedStatement preparedStatement = con.prepareStatement
1:             ("UPDATE " + BLOBDataModelSetup.getBlobTableName() +
1:              " SET val=?, length = ?, data = ? WHERE CURRENT OF " +
1:              rs.getCursorName());
1:         
1:         println("UpdateBlob");
1:         
1:         final TestInputStream newStream = new TestInputStream(newSize, newVal);
1:         
1:         preparedStatement.setInt(1, newVal);
1:         preparedStatement.setInt(2, newSize);
1:         preparedStatement.setBinaryStream(3, newStream, newSize);
1:         preparedStatement.executeUpdate();
1:         
1:         println("Verify updated blob with another query");
1:         verifyNewValueInTable(newVal, newSize);
1:     }
1:     
1:     
1:     /**
1:      * Verifies that the table has row with column val=newVal
1:      * and that it its data and size columns are consistent.
1:      * @param newVal value expected to be found in the val column of a row
1:      * @param newSize expected size of size column and size of blob
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
1:     private void verifyNewValueInTable(final int newVal,
1:                                        final int newSize)
1:         throws IOException, SQLException
1:     {
1:         println("Verify new value in table: " + newVal);
1:         
0:         final Statement stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                                    ResultSet.CONCUR_READ_ONLY);
1:         
1:         final ResultSet rs = 
0:             stmt.executeQuery("SELECT * FROM " +  
1:                               BLOBDataModelSetup.getBlobTableName() +
1:                               " WHERE val = " + newVal);
1:         
1:         println("Query executed, calling next");
1:         
1:         boolean foundVal = false;
1:         
1:         while (rs.next()) {
1:             println("Next called, verifying row");
1:             
0:             assertEquals("Unexpected value in val column", 
1:                          newVal, rs.getInt(1));
1:             
1:             verifyBlob(newVal, newSize, rs.getBlob(3));
1:             foundVal = true;
1:         }
1:         assertTrue("No column with value= " + newVal + " found ", foundVal);
1:     }
1:                           
1:     /**
1:      * Verifies that the blob is consistent
1:      * @param expectedVal the InputStream for the Blob should return this value
1:      *                    for every byte
0:      * @param expecteSize the Blob should have this size
1:      * @exception SQLException causes test to fail with error
1:      * @exception IOException causes test to fail with error
1:      */
0:     private void verifyBlob(final int expectedVal, 
0:                             final int expectedSize, 
0:                             final Blob blob) 
1:         throws IOException, SQLException
1:     {
1:         final InputStream stream = blob.getBinaryStream();
1:         int blobSize = 0;
1:         for (int val = stream.read(); val!=-1; val = stream.read()) {
1:             blobSize++;
1:             
1:             // avoid doing a string-concat for every byte in blob
1:             if (expectedVal!=val) {
0:                 assertEquals("Unexpected value in stream at position " + 
1:                              blobSize,
1:                              expectedVal, val);
1:             }
1:         }
1:         stream.close();
1:         assertEquals("Unexpected size of stream ", expectedSize, blobSize);
1:     }
1: 
1:     /**
1:      * The suite decorates the tests of this class with 
1:      * a setup which creates and populates the data model.
1:      */
1:     public static Test suite() 
1:     {
0:         TestSuite mainSuite = new TestSuite(BLOBTest.class);
1:         return new BLOBDataModelSetup(mainSuite);
1:     }
1: 
1:     /**
1:      * The setup creates a Connection to the database.
1:      * @exception Exception any exception will cause test to fail with error.
1:      */
1:     public final void setUp() 
1:         throws Exception
1:     {
0:         println("Setup of: " + getName());
0:         con = getConnection();
0:         con.setAutoCommit(false);
1:     }
1:     
1:     /**
0:      * Teardown test.
0:      * Rollback connection and close it.
0:      * @exception Exceptions causes the test to fail with error
1:      */
0:     public final void tearDown() 
1:         throws Exception
1:     {
0:         println("Teardown of: " + getName());
0:         try { 
0:             con.rollback();
0:             con.close();
0:         } catch (SQLException e) {
0:             printStackTrace(e);
1:         }      
1:     }
1:     
0:     /** JDBC Connection */        
0:     private Connection con;
1: }
============================================================================