1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.compile.OptimizablePredicateList
1:7ecc1f2: 
1:d4580ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d4580ab:    contributor license agreements.  See the NOTICE file distributed with
1:d4580ab:    this work for additional information regarding copyright ownership.
1:d4580ab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d4580ab:    (the "License"); you may not use this file except in compliance with
1:d4580ab:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * OptimizablePredicateList provides services for optimizing a table in a query.
1:eac0369:  * RESOLVE - the methods for this interface need to get defined.
1:eac0369:  */
1:eac0369: 
1:eac0369: public interface OptimizablePredicateList 
1:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 *  Return the number of OptimizablePredicates in the list.
8:eac0369: 	 *
1:eac0369: 	 *  @return integer		The number of OptimizablePredicates in the list.
1:eac0369: 	 */
1:eac0369: 	public int size();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Return the nth OptimizablePredicate in the list.
1:eac0369: 	 *
1:eac0369: 	 *  @param n				"index" (0 based) into the list.
1:eac0369: 	 *
1:eac0369: 	 *  @return OptimizablePredicate		The nth OptimizablePredicate in the list.
1:eac0369: 	 */
1:eac0369: 	public OptimizablePredicate getOptPredicate(int n);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove the OptimizablePredicate at the specified index (0-based) from the list.
1:eac0369: 	 *
1:eac0369: 	 * @param predCtr	The index.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void removeOptPredicate(int predCtr) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add the given OptimizablePredicate to the end of this list.
1:eac0369: 	 *
1:eac0369: 	 * @param optPredicate	The predicate to add
1:eac0369: 	 */
1:eac0369: 	void addOptPredicate(OptimizablePredicate optPredicate);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if this predicate list is useful for limiting the scan on
1:eac0369: 	 * the given table using the given conglomerate.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable An Optimizable for the table in question
1:eac0369: 	 * @param cd A ConglomerateDescriptor for the conglomerate in question
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this predicate list can limit the scan
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean useful(Optimizable optTable, ConglomerateDescriptor cd)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine which predicates in this list are useful for limiting
1:eac0369: 	 * the scan on the given table using its best conglomerate.  Remove
1:eac0369: 	 * those predicates from this list and push them down to the given
1:eac0369: 	 * Optimizable table.  The predicates are pushed down in the order of
1:eac0369: 	 * the index columns that they qualify.  Also, the predicates are
1:eac0369: 	 * "marked" as start predicates, stop predicates, or qualifier
1:eac0369: 	 * predicates.  Finally, the start and stop operators are set in
1:eac0369: 	 * the given Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	An Optimizable for the table in question
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void pushUsefulPredicates(Optimizable optTable)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Classify the predicates in this list according to the given
1:eac0369: 	 * table and conglomerate.  Each predicate can be a start key, stop key,
1:eac0369: 	 * and/or qualifier, or it can be none of the above.  This method
1:eac0369: 	 * also orders the predicates to match the order of the columns
1:eac0369: 	 * in a keyed conglomerate.  No ordering is done for heaps.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table for which to classify
1:eac0369: 	 *					the predicates in this list.
1:eac0369: 	 * @param cd	The ConglomerateDescriptor for which to classify
1:eac0369: 	 *				the predicates in this list.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void classify(Optimizable optTable, ConglomerateDescriptor cd)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark all of the predicates as Qualifiers and set the numberOfQualifiers
1:eac0369: 	 * to reflect this.  This is useful for hash joins where all of the
1:eac0369: 	 * predicates in the list to be evaluated during the probe into the
1:eac0369: 	 * hash table on a next are qualifiers.
1:eac0369: 	 */
1:eac0369: 	public void markAllPredicatesQualifiers();
1:200a5ea: 	
1:200a5ea: 	/**
1:200a5ea: 	 * Check into the predicate list if the passed column has an equijoin 
1:200a5ea: 	 * predicate on it.
1:200a5ea: 	 * 
1:200a5ea: 	 * @param optTable
1:200a5ea: 	 * @param columnNumber
1:200a5ea: 	 * @param isNullOkay
1:6aee232: 	 * @return the position of the predicate in the list which corresponds to 
1:6aee232: 	 *   the equijoin. If no quijoin predicate found, then the return value 
1:6aee232: 	 *   will be -1
1:200a5ea: 	 * @throws StandardException
1:200a5ea: 	 */
1:200a5ea: 	public int hasEqualityPredicateOnOrderedColumn(Optimizable optTable,
1:200a5ea: 			  int columnNumber,
1:200a5ea: 			  boolean isNullOkay)
1:200a5ea: 	throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is there an optimizable equality predicate on the specified column?
1:eac0369: 	 *
1:eac0369: 	 * @param optTable		The optimizable the column comes from.
1:eac0369: 	 * @param columnNumber	The column number within the base table.
1:eac0369: 	 * @param isNullOkay	boolean, whether or not the IS NULL operator
1:eac0369: 	 *						satisfies the search
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not there is an optimizable equality predicate on the specified column.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean hasOptimizableEqualityPredicate(Optimizable optTable,
1:eac0369: 											int columnNumber,
1:eac0369: 											boolean isNullOkay)
1:eac0369: 								throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is there an optimizable equijoin on the specified column?
1:eac0369: 	 *
1:eac0369: 	 * @param optTable		The optimizable the column comes from.
1:eac0369: 	 * @param columnNumber	The column number within the base table.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not there is an optimizable equijoin on the specified column.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	boolean hasOptimizableEquijoin(Optimizable optTable,
1:eac0369: 									int columnNumber)
1:eac0369: 							throws StandardException;
1:eac0369: 									
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Find the optimizable equality predicate on the specified column and make
1:eac0369: 	 * it the first predicate in this list.  This is useful for hash joins where
1:eac0369: 	 * Qualifier[0] is assumed to be on the hash key.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable		The optimizable the column comes from.
1:eac0369: 	 * @param columnNumber	The column number within the base table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void putOptimizableEqualityPredicateFirst(Optimizable optTable,
1:eac0369: 												int columnNumber)
1:eac0369: 								throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Transfer the predicates whose referenced set is contained by the
1:eac0369: 	 * specified referencedTableMap from this list to the other list.
1:eac0369: 	 * This is useful when splitting out a set of predicates from a larger
1:eac0369: 	 * set, like when generating a HashScanResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @param otherList				The predicateList to xfer to
1:eac0369: 	 * @param referencedTableMap	The table map to check against
1:eac0369: 	 * @param table					The table to order the new predicates
1:eac0369: 	 *								against
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void transferPredicates(OptimizablePredicateList otherList,
1:eac0369: 									JBitSet referencedTableMap,
1:eac0369: 									Optimizable table)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Transfer all the predicates from this list to the given list.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void transferAllPredicates(OptimizablePredicateList otherList)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Non-destructive copy of all of the predicates from this list to the
1:eac0369: 	 * other list.
1:eac0369: 	 *
1:eac0369: 	 * This is useful when splitting out a set of predicates from a larger
1:eac0369: 	 * set, like when generating a HashScanResultSet.
1:eac0369: 	 *
1:eac0369: 	 * @param otherList				The predicateList to xfer to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void copyPredicatesToOtherList(OptimizablePredicateList otherList)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the given list to have the same elements as this one, and
1:eac0369: 	 * the same properties as this one (number of qualifiers and start
1:eac0369: 	 * and stop predicates.
1:eac0369: 	 *
1:eac0369: 	 * @param otherList		The list to set the same as this one.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setPredicatesAndProperties(OptimizablePredicateList otherList)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not the specified entry in the list is a redundant
1:eac0369: 	 * predicate. This is useful for selectivity calculations because we
1:eac0369: 	 * do not want redundant predicates included in the selectivity calculation.
1:eac0369: 	 *
1:eac0369: 	 * @param predNum	The entry in the list
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not the specified entry in the list is a redundant predicate.
1:eac0369: 	 */
1:eac0369: 	public boolean isRedundantPredicate(int predNum);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the start operator for the given Optimizable for a heap or
1:eac0369: 	 * index scan.
1:eac0369: 	 */
1:eac0369: 	int startOperator(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the stop operator for the given Optimizable for a heap or
1:eac0369: 	 * index scan.
1:eac0369: 	 */
1:eac0369: 	int stopOperator(Optimizable optTable);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the qualifiers for a scan.  This method generates an array
1:eac0369: 	 * of Qualifiers, and fills them in with calls to the factory method
1:eac0369: 	 * for generating Qualifiers in the constructor for the activation.
1:eac0369: 	 * It stores the array of Qualifiers in a field in the activation, and
1:eac0369: 	 * returns a reference to that field.
1:eac0369: 	 *
1:eac0369: 	 * If there are no qualifiers, it initializes the array of Qualifiers
1:eac0369: 	 * to null.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilderInterface for the class we are building
1:eac0369: 	 * @param mb	The method the generated code is going into
1:eac0369: 	 * @param optTable	The Optimizable table the Qualifiers are on
1:eac0369: 	 * @param absolute	Generate absolute column positions if true,
1:eac0369: 	 *					else relative column positions (within the underlying
1:eac0369: 	 *					row)
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateQualifiers(ExpressionClassBuilderInterface acb,
1:eac0369: 									MethodBuilder mb,
1:eac0369: 									Optimizable optTable,
1:eac0369: 									boolean absolute)
1:eac0369: 							throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the start key for a heap or index scan.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
1:eac0369: 	 * @param mb	The method the generated code is to go into
1:eac0369: 	 * @param optTable	The Optimizable table the start key is for
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateStartKey(ExpressionClassBuilderInterface acb,
1:eac0369: 								MethodBuilder mb,
1:eac0369: 								Optimizable optTable)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the stop key for a heap or index scan.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
1:eac0369: 	 * @param mb	the method the generated code is to go into
1:eac0369: 	 * @param optTable	The Optimizable table the stop key is for
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void generateStopKey(ExpressionClassBuilderInterface acb,
1:eac0369: 								MethodBuilder mb,
1:eac0369: 								Optimizable optTable)
1:eac0369: 				throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Can we use the same key for both the start and stop key.
1:eac0369: 	 * This is possible when doing an exact match on an index
1:eac0369: 	 * where there are no other sargable predicates.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not we can use the same key for both the start and stop key.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean sameStartStopPosition()
1:eac0369: 				throws StandardException;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * calculate the selectivity for a set of predicates. 
1:eac0369: 	 * If statistics exist for the predicates this method uses the
1:eac0369: 	 * statistics. If statistics do not exist, then simply call 
1:eac0369: 	 * selectivity for each of the predicates and return the result.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	the Optimizable that the predicate list restricts.
1:eac0369: 	 */	
1:eac0369: 	public double selectivity(Optimizable optTable) throws StandardException;
1:eac0369: 	
1:20bd3c0: 	/**
1:20bd3c0: 	 * Walk through the predicates in this list and make any adjustments
1:20bd3c0: 	 * that are required to allow for proper handling of an ORDER BY
1:20bd3c0: 	 * clause.
1:20bd3c0: 	 */
1:20bd3c0: 	public void adjustForSortElimination(RequiredRowOrdering ordering)
1:20bd3c0: 		throws StandardException;
1:20bd3c0: 
1:eac0369: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6aee232
/////////////////////////////////////////////////////////////////////////
1: 	 * @return the position of the predicate in the list which corresponds to 
1: 	 *   the equijoin. If no quijoin predicate found, then the return value 
1: 	 *   will be -1
commit:200a5ea
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Check into the predicate list if the passed column has an equijoin 
1: 	 * predicate on it.
1: 	 * 
1: 	 * @param optTable
1: 	 * @param columnNumber
1: 	 * @param isNullOkay
0: 	 * @return
1: 	 * @throws StandardException
1: 	 */
1: 	public int hasEqualityPredicateOnOrderedColumn(Optimizable optTable,
1: 			  int columnNumber,
1: 			  boolean isNullOkay)
1: 	throws StandardException;
author:Army
-------------------------------------------------------------------------------
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Walk through the predicates in this list and make any adjustments
1: 	 * that are required to allow for proper handling of an ORDER BY
1: 	 * clause.
1: 	 */
1: 	public void adjustForSortElimination(RequiredRowOrdering ordering)
1: 		throws StandardException;
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d4580ab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.compile.OptimizablePredicateList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
1: /**
1:  * OptimizablePredicateList provides services for optimizing a table in a query.
1:  * RESOLVE - the methods for this interface need to get defined.
1:  */
1: 
1: public interface OptimizablePredicateList 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 *  Return the number of OptimizablePredicates in the list.
1: 	 *
1: 	 *  @return integer		The number of OptimizablePredicates in the list.
1: 	 */
1: 	public int size();
1: 
1: 	/**
1: 	 *  Return the nth OptimizablePredicate in the list.
1: 	 *
1: 	 *  @param n				"index" (0 based) into the list.
1: 	 *
1: 	 *  @return OptimizablePredicate		The nth OptimizablePredicate in the list.
1: 	 */
1: 	public OptimizablePredicate getOptPredicate(int n);
1: 
1: 	/**
1: 	 * Remove the OptimizablePredicate at the specified index (0-based) from the list.
1: 	 *
1: 	 * @param predCtr	The index.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void removeOptPredicate(int predCtr) throws StandardException;
1: 
1: 	/**
1: 	 * Add the given OptimizablePredicate to the end of this list.
1: 	 *
1: 	 * @param optPredicate	The predicate to add
1: 	 */
1: 	void addOptPredicate(OptimizablePredicate optPredicate);
1: 
1: 	/**
1: 	 * Return true if this predicate list is useful for limiting the scan on
1: 	 * the given table using the given conglomerate.
1: 	 *
1: 	 * @param optTable An Optimizable for the table in question
1: 	 * @param cd A ConglomerateDescriptor for the conglomerate in question
1: 	 *
1: 	 * @return	true if this predicate list can limit the scan
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean useful(Optimizable optTable, ConglomerateDescriptor cd)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Determine which predicates in this list are useful for limiting
1: 	 * the scan on the given table using its best conglomerate.  Remove
1: 	 * those predicates from this list and push them down to the given
1: 	 * Optimizable table.  The predicates are pushed down in the order of
1: 	 * the index columns that they qualify.  Also, the predicates are
1: 	 * "marked" as start predicates, stop predicates, or qualifier
1: 	 * predicates.  Finally, the start and stop operators are set in
1: 	 * the given Optimizable.
1: 	 *
1: 	 * @param optTable	An Optimizable for the table in question
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void pushUsefulPredicates(Optimizable optTable)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Classify the predicates in this list according to the given
1: 	 * table and conglomerate.  Each predicate can be a start key, stop key,
1: 	 * and/or qualifier, or it can be none of the above.  This method
1: 	 * also orders the predicates to match the order of the columns
1: 	 * in a keyed conglomerate.  No ordering is done for heaps.
1: 	 *
1: 	 * @param optTable	The Optimizable table for which to classify
1: 	 *					the predicates in this list.
1: 	 * @param cd	The ConglomerateDescriptor for which to classify
1: 	 *				the predicates in this list.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void classify(Optimizable optTable, ConglomerateDescriptor cd)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Mark all of the predicates as Qualifiers and set the numberOfQualifiers
1: 	 * to reflect this.  This is useful for hash joins where all of the
1: 	 * predicates in the list to be evaluated during the probe into the
1: 	 * hash table on a next are qualifiers.
1: 	 */
1: 	public void markAllPredicatesQualifiers();
1: 
1: 	/**
1: 	 * Is there an optimizable equality predicate on the specified column?
1: 	 *
1: 	 * @param optTable		The optimizable the column comes from.
1: 	 * @param columnNumber	The column number within the base table.
1: 	 * @param isNullOkay	boolean, whether or not the IS NULL operator
1: 	 *						satisfies the search
1: 	 *
1: 	 * @return Whether or not there is an optimizable equality predicate on the specified column.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean hasOptimizableEqualityPredicate(Optimizable optTable,
1: 											int columnNumber,
1: 											boolean isNullOkay)
1: 								throws StandardException;
1: 
1: 	/**
1: 	 * Is there an optimizable equijoin on the specified column?
1: 	 *
1: 	 * @param optTable		The optimizable the column comes from.
1: 	 * @param columnNumber	The column number within the base table.
1: 	 *
1: 	 * @return Whether or not there is an optimizable equijoin on the specified column.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	boolean hasOptimizableEquijoin(Optimizable optTable,
1: 									int columnNumber)
1: 							throws StandardException;
1: 									
1: 
1: 	/**
1: 	 * Find the optimizable equality predicate on the specified column and make
1: 	 * it the first predicate in this list.  This is useful for hash joins where
1: 	 * Qualifier[0] is assumed to be on the hash key.
1: 	 *
1: 	 * @param optTable		The optimizable the column comes from.
1: 	 * @param columnNumber	The column number within the base table.
1: 	 *
0: 	 * @return Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void putOptimizableEqualityPredicateFirst(Optimizable optTable,
1: 												int columnNumber)
1: 								throws StandardException;
1: 
1: 	/**
1: 	 * Transfer the predicates whose referenced set is contained by the
1: 	 * specified referencedTableMap from this list to the other list.
1: 	 * This is useful when splitting out a set of predicates from a larger
1: 	 * set, like when generating a HashScanResultSet.
1: 	 *
1: 	 * @param otherList				The predicateList to xfer to
1: 	 * @param referencedTableMap	The table map to check against
1: 	 * @param table					The table to order the new predicates
1: 	 *								against
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void transferPredicates(OptimizablePredicateList otherList,
1: 									JBitSet referencedTableMap,
1: 									Optimizable table)
1: 		throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Transfer all the predicates from this list to the given list.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void transferAllPredicates(OptimizablePredicateList otherList)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Non-destructive copy of all of the predicates from this list to the
1: 	 * other list.
1: 	 *
1: 	 * This is useful when splitting out a set of predicates from a larger
1: 	 * set, like when generating a HashScanResultSet.
1: 	 *
1: 	 * @param otherList				The predicateList to xfer to
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void copyPredicatesToOtherList(OptimizablePredicateList otherList)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Sets the given list to have the same elements as this one, and
1: 	 * the same properties as this one (number of qualifiers and start
1: 	 * and stop predicates.
1: 	 *
1: 	 * @param otherList		The list to set the same as this one.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setPredicatesAndProperties(OptimizablePredicateList otherList)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Return whether or not the specified entry in the list is a redundant
1: 	 * predicate. This is useful for selectivity calculations because we
1: 	 * do not want redundant predicates included in the selectivity calculation.
1: 	 *
1: 	 * @param predNum	The entry in the list
1: 	 *
1: 	 * @return Whether or not the specified entry in the list is a redundant predicate.
1: 	 */
1: 	public boolean isRedundantPredicate(int predNum);
1: 
1: 	/**
1: 	 * Get the start operator for the given Optimizable for a heap or
1: 	 * index scan.
1: 	 */
1: 	int startOperator(Optimizable optTable);
1: 
1: 	/**
1: 	 * Get the stop operator for the given Optimizable for a heap or
1: 	 * index scan.
1: 	 */
1: 	int stopOperator(Optimizable optTable);
1: 
1: 	/**
1: 	 * Generate the qualifiers for a scan.  This method generates an array
1: 	 * of Qualifiers, and fills them in with calls to the factory method
1: 	 * for generating Qualifiers in the constructor for the activation.
1: 	 * It stores the array of Qualifiers in a field in the activation, and
1: 	 * returns a reference to that field.
1: 	 *
1: 	 * If there are no qualifiers, it initializes the array of Qualifiers
1: 	 * to null.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilderInterface for the class we are building
1: 	 * @param mb	The method the generated code is going into
1: 	 * @param optTable	The Optimizable table the Qualifiers are on
1: 	 * @param absolute	Generate absolute column positions if true,
1: 	 *					else relative column positions (within the underlying
1: 	 *					row)
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateQualifiers(ExpressionClassBuilderInterface acb,
1: 									MethodBuilder mb,
1: 									Optimizable optTable,
1: 									boolean absolute)
1: 							throws StandardException;
1: 
1: 	/**
1: 	 * Generate the start key for a heap or index scan.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
1: 	 * @param mb	The method the generated code is to go into
1: 	 * @param optTable	The Optimizable table the start key is for
1: 	 *
0: 	 * @return	An expression which, when evaluated, returns the method to
0: 	 *			get the start key.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateStartKey(ExpressionClassBuilderInterface acb,
1: 								MethodBuilder mb,
1: 								Optimizable optTable)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Generate the stop key for a heap or index scan.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
1: 	 * @param mb	the method the generated code is to go into
1: 	 * @param optTable	The Optimizable table the stop key is for
1: 	 *
0: 	 * @return	An expression which, when evaluated, returns the method to
0: 	 *			get the stop key.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void generateStopKey(ExpressionClassBuilderInterface acb,
1: 								MethodBuilder mb,
1: 								Optimizable optTable)
1: 				throws StandardException;
1: 
1: 	/**
1: 	 * Can we use the same key for both the start and stop key.
1: 	 * This is possible when doing an exact match on an index
1: 	 * where there are no other sargable predicates.
1: 	 *
1: 	 * @return Whether or not we can use the same key for both the start and stop key.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean sameStartStopPosition()
1: 				throws StandardException;
1: 	
1: 	/**
1: 	 * calculate the selectivity for a set of predicates. 
1: 	 * If statistics exist for the predicates this method uses the
1: 	 * statistics. If statistics do not exist, then simply call 
1: 	 * selectivity for each of the predicates and return the result.
1: 	 *
1: 	 * @param optTable	the Optimizable that the predicate list restricts.
1: 	 */	
1: 	public double selectivity(Optimizable optTable) throws StandardException;
1: 	
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: /**
0:  * OptimizablePredicateList provides services for optimizing a table in a query.
0:  * RESOLVE - the methods for this interface need to get defined.
0:  */
0: 
0: public interface OptimizablePredicateList 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 *  Return the number of OptimizablePredicates in the list.
0: 	 *
0: 	 *  @return integer		The number of OptimizablePredicates in the list.
0: 	 */
0: 	public int size();
0: 
0: 	/**
0: 	 *  Return the nth OptimizablePredicate in the list.
0: 	 *
0: 	 *  @param n				"index" (0 based) into the list.
0: 	 *
0: 	 *  @return OptimizablePredicate		The nth OptimizablePredicate in the list.
0: 	 */
0: 	public OptimizablePredicate getOptPredicate(int n);
0: 
0: 	/**
0: 	 * Remove the OptimizablePredicate at the specified index (0-based) from the list.
0: 	 *
0: 	 * @param predCtr	The index.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void removeOptPredicate(int predCtr) throws StandardException;
0: 
0: 	/**
0: 	 * Add the given OptimizablePredicate to the end of this list.
0: 	 *
0: 	 * @param optPredicate	The predicate to add
0: 	 */
0: 	void addOptPredicate(OptimizablePredicate optPredicate);
0: 
0: 	/**
0: 	 * Return true if this predicate list is useful for limiting the scan on
0: 	 * the given table using the given conglomerate.
0: 	 *
0: 	 * @param optTable An Optimizable for the table in question
0: 	 * @param cd A ConglomerateDescriptor for the conglomerate in question
0: 	 *
0: 	 * @return	true if this predicate list can limit the scan
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean useful(Optimizable optTable, ConglomerateDescriptor cd)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Determine which predicates in this list are useful for limiting
0: 	 * the scan on the given table using its best conglomerate.  Remove
0: 	 * those predicates from this list and push them down to the given
0: 	 * Optimizable table.  The predicates are pushed down in the order of
0: 	 * the index columns that they qualify.  Also, the predicates are
0: 	 * "marked" as start predicates, stop predicates, or qualifier
0: 	 * predicates.  Finally, the start and stop operators are set in
0: 	 * the given Optimizable.
0: 	 *
0: 	 * @param optTable	An Optimizable for the table in question
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void pushUsefulPredicates(Optimizable optTable)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Classify the predicates in this list according to the given
0: 	 * table and conglomerate.  Each predicate can be a start key, stop key,
0: 	 * and/or qualifier, or it can be none of the above.  This method
0: 	 * also orders the predicates to match the order of the columns
0: 	 * in a keyed conglomerate.  No ordering is done for heaps.
0: 	 *
0: 	 * @param optTable	The Optimizable table for which to classify
0: 	 *					the predicates in this list.
0: 	 * @param cd	The ConglomerateDescriptor for which to classify
0: 	 *				the predicates in this list.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void classify(Optimizable optTable, ConglomerateDescriptor cd)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Mark all of the predicates as Qualifiers and set the numberOfQualifiers
0: 	 * to reflect this.  This is useful for hash joins where all of the
0: 	 * predicates in the list to be evaluated during the probe into the
0: 	 * hash table on a next are qualifiers.
0: 	 */
0: 	public void markAllPredicatesQualifiers();
0: 
0: 	/**
0: 	 * Is there an optimizable equality predicate on the specified column?
0: 	 *
0: 	 * @param optTable		The optimizable the column comes from.
0: 	 * @param columnNumber	The column number within the base table.
0: 	 * @param isNullOkay	boolean, whether or not the IS NULL operator
0: 	 *						satisfies the search
0: 	 *
0: 	 * @return Whether or not there is an optimizable equality predicate on the specified column.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean hasOptimizableEqualityPredicate(Optimizable optTable,
0: 											int columnNumber,
0: 											boolean isNullOkay)
0: 								throws StandardException;
0: 
0: 	/**
0: 	 * Is there an optimizable equijoin on the specified column?
0: 	 *
0: 	 * @param optTable		The optimizable the column comes from.
0: 	 * @param columnNumber	The column number within the base table.
0: 	 *
0: 	 * @return Whether or not there is an optimizable equijoin on the specified column.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	boolean hasOptimizableEquijoin(Optimizable optTable,
0: 									int columnNumber)
0: 							throws StandardException;
0: 									
0: 
0: 	/**
0: 	 * Find the optimizable equality predicate on the specified column and make
0: 	 * it the first predicate in this list.  This is useful for hash joins where
0: 	 * Qualifier[0] is assumed to be on the hash key.
0: 	 *
0: 	 * @param optTable		The optimizable the column comes from.
0: 	 * @param columnNumber	The column number within the base table.
0: 	 *
0: 	 * @return Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void putOptimizableEqualityPredicateFirst(Optimizable optTable,
0: 												int columnNumber)
0: 								throws StandardException;
0: 
0: 	/**
0: 	 * Transfer the predicates whose referenced set is contained by the
0: 	 * specified referencedTableMap from this list to the other list.
0: 	 * This is useful when splitting out a set of predicates from a larger
0: 	 * set, like when generating a HashScanResultSet.
0: 	 *
0: 	 * @param otherList				The predicateList to xfer to
0: 	 * @param referencedTableMap	The table map to check against
0: 	 * @param table					The table to order the new predicates
0: 	 *								against
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void transferPredicates(OptimizablePredicateList otherList,
0: 									JBitSet referencedTableMap,
0: 									Optimizable table)
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Transfer all the predicates from this list to the given list.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void transferAllPredicates(OptimizablePredicateList otherList)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Non-destructive copy of all of the predicates from this list to the
0: 	 * other list.
0: 	 *
0: 	 * This is useful when splitting out a set of predicates from a larger
0: 	 * set, like when generating a HashScanResultSet.
0: 	 *
0: 	 * @param otherList				The predicateList to xfer to
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void copyPredicatesToOtherList(OptimizablePredicateList otherList)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Sets the given list to have the same elements as this one, and
0: 	 * the same properties as this one (number of qualifiers and start
0: 	 * and stop predicates.
0: 	 *
0: 	 * @param otherList		The list to set the same as this one.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setPredicatesAndProperties(OptimizablePredicateList otherList)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Return whether or not the specified entry in the list is a redundant
0: 	 * predicate. This is useful for selectivity calculations because we
0: 	 * do not want redundant predicates included in the selectivity calculation.
0: 	 *
0: 	 * @param predNum	The entry in the list
0: 	 *
0: 	 * @return Whether or not the specified entry in the list is a redundant predicate.
0: 	 */
0: 	public boolean isRedundantPredicate(int predNum);
0: 
0: 	/**
0: 	 * Get the start operator for the given Optimizable for a heap or
0: 	 * index scan.
0: 	 */
0: 	int startOperator(Optimizable optTable);
0: 
0: 	/**
0: 	 * Get the stop operator for the given Optimizable for a heap or
0: 	 * index scan.
0: 	 */
0: 	int stopOperator(Optimizable optTable);
0: 
0: 	/**
0: 	 * Generate the qualifiers for a scan.  This method generates an array
0: 	 * of Qualifiers, and fills them in with calls to the factory method
0: 	 * for generating Qualifiers in the constructor for the activation.
0: 	 * It stores the array of Qualifiers in a field in the activation, and
0: 	 * returns a reference to that field.
0: 	 *
0: 	 * If there are no qualifiers, it initializes the array of Qualifiers
0: 	 * to null.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilderInterface for the class we are building
0: 	 * @param mb	The method the generated code is going into
0: 	 * @param optTable	The Optimizable table the Qualifiers are on
0: 	 * @param absolute	Generate absolute column positions if true,
0: 	 *					else relative column positions (within the underlying
0: 	 *					row)
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateQualifiers(ExpressionClassBuilderInterface acb,
0: 									MethodBuilder mb,
0: 									Optimizable optTable,
0: 									boolean absolute)
0: 							throws StandardException;
0: 
0: 	/**
0: 	 * Generate the start key for a heap or index scan.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
0: 	 * @param mb	The method the generated code is to go into
0: 	 * @param optTable	The Optimizable table the start key is for
0: 	 *
0: 	 * @return	An expression which, when evaluated, returns the method to
0: 	 *			get the start key.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateStartKey(ExpressionClassBuilderInterface acb,
0: 								MethodBuilder mb,
0: 								Optimizable optTable)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Generate the stop key for a heap or index scan.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilderInterface for the class we're building
0: 	 * @param mb	the method the generated code is to go into
0: 	 * @param optTable	The Optimizable table the stop key is for
0: 	 *
0: 	 * @return	An expression which, when evaluated, returns the method to
0: 	 *			get the stop key.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void generateStopKey(ExpressionClassBuilderInterface acb,
0: 								MethodBuilder mb,
0: 								Optimizable optTable)
0: 				throws StandardException;
0: 
0: 	/**
0: 	 * Can we use the same key for both the start and stop key.
0: 	 * This is possible when doing an exact match on an index
0: 	 * where there are no other sargable predicates.
0: 	 *
0: 	 * @return Whether or not we can use the same key for both the start and stop key.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean sameStartStopPosition()
0: 				throws StandardException;
0: 	
0: 	/**
0: 	 * calculate the selectivity for a set of predicates. 
0: 	 * If statistics exist for the predicates this method uses the
0: 	 * statistics. If statistics do not exist, then simply call 
0: 	 * selectivity for each of the predicates and return the result.
0: 	 *
0: 	 * @param optTable	the Optimizable that the predicate list restricts.
0: 	 */	
0: 	public double selectivity(Optimizable optTable) throws StandardException;
0: 	
0: }
============================================================================