1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.catalog.types.RoutineAliasInfo
1:9f60172: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
3:eac0369: 
1:eac0369: package org.apache.derby.catalog.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.services.io.ArrayUtil;
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.ObjectOutput;
1:e33b8d8: import java.sql.ParameterMetaData;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:01b5961: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:d241269: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
1:eac0369: /**
1:37a2f5e:  * Describe a routine (procedure or function) alias.
1:eac0369:  *
1:ae2cdc2:  * @see org.apache.derby.catalog.AliasInfo
1:eac0369:  */
1:eac0369: public class RoutineAliasInfo extends MethodAliasInfo
1:eac0369: {
1:eac0369: 
1:eac0369: 	private static final String[] SQL_CONTROL = {"MODIFIES SQL DATA", "READS SQL DATA", "CONTAINS SQL", "NO SQL"};
1:eac0369: 	public static final short MODIFIES_SQL_DATA = 0;
1:eac0369: 	public static final short READS_SQL_DATA	= 1;
1:eac0369: 	public static final short CONTAINS_SQL		= 2;
1:eac0369: 	public static final short NO_SQL			= 3;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/** PARAMETER STYLE JAVA */
1:eac0369: 	public static final short PS_JAVA = 0;
1:eac0369: 
1:4aef9b0: 	/** PARAMETER STYLE DERBY_JDBC_RESULT_SET */
1:4aef9b0: 	public static final short PS_DERBY_JDBC_RESULT_SET = PS_JAVA + 1;
1:4aef9b0: 
1:f9596d4: 	/** PARAMETER STYLE DERBY */
1:f9596d4: 	public static final short PS_DERBY = PS_DERBY_JDBC_RESULT_SET + 1;
1:f9596d4: 
1:9f4b339:     /** Masks for the sqlOptions field */
1:9f4b339:     private static final short SQL_ALLOWED_MASK = (short) 0xF;
1:9f4b339:     private static final short DETERMINISTIC_MASK = (short) 0x10;
1:f9596d4:     private static final short SECURITY_DEFINER_MASK = (short) 0x20; // Mask for the SECURITY INVOKER/DEFINER field
1:f9596d4:     private static final short VARARGS_MASK = (short) 0x40;
1:9f4b339: 
1:eac0369: 	private int parameterCount;
1:9f60172: 
1:01b5961:     /**
1:01b5961:      * Types of the parameters. If there are no parameters
1:01b5961:      * then this may be null (or a zero length array).
1:01b5961:      */
1:eac0369: 	private TypeDescriptor[]	parameterTypes;
1:37a2f5e:         /**
1:37a2f5e:          * Name of each parameter. As of DERBY 10.3, parameter names
1:37a2f5e:          * are optional. If the parameter is unnamed, parameterNames[i]
1:37a2f5e:          * is a string of length 0
1:37a2f5e:          */
1:eac0369: 	private String[]			parameterNames;
1:eac0369: 	/**
1:eac0369: 		IN, OUT, INOUT
1:eac0369: 	*/
1:eac0369: 	private int[]				parameterModes;
1:eac0369: 
1:eac0369: 	private int dynamicResultSets;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return type for functions. Null for procedures.
1:eac0369: 	*/
1:eac0369: 	private TypeDescriptor	returnType;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Parameter style - always PS_JAVA at the moment.
1:eac0369: 	*/
1:eac0369: 	private short parameterStyle;
1:eac0369: 
1:eac0369: 	/**
1:9f4b339: 		This field contains several pieces of information:
1:9f4b339: 
1:9f4b339:         bits 0-3    sqlAllowed = MODIFIES_SQL_DATA, READS_SQL_DATA,CONTAINS_SQL, or NO_SQL
1:9f4b339: 
1:9f4b339:         bit 4         on if function is DETERMINISTIC, off otherwise
1:9f60172:         bit 5         on if running with definer's right, off otherwise
1:9f4b339:     */
1:9f4b339: 	private short	sqlOptions;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		SQL Specific name (future)
1:eac0369: 	*/
1:eac0369: 	private String	specificName;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		True if the routine is called on null input.
1:eac0369: 		(always true for procedures).
1:eac0369: 	*/
1:eac0369: 	private boolean	calledOnNullInput;
1:eac0369: 
1:1fa1fd0: 	// What type of alias is this: PROCEDURE or FUNCTION?
1:2a1abd5: 	private transient char aliasType;
1:eac0369: 
1:eac0369: 	public RoutineAliasInfo() {
1:eac0369: 	}
1:eac0369: 
1:37a2f5e: 	/**
1:eac0369: 		Create a RoutineAliasInfo for an internal PROCEDURE.
1:eac0369: 	*/
1:f9596d4: 	public RoutineAliasInfo
1:f9596d4:         (
1:f9596d4:          String methodName,
1:f9596d4:          int parameterCount,
1:f9596d4:          String[] parameterNames,
1:f9596d4:          TypeDescriptor[]	parameterTypes,
1:f9596d4:          int[] parameterModes,
1:f9596d4:          int dynamicResultSets,
1:f9596d4:          short parameterStyle,
1:f9596d4:          short sqlAllowed,
1:f9596d4:          boolean isDeterministic,
1:f9596d4:          boolean hasVarargs
1:f9596d4:          )
1:f9596d4:     {
1:9f60172:         this(methodName,
1:9f60172:              parameterCount,
1:9f60172:              parameterNames,
1:9f60172:              parameterTypes,
1:9f60172:              parameterModes,
1:9f60172:              dynamicResultSets,
1:9f60172:              parameterStyle,
1:9f60172:              sqlAllowed,
1:9f60172:              isDeterministic,
1:f9596d4:              hasVarargs,
1:9f60172:              false /* definersRights*/,
1:9f60172:              true,
1:9f60172:              (TypeDescriptor) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create a RoutineAliasInfo for a PROCEDURE or FUNCTION
1:eac0369: 	*/
1:9f60172:     public RoutineAliasInfo(String methodName,
1:9f60172:                             int parameterCount,
1:9f60172:                             String[] parameterNames,
1:9f60172:                             TypeDescriptor[] parameterTypes,
1:9f60172:                             int[] parameterModes,
1:9f60172:                             int dynamicResultSets,
1:9f60172:                             short parameterStyle,
1:9f60172:                             short sqlAllowed,
1:9f60172:                             boolean isDeterministic,
1:f9596d4:                             boolean hasVarargs,
1:9f60172:                             boolean definersRights,
1:9f60172:                             boolean calledOnNullInput,
1:9f60172:                             TypeDescriptor returnType)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		super(methodName);
1:eac0369: 		this.parameterCount = parameterCount;
1:57465ef: 		this.parameterNames = ArrayUtil.copy( parameterNames );
1:57465ef: 		setParameterTypes( parameterTypes );
1:57465ef: 		this.parameterModes = ArrayUtil.copy( parameterModes );
1:eac0369: 		this.dynamicResultSets = dynamicResultSets;
1:eac0369: 		this.parameterStyle = parameterStyle;
1:9f4b339: 		this.sqlOptions = (short) (sqlAllowed & SQL_ALLOWED_MASK);
1:9f4b339:         if ( isDeterministic ) { this.sqlOptions = (short) (sqlOptions | DETERMINISTIC_MASK); }
1:f9596d4:         if ( hasVarargs ) { this.sqlOptions = (short) (sqlOptions | VARARGS_MASK); }
1:9f60172: 
1:9f60172:         if (definersRights) {
1:9f60172:             this.sqlOptions = (short) (sqlOptions | SECURITY_DEFINER_MASK);
1:9f60172:         }
1:9f60172: 
1:eac0369: 		this.calledOnNullInput = calledOnNullInput;
1:eac0369: 		this.returnType = returnType;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (parameterCount != 0 && parameterNames.length != parameterCount) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterNames array " + parameterNames.length + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 			else if (parameterCount == 0 && parameterNames != null && parameterNames.length != 0) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterNames array " + " not zero " + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (parameterCount != 0 && parameterTypes.length != parameterCount) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + parameterTypes.length + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 			else if (parameterCount == 0 && parameterTypes != null && parameterTypes.length != 0) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + " not zero " + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (parameterCount != 0 && parameterModes.length != parameterCount) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterModes array " + parameterModes.length + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 			else if (parameterCount == 0 && parameterModes != null && parameterModes.length != 0) {
1:eac0369: 				SanityManager.THROWASSERT("Invalid parameterModes array " + " not zero " + " != " + parameterCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (returnType != null) {
1:eac0369: 				if (!((sqlAllowed >= RoutineAliasInfo.READS_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
1:eac0369: 					SanityManager.THROWASSERT("Invalid sqlAllowed for FUNCTION " + methodName + " " + sqlAllowed);
1:eac0369: 				}
1:eac0369: 			} else {
1:eac0369: 				if (!((sqlAllowed >= RoutineAliasInfo.MODIFIES_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
1:eac0369: 					SanityManager.THROWASSERT("Invalid sqlAllowed for PROCEDURE " + methodName + " " + sqlAllowed);
1:eac0369: 				}
1:eac0369: 				
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getParameterCount() {
1:eac0369: 		return parameterCount;
1:eac0369: 	}
1:eac0369: 
1:01b5961:     /**
1:01b5961:      * Types of the parameters. If there are no parameters
1:01b5961:      * then this may return null (or a zero length array).
1:01b5961:      */
1:57465ef: 	public TypeDescriptor[] getParameterTypes()
1:57465ef:     {
1:57465ef:         return TypeDescriptorImpl.copyTypeDescriptors( parameterTypes );
1:eac0369: 	}
1:eac0369: 
1:57465ef:     /** Set the paramter types. Useful if they need to be bound. */
1:57465ef:     public  void    setParameterTypes( TypeDescriptor[] parameterTypes )
1:57465ef:     {
1:57465ef: 		this.parameterTypes = TypeDescriptorImpl.copyTypeDescriptors( parameterTypes );
1:57465ef:     }
1:57465ef: 
1:57465ef: 	public int[] getParameterModes() { return ArrayUtil.copy( parameterModes ); }
1:eac0369:         /**
1:37a2f5e:          * Returns an array containing the names of the parameters.
1:37a2f5e:          * As of DERBY 10.3, parameter names are optional (see DERBY-183
1:37a2f5e:          * for more information). If the i-th parameter was unnamed,
1:37a2f5e:          * parameterNames[i] will contain a string of length 0.
1:37a2f5e:          */
1:57465ef: 	public String[] getParameterNames() { return ArrayUtil.copy( parameterNames );}
1:eac0369: 
1:eac0369: 	public int getMaxDynamicResultSets() {
1:eac0369: 		return dynamicResultSets;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public short getParameterStyle() {
1:eac0369: 		return parameterStyle;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public short getSQLAllowed() {
1:9f4b339: 		return (short) (sqlOptions & SQL_ALLOWED_MASK);
1:eac0369: 	}
1:eac0369: 
1:9f4b339:     public boolean isDeterministic()
1:9f4b339:     {
1:9f4b339:         return ( (sqlOptions & DETERMINISTIC_MASK) != 0 );
1:9f4b339:     }
1:9f4b339: 
1:f9596d4:     public boolean hasVarargs()
1:f9596d4:     {
1:f9596d4:         return ( (sqlOptions & VARARGS_MASK) != 0 );
1:f9596d4:     }
1:f9596d4: 
1:9f60172:     public boolean hasDefinersRights()
1:9f60172:     {
1:9f60172:         return ( (sqlOptions & SECURITY_DEFINER_MASK) != 0 );
1:9f60172:     }
1:9f60172: 
1:eac0369: 	public boolean calledOnNullInput() {
1:eac0369: 		return calledOnNullInput;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public TypeDescriptor getReturnType() {
1:eac0369: 		return returnType;
1:eac0369: 	}
1:eac0369: 
1:768e56f: 	public boolean isTableFunction() {
1:d753aef: 		if ( returnType == null ) { return false; }
1:d753aef: 		else { return returnType.isRowMultiSet(); }
1:768e56f: 	}
1:768e56f: 
1:eac0369: 
1:eac0369: 	// Formatable methods
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param in read this.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void readExternal( ObjectInput in )
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		super.readExternal(in);
1:eac0369: 		specificName = (String) in.readObject();
1:eac0369: 		dynamicResultSets = in.readInt();
1:eac0369: 		parameterCount = in.readInt();
1:eac0369: 		parameterStyle = in.readShort();
1:9f4b339: 		sqlOptions = in.readShort();
1:2e83f13: 		returnType = getStoredType(in.readObject());
1:eac0369: 		calledOnNullInput = in.readBoolean();
1:eac0369: 		in.readInt(); // future expansion.
1:eac0369: 
1:eac0369: 		if (parameterCount != 0) {
1:eac0369: 			parameterNames = new String[parameterCount];
1:eac0369: 			parameterTypes = new TypeDescriptor[parameterCount];
1:eac0369: 
1:eac0369: 			ArrayUtil.readArrayItems(in, parameterNames);
1:2e83f13:             for (int p = 0; p < parameterTypes.length; p++)
1:2e83f13:             {
1:2e83f13:                 parameterTypes[p] = getStoredType(in.readObject());
1:2e83f13:             }
1:eac0369: 			parameterModes = ArrayUtil.readIntArray(in);
1:eac0369: 
1:eac0369: 		} else {
1:eac0369: 			parameterNames = null;
1:eac0369: 			parameterTypes = null;
1:eac0369: 			parameterModes = null;
1:eac0369: 		}
1:eac0369: 	}
1:2e83f13:     
1:2e83f13:     /**
1:2e83f13:      * Old releases (10.3 and before) wrote out the runtime
1:2e83f13:      * DataTypeDescriptor for routine parameter and return types.
1:2e83f13:      * 10.4 onwards (DERBY-2775) always writes out the catalog
1:2e83f13:      * type TypeDescriptor. Here we see what object was read from
1:2e83f13:      * disk and if it was the old type, now mapped to OldRoutineType,
1:2e83f13:      * we extract the catalog type and use that.
1:2e83f13:      * 
1:2e83f13:      * @param onDiskType The object read that represents the type.
1:ae2cdc2:      * @return A type descriptor.
1:2e83f13:      */
1:000d4bc:     public static TypeDescriptor getStoredType(Object onDiskType)
1:2e83f13:     {
1:2e83f13:         if (onDiskType instanceof OldRoutineType)
1:2e83f13:             return ((OldRoutineType) onDiskType).getCatalogType();
1:2e83f13:         return (TypeDescriptor) onDiskType;
1:2e83f13:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException		thrown on error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal( ObjectOutput out )
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		super.writeExternal(out);
1:eac0369: 		out.writeObject(specificName);
1:eac0369: 		out.writeInt(dynamicResultSets);
1:eac0369: 		out.writeInt(parameterCount);
1:eac0369: 		out.writeShort(parameterStyle);
1:9f4b339: 		out.writeShort(sqlOptions);
1:eac0369: 		out.writeObject(returnType);
1:eac0369: 		out.writeBoolean(calledOnNullInput);
1:eac0369: 		out.writeInt(0); // future expansion
1:eac0369: 		if (parameterCount != 0) {
1:eac0369: 			ArrayUtil.writeArrayItems(out, parameterNames);
1:eac0369: 			ArrayUtil.writeArrayItems(out, parameterTypes);
1:eac0369: 			ArrayUtil.writeIntArray(out, parameterModes);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:  
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:eac0369: 	 */
1:eac0369: 	public	int	getTypeFormatId()	{ return StoredFormatIds.ROUTINE_INFO_V01_ID; }
1:eac0369: 
1:eac0369: 	/**
1:1fa1fd0: 	 * Get this alias info as a string.  NOTE: The "ALIASINFO" column
1:1fa1fd0: 	 * in the SYSALIASES table will return the result of this method
1:1fa1fd0: 	 * on a ResultSet.getString() call.  That said, since the dblook
1:1fa1fd0: 	 * utility uses ResultSet.getString() to retrieve ALIASINFO and
1:1fa1fd0: 	 * to generate the DDL, THIS METHOD MUST RETURN A STRING THAT
1:1fa1fd0: 	 * IS SYNTACTICALLY VALID, or else the DDL generated by dblook
1:1fa1fd0: 	 * will be incorrect.
1:eac0369: 	 */
1:eac0369: 	public String toString() {
1:eac0369: 
1:eac0369: 		StringBuffer sb = new StringBuffer(100);
1:eac0369: 		sb.append(getMethodName());
1:eac0369: 		sb.append('(');
1:eac0369: 		for (int i = 0; i < parameterCount; i++) {
1:eac0369: 			if (i != 0)
1:eac0369: 				sb.append(',');
1:eac0369: 
1:14d5f00: 			if (returnType == null) {
1:1fa1fd0: 			// This is a PROCEDURE.  We only want to print the
1:1fa1fd0: 			// parameter mode (ex. "IN", "OUT", "INOUT") for procedures--
1:1fa1fd0: 			// we don't do it for functions since use of the "IN" keyword
1:1fa1fd0: 			// is not part of the FUNCTION syntax.
1:eac0369: 				sb.append(RoutineAliasInfo.parameterMode(parameterModes[i]));
1:eac0369: 				sb.append(' ');
1:eac0369: 			}
1:d241269: 			sb.append(IdUtil.normalToDelimited(parameterNames[i]));
1:eac0369: 			sb.append(' ');
1:eac0369: 			sb.append(parameterTypes[i].getSQLstring());
1:eac0369: 		}
1:f9596d4:         if ( hasVarargs() ) { sb.append( " ... " ); }
1:eac0369: 		sb.append(')');
1:eac0369: 
1:14d5f00: 		if (returnType != null) {
1:1fa1fd0: 		// this a FUNCTION, so syntax requires us to append the return type.
1:1fa1fd0: 			sb.append(" RETURNS " + returnType.getSQLstring());
1:eac0369: 		}
1:eac0369: 
1:4aef9b0: 		sb.append(" LANGUAGE JAVA PARAMETER STYLE " );
1:fba255c: 
1:4aef9b0: 		switch( parameterStyle )
1:4aef9b0: 		{
1:4aef9b0: 		    case PS_JAVA:    sb.append( "JAVA " ); break;
1:4aef9b0: 		    case PS_DERBY_JDBC_RESULT_SET:    sb.append( "DERBY_JDBC_RESULT_SET " ); break;
1:f9596d4: 		    case PS_DERBY:    sb.append( "DERBY " ); break;
1:4aef9b0: 		}
1:fba255c:         
1:fba255c:         if ( isDeterministic() )
1:fba255c:         { sb.append( " DETERMINISTIC " ); }
1:fba255c: 
1:9f60172:         if ( hasDefinersRights())
1:9f60172:         { sb.append( " EXTERNAL SECURITY DEFINER " ); }
1:9f60172: 
1:eac0369: 		sb.append(RoutineAliasInfo.SQL_CONTROL[getSQLAllowed()]);
1:14d5f00: 		if ((returnType == null) &&
1:1fa1fd0: 			(dynamicResultSets != 0))
1:1fa1fd0: 		{ // Only print dynamic result sets if this is a PROCEDURE
1:1fa1fd0: 		  // because it's not valid syntax for FUNCTIONs.
1:eac0369: 			sb.append(" DYNAMIC RESULT SETS ");
1:eac0369: 			sb.append(dynamicResultSets);
1:eac0369: 		}
1:eac0369: 
1:14d5f00: 		if (returnType != null) {
1:1fa1fd0: 		// this a FUNCTION, so append the syntax telling what to
1:1fa1fd0: 		// do with a null parameter.
1:1fa1fd0: 			sb.append(calledOnNullInput ? " CALLED " : " RETURNS NULL ");
1:1fa1fd0: 			sb.append("ON NULL INPUT");
3:1fa1fd0: 		}
1:eac0369: 		
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static String parameterMode(int parameterMode) {
1:eac0369: 		switch (parameterMode) {
1:e33b8d8:         case (ParameterMetaData.parameterModeIn):
1:eac0369: 			return "IN";
1:e33b8d8:         case (ParameterMetaData.parameterModeOut):
1:eac0369: 			return "OUT";
1:e33b8d8:         case (ParameterMetaData.parameterModeInOut):
1:eac0369: 			return "INOUT";
1:eac0369: 		default:
1:eac0369: 			return "UNKNOWN";
1:eac0369: 		}
1:eac0369: 	}
1:01b5961:     
1:01b5961:     /**
1:01b5961:      * Set the collation type of all string types declared for
1:01b5961:      * use in this routine to the given collation type.
1:01b5961:      * @param collationType
1:01b5961:      */
1:01b5961:     public void setCollationTypeForAllStringTypes(int collationType)
1:01b5961:     {
1:01b5961:         if (parameterCount != 0)
1:01b5961:         {
1:01b5961:             for (int p = 0; p < parameterTypes.length; p++)
1:01b5961:                 parameterTypes[p] = DataTypeDescriptor.getCatalogType(
1:01b5961:                         parameterTypes[p], collationType);
1:01b5961:         }
1:01b5961:         
1:01b5961:         if (returnType != null)
1:01b5961:             returnType = DataTypeDescriptor.getCatalogType(returnType, collationType);
1:01b5961:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:37a2f5e
/////////////////////////////////////////////////////////////////////////
1:  * Describe a routine (procedure or function) alias.
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Name of each parameter. As of DERBY 10.3, parameter names
1:          * are optional. If the parameter is unnamed, parameterNames[i]
1:          * is a string of length 0
1:          */
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * Returns an array containing the names of the parameters.
1:          * As of DERBY 10.3, parameter names are optional (see DERBY-183
1:          * for more information). If the i-th parameter was unnamed,
1:          * parameterNames[i] will contain a string of length 0.
1:          */
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:         case (ParameterMetaData.parameterModeIn):
1:         case (ParameterMetaData.parameterModeOut):
1:         case (ParameterMetaData.parameterModeInOut):
commit:d241269
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1: 			sb.append(IdUtil.normalToDelimited(parameterNames[i]));
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:57465ef
/////////////////////////////////////////////////////////////////////////
1: 		this.parameterNames = ArrayUtil.copy( parameterNames );
1: 		setParameterTypes( parameterTypes );
1: 		this.parameterModes = ArrayUtil.copy( parameterModes );
/////////////////////////////////////////////////////////////////////////
1: 	public TypeDescriptor[] getParameterTypes()
1:     {
1:         return TypeDescriptorImpl.copyTypeDescriptors( parameterTypes );
1:     /** Set the paramter types. Useful if they need to be bound. */
1:     public  void    setParameterTypes( TypeDescriptor[] parameterTypes )
1:     {
1: 		this.parameterTypes = TypeDescriptorImpl.copyTypeDescriptors( parameterTypes );
1:     }
1: 
1: 	public int[] getParameterModes() { return ArrayUtil.copy( parameterModes ); }
1: 	public String[] getParameterNames() { return ArrayUtil.copy( parameterNames );}
commit:f9596d4
/////////////////////////////////////////////////////////////////////////
1: 	/** PARAMETER STYLE DERBY */
1: 	public static final short PS_DERBY = PS_DERBY_JDBC_RESULT_SET + 1;
1: 
1:     private static final short SECURITY_DEFINER_MASK = (short) 0x20; // Mask for the SECURITY INVOKER/DEFINER field
1:     private static final short VARARGS_MASK = (short) 0x40;
/////////////////////////////////////////////////////////////////////////
1: 	public RoutineAliasInfo
1:         (
1:          String methodName,
1:          int parameterCount,
1:          String[] parameterNames,
1:          TypeDescriptor[]	parameterTypes,
1:          int[] parameterModes,
1:          int dynamicResultSets,
1:          short parameterStyle,
1:          short sqlAllowed,
1:          boolean isDeterministic,
1:          boolean hasVarargs
1:          )
1:     {
/////////////////////////////////////////////////////////////////////////
1:              hasVarargs,
/////////////////////////////////////////////////////////////////////////
1:                             boolean hasVarargs,
/////////////////////////////////////////////////////////////////////////
1:         if ( hasVarargs ) { this.sqlOptions = (short) (sqlOptions | VARARGS_MASK); }
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasVarargs()
1:     {
1:         return ( (sqlOptions & VARARGS_MASK) != 0 );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( hasVarargs() ) { sb.append( " ... " ); }
/////////////////////////////////////////////////////////////////////////
1: 		    case PS_DERBY:    sb.append( "DERBY " ); break;
commit:fba255c
/////////////////////////////////////////////////////////////////////////
1: 
1:         
1:         if ( isDeterministic() )
1:         { sb.append( " DETERMINISTIC " ); }
1:         
commit:9f4b339
/////////////////////////////////////////////////////////////////////////
1:     /** Masks for the sqlOptions field */
1:     private static final short SQL_ALLOWED_MASK = (short) 0xF;
1:     private static final short DETERMINISTIC_MASK = (short) 0x10;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		This field contains several pieces of information:
1: 
1:         bits 0-3    sqlAllowed = MODIFIES_SQL_DATA, READS_SQL_DATA,CONTAINS_SQL, or NO_SQL
1: 
1:         bit 4         on if function is DETERMINISTIC, off otherwise
1:     */
1: 	private short	sqlOptions;
/////////////////////////////////////////////////////////////////////////
0:                             TypeDescriptor[]	parameterTypes, int[] parameterModes, int dynamicResultSets, short parameterStyle, short sqlAllowed,
0:                             boolean isDeterministic ) {
0:              dynamicResultSets, parameterStyle, sqlAllowed, isDeterministic, true, (TypeDescriptor) null);
/////////////////////////////////////////////////////////////////////////
0:                             boolean isDeterministic, boolean calledOnNullInput, TypeDescriptor returnType)
/////////////////////////////////////////////////////////////////////////
1: 		this.sqlOptions = (short) (sqlAllowed & SQL_ALLOWED_MASK);
1:         if ( isDeterministic ) { this.sqlOptions = (short) (sqlOptions | DETERMINISTIC_MASK); }
/////////////////////////////////////////////////////////////////////////
1: 		return (short) (sqlOptions & SQL_ALLOWED_MASK);
1:     public boolean isDeterministic()
1:     {
1:         return ( (sqlOptions & DETERMINISTIC_MASK) != 0 );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		sqlOptions = in.readShort();
/////////////////////////////////////////////////////////////////////////
1: 		out.writeShort(sqlOptions);
commit:d753aef
/////////////////////////////////////////////////////////////////////////
1: 		if ( returnType == null ) { return false; }
1: 		else { return returnType.isRowMultiSet(); }
commit:768e56f
/////////////////////////////////////////////////////////////////////////
1: 	public boolean isTableFunction() {
0: 		return returnType.isRowMultiSet();
1: 	}
1: 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1: 	/** PARAMETER STYLE DERBY_JDBC_RESULT_SET */
1: 	public static final short PS_DERBY_JDBC_RESULT_SET = PS_JAVA + 1;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		sb.append(" LANGUAGE JAVA PARAMETER STYLE " );
1: 		switch( parameterStyle )
1: 		{
1: 		    case PS_JAVA:    sb.append( "JAVA " ); break;
1: 		    case PS_DERBY_JDBC_RESULT_SET:    sb.append( "DERBY_JDBC_RESULT_SET " ); break;
1: 		}
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:000d4bc
/////////////////////////////////////////////////////////////////////////
1:     public static TypeDescriptor getStoredType(Object onDiskType)
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:9f60172
/////////////////////////////////////////////////////////////////////////
0:     /** Mask for the SECURITY INVOKER/DEFINER field */
0:     private static final short SECURITY_DEFINER_MASK = (short) 0x20;
1: 
/////////////////////////////////////////////////////////////////////////
1:         bit 5         on if running with definer's right, off otherwise
/////////////////////////////////////////////////////////////////////////
1:         this(methodName,
1:              parameterCount,
1:              parameterNames,
1:              parameterTypes,
1:              parameterModes,
1:              dynamicResultSets,
1:              parameterStyle,
1:              sqlAllowed,
1:              isDeterministic,
1:              false /* definersRights*/,
1:              true,
1:              (TypeDescriptor) null);
1:     public RoutineAliasInfo(String methodName,
1:                             int parameterCount,
1:                             String[] parameterNames,
1:                             TypeDescriptor[] parameterTypes,
1:                             int[] parameterModes,
1:                             int dynamicResultSets,
1:                             short parameterStyle,
1:                             short sqlAllowed,
1:                             boolean isDeterministic,
1:                             boolean definersRights,
1:                             boolean calledOnNullInput,
1:                             TypeDescriptor returnType)
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (definersRights) {
1:             this.sqlOptions = (short) (sqlOptions | SECURITY_DEFINER_MASK);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean hasDefinersRights()
1:     {
1:         return ( (sqlOptions & SECURITY_DEFINER_MASK) != 0 );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         if ( hasDefinersRights())
1:         { sb.append( " EXTERNAL SECURITY DEFINER " ); }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:ae2cdc2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:  * @see org.apache.derby.catalog.AliasInfo
/////////////////////////////////////////////////////////////////////////
1:      * @return A type descriptor.
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:2e83f13
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		returnType = getStoredType(in.readObject());
/////////////////////////////////////////////////////////////////////////
1:             for (int p = 0; p < parameterTypes.length; p++)
1:             {
1:                 parameterTypes[p] = getStoredType(in.readObject());
1:             }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Old releases (10.3 and before) wrote out the runtime
1:      * DataTypeDescriptor for routine parameter and return types.
1:      * 10.4 onwards (DERBY-2775) always writes out the catalog
1:      * type TypeDescriptor. Here we see what object was read from
1:      * disk and if it was the old type, now mapped to OldRoutineType,
1:      * we extract the catalog type and use that.
1:      * 
1:      * @param onDiskType The object read that represents the type.
0:      * @return
1:      */
0:     private static TypeDescriptor getStoredType(Object onDiskType)
1:     {
1:         if (onDiskType instanceof OldRoutineType)
1:             return ((OldRoutineType) onDiskType).getCatalogType();
1:         return (TypeDescriptor) onDiskType;
1:     }
commit:01b5961
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Types of the parameters. If there are no parameters
1:      * then this may be null (or a zero length array).
1:      */
/////////////////////////////////////////////////////////////////////////
0:                 SanityManager.ASSERT(!(returnType instanceof DataTypeDescriptor));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Types of the parameters. If there are no parameters
1:      * then this may return null (or a zero length array).
1:      */
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the collation type of all string types declared for
1:      * use in this routine to the given collation type.
1:      * @param collationType
1:      */
1:     public void setCollationTypeForAllStringTypes(int collationType)
1:     {
1:         if (parameterCount != 0)
1:         {
1:             for (int p = 0; p < parameterTypes.length; p++)
1:                 parameterTypes[p] = DataTypeDescriptor.getCatalogType(
1:                         parameterTypes[p], collationType);
1:         }
1:         
1:         if (returnType != null)
1:             returnType = DataTypeDescriptor.getCatalogType(returnType, collationType);
1:     }
commit:14d5f00
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (returnType == null) {
/////////////////////////////////////////////////////////////////////////
1: 		if (returnType != null) {
1: 		if ((returnType == null) &&
/////////////////////////////////////////////////////////////////////////
1: 		if (returnType != null) {
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.catalog.types.RoutineAliasInfo
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.catalog.types;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.catalog.AliasInfo;
1: import org.apache.derby.catalog.TypeDescriptor;
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: /**
0:  * Describe a r (procedure or function) alias.
1:  *
0:  * @see AliasInfo
1:  */
1: public class RoutineAliasInfo extends MethodAliasInfo
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 
1: 	private static final String[] SQL_CONTROL = {"MODIFIES SQL DATA", "READS SQL DATA", "CONTAINS SQL", "NO SQL"};
1: 	public static final short MODIFIES_SQL_DATA = 0;
1: 	public static final short READS_SQL_DATA	= 1;
1: 	public static final short CONTAINS_SQL		= 2;
1: 	public static final short NO_SQL			= 3;
1: 
1: 
1: 
1: 	/** PARAMETER STYLE JAVA */
1: 	public static final short PS_JAVA = 0;
1: 
1: 	private int parameterCount;
1: 
1: 	private TypeDescriptor[]	parameterTypes;
1: 	private String[]			parameterNames;
1: 	/**
1: 		IN, OUT, INOUT
1: 	*/
1: 	private int[]				parameterModes;
1: 
1: 	private int dynamicResultSets;
1: 
1: 	/**
1: 		Return type for functions. Null for procedures.
1: 	*/
1: 	private TypeDescriptor	returnType;
1: 
1: 	/**
1: 		Parameter style - always PS_JAVA at the moment.
1: 	*/
1: 	private short parameterStyle;
1: 
1: 	/**
0: 		What SQL is allowed by this procedure.
1: 	*/
0: 	private short	sqlAllowed;
1: 
1: 	/**
1: 		SQL Specific name (future)
1: 	*/
1: 	private String	specificName;
1: 
1: 	/**
1: 		True if the routine is called on null input.
1: 		(always true for procedures).
1: 	*/
1: 	private boolean	calledOnNullInput;
1: 
1: 	public RoutineAliasInfo() {
1: 	}
1: 
1: 	/**
1: 		Create a RoutineAliasInfo for an internal PROCEDURE.
1: 	*/
0: 	public RoutineAliasInfo(String methodName, int parameterCount, String[] parameterNames,
0: 		TypeDescriptor[]	parameterTypes, int[] parameterModes, int dynamicResultSets, short parameterStyle, short sqlAllowed) {
1: 
0: 		this(methodName, parameterCount, parameterNames, parameterTypes, parameterModes, 
0: 			dynamicResultSets, parameterStyle, sqlAllowed, true, (TypeDescriptor) null);
1: 	}
1: 
1: 	/**
1: 		Create a RoutineAliasInfo for a PROCEDURE or FUNCTION
1: 	*/
0: 	public RoutineAliasInfo(String methodName, int parameterCount, String[] parameterNames,
0: 		TypeDescriptor[]	parameterTypes, int[] parameterModes, int dynamicResultSets, short parameterStyle, short sqlAllowed,
0: 		boolean calledOnNullInput, TypeDescriptor returnType)
1: 	{
1: 
1: 		super(methodName);
1: 		this.parameterCount = parameterCount;
0: 		this.parameterNames = parameterNames;
0: 		this.parameterTypes = parameterTypes;
0: 		this.parameterModes = parameterModes;
1: 		this.dynamicResultSets = dynamicResultSets;
1: 		this.parameterStyle = parameterStyle;
0: 		this.sqlAllowed = sqlAllowed;
1: 		this.calledOnNullInput = calledOnNullInput;
1: 		this.returnType = returnType;
1: 
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (parameterCount != 0 && parameterNames.length != parameterCount) {
1: 				SanityManager.THROWASSERT("Invalid parameterNames array " + parameterNames.length + " != " + parameterCount);
1: 			}
1: 			else if (parameterCount == 0 && parameterNames != null && parameterNames.length != 0) {
1: 				SanityManager.THROWASSERT("Invalid parameterNames array " + " not zero " + " != " + parameterCount);
1: 			}
1: 
1: 			if (parameterCount != 0 && parameterTypes.length != parameterCount) {
1: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + parameterTypes.length + " != " + parameterCount);
1: 			}
1: 			else if (parameterCount == 0 && parameterTypes != null && parameterTypes.length != 0) {
1: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + " not zero " + " != " + parameterCount);
1: 			}
1: 
1: 			if (parameterCount != 0 && parameterModes.length != parameterCount) {
1: 				SanityManager.THROWASSERT("Invalid parameterModes array " + parameterModes.length + " != " + parameterCount);
1: 			}
1: 			else if (parameterCount == 0 && parameterModes != null && parameterModes.length != 0) {
1: 				SanityManager.THROWASSERT("Invalid parameterModes array " + " not zero " + " != " + parameterCount);
1: 			}
1: 
1: 			if (returnType != null) {
1: 				if (!((sqlAllowed >= RoutineAliasInfo.READS_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
1: 					SanityManager.THROWASSERT("Invalid sqlAllowed for FUNCTION " + methodName + " " + sqlAllowed);
1: 				}
1: 			} else {
1: 				if (!((sqlAllowed >= RoutineAliasInfo.MODIFIES_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
1: 					SanityManager.THROWASSERT("Invalid sqlAllowed for PROCEDURE " + methodName + " " + sqlAllowed);
1: 				}
1: 				
1: 			}
1: 		}
1: 	}
1: 
1: 	public int getParameterCount() {
1: 		return parameterCount;
1: 	}
1: 
0: 	public TypeDescriptor[] getParameterTypes() {
0: 		return parameterTypes;
1: 	}
1: 
0: 	public int[] getParameterModes() {
0: 		return parameterModes;
1: 	}
0: 	public String[] getParameterNames() {
0: 		return parameterNames;
1: 	}
1: 
1: 	public int getMaxDynamicResultSets() {
1: 		return dynamicResultSets;
1: 	}
1: 
1: 	public short getParameterStyle() {
1: 		return parameterStyle;
1: 	}
1: 
1: 	public short getSQLAllowed() {
0: 		return sqlAllowed;
1: 	}
1: 
1: 	public boolean calledOnNullInput() {
1: 		return calledOnNullInput;
1: 	}
1: 
1: 	public TypeDescriptor getReturnType() {
1: 		return returnType;
1: 	}
1: 
1: 
1: 	// Formatable methods
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal( ObjectInput in )
1: 		 throws IOException, ClassNotFoundException
1: 	{
1: 		super.readExternal(in);
1: 		specificName = (String) in.readObject();
1: 		dynamicResultSets = in.readInt();
1: 		parameterCount = in.readInt();
1: 		parameterStyle = in.readShort();
0: 		sqlAllowed = in.readShort();
0: 		returnType = (TypeDescriptor) in.readObject();
1: 		calledOnNullInput = in.readBoolean();
1: 		in.readInt(); // future expansion.
1: 
1: 		if (parameterCount != 0) {
1: 			parameterNames = new String[parameterCount];
1: 			parameterTypes = new TypeDescriptor[parameterCount];
1: 
1: 			ArrayUtil.readArrayItems(in, parameterNames);
0: 			ArrayUtil.readArrayItems(in, parameterTypes);
1: 			parameterModes = ArrayUtil.readIntArray(in);
1: 
1: 		} else {
1: 			parameterNames = null;
1: 			parameterTypes = null;
1: 			parameterModes = null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException		thrown on error
1: 	 */
1: 	public void writeExternal( ObjectOutput out )
1: 		 throws IOException
1: 	{
1: 		super.writeExternal(out);
1: 		out.writeObject(specificName);
1: 		out.writeInt(dynamicResultSets);
1: 		out.writeInt(parameterCount);
1: 		out.writeShort(parameterStyle);
0: 		out.writeShort(sqlAllowed);
1: 		out.writeObject(returnType);
1: 		out.writeBoolean(calledOnNullInput);
1: 		out.writeInt(0); // future expansion
1: 		if (parameterCount != 0) {
1: 			ArrayUtil.writeArrayItems(out, parameterNames);
1: 			ArrayUtil.writeArrayItems(out, parameterTypes);
1: 			ArrayUtil.writeIntArray(out, parameterModes);
1: 		}
1: 	}
1:  
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
1: 	public	int	getTypeFormatId()	{ return StoredFormatIds.ROUTINE_INFO_V01_ID; }
1: 
1: 	public String toString() {
1: 
1: 		StringBuffer sb = new StringBuffer(100);
1: 		sb.append(getMethodName());
1: 		sb.append('(');
1: 		for (int i = 0; i < parameterCount; i++) {
1: 			if (i != 0)
1: 				sb.append(',');
1: 
1: 			sb.append(RoutineAliasInfo.parameterMode(parameterModes[i]));
1: 			sb.append(' ');
0: 			sb.append(parameterNames[i]);
1: 			sb.append(' ');
1: 			sb.append(parameterTypes[i].getSQLstring());
1: 		}
1: 		sb.append(')');
1: 
0: 		sb.append(" LANGUAGE JAVA PARAMETER STYLE JAVA ");
1: 		sb.append(RoutineAliasInfo.SQL_CONTROL[getSQLAllowed()]);
0: 		if (dynamicResultSets != 0) {
1: 			sb.append(" DYNAMIC RESULT SETS ");
1: 			sb.append(dynamicResultSets);
1: 		}
1: 
1: 		return sb.toString();
1: 	}
1: 
1: 	public static String parameterMode(int parameterMode) {
1: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
1: 			return "IN";
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
1: 			return "OUT";
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
1: 			return "INOUT";
1: 		default:
1: 			return "UNKNOWN";
1: 		}
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2a1abd5
/////////////////////////////////////////////////////////////////////////
1: 	private transient char aliasType;
commit:1fa1fd0
/////////////////////////////////////////////////////////////////////////
1: 	// What type of alias is this: PROCEDURE or FUNCTION?
0: 	private char aliasType;
0: 
/////////////////////////////////////////////////////////////////////////
0: 		setAliasType();
/////////////////////////////////////////////////////////////////////////
0: 		setAliasType();
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Get this alias info as a string.  NOTE: The "ALIASINFO" column
1: 	 * in the SYSALIASES table will return the result of this method
1: 	 * on a ResultSet.getString() call.  That said, since the dblook
1: 	 * utility uses ResultSet.getString() to retrieve ALIASINFO and
1: 	 * to generate the DDL, THIS METHOD MUST RETURN A STRING THAT
1: 	 * IS SYNTACTICALLY VALID, or else the DDL generated by dblook
1: 	 * will be incorrect.
0: 	 */
/////////////////////////////////////////////////////////////////////////
0: 			if (aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) {
1: 			// This is a PROCEDURE.  We only want to print the
1: 			// parameter mode (ex. "IN", "OUT", "INOUT") for procedures--
1: 			// we don't do it for functions since use of the "IN" keyword
1: 			// is not part of the FUNCTION syntax.
0: 				sb.append(RoutineAliasInfo.parameterMode(parameterModes[i]));
0: 				sb.append(' ');
1: 			}
0: 		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR) {
1: 		// this a FUNCTION, so syntax requires us to append the return type.
1: 			sb.append(" RETURNS " + returnType.getSQLstring());
1: 		}
0: 
0: 		if ((aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) &&
1: 			(dynamicResultSets != 0))
1: 		{ // Only print dynamic result sets if this is a PROCEDURE
1: 		  // because it's not valid syntax for FUNCTIONs.
0: 		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR) {
1: 		// this a FUNCTION, so append the syntax telling what to
1: 		// do with a null parameter.
1: 			sb.append(calledOnNullInput ? " CALLED " : " RETURNS NULL ");
1: 			sb.append("ON NULL INPUT");
1: 		}
0: 		
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Set the type of this alias based on whether or not
0: 	 * the returnType is null.
0: 	 */
0: 	private void setAliasType()
0: 	{
0: 		if (returnType == null)
0: 		// must be a PROCEDURE.
0: 			aliasType = AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR;
0: 		else
0: 		// must be a FUNCTION.
0: 			aliasType = AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR;
0: 	}
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.catalog.types;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.ArrayUtil;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: /**
0:  * Describe a r (procedure or function) alias.
0:  *
0:  * @see AliasInfo
0:  */
0: public class RoutineAliasInfo extends MethodAliasInfo
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 
0: 	private static final String[] SQL_CONTROL = {"MODIFIES SQL DATA", "READS SQL DATA", "CONTAINS SQL", "NO SQL"};
0: 	public static final short MODIFIES_SQL_DATA = 0;
0: 	public static final short READS_SQL_DATA	= 1;
0: 	public static final short CONTAINS_SQL		= 2;
0: 	public static final short NO_SQL			= 3;
0: 
0: 
0: 
0: 	/** PARAMETER STYLE JAVA */
0: 	public static final short PS_JAVA = 0;
0: 
0: 	private int parameterCount;
0: 
0: 	private TypeDescriptor[]	parameterTypes;
0: 	private String[]			parameterNames;
0: 	/**
0: 		IN, OUT, INOUT
0: 	*/
0: 	private int[]				parameterModes;
0: 
0: 	private int dynamicResultSets;
0: 
0: 	/**
0: 		Return type for functions. Null for procedures.
0: 	*/
0: 	private TypeDescriptor	returnType;
0: 
0: 	/**
0: 		Parameter style - always PS_JAVA at the moment.
0: 	*/
0: 	private short parameterStyle;
0: 
0: 	/**
0: 		What SQL is allowed by this procedure.
0: 	*/
0: 	private short	sqlAllowed;
0: 
0: 	/**
0: 		SQL Specific name (future)
0: 	*/
0: 	private String	specificName;
0: 
0: 	/**
0: 		True if the routine is called on null input.
0: 		(always true for procedures).
0: 	*/
0: 	private boolean	calledOnNullInput;
0: 
0: 	public RoutineAliasInfo() {
0: 	}
0: 
0: 	/**
0: 		Create a RoutineAliasInfo for an internal PROCEDURE.
0: 	*/
0: 	public RoutineAliasInfo(String methodName, int parameterCount, String[] parameterNames,
0: 		TypeDescriptor[]	parameterTypes, int[] parameterModes, int dynamicResultSets, short parameterStyle, short sqlAllowed) {
0: 
0: 		this(methodName, parameterCount, parameterNames, parameterTypes, parameterModes, 
0: 			dynamicResultSets, parameterStyle, sqlAllowed, true, (TypeDescriptor) null);
0: 	}
0: 
0: 	/**
0: 		Create a RoutineAliasInfo for a PROCEDURE or FUNCTION
0: 	*/
0: 	public RoutineAliasInfo(String methodName, int parameterCount, String[] parameterNames,
0: 		TypeDescriptor[]	parameterTypes, int[] parameterModes, int dynamicResultSets, short parameterStyle, short sqlAllowed,
0: 		boolean calledOnNullInput, TypeDescriptor returnType)
0: 	{
0: 
0: 		super(methodName);
0: 		this.parameterCount = parameterCount;
0: 		this.parameterNames = parameterNames;
0: 		this.parameterTypes = parameterTypes;
0: 		this.parameterModes = parameterModes;
0: 		this.dynamicResultSets = dynamicResultSets;
0: 		this.parameterStyle = parameterStyle;
0: 		this.sqlAllowed = sqlAllowed;
0: 		this.calledOnNullInput = calledOnNullInput;
0: 		this.returnType = returnType;
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (parameterCount != 0 && parameterNames.length != parameterCount) {
0: 				SanityManager.THROWASSERT("Invalid parameterNames array " + parameterNames.length + " != " + parameterCount);
0: 			}
0: 			else if (parameterCount == 0 && parameterNames != null && parameterNames.length != 0) {
0: 				SanityManager.THROWASSERT("Invalid parameterNames array " + " not zero " + " != " + parameterCount);
0: 			}
0: 
0: 			if (parameterCount != 0 && parameterTypes.length != parameterCount) {
0: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + parameterTypes.length + " != " + parameterCount);
0: 			}
0: 			else if (parameterCount == 0 && parameterTypes != null && parameterTypes.length != 0) {
0: 				SanityManager.THROWASSERT("Invalid parameterTypes array " + " not zero " + " != " + parameterCount);
0: 			}
0: 
0: 			if (parameterCount != 0 && parameterModes.length != parameterCount) {
0: 				SanityManager.THROWASSERT("Invalid parameterModes array " + parameterModes.length + " != " + parameterCount);
0: 			}
0: 			else if (parameterCount == 0 && parameterModes != null && parameterModes.length != 0) {
0: 				SanityManager.THROWASSERT("Invalid parameterModes array " + " not zero " + " != " + parameterCount);
0: 			}
0: 
0: 			if (returnType != null) {
0: 				if (!((sqlAllowed >= RoutineAliasInfo.READS_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
0: 					SanityManager.THROWASSERT("Invalid sqlAllowed for FUNCTION " + methodName + " " + sqlAllowed);
0: 				}
0: 			} else {
0: 				if (!((sqlAllowed >= RoutineAliasInfo.MODIFIES_SQL_DATA) && (sqlAllowed <= RoutineAliasInfo.NO_SQL))) {
0: 					SanityManager.THROWASSERT("Invalid sqlAllowed for PROCEDURE " + methodName + " " + sqlAllowed);
0: 				}
0: 				
0: 			}
0: 		}
0: 	}
0: 
0: 	public int getParameterCount() {
0: 		return parameterCount;
0: 	}
0: 
0: 	public TypeDescriptor[] getParameterTypes() {
0: 		return parameterTypes;
0: 	}
0: 
0: 	public int[] getParameterModes() {
0: 		return parameterModes;
0: 	}
0: 	public String[] getParameterNames() {
0: 		return parameterNames;
0: 	}
0: 
0: 	public int getMaxDynamicResultSets() {
0: 		return dynamicResultSets;
0: 	}
0: 
0: 	public short getParameterStyle() {
0: 		return parameterStyle;
0: 	}
0: 
0: 	public short getSQLAllowed() {
0: 		return sqlAllowed;
0: 	}
0: 
0: 	public boolean calledOnNullInput() {
0: 		return calledOnNullInput;
0: 	}
0: 
0: 	public TypeDescriptor getReturnType() {
0: 		return returnType;
0: 	}
0: 
0: 
0: 	// Formatable methods
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal( ObjectInput in )
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		super.readExternal(in);
0: 		specificName = (String) in.readObject();
0: 		dynamicResultSets = in.readInt();
0: 		parameterCount = in.readInt();
0: 		parameterStyle = in.readShort();
0: 		sqlAllowed = in.readShort();
0: 		returnType = (TypeDescriptor) in.readObject();
0: 		calledOnNullInput = in.readBoolean();
0: 		in.readInt(); // future expansion.
0: 
0: 		if (parameterCount != 0) {
0: 			parameterNames = new String[parameterCount];
0: 			parameterTypes = new TypeDescriptor[parameterCount];
0: 
0: 			ArrayUtil.readArrayItems(in, parameterNames);
0: 			ArrayUtil.readArrayItems(in, parameterTypes);
0: 			parameterModes = ArrayUtil.readIntArray(in);
0: 
0: 		} else {
0: 			parameterNames = null;
0: 			parameterTypes = null;
0: 			parameterModes = null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException		thrown on error
0: 	 */
0: 	public void writeExternal( ObjectOutput out )
0: 		 throws IOException
0: 	{
0: 		super.writeExternal(out);
0: 		out.writeObject(specificName);
0: 		out.writeInt(dynamicResultSets);
0: 		out.writeInt(parameterCount);
0: 		out.writeShort(parameterStyle);
0: 		out.writeShort(sqlAllowed);
0: 		out.writeObject(returnType);
0: 		out.writeBoolean(calledOnNullInput);
0: 		out.writeInt(0); // future expansion
0: 		if (parameterCount != 0) {
0: 			ArrayUtil.writeArrayItems(out, parameterNames);
0: 			ArrayUtil.writeArrayItems(out, parameterTypes);
0: 			ArrayUtil.writeIntArray(out, parameterModes);
0: 		}
0: 	}
0:  
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.ROUTINE_INFO_V01_ID; }
0: 
0: 	public String toString() {
0: 
0: 		StringBuffer sb = new StringBuffer(100);
0: 		sb.append(getMethodName());
0: 		sb.append('(');
0: 		for (int i = 0; i < parameterCount; i++) {
0: 			if (i != 0)
0: 				sb.append(',');
0: 
0: 			sb.append(RoutineAliasInfo.parameterMode(parameterModes[i]));
0: 			sb.append(' ');
0: 			sb.append(parameterNames[i]);
0: 			sb.append(' ');
0: 			sb.append(parameterTypes[i].getSQLstring());
0: 		}
0: 		sb.append(')');
0: 
0: 		sb.append(" LANGUAGE JAVA PARAMETER STYLE JAVA ");
0: 		sb.append(RoutineAliasInfo.SQL_CONTROL[getSQLAllowed()]);
0: 		if (dynamicResultSets != 0) {
0: 			sb.append(" DYNAMIC RESULT SETS ");
0: 			sb.append(dynamicResultSets);
0: 		}
0: 
0: 		return sb.toString();
0: 	}
0: 
0: 	public static String parameterMode(int parameterMode) {
0: 		switch (parameterMode) {
0: 		case JDBC30Translation.PARAMETER_MODE_IN:
0: 			return "IN";
0: 		case JDBC30Translation.PARAMETER_MODE_OUT:
0: 			return "OUT";
0: 		case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 			return "INOUT";
0: 		default:
0: 			return "UNKNOWN";
0: 		}
0: 	}
0: }
============================================================================