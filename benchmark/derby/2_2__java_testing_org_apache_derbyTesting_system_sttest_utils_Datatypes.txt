1:9bbe2e4: /*
6:9bbe2e4: 
1:9bbe2e4:  Derby - Class org.apache.derbyTesting.system.sttest.Datatypes
1:9bbe2e4: 
1:9bbe2e4:  Licensed to the Apache Software Foundation (ASF) under one or more
1:9bbe2e4:  contributor license agreements.  See the NOTICE file distributed with
1:9bbe2e4:  this work for additional information regarding copyright ownership.
1:9bbe2e4:  The ASF licenses this file to You under the Apache License, Version 2.0
1:9bbe2e4:  (the "License"); you may not use this file except in compliance with
1:9bbe2e4:  the License.  You may obtain a copy of the License at
1:9bbe2e4: 
1:9bbe2e4:  http://www.apache.org/licenses/LICENSE-2.0
1:9bbe2e4: 
1:9bbe2e4:  Unless required by applicable law or agreed to in writing, software
1:9bbe2e4:  distributed under the License is distributed on an "AS IS" BASIS,
1:9bbe2e4:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9bbe2e4:  See the License for the specific language governing permissions and
1:9bbe2e4:  limitations under the License.
1:9bbe2e4: 
1:9bbe2e4:  */
1:9bbe2e4: 
1:9bbe2e4: package org.apache.derbyTesting.system.sttest.utils;
1:9bbe2e4: 
1:9bbe2e4: import java.io.InputStream;
1:a5430dd: import java.io.Reader;
1:9bbe2e4: import java.math.BigDecimal;
1:9bbe2e4: import java.sql.Connection;
1:9bbe2e4: import java.sql.Date;
1:9bbe2e4: import java.sql.PreparedStatement;
1:9bbe2e4: import java.sql.ResultSet;
1:9bbe2e4: import java.sql.ResultSetMetaData;
1:9bbe2e4: import java.sql.SQLException;
1:9bbe2e4: import java.sql.Statement;
1:9bbe2e4: import java.sql.Time;
1:9bbe2e4: import java.sql.Timestamp;
1:9bbe2e4: import java.util.Random;
1:9bbe2e4: import org.apache.derby.tools.JDBCDisplayUtil;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:a5430dd: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:9bbe2e4: 
1:9bbe2e4: /**
1:9bbe2e4:  * This class is used to insert, delete and updated the rows
1:9bbe2e4:  */
1:9bbe2e4: public class Datatypes {
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TCHAR = 0;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TBLOB = 1;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TCLOB = 2;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TDATE = 3;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TDECIMAL = 4;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TDECIMALNN = 5;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TDOUBLE = 6;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TFLOAT = 7;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TINT = 8;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TLONGINT = 9;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TNUMERICLARGE = 10;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TREAL = 11;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TSMALLINT = 12;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TTIME = 13;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TTIMESTAMP = 14;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int TVARCHAR = 15;
1:9bbe2e4: 
1:9bbe2e4: 	public static final int NUMTYPES = 15;
1:9bbe2e4: 
1:a5430dd: 	public static Random Rn = new Random();
1:9bbe2e4: 
1:9bbe2e4: 	public static String[] colnames = { "t_char", "t_blob", "t_clob", "t_date",
1:9bbe2e4: 		"t_decimal", "t_decimal_nn", "t_double", "t_float", "t_int",
1:9bbe2e4: 		"t_longint", "t_numeric_large", "t_real", "t_smallint", "t_time",
1:9bbe2e4: 		"t_timestamp", "t_varchar"
1:9bbe2e4: 
1:9bbe2e4: 	};
1:9bbe2e4: 
1:9bbe2e4: 	public static synchronized void add_one_row(Connection conn, int thread_id)
1:9bbe2e4: 	throws Exception {
1:9bbe2e4: 		try {
1:9bbe2e4: 			//initialize();
1:9bbe2e4: 			PreparedStatement ps = conn.prepareStatement(
1:9bbe2e4: 					" insert into Datatypes (id,t_char,t_blob," + "t_clob,"
1:9bbe2e4: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1:9bbe2e4: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1:9bbe2e4: 					+ " t_real, t_smallint, t_time, t_timestamp,"
1:9bbe2e4: 					+ " t_varchar) values ("
1:a5430dd: 					+ " ?,?, ?,?, ?, ?,?, ?, ?, ?,?, ?, ?, ?, ?, ?,?)" 
1:a5430dd: 					/* autoincrement feature added, so we need to specify the
1:a5430dd: 					 * column name for prepared statement, otherwise auto increment
1:a5430dd: 					 * column will think it is trying to update/insert a null value
1:a5430dd: 					 * to the column.
1:a5430dd: 					 */
1:9bbe2e4: 					, Statement.RETURN_GENERATED_KEYS);
1:a5430dd: 			InputStream streamIn = null;
1:a5430dd: 			Reader streamReader = null;
1:a5430dd: 			int ind = Rn.nextInt();
1:9bbe2e4: 			double x;
1:9bbe2e4: 			Date dt = new Date(1);
1:9bbe2e4: 			Time tt = new Time(1);
1:9bbe2e4: 			Timestamp ts = new Timestamp(1);
1:9bbe2e4: 			String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1:9bbe2e4: 			ps.setInt(1, ind);
1:9bbe2e4: 			// scramble the string
1:9bbe2e4: 			int i1 = Math.abs(ind % 100);
1:9bbe2e4: 			String cs2 = cs.substring(i1, 99) + cs.substring(0, i1);
1:9bbe2e4: 			int i2 = i1 < 89 ? i1 + 10 : i1;
1:9bbe2e4: 			ps.setString(2, cs2.substring(0, i2));
1:9bbe2e4: 			//"t_blob"
1:a5430dd: 			int blobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1:a5430dd: 			streamIn = new LoopingAlphabetStream(blobLength);
1:a5430dd: 			ps.setBinaryStream(3, streamIn, blobLength);
1:9bbe2e4: 			//"t_clob
1:a5430dd: 			int clobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1:a5430dd: 			streamReader = new LoopingAlphabetReader(clobLength, CharAlphabet
1:a5430dd: 					.modernLatinLowercase());
1:a5430dd: 			ps.setCharacterStream(4, streamReader, clobLength);
1:9bbe2e4: 			//"t_ndate"
1:a5430dd: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1:9bbe2e4: 			ps.setDate(5, dt);
1:9bbe2e4: 			//"t_decimal"
1:a5430dd: 			x = Math.abs(Rn.nextInt() % 18);
1:9bbe2e4: 			if (x > 5)
1:9bbe2e4: 				x = 5;
1:a5430dd: 			ps.setDouble(6, Math.abs(Rn.nextDouble() * Math.pow(10, x)));
1:9bbe2e4: 			//"t_decimal_nn"
1:a5430dd: 			ps.setDouble(7, Rn.nextDouble());
1:9bbe2e4: 			//"t_double"
1:a5430dd: 			ps.setDouble(8, Rn.nextDouble()
1:a5430dd: 					* Math.pow(10, Math.abs(Rn.nextInt() % 300)));
1:9bbe2e4: 			//"t_float"
1:a5430dd: 			ps.setFloat(9, Rn.nextFloat()
1:a5430dd: 					* (float) Math.pow(10, Math.abs(Rn.nextInt() % 30)));
1:9bbe2e4: 			//"t_int"
1:a5430dd: 			ps.setInt(10, Rn.nextInt());
1:9bbe2e4: 			//"t_longint"
1:a5430dd: 			ps.setLong(11, Rn.nextLong());
1:9bbe2e4: 			//"t_numeric_large"
1:a5430dd: 			x = Math.abs(Rn.nextInt() % 30);
1:9bbe2e4: 			if (x > 30)
1:9bbe2e4: 				x = 31;
1:a5430dd: 			ps.setDouble(12, Math.abs(Rn.nextDouble() * Math.pow(10, x)));
1:9bbe2e4: 			//"t_real"
1:a5430dd: 			ps.setFloat(13, Rn.nextFloat()
1:a5430dd: 					* (float) Math.pow(10, Math.abs(Rn.nextInt() % 7)));
1:9bbe2e4: 			//"t_smallint"
1:a5430dd: 			ps.setInt(14, Rn.nextInt() % (256 * 128));
1:9bbe2e4: 			//"t_time"
1:a5430dd: 			tt.setTime(Math.abs(Rn.nextInt()));
1:9bbe2e4: 			ps.setTime(15, tt);
1:9bbe2e4: 			//"t_timestamp"
1:a5430dd: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1:9bbe2e4: 			ps.setTimestamp(16, ts);
1:9bbe2e4: 			//"t_varchar"
1:a5430dd: 			ps.setString(17, cs.substring(Math.abs(Rn.nextInt() % 100)));
1:9bbe2e4: 			int rows = ps.executeUpdate();
1:9bbe2e4: 			if (rows == 1) {
1:9bbe2e4: 
1:9bbe2e4: 				ResultSet rs = ps.getGeneratedKeys();
1:9bbe2e4: 
1:9bbe2e4: 				while (rs.next()) {
1:9bbe2e4: 					ResultSetMetaData rsmd = rs.getMetaData();
1:9bbe2e4: 					int numCols = rsmd.getColumnCount();
2:9bbe2e4: 				}
1:9bbe2e4: 			} else
1:9bbe2e4: 				System.out.println("t" + thread_id + " insert failed");
1:a5430dd: 			streamReader.close();
1:a5430dd: 			streamIn.close();
1:9bbe2e4: 
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 		}
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	//pick quantity number of rows randomly and delete them
1:9bbe2e4: 	public static int delete_some(Connection conn, int thread_id, int quantity)
1:9bbe2e4: 	throws Exception {
1:9bbe2e4: 		PreparedStatement ps = null;
1:9bbe2e4: 		int list[] = pick_some(conn, thread_id, quantity);
1:9bbe2e4: 		//delete them
1:9bbe2e4: 		int rows = 0;
1:9bbe2e4: 		try {
1:9bbe2e4: 			ps = conn.prepareStatement(" delete from  Datatypes where id = ?");
1:9bbe2e4: 			for (int i = 0; i < quantity; i++) {
1:9bbe2e4: 				ps.setInt(1, list[i]);
1:9bbe2e4: 				rows += ps.executeUpdate();
1:9bbe2e4: 			}
1:9bbe2e4: 			if (ps != null)
1:9bbe2e4: 				ps.close();
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 			return (rows);
1:9bbe2e4: 		}
1:9bbe2e4: 		// all deletes in a single transaction, to force some overlap of
1:9bbe2e4: 		// transactions
1:9bbe2e4: 		// by different threads
1:9bbe2e4: 		conn.commit();
1:9bbe2e4: 		return (rows);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	//get a random set of row ids
1:9bbe2e4: 	public static int[] pick_some(Connection conn, int thread_id, int quantity)
1:9bbe2e4: 	throws Exception {
1:9bbe2e4: 		System.out.println("quantity in pick_some is: " + quantity);
1:9bbe2e4: 		int ind = 0;
1:9bbe2e4: 		PreparedStatement ps = null;
1:9bbe2e4: 		ResultSet rs = null;
1:9bbe2e4: 		//pick the rows
1:9bbe2e4: 		try {
1:9bbe2e4: 			ps = conn
1:bbde618: 			.prepareStatement(" select id from  Datatypes where id >= ?");
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 			return (null);
1:9bbe2e4: 		}
1:9bbe2e4: 		int list[] = new int[quantity];
1:9bbe2e4: 		int j = 0;
1:9bbe2e4: 		for (int i = 0; i < quantity; i++) {
1:a5430dd: 			ind = Rn.nextInt();
1:9bbe2e4: 			try {
1:9bbe2e4: 				ps.setInt(1, ind);
1:9bbe2e4: 				rs = ps.executeQuery();
1:9bbe2e4: 				if (rs.next()) {
1:9bbe2e4: 					j = rs.getInt(1);
1:bbde618: 					//if the id is null, find another row.
1:9bbe2e4: 					if (rs.wasNull()) {
1:9bbe2e4: 						i--;
1:9bbe2e4: 						continue;
1:9bbe2e4: 					}
1:9bbe2e4: 					list[i] = j;
1:9bbe2e4: 
1:9bbe2e4: 				}
1:bbde618: 				else {
1:bbde618: 					// the random number is higher than the
1:bbde618: 					// highest id value in the database. 
1:bbde618: 					// delete would fail. Pick another.
1:bbde618: 					i--;
1:bbde618: 					continue;
1:bbde618: 				}
1:9bbe2e4: 				//don't worry about consistency; if row with this id
1:9bbe2e4: 				//gets changed by another thread we will just forge ahead;
1:9bbe2e4: 				//otherwise we gets lots of deadlocks
1:9bbe2e4: 				conn.commit();
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				if (se.getNextException() == null)
1:9bbe2e4: 					throw se;
1:9bbe2e4: 				String m = se.getNextException().getSQLState();
1:9bbe2e4: 				System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 						+ " SQLSTATE: " + m);
1:9bbe2e4: 				return (null);
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:9bbe2e4: 		if (rs != null)
1:9bbe2e4: 			rs.close();
1:9bbe2e4: 		if (ps != null)
1:9bbe2e4: 			ps.close();
1:9bbe2e4: 		return (list);
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public static void delete_one_row(Connection conn, int thread_id)
1:9bbe2e4: 	throws Exception {
1:9bbe2e4: 
1:9bbe2e4: 		PreparedStatement ps = null;
1:9bbe2e4: 		PreparedStatement ps2 = null;
1:9bbe2e4: 		String column = null;
1:9bbe2e4: 		int ind = 0;
1:9bbe2e4: 		ResultSet rs = null;
1:a5430dd: 		ind = Math.abs(Rn.nextInt());
1:9bbe2e4: 		while (ind % NUMTYPES == TDECIMAL || ind % NUMTYPES == TVARCHAR
1:9bbe2e4: 				|| ind % NUMTYPES == TCHAR)
1:a5430dd: 			ind = Math.abs(Rn.nextInt());
1:9bbe2e4: 		column = colnames[ind % NUMTYPES];
1:9bbe2e4: 		try {
1:9bbe2e4: 			ps = conn.prepareStatement(" select cast (max (" + column + ") as "
1:9bbe2e4: 					+ " char(120)) from Datatypes where " + column + " <= ? ");
1:9bbe2e4: 			ps2 = conn.prepareStatement(" delete from  Datatypes where "
1:9bbe2e4: 					+ column + " = ?");
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 			return;
1:9bbe2e4: 		}
1:9bbe2e4: 		String ds = null;
1:9bbe2e4: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1:9bbe2e4: 		double d = 0.0;
1:9bbe2e4: 		float f = 0;
1:9bbe2e4: 		BigDecimal bdec = null;
1:9bbe2e4: 		switch (ind % NUMTYPES) {
1:9bbe2e4: 		case TCHAR:
1:a5430dd: 			ds = cs.substring(Math.abs(Rn.nextInt() % 100));
1:9bbe2e4: 			ps.setString(1, ds);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDATE:
1:9bbe2e4: 			Date dt = new Date(1);
1:a5430dd: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1:9bbe2e4: 			ps.setString(1, dt.toString());
1:9bbe2e4: 			ds = dt.toString();
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDECIMAL:
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 18);
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps.setString(1, String.valueOf(bdec));
1:9bbe2e4: 			ds = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDECIMALNN:
1:a5430dd: 			d = Rn.nextDouble();
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps.setString(1, String.valueOf(bdec));
1:9bbe2e4: 			ds = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDOUBLE:
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 300);
1:9bbe2e4: 			ps.setString(1, String.valueOf(d));
1:9bbe2e4: 			ds = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TFLOAT:
1:a5430dd: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 30);
1:9bbe2e4: 			ps.setString(1, String.valueOf(f));
1:9bbe2e4: 			ds = String.valueOf(f);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TINT:
1:a5430dd: 			ps.setString(1, String.valueOf(Rn.nextInt()));
1:a5430dd: 			ds = String.valueOf(Rn.nextInt());
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TLONGINT:
1:a5430dd: 			ps.setString(1, String.valueOf(Rn.nextLong()));
1:a5430dd: 			ds = String.valueOf(Rn.nextLong());
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TNUMERICLARGE:
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 50);
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps.setString(1, String.valueOf(bdec));
1:9bbe2e4: 			ds = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TREAL:
1:a5430dd: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 7);
1:9bbe2e4: 			ps.setString(1, String.valueOf(f));
1:9bbe2e4: 			ds = String.valueOf(f);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TSMALLINT:
1:a5430dd: 			int i = Rn.nextInt() % (256 * 128);
1:9bbe2e4: 			ps.setString(1, String.valueOf(i));
1:9bbe2e4: 			ds = String.valueOf(i);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TTIME:
1:9bbe2e4: 			Time tt = new Time(1);
1:a5430dd: 			tt.setTime(Math.abs(Rn.nextInt()));
1:9bbe2e4: 			ps.setString(1, "time'" + tt.toString() + "'");
1:9bbe2e4: 			ds = "time'" + tt.toString() + "'";
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TTIMESTAMP:
1:9bbe2e4: 			Timestamp ts = new Timestamp(1);
1:a5430dd: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1:9bbe2e4: 			ps.setString(1, "timestamp'" + ts.toString() + "'");
1:9bbe2e4: 			ds = "timestamp'" + ts.toString() + "'";
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TVARCHAR:
1:a5430dd: 			ds = cs.substring(Math.abs(Rn.nextInt() % 100));
1:9bbe2e4: 			ps.setString(1, ds);
1:9bbe2e4: 			break;
1:9bbe2e4: 		}
1:9bbe2e4: 		String ds3 = null;
1:9bbe2e4: 		String ds4 = null;
1:9bbe2e4: 		int rows = 0;
1:9bbe2e4: 		boolean cleanuponly = false;
1:9bbe2e4: 		try {
1:9bbe2e4: 			rs = ps.executeQuery();
1:9bbe2e4: 			if (rs.next()) {
1:9bbe2e4: 				ds3 = rs.getString(1);
1:9bbe2e4: 				if (rs.wasNull()) {
1:9bbe2e4: 					cleanuponly = true;
2:9bbe2e4: 				} else {
1:9bbe2e4: 					ds4 = ds3.trim();
1:9bbe2e4: 					ds3 = ds4;
1:9bbe2e4: 				}
1:9bbe2e4: 			}
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 		}
1:9bbe2e4: 		if (ps != null)
1:9bbe2e4: 			try {
1:9bbe2e4: 				ps.close();
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				if (se.getNextException() == null)
1:9bbe2e4: 					throw se;
1:9bbe2e4: 				String m = se.getNextException().getSQLState();
1:9bbe2e4: 				System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 						+ " SQLSTATE: " + m);
1:9bbe2e4: 			}
1:9bbe2e4: 			if (rs != null)
1:9bbe2e4: 				try {
1:9bbe2e4: 					rs.close();
1:9bbe2e4: 				} catch (SQLException se) {
1:9bbe2e4: 					if (se.getNextException() == null)
1:9bbe2e4: 						throw se;
1:9bbe2e4: 					String m = se.getNextException().getSQLState();
1:9bbe2e4: 					System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 							+ " SQLSTATE: " + m);
1:9bbe2e4: 				}
1:9bbe2e4: 				if (cleanuponly == false) {
1:9bbe2e4: 					try {
1:9bbe2e4: 						ps2.setString(1, ds3);
1:9bbe2e4: 						rows = ps2.executeUpdate();
1:9bbe2e4: 
1:9bbe2e4: 					} catch (SQLException se) {
1:9bbe2e4: 						if (se.getNextException() == null)
1:9bbe2e4: 							throw se;
1:9bbe2e4: 						String m = se.getNextException().getSQLState();
1:9bbe2e4: 						System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 								+ " SQLSTATE: " + m);
1:9bbe2e4: 					}
1:9bbe2e4: 
1:a5430dd: 					if (rows < 0)
1:9bbe2e4: 						System.out.println("t" + thread_id + " delete failed.");
1:9bbe2e4: 				}
1:9bbe2e4: 				if (ps2 != null)
1:9bbe2e4: 					try {
1:9bbe2e4: 						ps2.close();
1:9bbe2e4: 					} catch (SQLException se) {
1:9bbe2e4: 						if (se.getNextException() == null)
1:9bbe2e4: 							throw se;
1:9bbe2e4: 						String m = se.getNextException().getSQLState();
1:9bbe2e4: 						System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 								+ " SQLSTATE: " + m);
1:9bbe2e4: 					}
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public static synchronized void update_one_row(Connection conn,
1:9bbe2e4: 			int thread_id) throws Exception {
1:9bbe2e4: 		PreparedStatement ps2 = null;
1:9bbe2e4: 		Statement stmt = conn.createStatement();
1:9bbe2e4: 		ResultSet rs;
1:9bbe2e4: 		String column = null;
1:9bbe2e4: 		int ind = 0;
1:9bbe2e4: 		long max = 0;
1:9bbe2e4: 		long min = 0;
1:9bbe2e4: 		double x;
1:9bbe2e4: 		long id_to_update;
1:a5430dd: 		InputStream streamIn = null;
1:a5430dd: 		Reader streamReader = null;
1:9bbe2e4: 		rs = stmt.executeQuery("select max(serialkey) from Datatypes");
1:9bbe2e4: 		while (rs.next())
1:9bbe2e4: 			max = rs.getLong(1);
1:9bbe2e4: 		rs = stmt.executeQuery("select min(serialkey) from Datatypes");
1:9bbe2e4: 		while (rs.next())
1:9bbe2e4: 			min = rs.getLong(1);
1:a5430dd: 		id_to_update = (min + 1) + (Math.abs(Rn.nextLong()) % (max - min));
1:9bbe2e4: 		if (id_to_update == 0)
1:9bbe2e4: 			id_to_update = 1;
1:a5430dd: 		ind = Math.abs(Rn.nextInt());
1:9bbe2e4: 		column = colnames[ind % NUMTYPES];
1:9bbe2e4: 		try {
1:9bbe2e4: 			conn
1:9bbe2e4: 			.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:9bbe2e4: 			ps2 = conn.prepareStatement(" update Datatypes set " + column
1:9bbe2e4: 					+ " = ? " + " where serialkey = " + id_to_update);
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			return;
1:9bbe2e4: 		}
1:9bbe2e4: 		String ds = null;
1:9bbe2e4: 		String ds2 = null;
1:9bbe2e4: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1:9bbe2e4: 		double d = 0.0;
1:9bbe2e4: 		float f = 0;
1:9bbe2e4: 		BigDecimal bdec = null;
1:9bbe2e4: 		int type = (ind % NUMTYPES);
1:9bbe2e4: 		switch (type) {
1:9bbe2e4: 		case TCHAR:
1:a5430dd: 			ds2 = cs.substring(Math.abs(Rn.nextInt() % 100));
1:9bbe2e4: 			ps2.setString(1, ds2);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDATE:
1:9bbe2e4: 			Date dt = new Date(1);
1:a5430dd: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1:a5430dd: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1:9bbe2e4: 			ps2.setDate(1, dt);
1:9bbe2e4: 			ds2 = dt.toString();
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDECIMAL:
1:a5430dd: 			x = Math.abs(Rn.nextInt() % 18);
1:9bbe2e4: 			if (x > 5)
1:9bbe2e4: 				x = 5;
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, x);
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps2.setBigDecimal(1, bdec);
1:9bbe2e4: 			ds2 = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TDECIMALNN:
1:9bbe2e4: 			ds = String.valueOf(d);
1:a5430dd: 			d = Rn.nextDouble();
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps2.setBigDecimal(1, bdec);
1:9bbe2e4: 			ds2 = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 
1:9bbe2e4: 		case TDOUBLE:
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 300);
1:9bbe2e4: 			ps2.setDouble(1, d);
1:9bbe2e4: 			ds2 = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TFLOAT:
1:9bbe2e4: 			ds = String.valueOf(f);
1:a5430dd: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 30);
1:9bbe2e4: 			ps2.setFloat(1, f);
1:9bbe2e4: 			ds2 = String.valueOf(f);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TINT:
1:a5430dd: 			int i = Rn.nextInt();
1:9bbe2e4: 			ds2 = String.valueOf(i);
1:9bbe2e4: 			ps2.setInt(1, i);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TLONGINT:
1:a5430dd: 			long l = Rn.nextLong();
1:9bbe2e4: 			ds2 = String.valueOf(l);
1:9bbe2e4: 			ps2.setLong(1, l);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TNUMERICLARGE:
1:9bbe2e4: 			ds = String.valueOf(d);
1:a5430dd: 			x = Math.abs(Rn.nextInt() % 30);
1:9bbe2e4: 			if (x > 30)
1:9bbe2e4: 				x = 31;
1:a5430dd: 			d = Rn.nextDouble() * Math.pow(10, x);
1:9bbe2e4: 			bdec = new BigDecimal(d);
1:9bbe2e4: 			ps2.setBigDecimal(1, bdec);
1:9bbe2e4: 			ds2 = String.valueOf(d);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TREAL:
1:9bbe2e4: 			ds = String.valueOf(f);
1:a5430dd: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 7);
1:9bbe2e4: 			ps2.setFloat(1, f);
1:9bbe2e4: 			ds2 = String.valueOf(f);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TSMALLINT:
1:a5430dd: 			i = Rn.nextInt() % (256 * 128);
1:9bbe2e4: 			ds = String.valueOf(i);
1:9bbe2e4: 			short si = (short) i;
1:9bbe2e4: 			ps2.setShort(1, si);
1:9bbe2e4: 			ds2 = String.valueOf(si);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TTIME:
1:9bbe2e4: 			Time tt = new Time(1);
1:a5430dd: 			tt.setTime(Math.abs(Rn.nextInt()));
1:9bbe2e4: 			ps2.setTime(1, tt);
1:9bbe2e4: 			ds2 = tt.toString();
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TTIMESTAMP:
1:9bbe2e4: 			Timestamp ts = new Timestamp(1);
1:a5430dd: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1:9bbe2e4: 			ps2.setTimestamp(1, ts);
1:9bbe2e4: 			ds2 = ts.toString();
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TVARCHAR:
1:a5430dd: 			ds2 = cs.substring(Math.abs(Rn.nextInt() % 100));
1:9bbe2e4: 			ps2.setString(1, ds2);
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TBLOB:
1:a5430dd: 			int blobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1:a5430dd: 			streamIn = new LoopingAlphabetStream(blobLength);
1:a5430dd: 			ps2.setBinaryStream(1, streamIn, blobLength);
1:9bbe2e4: 
1:9bbe2e4: 			break;
1:9bbe2e4: 		case TCLOB:
1:a5430dd: 			int clobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1:a5430dd: 			streamReader = new LoopingAlphabetReader(clobLength, CharAlphabet
1:a5430dd: 					.modernLatinLowercase());
1:a5430dd: 			ps2.setCharacterStream(1, streamReader, clobLength);
1:9bbe2e4: 			break;
1:9bbe2e4: 		}
1:9bbe2e4: 		int rows = 0;
1:9bbe2e4: 		boolean cleanuponly = false;
1:9bbe2e4: 		if (cleanuponly == false) {
1:9bbe2e4: 			try {
1:9bbe2e4: 				rows = ps2.executeUpdate();
1:9bbe2e4: 
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				if (se.getNextException() == null)
1:9bbe2e4: 					throw se;
1:9bbe2e4: 				String m = se.getNextException().getSQLState();
1:9bbe2e4: 				System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 						+ " SQLSTATE: " + m);
1:9bbe2e4: 			}
1:a5430dd: 			if (rows < 0)
1:9bbe2e4: 				System.out.println("t" + thread_id + " update failed.");
1:9bbe2e4: 		}
1:7e57d4b: 		if (streamReader != null)
1:7e57d4b: 			streamReader.close();
1:7e57d4b: 		if (streamIn !=null)
1:7e57d4b: 			streamIn.close();
1:9bbe2e4: 		if (ps2 != null)
1:9bbe2e4: 			try {
1:9bbe2e4: 				ps2.close();
1:9bbe2e4: 				rs.close();
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				if (se.getNextException() == null)
1:9bbe2e4: 					throw se;
1:9bbe2e4: 				String m = se.getNextException().getSQLState();
1:9bbe2e4: 				System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 						+ " SQLSTATE: " + m);
1:9bbe2e4: 			}
1:9bbe2e4: 	}
1:9bbe2e4: 
1:9bbe2e4: 	public static synchronized int get_table_count(Connection conn)
1:9bbe2e4: 	throws Exception {
1:9bbe2e4: 		PreparedStatement ps = null;
1:9bbe2e4: 		ResultSet rs = null;
1:9bbe2e4: 		int rows = 0;
1:9bbe2e4: 		boolean locked = false;
1:9bbe2e4: 		int tick = 1;
1:9bbe2e4: 		while (locked == false) {
1:9bbe2e4: 			try {
1:9bbe2e4: 				Statement s = conn.createStatement();
1:9bbe2e4: 				s.execute("lock table Datatypes in exclusive mode");
1:9bbe2e4: 				s.close();
1:9bbe2e4: 				locked = true;
1:9bbe2e4: 			} catch (SQLException se) {
1:9bbe2e4: 				// not now lockable
1:9bbe2e4: 				if (se.getSQLState().equals("X0X02")) {
1:9bbe2e4: 					Thread.sleep(20000);
1:9bbe2e4: 					if (tick++ < 60) {
1:9bbe2e4: 						System.out
1:9bbe2e4: 						.println("count: cannot lock table, retrying "
1:9bbe2e4: 								+ tick + "\n");
1:9bbe2e4: 						continue;
1:9bbe2e4: 					} else {
1:9bbe2e4: 						System.out.println("count timed out\n");
1:9bbe2e4: 						return (-1);
1:7e57d4b: 					}
1:9bbe2e4: 				} else
1:9bbe2e4: 					JDBCDisplayUtil.ShowException(System.out, se);
1:9bbe2e4: 			}
1:9bbe2e4: 		}
1:9bbe2e4: 		try {
1:9bbe2e4: 			ps = conn.prepareStatement(" select count (*) from Datatypes ");
1:9bbe2e4: 			rs = ps.executeQuery();
1:9bbe2e4: 			if (rs.next())
1:9bbe2e4: 				rows = rs.getInt(1);
1:9bbe2e4: 			if (ps != null)
1:9bbe2e4: 				ps.close();
1:9bbe2e4: 		} catch (SQLException se) {
1:9bbe2e4: 			if (se.getNextException() == null)
1:9bbe2e4: 				throw se;
1:9bbe2e4: 			String m = se.getNextException().getSQLState();
1:9bbe2e4: 			System.out.println(se.getNextException().getMessage()
1:9bbe2e4: 					+ " SQLSTATE: " + m);
1:9bbe2e4: 		}
1:9bbe2e4: 		locked = true;
1:9bbe2e4: 		return (rows);
1:9bbe2e4: 	}
1:9bbe2e4: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:bbde618
/////////////////////////////////////////////////////////////////////////
1: 			.prepareStatement(" select id from  Datatypes where id >= ?");
/////////////////////////////////////////////////////////////////////////
1: 					//if the id is null, find another row.
/////////////////////////////////////////////////////////////////////////
1: 				else {
1: 					// the random number is higher than the
1: 					// highest id value in the database. 
1: 					// delete would fail. Pick another.
1: 					i--;
1: 					continue;
1: 				}
commit:7e57d4b
/////////////////////////////////////////////////////////////////////////
1: 		if (streamReader != null)
1: 			streamReader.close();
1: 		if (streamIn !=null)
1: 			streamIn.close();
/////////////////////////////////////////////////////////////////////////
1: }
commit:9bbe2e4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:  Derby - Class org.apache.derbyTesting.system.sttest.Datatypes
1:  
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1:  
1:  http://www.apache.org/licenses/LICENSE-2.0
1:  
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.system.sttest.utils;
1: 
1: import java.io.InputStream;
1: import java.math.BigDecimal;
1: import java.sql.Connection;
1: import java.sql.Date;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Random;
0: import java.util.Vector;
1: import org.apache.derby.tools.JDBCDisplayUtil;
1: 
1: 
1: /**
1:  * This class is used to insert, delete and updated the rows
1:  */
1: public class Datatypes {
1: 	
1: 	public static final int TCHAR = 0;
1: 	
1: 	public static final int TBLOB = 1;
1: 	
1: 	public static final int TCLOB = 2;
1: 	
1: 	public static final int TDATE = 3;
1: 	
1: 	public static final int TDECIMAL = 4;
1: 	
1: 	public static final int TDECIMALNN = 5;
1: 	
1: 	public static final int TDOUBLE = 6;
1: 	
1: 	public static final int TFLOAT = 7;
1: 	
1: 	public static final int TINT = 8;
1: 	
1: 	public static final int TLONGINT = 9;
1: 	
1: 	public static final int TNUMERICLARGE = 10;
1: 	
1: 	public static final int TREAL = 11;
1: 	
1: 	public static final int TSMALLINT = 12;
1: 	
1: 	public static final int TTIME = 13;
1: 	
1: 	public static final int TTIMESTAMP = 14;
1: 	
1: 	public static final int TVARCHAR = 15;
1: 	
1: 	public static final int NUMTYPES = 15;
1: 	
0: 	static String[] fileName = new String[35];
1: 	
0: 	static String[] fileName1 = new String[35];
1: 	
0: 	static String[] fileName2 = new String[35];
1: 	
0: 	static long[] fileLength = { 16644, 65949, 65675, 65675, 9894, 26651,
0: 			37370, 9676, 32191, 26883, 52817, 34590, 59510, 52063, 19723, 9894,
0: 			10937, 12522, 10962, 29815, 13605, 1620, 13800, 14606, 10126,
0: 			14430, 21757, 7765, 11431, 14047, 10992, 20141, 11357, 8609, 23259 };
1: 	
0: 	static long[] fileLength1 = { 6285, 6944, 58937, 28225, 89773, 31076,
0: 			11577, 43729, 29501, 14044, 3258, 10590, 0, 2588, 3270, 3433, 4149,
0: 			2778, 1529, 6672, 1918, 1308, 1899, 6143, 6554, 15456, 16617, 571,
0: 			13657, 5000, 10000, 401, 401, 401, 401 };
1: 	
1: 	public static String[] colnames = { "t_char", "t_blob", "t_clob", "t_date",
1: 			"t_decimal", "t_decimal_nn", "t_double", "t_float", "t_int",
1: 			"t_longint", "t_numeric_large", "t_real", "t_smallint", "t_time",
1: 			"t_timestamp", "t_varchar"
1: 			
1: 	};
1: 	
0: 	public static Random rand;
1: 	
1: 	public static synchronized void add_one_row(Connection conn, int thread_id)
1: 	throws Exception {
1: 		try {
1: 			//initialize();
1: 			PreparedStatement ps = conn.prepareStatement(
1: 					" insert into Datatypes (id,t_char,t_blob," + "t_clob,"
1: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1: 					+ " t_real, t_smallint, t_time, t_timestamp,"
1: 					+ " t_varchar) values ("
0: 					+ " ?,?, ?,?, ?, ?,?, ?, ?, ?,?, ?, ?, ?, ?, ?,?)" //autoincrement
0: 					// feature
0: 					// added,
0: 					// so
0: 					// we
0: 					// need
0: 					// to
0: 					// specify
0: 					// the
0: 					// column
0: 					// name
0: 					// for prepared statement, otherwise auto increment
0: 					// column will think
0: 					// it is trying to update/insert a null value to the column.
1: 					, Statement.RETURN_GENERATED_KEYS);
0: 			int ind = rand.nextInt();
0: 			int id_ind = ind;
1: 			double x;
1: 			Date dt = new Date(1);
1: 			Time tt = new Time(1);
1: 			Timestamp ts = new Timestamp(1);
1: 			String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
0: 			boolean bo = false;
0: 			Vector vec = null;
0: 			Integer ji = null;
1: 			ps.setInt(1, ind);
1: 			// scramble the string
1: 			int i1 = Math.abs(ind % 100);
1: 			String cs2 = cs.substring(i1, 99) + cs.substring(0, i1);
1: 			int i2 = i1 < 89 ? i1 + 10 : i1;
1: 			ps.setString(2, cs2.substring(0, i2));
1: 			//"t_blob"
0: 			int j = (int) (Math.random() * 35);
0: 			fileName[j] = "p" + j + ".jpg";
0: 			InputStream fileIn = Datatypes.class
0: 			.getResourceAsStream(fileName[j]);
0: 			ps.setBinaryStream(3, fileIn, (int) fileLength[j]);
1: 			//"t_clob
0: 			int k = (int) (Math.random() * 35);
0: 			fileName1[k] = "t" + k + ".txt";
0: 			InputStream fileIn1 = Datatypes.class
0: 			.getResourceAsStream(fileName1[k]);
0: 			ps.setAsciiStream(4, fileIn1, (int) fileLength1[k]);
1: 			//"t_ndate"
0: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			ps.setDate(5, dt);
1: 			//"t_decimal"
0: 			x = Math.abs(rand.nextInt() % 18);
1: 			if (x > 5)
1: 				x = 5;
0: 			ps.setDouble(6, Math.abs(rand.nextDouble() * Math.pow(10, x)));
1: 			//"t_decimal_nn"
0: 			ps.setDouble(7, rand.nextDouble());
1: 			//"t_double"
0: 			ps.setDouble(8, rand.nextDouble()
0: 					* Math.pow(10, Math.abs(rand.nextInt() % 300)));
1: 			//"t_float"
0: 			ps.setFloat(9, rand.nextFloat()
0: 					* (float) Math.pow(10, Math.abs(rand.nextInt() % 30)));
1: 			//"t_int"
0: 			ps.setInt(10, rand.nextInt());
1: 			//"t_longint"
0: 			ps.setLong(11, rand.nextLong());
1: 			//"t_numeric_large"
0: 			x = Math.abs(rand.nextInt() % 30);
1: 			if (x > 30)
1: 				x = 31;
0: 			ps.setDouble(12, Math.abs(rand.nextDouble() * Math.pow(10, x)));
1: 			//"t_real"
0: 			ps.setFloat(13, rand.nextFloat()
0: 					* (float) Math.pow(10, Math.abs(rand.nextInt() % 7)));
1: 			//"t_smallint"
0: 			ps.setInt(14, rand.nextInt() % (256 * 128));
1: 			//"t_time"
0: 			tt.setTime(Math.abs(rand.nextInt()));
1: 			ps.setTime(15, tt);
1: 			//"t_timestamp"
0: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1: 			ps.setTimestamp(16, ts);
1: 			//"t_varchar"
0: 			ps.setString(17, cs.substring(Math.abs(rand.nextInt() % 100)));
1: 			int rows = ps.executeUpdate();
1: 			if (rows == 1) {
1: 				
0: 				System.out.println("t" + thread_id + " inserted row with id "
0: 						+ id_ind);
1: 				ResultSet rs = ps.getGeneratedKeys();
1: 				
1: 				while (rs.next()) {
1: 					ResultSetMetaData rsmd = rs.getMetaData();
1: 					int numCols = rsmd.getColumnCount();
1: 				}
1: 			} else
1: 				System.out.println("t" + thread_id + " insert failed");
1: 			
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 		}
1: 	}
1: 	
1: 	//pick quantity number of rows randomly and delete them
1: 	public static int delete_some(Connection conn, int thread_id, int quantity)
1: 	throws Exception {
1: 		PreparedStatement ps = null;
1: 		int list[] = pick_some(conn, thread_id, quantity);
1: 		//delete them
1: 		int rows = 0;
1: 		try {
1: 			ps = conn.prepareStatement(" delete from  Datatypes where id = ?");
1: 			for (int i = 0; i < quantity; i++) {
1: 				ps.setInt(1, list[i]);
1: 				rows += ps.executeUpdate();
0: 				System.out.println("t" + thread_id + " deleted "
0: 						+ " row with id " + list[i]);
1: 			}
1: 			if (ps != null)
1: 				ps.close();
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 			return (rows);
1: 		}
1: 		// all deletes in a single transaction, to force some overlap of
1: 		// transactions
1: 		// by different threads
1: 		conn.commit();
1: 		return (rows);
1: 	}
1: 	
1: 	//get a random set of row ids
1: 	public static int[] pick_some(Connection conn, int thread_id, int quantity)
1: 	throws Exception {
1: 		System.out.println("quantity in pick_some is: " + quantity);
1: 		int ind = 0;
1: 		PreparedStatement ps = null;
1: 		ResultSet rs = null;
1: 		//pick the rows
1: 		try {
1: 			ps = conn
0: 			.prepareStatement(" select id from  Datatypes where id = ?");
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 			return (null);
1: 		}
1: 		int list[] = new int[quantity];
1: 		int j = 0;
1: 		for (int i = 0; i < quantity; i++) {
0: 			ind = rand.nextInt();
1: 			try {
1: 				ps.setInt(1, ind);
1: 				rs = ps.executeQuery();
1: 				if (rs.next()) {
0: 					//keep trying till we get a good one
1: 					j = rs.getInt(1);
1: 					if (rs.wasNull()) {
0: 						System.out.println("rs.wasNull() ind is " + ind);
1: 						i--;
1: 						continue;
1: 					}
1: 					list[i] = j;
1: 					
0: 					System.out.println("list[1] in picksome=:" + list[i]);
1: 				} else {
0: 					System.out.println("thread " + thread_id
0: 							+ ", select for delete: no row found");
1: 				}
1: 				//don't worry about consistency; if row with this id
1: 				//gets changed by another thread we will just forge ahead;
1: 				//otherwise we gets lots of deadlocks
1: 				conn.commit();
1: 			} catch (SQLException se) {
1: 				if (se.getNextException() == null)
1: 					throw se;
1: 				String m = se.getNextException().getSQLState();
1: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 				return (null);
1: 			}
1: 		}
1: 		if (rs != null)
1: 			rs.close();
1: 		if (ps != null)
1: 			ps.close();
1: 		return (list);
1: 	}
1: 	
1: 	public static void delete_one_row(Connection conn, int thread_id)
1: 	throws Exception {
1: 		
1: 		PreparedStatement ps = null;
1: 		PreparedStatement ps2 = null;
1: 		String column = null;
1: 		int ind = 0;
1: 		ResultSet rs = null;
0: 		ind = Math.abs(rand.nextInt());
1: 		while (ind % NUMTYPES == TDECIMAL || ind % NUMTYPES == TVARCHAR
1: 				|| ind % NUMTYPES == TCHAR)
0: 			ind = Math.abs(rand.nextInt());
1: 		column = colnames[ind % NUMTYPES];
1: 		try {
1: 			ps = conn.prepareStatement(" select cast (max (" + column + ") as "
1: 					+ " char(120)) from Datatypes where " + column + " <= ? ");
1: 			ps2 = conn.prepareStatement(" delete from  Datatypes where "
1: 					+ column + " = ?");
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 			return;
1: 		}
1: 		String ds = null;
1: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1: 		double d = 0.0;
1: 		float f = 0;
1: 		BigDecimal bdec = null;
1: 		switch (ind % NUMTYPES) {
1: 		case TCHAR:
0: 			ds = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps.setString(1, ds);
1: 			break;
1: 		case TDATE:
1: 			Date dt = new Date(1);
0: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			ps.setString(1, dt.toString());
1: 			ds = dt.toString();
1: 			break;
1: 		case TDECIMAL:
0: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 18);
1: 			bdec = new BigDecimal(d);
1: 			ps.setString(1, String.valueOf(bdec));
1: 			ds = String.valueOf(d);
1: 			break;
1: 		case TDECIMALNN:
0: 			d = rand.nextDouble();
1: 			bdec = new BigDecimal(d);
1: 			ps.setString(1, String.valueOf(bdec));
1: 			ds = String.valueOf(d);
1: 			break;
1: 		case TDOUBLE:
0: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 300);
1: 			ps.setString(1, String.valueOf(d));
1: 			ds = String.valueOf(d);
1: 			break;
1: 		case TFLOAT:
0: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 30);
1: 			ps.setString(1, String.valueOf(f));
1: 			ds = String.valueOf(f);
1: 			break;
1: 		case TINT:
0: 			ps.setString(1, String.valueOf(rand.nextInt()));
0: 			ds = String.valueOf(rand.nextInt());
1: 			break;
1: 		case TLONGINT:
0: 			ps.setString(1, String.valueOf(rand.nextLong()));
0: 			ds = String.valueOf(rand.nextLong());
1: 			break;
1: 		case TNUMERICLARGE:
0: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 50);
1: 			bdec = new BigDecimal(d);
1: 			ps.setString(1, String.valueOf(bdec));
1: 			ds = String.valueOf(d);
1: 			break;
1: 		case TREAL:
0: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 7);
1: 			ps.setString(1, String.valueOf(f));
1: 			ds = String.valueOf(f);
1: 			break;
1: 		case TSMALLINT:
0: 			int i = rand.nextInt() % (256 * 128);
1: 			ps.setString(1, String.valueOf(i));
1: 			ds = String.valueOf(i);
1: 			break;
1: 		case TTIME:
1: 			Time tt = new Time(1);
0: 			tt.setTime(Math.abs(rand.nextInt()));
1: 			ps.setString(1, "time'" + tt.toString() + "'");
1: 			ds = "time'" + tt.toString() + "'";
1: 			break;
1: 		case TTIMESTAMP:
1: 			Timestamp ts = new Timestamp(1);
0: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1: 			ps.setString(1, "timestamp'" + ts.toString() + "'");
1: 			ds = "timestamp'" + ts.toString() + "'";
1: 			break;
1: 		case TVARCHAR:
0: 			ds = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps.setString(1, ds);
1: 			break;
1: 		}
0: 		System.out.println("t" + thread_id + " delete " + column
0: 				+ " select seed " + ds);
1: 		String ds3 = null;
1: 		String ds4 = null;
1: 		int rows = 0;
1: 		boolean cleanuponly = false;
1: 		try {
1: 			rs = ps.executeQuery();
1: 			if (rs.next()) {
1: 				ds3 = rs.getString(1);
1: 				if (rs.wasNull()) {
1: 					cleanuponly = true;
1: 				} else {
1: 					ds4 = ds3.trim();
1: 					ds3 = ds4;
1: 				}
1: 			}
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 		}
1: 		if (ps != null)
1: 			try {
1: 				ps.close();
1: 			} catch (SQLException se) {
1: 				if (se.getNextException() == null)
1: 					throw se;
1: 				String m = se.getNextException().getSQLState();
1: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 			}
1: 			if (rs != null)
1: 				try {
1: 					rs.close();
1: 				} catch (SQLException se) {
1: 					if (se.getNextException() == null)
1: 						throw se;
1: 					String m = se.getNextException().getSQLState();
1: 					System.out.println(se.getNextException().getMessage()
1: 							+ " SQLSTATE: " + m);
1: 				}
1: 				if (cleanuponly == false) {
0: 					System.out.println("t" + thread_id + " delete where " + column
0: 							+ " = " + ds3);
1: 					try {
1: 						ps2.setString(1, ds3);
1: 						rows = ps2.executeUpdate();
1: 						
1: 					} catch (SQLException se) {
1: 						if (se.getNextException() == null)
1: 							throw se;
1: 						String m = se.getNextException().getSQLState();
1: 						System.out.println(se.getNextException().getMessage()
1: 								+ " SQLSTATE: " + m);
1: 					}
1: 					
0: 					if (rows > 0)
0: 						System.out.println("t" + thread_id + " deleted " + rows
0: 								+ " row(s)");
0: 					else
1: 						System.out.println("t" + thread_id + " delete failed.");
1: 				}
1: 				if (ps2 != null)
1: 					try {
1: 						ps2.close();
1: 					} catch (SQLException se) {
1: 						if (se.getNextException() == null)
1: 							throw se;
1: 						String m = se.getNextException().getSQLState();
1: 						System.out.println(se.getNextException().getMessage()
1: 								+ " SQLSTATE: " + m);
1: 					}
1: 	}
1: 	
1: 	public static synchronized void update_one_row(Connection conn,
1: 			int thread_id) throws Exception {
1: 		PreparedStatement ps2 = null;
1: 		Statement stmt = conn.createStatement();
1: 		ResultSet rs;
1: 		String column = null;
1: 		int ind = 0;
1: 		long max = 0;
1: 		long min = 0;
1: 		double x;
1: 		long id_to_update;
1: 		rs = stmt.executeQuery("select max(serialkey) from Datatypes");
1: 		while (rs.next())
1: 			max = rs.getLong(1);
1: 		rs = stmt.executeQuery("select min(serialkey) from Datatypes");
1: 		while (rs.next())
1: 			min = rs.getLong(1);
0: 		id_to_update = (min + 1) + (Math.abs(rand.nextLong()) % (max - min));
1: 		if (id_to_update == 0)
1: 			id_to_update = 1;
0: 		ind = Math.abs(rand.nextInt());
1: 		column = colnames[ind % NUMTYPES];
1: 		try {
1: 			conn
1: 			.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1: 			ps2 = conn.prepareStatement(" update Datatypes set " + column
1: 					+ " = ? " + " where serialkey = " + id_to_update);
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			return;
1: 		}
1: 		String ds = null;
1: 		String ds2 = null;
1: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1: 		double d = 0.0;
1: 		float f = 0;
1: 		BigDecimal bdec = null;
1: 		int type = (ind % NUMTYPES);
0: 		int ji = 0;
0: 		boolean bo = false;
1: 		switch (type) {
1: 		case TCHAR:
0: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps2.setString(1, ds2);
1: 			break;
1: 		case TDATE:
1: 			Date dt = new Date(1);
0: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
0: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			ps2.setDate(1, dt);
1: 			ds2 = dt.toString();
1: 			break;
1: 		case TDECIMAL:
0: 			x = Math.abs(rand.nextInt() % 18);
1: 			if (x > 5)
1: 				x = 5;
0: 			d = rand.nextDouble() * Math.pow(10, x);
1: 			bdec = new BigDecimal(d);
1: 			ps2.setBigDecimal(1, bdec);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 		case TDECIMALNN:
1: 			ds = String.valueOf(d);
0: 			d = rand.nextDouble();
1: 			bdec = new BigDecimal(d);
1: 			ps2.setBigDecimal(1, bdec);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 			
1: 		case TDOUBLE:
0: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 300);
1: 			ps2.setDouble(1, d);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 		case TFLOAT:
1: 			ds = String.valueOf(f);
0: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 30);
1: 			ps2.setFloat(1, f);
1: 			ds2 = String.valueOf(f);
1: 			break;
1: 		case TINT:
0: 			int i = rand.nextInt();
1: 			ds2 = String.valueOf(i);
1: 			ps2.setInt(1, i);
1: 			break;
1: 		case TLONGINT:
0: 			long l = rand.nextLong();
1: 			ds2 = String.valueOf(l);
1: 			ps2.setLong(1, l);
1: 			break;
1: 		case TNUMERICLARGE:
1: 			ds = String.valueOf(d);
0: 			x = Math.abs(rand.nextInt() % 30);
1: 			if (x > 30)
1: 				x = 31;
0: 			d = rand.nextDouble() * Math.pow(10, x);
1: 			bdec = new BigDecimal(d);
1: 			ps2.setBigDecimal(1, bdec);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 		case TREAL:
1: 			ds = String.valueOf(f);
0: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 7);
1: 			ps2.setFloat(1, f);
1: 			ds2 = String.valueOf(f);
1: 			break;
1: 		case TSMALLINT:
0: 			i = rand.nextInt() % (256 * 128);
1: 			ds = String.valueOf(i);
1: 			short si = (short) i;
1: 			ps2.setShort(1, si);
1: 			ds2 = String.valueOf(si);
1: 			break;
1: 		case TTIME:
1: 			Time tt = new Time(1);
0: 			tt.setTime(Math.abs(rand.nextInt()));
1: 			ps2.setTime(1, tt);
1: 			ds2 = tt.toString();
1: 			break;
1: 		case TTIMESTAMP:
1: 			Timestamp ts = new Timestamp(1);
0: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1: 			ps2.setTimestamp(1, ts);
1: 			ds2 = ts.toString();
1: 			break;
1: 		case TVARCHAR:
0: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps2.setString(1, ds2);
1: 			break;
1: 		case TBLOB:
0: 			int j = (int) (Math.random() * 35);
0: 			fileName[j] = "p" + j + ".jpg";
0: 			InputStream fileIn = Datatypes.class
0: 			.getResourceAsStream(fileName[j]);
0: 			ps2.setBinaryStream(1, fileIn, (int) fileLength[j]);
1: 			break;
1: 		case TCLOB:
0: 			int k = (int) (Math.random() * 35);
0: 			fileName1[k] = "t" + k + ".txt";
0: 			InputStream fileIn1 = Datatypes.class
0: 			.getResourceAsStream(fileName1[k]);
0: 			ps2.setAsciiStream(1, fileIn1, (int) fileLength1[k]);
1: 			break;
1: 		}
1: 		int rows = 0;
1: 		boolean cleanuponly = false;
1: 		if (cleanuponly == false) {
0: 			System.out.println("t" + thread_id + " update " + column);
1: 			try {
1: 				rows = ps2.executeUpdate();
1: 				
1: 			} catch (SQLException se) {
1: 				if (se.getNextException() == null)
1: 					throw se;
1: 				String m = se.getNextException().getSQLState();
1: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 			}
0: 			if (rows > 0)
0: 				System.out.println("t" + thread_id + " updated 1 row with id "
0: 						+ id_to_update);
0: 			else
1: 				System.out.println("t" + thread_id + " update failed.");
1: 		}
1: 		if (ps2 != null)
1: 			try {
1: 				ps2.close();
1: 				rs.close();
1: 			} catch (SQLException se) {
1: 				if (se.getNextException() == null)
1: 					throw se;
1: 				String m = se.getNextException().getSQLState();
1: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
1: 			}
1: 	}
1: 	
1: 	public static synchronized int get_table_count(Connection conn)
1: 	throws Exception {
1: 		PreparedStatement ps = null;
1: 		ResultSet rs = null;
1: 		int rows = 0;
1: 		boolean locked = false;
1: 		int tick = 1;
1: 		while (locked == false) {
1: 			try {
1: 				Statement s = conn.createStatement();
1: 				s.execute("lock table Datatypes in exclusive mode");
1: 				s.close();
1: 				locked = true;
1: 			} catch (SQLException se) {
1: 				// not now lockable
1: 				if (se.getSQLState().equals("X0X02")) {
1: 					Thread.sleep(20000);
1: 					if (tick++ < 60) {
1: 						System.out
1: 						.println("count: cannot lock table, retrying "
1: 								+ tick + "\n");
1: 						continue;
1: 					} else {
1: 						System.out.println("count timed out\n");
1: 						return (-1);
1: 					}
1: 				} else
1: 					JDBCDisplayUtil.ShowException(System.out, se);
1: 			}
1: 		}
1: 		try {
1: 			ps = conn.prepareStatement(" select count (*) from Datatypes ");
1: 			rs = ps.executeQuery();
1: 			if (rs.next())
1: 				rows = rs.getInt(1);
1: 			if (ps != null)
1: 				ps.close();
1: 		} catch (SQLException se) {
1: 			if (se.getNextException() == null)
1: 				throw se;
1: 			String m = se.getNextException().getSQLState();
1: 			System.out.println(se.getNextException().getMessage()
1: 					+ " SQLSTATE: " + m);
1: 		}
0: 		System.out.println("rows in calling initial_data()" + rows);
1: 		locked = true;
1: 		return (rows);
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:a5430dd
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 
0: 
0: 
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
0: 
1: 	public static Random Rn = new Random();
0: 
0: 		"t_decimal", "t_decimal_nn", "t_double", "t_float", "t_int",
0: 		"t_longint", "t_numeric_large", "t_real", "t_smallint", "t_time",
0: 		"t_timestamp", "t_varchar"
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1: 					+ " ?,?, ?,?, ?, ?,?, ?, ?, ?,?, ?, ?, ?, ?, ?,?)" 
1: 					/* autoincrement feature added, so we need to specify the
1: 					 * column name for prepared statement, otherwise auto increment
1: 					 * column will think it is trying to update/insert a null value
1: 					 * to the column.
1: 					 */
1: 			InputStream streamIn = null;
1: 			Reader streamReader = null;
1: 			int ind = Rn.nextInt();
/////////////////////////////////////////////////////////////////////////
1: 			int blobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1: 			streamIn = new LoopingAlphabetStream(blobLength);
1: 			ps.setBinaryStream(3, streamIn, blobLength);
1: 			int clobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1: 			streamReader = new LoopingAlphabetReader(clobLength, CharAlphabet
1: 					.modernLatinLowercase());
1: 			ps.setCharacterStream(4, streamReader, clobLength);
1: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1: 			x = Math.abs(Rn.nextInt() % 18);
1: 			ps.setDouble(6, Math.abs(Rn.nextDouble() * Math.pow(10, x)));
1: 			ps.setDouble(7, Rn.nextDouble());
1: 			ps.setDouble(8, Rn.nextDouble()
1: 					* Math.pow(10, Math.abs(Rn.nextInt() % 300)));
1: 			ps.setFloat(9, Rn.nextFloat()
1: 					* (float) Math.pow(10, Math.abs(Rn.nextInt() % 30)));
1: 			ps.setInt(10, Rn.nextInt());
1: 			ps.setLong(11, Rn.nextLong());
1: 			x = Math.abs(Rn.nextInt() % 30);
1: 			ps.setDouble(12, Math.abs(Rn.nextDouble() * Math.pow(10, x)));
1: 			ps.setFloat(13, Rn.nextFloat()
1: 					* (float) Math.pow(10, Math.abs(Rn.nextInt() % 7)));
1: 			ps.setInt(14, Rn.nextInt() % (256 * 128));
1: 			tt.setTime(Math.abs(Rn.nextInt()));
1: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1: 			ps.setString(17, cs.substring(Math.abs(Rn.nextInt() % 100)));
0: 
0: 
1: 			streamReader.close();
1: 			streamIn.close();
0: 
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: 			ind = Rn.nextInt();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
1: 		ind = Math.abs(Rn.nextInt());
1: 			ind = Math.abs(Rn.nextInt());
/////////////////////////////////////////////////////////////////////////
1: 			ds = cs.substring(Math.abs(Rn.nextInt() % 100));
1: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 18);
1: 			d = Rn.nextDouble();
1: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 300);
1: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 30);
1: 			ps.setString(1, String.valueOf(Rn.nextInt()));
1: 			ds = String.valueOf(Rn.nextInt());
1: 			ps.setString(1, String.valueOf(Rn.nextLong()));
1: 			ds = String.valueOf(Rn.nextLong());
1: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 50);
1: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 7);
1: 			int i = Rn.nextInt() % (256 * 128);
1: 			tt.setTime(Math.abs(Rn.nextInt()));
1: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1: 			ds = cs.substring(Math.abs(Rn.nextInt() % 100));
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1: 					if (rows < 0)
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
1: 		InputStream streamIn = null;
1: 		Reader streamReader = null;
1: 		id_to_update = (min + 1) + (Math.abs(Rn.nextLong()) % (max - min));
1: 		ind = Math.abs(Rn.nextInt());
/////////////////////////////////////////////////////////////////////////
1: 			ds2 = cs.substring(Math.abs(Rn.nextInt() % 100));
1: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1: 			dt.setTime(Math.abs(Rn.nextLong() / 150000));
1: 			x = Math.abs(Rn.nextInt() % 18);
1: 			d = Rn.nextDouble() * Math.pow(10, x);
1: 			d = Rn.nextDouble();
0: 
1: 			d = Rn.nextDouble() * Math.pow(10, Rn.nextInt() % 300);
1: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 30);
1: 			int i = Rn.nextInt();
1: 			long l = Rn.nextLong();
1: 			x = Math.abs(Rn.nextInt() % 30);
1: 			d = Rn.nextDouble() * Math.pow(10, x);
1: 			f = Rn.nextFloat() * (float) Math.pow(10, Rn.nextInt() % 7);
1: 			i = Rn.nextInt() % (256 * 128);
/////////////////////////////////////////////////////////////////////////
1: 			tt.setTime(Math.abs(Rn.nextInt()));
1: 			ts.setTime(Math.abs(Rn.nextLong() / 50000));
1: 			ds2 = cs.substring(Math.abs(Rn.nextInt() % 100));
1: 			int blobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1: 			streamIn = new LoopingAlphabetStream(blobLength);
1: 			ps2.setBinaryStream(1, streamIn, blobLength);
0: 
1: 			int clobLength = Rn.nextInt(102400 - 0 + 1) + 0;//to create a stream of random length between 0 and 100K
1: 			streamReader = new LoopingAlphabetReader(clobLength, CharAlphabet
1: 					.modernLatinLowercase());
1: 			ps2.setCharacterStream(1, streamReader, clobLength);
0: 
/////////////////////////////////////////////////////////////////////////
1: 			if (rows < 0)
0: 		streamReader.close();
0: 		streamIn.close();
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
============================================================================