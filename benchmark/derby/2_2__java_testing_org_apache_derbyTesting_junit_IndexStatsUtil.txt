1:ff589e5: /*
2:ff589e5: 
1:ff589e5:    Derby - Class org.apache.derbyTesting.junit.IndexStatsUtil
1:ff589e5: 
1:ff589e5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ff589e5:    contributor license agreements.  See the NOTICE file distributed with
1:ff589e5:    this work for additional information regarding copyright ownership.
1:ff589e5:    The ASF licenses this file to you under the Apache License, Version 2.0
1:ff589e5:    (the "License"); you may not use this file except in compliance with
1:ff589e5:    the License.  You may obtain a copy of the License at
1:ff589e5: 
1:ff589e5:       http://www.apache.org/licenses/LICENSE-2.0
1:ff589e5: 
1:ff589e5:    Unless required by applicable law or agreed to in writing, software
1:ff589e5:    distributed under the License is distributed on an "AS IS" BASIS,
1:ff589e5:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ff589e5:    See the License for the specific language governing permissions and
1:ff589e5:    limitations under the License.
1:ff589e5: 
2:ff589e5:  */
1:ff589e5: 
1:ff589e5: package org.apache.derbyTesting.junit;
1:ff589e5: 
1:ff589e5: import java.sql.Connection;
1:ff589e5: import java.sql.PreparedStatement;
1:ff589e5: import java.sql.ResultSet;
1:ff589e5: import java.sql.SQLException;
1:ff589e5: import java.sql.Timestamp;
1:ff589e5: 
1:ff589e5: import java.util.ArrayList;
1:3574e10: import java.util.Arrays;
1:ff589e5: import java.util.HashMap;
1:3574e10: import java.util.HashSet;
1:ff589e5: import java.util.List;
1:ff589e5: import java.util.Map;
1:3574e10: import java.util.Set;
1:ff589e5: 
1:ff589e5: import junit.framework.Assert;
1:ff589e5: 
2:ff589e5: /**
1:ff589e5:  * Helper class for obtaining index statistics and doing asserts on them.
1:ff589e5:  * <p>
1:ff589e5:  * This implementation assumes all tables/indexes belong to the current schema.
1:1e0e0ca:  * <p>
1:1e0e0ca:  * The <em>timeout</em> value is used to make the utility more resilient to
1:1e0e0ca:  * differences in timing due to varying scheduling decisions, processor speeds,
1:1e0e0ca:  * etc. If the system table contains the wrong number of statistics objects for
1:1e0e0ca:  * the query, it will be queried repeatedly until the right number of statistics
1:1e0e0ca:  * objects is obtained or the query times out.
1:ff589e5:  */
1:ff589e5: public class IndexStatsUtil {
1:ff589e5: 
1:1e0e0ca:     private static final boolean INDEX = false;
1:1e0e0ca:     private static final boolean TABLE = true;
1:1e0e0ca:     private static final int NO_EXPECTATION = -1;
1:1e0e0ca:     private static final String SEP =
1:1e0e0ca:                 BaseJDBCTestCase.getSystemProperty("line.separator");
1:1e0e0ca: 
1:ff589e5:     private final Connection con;
1:1e0e0ca:     /** Timeout in milliseconds. */
1:1e0e0ca:     private final long timeout;
1:ff589e5:     private PreparedStatement psGetTableId;
1:ff589e5:     private PreparedStatement psGetStatsForTable;
1:ff589e5:     private PreparedStatement psGetIndexId;
1:ff589e5:     private PreparedStatement psGetStatsForIndex;
1:ff589e5:     private PreparedStatement psGetStats;
1:ff589e5:     private PreparedStatement psGetIdToNameMapConglom;
1:ff589e5:     private PreparedStatement psGetIdToNameMapTable;
1:ff589e5: 
1:1e0e0ca:     /**
1:1e0e0ca:      * Creates an instance querying the given database with no timeout set.
1:1e0e0ca:      * <p>
1:1e0e0ca:      * Querying with no timeout means that if there are too few or too many
1:1e0e0ca:      * statistics objects matching the query, a failure will be raised
1:1e0e0ca:      * immediately.
1:1e0e0ca:      *
1:1e0e0ca:      * @param con connection to the database to query
1:1e0e0ca:      */
1:1e0e0ca:     public IndexStatsUtil(Connection con) {
1:1e0e0ca:         this(con, 0L);
1:1e0e0ca:     }
1:1e0e0ca: 
1:1e0e0ca:     /**
1:1e0e0ca:      * Creates an instance querying the given database with the specified
1:1e0e0ca:      * timeout value.
1:1e0e0ca:      *
1:1e0e0ca:      * @param con connection to the database to query
1:1e0e0ca:      * @param timeout the longest time to wait to see if the expectations for a
1:1e0e0ca:      *      query are met (milliseconds)
1:1e0e0ca:      */
1:1e0e0ca:     public IndexStatsUtil(Connection con, long timeout) {
1:ff589e5:         // Rely on auto-commit to release locks.
1:1e0e0ca:         try {
1:1e0e0ca:             Assert.assertTrue(con.getAutoCommit());
1:1e0e0ca:         } catch (SQLException sqle) {
1:1e0e0ca:             Assert.fail("Failed to get auto commit: " + sqle.getMessage());
1:1e0e0ca:         }
1:1e0e0ca:         if (timeout < 0) {
1:1e0e0ca:             throw new IllegalArgumentException("timeout cannot be negative");
1:1e0e0ca:         }
1:ff589e5:         this.con = con;
1:1e0e0ca:         this.timeout = timeout;
5:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Asserts that there are no existing statistics in the database.
2:ff589e5:      *
1:ff589e5:      * @throws SQLException if obtaining the statistics fails
1:ff589e5:      */
1:ff589e5:     public void assertNoStats()
2:ff589e5:             throws SQLException {
1:ff589e5:         assertStats(0);
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:6bc69d9:      * Asserts that there are no existing statistics for the specified table.
1:6bc69d9:      *
1:6bc69d9:      * @throws SQLException if obtaining the statistics fails
1:6bc69d9:      */
1:6bc69d9:     public void assertNoStatsTable(String table)
1:6bc69d9:             throws SQLException {
1:6bc69d9:         assertTableStats(table, 0);
1:6bc69d9:     }
1:6bc69d9: 
1:6bc69d9:     /**
2:ff589e5:      * Asserts that the expected number of statistics exists.
1:ff589e5:      *
2:ff589e5:      * @param expectedCount expected number of statistics
1:ff589e5:      * @throws SQLException if obtaining the statistics fails
1:ff589e5:      */
1:ff589e5:     public void assertStats(int expectedCount)
1:ff589e5:             throws SQLException {
1:1e0e0ca:         IdxStats[] ret = getStats();
1:1e0e0ca:         if (ret.length != expectedCount) {
1:1e0e0ca:             Assert.assertEquals(buildStatString(ret, "<ALL TABLES>"),
1:1e0e0ca:                     expectedCount, ret.length);
1:1e0e0ca:         }
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Asserts that the expected number of statistics exists for the specified
1:ff589e5:      * table.
1:ff589e5:      *
1:ff589e5:      * @param table the target table
1:ff589e5:      * @param expectedCount expected number of statistics
1:ff589e5:      * @throws SQLException if obtaining the statistics fails
1:ff589e5:      */
1:ff589e5:     public void assertTableStats(String table, int expectedCount)
1:ff589e5:             throws SQLException {
1:1e0e0ca:         getStatsTable(table, expectedCount);
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Asserts that the expected number of statistics exists for the specified
1:ff589e5:      * index.
1:ff589e5:      *
1:ff589e5:      * @param index the target index
1:ff589e5:      * @param expectedCount expected number of statistics
1:ff589e5:      * @throws SQLException if obtaining the statistics fails
1:ff589e5:      */
1:ff589e5:     public void assertIndexStats(String index, int expectedCount)
1:ff589e5:             throws SQLException {
1:1e0e0ca:         getStatsIndex(index, expectedCount);
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Builds a human readable representation of a list of statistics objects.
1:ff589e5:      *
1:ff589e5:      * @param stats a list of statistics (possibly empty)
1:ff589e5:      * @param name the name of the table(s)/index(es) associated with the stats
1:ff589e5:      * @return A string representation of the statistics.
1:ff589e5:      */
1:bce78c9:     public static String buildStatString(IdxStats[] stats, String name) {
1:ff589e5:         StringBuffer sb = new StringBuffer(
1:ff589e5:                 "Index statistics for " + name + SEP);
1:ff589e5:         for (int i=0; i < stats.length; i++) {
1:ff589e5:             sb.append(i+1).append(": ").append(stats[i].toString()).
1:ff589e5:                     append(SEP);
1:ff589e5:         }
1:ff589e5:         if (stats.length == 0) {
1:ff589e5:             sb.append(" : <no stats>").append(SEP);
1:ff589e5:         }
1:ff589e5:         return sb.toString();
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Obtains all existing statistics entries.
1:ff589e5:      *
1:ff589e5:      * @return A list of statistics entries (possibly empty).
1:ff589e5:      * @throws SQLException if obtaining the statistics fail
1:ff589e5:      */
1:ff589e5:     public IdxStats[] getStats()
1:ff589e5:             throws SQLException {
1:ff589e5:         if (psGetStats == null) {
1:ff589e5:             psGetStats = con.prepareStatement(
1:1e0e0ca:                     "select * from SYS.SYSSTATISTICS " +
1:1e0e0ca:                     "order by TABLEID, REFERENCEID, COLCOUNT");
1:ff589e5:         }
1:ff589e5:         return buildStatisticsList(psGetStats.executeQuery(), getIdToNameMap());
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Obtains statistics for the specified table.
1:ff589e5:      *
1:ff589e5:      * @param table table name
1:ff589e5:      * @return A list of statistics entries (possibly empty).
1:ff589e5:      * @throws SQLException if obtaining the statistics fail
1:ff589e5:      */
1:ff589e5:     public IdxStats[] getStatsTable(String table)
1:ff589e5:             throws SQLException {
1:1e0e0ca:         return getStatsTable(table, NO_EXPECTATION);
1:1e0e0ca:     }
1:1e0e0ca: 
1:1e0e0ca:     /**
1:1e0e0ca:      * Obtains statistics for the specified table, fails if the number of
1:1e0e0ca:      * statistics objects isn't as expected within the timeout.
1:1e0e0ca:      *
1:1e0e0ca:      * @param table table name
1:1e0e0ca:      * @param expectedCount number of expected statistics objects
1:1e0e0ca:      * @return A list of statistics entries (possibly empty).
1:1e0e0ca:      * @throws SQLException if obtaining the statistics fail
1:1e0e0ca:      */
1:1e0e0ca:     public IdxStats[] getStatsTable(String table, int expectedCount)
1:1e0e0ca:             throws SQLException {
1:ff589e5:         if (psGetTableId == null) {
1:ff589e5:             psGetTableId = con.prepareStatement(
1:ff589e5:                 "select TABLEID from SYS.SYSTABLES where TABLENAME = ?");
1:ff589e5:         }
1:ff589e5:         psGetTableId.setString(1, table);
1:ff589e5:         ResultSet rs = psGetTableId.executeQuery();
1:ff589e5:         Assert.assertTrue("No such table: " + table, rs.next());
1:ff589e5:         String tableId = rs.getString(1);
1:ff589e5:         Assert.assertFalse("More than one table named " + table, rs.next());
1:ff589e5:         rs.close();
1:1e0e0ca: 
1:1e0e0ca:         IdxStats[] ret = querySystemTable(tableId, TABLE, expectedCount);
1:1e0e0ca:         // Avoid building the stat string if not necessary.
1:1e0e0ca:         if (expectedCount != NO_EXPECTATION && ret.length != expectedCount) {
1:1e0e0ca:             Assert.assertEquals("failed to get statistics for table " + table +
1:1e0e0ca:                     " (#expected=" + expectedCount + ", timeout=" + timeout +
1:1e0e0ca:                     ")" + SEP + buildStatString(ret, table),
1:1e0e0ca:                     expectedCount, ret.length);
1:1e0e0ca:         }
1:1e0e0ca:         return ret;
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:3574e10:      * Waits for the current statistics to disappear and expects to fetch the
1:3574e10:      * same number of new statistics for the table.
1:3574e10:      *
1:3574e10:      * @param table the table to get statistics for
1:3574e10:      * @param currentStats the current statistics
1:3574e10:      * @return The new statistics.
1:3574e10:      * @throws SQLException if obtaining statistics fails
1:3574e10:      */
1:3574e10:     public IdxStats[] getNewStatsTable(String table, IdxStats[] currentStats)
1:3574e10:             throws SQLException {
1:3574e10:         if (timeout == 0) {
1:3574e10:             throw new IllegalStateException(
1:3574e10:                     "no timeout specified in the constructor");
1:3574e10:         }
1:3574e10:         awaitChange(currentStats, timeout);
1:3574e10:         return getStatsTable(table, currentStats.length);
1:3574e10:     }
1:3574e10: 
1:3574e10:     /**
1:ff589e5:      * Obtains statistics for the specified index.
1:ff589e5:      *
1:ff589e5:      * @param index index name
1:ff589e5:      * @return A list of statistics entries (possibly empty).
1:ff589e5:      * @throws SQLException if obtaining the statistics fail
1:ff589e5:      */
1:ff589e5:     public IdxStats[] getStatsIndex(String index)
1:ff589e5:              throws SQLException {
1:1e0e0ca:         return getStatsIndex(index, NO_EXPECTATION);
1:1e0e0ca:     }
1:1e0e0ca: 
1:1e0e0ca:     /**
1:1e0e0ca:      * Obtains statistics for the specified index, fails if the number of
1:1e0e0ca:      * statistics objects isn't as expected within the timeout.
1:1e0e0ca:      *
1:1e0e0ca:      * @param index index name
1:1e0e0ca:      * @param expectedCount number of expected statistics objects
1:1e0e0ca:      * @return A list of statistics entries (possibly empty).
1:1e0e0ca:      * @throws SQLException if obtaining the statistics fail
1:1e0e0ca:      */
1:1e0e0ca:     public IdxStats[] getStatsIndex(String index, int expectedCount)
1:1e0e0ca:              throws SQLException {
1:ff589e5:         if (psGetIndexId == null) {
1:ff589e5:             psGetIndexId = con.prepareStatement(
1:ff589e5:                     "select CONGLOMERATEID from SYS.SYSCONGLOMERATES where " +
1:ff589e5:                     "CONGLOMERATENAME = ? and " +
1:ff589e5:                     "CAST(ISINDEX as VARCHAR(5)) = 'true'");
1:ff589e5:         }
1:ff589e5:         psGetIndexId.setString(1, index);
1:ff589e5:         ResultSet rs = psGetIndexId.executeQuery();
1:ff589e5:         Assert.assertTrue("No such index: " + index, rs.next());
1:ff589e5:         String indexId = rs.getString(1);
1:ff589e5:         Assert.assertFalse("More than one index named " + index, rs.next());
1:ff589e5:         rs.close();
1:1e0e0ca: 
1:1e0e0ca:         IdxStats[] ret = querySystemTable(indexId, INDEX, expectedCount);
1:1e0e0ca:         // Avoid building the stat string if not necessary.
1:1e0e0ca:         if (expectedCount != NO_EXPECTATION && ret.length != expectedCount) {
1:1e0e0ca:             Assert.assertEquals("failed to get statistics for index " + index +
1:1e0e0ca:                     " (#expected=" + expectedCount + ", timeout=" + timeout +
1:1e0e0ca:                     ")" + SEP + buildStatString(ret, index),
1:1e0e0ca:                     expectedCount, ret.length);
1:1e0e0ca:         }
1:1e0e0ca:         return ret;
1:1e0e0ca:     }
1:1e0e0ca: 
1:1e0e0ca:     /**
1:1e0e0ca:      * Queries the system table {@code SYS.SYSSTATISTICS} for statistics
1:1e0e0ca:      * associated with a specific table or index.
1:1e0e0ca:      *
1:1e0e0ca:      * @param conglomId conglomerate id (UUID)
1:1e0e0ca:      * @param isTable tells if the conglomerate is a table or an index
1:1e0e0ca:      * @param expectedCount the number of statistics objects expected, use
1:1e0e0ca:      *      {@code NO_EXPECTATION} to return whatever matches the query
1:1e0e0ca:      *      immediately
1:1e0e0ca:      */
1:1e0e0ca:     private IdxStats[] querySystemTable(String conglomId, boolean isTable,
1:1e0e0ca:                                         int expectedCount)
1:1e0e0ca:             throws SQLException {
1:1e0e0ca:         // Assign the correct prepared statement.
1:1e0e0ca:         PreparedStatement ps;
1:1e0e0ca:         if (isTable) {
1:1e0e0ca:             if (psGetStatsForTable == null) {
1:1e0e0ca:                 psGetStatsForTable = con.prepareStatement(
1:1e0e0ca:                         "select * from SYS.SYSSTATISTICS " +
1:1e0e0ca:                             "where TABLEID = ? " +
1:1e0e0ca:                             "order by REFERENCEID, COLCOUNT");
1:1e0e0ca:             }
1:1e0e0ca:             ps = psGetStatsForTable;
1:1e0e0ca:         } else {
1:1e0e0ca:             if (psGetStatsForIndex == null) {
1:1e0e0ca:                 psGetStatsForIndex = con.prepareStatement(
1:1e0e0ca:                         "select * from SYS.SYSSTATISTICS " +
1:1e0e0ca:                             "where REFERENCEID = ? " +
1:1e0e0ca:                             "order by COLCOUNT");
1:1e0e0ca:             }
1:1e0e0ca:             ps = psGetStatsForIndex;
1:1e0e0ca:         }
1:1e0e0ca:         ps.setString(1, conglomId);
1:1e0e0ca: 
1:1e0e0ca:         long started = System.currentTimeMillis();
1:1e0e0ca:         long waited = -1;
1:1e0e0ca:         IdxStats[] ret = null;
1:1e0e0ca:         while (waited < timeout) {
1:1e0e0ca:             // Don't wait the first time.
1:1e0e0ca:             if (ret != null) {
1:1e0e0ca:                 Utilities.sleep(Math.min(250L, timeout - waited));
1:1e0e0ca:             }
1:1e0e0ca:             ret = buildStatisticsList(ps.executeQuery(), getIdToNameMap());
1:1e0e0ca:             if (expectedCount == NO_EXPECTATION || ret.length == expectedCount){
1:1e0e0ca:                 break;
1:1e0e0ca:             }
1:1e0e0ca:             waited = System.currentTimeMillis() - started;
1:1e0e0ca:         }
1:1e0e0ca:         return ret;
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Prints all entries in the {@code SYS.SYSSTATISTICS} system table.
1:ff589e5:      *
1:ff589e5:      * @throws SQLException if obtaining the statistics fails
1:ff589e5:      */
1:ff589e5:     public void printStats()
1:ff589e5:             throws SQLException {
1:ff589e5:         System.out.println(buildStatString(getStats(), "all tables"));
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Generates a map from ids to names for conglomerates in the database.
1:ff589e5:      * <p>
1:ff589e5:      * Convenience method, used for better reporting.
1:ff589e5:      *
1:ff589e5:      * @return Mappings from conglomerate id to conglomerate name.
1:ff589e5:      * @throws SQLException if accessing the system tables fail
1:ff589e5:      */
1:2510115:     private Map<String, String> getIdToNameMap()
1:ff589e5:             throws SQLException {
1:ff589e5:         if (psGetIdToNameMapConglom == null) {
1:ff589e5:             psGetIdToNameMapConglom = con.prepareStatement(
1:ff589e5:                     "select CONGLOMERATEID, CONGLOMERATENAME " +
1:ff589e5:                     "from SYS.SYSCONGLOMERATES");
1:ff589e5:         }
1:ff589e5:         if (psGetIdToNameMapTable == null) {
1:ff589e5:             psGetIdToNameMapTable = con.prepareStatement(
1:ff589e5:                     "select TABLEID, TABLENAME from SYS.SYSTABLES");
1:ff589e5:         }
1:2510115:         Map<String, String> map = new HashMap<String, String>();
1:ff589e5:         ResultSet rs = psGetIdToNameMapConglom.executeQuery();
1:ff589e5:         while (rs.next()) {
1:ff589e5:             map.put(rs.getString(1), rs.getString(2));
1:ff589e5:         }
1:ff589e5:         rs.close();
1:ff589e5:         rs = psGetIdToNameMapTable.executeQuery();
1:ff589e5:         while (rs.next()) {
1:ff589e5:             map.put(rs.getString(1), rs.getString(2));
1:ff589e5:         }
1:ff589e5:         rs.close();
1:ff589e5:         return map;
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:ff589e5:      * Builds an array of statistics objects from data from the
1:ff589e5:      * {@code SYS.SYSSTATISTICS} system table.
1:ff589e5:      *
1:ff589e5:      * @param rs a result set containing rows from {@code SYS.SYSSTATISTICS}
1:ff589e5:      * @return A list of statistics objects
1:ff589e5:      * @throws SQLException if accessing the result set fails
1:ff589e5:      */
1:2510115:     private IdxStats[] buildStatisticsList(
1:2510115:             ResultSet rs, Map<String, String> idToName)
1:ff589e5:             throws SQLException {
1:2510115:         List<IdxStats> stats = new ArrayList<IdxStats>();
1:ff589e5:         while (rs.next()) {
1:ff589e5:             // NOTE: Bad practice to call rs.getString(X) twice, but it works
1:ff589e5:             //       for Derby with the string type...
1:ff589e5:             stats.add(new IdxStats(rs.getString(1), rs.getString(2),
1:2510115:                     idToName.get(rs.getString(2)),
1:ff589e5:                     rs.getString(3),
1:2510115:                     idToName.get(rs.getString(3)),
1:ff589e5:                     rs.getTimestamp(4), rs.getInt(7),
1:ff589e5:                     rs.getString(8)));
1:ff589e5:         }
1:ff589e5:         rs.close();
1:2510115:         return stats.toArray(new IdxStats[stats.size()]);
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:5a72b2c:      * Releases resources and closes the associated connection.
1:ff589e5:      */
1:ff589e5:     public void release() {
1:5a72b2c:         release(true);
1:5a72b2c:     }
1:5a72b2c: 
1:5a72b2c:     /**
1:5a72b2c:      * Releases resources.
1:5a72b2c:      *
1:5a72b2c:      * @param closeConnection whether to close the associated connection
1:5a72b2c:      */
1:5a72b2c:     public void release(boolean closeConnection) {
1:ff589e5:         PreparedStatement[] psToClose = new PreparedStatement[] {
1:ff589e5:             psGetStats, psGetIndexId, psGetStatsForIndex,
1:ff589e5:             psGetStatsForTable, psGetTableId,
1:ff589e5:             psGetIdToNameMapConglom, psGetIdToNameMapTable
1:ff589e5:         };
1:ff589e5:         for (int i=0; i < psToClose.length; i++) {
1:ff589e5:             try {
1:ff589e5:                 if (psToClose[i] != null) {
1:ff589e5:                     psToClose[i].close();
1:ff589e5:                 }
1:ff589e5:             } catch (SQLException sqle) {
1:ff589e5:                 // Ignore
1:ff589e5:             }
1:ff589e5:         }
1:ff589e5:         try {
1:ff589e5:             if (!con.isClosed()) {
1:ff589e5:                 con.rollback();
1:ff589e5:             }
1:5a72b2c:             if (closeConnection) {
1:5a72b2c:                 con.close();
1:5a72b2c:             }
1:ff589e5:         } catch (SQLException sqle) {
1:ff589e5:             // Ignore
1:ff589e5:         }
1:ff589e5:     }
1:ff589e5: 
1:ff589e5:     /**
1:3574e10:      * Waits until all given statistics entries have been changed, or until
1:3574e10:      * the call times out.
1:3574e10:      * <p>
1:3574e10:      * <em>NOTE</em>: The method is built on the assumption that the UUIDs of
1:3574e10:      * statistics objects aren't reused. That is, when statistics are updated,
1:3574e10:      * the old row in SYS.SYSSTATISTICS will be dropped and a new row will be
1:3574e10:      * inserted.
1:3574e10:      *
1:3574e10:      * @param current the statistics that must change / be replaced
1:3574e10:      * @param timeout maximum number of milliseconds to wait before giving up
1:3574e10:      * @throws SQLException if obtaining statistics fails
1:3574e10:      */
1:3574e10:     private void awaitChange(IdxStats[] current, long timeout)
1:3574e10:             throws SQLException {
1:2510115:         Set<IdxStats> oldStats = new HashSet<IdxStats>(Arrays.asList(current));
1:2510115:         Set<IdxStats> newStats = null;
1:3574e10:         long start = System.currentTimeMillis();
1:3574e10:         // Make sure we run at least once.
1:3574e10:         while (System.currentTimeMillis() - start < timeout ||
1:3574e10:                 newStats == null) {
1:2510115:             newStats = new HashSet<IdxStats>(Arrays.asList(getStats()));
1:3574e10:             newStats.retainAll(oldStats);
1:3574e10:             if (newStats.isEmpty()) {
1:3574e10:                 return;
1:3574e10:             }
1:3574e10:             Utilities.sleep(200);
1:3574e10:         }
1:3574e10:         IdxStats[] outstanding = new IdxStats[newStats.size()];
1:3574e10:         newStats.toArray(outstanding);
1:3574e10:         Assert.fail(outstanding.length + " missing statistics changes " +
1:3574e10:                 "(timeout=" + timeout + "ms): " +
1:3574e10:                 buildStatString(outstanding, "<unchanged statistics>"));
1:3574e10:     }
1:3574e10: 
1:3574e10:     /**
1:ff589e5:      * Immutable class representing index statistics.
1:ff589e5:      */
1:ff589e5:     public static final class IdxStats {
1:ff589e5:         private static final String NA = "<n/a>";
1:ff589e5:         /** Number of rows in the table / index. */
1:ff589e5:         public final long rows;
1:ff589e5:         /** Cardinality of the index. */
1:ff589e5:         public final long card;
1:ff589e5:         /** Number of leading columns (in the index) for this stats object. */
1:ff589e5:         public final int lcols;
1:ff589e5:         public final String id;
1:ff589e5:         public final String tableId;
1:ff589e5:         public final String tableName;
1:ff589e5:         public final String indexId;
1:ff589e5:         public final String indexName;
1:ff589e5:         public final Timestamp created;
1:ff589e5: 
1:ff589e5:         /**
1:ff589e5:          * Creates a new statistics object with names for the table and the
1:ff589e5:          * index specified for convenience.
1:ff589e5:          *
1:ff589e5:          * @param id statistics identifier
1:ff589e5:          * @param indexId index identifier
1:ff589e5:          * @param indexName index name (may be {@code null})
1:ff589e5:          * @param tableId table identifier
1:ff589e5:          * @param tableName table name (may be {@code null})
1:ff589e5:          * @param created creation timestamp
1:ff589e5:          * @param lcols number of leading columns
1:ff589e5:          * @param stats the statistics, as reported when doing {@code getString}
1:ff589e5:          *      on the column {@code STATISTICS} in {@code SYS.SYSSTATISTICS}
1:ff589e5:          *      (number of unique rows and total rows, for instance
1:ff589e5:          *      "numunique= 3 numrows= 3")
1:ff589e5:          */
1:ff589e5:         public IdxStats(String id, String indexId, String indexName,
1:ff589e5:                         String tableId, String tableName,
1:ff589e5:                         Timestamp created, int lcols, String stats) {
1:ff589e5:             this.id = id;
1:ff589e5:             this.indexId = indexId;
1:ff589e5:             this.indexName = indexName != null ? indexName : NA;
1:ff589e5:             this.tableId = tableId;
1:ff589e5:             this.tableName = tableName != null ? tableName : NA;
1:ff589e5:             this.created = created;
1:ff589e5:             this.lcols = lcols;
1:ff589e5:             // "numunique= 3 numrows= 3"
1:ff589e5:             int uniqPos = stats.indexOf('=');
1:ff589e5:             int space = stats.indexOf(' ', uniqPos+2);
1:ff589e5:             int rowsPos = stats.indexOf('=', space);
1:ff589e5:             this.card =
1:ff589e5:                     Integer.parseInt(stats.substring(uniqPos+1, space).trim());
1:ff589e5:             this.rows =
1:ff589e5:                     Integer.parseInt(stats.substring(rowsPos+1).trim());
1:ff589e5:         }
1:ff589e5: 
1:ff589e5:         public boolean after(IdxStats other) {
1:ff589e5:             return created.after(other.created);
1:ff589e5:         }
1:ff589e5: 
1:ff589e5:         public boolean before(IdxStats other) {
1:ff589e5:             return created.before(other.created);
1:ff589e5:         }
1:ff589e5: 
1:ff589e5:         public String toString() {
1:ff589e5:             // Note that not all available information is printed.
1:ff589e5:             // Add more if required for debugging.
1:ff589e5:             StringBuffer sb = new StringBuffer(200);
1:ff589e5:             sb.append("{tableId=").append(tableId).
1:ff589e5:                     append(", tableName=").append(tableName).
1:ff589e5:                     append(", indexName=").append(indexName).
1:ec5de74:                     append(", lcols=").append(lcols).
1:ff589e5:                     append(", rows=").append(rows).
1:ff589e5:                     append(", unique/card=").append(card).
1:ff589e5:                     append(", created=").append(created).append('}');
1:ff589e5:             return sb.toString();
1:ff589e5:         }
1:1e0e0ca: 
1:1e0e0ca:         /**
1:1e0e0ca:          * Equality is based on the statistics entry UUID.
1:1e0e0ca:          *
1:1e0e0ca:          * @param obj other object
1:1e0e0ca:          * @return {@code true} if the other object is considered equal to this
1:1e0e0ca:          */
1:1e0e0ca:         public boolean equals(Object obj) {
1:1e0e0ca:             if (obj == null) {
1:1e0e0ca:                 return false;
1:1e0e0ca:             }
1:1e0e0ca:             if (getClass() != obj.getClass()) {
1:1e0e0ca:                 return false;
1:1e0e0ca:             }
1:1e0e0ca:             final IdxStats other = (IdxStats) obj;
1:1e0e0ca:             return this.id.equals(other.id);
1:1e0e0ca:         }
1:1e0e0ca: 
1:1e0e0ca:         public int hashCode() {
1:1e0e0ca:             int hash = 7;
1:1e0e0ca:             hash = 17 * hash + this.id.hashCode();
1:1e0e0ca:             return hash;
1:1e0e0ca:         }
1:ff589e5:     }
1:ff589e5: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:     private Map<String, String> getIdToNameMap()
/////////////////////////////////////////////////////////////////////////
1:         Map<String, String> map = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1:     private IdxStats[] buildStatisticsList(
1:             ResultSet rs, Map<String, String> idToName)
1:         List<IdxStats> stats = new ArrayList<IdxStats>();
1:                     idToName.get(rs.getString(2)),
1:                     idToName.get(rs.getString(3)),
1:         return stats.toArray(new IdxStats[stats.size()]);
/////////////////////////////////////////////////////////////////////////
1:         Set<IdxStats> oldStats = new HashSet<IdxStats>(Arrays.asList(current));
1:         Set<IdxStats> newStats = null;
1:             newStats = new HashSet<IdxStats>(Arrays.asList(getStats()));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:3574e10
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
1:      * Waits for the current statistics to disappear and expects to fetch the
1:      * same number of new statistics for the table.
1:      *
1:      * @param table the table to get statistics for
1:      * @param currentStats the current statistics
1:      * @return The new statistics.
1:      * @throws SQLException if obtaining statistics fails
1:      */
1:     public IdxStats[] getNewStatsTable(String table, IdxStats[] currentStats)
1:             throws SQLException {
1:         if (timeout == 0) {
1:             throw new IllegalStateException(
1:                     "no timeout specified in the constructor");
1:         }
1:         awaitChange(currentStats, timeout);
1:         return getStatsTable(table, currentStats.length);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Waits until all given statistics entries have been changed, or until
1:      * the call times out.
1:      * <p>
1:      * <em>NOTE</em>: The method is built on the assumption that the UUIDs of
1:      * statistics objects aren't reused. That is, when statistics are updated,
1:      * the old row in SYS.SYSSTATISTICS will be dropped and a new row will be
1:      * inserted.
1:      *
1:      * @param current the statistics that must change / be replaced
1:      * @param timeout maximum number of milliseconds to wait before giving up
1:      * @throws SQLException if obtaining statistics fails
1:      */
1:     private void awaitChange(IdxStats[] current, long timeout)
1:             throws SQLException {
0:         Set oldStats = new HashSet(Arrays.asList(current));
0:         Set newStats = null;
1:         long start = System.currentTimeMillis();
1:         // Make sure we run at least once.
1:         while (System.currentTimeMillis() - start < timeout ||
1:                 newStats == null) {
0:             newStats = new HashSet(Arrays.asList(getStats()));
1:             newStats.retainAll(oldStats);
1:             if (newStats.isEmpty()) {
1:                 return;
1:             }
1:             Utilities.sleep(200);
1:         }
1:         IdxStats[] outstanding = new IdxStats[newStats.size()];
1:         newStats.toArray(outstanding);
1:         Assert.fail(outstanding.length + " missing statistics changes " +
1:                 "(timeout=" + timeout + "ms): " +
1:                 buildStatString(outstanding, "<unchanged statistics>"));
1:     }
1: 
1:     /**
commit:bce78c9
/////////////////////////////////////////////////////////////////////////
1:     public static String buildStatString(IdxStats[] stats, String name) {
commit:5a72b2c
/////////////////////////////////////////////////////////////////////////
1:      * Releases resources and closes the associated connection.
1:         release(true);
1:     }
1: 
1:     /**
1:      * Releases resources.
1:      *
1:      * @param closeConnection whether to close the associated connection
1:      */
1:     public void release(boolean closeConnection) {
/////////////////////////////////////////////////////////////////////////
1:             if (closeConnection) {
1:                 con.close();
1:             }
commit:ec5de74
/////////////////////////////////////////////////////////////////////////
1:                     append(", lcols=").append(lcols).
commit:1e0e0ca
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * The <em>timeout</em> value is used to make the utility more resilient to
1:  * differences in timing due to varying scheduling decisions, processor speeds,
1:  * etc. If the system table contains the wrong number of statistics objects for
1:  * the query, it will be queried repeatedly until the right number of statistics
1:  * objects is obtained or the query times out.
1:     private static final boolean INDEX = false;
1:     private static final boolean TABLE = true;
1:     private static final int NO_EXPECTATION = -1;
1:     private static final String SEP =
1:                 BaseJDBCTestCase.getSystemProperty("line.separator");
1: 
1:     /** Timeout in milliseconds. */
1:     private final long timeout;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Creates an instance querying the given database with no timeout set.
1:      * <p>
1:      * Querying with no timeout means that if there are too few or too many
1:      * statistics objects matching the query, a failure will be raised
1:      * immediately.
1:      *
1:      * @param con connection to the database to query
1:      */
1:     public IndexStatsUtil(Connection con) {
1:         this(con, 0L);
1:     }
1: 
1:     /**
1:      * Creates an instance querying the given database with the specified
1:      * timeout value.
1:      *
1:      * @param con connection to the database to query
1:      * @param timeout the longest time to wait to see if the expectations for a
1:      *      query are met (milliseconds)
1:      */
1:     public IndexStatsUtil(Connection con, long timeout) {
1:         try {
1:             Assert.assertTrue(con.getAutoCommit());
1:         } catch (SQLException sqle) {
1:             Assert.fail("Failed to get auto commit: " + sqle.getMessage());
1:         }
1:         if (timeout < 0) {
1:             throw new IllegalArgumentException("timeout cannot be negative");
1:         }
1:         this.timeout = timeout;
/////////////////////////////////////////////////////////////////////////
1:         IdxStats[] ret = getStats();
1:         if (ret.length != expectedCount) {
1:             Assert.assertEquals(buildStatString(ret, "<ALL TABLES>"),
1:                     expectedCount, ret.length);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         getStatsTable(table, expectedCount);
/////////////////////////////////////////////////////////////////////////
1:         getStatsIndex(index, expectedCount);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     "select * from SYS.SYSSTATISTICS " +
1:                     "order by TABLEID, REFERENCEID, COLCOUNT");
/////////////////////////////////////////////////////////////////////////
1:         return getStatsTable(table, NO_EXPECTATION);
1:     }
1: 
1:     /**
1:      * Obtains statistics for the specified table, fails if the number of
1:      * statistics objects isn't as expected within the timeout.
1:      *
1:      * @param table table name
1:      * @param expectedCount number of expected statistics objects
1:      * @return A list of statistics entries (possibly empty).
1:      * @throws SQLException if obtaining the statistics fail
1:      */
1:     public IdxStats[] getStatsTable(String table, int expectedCount)
1:             throws SQLException {
1: 
1:         IdxStats[] ret = querySystemTable(tableId, TABLE, expectedCount);
1:         // Avoid building the stat string if not necessary.
1:         if (expectedCount != NO_EXPECTATION && ret.length != expectedCount) {
1:             Assert.assertEquals("failed to get statistics for table " + table +
1:                     " (#expected=" + expectedCount + ", timeout=" + timeout +
1:                     ")" + SEP + buildStatString(ret, table),
1:                     expectedCount, ret.length);
1:         }
1:         return ret;
/////////////////////////////////////////////////////////////////////////
1:         return getStatsIndex(index, NO_EXPECTATION);
1:     }
1: 
1:     /**
1:      * Obtains statistics for the specified index, fails if the number of
1:      * statistics objects isn't as expected within the timeout.
1:      *
1:      * @param index index name
1:      * @param expectedCount number of expected statistics objects
1:      * @return A list of statistics entries (possibly empty).
1:      * @throws SQLException if obtaining the statistics fail
1:      */
1:     public IdxStats[] getStatsIndex(String index, int expectedCount)
1:              throws SQLException {
1: 
1:         IdxStats[] ret = querySystemTable(indexId, INDEX, expectedCount);
1:         // Avoid building the stat string if not necessary.
1:         if (expectedCount != NO_EXPECTATION && ret.length != expectedCount) {
1:             Assert.assertEquals("failed to get statistics for index " + index +
1:                     " (#expected=" + expectedCount + ", timeout=" + timeout +
1:                     ")" + SEP + buildStatString(ret, index),
1:                     expectedCount, ret.length);
1:         }
1:         return ret;
1:     }
1: 
1:     /**
1:      * Queries the system table {@code SYS.SYSSTATISTICS} for statistics
1:      * associated with a specific table or index.
1:      *
1:      * @param conglomId conglomerate id (UUID)
1:      * @param isTable tells if the conglomerate is a table or an index
1:      * @param expectedCount the number of statistics objects expected, use
1:      *      {@code NO_EXPECTATION} to return whatever matches the query
1:      *      immediately
1:      */
1:     private IdxStats[] querySystemTable(String conglomId, boolean isTable,
1:                                         int expectedCount)
1:             throws SQLException {
1:         // Assign the correct prepared statement.
1:         PreparedStatement ps;
1:         if (isTable) {
1:             if (psGetStatsForTable == null) {
1:                 psGetStatsForTable = con.prepareStatement(
1:                         "select * from SYS.SYSSTATISTICS " +
1:                             "where TABLEID = ? " +
1:                             "order by REFERENCEID, COLCOUNT");
1:             }
1:             ps = psGetStatsForTable;
1:         } else {
1:             if (psGetStatsForIndex == null) {
1:                 psGetStatsForIndex = con.prepareStatement(
1:                         "select * from SYS.SYSSTATISTICS " +
1:                             "where REFERENCEID = ? " +
1:                             "order by COLCOUNT");
1:             }
1:             ps = psGetStatsForIndex;
1:         }
1:         ps.setString(1, conglomId);
1: 
1:         long started = System.currentTimeMillis();
1:         long waited = -1;
1:         IdxStats[] ret = null;
1:         while (waited < timeout) {
1:             // Don't wait the first time.
1:             if (ret != null) {
1:                 Utilities.sleep(Math.min(250L, timeout - waited));
1:             }
1:             ret = buildStatisticsList(ps.executeQuery(), getIdToNameMap());
1:             if (expectedCount == NO_EXPECTATION || ret.length == expectedCount){
1:                 break;
1:             }
1:             waited = System.currentTimeMillis() - started;
1:         }
1:         return ret;
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * Equality is based on the statistics entry UUID.
1:          *
1:          * @param obj other object
1:          * @return {@code true} if the other object is considered equal to this
1:          */
1:         public boolean equals(Object obj) {
1:             if (obj == null) {
1:                 return false;
1:             }
1:             if (getClass() != obj.getClass()) {
1:                 return false;
1:             }
1:             final IdxStats other = (IdxStats) obj;
1:             return this.id.equals(other.id);
1:         }
1: 
1:         public int hashCode() {
1:             int hash = 7;
1:             hash = 17 * hash + this.id.hashCode();
1:             return hash;
1:         }
commit:6bc69d9
/////////////////////////////////////////////////////////////////////////
1:      * Asserts that there are no existing statistics for the specified table.
1:      *
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void assertNoStatsTable(String table)
1:             throws SQLException {
1:         assertTableStats(table, 0);
1:     }
1: 
1:     /**
commit:ff589e5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.junit.IndexStatsUtil
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.junit;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Timestamp;
1: 
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.List;
1: import java.util.Map;
1: 
1: import junit.framework.Assert;
1: 
1: /**
1:  * Helper class for obtaining index statistics and doing asserts on them.
1:  * <p>
1:  * This implementation assumes all tables/indexes belong to the current schema.
1:  */
1: public class IndexStatsUtil {
1: 
1:     private final Connection con;
1:     private PreparedStatement psGetTableId;
1:     private PreparedStatement psGetStatsForTable;
1:     private PreparedStatement psGetIndexId;
1:     private PreparedStatement psGetStatsForIndex;
1:     private PreparedStatement psGetStats;
1:     private PreparedStatement psGetIdToNameMapConglom;
1:     private PreparedStatement psGetIdToNameMapTable;
1: 
0:     public IndexStatsUtil(Connection con)
1:             throws SQLException {
1:         // Rely on auto-commit to release locks.
0:         Assert.assertTrue(con.getAutoCommit());
1:         this.con = con;
1:     }
1: 
1:     /**
1:      * Asserts that there are no existing statistics in the database.
1:      *
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void assertNoStats()
1:             throws SQLException {
1:         assertStats(0);
1:     }
1: 
1:     /**
1:      * Asserts that the expected number of statistics exists.
1:      *
1:      * @param expectedCount expected number of statistics
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void assertStats(int expectedCount)
1:             throws SQLException {
0:         assertStatCount(getStats(), "<ALL>", expectedCount, false);
1:     }
1: 
1:     /**
1:      * Asserts that the expected number of statistics exists for the specified
1:      * table.
1:      *
1:      * @param table the target table
1:      * @param expectedCount expected number of statistics
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void assertTableStats(String table, int expectedCount)
1:             throws SQLException {
0:         assertStatCount(getStatsTable(table), table, expectedCount, false);
1:     }
1: 
1:     /**
1:      * Asserts that the expected number of statistics exists for the specified
1:      * index.
1:      *
1:      * @param index the target index
1:      * @param expectedCount expected number of statistics
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void assertIndexStats(String index, int expectedCount)
1:             throws SQLException {
0:         assertStatCount(getStatsIndex(index), index, expectedCount, true);
1:     }
1: 
1:     /**
1:      * Asserts that the expected number of statistics exists.
1:      *
0:      * @param stats statistics
0:      * @param conglom conglomerate name
1:      * @param expectedCount expected number of statistics
0:      * @param isIndex {@code true} if the conglomerate is an index
1:      */
0:     private void assertStatCount(IdxStats[] stats, String conglom,
0:                                  int expectedCount, boolean isIndex) {
0:         if (stats.length != expectedCount) {
0:             String name = (isIndex ? "index " : "table ") + "'" + conglom + "'";
0:             Assert.assertEquals(buildStatString(stats, name),
0:                     expectedCount, stats.length);
1:         }
1:     }
1: 
1:     /**
1:      * Builds a human readable representation of a list of statistics objects.
1:      *
1:      * @param stats a list of statistics (possibly empty)
1:      * @param name the name of the table(s)/index(es) associated with the stats
1:      * @return A string representation of the statistics.
1:      */
0:     private String buildStatString(IdxStats[] stats, String name) {
0:         String SEP =
0:                 BaseJDBCTestCase.getSystemProperty("line.separator");
1:         StringBuffer sb = new StringBuffer(
1:                 "Index statistics for " + name + SEP);
1:         for (int i=0; i < stats.length; i++) {
1:             sb.append(i+1).append(": ").append(stats[i].toString()).
1:                     append(SEP);
1:         }
1:         if (stats.length == 0) {
1:             sb.append(" : <no stats>").append(SEP);
1:         }
1:         return sb.toString();
1:     }
1: 
1:     /**
1:      * Obtains all existing statistics entries.
1:      *
1:      * @return A list of statistics entries (possibly empty).
1:      * @throws SQLException if obtaining the statistics fail
1:      */
1:     public IdxStats[] getStats()
1:             throws SQLException {
1:         if (psGetStats == null) {
1:             psGetStats = con.prepareStatement(
0:                     "select * from SYS.SYSSTATISTICS");
1:         }
1:         return buildStatisticsList(psGetStats.executeQuery(), getIdToNameMap());
1:     }
1: 
1:     /**
1:      * Obtains statistics for the specified table.
1:      *
1:      * @param table table name
1:      * @return A list of statistics entries (possibly empty).
1:      * @throws SQLException if obtaining the statistics fail
1:      */
1:     public IdxStats[] getStatsTable(String table)
1:             throws SQLException {
1:         if (psGetTableId == null) {
1:             psGetTableId = con.prepareStatement(
1:                 "select TABLEID from SYS.SYSTABLES where TABLENAME = ?");
1:         }
0:         if (psGetStatsForTable == null) {
0:             psGetStatsForTable = con.prepareStatement(
0:                 "select * from SYS.SYSSTATISTICS where TABLEID = ?");
1:         }
1:         psGetTableId.setString(1, table);
1:         ResultSet rs = psGetTableId.executeQuery();
1:         Assert.assertTrue("No such table: " + table, rs.next());
1:         String tableId = rs.getString(1);
1:         Assert.assertFalse("More than one table named " + table, rs.next());
1:         rs.close();
0:         psGetStatsForTable.setString(1, tableId);
0:         return buildStatisticsList(
0:                 psGetStatsForTable.executeQuery(), getIdToNameMap());
1:     }
1: 
1:     /**
1:      * Obtains statistics for the specified index.
1:      *
1:      * @param index index name
1:      * @return A list of statistics entries (possibly empty).
1:      * @throws SQLException if obtaining the statistics fail
1:      */
1:     public IdxStats[] getStatsIndex(String index)
1:              throws SQLException {
1:         if (psGetIndexId == null) {
1:             psGetIndexId = con.prepareStatement(
1:                     "select CONGLOMERATEID from SYS.SYSCONGLOMERATES where " +
1:                     "CONGLOMERATENAME = ? and " +
1:                     "CAST(ISINDEX as VARCHAR(5)) = 'true'");
1:         }
0:         if (psGetStatsForIndex == null) {
0:             psGetStatsForIndex = con.prepareStatement(
0:                    "select * from SYS.SYSSTATISTICS where REFERENCEID = ?");
1:         }
1:         psGetIndexId.setString(1, index);
1:         ResultSet rs = psGetIndexId.executeQuery();
1:         Assert.assertTrue("No such index: " + index, rs.next());
1:         String indexId = rs.getString(1);
1:         Assert.assertFalse("More than one index named " + index, rs.next());
1:         rs.close();
0:         psGetStatsForIndex.setString(1, indexId);
0:         return buildStatisticsList(
0:                 psGetStatsForIndex.executeQuery(), getIdToNameMap());
1:     }
1: 
1:     /**
1:      * Prints all entries in the {@code SYS.SYSSTATISTICS} system table.
1:      *
1:      * @throws SQLException if obtaining the statistics fails
1:      */
1:     public void printStats()
1:             throws SQLException {
1:         System.out.println(buildStatString(getStats(), "all tables"));
1:     }
1: 
1:     /**
1:      * Generates a map from ids to names for conglomerates in the database.
1:      * <p>
1:      * Convenience method, used for better reporting.
1:      *
1:      * @return Mappings from conglomerate id to conglomerate name.
1:      * @throws SQLException if accessing the system tables fail
1:      */
0:     private Map getIdToNameMap()
1:             throws SQLException {
1:         if (psGetIdToNameMapConglom == null) {
1:             psGetIdToNameMapConglom = con.prepareStatement(
1:                     "select CONGLOMERATEID, CONGLOMERATENAME " +
1:                     "from SYS.SYSCONGLOMERATES");
1:         }
1:         if (psGetIdToNameMapTable == null) {
1:             psGetIdToNameMapTable = con.prepareStatement(
1:                     "select TABLEID, TABLENAME from SYS.SYSTABLES");
1:         }
0:         Map map = new HashMap();
1:         ResultSet rs = psGetIdToNameMapConglom.executeQuery();
1:         while (rs.next()) {
1:             map.put(rs.getString(1), rs.getString(2));
1:         }
1:         rs.close();
1:         rs = psGetIdToNameMapTable.executeQuery();
1:         while (rs.next()) {
1:             map.put(rs.getString(1), rs.getString(2));
1:         }
1:         rs.close();
1:         return map;
1:     }
1: 
1:     /**
1:      * Builds an array of statistics objects from data from the
1:      * {@code SYS.SYSSTATISTICS} system table.
1:      *
1:      * @param rs a result set containing rows from {@code SYS.SYSSTATISTICS}
1:      * @return A list of statistics objects
1:      * @throws SQLException if accessing the result set fails
1:      */
0:     private IdxStats[] buildStatisticsList(ResultSet rs, Map idToName)
1:             throws SQLException {
0:         List stats = new ArrayList();
1:         while (rs.next()) {
1:             // NOTE: Bad practice to call rs.getString(X) twice, but it works
1:             //       for Derby with the string type...
1:             stats.add(new IdxStats(rs.getString(1), rs.getString(2),
0:                     (String)idToName.get(rs.getString(2)),
1:                     rs.getString(3),
0:                     (String)idToName.get(rs.getString(3)),
1:                     rs.getTimestamp(4), rs.getInt(7),
1:                     rs.getString(8)));
1:         }
1:         rs.close();
0:         IdxStats[] s = new IdxStats[stats.size()];
0:         stats.toArray(s);
0:         return s;
1:     }
1: 
1:     /**
0:      * Releases resources.
1:      */
1:     public void release() {
1:         PreparedStatement[] psToClose = new PreparedStatement[] {
1:             psGetStats, psGetIndexId, psGetStatsForIndex,
1:             psGetStatsForTable, psGetTableId,
1:             psGetIdToNameMapConglom, psGetIdToNameMapTable
1:         };
1:         for (int i=0; i < psToClose.length; i++) {
1:             try {
1:                 if (psToClose[i] != null) {
1:                     psToClose[i].close();
1:                 }
1:             } catch (SQLException sqle) {
1:                 // Ignore
1:             }
1:         }
1:         try {
1:             if (!con.isClosed()) {
1:                 con.rollback();
1:             }
0:             con.close();
1:         } catch (SQLException sqle) {
1:             // Ignore
1:         }
1:     }
1: 
1:     /**
1:      * Immutable class representing index statistics.
1:      */
1:     public static final class IdxStats {
1:         private static final String NA = "<n/a>";
1:         /** Number of rows in the table / index. */
1:         public final long rows;
1:         /** Cardinality of the index. */
1:         public final long card;
1:         /** Number of leading columns (in the index) for this stats object. */
1:         public final int lcols;
1:         public final String id;
1:         public final String tableId;
1:         public final String tableName;
1:         public final String indexId;
1:         public final String indexName;
1:         public final Timestamp created;
1: 
1:         /**
1:          * Creates a new statistics object with names for the table and the
1:          * index specified for convenience.
1:          *
1:          * @param id statistics identifier
1:          * @param indexId index identifier
1:          * @param indexName index name (may be {@code null})
1:          * @param tableId table identifier
1:          * @param tableName table name (may be {@code null})
1:          * @param created creation timestamp
1:          * @param lcols number of leading columns
1:          * @param stats the statistics, as reported when doing {@code getString}
1:          *      on the column {@code STATISTICS} in {@code SYS.SYSSTATISTICS}
1:          *      (number of unique rows and total rows, for instance
1:          *      "numunique= 3 numrows= 3")
1:          */
1:         public IdxStats(String id, String indexId, String indexName,
1:                         String tableId, String tableName,
1:                         Timestamp created, int lcols, String stats) {
1:             this.id = id;
1:             this.indexId = indexId;
1:             this.indexName = indexName != null ? indexName : NA;
1:             this.tableId = tableId;
1:             this.tableName = tableName != null ? tableName : NA;
1:             this.created = created;
1:             this.lcols = lcols;
1:             // "numunique= 3 numrows= 3"
1:             int uniqPos = stats.indexOf('=');
1:             int space = stats.indexOf(' ', uniqPos+2);
1:             int rowsPos = stats.indexOf('=', space);
1:             this.card =
1:                     Integer.parseInt(stats.substring(uniqPos+1, space).trim());
1:             this.rows =
1:                     Integer.parseInt(stats.substring(rowsPos+1).trim());
1:         }
1: 
1:         public boolean after(IdxStats other) {
1:             return created.after(other.created);
1:         }
1: 
1:         public boolean before(IdxStats other) {
1:             return created.before(other.created);
1:         }
1: 
1:         public String toString() {
1:             // Note that not all available information is printed.
1:             // Add more if required for debugging.
1:             StringBuffer sb = new StringBuffer(200);
1:             sb.append("{tableId=").append(tableId).
1:                     append(", tableName=").append(tableName).
1:                     append(", indexName=").append(indexName).
1:                     append(", rows=").append(rows).
1:                     append(", unique/card=").append(card).
1:                     append(", created=").append(created).append('}');
1:             return sb.toString();
1:         }
1:     }
1: }
============================================================================