1:1a36302: /*
1:1a36302:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.AccessTest
1:1a36302: 
1:1a36302:    Licensed to the Apache Software Foundation (ASF) under one
1:1a36302:    or more contributor license agreements.  See the NOTICE file
1:1a36302:    distributed with this work for additional information
1:1a36302:    regarding copyright ownership.  The ASF licenses this file
1:1a36302:    to you under the Apache License, Version 2.0 (the
1:1a36302:    "License"); you may not use this file except in compliance
1:1a36302:    with the License.  You may obtain a copy of the License at
1:1a36302:    
1:1a36302:    http://www.apache.org/licenses/LICENSE-2.0
1:1a36302:    
1:1a36302:    Unless required by applicable law or agreed to in writing,
1:1a36302:    software distributed under the License is distributed on an
1:1a36302:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1a36302:    KIND, either express or implied.  See the License for the
1:1a36302:    specific language governing permissions and limitations
1:1a36302:    under the License.
1:1a36302: */
1:1a36302: 
1:1a36302: package org.apache.derbyTesting.functionTests.tests.store;
1:1a36302: 
1:1a36302: import java.sql.CallableStatement;
1:1a36302: import java.sql.Connection;
1:1a36302: import java.sql.PreparedStatement;
1:1a36302: import java.sql.ResultSet;
1:1a36302: import java.sql.SQLException;
1:1a36302: import java.sql.Statement;
1:1a36302: import java.util.Properties;
1:1a36302: 
1:efe47b4: import junit.framework.AssertionFailedError;
1:1a36302: import junit.framework.Test;
1:1a36302: 
1:1a36302: import org.apache.derbyTesting.functionTests.util.Formatters;
1:1a36302: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1a36302: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1a36302: import org.apache.derbyTesting.junit.JDBC;
1:1a36302: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:1a36302: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1a36302: import org.apache.derbyTesting.junit.TestConfiguration;
1:1a36302: 
1:1a36302: 
1:1a36302: public final class AccessTest extends BaseJDBCTestCase {
1:1a36302: 
1:1a36302:     /**
1:9b3569f:      * Array with names of database properties that may be modified by
1:9b3569f:      * the test cases in this class. The properties will be cleared in
1:9b3569f:      * {@link #tearDown()}.
1:9b3569f:      */
1:9b3569f:     private static final String[] MODIFIED_DB_PROPS = {
1:9b3569f:         "derby.storage.pageSize",
1:9b3569f:         "derby.storage.minimumRecordSize",
1:9b3569f:         "derby.storage.pageReservedSpace",
1:9b3569f:     };
1:1a36302: 
1:9b3569f:     /**
1:1a36302:      * Public constructor required for running test as standalone JUnit.
1:1a36302:      */
1:1a36302:     public AccessTest(String name)
1:1a36302:     {
1:1a36302:         super(name);
1:1a36302:     }
1:1a36302:     
1:1a36302:     public static Test suite() {
1:1a36302:         Properties sysProps = new Properties();
1:1a36302:         sysProps.put("derby.optimizer.optimizeJoinOrder", "false");
1:1a36302:         sysProps.put("derby.optimizer.ruleBasedOptimization", "true");
1:1a36302:         sysProps.put("derby.optimizer.noTimeout", "true");
1:1a36302: 
1:1a36302:         Test suite = TestConfiguration.embeddedSuite(AccessTest.class);
1:1a36302:         return new CleanDatabaseTestSetup(new SystemPropertyTestSetup(suite, sysProps, true)) {
1:1a36302:             /**
1:1a36302:              * Creates the table used in the test cases.
1:1a36302:              *
1:1a36302:              */
1:1a36302:             protected void decorateSQL(Statement s) throws SQLException {
1:1a36302:                 Connection conn = s.getConnection();
1:1a36302:                 conn.setAutoCommit(false);
1:1a36302: 
1:1a36302:                 s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:1a36302:                         + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME " +
1:1a36302:                         "'org.apache.derbyTesting.functionTests.util.Formatters" +
1:1a36302:                 ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:1a36302:             }
1:1a36302:         };
1:1a36302:     }    
1:9b3569f: 
1:9b3569f:     /**
1:9b3569f:      * Tear down the test environment.
1:9b3569f:      */
1:9b3569f:     protected void tearDown() throws Exception {
1:9b3569f:         rollback();
1:40ca7ba:         Statement s = createStatement();
1:40ca7ba:         //DERBY-5119 Table foo is used in lots of fixtures.
1:40ca7ba:         // make sure it gets cleaned up.
1:1a36302:         try {
1:40ca7ba:             s.executeUpdate("DROP TABLE FOO");
1:40ca7ba:         } catch (SQLException se) {
1:40ca7ba:             // if the table couldn't drop make sure it is because it doesn't
1:40ca7ba:             // exist
1:40ca7ba:             assertSQLState("42Y55",se);
1:1a36302:         }
1:9b3569f:         // Clear the database properties set by this test so that they
1:9b3569f:         // don't affect other tests.
1:9b3569f:         PreparedStatement clearProp = prepareStatement(
1:9b3569f:                 "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, NULL)");
1:9b3569f:         for (int i = 0; i < MODIFIED_DB_PROPS.length; i++) {
1:9b3569f:             clearProp.setString(1, MODIFIED_DB_PROPS[i]);
1:9b3569f:             clearProp.executeUpdate();
1:c211833:         }
1:9b3569f:         commit();
3:9b3569f: 
1:1a36302:         super.tearDown();
1:1a36302:     }
1:1a36302: 
1:1a36302:     //---------------------------------------------------------
1:1a36302:     //    test qualifier skip code on fields with length  
1:1a36302:     //    having the 8th bit set in low order length byte. 
1:1a36302:     // --------------------------------------------------------
1:1a36302:     public void testQualifierSkipLOLB() throws Exception
1:1a36302:     {
1:1a36302: 
2:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
2:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         setAutoCommit(false);
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '32768')");
1:1a36302:         cSt.execute();
1:1a36302:         st.executeUpdate("create table a ( " +
1:1a36302:                 "i1 int, col00 varchar(384), col01 varchar(390), i2 int )");
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         // insert rows
1:1a36302:         st.executeUpdate(
1:1a36302:                 "insert into a values (1, PADSTRING('10',384), "
1:1a36302:                 + "PADSTRING('100',390), 1000)");
1:1a36302:         st.executeUpdate(
1:1a36302:                 "insert into a values (2, PADSTRING('20',384), "
1:1a36302:                 + "PADSTRING('200',390), 2000)");
1:1a36302:         st.executeUpdate(
1:1a36302:                 "insert into a values (3, PADSTRING('30',384), "
1:1a36302:                 + "PADSTRING('300',390), 3000)");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select i1, i2 from a where i2 = 3000");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"I1", "I2"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][] {{"3", "3000"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table a");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302: 
1:1a36302:     // test case for a fixed bug where the problem was that the btree split 
1:1a36302:     // would self deadlock while trying to reclaim rows during the split.
1:1a36302:     // Fixed by just giving up if btree can't get the locks during the 
1:1a36302:     // reclaim try.
1:1a36302:     public void testCSBug2590() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("create table foo (a int, b varchar(900), c int)");
1:1a36302: 
1:1a36302:         // insert
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('1',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (2, PADSTRING('2',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (3, PADSTRING('3',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (4, PADSTRING('4',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (5, PADSTRING('5',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (6, PADSTRING('6',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (7, PADSTRING('7',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (8, PADSTRING('8',900), 1)");
1:1a36302: 
1:1a36302:         CallableStatement cSt;
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '4096')");
1:1a36302:         cSt.execute();
1:1a36302:         st.executeUpdate("create index foox on foo (a, b)");
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 7, "delete from foo where foo.a <> 2");
1:1a36302: 
1:1a36302:         ResultSet rs = null;
1:1a36302:         String [][] expRS;
1:1a36302: 
1:1a36302:         // Test full cursor for update scan over all the rows in the heap,  
1:1a36302:         // with default group fetch.  Group fetch should be disabled.
1:1a36302:         
1:1a36302:         rs = st.executeQuery("select a, b, c from foo for update of c");
1:1a36302:         expRS = new String [][] {{"2","2","1"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // Do the same, but use a PreparedStatement.
1:1a36302:         PreparedStatement ps_scan_cursor = prepareStatement(
1:1a36302:             "select a, b, c from foo for update of c");
1:1a36302:         ResultSet scan_cursor = ps_scan_cursor.executeQuery();
1:1a36302:         expRS = new String [][] {{"2","2","1"}};
1:1a36302:         JDBC.assertFullResultSet(scan_cursor, expRS, true);
1:1a36302: 
1:1a36302:         // these inserts would cause a lock wait timeout before 
1:1a36302:         // the bug fix.
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('11',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('12',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('13',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('14',900), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('15',900), 1)");
1:1a36302: 
1:1a36302:         commit();
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302: 
1:1a36302:     // test case a fixed bug where the problem was that when 
1:1a36302:     // the level of btree grew, raw store would incorrectly 
1:1a36302:     // report that there was not enough space to move all the   
1:1a36302:     // rows from the root page to a newly allocated leaf page, 
1:1a36302:     // so the create index operation would fail with a 
1:1a36302:     // message saying that a row was too big. create and 
1:1a36302:     // load a table with values from 1024 down to 1, the 
1:1a36302:     // reverse order is important to reproduce the bug.
1:1a36302:     public void testCSBug735() throws Exception
1:1a36302:     {
1:1a36302: 
1:1a36302:         ResultSet rs = null;
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int)");
1:1a36302:         st.executeUpdate("insert into foo values (1024)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 1   from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 2   from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 4   from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 8   from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 16  from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 32  from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 64  from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 128 from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 256 from foo)");
1:1a36302:         st.executeUpdate("insert into foo (select foo.a - 512 from foo)");
1:1a36302:         
1:1a36302:         // this create index used to fail.
1:1a36302:         assertEquals(0, st.executeUpdate("create index a on foo (a)"));
1:1a36302: 
1:1a36302:         // Check the consistency of the indexes
2:1a36302:         rs = st.executeQuery(
1:1a36302:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'FOO')");
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][] {{"1"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // a delete of the whole table also exercises the index well.
1:1a36302:         assertUpdateCount(st, 1024, "delete from foo");
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     // stress the conglomerate directory.  
1:1a36302:     // abort of an alter table will clear the cache. 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     public void test_conglomDirectory() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         String [] expColNames;
1:1a36302:         setAutoCommit(false);
1:1a36302: 
1:1a36302:         st.executeUpdate("create table a (a int)");
1:1a36302:         commit();
1:1a36302:         st.executeUpdate("alter table a add column c1 int");
1:1a36302: 
1:1a36302:         rollback();
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select * from a");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table a");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302: 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     // ----- test case for partial row runtime statistics. ----- 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     /* This test checks correctness of simple runtime statistics.
1:1a36302:        It first exercises queries when there's no index present, then with
1:1a36302:         an index present; expecting to see a difference between Table Scan 
1:1a36302:         and Index Scan. Also of interest is that the qualifiers look right; 
1:1a36302:         whether it is using scan start/stop (this is a way to do qualifiers 
1:1a36302:         using index).
1:1a36302:        Then it does the same 2 actions after some rows have been
1:1a36302:         deleted, to exercise the 'deleted rows visited' section in the
1:1a36302:         runtime statistics.
1:1a36302:        The queries which are cycled through are:
1:1a36302:          query1: all columns & rows: "select * from foo"
1:1a36302:          query2 - just last column: "select e from foo"
1:1a36302:          query3: as subset of columns: "select e, c, a from foo"
1:1a36302:          query4: as subset of columns, with qualifier in list: 
1:1a36302:              "select e, c, a from foo where foo.e = 5"
1:1a36302:          query5: as subset of columns, with qualifier not in list: 
1:1a36302:              "select e, c, a from foo where foo.b = 20"
1:1a36302:          query6: as subset of columns: "select a, b from foo"
1:1a36302:      */
1:1a36302:     public void testPartialRowRTStats() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         setAutoCommit(false);
1:1a36302:         
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table foo (a int, b int, c int, d int, e int)");
1:1a36302:         st.executeUpdate("insert into foo values (1, 2, 3, 4, 5)");
1:1a36302:         st.executeUpdate("insert into foo values (10, 20, 30, 40, 50)");
1:1a36302:         
1:1a36302:         // switch on runtime statistics
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         runQueriesNormal(st);
1:1a36302: 
1:1a36302:         // now check index scans - force the index just to make sure it 
1:1a36302:         // does an index scan. 
1:1a36302:         st.executeUpdate("create index foo_cover on foo (e, d, c, b, a)");
1:1a36302:         runQueriesWithIndex(st);
1:1a36302:         // drop the index...
1:1a36302:         st.executeUpdate("drop index foo_cover");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','FOO',null)");
1:1a36302:         
1:1a36302:         // check deleted row feature
1:1a36302:         st.executeUpdate("insert into foo values (100, 2, 3, 4, 5)");
1:1a36302:         st.executeUpdate("insert into foo values (1000, 2, 3, 4, 5)");
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 100");
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1000");
1:1a36302:         runQueriesWithDeletedRows(st);
1:1a36302:         
1:1a36302:         // now check index scans again
1:1a36302:         // recreate the index to make sure it does an index scan.
1:1a36302:         st.execute("create index foo_cover on foo (e, d, c, b, a)");
1:1a36302:         // of course, we'll have to update statistics now before it looks good
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','FOO',null)");
1:1a36302:         // and then we have to re-delete the rows because update statistics would've
1:1a36302:         // reset the info about deleted rows.
1:1a36302:         st.executeUpdate("insert into foo values (100, 2, 3, 4, 5)");
1:1a36302:         st.executeUpdate("insert into foo values (1000, 2, 3, 4, 5)");
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 100");
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1000");
1:1a36302:         runQueriesWithIndexDeletedRows(st);
1:1a36302:         
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:     }
1:1a36302:     
1:1a36302:     /* method used in testPartialRowRTStats and testCostingCoveredQuery */
1:1a36302:     private void assertStatsOK(Statement st, String expectedScan, 
1:1a36302:             String expTableInIndexScan, String expIndexInIndexScan, 
1:1a36302:             String expBits, String expNumCols, String expDelRowsV,  
1:1a36302:             String expPages, String expRowsQ, String expRowsV, 
1:1a36302:             String expScanType, String expStartPosition, String expStopPosition,
1:1a36302:             String expQualifier, String expQualifierInfo)
1:1a36302:     throws SQLException {
1:efe47b4:         ResultSet rs = st.executeQuery(
1:1a36302:             "values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:1a36302:         rs.next();
1:efe47b4:         RuntimeStatisticsParser rtsp =
1:efe47b4:             new RuntimeStatisticsParser(rs.getString(1));
1:1a36302:         rs.close();
1:1a36302: 
1:efe47b4:         try {
1:1a36302:             if (expectedScan.equals("Table"))
1:1a36302:                     assertTrue(rtsp.usedTableScan());
1:1a36302:             else if (expectedScan.equals("Index"))
1:1a36302:             {
1:1a36302:                 assertTrue(rtsp.usedIndexScan());
1:1a36302:                 assertTrue(rtsp.usedSpecificIndexForIndexScan(
1:1a36302:                         expTableInIndexScan, expIndexInIndexScan));
1:1a36302:             }
1:1a36302:             else if (expectedScan.equals("Constraint"))
1:1a36302:             {
1:1a36302:                 assertTrue(rtsp.usedIndexScan());
1:1a36302:                 assertTrue(rtsp.usedConstraintForIndexScan(
1:1a36302:                         expTableInIndexScan));
1:1a36302:             }
1:1a36302:             assertTrue(rtsp.findString("Bit set of columns fetched="+expBits, 1));
1:1a36302:             assertTrue(rtsp.findString("Number of columns fetched="+expNumCols, 1));
1:1a36302:             if (expDelRowsV!=null)
1:1a36302:                 assertTrue(rtsp.findString("Number of deleted rows visited="+expDelRowsV, 1));
1:c211833: 
1:c211833: 
1:8454e15:             if (expPages != null) {
1:8454e15:                 assertTrue(
1:8454e15:                         "RuntimeStatisticsParser.findstring(Number of pages visited= "
1:8454e15:                         + expPages + ") returned false" +
1:8454e15:                         "full runtime statistics = " + rtsp.toString(),
1:8454e15:                         rtsp.findString("Number of pages visited=" + expPages, 1));
1:8454e15:             }
1:c211833: 
1:1a36302:             assertTrue(rtsp.findString("Number of rows qualified="+expRowsQ, 1));            
1:1a36302:             assertTrue(rtsp.findString("Number of rows visited="+expRowsV, 1));
1:1a36302:             assertTrue(rtsp.findString("Scan type="+expScanType, 1));
1:1a36302:             assertTrue(rtsp.getStartPosition()[1].indexOf(expStartPosition)>1);
1:1a36302:             assertTrue(rtsp.getStopPosition()[1].indexOf(expStopPosition)>1);
1:1a36302: 
1:1a36302:             if (expQualifier.equals("None"))
1:1a36302:                 assertTrue(rtsp.hasNoQualifiers());
1:1a36302:             else if (expQualifier.equals("Equals"))
1:1a36302:                 assertTrue(rtsp.hasEqualsQualifier());
1:1a36302:             if (expQualifierInfo !=null)
1:1a36302:                 assertTrue(rtsp.findString(expQualifierInfo, 1));
1:efe47b4:         } catch (AssertionFailedError e) {
1:efe47b4:             // One of the assertions failed. Report the full statistics
1:efe47b4:             // to help debugging.
1:efe47b4:             fail("Statistics didn't match:\n" + rtsp.toString(), e);
1:1a36302:         }
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void runQueriesNormal(Statement st) throws SQLException { 
1:1a36302:         doQuery1(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "All", "5", null, "1", "2", "2", 
1:1a36302:             "heap","null","null","None", null);
1:1a36302:         
1:1a36302:         doQuery2(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{4}", "1", null, "1", "2", "2", 
1:1a36302:             "heap","null","null","None", null);
1:1a36302: 
1:1a36302:         doQuery3(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "2", "2", 
1:1a36302:             "heap","null","null","None", null);
1:1a36302: 
1:1a36302:         doQuery4(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "1", "2", 
1:1a36302:             "heap","null","null","Equals","Column[0][0] Id: 4");
1:1a36302: 
1:1a36302:         doQuery5(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 1, 2, 4}", "4", null, "1", "1", "2", 
1:1a36302:             "heap","null","null","Equals","Column[0][0] Id: 1");
1:1a36302: 
1:1a36302:         doQuery6(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 1}", "2", null, "1", "2", "2", 
1:1a36302:             "heap","null","null","None",null);
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void runQueriesWithIndex(Statement st) throws SQLException {
1:1a36302:         doQuery1(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 1, 2, 3, 4}", "5", "0", "1", "2", "2", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery2(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0}", "1", "0", "1", "2", "2", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery3(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 4}", "3", "0", "1", "2", "2", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery4(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 4}", "3", "0", "1", "1", "2", 
1:1a36302:             "btree",">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         doQuery5(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 3, 4}", "4", "0", "1", "1", "2", "btree",
1:1a36302:             "None","None","Equals", "Column[0][0] Id: 3");
1:1a36302: 
1:1a36302:         doQuery6(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{3, 4}", "2", "0", "1", "2", "2", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void runQueriesWithDeletedRows(Statement st) throws SQLException {
1:1a36302:         doQuery1(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "All", "5", null, "1", "2", "4", "heap",
1:1a36302:             "null","null","None", null);
1:1a36302: 
1:1a36302:         doQuery2(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{4}", "1", null, "1", "2", "4", "heap",
1:1a36302:             "null","null","None", null);
1:1a36302: 
1:1a36302:         doQuery3(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "2", "4", "heap",
1:1a36302:             "null","null","None", null);
1:1a36302: 
1:1a36302:         doQuery4(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "1", "4", "heap",
1:1a36302:             "null","null","Equals","Column[0][0] Id: 4");
1:1a36302: 
1:1a36302:         doQuery5(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 1, 2, 4}", "4", null, "1", "1", "4", "heap",
1:1a36302:             "null","null","Equals","Column[0][0] Id: 1");
1:1a36302: 
1:1a36302:         doQuery6(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 1}", "2", null, "1", "2", "4", "heap",
1:1a36302:             "null","null","None",null);
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void runQueriesWithIndexDeletedRows(Statement st) throws SQLException {
1:1a36302:         doQuery1(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 1, 2, 3, 4}", "5", "2", "1", "2", "4", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery2(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0}", "1", "2", "1", "2", "4", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery3(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 4}", "3", "2", "1", "2", "4", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302: 
1:1a36302:         doQuery4(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 4}", "3", "2", "1", "1", "4", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         doQuery5(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{0, 2, 3, 4}", "4", "2", "1", "1", "4", "btree",
1:1a36302:             "None","None","Equals", "Column[0][0] Id: 3");
1:1a36302: 
1:1a36302:         doQuery6(st);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Index", "FOO", "FOO_COVER", 
1:1a36302:             "{3, 4}", "2", "2", "1", "2", "4", "btree",
1:1a36302:             "None","None","None", null);
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doQuery1(Statement st) throws SQLException {
1:1a36302:         // all columns and rows
1:1a36302:         doQuery(st, "select * from foo",
1:1a36302:                 new String [] {"A", "B", "C", "D", "E"},
1:1a36302:                 new String [][] {
1:1a36302:                         {"1", "2", "3", "4", "5"},
1:1a36302:                         {"10", "20", "30", "40", "50"}});        
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doQuery2(Statement st) throws SQLException {
1:1a36302:         // just last column - should be 5 and 50 
1:1a36302:         doQuery(st, "select e from foo", 
1:1a36302:                 new String[] {"E"}, 
1:1a36302:                 new String[][] {{"5"},{"50"}});
1:1a36302:     }
1:1a36302: 
1:1a36302:     private void doQuery3(Statement st) throws SQLException {
1:1a36302:         // as subset of columns - should be 5,3,1 and 50,30,10
1:1a36302:         doQuery(st, "select e, c, a from foo",
1:1a36302:                 new String [] {"E", "C", "A"},
1:1a36302:                 new String [][] {
1:1a36302:                         {"5", "3", "1"},
1:1a36302:                         {"50", "30", "10"}});
1:1a36302:     }
1:1a36302: 
1:1a36302:     private void doQuery4(Statement st) throws SQLException {
1:1a36302:         // as subset of columns, with qualifier in list - should be 5,3,1
1:1a36302:         doQuery(st, "select e, c, a from foo where foo.e = 5",
1:1a36302:                 new String [] {"E", "C", "A"},
1:1a36302:                 new String [][]{{"5", "3", "1"}});        
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doQuery5(Statement st) throws SQLException {
1:1a36302:         // as subset of columns, with qualifier not in list; should be 50,30,10 
1:1a36302:         doQuery(st, "select e, c, a from foo where foo.b = 20", 
1:1a36302:                 new String [] {"E", "C", "A"}, 
1:1a36302:                 new String [][] {{"50", "30", "10"}});        
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doQuery6(Statement st) throws SQLException {
1:1a36302:         // as subset of columns
1:1a36302:         doQuery(st, "select a, b from foo", 
1:1a36302:                 new String [] {"A", "B"}, 
1:1a36302:                 new String [][] {{"1", "2"},{"10", "20"}}); 
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doQuery(Statement st,
1:1a36302:             String query, String [] expColNames, String[][] expRS) 
1:1a36302:     throws SQLException {
1:1a36302:         ResultSet rs = null;
1:1a36302:         rs = st.executeQuery(query);
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);        
1:1a36302:     }
1:1a36302:     
1:1a36302:     // ----------------------------------------------------
1:1a36302:     //           -- test case for costing - 
1:1a36302:     // make sure optimizer picks obvious covered query. 
1:1a36302:     // ----------------------------------------------------
1:1a36302:     public void testCostingCoveredQuery() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         setAutoCommit(false);
1:1a36302: 
1:1a36302:         st.executeUpdate("create table base_table (a int, b varchar(1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (1, PADSTRING('1',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (2, PADSTRING('2',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (3,  PADSTRING('3',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (4,  PADSTRING('4',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (5,  PADSTRING('5',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (6,  PADSTRING('6',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (7,  PADSTRING('7',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:         "insert into base_table values (8,  PADSTRING('8',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (9,  PADSTRING('9',1000))");
1:1a36302:         st.executeUpdate(
1:1a36302:             "insert into base_table values (10, PADSTRING('10',1000))");
1:1a36302:         st.executeUpdate("create index cover_idx on base_table(a)");
1:1a36302: 
1:1a36302:         // switch on runtime statistics
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         // make sure covered index is chosen
1:1a36302:         doQuery(st, "select a from base_table", 
1:1a36302:                 new String [] {"A"}, 
1:1a36302:                 new String [][] {{"1"},{"2"},{"3"},{"4"},{"5"},
1:1a36302:                                 {"6"},{"7"},{"8"},{"9"},{"10"}});
1:1a36302:         assertStatsOK(st, 
1:1a36302:                 "Index", "BASE_TABLE", "COVER_IDX", 
1:1a36302:                 "{0}", "1", "0", "1", "10", "10", "btree",
1:1a36302:                 "None","None","None", null);
1:1a36302:     }
1:1a36302:     
1:1a36302:     // ----------------------------------------------------
1:1a36302:     //       -- test for key too big error message. -- 
1:1a36302:     // ----------------------------------------------------
1:1a36302:     public void testKeyTooBigError() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate ("create table d (id int not null, " +
1:1a36302:             "t_bigvarchar varchar(400), unique (id))");
1:1a36302:         st.executeUpdate("create index t_bigvarchar_ind on d ( t_bigvarchar)");
1:1a36302:         st.executeUpdate(
1:1a36302:             "alter table d alter t_bigvarchar set data type varchar(4096)");
1:1a36302: 
1:1a36302:         String bigString="1111111";
1:1a36302:         for (int i=0 ; i<314 ; i++)
1:1a36302:             bigString=bigString+"1234567890";
1:1a36302:         bigString=bigString+"123456";
1:1a36302:         assertStatementError("XSCB6", st,
1:1a36302:             "insert into d (id, t_bigvarchar) values (1, '" + bigString + "')");
1:1a36302:     }
1:1a36302:     
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     //                  test space for update 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     public void testSpaceForUpdate() throws Exception
1:1a36302:     {
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.minimumRecordSize', '1')");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', '0')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create table testing (a varchar(100))");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:         "'derby.storage.minimumRecordSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:         "'derby.storage.minimumRecordSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into testing values ('a')");
1:1a36302:         for (int i=0 ; i<7 ; i++)
1:1a36302:             st.executeUpdate(
1:1a36302:                 "insert into testing (select testing.a from testing)");
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 128,
1:1a36302:             "update testing set a = 'abcd' where a = 'a'");
1:1a36302: 
1:1a36302:         st.executeUpdate("create index zz on testing (a)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.minimumRecordSize', '1')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create table t1 (a varchar(100))");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into t1 values ('a')");
1:1a36302:         for (int i=0 ; i<7 ; i++)
1:1a36302:             st.executeUpdate("insert into t1 (select t1.a from t1)");
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 128,
1:1a36302:         " update t1 set a = 'abcd' where a = 'a'");
1:1a36302: 
1:1a36302:         st.executeUpdate("create index zz1 on t1 (a)");
1:1a36302:     }
1:1a36302:     
1:1a36302:         
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     //     test load with long columns with index creation 
1:1a36302:     // ---------------------------------------------------------
1:1a36302:     public void testLoadLongColumnsCreateIndex() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         setAutoCommit(false);
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long1 (a varchar(32000), b int, c int)");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long1 values (" +
1:1a36302:             "'this is a long row which will get even longer and longer " +
1:1a36302:             "to force a stream', 1, 2)");
1:1a36302:         st.executeUpdate("insert into long1 values (" +
1:1a36302:             "'this is another long row which will get even longer " +
1:1a36302:             "and longer to force a stream', 2, 3)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long1");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"5328"},{"5760"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long2 (a varchar(16384), b int, c int)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '16384')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create index long2i1 on long2 (a)");
1:1a36302:         st.executeUpdate("create index long2i2 on long2 (a,b)");
1:1a36302:         st.executeUpdate("create index long2i3 on long2 (a,b,c)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"5328"},{"5760"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long2 " +
1:1a36302:             "/*derby_properties index=long2i2*/");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"5328"},{"5760"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // DefectId CS 1346
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"5328"},{"5328"},{"5760"},{"5760"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long2 " +
1:1a36302:             "/*derby_properties index=long2i2*/");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"5328"},{"5328"},{"5760"},{"5760"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         
1:1a36302:         assertUpdateCount(st, 4, "delete from long2");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create index long2small on long2 (a, c)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         // this small index should cause the insert to fail
1:1a36302: 
1:1a36302:         assertStatementError("XSCB6", st, 
1:1a36302:             "insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         // DefectId CS 1346 the small index should cause this insert 
1:1a36302:         // to also fail
1:1a36302: 
1:1a36302:         assertStatementError("XSCB6", st,
1:1a36302:             "insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) from long2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302: 
1:1a36302:         // test case for track 1346
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table long1");
1:1a36302:         st.executeUpdate("drop table long2");
1:1a36302:     }
1:1a36302:     
1:1a36302:     public void testCS1346() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         setAutoCommit(false);
1:1a36302:         
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long1 (a varchar(32000), b int, c int)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long1 values ('this is a long row " +
1:1a36302:             "which will get even longer', 1, 2)");
1:1a36302:         st.executeUpdate("insert into long1 values ('a second row that will " +
1:1a36302:             "also grow very long', 2, 3)");
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) as x from long1 order by x");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"X"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"3024"},{"3240"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long2 (a varchar(30000), b int, c int)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '16384')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create index long2i1 on long2 (a)");
1:1a36302:         st.executeUpdate("create index long2i2 on long2 (b, a)");
1:1a36302:         st.executeUpdate("create index long2i3 on long2 (b, a, c)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long2 select * from long1");
1:1a36302:         st.executeUpdate("insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) as x from long2 order by x");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"X"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"3024"},{"3024"},{"3240"},{"3240"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table long1");
1:1a36302:         st.executeUpdate("drop table long2");
1:1a36302: 
1:1a36302:     }
1:1a36302: 
1:1a36302:     public void testCS1346b() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long1 (a varchar(32000), b int, c int)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into long1 values ('this is a long row " +
1:1a36302:             "which will get even longer', 1, 2)");
1:1a36302:         st.executeUpdate("insert into long1 values ('a second row that will "
1:1a36302:             + "also grow very long', 2, 3)");
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:1a36302:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) as x from long1 order by x");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"X"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"3024"},{"3240"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '1024')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table long2 (a varchar(32000), b int, c int)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '16384')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create index long2i1 on long2 (a)");
1:1a36302:         st.executeUpdate("create index long2i2 on long2 (b, a)");
1:1a36302:         st.executeUpdate("create index long2i3 on long2 (b, a, c)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         // insert into the second table multiple times
1:1a36302:         for (int i=0 ; i<10 ; i++)
1:1a36302:             st.executeUpdate("insert into long2 select * from long1");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select LENGTH(a) as x from long2 order by x");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"X"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [20][1];
1:1a36302:         //10 rows should have '3024' and 10 '3240 as length
1:1a36302:         for (int i=0 ; i<10 ; i++)
1:1a36302:             expRS[i][0]="3024";
1:1a36302:         for (int i=10 ; i<20 ; i++)
1:1a36302:             expRS[i][0]="3240";
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         rs = st.executeQuery("select count(*) from long2");
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"20"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:f59fc44:         st.executeUpdate("drop table long1");
1:f59fc44:         st.executeUpdate("drop table long2");
1:1a36302:     }
1:efe47b4: 
1:1a36302:     // regression test case for a Cloudscape era bug, 1552
1:1a36302:     // Make sure that a full scan which needs columns not in index
1:1a36302:     // does not use the index.
1:1a36302:     // Before the fix, access costing would make the optimizer 
1:1a36302:     // pick the index because it incorrectly costed rows spanning pages.
1:1a36302:     public void testCS1552() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize','4096')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create table a " +
1:1a36302:             "(a int, b varchar(4000), c varchar(4000), d varchar(4000))");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create index a_idx on a (a)");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into a values (5, PADSTRING('a',4000), " + 
1:1a36302:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:1a36302:         st.executeUpdate("insert into a values (4, PADSTRING('a',4000), " + 
1:1a36302:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:1a36302:         st.executeUpdate("insert into a values (3, PADSTRING('a',4000), " +
1:1a36302:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:1a36302:         st.executeUpdate("insert into a values (2, PADSTRING('a',4000), " +
1:1a36302:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:1a36302:         st.executeUpdate("insert into a values (1, PADSTRING('a',4000), " +
1:1a36302:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select a, d from a");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "D"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         String paddeda = Formatters.padString("a", 4000);
1:1a36302:         expRS = new String[][] {
1:1a36302:             {"5", paddeda},
1:1a36302:             {"4", paddeda}, 
1:1a36302:             {"3", paddeda}, 
1:1a36302:             {"2", paddeda}, 
1:1a36302:             {"1", paddeda}}; 
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             "Table", null, null, "{0, 3}", "2", null, "6", "5", "5", 
1:1a36302:             "heap","null","null","None", null);
1:1a36302:         
1:1a36302:         st.execute("drop table a");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302:     
1:1a36302:     // test case for track 2241"};
1:1a36302:     // The problem was that when the level of btree grew, 
1:1a36302:     // sometimes a long row would be chosen as the branch 
1:1a36302:     // delimiter, and the branch code did not throw the 
1:1a36302:     // correct error noSpaceForKey error.
1:1a36302:     public void testCS2241() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.minimumRecordSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create table b2241 (a int, b varchar(32000))");
1:1a36302:         st.executeUpdate("insert into b2241 values (1024, " +
1:1a36302:             "'01234567890123456789012345678901234567890123456789')");
1:1a36302:         String inshalf1 = "insert into b2241 (select b2241.a + ";
1:1a36302:         String inshalf2 = ", b from b2241)";
1:1a36302:         st.executeUpdate(inshalf1 + "1" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "2" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "4" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "8" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "16" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "32" + inshalf2);
1:1a36302:         st.executeUpdate(inshalf1 + "64" + inshalf2);
1:1a36302:         for (int i=0 ; i<5  ; i++)
1:1a36302:             assertUpdateCount(st, 128, "update b2241 set b = b||b");
1:1a36302:         rs = st.executeQuery("select LENGTH(b) from b2241 where a = 1025");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"1600"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         st.executeUpdate(
1:1a36302:                 " insert into b2241 (select 1, "
1:1a36302:                 + "b||b||b||b||b||b||b||b from b2241 where a = 1024)");
1:1a36302:         st.executeUpdate(
1:1a36302:                 " insert into b2241 (select 8000, "
1:1a36302:                 + "b||b||b||b||b||b||b||b from b2241 where a = 1024)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '4096')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         // this create index use to fail with an assert - should 
1:1a36302:         // fail with key too big error.
1:1a36302:         assertStatementError("XSCB6", st, "create index a on b2241 (b, a)");
1:1a36302:         // make sure table still accessable, by doing the same statement
1:1a36302:         assertStatementError("XSCB6", st, "create index a on b2241 (b, a)");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         // delete 2 big records and then index should work.
1:1a36302:         assertUpdateCount(st, 1, "delete from b2241 where a = 1");
1:1a36302:         assertUpdateCount(st, 1, "delete from b2241 where a = 8000");
1:1a36302: 
1:1a36302:         st.executeUpdate("create index a on b2241 (b, a)");
1:1a36302: 
1:1a36302:         // Check the consistency of the indexes
1:1a36302:         rs = st.executeQuery("VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'B2241')");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"1"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table b2241");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // o insert bunch of rows with sequential keys.
1:1a36302:     // o create an index (non unique or unique)
1:1a36302:     // o delete every other one - will make normat post commit not fire.
1:1a36302:     // o commit
1:1a36302:     // o now reinsert rows into the "holes" which before the fix 
1:1a36302:     //   would cause splits, but now will force reclaim space and 
1:1a36302:     //   reuse existing space in btree.
1:1a36302:     private void reclaimTest(String createIndex, String expectedError) 
1:1a36302:     throws SQLException {
1:1a36302:         CallableStatement cSt;
1:1a36302:         setAutoCommit(false);
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         // set page size to default.
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '4096')");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.minimumRecordSize', '1')");
1:1a36302:         cSt.execute();
1:1a36302:         cSt.close();        
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         // create and load a table with values from 1024 down to 1,
1:1a36302:         st.executeUpdate("create table foo (a int, b char(200), c int)");
1:1a36302:         st.executeUpdate("insert into foo values (1024, 'even', 0)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 1, 'odd' , 1 from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 2, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 4, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 8, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 16, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 32, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 64, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 128, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 256, foo.b, foo.c from foo)");
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo.a - 512, foo.b, foo.c from foo)");
1:1a36302: 
1:1a36302:         // insert into the "holes", but different keys (even2 instead of even)
1:1a36302:         st.executeUpdate("create table foo2 (a int, b char(200), c int)");
1:1a36302:         st.executeUpdate("insert into foo2 (select * from foo)");
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 512, "delete from foo2 where foo2.c = 1");
1:1a36302: 
1:1a36302:         // create "packed" index.
1:1a36302:         st.executeUpdate(createIndex);
1:1a36302: 
1:1a36302:         // delete ever other row
1:1a36302:         assertUpdateCount(st, 512, "delete from foo where foo.c = 0");
1:1a36302: 
1:1a36302:         // turn all the deletes into "committed deletes"
1:1a36302:         commit();
1:1a36302:         st.executeUpdate("insert into foo " +
1:1a36302:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         // insert dups
1:1a36302:         if (expectedError !=  null)
1:1a36302:             assertStatementError("23505", st, "insert into foo " +
1:1a36302:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:1a36302:         else
1:1a36302:             assertUpdateCount(st, 512, "insert into foo " +
1:1a36302:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         // a delete of the whole table also exercises the btree well.
1:1a36302:         if (expectedError !=  null)
1:1a36302:         {
1:1a36302:             assertUpdateCount(st, 1024, "delete from foo");
1:1a36302:             assertUpdateCount(st, 512, "delete from foo2");
1:1a36302:         }
1:1a36302:         else 
1:1a36302:         {
1:1a36302:             assertUpdateCount(st, 1536, "delete from foo");
1:1a36302:             assertUpdateCount(st, 512, "delete from foo2");
1:1a36302:         }
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:         st.executeUpdate("drop table foo2");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302:     
1:1a36302:     // test case for reclaiming deleted rows during split.
1:1a36302:     // actual work is done in method reclaimTest()
1:1a36302:     // exercise test case with non-unique index
1:1a36302:     public void testReclaimDeletedRowsDuringSplit() throws Exception
1:1a36302:     {
1:1a36302:         reclaimTest("create index a on foo (a, b)", null);
1:1a36302:     }
1:1a36302: 
1:1a36302:     // as testReclaimDeletedRowsDuringSplit, but with unique index,
1:1a36302:     // so when attempting to create the duplicat rows, we should get an
1:1a36302:     // error. 
1:1a36302:     // actual work is done in method reclaimTest()
1:1a36302:     public void testReclaimDeletedRowsUniqueIndex() throws Exception
1:1a36302:     {
1:1a36302:         reclaimTest("create unique index a on foo (a, b)", "23505");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // same foo used in the next 3 test fixtures
1:1a36302:     private void setupForReclaim2(Statement st) throws SQLException {
1:1a36302:         st.executeUpdate("create table foo (a int, b varchar(1100), c int)");
1:1a36302:         st.executeUpdate("create index a on foo (a, b)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('a',1100), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (2, PADSTRING('a',1100), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (3, PADSTRING('a',1100), 1)");
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void reclaimDeletedRows2(boolean toCommit) throws SQLException {
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         setupForReclaim2(st);
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1");
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 2");
1:1a36302:         
1:1a36302:         if (toCommit)
1:1a36302:             commit();
1:1a36302:         st.executeUpdate("insert into foo values " +
1:1a36302:             "(-1, PADSTRING('ab',1100), 1)");
1:1a36302:         st.executeUpdate("insert into foo values " +
1:1a36302:             "(-2, PADSTRING('ab',1100), 1)");
1:1a36302:         rollback();
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302:     
1:1a36302:     // another simple test of reclaim deleted row code paths. 
1:1a36302:     // this test should not reclaim rows as deletes are not committed.
1:1a36302:     public void testUncommittedDeletesNotReclaimed() throws Exception
1:1a36302:     {
1:1a36302:         reclaimDeletedRows2(false);
1:1a36302:     }
1:1a36302: 
1:1a36302:     // another simple test of reclaim deleted row code paths. 
1:1a36302:     // this test should reclaim rows as deletes are committed.
1:1a36302:     public void testCommittedDeletesReclaim() throws Exception
1:1a36302:     {
1:1a36302:         reclaimDeletedRows2(true);
1:1a36302:     }
1:1a36302: 
1:1a36302:     // this test will not reclaim rows because the parent xact 
1:1a36302:     // has table level lock.
1:1a36302:     public void testAllUncommittedReclaim() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         setupForReclaim2(st);
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into foo values (0, PADSTRING('a',1100), 1)");
1:1a36302:         st.executeUpdate("insert into foo values (1, PADSTRING('a',1100), 1)");
1:1a36302:         rollback();
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // regression test case for Cloudscape fixed bug track 2778
1:1a36302:     // Make sure that an update which causes a row to go from a non long row 
1:1a36302:     // to a long row can be aborted correctly.
1:1a36302:     // Prior to this fix the columns moving off the page would be corrupted. 
1:1a36302:     // create a base table that contains 2 rows, 19 columns,  
1:1a36302:     // that leaves just 1 byte free on the page.
1:1a36302:     // freeSpace: 1, spareSpace: 10, PageSize: 2048
1:1a36302:     public void testCS2778() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', '2048')");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', '10')");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create table t2778 (" +
1:1a36302:             "col00 char(2), col01 char(1), col02 char(99), col03 char(11), " +
1:1a36302:             "col04 char(7), col05 char(11), col06 char(6), col07 char(6), " +
1:1a36302:             "col08 char(2), col09 char(6), col10 varchar(1000), " +
1:1a36302:             "col11 char(2), col12 char(1), col13 char(7), col14 char(24), " +
1:1a36302:             "col15 char(1), col16 char(166), col17 char(207), col18 char(2))");
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageSize', NULL)");
1:1a36302:         cSt.execute();
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("create unique index a_idx on t2778 (col00)");
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into t2778 values ( '0_', '0', '0_col02', " +
1:1a36302:             "'0_col03', '0_col04', '0_col05', '0_06', '0_07', '0_', '0_09', " +
1:1a36302:             "'0_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllll012340_col10lllllllllll', '0_', '0', '0_col13', " +
1:1a36302:             "'0_col14', '0', '0_col16', '0_col17', '0_' )");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into t2778 values ( '1_', '1', '1_col02', " +
1:1a36302:             "'1_col03', '1_col04', '1_col05', '1_06', '1_07', '1_', '1_09', " +
1:1a36302:             "'1_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllll012340_col10llllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllll012340_col10lllllllllllxxx" +
1:1a36302:             "xxxxxxxxxxxxxxxx', '1_', '1', '1_col13', '1_col14', '1', " +
1:1a36302:             "'1_col16', '1_col17', '1_' )");
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         rs = st.executeQuery(" select col16, col17, col18 from t2778");
1:1a36302:         expColNames = new String [] {"COL16", "COL17", "COL18"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{
1:1a36302:             {"0_col16", "0_col17", "0_"},
1:1a36302:             {"1_col16", "1_col17", "1_"}
1:1a36302:                               };
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         assertUpdateCount(st, 1, "update t2778 " +
1:1a36302:             "/*derby-properties index=a_idx*/ set col10 = " +
1:1a36302:             "'0_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllll012340_col10lllllllllllxxxxxx' " +
1:1a36302:             "where col00 = '0_'");
1:1a36302:         rollback();
1:1a36302: 
1:1a36302:         // prior to the fix col17 and col18 would come back null.
1:1a36302:         rs = st.executeQuery("select " +
1:1a36302:             "col01, col02, col03, col04, col05,  col06, " +
1:1a36302:             "col07, col08, col09, col10, col11, col12, col13, " +
1:1a36302:             "col14, col15, col16, col17, col18 from t2778");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"COL01", "COL02", "COL03", "COL04", 
1:1a36302:             "COL05", "COL06", "COL07", "COL08", "COL09", "COL10", "COL11",
1:1a36302:             "COL12", "COL13", "COL14", "COL15", "COL16", "COL17", "COL18"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"0", "0_col02", "0_col03", "0_col04", 
1:1a36302:             "0_col05", "0_06", "0_07", "0_", "0_09", 
1:1a36302:             "0_col10llllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "llllllllll012340_col10lllllllllllxxxxxx", 
1:1a36302:             "0_", "0", "0_col13", "0_col14", "0", "0_col16", "0_col17", "0_"},
1:1a36302:                                 {"1", "1_col02", "1_col03", "1_col04", 
1:1a36302:             "1_col05", "1_06", "1_07", "1_", "1_09", 
1:1a36302:             "1_col10llllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "llllllllll012340_col10lllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:1a36302:             "llllllllllllllllllllllllllllllllllll012340_col10lllllllllllxxxx" +
1:1a36302:             "xxxxxxxxxxxxxxx", "1_", "1", "1_col13", "1_col14", "1", 
1:1a36302:             "1_col16", "1_col17", "1_"}
1:1a36302:                               };
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table t2778");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302: 
1:1a36302:     // test case for Cloudscape track 3149, improving max on btree optimization
1:1a36302:     public void testCS3149() throws Exception
1:1a36302:     {
1:1a36302:         ResultSet rs = null;
1:1a36302:         Statement st = createStatement();
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;        
1:1a36302: 
1:1a36302:         setAutoCommit(false);
1:1a36302:         st.executeUpdate("create table foo (a int, b varchar(500), c int)");
1:1a36302:         
1:1a36302:         String insertPart1 = "insert into foo values (";
1:1a36302:         String insertPart2 = ", PADSTRING('";
1:1a36302:         String insertPart3 = "',500), 1)";
1:1a36302:         for (int i=1 ; i<10 ; i++)
1:1a36302:         {
1:1a36302:             String s = String.valueOf(i);
1:1a36302:             st.executeUpdate(insertPart1 + s + insertPart2 + s + insertPart3);
1:1a36302:         }
1:1a36302:         for (int i=11 ; i<19 ; i++)
1:1a36302:         {
1:1a36302:             String s = String.valueOf(i);
1:1a36302:             st.executeUpdate(insertPart1 + s + insertPart2 + s + insertPart3);
1:1a36302:         }
1:1a36302:         st.executeUpdate("create index foox on foo (b)");
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         // normal max optimization, last row in index is not deleted.
1:1a36302:         rs = st.executeQuery("select max(b) from foo");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"9"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // new max optimization, last row in index is deleted but 
1:1a36302:         // others on page aren't.
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where a = 9");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select max(b) from foo");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"8"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // new max optimization, last row in index is deleted but 
1:1a36302:         // others on page aren't.
1:1a36302:         assertUpdateCount(st, 1, "delete from foo where a = 8");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select max(b) from foo");
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"7"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // max optimization does not work - fail over to scan, all 
1:1a36302:         // rows on last page are deleted.
1:1a36302:         assertUpdateCount(st, 13, "delete from foo where a > 2");
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select max(b) from foo");
1:1a36302:         expColNames = new String [] {"1"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"2"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302:         commit();
1:1a36302: 
1:1a36302:         st.executeUpdate("drop table foo");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302: 
1:1a36302:     //---------------------------------------------------------
1:1a36302:     //         regression test for Cloudscape bugs 3368, 3370  
1:1a36302:     // the bugs arose for the edge case where pageReservedSpace = 100
1:1a36302:     // before bug 3368 was fixed, a short row insert caused 2 pages 
1:1a36302:     // to be allocated per short row insert.
1:1a36302:     public void testCS3368_3370() throws Exception
1:1a36302:     {
1:1a36302:         CallableStatement cSt;
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', '100')");
1:1a36302:         cSt.execute();
1:1a36302:         st.executeUpdate("create table a (a int)");
1:1a36302:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:1a36302:             "'derby.storage.pageReservedSpace', NULL)");
1:1a36302:         cSt.execute();
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into a values (1)");
1:1a36302: 
1:1a36302:         checkSpaceTable(st, "2");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into a values (2)");
1:1a36302: 
1:1a36302:         checkSpaceTable(st, "3");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into a values (1)");
1:1a36302: 
1:1a36302:         checkSpaceTable(st, "4");
1:1a36302: 
1:1a36302:         st.executeUpdate("insert into a values (2)");
1:1a36302: 
1:1a36302:         checkSpaceTable(st, "5");
1:1a36302: 
1:f59fc44:         st.executeUpdate("drop table a");
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void checkSpaceTable(Statement st, String expValue)
1:1a36302:     throws SQLException {
1:1a36302:         ResultSet rs = null;
1:1a36302:         String [][] expRS;
1:1a36302:         
1:1a36302:         rs = st.executeQuery("select numallocatedpages from TABLE" +
1:1a36302:                 "(SYSCS_DIAG.SPACE_TABLE('APP', 'A')) a");
1:1a36302:         expRS = new String [][]{{expValue}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);        
1:1a36302:     }
1:1a36302: 
1:1a36302:     //---------------------------------------------------------
1:1a36302:     // regression test for old Cloudscape bug track 4595,
1:1a36302:     // following are 2 test cases that get cycled with 3 different indexes:
1:1a36302:     // 1. unique index
1:1a36302:     // 2. primary key
1:1a36302:     // 3. non unique index
1:1a36302:     // The 2 test cases are:
1:1a36302:     // a. do delete, update and select without any rows (and check statistics)
1:1a36302:     //    then insert a row, and do update and delete
1:1a36302:     // b. do delete, and update after inserting a row (and check stats)
1:1a36302:     //    then do the same selects as in test case a
1:1a36302:     private void doTestCaseCS4595A (Statement st, String indexOrConstraint) 
1:1a36302:     throws SQLException {
1:1a36302:         ResultSet rs = null;
1:1a36302:         String [] expColNames;
1:1a36302:         
1:1a36302:         String indexName;
1:1a36302:         if (indexOrConstraint.equals("Index"))
1:1a36302:             indexName="FOOX";
1:1a36302:         else 
1:1a36302:             indexName=null;
1:1a36302: 
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         
1:1a36302:         // delete against table with 0 rows.
1:1a36302:         assertUpdateCount(st, 0, "delete from foo where a = 1");
1:1a36302: 
1:1a36302:         // make sure index used in unique key update even if table has zero rows.
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "{0, 1}", "2", "0", "1", "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // update against table with 0 rows. 
1:1a36302:         
1:1a36302:         assertUpdateCount(st, 0, "update foo set b = 1 where a = 2");
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
2:1a36302:             "All", "2", "0", "1", "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // select * against table with 0 rows. 
1:1a36302:         rs = st.executeQuery("select * from foo where a = 2");
1:1a36302: 
1:1a36302:         JDBC.assertEmpty(rs);
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "All", "2", "0", "1", "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // select against table with 0 rows
1:1a36302:         rs = st.executeQuery("select a from foo where a = 2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302:         
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
3:1a36302:             "{0}", "1", "0", "1", "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // select against table with 0 rows.
1:1a36302:         // second time should give slightly different statistics; different
1:1a36302:         // set of rows fetched.
1:1a36302:         rs = st.executeQuery("select a from foo where a = 2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "{0}", "1", "0", "1", "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302:         
1:1a36302:         // now insert one row and make sure still same plan.  
1:1a36302:         // Previous to 4595, 0 row plan was a table scan and it would not 
1:1a36302:         // change when 1 row was inserted.
1:1a36302:         st.execute("insert into foo values (1, 1)");
1:1a36302: 
1:1a36302:         // update against table with 1 row.
1:1a36302:         assertUpdateCount(st, 1, "update foo set b = 2 where a = 1");
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "All", "2", "0", "1", "1", "1", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // delete against table with 1 row.
1:1a36302:         st.execute("delete from foo where a = 1");
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "{0, 1}", "2", "0", "1", "1", "1", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         st.execute("drop table foo");
1:1a36302:         commit();
1:1a36302:     }
1:1a36302:     
1:1a36302:     private void doTestCaseCS4595B(Statement st, String indexOrConstraint) throws SQLException {
1:1a36302:         ResultSet rs = null;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         String indexName;
1:1a36302:         if (indexOrConstraint.equals("Index"))
1:1a36302:             indexName="FOOX";
1:1a36302:         else 
1:1a36302:             indexName=null;
1:1a36302:         
1:1a36302:         commit();
1:1a36302:         
1:1a36302:         // update against table with 1 row.
1:1a36302:         assertUpdateCount(st, 1, "update foo set b = 2 where a = 1");
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "All", "2", "0", "1", "1", "1", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // delete against table with 1 row.
1:1a36302:         st.execute("delete from foo where a = 1");
1:1a36302: 
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:1a36302:             "{0, 1}", "2", "0", "1", "1", "1", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302:         
1:1a36302:         rs = st.executeQuery("select * from foo where a = 2");
1:1a36302: 
1:1a36302:         JDBC.assertEmpty(rs);
1:8454e15:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:8454e15:         // See DERBY-5377.
1:8454e15:         // Passing in null to prevent uninteresting failures.
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:8454e15:             "All", "2", "0", null, "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // select against table with 0 rows
1:1a36302:         rs = st.executeQuery("select a from foo where a = 2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302:         
1:8454e15:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:8454e15:         // See DERBY-5377.
1:8454e15:         // Passing in null to prevent uninteresting failures.
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:26fa4b7:             "{0}", "1", "0", null, "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         // select against table with 0 rows.
1:1a36302:         // second time should give slightly different statistics; different
1:1a36302:         // set of rows fetched.
1:1a36302:         rs = st.executeQuery("select a from foo where a = 2");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302: 
1:8454e15:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:8454e15:         // See DERBY-5377.
1:8454e15:         // Passing in null to prevent uninteresting failures.
1:1a36302:         assertStatsOK(st, 
1:1a36302:             indexOrConstraint, "FOO", indexName, 
1:8454e15:             "{0}", "1", "0", null, "0", "0", "btree",
1:1a36302:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:1a36302: 
1:1a36302:         st.execute("drop table foo");
1:1a36302:     }
1:9b3569f: 
1:1a36302:     public void testCS4595A_UniqueIndex() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int, b int)");
1:1a36302:         st.executeUpdate("create unique index foox on foo (a)");
1:1a36302: 
1:1a36302:         doTestCaseCS4595A(st, "Index");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // try delete/update statement compiled against table with 1 row.
1:1a36302:     public void testCS4595B_UniqueIndex() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int, b int)");
1:1a36302:         // this time, insert a row before creating an index
1:1a36302:         st.executeUpdate("insert into foo values (1, 1)");
1:1a36302:         st.executeUpdate("create unique index foox on foo (a)");
1:1a36302: 
1:1a36302:         doTestCaseCS4595B(st, "Index");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // repeat set of testCS459_a against table with primary key, 
1:1a36302:     // vs. unique index 
1:1a36302:     // there should be no difference in plan shape. 
1:1a36302:     // try delete/update statement compiled against table with 0 rows
1:1a36302:     public void testCS4595A_PrimaryKey() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table foo (a int not null primary key, b int)");
1:1a36302:         
1:1a36302:         doTestCaseCS4595A(st, "Constraint");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // try delete/update statement compiled against table with 1 row.
1:1a36302:     // With primary key.
1:1a36302:     public void testCS4595B_PrimaryKey() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302:         
1:1a36302:         st.executeUpdate(
1:1a36302:             "create table foo (a int not null primary key, b int)");
1:1a36302:         st.executeUpdate("insert into foo values (1, 1)");
1:1a36302:         
1:1a36302:         doTestCaseCS4595B(st, "Constraint");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // repeat set of 4595 tests against table with non-unique index 
1:1a36302:     // with no statistics.
1:1a36302:     // there should be no difference in plan shape.
1:1a36302:     // try delete/update statement compiled against table with 0 rows
1:1a36302:     public void testCaseCS4595A_NonUniqueIndex() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int, b int)");
1:1a36302:         st.executeUpdate("create index foox on foo (a)");
1:1a36302: 
1:1a36302:         doTestCaseCS4595A(st, "Index");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // try delete/update statement compiled against table with 1 row.
1:1a36302:     public void testCaseCS4595B_NonUniqueIndex() throws Exception
1:1a36302:     {
1:1a36302:         Statement st = createStatement();
1:1a36302:         st.executeUpdate("set ISOLATION to RR");
1:1a36302:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int, b int)");
1:1a36302:         st.executeUpdate("create index foox on foo (a)");
1:1a36302:         st.executeUpdate("insert into foo values (1, 1)");
1:1a36302:         
1:1a36302:         doTestCaseCS4595B(st, "Index");
1:1a36302:     }
1:1a36302: 
1:1a36302:     // ----------------------------------------------------
1:1a36302:     //        simple regression test for qualifier work. 
1:1a36302:     // ----------------------------------------------------
1:1a36302:     public void testQualifiers() throws Exception
1:1a36302:     {
1:f59fc44:         setAutoCommit(false);
1:1a36302: 
1:1a36302:         ResultSet rs = null;
1:1a36302:         Statement st = createStatement();
1:1a36302: 
1:1a36302:         String [][] expRS;
1:1a36302:         String [] expColNames;
1:1a36302: 
1:1a36302:         st.executeUpdate("create table foo (a int, b int, c int)");
1:1a36302:         st.executeUpdate("insert into foo values (1, 10, 100)");
1:1a36302:         st.executeUpdate("insert into foo values (2, 20, 200)");
1:1a36302:         st.executeUpdate("insert into foo values (3, 30, 300)");
1:1a36302: 
1:1a36302:         // should return no rows
1:1a36302:         rs = st.executeQuery("select a, b, c from foo where a = 1 and b = 20");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "B", "C"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         JDBC.assertDrainResults(rs, 0);
1:1a36302: 
1:1a36302:         // should return one row
1:1a36302:         rs = st.executeQuery("select a, b, c from foo where a = 3 and b = 30");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "B", "C"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"3", "30", "300"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select a, b, c from foo where a = 3 or c = 40");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "B", "C"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"3", "30", "300"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         // should return 2 rows
1:1a36302:         rs = st.executeQuery("select a, b, c from foo where a = 1 or b = 20");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "B", "C"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"1", "10", "100"}, {"2", "20", "200"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         rs = st.executeQuery("select a, b, c from foo where a = 1 or a = 3");
1:1a36302: 
1:1a36302:         expColNames = new String [] {"A", "B", "C"};
1:1a36302:         JDBC.assertColumnNames(rs, expColNames);
1:1a36302:         expRS = new String [][]{{"1", "10", "100"}, {"3", "30", "300"}};
1:1a36302:         JDBC.assertFullResultSet(rs, expRS, true);
1:1a36302: 
1:1a36302:         rollback();
1:1a36302:         st.close();
1:1a36302:     }
1:1a36302: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:26fa4b7
/////////////////////////////////////////////////////////////////////////
1:             "{0}", "1", "0", null, "0", "0", "btree",
commit:8454e15
/////////////////////////////////////////////////////////////////////////
1:             if (expPages != null) {
1:                 assertTrue(
1:                         "RuntimeStatisticsParser.findstring(Number of pages visited= "
1:                         + expPages + ") returned false" +
1:                         "full runtime statistics = " + rtsp.toString(),
1:                         rtsp.findString("Number of pages visited=" + expPages, 1));
1:             }
/////////////////////////////////////////////////////////////////////////
1:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:         // See DERBY-5377.
1:         // Passing in null to prevent uninteresting failures.
1:             "All", "2", "0", null, "0", "0", "btree",
/////////////////////////////////////////////////////////////////////////
1:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:         // See DERBY-5377.
1:         // Passing in null to prevent uninteresting failures.
1:             "{0}", "1", "0", null, "0", "0", "btree",
/////////////////////////////////////////////////////////////////////////
1:         // Mostly this returns 1, but sometimes, 2 pages visited.
1:         // See DERBY-5377.
1:         // Passing in null to prevent uninteresting failures.
commit:1a36302
/////////////////////////////////////////////////////////////////////////
1: /*
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.AccessTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one
1:    or more contributor license agreements.  See the NOTICE file
1:    distributed with this work for additional information
1:    regarding copyright ownership.  The ASF licenses this file
1:    to you under the Apache License, Version 2.0 (the
1:    "License"); you may not use this file except in compliance
1:    with the License.  You may obtain a copy of the License at
1:    
1:    http://www.apache.org/licenses/LICENSE-2.0
1:    
1:    Unless required by applicable law or agreed to in writing,
1:    software distributed under the License is distributed on an
1:    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:    KIND, either express or implied.  See the License for the
1:    specific language governing permissions and limitations
1:    under the License.
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Properties;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: public final class AccessTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Public constructor required for running test as standalone JUnit.
1:      */
1:     public AccessTest(String name)
1:     {
1:         super(name);
1:     }
1:     
0:     public void tearDown() throws Exception {
1:         Statement st = createStatement();
1:         super.tearDown();
1:         try {
0:             st.executeUpdate("DROP FUNCTION PADSTRING");
0:         } catch (SQLException e) {
0:             // never mind.
1:         }
1:     }
1:     
1:     public static Test suite() {
1:         Properties sysProps = new Properties();
1:         sysProps.put("derby.optimizer.optimizeJoinOrder", "false");
1:         sysProps.put("derby.optimizer.ruleBasedOptimization", "true");
1:         sysProps.put("derby.optimizer.noTimeout", "true");
1: 
1:         Test suite = TestConfiguration.embeddedSuite(AccessTest.class);
1:         return new CleanDatabaseTestSetup(new SystemPropertyTestSetup(suite, sysProps, true)) {
1:             /**
1:              * Creates the table used in the test cases.
1:              *
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 Connection conn = s.getConnection();
1:                 conn.setAutoCommit(false);
1: 
1:                 s.execute("CREATE FUNCTION  PADSTRING (DATA VARCHAR(32000), "
1:                         + "LENGTH INTEGER) RETURNS VARCHAR(32000) EXTERNAL NAME " +
1:                         "'org.apache.derbyTesting.functionTests.util.Formatters" +
1:                 ".padString' LANGUAGE JAVA PARAMETER STYLE JAVA");
1:             }
1:         };
1:     }    
1:     
1:     //---------------------------------------------------------
1:     //    test qualifier skip code on fields with length  
1:     //    having the 8th bit set in low order length byte. 
1:     // --------------------------------------------------------
1:     public void testQualifierSkipLOLB() throws Exception
1:     {
1: 
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1: 
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         setAutoCommit(false);
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '32768')");
1:         cSt.execute();
1:         st.executeUpdate("create table a ( " +
1:                 "i1 int, col00 varchar(384), col01 varchar(390), i2 int )");
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         // insert rows
1:         st.executeUpdate(
1:                 "insert into a values (1, PADSTRING('10',384), "
1:                 + "PADSTRING('100',390), 1000)");
1:         st.executeUpdate(
1:                 "insert into a values (2, PADSTRING('20',384), "
1:                 + "PADSTRING('200',390), 2000)");
1:         st.executeUpdate(
1:                 "insert into a values (3, PADSTRING('30',384), "
1:                 + "PADSTRING('300',390), 3000)");
1: 
1:         rs = st.executeQuery("select i1, i2 from a where i2 = 3000");
1: 
1:         expColNames = new String [] {"I1", "I2"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][] {{"3", "3000"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         st.executeUpdate("drop table a");
1:         commit();
1:     }
1: 
1:     // test case for a fixed bug where the problem was that the btree split 
1:     // would self deadlock while trying to reclaim rows during the split.
1:     // Fixed by just giving up if btree can't get the locks during the 
1:     // reclaim try.
1:     public void testCSBug2590() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("create table foo (a int, b varchar(900), c int)");
1: 
1:         // insert
1:         st.executeUpdate("insert into foo values (1, PADSTRING('1',900), 1)");
1:         st.executeUpdate("insert into foo values (2, PADSTRING('2',900), 1)");
1:         st.executeUpdate("insert into foo values (3, PADSTRING('3',900), 1)");
1:         st.executeUpdate("insert into foo values (4, PADSTRING('4',900), 1)");
1:         st.executeUpdate("insert into foo values (5, PADSTRING('5',900), 1)");
1:         st.executeUpdate("insert into foo values (6, PADSTRING('6',900), 1)");
1:         st.executeUpdate("insert into foo values (7, PADSTRING('7',900), 1)");
1:         st.executeUpdate("insert into foo values (8, PADSTRING('8',900), 1)");
1: 
1:         CallableStatement cSt;
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '4096')");
1:         cSt.execute();
1:         st.executeUpdate("create index foox on foo (a, b)");
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         commit();
1: 
1:         assertUpdateCount(st, 7, "delete from foo where foo.a <> 2");
1: 
1:         ResultSet rs = null;
1:         String [][] expRS;
1: 
1:         // Test full cursor for update scan over all the rows in the heap,  
1:         // with default group fetch.  Group fetch should be disabled.
1:         
1:         rs = st.executeQuery("select a, b, c from foo for update of c");
1:         expRS = new String [][] {{"2","2","1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // Do the same, but use a PreparedStatement.
1:         PreparedStatement ps_scan_cursor = prepareStatement(
1:             "select a, b, c from foo for update of c");
1:         ResultSet scan_cursor = ps_scan_cursor.executeQuery();
1:         expRS = new String [][] {{"2","2","1"}};
1:         JDBC.assertFullResultSet(scan_cursor, expRS, true);
1: 
1:         // these inserts would cause a lock wait timeout before 
1:         // the bug fix.
1:         st.executeUpdate("insert into foo values (1, PADSTRING('11',900), 1)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('12',900), 1)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('13',900), 1)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('14',900), 1)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('15',900), 1)");
1: 
1:         commit();
1:         st.executeUpdate("drop table foo");
1:         commit();
1:     }
1: 
1:     // test case a fixed bug where the problem was that when 
1:     // the level of btree grew, raw store would incorrectly 
1:     // report that there was not enough space to move all the   
1:     // rows from the root page to a newly allocated leaf page, 
1:     // so the create index operation would fail with a 
1:     // message saying that a row was too big. create and 
1:     // load a table with values from 1024 down to 1, the 
1:     // reverse order is important to reproduce the bug.
1:     public void testCSBug735() throws Exception
1:     {
1: 
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         st.executeUpdate("create table foo (a int)");
1:         st.executeUpdate("insert into foo values (1024)");
1:         st.executeUpdate("insert into foo (select foo.a - 1   from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 2   from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 4   from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 8   from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 16  from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 32  from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 64  from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 128 from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 256 from foo)");
1:         st.executeUpdate("insert into foo (select foo.a - 512 from foo)");
1:         
1:         // this create index used to fail.
1:         assertEquals(0, st.executeUpdate("create index a on foo (a)"));
1: 
1:         // Check the consistency of the indexes
1:         rs = st.executeQuery(
1:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'FOO')");
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][] {{"1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // a delete of the whole table also exercises the index well.
1:         assertUpdateCount(st, 1024, "delete from foo");
1: 
1:         st.executeUpdate("drop table foo");
1:     }
1: 
1:     // ---------------------------------------------------------
1:     // stress the conglomerate directory.  
1:     // abort of an alter table will clear the cache. 
1:     // ---------------------------------------------------------
1:     public void test_conglomDirectory() throws Exception
1:     {
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         String [] expColNames;
1:         setAutoCommit(false);
1: 
1:         st.executeUpdate("create table a (a int)");
1:         commit();
1:         st.executeUpdate("alter table a add column c1 int");
1: 
1:         rollback();
1: 
1:         rs = st.executeQuery("select * from a");
1: 
1:         expColNames = new String [] {"A"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         st.executeUpdate("drop table a");
1:         commit();
1:     }
1: 
1:     // ---------------------------------------------------------
1:     // ----- test case for partial row runtime statistics. ----- 
1:     // ---------------------------------------------------------
1:     /* This test checks correctness of simple runtime statistics.
1:        It first exercises queries when there's no index present, then with
1:         an index present; expecting to see a difference between Table Scan 
1:         and Index Scan. Also of interest is that the qualifiers look right; 
1:         whether it is using scan start/stop (this is a way to do qualifiers 
1:         using index).
1:        Then it does the same 2 actions after some rows have been
1:         deleted, to exercise the 'deleted rows visited' section in the
1:         runtime statistics.
1:        The queries which are cycled through are:
1:          query1: all columns & rows: "select * from foo"
1:          query2 - just last column: "select e from foo"
1:          query3: as subset of columns: "select e, c, a from foo"
1:          query4: as subset of columns, with qualifier in list: 
1:              "select e, c, a from foo where foo.e = 5"
1:          query5: as subset of columns, with qualifier not in list: 
1:              "select e, c, a from foo where foo.b = 20"
1:          query6: as subset of columns: "select a, b from foo"
1:      */
1:     public void testPartialRowRTStats() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set ISOLATION to RR");
1:         setAutoCommit(false);
1:         
1:         st.executeUpdate(
1:             "create table foo (a int, b int, c int, d int, e int)");
1:         st.executeUpdate("insert into foo values (1, 2, 3, 4, 5)");
1:         st.executeUpdate("insert into foo values (10, 20, 30, 40, 50)");
1:         
1:         // switch on runtime statistics
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         runQueriesNormal(st);
1: 
1:         // now check index scans - force the index just to make sure it 
1:         // does an index scan. 
1:         st.executeUpdate("create index foo_cover on foo (e, d, c, b, a)");
1:         runQueriesWithIndex(st);
1:         // drop the index...
1:         st.executeUpdate("drop index foo_cover");
1:         st.execute("call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','FOO',null)");
1:         
1:         // check deleted row feature
1:         st.executeUpdate("insert into foo values (100, 2, 3, 4, 5)");
1:         st.executeUpdate("insert into foo values (1000, 2, 3, 4, 5)");
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 100");
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1000");
1:         runQueriesWithDeletedRows(st);
1:         
1:         // now check index scans again
1:         // recreate the index to make sure it does an index scan.
1:         st.execute("create index foo_cover on foo (e, d, c, b, a)");
1:         // of course, we'll have to update statistics now before it looks good
1:         st.execute("call SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','FOO',null)");
1:         // and then we have to re-delete the rows because update statistics would've
1:         // reset the info about deleted rows.
1:         st.executeUpdate("insert into foo values (100, 2, 3, 4, 5)");
1:         st.executeUpdate("insert into foo values (1000, 2, 3, 4, 5)");
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 100");
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1000");
1:         runQueriesWithIndexDeletedRows(st);
1:         
1:         st.executeUpdate("drop table foo");
1:     }
1:     
1:     /* method used in testPartialRowRTStats and testCostingCoveredQuery */
1:     private void assertStatsOK(Statement st, String expectedScan, 
1:             String expTableInIndexScan, String expIndexInIndexScan, 
1:             String expBits, String expNumCols, String expDelRowsV,  
1:             String expPages, String expRowsQ, String expRowsV, 
1:             String expScanType, String expStartPosition, String expStopPosition,
1:             String expQualifier, String expQualifierInfo)
1:     throws SQLException {
1:         
1:         ResultSet rs = null;
1:         rs = st.executeQuery(
1:             "values SYSCS_UTIL.SYSCS_GET_RUNTIMESTATISTICS()");
1:         rs.next();
0:         if(usingEmbedded()){
0:             RuntimeStatisticsParser rtsp = new RuntimeStatisticsParser(rs.getString(1));
1:             rs.close();
1:             if (expectedScan.equals("Table"))
1:                     assertTrue(rtsp.usedTableScan());
1:             else if (expectedScan.equals("Index"))
1:             {
1:                 assertTrue(rtsp.usedIndexScan());
1:                 assertTrue(rtsp.usedSpecificIndexForIndexScan(
1:                         expTableInIndexScan, expIndexInIndexScan));
1:             }
1:             else if (expectedScan.equals("Constraint"))
1:             {
1:                 assertTrue(rtsp.usedIndexScan());
1:                 assertTrue(rtsp.usedConstraintForIndexScan(
1:                         expTableInIndexScan));
1:             }
1:             assertTrue(rtsp.findString("Bit set of columns fetched="+expBits, 1));
1:             assertTrue(rtsp.findString("Number of columns fetched="+expNumCols, 1));
1:             if (expDelRowsV!=null)
1:                 assertTrue(rtsp.findString("Number of deleted rows visited="+expDelRowsV, 1));
0:             assertTrue(rtsp.findString("Number of pages visited="+expPages, 1));
1:             assertTrue(rtsp.findString("Number of rows qualified="+expRowsQ, 1));            
1:             assertTrue(rtsp.findString("Number of rows visited="+expRowsV, 1));
1:             assertTrue(rtsp.findString("Scan type="+expScanType, 1));
1:             assertTrue(rtsp.getStartPosition()[1].indexOf(expStartPosition)>1);
1:             assertTrue(rtsp.getStopPosition()[1].indexOf(expStopPosition)>1);
1: 
1:             if (expQualifier.equals("None"))
1:                 assertTrue(rtsp.hasNoQualifiers());
1:             else if (expQualifier.equals("Equals"))
1:                 assertTrue(rtsp.hasEqualsQualifier());
1:             if (expQualifierInfo !=null)
1:                 assertTrue(rtsp.findString(expQualifierInfo, 1));
1:         }
1:     }
1:     
1:     private void runQueriesNormal(Statement st) throws SQLException { 
1:         doQuery1(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "All", "5", null, "1", "2", "2", 
1:             "heap","null","null","None", null);
1:         
1:         doQuery2(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{4}", "1", null, "1", "2", "2", 
1:             "heap","null","null","None", null);
1: 
1:         doQuery3(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "2", "2", 
1:             "heap","null","null","None", null);
1: 
1:         doQuery4(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "1", "2", 
1:             "heap","null","null","Equals","Column[0][0] Id: 4");
1: 
1:         doQuery5(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 1, 2, 4}", "4", null, "1", "1", "2", 
1:             "heap","null","null","Equals","Column[0][0] Id: 1");
1: 
1:         doQuery6(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 1}", "2", null, "1", "2", "2", 
1:             "heap","null","null","None",null);
1:     }
1:     
1:     private void runQueriesWithIndex(Statement st) throws SQLException {
1:         doQuery1(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 1, 2, 3, 4}", "5", "0", "1", "2", "2", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery2(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0}", "1", "0", "1", "2", "2", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery3(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 4}", "3", "0", "1", "2", "2", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery4(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 4}", "3", "0", "1", "1", "2", 
1:             "btree",">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         doQuery5(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 3, 4}", "4", "0", "1", "1", "2", "btree",
1:             "None","None","Equals", "Column[0][0] Id: 3");
1: 
1:         doQuery6(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{3, 4}", "2", "0", "1", "2", "2", "btree",
1:             "None","None","None", null);
1:     }
1:     
1:     private void runQueriesWithDeletedRows(Statement st) throws SQLException {
1:         doQuery1(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "All", "5", null, "1", "2", "4", "heap",
1:             "null","null","None", null);
1: 
1:         doQuery2(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{4}", "1", null, "1", "2", "4", "heap",
1:             "null","null","None", null);
1: 
1:         doQuery3(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "2", "4", "heap",
1:             "null","null","None", null);
1: 
1:         doQuery4(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 2, 4}", "3", null, "1", "1", "4", "heap",
1:             "null","null","Equals","Column[0][0] Id: 4");
1: 
1:         doQuery5(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 1, 2, 4}", "4", null, "1", "1", "4", "heap",
1:             "null","null","Equals","Column[0][0] Id: 1");
1: 
1:         doQuery6(st);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 1}", "2", null, "1", "2", "4", "heap",
1:             "null","null","None",null);
1:     }
1:     
1:     private void runQueriesWithIndexDeletedRows(Statement st) throws SQLException {
1:         doQuery1(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 1, 2, 3, 4}", "5", "2", "1", "2", "4", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery2(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0}", "1", "2", "1", "2", "4", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery3(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 4}", "3", "2", "1", "2", "4", "btree",
1:             "None","None","None", null);
1: 
1:         doQuery4(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 4}", "3", "2", "1", "1", "4", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         doQuery5(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{0, 2, 3, 4}", "4", "2", "1", "1", "4", "btree",
1:             "None","None","Equals", "Column[0][0] Id: 3");
1: 
1:         doQuery6(st);
1:         assertStatsOK(st, 
1:             "Index", "FOO", "FOO_COVER", 
1:             "{3, 4}", "2", "2", "1", "2", "4", "btree",
1:             "None","None","None", null);
1:     }
1:     
1:     private void doQuery1(Statement st) throws SQLException {
1:         // all columns and rows
1:         doQuery(st, "select * from foo",
1:                 new String [] {"A", "B", "C", "D", "E"},
1:                 new String [][] {
1:                         {"1", "2", "3", "4", "5"},
1:                         {"10", "20", "30", "40", "50"}});        
1:     }
1:     
1:     private void doQuery2(Statement st) throws SQLException {
1:         // just last column - should be 5 and 50 
1:         doQuery(st, "select e from foo", 
1:                 new String[] {"E"}, 
1:                 new String[][] {{"5"},{"50"}});
1:     }
1: 
1:     private void doQuery3(Statement st) throws SQLException {
1:         // as subset of columns - should be 5,3,1 and 50,30,10
1:         doQuery(st, "select e, c, a from foo",
1:                 new String [] {"E", "C", "A"},
1:                 new String [][] {
1:                         {"5", "3", "1"},
1:                         {"50", "30", "10"}});
1:     }
1: 
1:     private void doQuery4(Statement st) throws SQLException {
1:         // as subset of columns, with qualifier in list - should be 5,3,1
1:         doQuery(st, "select e, c, a from foo where foo.e = 5",
1:                 new String [] {"E", "C", "A"},
1:                 new String [][]{{"5", "3", "1"}});        
1:     }
1:     
1:     private void doQuery5(Statement st) throws SQLException {
1:         // as subset of columns, with qualifier not in list; should be 50,30,10 
1:         doQuery(st, "select e, c, a from foo where foo.b = 20", 
1:                 new String [] {"E", "C", "A"}, 
1:                 new String [][] {{"50", "30", "10"}});        
1:     }
1:     
1:     private void doQuery6(Statement st) throws SQLException {
1:         // as subset of columns
1:         doQuery(st, "select a, b from foo", 
1:                 new String [] {"A", "B"}, 
1:                 new String [][] {{"1", "2"},{"10", "20"}}); 
1:     }
1:     
1:     private void doQuery(Statement st,
1:             String query, String [] expColNames, String[][] expRS) 
1:     throws SQLException {
1:         ResultSet rs = null;
1:         rs = st.executeQuery(query);
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertFullResultSet(rs, expRS, true);        
1:     }
1:     
1:     // ----------------------------------------------------
1:     //           -- test case for costing - 
1:     // make sure optimizer picks obvious covered query. 
1:     // ----------------------------------------------------
1:     public void testCostingCoveredQuery() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set ISOLATION to RR");
1:         setAutoCommit(false);
1: 
1:         st.executeUpdate("create table base_table (a int, b varchar(1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (1, PADSTRING('1',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (2, PADSTRING('2',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (3,  PADSTRING('3',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (4,  PADSTRING('4',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (5,  PADSTRING('5',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (6,  PADSTRING('6',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (7,  PADSTRING('7',1000))");
1:         st.executeUpdate(
1:         "insert into base_table values (8,  PADSTRING('8',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (9,  PADSTRING('9',1000))");
1:         st.executeUpdate(
1:             "insert into base_table values (10, PADSTRING('10',1000))");
1:         st.executeUpdate("create index cover_idx on base_table(a)");
1: 
1:         // switch on runtime statistics
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         // make sure covered index is chosen
1:         doQuery(st, "select a from base_table", 
1:                 new String [] {"A"}, 
1:                 new String [][] {{"1"},{"2"},{"3"},{"4"},{"5"},
1:                                 {"6"},{"7"},{"8"},{"9"},{"10"}});
1:         assertStatsOK(st, 
1:                 "Index", "BASE_TABLE", "COVER_IDX", 
1:                 "{0}", "1", "0", "1", "10", "10", "btree",
1:                 "None","None","None", null);
1:     }
1:     
1:     // ----------------------------------------------------
1:     //       -- test for key too big error message. -- 
1:     // ----------------------------------------------------
1:     public void testKeyTooBigError() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate ("create table d (id int not null, " +
1:             "t_bigvarchar varchar(400), unique (id))");
1:         st.executeUpdate("create index t_bigvarchar_ind on d ( t_bigvarchar)");
1:         st.executeUpdate(
1:             "alter table d alter t_bigvarchar set data type varchar(4096)");
1: 
1:         String bigString="1111111";
1:         for (int i=0 ; i<314 ; i++)
1:             bigString=bigString+"1234567890";
1:         bigString=bigString+"123456";
1:         assertStatementError("XSCB6", st,
1:             "insert into d (id, t_bigvarchar) values (1, '" + bigString + "')");
1:     }
1:     
1:     // ---------------------------------------------------------
1:     //                  test space for update 
1:     // ---------------------------------------------------------
1:     public void testSpaceForUpdate() throws Exception
1:     {
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.minimumRecordSize', '1')");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', '0')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create table testing (a varchar(100))");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:         "'derby.storage.minimumRecordSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:         "'derby.storage.minimumRecordSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into testing values ('a')");
1:         for (int i=0 ; i<7 ; i++)
1:             st.executeUpdate(
1:                 "insert into testing (select testing.a from testing)");
1: 
1:         assertUpdateCount(st, 128,
1:             "update testing set a = 'abcd' where a = 'a'");
1: 
1:         st.executeUpdate("create index zz on testing (a)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.minimumRecordSize', '1')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create table t1 (a varchar(100))");
1: 
1:         st.executeUpdate("insert into t1 values ('a')");
1:         for (int i=0 ; i<7 ; i++)
1:             st.executeUpdate("insert into t1 (select t1.a from t1)");
1: 
1:         assertUpdateCount(st, 128,
1:         " update t1 set a = 'abcd' where a = 'a'");
1: 
1:         st.executeUpdate("create index zz1 on t1 (a)");
1:     }
1:     
1:         
1:     // ---------------------------------------------------------
1:     //     test load with long columns with index creation 
1:     // ---------------------------------------------------------
1:     public void testLoadLongColumnsCreateIndex() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1:         st.executeUpdate("set ISOLATION to RR");
1:         setAutoCommit(false);
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate(
1:             "create table long1 (a varchar(32000), b int, c int)");
1: 
1:         st.executeUpdate("insert into long1 values (" +
1:             "'this is a long row which will get even longer and longer " +
1:             "to force a stream', 1, 2)");
1:         st.executeUpdate("insert into long1 values (" +
1:             "'this is another long row which will get even longer " +
1:             "and longer to force a stream', 2, 3)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long1");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"5328"},{"5760"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate(
1:             "create table long2 (a varchar(16384), b int, c int)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '16384')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create index long2i1 on long2 (a)");
1:         st.executeUpdate("create index long2i2 on long2 (a,b)");
1:         st.executeUpdate("create index long2i3 on long2 (a,b,c)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into long2 select * from long1");
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long2");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"5328"},{"5760"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long2 " +
1:             "/*derby_properties index=long2i2*/");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"5328"},{"5760"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // DefectId CS 1346
1: 
1:         st.executeUpdate("insert into long2 select * from long1");
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long2");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"5328"},{"5328"},{"5760"},{"5760"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long2 " +
1:             "/*derby_properties index=long2i2*/");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"5328"},{"5328"},{"5760"},{"5760"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         
1:         assertUpdateCount(st, 4, "delete from long2");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create index long2small on long2 (a, c)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         // this small index should cause the insert to fail
1: 
1:         assertStatementError("XSCB6", st, 
1:             "insert into long2 select * from long1");
1: 
1:         // DefectId CS 1346 the small index should cause this insert 
1:         // to also fail
1: 
1:         assertStatementError("XSCB6", st,
1:             "insert into long2 select * from long1");
1: 
1:         rs = st.executeQuery("select LENGTH(a) from long2");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         // test case for track 1346
1: 
1:         st.executeUpdate("drop table long1");
1:         st.executeUpdate("drop table long2");
1:     }
1:     
1:     public void testCS1346() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1:         st.executeUpdate("set ISOLATION to RR");
1:         setAutoCommit(false);
1:         
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1:         st.executeUpdate(
1:             "create table long1 (a varchar(32000), b int, c int)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into long1 values ('this is a long row " +
1:             "which will get even longer', 1, 2)");
1:         st.executeUpdate("insert into long1 values ('a second row that will " +
1:             "also grow very long', 2, 3)");
1: 
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1: 
1:         rs = st.executeQuery("select LENGTH(a) as x from long1 order by x");
1: 
1:         expColNames = new String [] {"X"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"3024"},{"3240"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate(
1:             "create table long2 (a varchar(30000), b int, c int)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '16384')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create index long2i1 on long2 (a)");
1:         st.executeUpdate("create index long2i2 on long2 (b, a)");
1:         st.executeUpdate("create index long2i3 on long2 (b, a, c)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into long2 select * from long1");
1:         st.executeUpdate("insert into long2 select * from long1");
1: 
1:         rs = st.executeQuery("select LENGTH(a) as x from long2 order by x");
1: 
1:         expColNames = new String [] {"X"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"3024"},{"3024"},{"3240"},{"3240"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         st.executeUpdate("drop table long1");
1:         st.executeUpdate("drop table long2");
1: 
1:     }
1: 
1:     public void testCS1346b() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate(
1:             "create table long1 (a varchar(32000), b int, c int)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into long1 values ('this is a long row " +
1:             "which will get even longer', 1, 2)");
1:         st.executeUpdate("insert into long1 values ('a second row that will "
1:             + "also grow very long', 2, 3)");
1: 
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a||a||a||a||a");
1:         assertUpdateCount(st, 2, "update long1 set a = a||a");
1: 
1:         rs = st.executeQuery("select LENGTH(a) as x from long1 order by x");
1: 
1:         expColNames = new String [] {"X"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"3024"},{"3240"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '1024')");
1:         cSt.execute();
1: 
1:         st.executeUpdate(
1:             "create table long2 (a varchar(32000), b int, c int)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '16384')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create index long2i1 on long2 (a)");
1:         st.executeUpdate("create index long2i2 on long2 (b, a)");
1:         st.executeUpdate("create index long2i3 on long2 (b, a, c)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         // insert into the second table multiple times
1:         for (int i=0 ; i<10 ; i++)
1:             st.executeUpdate("insert into long2 select * from long1");
1: 
1:         rs = st.executeQuery("select LENGTH(a) as x from long2 order by x");
1: 
1:         expColNames = new String [] {"X"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [20][1];
1:         //10 rows should have '3024' and 10 '3240 as length
1:         for (int i=0 ; i<10 ; i++)
1:             expRS[i][0]="3024";
1:         for (int i=10 ; i<20 ; i++)
1:             expRS[i][0]="3240";
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         rs = st.executeQuery("select count(*) from long2");
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"20"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:     }
1: 
1:     // regression test case for a Cloudscape era bug, 1552
1:     // Make sure that a full scan which needs columns not in index
1:     // does not use the index.
1:     // Before the fix, access costing would make the optimizer 
1:     // pick the index because it incorrectly costed rows spanning pages.
1:     public void testCS1552() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize','4096')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create table a " +
1:             "(a int, b varchar(4000), c varchar(4000), d varchar(4000))");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create index a_idx on a (a)");
1: 
1:         st.executeUpdate("insert into a values (5, PADSTRING('a',4000), " + 
1:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:         st.executeUpdate("insert into a values (4, PADSTRING('a',4000), " + 
1:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:         st.executeUpdate("insert into a values (3, PADSTRING('a',4000), " +
1:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:         st.executeUpdate("insert into a values (2, PADSTRING('a',4000), " +
1:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1:         st.executeUpdate("insert into a values (1, PADSTRING('a',4000), " +
1:             "PADSTRING('a',4000), PADSTRING('a',4000))");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         cSt.execute();
1: 
1:         rs = st.executeQuery("select a, d from a");
1: 
1:         expColNames = new String [] {"A", "D"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         String paddeda = Formatters.padString("a", 4000);
1:         expRS = new String[][] {
1:             {"5", paddeda},
1:             {"4", paddeda}, 
1:             {"3", paddeda}, 
1:             {"2", paddeda}, 
1:             {"1", paddeda}}; 
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         assertStatsOK(st, 
1:             "Table", null, null, "{0, 3}", "2", null, "6", "5", "5", 
1:             "heap","null","null","None", null);
1:         
1:         st.execute("drop table a");
1:         commit();
1:     }
1:     
1:     // test case for track 2241"};
1:     // The problem was that when the level of btree grew, 
1:     // sometimes a long row would be chosen as the branch 
1:     // delimiter, and the branch code did not throw the 
1:     // correct error noSpaceForKey error.
1:     public void testCS2241() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.minimumRecordSize', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create table b2241 (a int, b varchar(32000))");
1:         st.executeUpdate("insert into b2241 values (1024, " +
1:             "'01234567890123456789012345678901234567890123456789')");
1:         String inshalf1 = "insert into b2241 (select b2241.a + ";
1:         String inshalf2 = ", b from b2241)";
1:         st.executeUpdate(inshalf1 + "1" + inshalf2);
1:         st.executeUpdate(inshalf1 + "2" + inshalf2);
1:         st.executeUpdate(inshalf1 + "4" + inshalf2);
1:         st.executeUpdate(inshalf1 + "8" + inshalf2);
1:         st.executeUpdate(inshalf1 + "16" + inshalf2);
1:         st.executeUpdate(inshalf1 + "32" + inshalf2);
1:         st.executeUpdate(inshalf1 + "64" + inshalf2);
1:         for (int i=0 ; i<5  ; i++)
1:             assertUpdateCount(st, 128, "update b2241 set b = b||b");
1:         rs = st.executeQuery("select LENGTH(b) from b2241 where a = 1025");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"1600"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         st.executeUpdate(
1:                 " insert into b2241 (select 1, "
1:                 + "b||b||b||b||b||b||b||b from b2241 where a = 1024)");
1:         st.executeUpdate(
1:                 " insert into b2241 (select 8000, "
1:                 + "b||b||b||b||b||b||b||b from b2241 where a = 1024)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '4096')");
1:         cSt.execute();
1: 
1:         // this create index use to fail with an assert - should 
1:         // fail with key too big error.
1:         assertStatementError("XSCB6", st, "create index a on b2241 (b, a)");
1:         // make sure table still accessable, by doing the same statement
1:         assertStatementError("XSCB6", st, "create index a on b2241 (b, a)");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1: 
1:         // delete 2 big records and then index should work.
1:         assertUpdateCount(st, 1, "delete from b2241 where a = 1");
1:         assertUpdateCount(st, 1, "delete from b2241 where a = 8000");
1: 
1:         st.executeUpdate("create index a on b2241 (b, a)");
1: 
1:         // Check the consistency of the indexes
1:         rs = st.executeQuery("VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'B2241')");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         st.executeUpdate("drop table b2241");
1:     }
1: 
1:     // o insert bunch of rows with sequential keys.
1:     // o create an index (non unique or unique)
1:     // o delete every other one - will make normat post commit not fire.
1:     // o commit
1:     // o now reinsert rows into the "holes" which before the fix 
1:     //   would cause splits, but now will force reclaim space and 
1:     //   reuse existing space in btree.
1:     private void reclaimTest(String createIndex, String expectedError) 
1:     throws SQLException {
1:         CallableStatement cSt;
1:         setAutoCommit(false);
1:         Statement st = createStatement();
1: 
1:         // set page size to default.
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '4096')");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.minimumRecordSize', '1')");
1:         cSt.execute();
1:         cSt.close();        
1:         commit();
1: 
1:         // create and load a table with values from 1024 down to 1,
1:         st.executeUpdate("create table foo (a int, b char(200), c int)");
1:         st.executeUpdate("insert into foo values (1024, 'even', 0)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 1, 'odd' , 1 from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 2, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 4, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 8, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 16, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 32, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 64, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 128, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 256, foo.b, foo.c from foo)");
1:         st.executeUpdate("insert into foo " +
1:             "(select foo.a - 512, foo.b, foo.c from foo)");
1: 
1:         // insert into the "holes", but different keys (even2 instead of even)
1:         st.executeUpdate("create table foo2 (a int, b char(200), c int)");
1:         st.executeUpdate("insert into foo2 (select * from foo)");
1: 
1:         assertUpdateCount(st, 512, "delete from foo2 where foo2.c = 1");
1: 
1:         // create "packed" index.
1:         st.executeUpdate(createIndex);
1: 
1:         // delete ever other row
1:         assertUpdateCount(st, 512, "delete from foo where foo.c = 0");
1: 
1:         // turn all the deletes into "committed deletes"
1:         commit();
1:         st.executeUpdate("insert into foo " +
1:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:         commit();
1: 
1:         // insert dups
1:         if (expectedError !=  null)
1:             assertStatementError("23505", st, "insert into foo " +
1:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:         else
1:             assertUpdateCount(st, 512, "insert into foo " +
1:             "(select foo2.a, 'even2', foo2.c from foo2)");
1:         commit();
1: 
1:         // a delete of the whole table also exercises the btree well.
1:         if (expectedError !=  null)
1:         {
1:             assertUpdateCount(st, 1024, "delete from foo");
1:             assertUpdateCount(st, 512, "delete from foo2");
1:         }
1:         else 
1:         {
1:             assertUpdateCount(st, 1536, "delete from foo");
1:             assertUpdateCount(st, 512, "delete from foo2");
1:         }
1:         commit();
1: 
1:         st.executeUpdate("drop table foo");
1:         st.executeUpdate("drop table foo2");
1:         commit();
1:     }
1:     
1:     // test case for reclaiming deleted rows during split.
1:     // actual work is done in method reclaimTest()
1:     // exercise test case with non-unique index
1:     public void testReclaimDeletedRowsDuringSplit() throws Exception
1:     {
1:         reclaimTest("create index a on foo (a, b)", null);
1:     }
1: 
1:     // as testReclaimDeletedRowsDuringSplit, but with unique index,
1:     // so when attempting to create the duplicat rows, we should get an
1:     // error. 
1:     // actual work is done in method reclaimTest()
1:     public void testReclaimDeletedRowsUniqueIndex() throws Exception
1:     {
1:         reclaimTest("create unique index a on foo (a, b)", "23505");
1:     }
1: 
1:     // same foo used in the next 3 test fixtures
1:     private void setupForReclaim2(Statement st) throws SQLException {
1:         st.executeUpdate("create table foo (a int, b varchar(1100), c int)");
1:         st.executeUpdate("create index a on foo (a, b)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('a',1100), 1)");
1:         st.executeUpdate("insert into foo values (2, PADSTRING('a',1100), 1)");
1:         st.executeUpdate("insert into foo values (3, PADSTRING('a',1100), 1)");
1:     }
1:     
1:     private void reclaimDeletedRows2(boolean toCommit) throws SQLException {
1:         Statement st = createStatement();
1: 
1:         setupForReclaim2(st);
1:         commit();
1: 
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1");
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 2");
1:         
1:         if (toCommit)
1:             commit();
1:         st.executeUpdate("insert into foo values " +
1:             "(-1, PADSTRING('ab',1100), 1)");
1:         st.executeUpdate("insert into foo values " +
1:             "(-2, PADSTRING('ab',1100), 1)");
1:         rollback();
1: 
1:         st.executeUpdate("drop table foo");
1:         commit();
1:     }
1:     
1:     // another simple test of reclaim deleted row code paths. 
1:     // this test should not reclaim rows as deletes are not committed.
1:     public void testUncommittedDeletesNotReclaimed() throws Exception
1:     {
1:         reclaimDeletedRows2(false);
1:     }
1: 
1:     // another simple test of reclaim deleted row code paths. 
1:     // this test should reclaim rows as deletes are committed.
1:     public void testCommittedDeletesReclaim() throws Exception
1:     {
1:         reclaimDeletedRows2(true);
1:     }
1: 
1:     // this test will not reclaim rows because the parent xact 
1:     // has table level lock.
1:     public void testAllUncommittedReclaim() throws Exception
1:     {
1:         Statement st = createStatement();
1: 
1:         setupForReclaim2(st);
1:         assertUpdateCount(st, 1, "delete from foo where foo.a = 1");
1: 
1:         st.executeUpdate("insert into foo values (0, PADSTRING('a',1100), 1)");
1:         st.executeUpdate("insert into foo values (1, PADSTRING('a',1100), 1)");
1:         rollback();
1: 
1:         st.executeUpdate("drop table foo");
1:     }
1: 
1:     // regression test case for Cloudscape fixed bug track 2778
1:     // Make sure that an update which causes a row to go from a non long row 
1:     // to a long row can be aborted correctly.
1:     // Prior to this fix the columns moving off the page would be corrupted. 
1:     // create a base table that contains 2 rows, 19 columns,  
1:     // that leaves just 1 byte free on the page.
1:     // freeSpace: 1, spareSpace: 10, PageSize: 2048
1:     public void testCS2778() throws Exception
1:     {
1:         ResultSet rs = null;
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', '2048')");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', '10')");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create table t2778 (" +
1:             "col00 char(2), col01 char(1), col02 char(99), col03 char(11), " +
1:             "col04 char(7), col05 char(11), col06 char(6), col07 char(6), " +
1:             "col08 char(2), col09 char(6), col10 varchar(1000), " +
1:             "col11 char(2), col12 char(1), col13 char(7), col14 char(24), " +
1:             "col15 char(1), col16 char(166), col17 char(207), col18 char(2))");
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageSize', NULL)");
1:         cSt.execute();
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("create unique index a_idx on t2778 (col00)");
1:         commit();
1: 
1:         st.executeUpdate("insert into t2778 values ( '0_', '0', '0_col02', " +
1:             "'0_col03', '0_col04', '0_col05', '0_06', '0_07', '0_', '0_09', " +
1:             "'0_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllll012340_col10lllllllllll', '0_', '0', '0_col13', " +
1:             "'0_col14', '0', '0_col16', '0_col17', '0_' )");
1: 
1:         st.executeUpdate("insert into t2778 values ( '1_', '1', '1_col02', " +
1:             "'1_col03', '1_col04', '1_col05', '1_06', '1_07', '1_', '1_09', " +
1:             "'1_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllll012340_col10llllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllll012340_col10lllllllllllxxx" +
1:             "xxxxxxxxxxxxxxxx', '1_', '1', '1_col13', '1_col14', '1', " +
1:             "'1_col16', '1_col17', '1_' )");
1:         commit();
1: 
1:         rs = st.executeQuery(" select col16, col17, col18 from t2778");
1:         expColNames = new String [] {"COL16", "COL17", "COL18"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{
1:             {"0_col16", "0_col17", "0_"},
1:             {"1_col16", "1_col17", "1_"}
1:                               };
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         commit();
1: 
1:         assertUpdateCount(st, 1, "update t2778 " +
1:             "/*derby-properties index=a_idx*/ set col10 = " +
1:             "'0_col10lllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllll012340_col10lllllllllllxxxxxx' " +
1:             "where col00 = '0_'");
1:         rollback();
1: 
1:         // prior to the fix col17 and col18 would come back null.
1:         rs = st.executeQuery("select " +
1:             "col01, col02, col03, col04, col05,  col06, " +
1:             "col07, col08, col09, col10, col11, col12, col13, " +
1:             "col14, col15, col16, col17, col18 from t2778");
1: 
1:         expColNames = new String [] {"COL01", "COL02", "COL03", "COL04", 
1:             "COL05", "COL06", "COL07", "COL08", "COL09", "COL10", "COL11",
1:             "COL12", "COL13", "COL14", "COL15", "COL16", "COL17", "COL18"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"0", "0_col02", "0_col03", "0_col04", 
1:             "0_col05", "0_06", "0_07", "0_", "0_09", 
1:             "0_col10llllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "llllllllll012340_col10lllllllllllxxxxxx", 
1:             "0_", "0", "0_col13", "0_col14", "0", "0_col16", "0_col17", "0_"},
1:                                 {"1", "1_col02", "1_col03", "1_col04", 
1:             "1_col05", "1_06", "1_07", "1_", "1_09", 
1:             "1_col10llllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "llllllllll012340_col10lllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll" +
1:             "llllllllllllllllllllllllllllllllllll012340_col10lllllllllllxxxx" +
1:             "xxxxxxxxxxxxxxx", "1_", "1", "1_col13", "1_col14", "1", 
1:             "1_col16", "1_col17", "1_"}
1:                               };
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         commit();
1: 
1:         st.executeUpdate("drop table t2778");
1:         commit();
1:     }
1: 
1:     // test case for Cloudscape track 3149, improving max on btree optimization
1:     public void testCS3149() throws Exception
1:     {
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1:         String [][] expRS;
1:         String [] expColNames;        
1: 
1:         setAutoCommit(false);
1:         st.executeUpdate("create table foo (a int, b varchar(500), c int)");
1:         
1:         String insertPart1 = "insert into foo values (";
1:         String insertPart2 = ", PADSTRING('";
1:         String insertPart3 = "',500), 1)";
1:         for (int i=1 ; i<10 ; i++)
1:         {
1:             String s = String.valueOf(i);
1:             st.executeUpdate(insertPart1 + s + insertPart2 + s + insertPart3);
1:         }
1:         for (int i=11 ; i<19 ; i++)
1:         {
1:             String s = String.valueOf(i);
1:             st.executeUpdate(insertPart1 + s + insertPart2 + s + insertPart3);
1:         }
1:         st.executeUpdate("create index foox on foo (b)");
1:         commit();
1: 
1:         // normal max optimization, last row in index is not deleted.
1:         rs = st.executeQuery("select max(b) from foo");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"9"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // new max optimization, last row in index is deleted but 
1:         // others on page aren't.
1:         assertUpdateCount(st, 1, "delete from foo where a = 9");
1: 
1:         rs = st.executeQuery("select max(b) from foo");
1: 
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"8"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // new max optimization, last row in index is deleted but 
1:         // others on page aren't.
1:         assertUpdateCount(st, 1, "delete from foo where a = 8");
1: 
1:         rs = st.executeQuery("select max(b) from foo");
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"7"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // max optimization does not work - fail over to scan, all 
1:         // rows on last page are deleted.
1:         assertUpdateCount(st, 13, "delete from foo where a > 2");
1: 
1:         rs = st.executeQuery("select max(b) from foo");
1:         expColNames = new String [] {"1"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"2"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1:         commit();
1: 
1:         st.executeUpdate("drop table foo");
1:         commit();
1:     }
1: 
1:     //---------------------------------------------------------
1:     //         regression test for Cloudscape bugs 3368, 3370  
1:     // the bugs arose for the edge case where pageReservedSpace = 100
1:     // before bug 3368 was fixed, a short row insert caused 2 pages 
1:     // to be allocated per short row insert.
1:     public void testCS3368_3370() throws Exception
1:     {
1:         CallableStatement cSt;
1:         Statement st = createStatement();
1: 
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', '100')");
1:         cSt.execute();
1:         st.executeUpdate("create table a (a int)");
1:         cSt = prepareCall("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(" +
1:             "'derby.storage.pageReservedSpace', NULL)");
1:         cSt.execute();
1: 
1:         st.executeUpdate("insert into a values (1)");
1: 
1:         checkSpaceTable(st, "2");
1: 
1:         st.executeUpdate("insert into a values (2)");
1: 
1:         checkSpaceTable(st, "3");
1: 
1:         st.executeUpdate("insert into a values (1)");
1: 
1:         checkSpaceTable(st, "4");
1: 
1:         st.executeUpdate("insert into a values (2)");
1: 
1:         checkSpaceTable(st, "5");
1:     }
1:     
1:     private void checkSpaceTable(Statement st, String expValue)
1:     throws SQLException {
1:         ResultSet rs = null;
1:         String [][] expRS;
1:         
1:         rs = st.executeQuery("select numallocatedpages from TABLE" +
1:                 "(SYSCS_DIAG.SPACE_TABLE('APP', 'A')) a");
1:         expRS = new String [][]{{expValue}};
1:         JDBC.assertFullResultSet(rs, expRS, true);        
1:     }
1: 
1:     //---------------------------------------------------------
1:     // regression test for old Cloudscape bug track 4595,
1:     // following are 2 test cases that get cycled with 3 different indexes:
1:     // 1. unique index
1:     // 2. primary key
1:     // 3. non unique index
1:     // The 2 test cases are:
1:     // a. do delete, update and select without any rows (and check statistics)
1:     //    then insert a row, and do update and delete
1:     // b. do delete, and update after inserting a row (and check stats)
1:     //    then do the same selects as in test case a
1:     private void doTestCaseCS4595A (Statement st, String indexOrConstraint) 
1:     throws SQLException {
1:         ResultSet rs = null;
1:         String [] expColNames;
1:         
1:         String indexName;
1:         if (indexOrConstraint.equals("Index"))
1:             indexName="FOOX";
1:         else 
1:             indexName=null;
1: 
1:         st.executeUpdate("set ISOLATION to RR");
1:         
1:         // delete against table with 0 rows.
1:         assertUpdateCount(st, 0, "delete from foo where a = 1");
1: 
1:         // make sure index used in unique key update even if table has zero rows.
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0, 1}", "2", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // update against table with 0 rows. 
1:         
1:         assertUpdateCount(st, 0, "update foo set b = 1 where a = 2");
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "All", "2", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // select * against table with 0 rows. 
1:         rs = st.executeQuery("select * from foo where a = 2");
1: 
1:         JDBC.assertEmpty(rs);
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "All", "2", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // select against table with 0 rows
1:         rs = st.executeQuery("select a from foo where a = 2");
1: 
1:         expColNames = new String [] {"A"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0}", "1", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // select against table with 0 rows.
1:         // second time should give slightly different statistics; different
1:         // set of rows fetched.
1:         rs = st.executeQuery("select a from foo where a = 2");
1: 
1:         expColNames = new String [] {"A"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0}", "1", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:         
1:         // now insert one row and make sure still same plan.  
1:         // Previous to 4595, 0 row plan was a table scan and it would not 
1:         // change when 1 row was inserted.
1:         st.execute("insert into foo values (1, 1)");
1: 
1:         // update against table with 1 row.
1:         assertUpdateCount(st, 1, "update foo set b = 2 where a = 1");
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "All", "2", "0", "1", "1", "1", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // delete against table with 1 row.
1:         st.execute("delete from foo where a = 1");
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0, 1}", "2", "0", "1", "1", "1", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         st.execute("drop table foo");
1:         commit();
1:     }
1:     
1:     private void doTestCaseCS4595B(Statement st, String indexOrConstraint) throws SQLException {
1:         ResultSet rs = null;
1:         String [] expColNames;
1: 
1:         String indexName;
1:         if (indexOrConstraint.equals("Index"))
1:             indexName="FOOX";
1:         else 
1:             indexName=null;
1:         
1:         commit();
1:         
1:         // update against table with 1 row.
1:         assertUpdateCount(st, 1, "update foo set b = 2 where a = 1");
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "All", "2", "0", "1", "1", "1", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // delete against table with 1 row.
1:         st.execute("delete from foo where a = 1");
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0, 1}", "2", "0", "1", "1", "1", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1:         
1:         rs = st.executeQuery("select * from foo where a = 2");
1: 
1:         JDBC.assertEmpty(rs);
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "All", "2", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // select against table with 0 rows
1:         rs = st.executeQuery("select a from foo where a = 2");
1: 
1:         expColNames = new String [] {"A"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1:         
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0}", "1", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         // select against table with 0 rows.
1:         // second time should give slightly different statistics; different
1:         // set of rows fetched.
1:         rs = st.executeQuery("select a from foo where a = 2");
1: 
1:         expColNames = new String [] {"A"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         assertStatsOK(st, 
1:             indexOrConstraint, "FOO", indexName, 
1:             "{0}", "1", "0", "1", "0", "0", "btree",
1:             ">= on first 1 column(s).","> on first 1 column(s).","None", null);
1: 
1:         st.execute("drop table foo");
1:     }
1: 
1:     public void testCS4595A_UniqueIndex() throws Exception
1:     {
1:         Statement st = createStatement();
1:         
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         st.executeUpdate("create table foo (a int, b int)");
1:         st.executeUpdate("create unique index foox on foo (a)");
1: 
1:         doTestCaseCS4595A(st, "Index");
1:     }
1: 
1:     // try delete/update statement compiled against table with 1 row.
1:     public void testCS4595B_UniqueIndex() throws Exception
1:     {
1:         Statement st = createStatement();
1: 
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         st.executeUpdate("create table foo (a int, b int)");
1:         // this time, insert a row before creating an index
1:         st.executeUpdate("insert into foo values (1, 1)");
1:         st.executeUpdate("create unique index foox on foo (a)");
1: 
1:         doTestCaseCS4595B(st, "Index");
1:     }
1: 
1:     // repeat set of testCS459_a against table with primary key, 
1:     // vs. unique index 
1:     // there should be no difference in plan shape. 
1:     // try delete/update statement compiled against table with 0 rows
1:     public void testCS4595A_PrimaryKey() throws Exception
1:     {
1:         Statement st = createStatement();
1: 
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         st.executeUpdate(
1:             "create table foo (a int not null primary key, b int)");
1:         
1:         doTestCaseCS4595A(st, "Constraint");
1:     }
1: 
1:     // try delete/update statement compiled against table with 1 row.
1:     // With primary key.
1:     public void testCS4595B_PrimaryKey() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         
1:         st.executeUpdate(
1:             "create table foo (a int not null primary key, b int)");
1:         st.executeUpdate("insert into foo values (1, 1)");
1:         
1:         doTestCaseCS4595B(st, "Constraint");
1:     }
1: 
1:     // repeat set of 4595 tests against table with non-unique index 
1:     // with no statistics.
1:     // there should be no difference in plan shape.
1:     // try delete/update statement compiled against table with 0 rows
1:     public void testCaseCS4595A_NonUniqueIndex() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         st.executeUpdate("create table foo (a int, b int)");
1:         st.executeUpdate("create index foox on foo (a)");
1: 
1:         doTestCaseCS4595A(st, "Index");
1:     }
1: 
1:     // try delete/update statement compiled against table with 1 row.
1:     public void testCaseCS4595B_NonUniqueIndex() throws Exception
1:     {
1:         Statement st = createStatement();
1:         st.executeUpdate("set ISOLATION to RR");
1:         st.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 
1:         st.executeUpdate("create table foo (a int, b int)");
1:         st.executeUpdate("create index foox on foo (a)");
1:         st.executeUpdate("insert into foo values (1, 1)");
1:         
1:         doTestCaseCS4595B(st, "Index");
1:     }
1: 
1:     // ----------------------------------------------------
1:     //        simple regression test for qualifier work. 
1:     // ----------------------------------------------------
1:     public void testQualifiers() throws Exception
1:     {
1:         ResultSet rs = null;
1:         Statement st = createStatement();
1: 
1:         String [][] expRS;
1:         String [] expColNames;
1: 
1:         st.executeUpdate("create table foo (a int, b int, c int)");
1:         st.executeUpdate("insert into foo values (1, 10, 100)");
1:         st.executeUpdate("insert into foo values (2, 20, 200)");
1:         st.executeUpdate("insert into foo values (3, 30, 300)");
1: 
1:         // should return no rows
1:         rs = st.executeQuery("select a, b, c from foo where a = 1 and b = 20");
1: 
1:         expColNames = new String [] {"A", "B", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         JDBC.assertDrainResults(rs, 0);
1: 
1:         // should return one row
1:         rs = st.executeQuery("select a, b, c from foo where a = 3 and b = 30");
1: 
1:         expColNames = new String [] {"A", "B", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"3", "30", "300"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery("select a, b, c from foo where a = 3 or c = 40");
1: 
1:         expColNames = new String [] {"A", "B", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"3", "30", "300"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // should return 2 rows
1:         rs = st.executeQuery("select a, b, c from foo where a = 1 or b = 20");
1: 
1:         expColNames = new String [] {"A", "B", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"1", "10", "100"}, {"2", "20", "200"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         rs = st.executeQuery("select a, b, c from foo where a = 1 or a = 3");
1: 
1:         expColNames = new String [] {"A", "B", "C"};
1:         JDBC.assertColumnNames(rs, expColNames);
1:         expRS = new String [][]{{"1", "10", "100"}, {"3", "30", "300"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
0:         st.executeUpdate("DROP FUNCTION PADSTRING");
1: 
1:         rollback();
1:         st.close();
1:     }
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c211833
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:             assertTrue(
0:                 "RuntimeStatisticsParser.findstring(Number of pages visited= "
0:                     + expPages + ") returned false" +
0:                 "full runtime statistics = " + rtsp.toString(),
0:                 rtsp.findString("Number of pages visited=" + expPages, 1));
1: 
/////////////////////////////////////////////////////////////////////////
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:efe47b4
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.AssertionFailedError;
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = st.executeQuery(
1:         RuntimeStatisticsParser rtsp =
1:             new RuntimeStatisticsParser(rs.getString(1));
0:         rs.close();
1: 
1:         try {
/////////////////////////////////////////////////////////////////////////
1:         } catch (AssertionFailedError e) {
1:             // One of the assertions failed. Report the full statistics
1:             // to help debugging.
1:             fail("Statistics didn't match:\n" + rtsp.toString(), e);
commit:9b3569f
/////////////////////////////////////////////////////////////////////////
1:      * Array with names of database properties that may be modified by
1:      * the test cases in this class. The properties will be cleared in
1:      * {@link #tearDown()}.
1:      */
1:     private static final String[] MODIFIED_DB_PROPS = {
1:         "derby.storage.pageSize",
1:         "derby.storage.minimumRecordSize",
1:         "derby.storage.pageReservedSpace",
1:     };
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tear down the test environment.
1:      */
1:     protected void tearDown() throws Exception {
1:         rollback();
1: 
1:         // Clear the database properties set by this test so that they
1:         // don't affect other tests.
1:         PreparedStatement clearProp = prepareStatement(
1:                 "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, NULL)");
1:         for (int i = 0; i < MODIFIED_DB_PROPS.length; i++) {
1:             clearProp.setString(1, MODIFIED_DB_PROPS[i]);
1:             clearProp.executeUpdate();
0:         }
1:         commit();
1: 
0:         super.tearDown();
0:     }
1: 
commit:f59fc44
/////////////////////////////////////////////////////////////////////////
0: 
1:         st.executeUpdate("drop table long1");
1:         st.executeUpdate("drop table long2");
/////////////////////////////////////////////////////////////////////////
0: 
1:         st.executeUpdate("drop table a");
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
0: 
/////////////////////////////////////////////////////////////////////////
commit:9556e96
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:40ca7ba
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         //DERBY-5119 Table foo is used in lots of fixtures.
1:         // make sure it gets cleaned up.
0:         try {
1:             s.executeUpdate("DROP TABLE FOO");
1:         } catch (SQLException se) {
1:             // if the table couldn't drop make sure it is because it doesn't
1:             // exist
1:             assertSQLState("42Y55",se);
0:         }
============================================================================