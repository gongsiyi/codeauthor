1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.UCode_CharStream
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
1:eac0369: package org.apache.derby.impl.sql.compile;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * An implementation of interface CharStream, where the stream is assumed to
1:eac0369:  * contain only Unicode characters.
1:eac0369:  */
1:eac0369: 
1:eac0369: // NOTE: This class was modified to support the ability to get all the
1:eac0369: // characters in the input stream between two tokens.  - Jeff
1:eac0369: 
1:eac0369: public final class UCode_CharStream implements CharStream
1:eac0369: {
1:eac0369:   // The next two lines are added to support ability to get the input
1:eac0369:   // between two tokens.
1:eac0369:   int charCnt;
1:eac0369:   int[] charOffset;
1:eac0369: 
1:eac0369:   public static final boolean staticFlag = false;
1:eac0369:   public int bufpos = -1;
1:eac0369:   int bufsize;
1:eac0369:   int available;
1:eac0369:   int tokenBegin;
1:eac0369:   private int bufline[];
1:eac0369:   private int bufcolumn[];
1:eac0369: 
1:eac0369:   private int column = 0;
1:eac0369:   private int line = 1;
1:eac0369: 
1:eac0369:   private boolean prevCharIsCR = false;
1:eac0369:   private boolean prevCharIsLF = false;
1:eac0369: 
1:eac0369:   private java.io.Reader inputStream;
1:eac0369: 
1:eac0369:   private char[] nextCharBuf;
1:eac0369:   private char[] buffer;
1:eac0369:   private int maxNextCharInd = 0;
1:eac0369:   private int nextCharInd = -1;
1:eac0369: 
1:3bb140c:   private void ExpandBuff(boolean wrapAround)
1:eac0369:   {
1:eac0369:      char[] newbuffer = new char[bufsize + 2048];
1:eac0369:      int newbufline[] = new int[bufsize + 2048];
1:eac0369:      int newbufcolumn[] = new int[bufsize + 2048];
1:eac0369: 
1:eac0369: 	// The next line was added to support ability to get the input
1:eac0369: 	// between two tokens.
1:eac0369: 	int newcharOffset[] = new int[bufsize + 2048];
1:eac0369: 
1:eac0369:      try
1:eac0369:      {
1:eac0369:         if (wrapAround)
1:eac0369:         {
1:eac0369:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:eac0369:            System.arraycopy(buffer, 0, newbuffer,
1:eac0369:                                              bufsize - tokenBegin, bufpos);
1:eac0369:            buffer = newbuffer;
1:eac0369: 
1:eac0369:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:eac0369:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
1:eac0369:            bufline = newbufline;
1:eac0369: 
1:eac0369:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:eac0369:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
1:eac0369:            bufcolumn = newbufcolumn;
1:eac0369: 
1:eac0369: 			// The next three lines were added to support ability to get input
1:eac0369: 			// between two tokens.
1:eac0369: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
1:eac0369: 		   System.arraycopy(charOffset, 0, newcharOffset, bufsize - tokenBegin, bufpos);
1:eac0369: 		   charOffset = newcharOffset;
1:eac0369: 
1:eac0369:            bufpos += (bufsize - tokenBegin);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:eac0369:            buffer = newbuffer;
1:eac0369: 
1:eac0369:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:eac0369:            bufline = newbufline;
1:eac0369: 
1:eac0369:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:eac0369:            bufcolumn = newbufcolumn;
1:eac0369: 
1:eac0369: 			// The next two lines were added to support ability to get input
1:eac0369: 			// between two tokens.
1:eac0369: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
1:eac0369: 		   charOffset = newcharOffset;
1:eac0369: 
1:eac0369:            bufpos -= tokenBegin;
1:eac0369:         }
1:eac0369:      }
1:eac0369:      catch (Throwable t)
1:eac0369:      {
1:eac0369:         throw new Error(t.getMessage());
1:eac0369:      }
1:eac0369: 
1:eac0369:      available = (bufsize += 2048);
1:eac0369:      tokenBegin = 0;
1:eac0369:   }
1:eac0369: 
1:3bb140c:   private void FillBuff() throws java.io.IOException
1:eac0369:   {
1:eac0369:      if (maxNextCharInd == nextCharBuf.length)
1:eac0369:         maxNextCharInd = nextCharInd = 0;
1:eac0369: 
1:eac0369:      int i;
1:eac0369:      try {
1:eac0369:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
1:eac0369:                                   nextCharBuf.length - maxNextCharInd)) == -1)
1:eac0369:         {
1:eac0369:            inputStream.close();
1:eac0369:            throw new java.io.IOException();
1:eac0369:         }
1:eac0369:         else
1:eac0369:            maxNextCharInd += i;
1:eac0369:      }
1:eac0369:      catch(java.io.IOException e) {
1:eac0369:         if (bufpos != 0)
1:eac0369:         {
1:eac0369:            --bufpos;
1:eac0369:            backup(0);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:            bufline[bufpos] = line;
1:eac0369:            bufcolumn[bufpos] = column;
1:eac0369:         }
1:eac0369:         if (tokenBegin == -1)
1:eac0369:            tokenBegin = bufpos;
1:eac0369:         throw e;
1:eac0369:      }
1:eac0369:   }
1:eac0369: 
1:3bb140c:   private char ReadChar() throws java.io.IOException
1:eac0369:   {
1:eac0369:      if (++nextCharInd >= maxNextCharInd)
1:eac0369:         FillBuff();
1:eac0369: 
1:eac0369: 	 return nextCharBuf[nextCharInd];
1:eac0369:   }
1:eac0369:      
1:eac0369:   public char BeginToken() throws java.io.IOException
1:eac0369:   {     
1:eac0369: 	 if (inBuf > 0)
1:eac0369: 	 {
1:eac0369: 		--inBuf;
1:eac0369: 		return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0)
1:eac0369: 															: ++bufpos];
1:eac0369: 	 }
1:eac0369: 
1:eac0369:      tokenBegin = 0;
1:eac0369: 	 bufpos = -1;
1:eac0369:      char c = readChar();
1:eac0369: 
1:eac0369:      return c;
1:eac0369:   }     
1:eac0369: 
1:3bb140c:   private void UpdateLineColumn(char c)
1:eac0369:   {
1:eac0369:      column++;
1:eac0369: 
1:eac0369:      if (prevCharIsLF)
1:eac0369:      {
1:eac0369:         prevCharIsLF = false;
1:eac0369:         line += (column = 1);
1:eac0369:      }
1:eac0369:      else if (prevCharIsCR)
1:eac0369:      {
1:eac0369:         prevCharIsCR = false;
1:eac0369:         if (c == '\n')
1:eac0369:         {
1:eac0369:            prevCharIsLF = true;
1:eac0369:         }
1:eac0369:         else
1:eac0369:            line += (column = 1);
1:eac0369:      }
1:eac0369: 
1:eac0369:      switch (c)
1:eac0369:      {
1:eac0369:         case '\r' :
1:eac0369:            prevCharIsCR = true;
1:eac0369:            break;
1:eac0369:         case '\n' :
1:eac0369:            prevCharIsLF = true;
1:eac0369:            break;
1:eac0369:         case '\t' :
1:eac0369:            column--;
1:eac0369:            column += (8 - (column & 07));
1:eac0369:            break;
1:eac0369:         default :
1:eac0369:            break;
1:eac0369:      }
1:eac0369: 
1:eac0369: 	 bufline[bufpos] = line;
1:eac0369: 	 bufcolumn[bufpos] = column;
1:eac0369:   }
1:eac0369: 
1:eac0369:   private int inBuf = 0;
1:eac0369:   public final char readChar() throws java.io.IOException
1:eac0369:   {
1:eac0369:      if (inBuf > 0)
1:eac0369:      {
1:eac0369:         --inBuf;
1:3bb140c:         return buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
1:eac0369:      }
1:eac0369: 
1:eac0369:      if (++bufpos == available)
1:eac0369:      {
1:eac0369:         if (available == bufsize)
1:eac0369:         {
1:eac0369:            if (tokenBegin > 2048)
1:eac0369:            {
1:eac0369:               bufpos = 0;
1:eac0369:               available = tokenBegin;
1:eac0369:            }
1:eac0369:            else if (tokenBegin < 0)
1:eac0369:               bufpos = 0;
1:eac0369:            else
1:eac0369:               ExpandBuff(false);
1:eac0369:         }
1:eac0369:         else if (available > tokenBegin)
1:eac0369:            available = bufsize;
1:eac0369:         else if ((tokenBegin - available) < 2048)
1:eac0369:            ExpandBuff(true);
1:eac0369:         else
1:eac0369:            available = tokenBegin;
1:eac0369:      }
1:eac0369: 
1:eac0369: 	 char c = ReadChar();
1:eac0369: 
1:eac0369:      UpdateLineColumn(c);
1:eac0369: 
1:eac0369: 	// The next line was added to support ability to get the input
1:eac0369: 	// between two tokens.
1:eac0369: 	charOffset[bufpos] = charCnt++;
1:eac0369: 
1:eac0369:      return (buffer[bufpos] = c);
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * @deprecated 
1:eac0369:    * @see #getEndColumn
1:eac0369:    */
1:3bb140c:   @Deprecated
1:eac0369:   public final int getColumn() {
1:eac0369:      return bufcolumn[bufpos];
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * @deprecated 
1:eac0369:    * @see #getEndLine
1:eac0369:    */
1:3bb140c:   @Deprecated
1:eac0369:   public final int getLine() {
1:eac0369:      return bufline[bufpos];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final int getEndColumn() {
1:eac0369:      return bufcolumn[bufpos];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final int getEndLine() {
1:eac0369:      return bufline[bufpos];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final int getBeginColumn() {
1:eac0369:      return bufcolumn[tokenBegin];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final int getBeginLine() {
1:eac0369:      return bufline[tokenBegin];
1:eac0369:   }
1:eac0369: 
1:eac0369:   // This method was added to support ability to get the input
1:eac0369:   // between two tokens.
1:eac0369:   public final int getBeginOffset() {
1:eac0369: 	return charOffset[tokenBegin];
1:eac0369:   }
1:eac0369: 
1:eac0369:   // This method was added to support ability to get the input
1:eac0369:   // between two tokens.
1:eac0369:   public final int getEndOffset() {
1:eac0369: 	return charOffset[bufpos];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final void backup(int amount) {
1:eac0369: 
1:eac0369:     inBuf += amount;
1:eac0369:     if ((bufpos -= amount) < 0)
1:eac0369:        bufpos += bufsize;
1:eac0369:   }
1:eac0369: 
1:eac0369:   public UCode_CharStream(java.io.Reader dstream,
1:eac0369:                  int startline, int startcolumn, int buffersize)
1:eac0369:   {
1:eac0369:     inputStream = dstream;
1:eac0369:     line = startline;
1:eac0369:     column = startcolumn - 1;
1:eac0369: 
1:eac0369:     available = bufsize = buffersize;
1:eac0369:     buffer = new char[buffersize];
1:eac0369:     nextCharBuf = new char[buffersize];
1:eac0369:     bufline = new int[buffersize];
1:eac0369:     bufcolumn = new int[buffersize];
1:eac0369: 
1:eac0369: 	// The next line was added to support ability to get the input
1:eac0369: 	// between two tokens.
1:eac0369: 	charOffset = new int[buffersize];
1:eac0369:   }
1:eac0369: 
1:eac0369:   public UCode_CharStream(java.io.Reader dstream,
1:eac0369:                                         int startline, int startcolumn)
1:eac0369:   {
1:eac0369:      this(dstream, startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369: 
1:eac0369:   public void ReInit(java.io.Reader dstream,
1:eac0369:                  int startline, int startcolumn, int buffersize)
1:eac0369:   {
1:eac0369:     inputStream = dstream;
1:eac0369:     line = startline;
1:eac0369:     column = startcolumn - 1;
1:eac0369: 
1:eac0369:     if (buffer == null || buffersize != buffer.length)
1:eac0369:     {
1:eac0369:       available = bufsize = buffersize;
1:eac0369:       buffer = new char[buffersize];
1:eac0369:       nextCharBuf = new char[buffersize];
1:eac0369:       bufline = new int[buffersize];
1:eac0369:       bufcolumn = new int[buffersize];
1:eac0369:     }
1:eac0369: 
1:eac0369: 	// The next line was added to support ability to get the input
1:eac0369: 	// between two tokens.
1:eac0369: 	inBuf = maxNextCharInd = charCnt = tokenBegin = 0;
1:eac0369: 	nextCharInd = bufpos = -1;
1:eac0369:   }
1:eac0369: 
1:eac0369:   public void ReInit(java.io.Reader dstream,
1:eac0369:                                         int startline, int startcolumn)
1:eac0369:   {
1:eac0369:      ReInit(dstream, startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:eac0369:   int startcolumn, int buffersize)
1:eac0369:   {
1:eac0369:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369: 
1:eac0369:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:eac0369:                                                            int startcolumn)
1:eac0369:   {
1:eac0369:      this(dstream, startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369: 
1:eac0369:   public void ReInit(java.io.InputStream dstream, int startline,
1:eac0369:   int startcolumn, int buffersize)
1:eac0369:   {
1:eac0369:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369:   public void ReInit(java.io.InputStream dstream, int startline,
1:eac0369:                                                            int startcolumn)
1:eac0369:   {
1:eac0369:      ReInit(dstream, startline, startcolumn, 4096);
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final String GetImage()
1:eac0369:   {
1:eac0369:      if (bufpos >= tokenBegin)
1:eac0369:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
1:eac0369:      else
1:eac0369:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
1:eac0369:                               new String(buffer, 0, bufpos + 1);
1:eac0369:   }
1:eac0369: 
1:eac0369:   public final char[] GetSuffix(int len)
1:eac0369:   {
1:eac0369:      char[] ret = new char[len];
1:eac0369: 
1:eac0369:      if ((bufpos + 1) >= len)
1:eac0369:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
1:eac0369:      else
1:eac0369:      {
1:eac0369:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
1:eac0369:                                                           len - bufpos - 1);
1:eac0369:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
1:eac0369:      }
1:eac0369: 
1:eac0369:      return ret;
1:eac0369:   }
1:eac0369: 
1:eac0369:   public void Done()
1:eac0369:   {
1:eac0369:      nextCharBuf = null;
1:eac0369:      buffer = null;
1:eac0369:      bufline = null;
1:eac0369:      bufcolumn = null;
1:eac0369: 
1:eac0369: 	// The next line was added to support ability to get the input
1:eac0369: 	// between two tokens.
1:eac0369: 	 charOffset = null;
1:eac0369:   }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * Method to adjust line and column numbers for the start of a token.<BR>
1:eac0369:    */
1:eac0369:   public void adjustBeginLineColumn(int newLine, int newCol)
1:eac0369:   {
1:eac0369:      int start = tokenBegin;
1:eac0369:      int len;
1:eac0369: 
1:eac0369:      if (bufpos >= tokenBegin)
1:eac0369:      {
1:eac0369:         len = bufpos - tokenBegin + inBuf + 1;
1:eac0369:      }
1:eac0369:      else
1:eac0369:      {
1:eac0369:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
1:eac0369:      }
1:eac0369: 
1:eac0369:      int i = 0, j = 0, k = 0;
1:3bb140c:      int columnDiff = 0;
1:eac0369: 
1:eac0369:      while (i < len &&
1:eac0369:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
1:eac0369:      {
1:eac0369:         bufline[j] = newLine;
1:3bb140c:         int nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
1:eac0369:         bufcolumn[j] = newCol + columnDiff;
1:eac0369:         columnDiff = nextColDiff;
1:eac0369:         i++;
1:eac0369:      } 
1:eac0369: 
1:eac0369:      if (i < len)
1:eac0369:      {
1:eac0369:         bufline[j] = newLine++;
1:eac0369:         bufcolumn[j] = newCol + columnDiff;
1:eac0369: 
1:eac0369:         while (i++ < len)
1:eac0369:         {
1:eac0369:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
1:eac0369:               bufline[j] = newLine++;
1:eac0369:            else
1:eac0369:               bufline[j] = newLine;
1:eac0369:         }
1:eac0369:      }
1:eac0369: 
1:eac0369:      line = bufline[j];
1:eac0369:      column = bufcolumn[j];
1:eac0369:   }
1:eac0369: 
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1:   private void ExpandBuff(boolean wrapAround)
/////////////////////////////////////////////////////////////////////////
1:   private void FillBuff() throws java.io.IOException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:   private char ReadChar() throws java.io.IOException
/////////////////////////////////////////////////////////////////////////
1:   private void UpdateLineColumn(char c)
/////////////////////////////////////////////////////////////////////////
1:         return buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
/////////////////////////////////////////////////////////////////////////
1:   @Deprecated
/////////////////////////////////////////////////////////////////////////
1:   @Deprecated
/////////////////////////////////////////////////////////////////////////
1:      int columnDiff = 0;
1:         int nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.UCode_CharStream
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
1: package org.apache.derby.impl.sql.compile;
1: 
1: /**
1:  * An implementation of interface CharStream, where the stream is assumed to
1:  * contain only Unicode characters.
1:  */
1: 
1: // NOTE: This class was modified to support the ability to get all the
1: // characters in the input stream between two tokens.  - Jeff
1: 
1: public final class UCode_CharStream implements CharStream
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1:   // The next two lines are added to support ability to get the input
1:   // between two tokens.
1:   int charCnt;
1:   int[] charOffset;
1: 
1:   public static final boolean staticFlag = false;
1:   public int bufpos = -1;
1:   int bufsize;
1:   int available;
1:   int tokenBegin;
1:   private int bufline[];
1:   private int bufcolumn[];
1: 
1:   private int column = 0;
1:   private int line = 1;
1: 
1:   private boolean prevCharIsCR = false;
1:   private boolean prevCharIsLF = false;
1: 
1:   private java.io.Reader inputStream;
1: 
1:   private char[] nextCharBuf;
1:   private char[] buffer;
1:   private int maxNextCharInd = 0;
1:   private int nextCharInd = -1;
1: 
0:   private final void ExpandBuff(boolean wrapAround)
1:   {
1:      char[] newbuffer = new char[bufsize + 2048];
1:      int newbufline[] = new int[bufsize + 2048];
1:      int newbufcolumn[] = new int[bufsize + 2048];
1: 
1: 	// The next line was added to support ability to get the input
1: 	// between two tokens.
1: 	int newcharOffset[] = new int[bufsize + 2048];
1: 
1:      try
1:      {
1:         if (wrapAround)
1:         {
1:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:            System.arraycopy(buffer, 0, newbuffer,
1:                                              bufsize - tokenBegin, bufpos);
1:            buffer = newbuffer;
1: 
1:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
1:            bufline = newbufline;
1: 
1:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
1:            bufcolumn = newbufcolumn;
1: 
1: 			// The next three lines were added to support ability to get input
1: 			// between two tokens.
1: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
1: 		   System.arraycopy(charOffset, 0, newcharOffset, bufsize - tokenBegin, bufpos);
1: 		   charOffset = newcharOffset;
1: 
1:            bufpos += (bufsize - tokenBegin);
1:         }
1:         else
1:         {
1:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:            buffer = newbuffer;
1: 
1:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:            bufline = newbufline;
1: 
1:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:            bufcolumn = newbufcolumn;
1: 
1: 			// The next two lines were added to support ability to get input
1: 			// between two tokens.
1: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
1: 		   charOffset = newcharOffset;
1: 
1:            bufpos -= tokenBegin;
1:         }
1:      }
1:      catch (Throwable t)
1:      {
1:         throw new Error(t.getMessage());
1:      }
1: 
1:      available = (bufsize += 2048);
1:      tokenBegin = 0;
1:   }
1: 
0:   private final void FillBuff() throws java.io.IOException
1:   {
1:      if (maxNextCharInd == nextCharBuf.length)
1:         maxNextCharInd = nextCharInd = 0;
1: 
1:      int i;
1:      try {
1:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
1:                                   nextCharBuf.length - maxNextCharInd)) == -1)
1:         {
1:            inputStream.close();
1:            throw new java.io.IOException();
1:         }
1:         else
1:            maxNextCharInd += i;
0:         return;
1:      }
1:      catch(java.io.IOException e) {
1:         if (bufpos != 0)
1:         {
1:            --bufpos;
1:            backup(0);
1:         }
1:         else
1:         {
1:            bufline[bufpos] = line;
1:            bufcolumn[bufpos] = column;
1:         }
1:         if (tokenBegin == -1)
1:            tokenBegin = bufpos;
1:         throw e;
1:      }
1:   }
1: 
0:   private final char ReadChar() throws java.io.IOException
1:   {
1:      if (++nextCharInd >= maxNextCharInd)
1:         FillBuff();
1: 
1: 	 return nextCharBuf[nextCharInd];
1:   }
1:      
1:   public char BeginToken() throws java.io.IOException
1:   {     
1: 	 if (inBuf > 0)
1: 	 {
1: 		--inBuf;
1: 		return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0)
1: 															: ++bufpos];
1: 	 }
1: 
1:      tokenBegin = 0;
1: 	 bufpos = -1;
1:      char c = readChar();
1: 
1:      return c;
1:   }     
1: 
0:   private final void UpdateLineColumn(char c)
1:   {
1:      column++;
1: 
1:      if (prevCharIsLF)
1:      {
1:         prevCharIsLF = false;
1:         line += (column = 1);
1:      }
1:      else if (prevCharIsCR)
1:      {
1:         prevCharIsCR = false;
1:         if (c == '\n')
1:         {
1:            prevCharIsLF = true;
1:         }
1:         else
1:            line += (column = 1);
1:      }
1: 
1:      switch (c)
1:      {
1:         case '\r' :
1:            prevCharIsCR = true;
1:            break;
1:         case '\n' :
1:            prevCharIsLF = true;
1:            break;
1:         case '\t' :
1:            column--;
1:            column += (8 - (column & 07));
1:            break;
1:         default :
1:            break;
1:      }
1: 
1: 	 bufline[bufpos] = line;
1: 	 bufcolumn[bufpos] = column;
1:   }
1: 
1:   private int inBuf = 0;
1:   public final char readChar() throws java.io.IOException
1:   {
1:      if (inBuf > 0)
1:      {
1:         --inBuf;
0:         return (char)buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
1:      }
1: 
1:      if (++bufpos == available)
1:      {
1:         if (available == bufsize)
1:         {
1:            if (tokenBegin > 2048)
1:            {
1:               bufpos = 0;
1:               available = tokenBegin;
1:            }
1:            else if (tokenBegin < 0)
1:               bufpos = 0;
1:            else
1:               ExpandBuff(false);
1:         }
1:         else if (available > tokenBegin)
1:            available = bufsize;
1:         else if ((tokenBegin - available) < 2048)
1:            ExpandBuff(true);
1:         else
1:            available = tokenBegin;
1:      }
1: 
1: 	 char c = ReadChar();
1: 
1:      UpdateLineColumn(c);
1: 
1: 	// The next line was added to support ability to get the input
1: 	// between two tokens.
1: 	charOffset[bufpos] = charCnt++;
1: 
1:      return (buffer[bufpos] = c);
1:   }
1: 
1:   /**
1:    * @deprecated 
1:    * @see #getEndColumn
1:    */
1: 
1:   public final int getColumn() {
1:      return bufcolumn[bufpos];
1:   }
1: 
1:   /**
1:    * @deprecated 
1:    * @see #getEndLine
1:    */
1: 
1:   public final int getLine() {
1:      return bufline[bufpos];
1:   }
1: 
1:   public final int getEndColumn() {
1:      return bufcolumn[bufpos];
1:   }
1: 
1:   public final int getEndLine() {
1:      return bufline[bufpos];
1:   }
1: 
1:   public final int getBeginColumn() {
1:      return bufcolumn[tokenBegin];
1:   }
1: 
1:   public final int getBeginLine() {
1:      return bufline[tokenBegin];
1:   }
1: 
1:   // This method was added to support ability to get the input
1:   // between two tokens.
1:   public final int getBeginOffset() {
1: 	return charOffset[tokenBegin];
1:   }
1: 
1:   // This method was added to support ability to get the input
1:   // between two tokens.
1:   public final int getEndOffset() {
1: 	return charOffset[bufpos];
1:   }
1: 
1:   public final void backup(int amount) {
1: 
1:     inBuf += amount;
1:     if ((bufpos -= amount) < 0)
1:        bufpos += bufsize;
1:   }
1: 
1:   public UCode_CharStream(java.io.Reader dstream,
1:                  int startline, int startcolumn, int buffersize)
1:   {
1:     inputStream = dstream;
1:     line = startline;
1:     column = startcolumn - 1;
1: 
1:     available = bufsize = buffersize;
1:     buffer = new char[buffersize];
1:     nextCharBuf = new char[buffersize];
1:     bufline = new int[buffersize];
1:     bufcolumn = new int[buffersize];
1: 
1: 	// The next line was added to support ability to get the input
1: 	// between two tokens.
1: 	charOffset = new int[buffersize];
1:   }
1: 
1:   public UCode_CharStream(java.io.Reader dstream,
1:                                         int startline, int startcolumn)
1:   {
1:      this(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public void ReInit(java.io.Reader dstream,
1:                  int startline, int startcolumn, int buffersize)
1:   {
1:     inputStream = dstream;
1:     line = startline;
1:     column = startcolumn - 1;
1: 
1:     if (buffer == null || buffersize != buffer.length)
1:     {
1:       available = bufsize = buffersize;
1:       buffer = new char[buffersize];
1:       nextCharBuf = new char[buffersize];
1:       bufline = new int[buffersize];
1:       bufcolumn = new int[buffersize];
1:     }
1: 
1: 	// The next line was added to support ability to get the input
1: 	// between two tokens.
1: 	inBuf = maxNextCharInd = charCnt = tokenBegin = 0;
1: 	nextCharInd = bufpos = -1;
1:   }
1: 
1:   public void ReInit(java.io.Reader dstream,
1:                                         int startline, int startcolumn)
1:   {
1:      ReInit(dstream, startline, startcolumn, 4096);
1:   }
1:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:   int startcolumn, int buffersize)
1:   {
1:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:   }
1: 
1:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:                                                            int startcolumn)
1:   {
1:      this(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public void ReInit(java.io.InputStream dstream, int startline,
1:   int startcolumn, int buffersize)
1:   {
1:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:   }
1:   public void ReInit(java.io.InputStream dstream, int startline,
1:                                                            int startcolumn)
1:   {
1:      ReInit(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public final String GetImage()
1:   {
1:      if (bufpos >= tokenBegin)
1:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
1:      else
1:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
1:                               new String(buffer, 0, bufpos + 1);
1:   }
1: 
1:   public final char[] GetSuffix(int len)
1:   {
1:      char[] ret = new char[len];
1: 
1:      if ((bufpos + 1) >= len)
1:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
1:      else
1:      {
1:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
1:                                                           len - bufpos - 1);
1:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
1:      }
1: 
1:      return ret;
1:   }
1: 
1:   public void Done()
1:   {
1:      nextCharBuf = null;
1:      buffer = null;
1:      bufline = null;
1:      bufcolumn = null;
1: 
1: 	// The next line was added to support ability to get the input
1: 	// between two tokens.
1: 	 charOffset = null;
1:   }
1: 
1:   /**
1:    * Method to adjust line and column numbers for the start of a token.<BR>
1:    */
1:   public void adjustBeginLineColumn(int newLine, int newCol)
1:   {
1:      int start = tokenBegin;
1:      int len;
1: 
1:      if (bufpos >= tokenBegin)
1:      {
1:         len = bufpos - tokenBegin + inBuf + 1;
1:      }
1:      else
1:      {
1:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
1:      }
1: 
1:      int i = 0, j = 0, k = 0;
0:      int nextColDiff = 0, columnDiff = 0;
1: 
1:      while (i < len &&
1:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
1:      {
1:         bufline[j] = newLine;
0:         nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
1:         bufcolumn[j] = newCol + columnDiff;
1:         columnDiff = nextColDiff;
1:         i++;
1:      } 
1: 
1:      if (i < len)
1:      {
1:         bufline[j] = newLine++;
1:         bufcolumn[j] = newCol + columnDiff;
1: 
1:         while (i++ < len)
1:         {
1:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
1:               bufline[j] = newLine++;
1:            else
1:               bufline[j] = newLine;
1:         }
1:      }
1: 
1:      line = bufline[j];
1:      column = bufcolumn[j];
1:   }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
0: package org.apache.derby.impl.sql.compile;
0: 
0: /**
0:  * An implementation of interface CharStream, where the stream is assumed to
0:  * contain only Unicode characters.
0:  */
0: 
0: // NOTE: This class was modified to support the ability to get all the
0: // characters in the input stream between two tokens.  - Jeff
0: 
0: public final class UCode_CharStream implements CharStream
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:   // The next two lines are added to support ability to get the input
0:   // between two tokens.
0:   int charCnt;
0:   int[] charOffset;
0: 
0:   public static final boolean staticFlag = false;
0:   public int bufpos = -1;
0:   int bufsize;
0:   int available;
0:   int tokenBegin;
0:   private int bufline[];
0:   private int bufcolumn[];
0: 
0:   private int column = 0;
0:   private int line = 1;
0: 
0:   private boolean prevCharIsCR = false;
0:   private boolean prevCharIsLF = false;
0: 
0:   private java.io.Reader inputStream;
0: 
0:   private char[] nextCharBuf;
0:   private char[] buffer;
0:   private int maxNextCharInd = 0;
0:   private int nextCharInd = -1;
0: 
0:   private final void ExpandBuff(boolean wrapAround)
0:   {
0:      char[] newbuffer = new char[bufsize + 2048];
0:      int newbufline[] = new int[bufsize + 2048];
0:      int newbufcolumn[] = new int[bufsize + 2048];
0: 
0: 	// The next line was added to support ability to get the input
0: 	// between two tokens.
0: 	int newcharOffset[] = new int[bufsize + 2048];
0: 
0:      try
0:      {
0:         if (wrapAround)
0:         {
0:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
0:            System.arraycopy(buffer, 0, newbuffer,
0:                                              bufsize - tokenBegin, bufpos);
0:            buffer = newbuffer;
0: 
0:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
0:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
0:            bufline = newbufline;
0: 
0:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
0:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
0:            bufcolumn = newbufcolumn;
0: 
0: 			// The next three lines were added to support ability to get input
0: 			// between two tokens.
0: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
0: 		   System.arraycopy(charOffset, 0, newcharOffset, bufsize - tokenBegin, bufpos);
0: 		   charOffset = newcharOffset;
0: 
0:            bufpos += (bufsize - tokenBegin);
0:         }
0:         else
0:         {
0:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
0:            buffer = newbuffer;
0: 
0:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
0:            bufline = newbufline;
0: 
0:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
0:            bufcolumn = newbufcolumn;
0: 
0: 			// The next two lines were added to support ability to get input
0: 			// between two tokens.
0: 		   System.arraycopy(charOffset, tokenBegin, newcharOffset, 0, bufsize - tokenBegin);
0: 		   charOffset = newcharOffset;
0: 
0:            bufpos -= tokenBegin;
0:         }
0:      }
0:      catch (Throwable t)
0:      {
0:         throw new Error(t.getMessage());
0:      }
0: 
0:      available = (bufsize += 2048);
0:      tokenBegin = 0;
0:   }
0: 
0:   private final void FillBuff() throws java.io.IOException
0:   {
0:      if (maxNextCharInd == nextCharBuf.length)
0:         maxNextCharInd = nextCharInd = 0;
0: 
0:      int i;
0:      try {
0:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
0:                                   nextCharBuf.length - maxNextCharInd)) == -1)
0:         {
0:            inputStream.close();
0:            throw new java.io.IOException();
0:         }
0:         else
0:            maxNextCharInd += i;
0:         return;
0:      }
0:      catch(java.io.IOException e) {
0:         if (bufpos != 0)
0:         {
0:            --bufpos;
0:            backup(0);
0:         }
0:         else
0:         {
0:            bufline[bufpos] = line;
0:            bufcolumn[bufpos] = column;
0:         }
0:         if (tokenBegin == -1)
0:            tokenBegin = bufpos;
0:         throw e;
0:      }
0:   }
0: 
0:   private final char ReadChar() throws java.io.IOException
0:   {
0:      if (++nextCharInd >= maxNextCharInd)
0:         FillBuff();
0: 
0: 	 return nextCharBuf[nextCharInd];
0:   }
0:      
0:   public char BeginToken() throws java.io.IOException
0:   {     
0: 	 if (inBuf > 0)
0: 	 {
0: 		--inBuf;
0: 		return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0)
0: 															: ++bufpos];
0: 	 }
0: 
0:      tokenBegin = 0;
0: 	 bufpos = -1;
0:      char c = readChar();
0: 
0:      return c;
0:   }     
0: 
0:   private final void UpdateLineColumn(char c)
0:   {
0:      column++;
0: 
0:      if (prevCharIsLF)
0:      {
0:         prevCharIsLF = false;
0:         line += (column = 1);
0:      }
0:      else if (prevCharIsCR)
0:      {
0:         prevCharIsCR = false;
0:         if (c == '\n')
0:         {
0:            prevCharIsLF = true;
0:         }
0:         else
0:            line += (column = 1);
0:      }
0: 
0:      switch (c)
0:      {
0:         case '\r' :
0:            prevCharIsCR = true;
0:            break;
0:         case '\n' :
0:            prevCharIsLF = true;
0:            break;
0:         case '\t' :
0:            column--;
0:            column += (8 - (column & 07));
0:            break;
0:         default :
0:            break;
0:      }
0: 
0: 	 bufline[bufpos] = line;
0: 	 bufcolumn[bufpos] = column;
0:   }
0: 
0:   private int inBuf = 0;
0:   public final char readChar() throws java.io.IOException
0:   {
0:      if (inBuf > 0)
0:      {
0:         --inBuf;
0:         return (char)buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
0:      }
0: 
0:      if (++bufpos == available)
0:      {
0:         if (available == bufsize)
0:         {
0:            if (tokenBegin > 2048)
0:            {
0:               bufpos = 0;
0:               available = tokenBegin;
0:            }
0:            else if (tokenBegin < 0)
0:               bufpos = 0;
0:            else
0:               ExpandBuff(false);
0:         }
0:         else if (available > tokenBegin)
0:            available = bufsize;
0:         else if ((tokenBegin - available) < 2048)
0:            ExpandBuff(true);
0:         else
0:            available = tokenBegin;
0:      }
0: 
0: 	 char c = ReadChar();
0: 
0:      UpdateLineColumn(c);
0: 
0: 	// The next line was added to support ability to get the input
0: 	// between two tokens.
0: 	charOffset[bufpos] = charCnt++;
0: 
0:      return (buffer[bufpos] = c);
0:   }
0: 
0:   /**
0:    * @deprecated 
0:    * @see #getEndColumn
0:    */
0: 
0:   public final int getColumn() {
0:      return bufcolumn[bufpos];
0:   }
0: 
0:   /**
0:    * @deprecated 
0:    * @see #getEndLine
0:    */
0: 
0:   public final int getLine() {
0:      return bufline[bufpos];
0:   }
0: 
0:   public final int getEndColumn() {
0:      return bufcolumn[bufpos];
0:   }
0: 
0:   public final int getEndLine() {
0:      return bufline[bufpos];
0:   }
0: 
0:   public final int getBeginColumn() {
0:      return bufcolumn[tokenBegin];
0:   }
0: 
0:   public final int getBeginLine() {
0:      return bufline[tokenBegin];
0:   }
0: 
0:   // This method was added to support ability to get the input
0:   // between two tokens.
0:   public final int getBeginOffset() {
0: 	return charOffset[tokenBegin];
0:   }
0: 
0:   // This method was added to support ability to get the input
0:   // between two tokens.
0:   public final int getEndOffset() {
0: 	return charOffset[bufpos];
0:   }
0: 
0:   public final void backup(int amount) {
0: 
0:     inBuf += amount;
0:     if ((bufpos -= amount) < 0)
0:        bufpos += bufsize;
0:   }
0: 
0:   public UCode_CharStream(java.io.Reader dstream,
0:                  int startline, int startcolumn, int buffersize)
0:   {
0:     inputStream = dstream;
0:     line = startline;
0:     column = startcolumn - 1;
0: 
0:     available = bufsize = buffersize;
0:     buffer = new char[buffersize];
0:     nextCharBuf = new char[buffersize];
0:     bufline = new int[buffersize];
0:     bufcolumn = new int[buffersize];
0: 
0: 	// The next line was added to support ability to get the input
0: 	// between two tokens.
0: 	charOffset = new int[buffersize];
0:   }
0: 
0:   public UCode_CharStream(java.io.Reader dstream,
0:                                         int startline, int startcolumn)
0:   {
0:      this(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public void ReInit(java.io.Reader dstream,
0:                  int startline, int startcolumn, int buffersize)
0:   {
0:     inputStream = dstream;
0:     line = startline;
0:     column = startcolumn - 1;
0: 
0:     if (buffer == null || buffersize != buffer.length)
0:     {
0:       available = bufsize = buffersize;
0:       buffer = new char[buffersize];
0:       nextCharBuf = new char[buffersize];
0:       bufline = new int[buffersize];
0:       bufcolumn = new int[buffersize];
0:     }
0: 
0: 	// The next line was added to support ability to get the input
0: 	// between two tokens.
0: 	inBuf = maxNextCharInd = charCnt = tokenBegin = 0;
0: 	nextCharInd = bufpos = -1;
0:   }
0: 
0:   public void ReInit(java.io.Reader dstream,
0:                                         int startline, int startcolumn)
0:   {
0:      ReInit(dstream, startline, startcolumn, 4096);
0:   }
0:   public UCode_CharStream(java.io.InputStream dstream, int startline,
0:   int startcolumn, int buffersize)
0:   {
0:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
0:   }
0: 
0:   public UCode_CharStream(java.io.InputStream dstream, int startline,
0:                                                            int startcolumn)
0:   {
0:      this(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public void ReInit(java.io.InputStream dstream, int startline,
0:   int startcolumn, int buffersize)
0:   {
0:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
0:   }
0:   public void ReInit(java.io.InputStream dstream, int startline,
0:                                                            int startcolumn)
0:   {
0:      ReInit(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public final String GetImage()
0:   {
0:      if (bufpos >= tokenBegin)
0:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
0:      else
0:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
0:                               new String(buffer, 0, bufpos + 1);
0:   }
0: 
0:   public final char[] GetSuffix(int len)
0:   {
0:      char[] ret = new char[len];
0: 
0:      if ((bufpos + 1) >= len)
0:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
0:      else
0:      {
0:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
0:                                                           len - bufpos - 1);
0:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
0:      }
0: 
0:      return ret;
0:   }
0: 
0:   public void Done()
0:   {
0:      nextCharBuf = null;
0:      buffer = null;
0:      bufline = null;
0:      bufcolumn = null;
0: 
0: 	// The next line was added to support ability to get the input
0: 	// between two tokens.
0: 	 charOffset = null;
0:   }
0: 
0:   /**
0:    * Method to adjust line and column numbers for the start of a token.<BR>
0:    */
0:   public void adjustBeginLineColumn(int newLine, int newCol)
0:   {
0:      int start = tokenBegin;
0:      int len;
0: 
0:      if (bufpos >= tokenBegin)
0:      {
0:         len = bufpos - tokenBegin + inBuf + 1;
0:      }
0:      else
0:      {
0:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
0:      }
0: 
0:      int i = 0, j = 0, k = 0;
0:      int nextColDiff = 0, columnDiff = 0;
0: 
0:      while (i < len &&
0:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
0:      {
0:         bufline[j] = newLine;
0:         nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
0:         bufcolumn[j] = newCol + columnDiff;
0:         columnDiff = nextColDiff;
0:         i++;
0:      } 
0: 
0:      if (i < len)
0:      {
0:         bufline[j] = newLine++;
0:         bufcolumn[j] = newCol + columnDiff;
0: 
0:         while (i++ < len)
0:         {
0:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
0:               bufline[j] = newLine++;
0:            else
0:               bufline[j] = newLine;
0:         }
0:      }
0: 
0:      line = bufline[j];
0:      column = bufcolumn[j];
0:   }
0: 
0: }
============================================================================