7:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedPreparedStatement
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
31:eac0369: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.VariableSizeDataValue;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.PreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:c56eceb: import org.apache.derby.iapi.types.RawToBinaryFormatStream;
1:19f33c6: import org.apache.derby.iapi.types.ReaderToUTF8Stream;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:10608cf: import java.math.BigDecimal;
1:10608cf: import java.math.BigInteger;
1:eac0369: import java.util.Calendar;
1:eac0369: import java.util.Vector;
1:eac0369: 
1:eac0369: /*
1:eac0369:  We would import these, but have name-overlap
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.ResultSet;
1:eac0369: */
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Date;
1:a0118e1: import java.sql.Statement;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: import java.sql.Clob;
1:eac0369: import java.sql.Blob;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.Reader;
1:b5f2776: import java.sql.Array;
1:b5f2776: import java.sql.NClob;
1:b5f2776: import java.sql.ParameterMetaData;
1:b5f2776: import java.sql.Ref;
1:b5f2776: import java.sql.RowId;
1:b5f2776: import java.sql.SQLXML;
1:eac0369: import java.sql.Types;
1:eac0369: 
1:448ecb0: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
1:aadfd42: import org.apache.derby.iapi.jdbc.EnginePreparedStatement;
1:e8fb6d6: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:8f75194: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:7af6726: import org.apache.derby.iapi.types.StringDataValue;
1:3a6f4cf: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:242c9bd: /**
1:eac0369:  * EmbedPreparedStatement is a local JDBC statement.
1:b5f2776:  * It supports JDBC 4.1.
1:eac0369:  */
1:b5f2776: public class EmbedPreparedStatement extends EmbedStatement
1:aadfd42: 	implements EnginePreparedStatement
11:eac0369: {
1:eac0369: 
1:eac0369: 	//Moving jdbc2.0 batch related code in this class because callableStatement in jdbc 20 needs
1:eac0369: 	//this code too and it doesn't derive from prepared statement in jdbc 20 in our implementation.
1:eac0369: 
1:eac0369: 	protected ResultSetMetaData rMetaData;
1:eac0369: 	//bug 4579-If the prepared statement was revalidated after doing getMetaData(), we
1:eac0369: 	//should get the metadata info again on next getMetaData(). We store the generated
1:eac0369: 	//class name in following variable during getMetaData() call. If it differs from the
1:eac0369: 	//current generated class name, then that indicates a refetch of metadata is required.
1:eac0369: 	private String			gcDuringGetMetaData;
1:eac0369: 
1:eac0369: 	protected PreparedStatement	preparedStatement;
1:eac0369: 	private Activation			activation;
1:8f75194:     /**
1:d92fa8c:      * Tells which header format to use when writing CLOBs into the store.
1:8f75194:      * <p>
1:d92fa8c:      * This is lazily set if we need it, and there are currently only two
1:d92fa8c:      * valid header formats to choose between.
1:d92fa8c:      * @see #usePreTenFiveHdrFormat()
1:8f75194:      */
1:d92fa8c:     private Boolean usePreTenFiveHdrFormat;
1:448ecb0:         
1:448ecb0:         private BrokeredConnectionControl bcc=null;
1:eac0369: 
1:dfce41f: 	/**
1:eac0369: 		Constructor assumes caller will setup context stack
1:eac0369: 		and restore it.
1:eac0369: 	 */
1:eac0369: 	public EmbedPreparedStatement (EmbedConnection conn, String sql, boolean forMetaData,
1:eac0369: 									  int resultSetType, int resultSetConcurrency,
1:eac0369: 									  int resultSetHoldability,
1:eac0369: 									  int autoGeneratedKeys,
1:eac0369: 									  int[] columnIndexes,
1:eac0369: 									  String[] columnNames)
4:eac0369: 		throws SQLException {
1:eac0369: 
1:eac0369: 		super(conn, forMetaData, resultSetType, resultSetConcurrency, resultSetHoldability);
1:7eed914: 		// PreparedStatement is poolable by default
1:7eed914: 		isPoolable = true;
1:eac0369: 
1:eac0369: 		// if the sql string is null, raise an error
1:eac0369: 		if (sql == null)
1:eac0369:   			throw newSQLException(SQLState.NULL_SQL_TEXT);
1:eac0369: 
1:eac0369: 			// set up the SQLText in EmbedStatement
1:eac0369: 			SQLText = sql;
1:eac0369: 
1:242c9bd: 			try {
1:5087be8: 			    preparedStatement = lcc.prepareInternalStatement
1:1e8a20f: 				(lcc.getDefaultSchema(), sql,
1:1e8a20f:                         resultSetConcurrency == java.sql.ResultSet.CONCUR_READ_ONLY,
1:1e8a20f:                         forMetaData);
1:4dbb0ff: 			    
1:72cc553: 			    addWarning(preparedStatement.getCompileTimeWarnings());
1:eac0369: 
1:1e8a20f: 			    activation = preparedStatement.getActivation(lcc,
1:1e8a20f:                         resultSetType == java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE);
1:eac0369: 
1:eac0369: 				checkRequiresCallableStatement(activation);
1:eac0369: 
1:eac0369: 			//bug 4838 - save the auto-generated key information in activation. keeping this
1:aa302c3: 			//information in lcc will not work as it can be tampered by a nested transaction
1:a0118e1:   				if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS)
1:eac0369:   					activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1:eac0369: 
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1:3a6f4cf:             } catch (Throwable t) {
1:3a6f4cf:                 throw handleException(t);
1:3a6f4cf:             }
1:054fa3a: 
25:eac0369: 	}
1:3a6f4cf: 
1:10608cf: 	/**
1:eac0369: 		JDBC states that a Statement is closed when garbage collected.
1:eac0369: 
1:eac0369: 		@exception Throwable Allows any exception to be thrown during finalize
1:10608cf: 	*/
1:eac0369: 	protected void finalize() throws Throwable {
1:eac0369: 		super.finalize();
1:eac0369: 
1:10608cf: 		/*
1:eac0369: 		** We mark the activation as not being used and
1:eac0369: 	 	** that is it.  We rely on the connection to sweep
1:eac0369: 		** through the activations to find the ones that
1:eac0369: 		** aren't in use, and to close them.  We cannot
1:eac0369: 	 	** do a activation.close() here because there are
1:eac0369: 		** synchronized methods under close that cannot
1:eac0369: 		** be called during finalization.
1:eac0369: 		*/
1:eac0369: 		if (activation != null) 
1:eac0369: 		{
1:eac0369: 			activation.markUnused();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:448ecb0: 	/*
1:eac0369: 	 * Statement interface
1:eac0369: 		we override all Statement methods that take a SQL
1:eac0369: 		string as they must thrown an exception in a PreparedStatement.
1:eac0369: 		See the JDBC 3.0 spec.
1:eac0369: 	 */
1:eac0369: 	public final boolean execute(String sql) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String)");
1:eac0369: 	}
1:eac0369: 	public final boolean execute(String sql, int autoGenKeys) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int)");
1:eac0369: 	}
1:eac0369: 	public final boolean execute(String sql, int[] columnIndexes) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int[])");
1:eac0369: 	}
1:eac0369: 	public final boolean execute(String sql, String[] columnNames) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, String[])");
1:eac0369: 	}
1:eac0369: 	public final java.sql.ResultSet executeQuery(String sql) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeQuery(String)");
1:eac0369: 	}
1:eac0369: 	public final int executeUpdate(String sql) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String)");
1:eac0369: 	}
1:eac0369: 	public final int executeUpdate(String sql, int autoGenKeys) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int)");
1:eac0369: 	}
1:eac0369: 	public final int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int[])");
1:eac0369: 	}
1:eac0369: 	public final int executeUpdate(String sql, String[] columnNames) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, String[])");
1:eac0369: 	}
1:eac0369: 	public final void addBatch(String sql) throws SQLException {
1:eac0369: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "addBatch(String)");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:054fa3a: 	/**
1:712b41b: 	 * Additional close to close our activation.
1:712b41b: 	 * In the case that a XAConnection is involved in the creation of this
1:712b41b: 	 * PreparedStatement for e.g in the following case
1:242c9bd: 	 *
1:712b41b: 	 *      <code>
1:712b41b: 	 *      XAConnection xaconn = xadatasource.getXAConnection();//where xadatasource is an object of XADataSource
1:712b41b: 	 *      Connection conn = xaconnection.getConnection();
1:712b41b: 	 *      PreparedStatement ps = conn.preparedStatement("values 1");
1:712b41b: 	 *      </code>
1:054fa3a: 	 *
1:712b41b: 	 * In the above case the PreparedStatement will actually be a 
1:863daa0:      * BrokeredPreparedStatement object. Hence when we call
1:712b41b: 	 * bcc.onStatementClose and pass the PreparedStatement that caused it
1:712b41b: 	 * applicationStatement will be the appropriate choice since it will 
1:712b41b: 	 * contain the appropriate instance of PreparedStatement in each case
1:c511410: 	 *
1:712b41b: 	 * @throws SQLException upon failure
1:712b41b: 	 *
1:054fa3a: 	 */
1:0c13195: 	void closeActions() throws SQLException {
1:054fa3a: 
1:712b41b: 		if (bcc!=null) {
1:712b41b: 			java.sql.PreparedStatement ps_app = 
1:712b41b: 				(java.sql.PreparedStatement)applicationStatement;
1:712b41b: 			bcc.onStatementClose(ps_app);
1:712b41b: 		}
1:eac0369: 		//we release the resource for preparedStatement
1:eac0369: 		preparedStatement = null;
1:eac0369: 
1:eac0369: 		try{
1:eac0369: 			setupContextStack();
1:eac0369: 		} catch (SQLException se) {
1:eac0369: 			//we may have already committed the transaction in which case
1:eac0369: 			//setupContextStack will fail, the close should just return
4:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		try
1:75fbaa9: 		{
1:eac0369: 		    activation.close();
1:eac0369: 			activation = null;
1:3a6f4cf: 
1:3a6f4cf:             InterruptStatus.restoreIntrFlagIfSeen();
1:eac0369: 		} catch (Throwable t)
1:eac0369: 		{
2:eac0369: 			throw handleException(t);
1:eac0369: 		} finally {
1:eac0369: 		    restoreContextStack();
1:eac0369: 		}
1:eac0369: 	}
1:75fbaa9: 	
1:448ecb0: 	/*
1:eac0369: 	 * PreparedStatement interface; we have inherited from
1:eac0369: 	 * EmbedStatement to get the Statement interface for
1:eac0369: 	 * EmbedPreparedStatement (needed by PreparedStatement)
1:eac0369: 	 * These are the JDBC interface comments, so we know
1:eac0369: 	 * what to do.
1:75fbaa9: 	 */
1:75fbaa9: 
1:c511410: 	/**
1:eac0369:      * A prepared SQL query is executed and its ResultSet is returned.
1:712b41b:      *
1:eac0369:      * @return a ResultSet that contains the data produced by the
1:eac0369:      * query; never null
2:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 	public final java.sql.ResultSet executeQuery() throws SQLException {
1:448ecb0:             try {
1:448ecb0:                 executeStatement(activation, true, false);
1:448ecb0:             } catch(SQLException sqle) {
1:448ecb0:                 checkStatementValidity(sqle);
1:448ecb0:             }
1:448ecb0:             
1:448ecb0:             if (SanityManager.DEBUG) {
1:448ecb0:                 if (results == null)
1:448ecb0:                     SanityManager.THROWASSERT("no results returned on executeQuery()");
1:448ecb0:             }
1:448ecb0:             
1:448ecb0:             return results;
1:448ecb0:         }
1:75fbaa9: 
1:c511410:     /**
1:eac0369:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:eac0369:      * SQL statements that return nothing such as SQL DDL statements
1:eac0369:      * can be executed.
1:712b41b:      *
1:eac0369:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:eac0369:      * for SQL statements that return nothing
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:448ecb0:         public final int executeUpdate() throws SQLException {
1:20b2fd9:             return (int) executeLargeUpdate();
1:20b2fd9:         }
1:20b2fd9: 
1:20b2fd9:     /**
1:20b2fd9:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:20b2fd9:      * SQL statements that return nothing such as SQL DDL statements
1:20b2fd9:      * can be executed. For use with
1:20b2fd9:      * statements which may touch more than Integer.MAX_VALUE rows.
1:20b2fd9:      */
1:20b2fd9:         public final long executeLargeUpdate() throws SQLException {
1:448ecb0:             try {
1:448ecb0:                 executeStatement(activation, false, true);
1:448ecb0:             } catch(SQLException sqle) {
1:448ecb0:                 checkStatementValidity(sqle);
1:448ecb0:             }
1:20b2fd9:             return updateCount;
1:448ecb0:         }
1:eac0369: 
5:eac0369:     /**
1:eac0369:      * Set a parameter to SQL NULL.
1:712b41b:      *
1:eac0369:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:712b41b:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param sqlType SQL type code defined by java.sql.Types
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setNull(int parameterIndex, int sqlType) throws SQLException {
1:eac0369: 
1:4c2fc4a: 		Util.checkForSupportedDataType(sqlType);
1:242c9bd: 		checkStatus();
1:eac0369: 
5:eac0369: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:eac0369: 		
1:eac0369: 		if (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {
1:eac0369: 
1:eac0369: 			throw dataTypeConversion(parameterIndex, Util.typeName(sqlType));
1:eac0369: 		}
1:eac0369: 		
5:eac0369: 		try {
3:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setToNull();
2:eac0369: 		} catch (StandardException t) {
3:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:75fbaa9: 
1:eac0369: 	}
1:75fbaa9: 
1:75fbaa9:     /**
1:eac0369:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
1:eac0369: 	 * the driver converts this to a SQL BIT value when it sends it to the
1:eac0369: 	 * database. But we don't have to do this, since the database engine
1:eac0369: 	 * supports a boolean type.
1:712b41b:      *
2:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
2:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1:eac0369: 		
1:050b616: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
2:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (StandardException t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java byte value.  The driver converts this
1:eac0369:      * to a SQL TINYINT value when it sends it to the database.
1:8f75194:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setByte(int parameterIndex, byte x) throws SQLException {
1:eac0369: 
1:050b616: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
3:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java short value.  The driver converts this
1:eac0369:      * to a SQL SMALLINT value when it sends it to the database.
9:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setShort(int parameterIndex, short x) throws SQLException {
1:eac0369: 
1:050b616: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java int value.  The driver converts this
1:eac0369:      * to a SQL INTEGER value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setInt(int parameterIndex, int x) throws SQLException {
1:e334847: 		checkStatus();
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java long value.  The driver converts this
1:eac0369:      * to a SQL BIGINT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setLong(int parameterIndex, long x) throws SQLException {
13:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:10608cf:      * Set a parameter to a java.lang.BigDecimal value.  
1:10608cf:      * The driver converts this to a SQL NUMERIC value when
1:10608cf:      * it sends it to the database.
1:10608cf:      *
1:10608cf:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:10608cf:      * @param x the parameter value
1:10608cf: 	 * @exception SQLException thrown on failure.
1:10608cf:      */
1:10608cf:     public final void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
1:10608cf: 		checkStatus();
1:10608cf: 		try {
1:10608cf: 			/* JDBC is one-based, DBMS is zero-based */
1:10608cf: 			getParms().getParameterForSet(parameterIndex - 1).setBigDecimal(x);
1:10608cf: 
1:10608cf: 		} catch (Throwable t) {
1:10608cf: 			throw EmbedResultSet.noStateChangeException(t);
1:10608cf: 		}
1:10608cf: 	}
1:10608cf: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java float value.  The driver converts this
1:eac0369:      * to a SQL FLOAT value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setFloat(int parameterIndex, float x) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java double value.  The driver converts this
1:eac0369:      * to a SQL DOUBLE value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setDouble(int parameterIndex, double x) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java String value.  The driver converts this
1:eac0369:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
1:eac0369:      * size relative to the driver's limits on VARCHARs) when it sends
1:eac0369:      * it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setString(int parameterIndex, String x) throws SQLException {
1:eac0369: 		checkStatus();		
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a Java array of bytes.  The driver converts
1:eac0369:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
1:eac0369:      * argument's size relative to the driver's limits on VARBINARYs)
1:eac0369:      * when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setBytes(int parameterIndex, byte x[]) throws SQLException {
1:eac0369: 		checkStatus();
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:eac0369:      * to a SQL DATE value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setDate(int parameterIndex, Date x) throws SQLException {
1:eac0369:         setDate( parameterIndex, x, (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:eac0369:      * to a SQL TIME value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setTime(int parameterIndex, Time x) throws SQLException {
1:eac0369:         setTime( parameterIndex, x, (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:eac0369:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:eac0369:      * database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void setTimestamp(int parameterIndex, Timestamp x)
1:eac0369: 	    throws SQLException {
1:eac0369:         setTimestamp( parameterIndex, x, (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:c511410: 	 * We do this inefficiently and read it all in here. The target type
1:c511410: 	 * is assumed to be a String.
1:c511410:      * 
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the ASCII parameter value
1:c511410:      * @param length the number of bytes in the stream 
1:c511410: 	 * @exception SQLException thrown on failure.
1:c511410:      */
1:c511410:     public final void setAsciiStream(int parameterIndex, InputStream x, long length)
1:eac0369: 	    throws SQLException {
1:d45f7d3:         checkAsciiStreamConditions(parameterIndex);
1:eac0369: 		java.io.Reader r = null;
1:c511410: 
1:eac0369: 		if (x != null)
1:eac0369: 		{
1:eac0369: 			// Use ISO-8859-1 and not US-ASCII as JDBC seems to define
1:eac0369: 			// ASCII as 8 bits. US-ASCII is 7.
1:eac0369: 			try {
1:eac0369: 				r = new java.io.InputStreamReader(x, "ISO-8859-1");
1:eac0369: 			} catch (java.io.UnsupportedEncodingException uee) {
1:eac0369: 				throw new SQLException(uee.getMessage());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:242c9bd:         setCharacterStreamInternal(parameterIndex, r, false, length);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * We do this inefficiently and read it all in here. The target type
1:eac0369:      * is assumed to be a String.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the java input stream which contains the ASCII parameter value
1:eac0369:      * @param length the number of bytes in the stream
1:eac0369:      * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369: 
1:c511410:     public final void setAsciiStream(int parameterIndex, InputStream x, int length)
1:c511410:     throws SQLException {
1:c511410:         setAsciiStream(parameterIndex,x,(long)length);
1:c511410:     }
1:c511410: 
1:c511410: 
1:c511410:     /**
1:eac0369: 		Deprecated in JDBC 3.0
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the java input stream which contains the
1:eac0369:      * UNICODE parameter value
1:eac0369:      * @param length the number of bytes in the stream
1:eac0369: 	 * @exception SQLException thrown on failure.
1:e24d8ef:      * @deprecated
1:eac0369:      */
1:eac0369:     public void setUnicodeStream(int parameterIndex, InputStream x, int length)
4:eac0369: 	    throws SQLException
1:eac0369: 	{
1:eac0369: 		throw Util.notImplemented("setUnicodeStream");
1:eac0369: 	}
1:050b616: 
1:eac0369:     /**
1:c511410:      * When a very large UNICODE value is input to a LONGVARCHAR
1:c511410:      * parameter, it may be more practical to send it via a
1:c511410:      * java.io.Reader. JDBC will read the data from the stream
1:c511410:      * as needed, until it reaches end-of-file.  The JDBC driver will
1:c511410:      * do any necessary conversion from UNICODE to the database char format.
1:c511410:      *
1:c511410:      * <P><B>Note:</B> This stream object can either be a standard
1:c511410:      * Java stream object or your own subclass that implements the
1:c511410:      * standard interface.
1:c511410:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param reader the java reader which contains the UNICODE data
1:c511410:      * @param length the number of characters in the stream
1:c511410:      * @exception SQLException if a database-access error occurs.
1:c511410:      */
1:c511410:     public final void setCharacterStream(int parameterIndex,
1:c511410:        			  java.io.Reader reader,
1:c511410: 			  long length) throws SQLException {
1:d45f7d3:         checkCharacterStreamConditions(parameterIndex);
1:242c9bd:         setCharacterStreamInternal(parameterIndex, reader, false, length);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * When a very large UNICODE value is input to a LONGVARCHAR
1:eac0369:      * parameter, it may be more practical to send it via a
1:eac0369:      * java.io.Reader. JDBC will read the data from the stream
1:eac0369:      * as needed, until it reaches end-of-file.  The JDBC driver will
1:eac0369:      * do any necessary conversion from UNICODE to the database char format.
1:eac0369:      *
1:eac0369:      * <P><B>Note:</B> This stream object can either be a standard
1:eac0369:      * Java stream object or your own subclass that implements the
1:eac0369:      * standard interface.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:3fcea8a:      * @param reader the java reader which contains the UNICODE data
1:eac0369:      * @param length the number of characters in the stream
2:eac0369:      * @exception SQLException if a database-access error occurs.
1:eac0369:      */
1:eac0369:     public final void setCharacterStream(int parameterIndex,
1:eac0369:         java.io.Reader reader,
1:c511410:         int length) throws SQLException {
1:c511410:         setCharacterStream(parameterIndex,reader,(long)length);
1:c511410:     }
1:c511410: 
1:242c9bd:     /**
1:d45f7d3:      * Check general preconditions for setCharacterStream methods.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex 1-based index of the parameter.
1:242c9bd:      */
1:d45f7d3:     private final void checkCharacterStreamConditions(int parameterIndex)
1:242c9bd:             throws SQLException {
1:92268ac:         checkStatus();
1:242c9bd:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:d45f7d3:         if (!DataTypeDescriptor.isCharacterStreamAssignable(jdbcTypeId)) {
1:d45f7d3:             throw dataTypeConversion(parameterIndex, "java.io.Reader");
1:d45f7d3:         }
1:d45f7d3:     }
1:d45f7d3: 
1:d45f7d3:     /**
1:d45f7d3:      * Check general preconditions for setAsciiStream methods.
1:d45f7d3:      *
1:d45f7d3:      * @param parameterIndex 1-based index of the parameter.
1:d45f7d3:      */
1:d45f7d3:     private final void checkAsciiStreamConditions(int parameterIndex)
1:d45f7d3:             throws SQLException {
1:d45f7d3:         checkStatus();
1:d45f7d3:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:d45f7d3:         if (!DataTypeDescriptor.isAsciiStreamAssignable(jdbcTypeId)) {
1:d45f7d3:             throw dataTypeConversion(parameterIndex,
1:d45f7d3:                                      "java.io.InputStream(ASCII)");
1:242c9bd:         }
1:242c9bd:     }
1:c511410: 
1:242c9bd:     /**
1:242c9bd:      * Set the given character stream for the specified parameter.
1:242c9bd:      *
1:242c9bd:      * If <code>lengthLess</code> is <code>true</code>, the following
1:242c9bd:      * conditions are either not checked or verified at the execution time
1:242c9bd:      * of the prepared statement:
1:242c9bd:      * <ol><li>If the stream length is negative.
1:242c9bd:      *     <li>If the stream's actual length equals the specified length.</ol>
1:242c9bd:      * The <code>lengthLess</code> variable was added to differentiate between
1:242c9bd:      * streams with invalid lengths and streams without known lengths.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex the 1-based index of the parameter to set.
1:242c9bd:      * @param reader the data.
1:242c9bd:      * @param lengthLess tells whether we know the length of the data or not.
1:242c9bd:      * @param length the length of the data. Ignored if <code>lengthLess</code>
1:242c9bd:      *          is <code>true</code>.
1:242c9bd:      */
1:050b616:     private void setCharacterStreamInternal(int parameterIndex,
1:242c9bd:                                             Reader reader,
1:242c9bd:                                             final boolean lengthLess,
1:242c9bd:                                             long length)
1:eac0369: 	    throws SQLException
1:eac0369: 	{
1:242c9bd:         // Check for negative length if length is specified.
1:242c9bd:         if (!lengthLess && length < 0)
1:242c9bd:             throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
1:e334847: 
1:e334847: 	    int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:e334847: 
1:eac0369: 
1:e334847:         if (reader == null)  {
1:e334847:              setNull(parameterIndex, jdbcTypeId);
1:e334847:              return;
1:eac0369:         }
1:eac0369: 
1:e334847:         /*
1:e334847:            The value stored should not exceed the maximum value that can be 
1:e334847:            stored in an integer 
1:e334847:            This checking needs to be done because currently derby does not
1:e334847:            support Clob sizes greater than 2G-1 
1:e334847:         */
1:242c9bd:         if (!lengthLess && length > Integer.MAX_VALUE)
1:e334847:                throw newSQLException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE,
1:10cc70b:                                      getParameterSQLType(parameterIndex));
1:e334847: 
1:92268ac:         try {
1:242c9bd:             ReaderToUTF8Stream utfIn;
1:7af6726:             final StringDataValue dvd = (StringDataValue)
1:7af6726:                     getParms().getParameter(parameterIndex -1);
1:d92fa8c:             dvd.setStreamHeaderFormat(usePreTenFiveHdrFormat());
1:242c9bd:             // Need column width to figure out if truncation is needed
1:242c9bd:             DataTypeDescriptor dtd[] = preparedStatement
1:242c9bd:                     .getParameterTypes();
1:242c9bd:             int colWidth = dtd[parameterIndex - 1].getMaximumWidth();
1:d4953dd:             // Holds either UNKNOWN_LOGICAL_LENGTH or the exact logical length.
1:d4953dd:             int usableLength = DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH;
1:eac0369: 
1:242c9bd:             if (!lengthLess) {
1:242c9bd:                 // We cast the length from long to int. This wouldn't be
1:242c9bd:                 // appropriate if the limit of 2G-1 is decided to be increased
1:242c9bd:                 // at a later stage.
1:d4953dd:                 usableLength = (int)length;
1:242c9bd:                 int truncationLength = 0;
1:eac0369: 
1:242c9bd:                 // Currently long varchar does not allow for truncation of
1:242c9bd:                 // trailing blanks.
1:242c9bd:                 // For char and varchar types, current mechanism of
1:242c9bd:                 // materializing when using streams seems fine given their max
1:242c9bd:                 // limits.
1:242c9bd:                 // This change is fix for DERBY-352: Insert of clobs using
1:242c9bd:                 // streams should not materialize the entire stream into memory
1:242c9bd:                 // In case of clobs, the truncation of trailing blanks is
1:242c9bd:                 // factored in when reading from the stream without
1:242c9bd:                 // materializing the entire stream, and so the special casing
1:242c9bd:                 // for clob below.
1:242c9bd:                 if (jdbcTypeId == Types.CLOB)
1:242c9bd:                 {
1:242c9bd: 
1:242c9bd:                     // It is possible that the length of the stream passed in
1:242c9bd:                     // is greater than the column width, in which case the data
1:242c9bd:                     // from the stream needs to be truncated.
1:242c9bd:                     // usableLength is the length of the data from stream that
1:242c9bd:                     // can be inserted which is min(colWidth,length) provided
1:242c9bd:                     // length - colWidth has trailing blanks only
1:d4953dd:                     if (usableLength > colWidth) {
1:d4953dd:                         truncationLength = usableLength - colWidth;
1:242c9bd:                         usableLength = colWidth;
1:242c9bd:                     }
1:4dbb0ff:                 }
1:242c9bd:                 // Create a stream with truncation.
1:10cc70b:                 utfIn = new ReaderToUTF8Stream(reader, usableLength,
1:7af6726:                         truncationLength, getParameterSQLType(parameterIndex),
1:6f4c92a:                         dvd.getStreamHeaderGenerator());
1:242c9bd:             } else {
1:10cc70b:                 // Create a stream without exactness checks,
1:10cc70b:                 // but with a maximum limit.
1:10cc70b:                 utfIn = new ReaderToUTF8Stream(reader, colWidth,
1:6f4c92a:                         getParameterSQLType(parameterIndex),
1:6f4c92a:                         dvd.getStreamHeaderGenerator());
1:eac0369:             }
1:eac0369: 
1:242c9bd:             // JDBC is one-based, DBMS is zero-based.
1:242c9bd:             // Note that for lengthless stream, usableLength will be
1:10cc70b:             // the maximum length for the column. 
1:10cc70b:             // This is okay, based on the observation that
1:242c9bd:             // setValue does not use the value for anything at all.
1:7af6726:             getParms().getParameterForSet(parameterIndex - 1).
1:7af6726:                     setValue(utfIn, usableLength);
1:eac0369: 
1:eac0369: 		} catch (StandardException t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:d92fa8c:      * Determines which header format to use for CLOBs when writing them to
1:d92fa8c:      * the store.
1:eac0369:      *
1:d92fa8c:      * @return {@code true} if the pre Derby 10.5 header format is to be used,
1:d92fa8c:      *      {@code false} if the new header format can be used (10.5 or newer)
1:8f75194:      * @throws StandardException if obtaining the access mode fails
1:8f75194:      */
1:d92fa8c:     private Boolean usePreTenFiveHdrFormat()
1:8f75194:             throws StandardException {
1:d92fa8c:         // Determine the version of the database we are accessing.
1:8f75194:         // This is required to write the correct stream header format for Clobs.
1:d92fa8c:         if (usePreTenFiveHdrFormat == null) {
1:d92fa8c:             usePreTenFiveHdrFormat = Boolean.valueOf(
1:d92fa8c:                 !lcc.getDataDictionary().checkVersion(
1:d92fa8c:                     DataDictionary.DD_VERSION_DERBY_10_5, null));
1:8f75194:         }
1:d92fa8c:         return usePreTenFiveHdrFormat;
1:8f75194:     }
1:8f75194: 
1:8f75194:     /**
1:242c9bd:      * Sets the designated parameter to the given input stream.
1:242c9bd:      * When a very large binary value is input to a <code>LONGVARBINARY</code>
1:242c9bd:      * parameter, it may be more practical to send it via a
1:242c9bd:      * <code>java.io.InputStream</code> object. The data will be read from the
1:242c9bd:      * stream as needed until end-of-file is reached.
1:242c9bd:      *
1:242c9bd:      * <em>Note:</em> This stream object can either be a standard Java stream
1:242c9bd:      * object or your own subclass that implements the standard interface.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:242c9bd:      * @param x the java input stream which contains the binary parameter value
1:242c9bd:      * @throws SQLException if a database access error occurs or this method is
1:242c9bd:      *      called on a closed <code>PreparedStatement</code>
1:242c9bd:      */
1:242c9bd:     public void setBinaryStream(int parameterIndex, InputStream x)
1:242c9bd:             throws SQLException {
1:242c9bd:         checkBinaryStreamConditions(parameterIndex);
1:242c9bd:         setBinaryStreamInternal(parameterIndex, x, true, -1);
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:c511410:      * sets the parameter to the Binary stream
1:eac0369:      * 
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the java input stream which contains the binary parameter value
1:eac0369:      * @param length the number of bytes in the stream 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:e334847:      */
1:c511410:     public final void setBinaryStream(int parameterIndex, InputStream x, long length)
1:c511410: 	    throws SQLException {
1:242c9bd:         checkBinaryStreamConditions(parameterIndex);
1:242c9bd:         setBinaryStreamInternal(parameterIndex, x, false, length);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:c511410:      * sets the parameter to the binary stream
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the binary parameter value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      */
1:c511410:     public final void setBinaryStream(int parameterIndex, InputStream x, int length)
1:c511410:     throws SQLException {
1:c511410:         setBinaryStream(parameterIndex,x,(long)length);
1:c511410:     }
1:c511410: 
1:242c9bd:     /**
1:242c9bd:      * Set the given stream for the specified parameter.
1:242c9bd:      *
1:242c9bd:      * If <code>lengthLess</code> is <code>true</code>, the following
1:242c9bd:      * conditions are either not checked or verified at the execution time
1:242c9bd:      * of the prepared statement:
1:242c9bd:      * <ol><li>If the stream length is negative.
1:242c9bd:      *     <li>If the stream's actual length equals the specified length.</ol>
1:242c9bd:      * The <code>lengthLess</code> variable was added to differentiate between
1:242c9bd:      * streams with invalid lengths and streams without known lengths.
1:eac0369:      *
1:242c9bd:      * @param parameterIndex the 1-based index of the parameter to set.
1:242c9bd:      * @param x the data.
1:242c9bd:      * @param lengthLess tells whether we know the length of the data or not.
1:242c9bd:      * @param length the length of the data. Ignored if <code>lengthLess</code>
1:242c9bd:      *          is <code>true</code>.
1:242c9bd:      */
1:050b616:     private void setBinaryStreamInternal(int parameterIndex, InputStream x,
1:242c9bd:                                          final boolean lengthLess, long length)
1:eac0369: 	    throws SQLException
1:eac0369: 	{
1:eac0369: 
1:242c9bd:         if ( !lengthLess && length < 0 )
2:eac0369:             throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
1:eac0369:         
1:eac0369: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:eac0369: 		if (x == null) {
2:eac0369: 			setNull(parameterIndex, jdbcTypeId);
1:75fbaa9:            	return;
1:eac0369: 		}
1:eac0369:         
1:2648e94:         // max number of bytes that can be set to be inserted 
1:2648e94:         // in Derby is 2Gb-1 (ie Integer.MAX_VALUE). 
1:2648e94:         // (e.g into a blob column).
1:2648e94:         // For now, we cast the length from long to int as a result.
1:2648e94:         // If we ever decide to increase these limits for lets say blobs, 
1:2648e94:         // in that case the cast to int would not be appropriate.
1:242c9bd:         if ( !lengthLess && length > Integer.MAX_VALUE ) {
1:2648e94:             throw newSQLException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE,
1:8514aa2:                getParameterMetaData().getParameterTypeName(
1:2648e94:                    parameterIndex));
1:eac0369:         }
1:eac0369: 
1:e334847:         try {
1:10cc70b:             RawToBinaryFormatStream rawStream;
1:242c9bd:             if (lengthLess) {
1:d4953dd:                 // Indicate that we don't know the logical length of the stream.
1:d4953dd:                 length = DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH;
1:10cc70b:                 DataTypeDescriptor dtd[] = 
1:10cc70b:                     preparedStatement.getParameterTypes();
1:10cc70b:                 rawStream = new RawToBinaryFormatStream(x,
1:10cc70b:                         dtd[parameterIndex -1].getMaximumWidth(),
1:10cc70b:                         dtd[parameterIndex -1].getTypeName());
1:10cc70b:             } else {
1:10cc70b:                 rawStream = new RawToBinaryFormatStream(x, (int)length);
1:242c9bd:             }
1:242c9bd:             getParms().getParameterForSet(parameterIndex - 1).setValue(
1:10cc70b:                     rawStream, (int)length);
1:eac0369: 
1:eac0369: 		} catch (StandardException t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:242c9bd:     /**
1:d45f7d3:      * Check general preconditions for setBinaryStream methods.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex 1-based index of the parameter.
1:242c9bd:      */
1:242c9bd:     private final void checkBinaryStreamConditions(int parameterIndex)
1:242c9bd:             throws SQLException {
1:242c9bd:         checkStatus();
1:242c9bd:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:d45f7d3:         if (!DataTypeDescriptor.isBinaryStreamAssignable(jdbcTypeId)) {
1:242c9bd:             throw dataTypeConversion(parameterIndex, "java.io.InputStream");
1:242c9bd:         }
1:242c9bd:     }
1:242c9bd: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:054fa3a: 	//
1:eac0369: 	//	JDBC 2.0	-	New public methods
1:054fa3a: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:054fa3a: 
1:eac0369:     /**
1:fe8446d:      *
1:75fbaa9:      * JDBC 2.0
1:75fbaa9:      *
1:fe8446d:      * Sets the designated parameter to SQL <code>NULL</code>.
1:fe8446d:      * This version of the method <code>setNull</code> should
1:fe8446d:      * be used for user-defined types and REF type parameters.  Examples
1:fe8446d:      * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
1:fe8446d:      * named array types.
1:fe8446d:      *
1:fe8446d:      * @param paramIndex the first parameter is 1, the second is 2, ...
1:fe8446d:      * @param sqlType a value from <code>java.sql.Types</code>
1:fe8446d:      * @param typeName the fully-qualified name of an SQL user-defined type;
1:fe8446d:      *  ignored if the parameter is not a user-defined type or REF
1:fe8446d:      * @exception SQLException if a database access error occurs or
1:fe8446d:      * this method is called on a closed <code>PreparedStatement</code>
1:f668d94:      * @exception java.sql.SQLFeatureNotSupportedException if Derby does not
1:f668d94:      * support the type specified in the {@code sqlType} parameter
1:eac0369:      */
1:fe8446d:     public void setNull(int paramIndex,
1:fe8446d:         int sqlType,
1:fe8446d:         String typeName)
1:fe8446d:         throws SQLException {
1:fe8446d:         setNull(paramIndex,sqlType);
1:fe8446d:     }
1:054fa3a: 
1:eac0369:     /**
2:eac0369:      * JDBC 2.0
1:fe8446d:      *
1:eac0369:      * Add a set of parameters to the batch.
1:75fbaa9:      * 
1:eac0369:      * @exception SQLException if a database-access error occurs.
1:eac0369:      */
1:eac0369:     public void addBatch() throws SQLException {
1:9495437: 	  checkStatus();
1:eac0369: 
1:9495437: 	  // need to synchronized to ensure that two threads
1:9495437: 	  // don't both create a Vector at the same time. This
1:9495437: 	  // would lead to one of the set of parameters being thrown
1:9495437: 	  // away
1:9495437:   	  synchronized (getConnectionSynchronization()) {
1:9495437:   			if (batchStatements == null)
1:71c8e86:   				batchStatements = new Vector<Object>();
1:eac0369: 
1:9495437:           //get a clone of the parameterValueSet and save it in the vector
1:9495437:           //which will be used later on at the time of batch execution.
1:9495437:           //This way we will get a copy of the current statement's parameter
1:9495437:           //values rather than a pointer to the statement's parameter value
1:9495437:           //set which will change with every new statement in the batch.
1:9495437:           batchStatements.add(getParms().getClone());
1:9495437:           clearParameters();
1:9495437:   	  }
1:92268ac:     }
1:eac0369: 
1:23b4f8b: 	boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
1:eac0369: 		
1:eac0369: 		ParameterValueSet temp = (ParameterValueSet) batchElement;
1:eac0369: 
1:eac0369: 		int numberOfParameters = temp.getParameterCount();
1:eac0369: 
1:eac0369: 		for (int j=0; j<numberOfParameters; j++) {
1:eac0369: 			temp.getParameter(j).setInto(this, j + 1);
1:92268ac: 		}
1:eac0369: 
1:eac0369: 		return super.executeStatement(activation, false, true);
1:054fa3a: 	}
1:eac0369: 
1:eac0369:  
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * <P>In general, parameter values remain in force for repeated use of a
1:eac0369:      * Statement. Setting a parameter value automatically clears its
1:eac0369:      * previous value.  However, in some cases it is useful to immediately
1:eac0369:      * release the resources used by the current parameter values; this can
1:eac0369:      * be done by calling clearParameters.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public void clearParameters() throws SQLException {
1:050b616: 		checkStatus();
1:eac0369: 
1:242c9bd: 		ParameterValueSet pvs = getParms();
1:eac0369: 		if (pvs != null)
1:eac0369: 			pvs.clearParameters();
1:054fa3a: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	 * JDBC 2.0
1:eac0369: 	 *
1:eac0369:      * The number, types and properties of a ResultSet's columns
1:eac0369:      * are provided by the getMetaData method.
1:eac0369:      *
1:eac0369:      * @return the description of a ResultSet's columns
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public java.sql.ResultSetMetaData getMetaData() throws SQLException
1:eac0369: 	{
2:eac0369: 		checkExecStatus();
2:75fbaa9: 		synchronized (getConnectionSynchronization())
1:eac0369: 		{
1:eac0369: 			//reason for casting is getActivationClass is not available on PreparedStatement
1:eac0369: 			ExecPreparedStatement execp = (ExecPreparedStatement)preparedStatement;
1:eac0369: 
1:eac0369: 			setupContextStack(); // make sure there's context
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 				//bug 4579 - gcDuringGetMetaData will be null if this is the first time
1:eac0369: 				//getMetaData call is made.
1:eac0369: 				//Second check - if the statement was revalidated since last getMetaData call,
1:eac0369: 				//then gcDuringGetMetaData wouldn't match with current generated class name
1:e8fb6d6: 
1:e8fb6d6:                 GeneratedClass currAc = null;
1:e8fb6d6:                 ResultDescription resd = null;
1:e8fb6d6: 
1:e8fb6d6:                 synchronized(execp) {
1:e8fb6d6:                     // DERBY-3823 Some other thread may be repreparing
1:e8fb6d6:                     do {
1:e8fb6d6:                         while (!execp.upToDate()) {
1:e8fb6d6:                             execp.rePrepare(lcc);
1:e8fb6d6:                         }
1:e8fb6d6: 
1:e8fb6d6:                         currAc = execp.getActivationClass();
1:e8fb6d6:                         resd = execp.getResultDescription();
1:e8fb6d6:                     } while (currAc == null);
1:e8fb6d6:                 }
1:e8fb6d6: 
1:e8fb6d6:                 if (gcDuringGetMetaData == null ||
1:e8fb6d6:                         !gcDuringGetMetaData.equals(currAc.getName())) {
1:e8fb6d6:                     rMetaData = null;
1:e8fb6d6:                     gcDuringGetMetaData = currAc.getName();
1:e8fb6d6:                 }
1:e8fb6d6: 
1:e8fb6d6:                 if (rMetaData == null && resd != null) {
1:e8fb6d6:                     // Internally, the result description has information
1:e8fb6d6:                     // which is used for insert, update and delete statements
1:e8fb6d6:                     // Externally, we decided that statements which don't
1:e8fb6d6:                     // produce result sets such as insert, update and delete
1:e8fb6d6:                     // should not return ResultSetMetaData.  This is enforced
1:e8fb6d6:                     // here
1:e8fb6d6:                     String statementType = resd.getStatementType();
1:e8fb6d6:                     if (statementType.equals("INSERT") ||
1:e8fb6d6:                             statementType.equals("UPDATE") ||
1:e8fb6d6:                             statementType.equals("DELETE"))
1:e8fb6d6:                         rMetaData = null;
1:e8fb6d6:                     else
1:e8fb6d6:                         rMetaData = newEmbedResultSetMetaData(resd);
1:e8fb6d6:                 }
1:e8fb6d6: 
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1:eac0369: 			} catch (Throwable t) {
1:eac0369: 				throw handleException(t);
1:eac0369: 			}	finally {
1:eac0369: 				restoreContextStack();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return rMetaData;
1:eac0369: 	}
1:eac0369: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 2.0
1:b5f2776:      *
1:b5f2776:      * Set a REF(&lt;structured-type&gt;) parameter.
1:b5f2776:      *
1:b5f2776:      * @param i the first parameter is 1, the second is 2, ...
1:b5f2776:      * @param x an object representing data of an SQL REF Type
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setRef(int i, Ref x) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     /**
1:b5f2776:      * JDBC 2.0
1:b5f2776:      *
1:b5f2776:      * Set an Array parameter.
1:b5f2776:      *
1:b5f2776:      * @param i the first parameter is 1, the second is 2, ...
1:b5f2776:      * @param x an object representing an SQL array
1:b5f2776:      * @exception SQLException Feature not implemented for now.
1:b5f2776:      */
1:b5f2776:     public final void setArray(int i, Array x) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:eac0369:     //----------------------------------------------------------------------
1:eac0369:     // Advanced features:
1:75fbaa9: 
1:b5f2776:     /**
1:eac0369: 	 * The interface says that the type of the Object parameter must
1:eac0369: 	 * be compatible with the type of the targetSqlType. We check that,
1:eac0369: 	 * and if it flies, we expect the underlying engine to do the
1:eac0369: 	 * required conversion once we pass in the value using its type.
1:eac0369: 	 * So, an Integer converting to a CHAR is done via setInteger()
1:eac0369: 	 * support on the underlying CHAR type.
1:eac0369:      *
1:eac0369:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
1:eac0369:      *
1:eac0369:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:eac0369:      * @param x The object containing the input parameter value
1:eac0369:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
1:eac0369:      * sent to the database. The scale argument may further qualify this type.
1:eac0369:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
1:eac0369:      *          this is the number of digits after the decimal.  For all other
1:eac0369:      *          types this value will be ignored,
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
1:eac0369:             throws SQLException {
1:054fa3a: 
1:eac0369: 		if (x == null) {
1:eac0369: 			setNull(parameterIndex, targetSqlType);
1:eac0369: 			return;
1:75fbaa9: 		}
1:dbbf9ff: 
1:4c2fc4a: 		Util.checkForSupportedDataType(targetSqlType);
1:eac0369: 
1:eac0369: 		int paramJDBCType = getParameterJDBCType(parameterIndex);
1:eac0369: 
1:eac0369: 		if (paramJDBCType != java.sql.Types.JAVA_OBJECT) {
1:eac0369: 			if (!DataTypeDescriptor.isJDBCTypeEquivalent(paramJDBCType, targetSqlType)) {
1:eac0369: 				throw dataTypeConversion(parameterIndex, Util.typeName(targetSqlType));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		setObject(parameterIndex, x);
1:eac0369: 				
1:e334847: 		/*
1:eac0369: 		* If the parameter type is DECIMAL or NUMERIC, then
1:eac0369: 		* we need to set the correct scale  or set it 
1:eac0369: 		* to the default which is zero for setObject.
1:eac0369: 		*/
1:eac0369: 		if ((paramJDBCType == Types.DECIMAL) || 
1:eac0369: 			 (paramJDBCType == Types.NUMERIC))
1:75fbaa9: 		{
1:eac0369: 			setScale(parameterIndex, scale);
1:eac0369: 		}	
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:       * This method is like setObject above, but assumes a scale of zero.
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:       */
1:eac0369:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
1:eac0369: 		throws SQLException {
1:eac0369: 		setObject(parameterIndex, x, targetSqlType, 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * <p>Set the value of a parameter using an object; use the
1:eac0369:      * java.lang equivalent objects for integral values.
1:eac0369:      *
1:eac0369:      * <p>The JDBC specification specifies a standard mapping from
1:eac0369:      * Java Object types to SQL types.  The given argument java object
1:eac0369:      * will be converted to the corresponding SQL type before being
1:eac0369:      * sent to the database.
1:eac0369:      *
1:eac0369:      * <p>Note that this method may be used to pass datatabase
1:eac0369:      * specific abstract data types, by using a Driver specific Java
1:eac0369:      * type.
1:eac0369:      *
1:eac0369:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:eac0369:      * @param x The object containing the input parameter value 
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     public final void setObject(int parameterIndex, Object x) throws SQLException {
1:eac0369: 		checkStatus();	
1:eac0369: 
1:eac0369: 
1:eac0369: 		int colType = getParameterJDBCType(parameterIndex);
1:eac0369: 
1:eac0369: 		// JDBC Tutorial and Reference books states in the PreparedStatement
1:eac0369: 		// overview, that passing a untyped null into setObject() is not allowed.
1:eac0369: 		// JCC disallows this, basically SQL can not handle a untyped NULL.
1:eac0369: 		// Section 25.1.6 (Third edition), 24.1.5 (Second Edition)
1:a92196c:         //
1:a92196c:         // However, the following update was made to the JDBC API:
1:a92196c:         // "Note: Not all databases allow for a non-typed Null to be sent to
1:a92196c:         // the backend. For maximum portability, the setNull or the
1:a92196c:         // setObject(int parameterIndex, Object x, int sqlType) method should
1:a92196c:         // be used instead of setObject(int parameterIndex, Object x)."
1:a92196c:         // Based on the above sentence, passing null is now allowed by Derby.
1:a92196c:         // See DERBY-1938 for details.
1:eac0369: 
1:eac0369: 		if (x == null) {
1:a92196c:             setNull(parameterIndex, colType);
1:a92196c:             return;
1:eac0369: 		}
1:eac0369: 		
1:1a4ea31: 		if (colType == Types.JAVA_OBJECT) {
1:eac0369: 			try {
1:eac0369: 				/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 				getParms().setParameterAsObject(parameterIndex - 1, x);
1:eac0369: 				return;
1:eac0369: 
1:eac0369: 			} catch (Throwable t) {
1:92268ac: 				throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		// Need to do instanceof checks here so that the behaviour
1:eac0369: 		// for these calls is consistent with the matching setXXX() value.
1:eac0369: 
1:eac0369: 		// These are the supported setObject conversions from JDBC 3.0 table B5
1:27190db: 		// Byte and Short were added to the table in JDBC 4.0.
1:eac0369: 
1:eac0369: 		if (x instanceof String) {
1:eac0369: 			setString(parameterIndex, (String) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (x instanceof Boolean) {
1:eac0369: 			setBoolean(parameterIndex, ((Boolean) x).booleanValue());
1:eac0369: 			return;
1:eac0369: 		}
1:27190db: 		if (x instanceof Byte) {
1:27190db: 			setByte(parameterIndex, ((Byte) x).byteValue());
1:27190db: 			return;
1:27190db: 		}
1:27190db: 		if (x instanceof Short) {
1:27190db: 			setShort(parameterIndex, ((Short) x).shortValue());
1:27190db: 			return;
1:27190db: 		}
1:eac0369: 		if (x instanceof Integer) {
1:eac0369: 			setInt(parameterIndex, ((Integer) x).intValue());
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (x instanceof Long) {
1:eac0369: 			setLong(parameterIndex, ((Long) x).longValue());
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (x instanceof Float) {
1:eac0369: 			setFloat(parameterIndex, ((Float) x).floatValue());
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (x instanceof Double) {
1:eac0369: 			setDouble(parameterIndex, ((Double) x).doubleValue());
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (x instanceof byte[]) {
1:eac0369: 			setBytes(parameterIndex, (byte[]) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (x instanceof Date) {
1:eac0369: 			setDate(parameterIndex, (Date) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (x instanceof Time) {
1:eac0369: 			setTime(parameterIndex, (Time) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (x instanceof Timestamp) {
1:eac0369: 			setTimestamp(parameterIndex, (Timestamp) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (x instanceof Blob) {
1:eac0369: 			setBlob(parameterIndex, (Blob) x);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 		if (x instanceof Clob) {
1:eac0369: 			setClob(parameterIndex, (Clob) x);
1:59f54f8: 			return;
1:59f54f8: 		}
1:59f54f8: 		if (x instanceof java.util.Date) {
1:59f54f8: 			setTimestamp(parameterIndex, new Timestamp(  ((java.util.Date) x).getTime() ) );
1:59f54f8: 			return;
1:59f54f8: 		}
1:59f54f8: 		if (x instanceof java.util.Calendar) {
1:59f54f8: 			setTimestamp(parameterIndex, new Timestamp(  ((java.util.Calendar) x).getTime().getTime() ) );
1:59f54f8: 			return;
1:59f54f8: 		}
1:10608cf: 		if (x instanceof BigDecimal) {
1:10608cf: 			setBigDecimal(parameterIndex, (BigDecimal) x);
1:eac0369: 			return;
1:10608cf: 		}
1:10608cf: 		if (x instanceof BigInteger) {
1:10608cf: 			setBigDecimal(parameterIndex, new BigDecimal( (BigInteger) x ) );
1:10608cf: 			return;
1:10608cf:         }
1:eac0369: 
1:eac0369: 		throw dataTypeConversion(parameterIndex, x.getClass().getName());
1:75fbaa9: 	}
1:75fbaa9: 
1:75fbaa9:     /**
1:eac0369:      * @see java.sql.Statement#execute
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:448ecb0:         public final boolean execute() throws SQLException {
1:448ecb0:             boolean ret=false;
1:448ecb0:             try{
1:448ecb0:                 ret = executeStatement(activation, false, false);
1:448ecb0:             } catch(SQLException sqle) {
1:448ecb0:                 checkStatementValidity(sqle);
1:448ecb0:             }
1:448ecb0:             return ret;
1:448ecb0:         }
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:eac0369:      * to a SQL DATE value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public final void setDate(int parameterIndex, java.sql.Date x, Calendar cal)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:eac0369:      * to a SQL TIME value when it sends it to the database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public final void setTime(int parameterIndex, java.sql.Time x, Calendar cal)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:eac0369:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:eac0369:      * database.
1:eac0369:      *
1:eac0369:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369:      * @param x the parameter value 
1:eac0369:      * @exception SQLException Feature not implemented for now.
1:eac0369:      */
1:eac0369:     public final void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal)
1:eac0369: 	    throws SQLException 
1:eac0369: 	{
1:eac0369: 		checkStatus();
1:eac0369: 		try {
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1:eac0369: 
1:92268ac: 		} catch (StandardException t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 2.0
1:eac0369:      *
1:75fbaa9:      * Set a BLOB parameter.
1:eac0369:      *
1:75fbaa9:      * @param i the first parameter is 1, the second is 2, ...
1:75fbaa9:      * @param x an object representing a BLOB
1:75fbaa9:      */
1:75fbaa9:     public void setBlob (int i, Blob x)
1:75fbaa9:         throws SQLException
1:75fbaa9:     {
1:242c9bd:         checkBlobConditions(i);
1:75fbaa9: 		if (x == null)
1:75fbaa9: 			setNull(i, Types.BLOB);
1:75fbaa9: 		else
1:75fbaa9:         {
1:2648e94:             // Note, x.length() needs to be called before retrieving the
1:2648e94:             // stream using x.getBinaryStream() because EmbedBlob.length()
1:2648e94:             // will read from the stream and drain some part of the stream 
1:2648e94:             // Hence the need to declare this local variable - streamLength
1:2648e94:             long streamLength = x.length();
1:242c9bd:             setBinaryStreamInternal(i, x.getBinaryStream(), false,
1:242c9bd:                     streamLength);
1:75fbaa9:         }
1:75fbaa9: 	}
1:75fbaa9: 
1:75fbaa9:     /**
1:242c9bd:      * Check general (pre)conditions for setClob methods.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex 1-based index of the parameter.
1:242c9bd:      */
1:242c9bd:     private final void checkClobConditions(int parameterIndex)
1:242c9bd:             throws SQLException {
1:242c9bd:         checkStatus();
1:242c9bd:         if (getParameterJDBCType(parameterIndex) != Types.CLOB) {
1:242c9bd:             throw dataTypeConversion(parameterIndex, "java.sql.Clob");
1:242c9bd:         }
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:75fbaa9:      * JDBC 2.0
1:75fbaa9:      *
1:75fbaa9:      * Set a CLOB parameter.
1:75fbaa9:      *
1:75fbaa9:      * @param i the first parameter is 1, the second is 2, ...
1:75fbaa9:      * @param x an object representing a CLOB
1:75fbaa9:      */
1:75fbaa9:     public void setClob (int i, Clob x)
1:75fbaa9:         throws SQLException
1:75fbaa9:     {
1:242c9bd:         checkClobConditions(i);
1:75fbaa9: 		if (x == null)
1:75fbaa9: 			setNull(i, Types.CLOB);
1:75fbaa9: 		else
1:eac0369:         {
1:28030d7:             // 1. max number of characters that can be inserted into a clob column
1:28030d7:             // is 2Gb-1 which is Integer.MAX_INT.
1:28030d7:             // This means that we do not allow any inserts of clobs where
1:28030d7:             // clob.length() > Integer.MAX_INT. For now, we cast the x.length()
1:28030d7:             // to int as a result. This will work ok for valid clob values that
1:28030d7:             // derby supports. If we ever decide to increase these limits for clobs, in that
1:28030d7:             // case the cast of x.Length() to int would not be appropriate.
1:28030d7:             // 2. Note, x.length() needs to be called before retrieving the
1:28030d7:             // stream using x.getCharacterStream() because EmbedClob.length()
1:28030d7:             // will read from the stream and drain the stream. 
1:28030d7:             // Hence the need to declare this local variable - streamLength
1:e334847:             long streamLength = x.length();
1:75fbaa9: 
1:242c9bd:             setCharacterStreamInternal(i, x.getCharacterStream(),
1:242c9bd:                                        false, streamLength);
1:75fbaa9:         }
1:75fbaa9:         
1:eac0369: 	}
1:75fbaa9: 
1:eac0369: 	/**
1:616634f: 	 * Get the ParameterValueSet from the activation.
1:616634f: 	 * 
1:616634f: 	 * The caller of this method should be aware that the
1:616634f: 	 * activation associated with a Statement can change
1:616634f: 	 * and hence the ParameterValueSet returned by this
1:616634f: 	 * call should not be hold onto. An example of this
1:616634f: 	 * can be seen in EmbedCallableStatement.executeStatement
1:616634f: 	 * where at the beginning of the method, we check the
1:616634f: 	 * validity of the parameters. But we donot keep the
1:616634f: 	 * parameters in a local variable to use later. The reason
1:616634f: 	 * for this is that the next call in the method, 
1:616634f: 	 * super.executeStatement can recompile the statement and 
1:616634f: 	 * create a new activation if the statement plan has been 
1:616634f: 	 * invalidated. To account for this possibility, 
1:616634f: 	 * EmbedCallableStatement.executeStatement makes 
1:616634f: 	 * another call to get the ParameterValueSet before stuffing 
1:616634f: 	 * the output parameter value into the ParameterValueSet
1:616634f: 	 * object.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @return	The ParameterValueSet for the activation
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public final ParameterValueSet getParms() {
1:eac0369: 
1:eac0369: 		return activation.getParameterValueSet();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the target JDBC type for a parameter. Will throw exceptions
1:6cc0702: 		if the parameter index is out of range. The parameterIndex is 1-based.
1:eac0369: 
2:eac0369: 		@exception SQLException parameter is out of range
1:eac0369: 	*/
1:eac0369: 	protected int getParameterJDBCType(int parameterIndex)
1:6cc0702: 		throws SQLException
1:6cc0702:     {
1:6cc0702:         try {
1:6cc0702:             DataTypeDescriptor dtd = preparedStatement.getParameterType( parameterIndex-1 );
1:eac0369: 
1:6cc0702:             return (dtd == null) ? Types.OTHER : dtd.getTypeId().getJDBCTypeId();
1:6cc0702:             
1:6cc0702: 		} catch (StandardException t) { throw EmbedResultSet.noStateChangeException(t); }
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:10cc70b:      * Return the SQL type name for the parameter.
1:10cc70b:      *
1:10cc70b:      * @param parameterIndex the 1-based index of the parameter
1:10cc70b:      * @return SQL name of the parameter
1:10cc70b:      * @throws SQLException if parameter is out of range
1:10cc70b:      */
1:10cc70b:     protected final String getParameterSQLType(int parameterIndex)
1:6cc0702:             throws SQLException
1:6cc0702:     {
1:6cc0702:         try {
1:6cc0702:             DataTypeDescriptor dtd = preparedStatement.getParameterType( parameterIndex-1 );
1:6cc0702: 
1:6cc0702:             return (dtd == null) ? null : dtd.getTypeName();
1:6cc0702:             
1:6cc0702: 		} catch (StandardException t) { throw EmbedResultSet.noStateChangeException(t); }
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:eac0369:      * Set the scale of a parameter.
1:eac0369:      *
1:eac0369:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:eac0369:      * @param scale	The scale
1:eac0369: 	 * @exception SQLException thrown on failure.
1:eac0369:      */
1:eac0369:     private void setScale(int parameterIndex, int scale)
1:eac0369: 		throws SQLException 
1:eac0369: 	{
1:050b616: 		checkStatus();
1:eac0369: 
1:eac0369: 		if (scale < 0)
1:ce40a31: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, scale);
1:eac0369: 		
1:eac0369: 		try {
1:eac0369: 
3:eac0369: 			ParameterValueSet pvs = getParms();
1:eac0369: 
1:eac0369: 			/* JDBC is one-based, DBMS is zero-based */
1:eac0369: 			DataValueDescriptor value = pvs.getParameter(parameterIndex - 1);
1:eac0369: 
1:eac0369: 
1:eac0369: 			int origvaluelen = value.getLength();
1:eac0369: 			((VariableSizeDataValue)
1:eac0369: 						value).setWidth(VariableSizeDataValue.IGNORE_PRECISION, 
1:eac0369: 							scale, 
1:eac0369: 							false);
1:eac0369: 
1:eac0369: 			if (value.getLength() < origvaluelen)
1:eac0369: 			{
1:eac0369: 				activation.addWarning(StandardException.newWarning(SQLState.LANG_VALUE_TRUNCATED, value.getString()));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		} catch (StandardException t) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(t);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b5f2776:     * JDBC 3.0
1:b5f2776:     *
1:eac0369:     * Sets the designated parameter to the given java.net.URL value. The driver
1:eac0369:     * converts this to an SQL DATALINK value when it sends it to the database.
1:eac0369:     *
1:eac0369:     * @param parameterIndex - the first parameter is 1, the second is 2, ...
1:eac0369:     * @param x - the java.net.URL object to be set
1:eac0369:     * @exception SQLException Feature not implemented for now.
1:eac0369: 	*/
1:eac0369: 	public final void setURL(int parameterIndex, java.net.URL x)
1:eac0369:     throws SQLException
1:eac0369: 	{
1:eac0369: 		throw Util.notImplemented();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * JDBC 3.0
1:eac0369:      *
1:b5f2776:      * Retrieves the number, types and properties of this PreparedStatement
1:b5f2776:      * object's parameters.
1:b5f2776:      *
1:b5f2776:      * @return a ParameterMetaData object that contains information about the
1:b5f2776:      * number, types and properties of this PreparedStatement object's
1:b5f2776:      * parameters.
1:b5f2776:      * @exception SQLException if a database access error occurs
1:b5f2776:      */
1:b5f2776:     public final ParameterMetaData getParameterMetaData()
1:b5f2776:             throws SQLException {
1:b5f2776:         checkStatus();
1:8514aa2:         return new EmbedParameterSetMetaData(
1:b5f2776:                 getParms(), preparedStatement.getParameterTypes());
1:b5f2776:     }
1:b5f2776: 
3:eac0369: 	//
1:eac0369: 	// methods to be overridden in subimplementations
1:eac0369: 	// that want to stay within their subimplementation.
1:eac0369: 	//
1:eac0369: 	protected EmbedResultSetMetaData newEmbedResultSetMetaData(ResultDescription resultDesc) {
1:eac0369: 
1:3bfb5f0: 		return factory.newEmbedResultSetMetaData(resultDesc.getColumnInfo());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString() {
1:eac0369: 
1:eac0369: 		if (activation != null)
1:eac0369: 			return activation.getPreparedStatement().getObjectName();
1:eac0369: 		return super.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void transferParameters(EmbedPreparedStatement newStatement) throws SQLException {
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			newStatement.activation.setParameters(getParms(), preparedStatement.getParameterTypes());
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			throw EmbedResultSet.noStateChangeException(se);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:23b4f8b: 	boolean executeStatement(Activation a,
1:eac0369:                      boolean executeQuery, boolean executeUpdate)
1:10cc70b:                      throws SQLException {
1:eac0369: 
1:eac0369: 		checkExecStatus();
1:eac0369: 		checkIfInMiddleOfBatch();
1:eac0369: 		clearResultSets();
1:eac0369: 		return super.executeStatement(a, executeQuery, executeUpdate);
1:eac0369: 	}
1:eac0369: 
1:23b4f8b: 	final SQLException dataTypeConversion(int column, String sourceType)
1:eac0369: 		throws SQLException {
1:8514aa2:         return newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:8514aa2:             getParameterMetaData().getParameterTypeName(column),
1:eac0369: 			sourceType);
1:eac0369: 	}
1:dfce41f:         /**
1:448ecb0:          * This method is used to initialize the BrokeredConnectionControl 
1:448ecb0:          * variable with its implementation. This method will be called in the  
1:448ecb0:          * BrokeredConnectionControl class 
1:448ecb0:          *
1:448ecb0:          * @param control used to call the onStatementClose and 
1:448ecb0:          * onStatementErrorOccurred methods that have logic to 
1:448ecb0:          * raise StatementEvents for the close and error events
1:448ecb0:          * on the PreparedStatement
1:448ecb0:          *
1:448ecb0:          */
1:448ecb0:         public void setBrokeredConnectionControl(BrokeredConnectionControl control) {
1:448ecb0:             bcc = control;
1:448ecb0:         }
1:448ecb0:         
1:dfce41f:         /**
1:448ecb0:          * Method calls onStatementError occurred on the 
1:448ecb0:          * BrokeredConnectionControl class after checking the 
1:448ecb0:          * SQLState of the SQLException thrown.
1:448ecb0:          *
1:712b41b:          * In the case that a XAConnection is involved in the creation of this
1:712b41b:          * PreparedStatement for e.g in the following case
1:448ecb0:          *
1:712b41b:          *      <code>
1:712b41b:          *      XAConnection xaconn = xadatasource.getXAConnection();//where xadatasource is an object of XADataSource
1:712b41b:          *      Connection conn = xaconnection.getConnection();
1:712b41b:          *      PreparedStatement ps = conn.preparedStatement("values 1");
1:712b41b:          *      </code>
1:712b41b:          *
1:712b41b:          * In the above case the PreparedStatement will actually be a 
1:863daa0:          * BrokeredPreparedStatement object. Hence when we call
1:712b41b:          * bcc.onStatementClose and pass the PreparedStatement that caused it
1:712b41b:          * applicationStatement will be the appropriate choice since it will 
1:712b41b:          * contain the appropriate instance of PreparedStatement in each case
1:712b41b:          *
1:448ecb0:          */
1:448ecb0:         
1:448ecb0:         private void checkStatementValidity(SQLException sqle) throws SQLException {
1:448ecb0:             /*
1:448ecb0:              * Check if the exception has occurred because the connection
1:448ecb0:              * associated with the PreparedStatement has been closed
1:448ecb0:              */
1:712b41b:             if(bcc != null && isClosed()) {
1:448ecb0:                 //call the BrokeredConnectionControl interface method
1:448ecb0:                 //onStatementErrorOccurred
1:712b41b:                 bcc.onStatementErrorOccurred((java.sql.PreparedStatement)
1:712b41b:                                                 applicationStatement,sqle);
1:448ecb0:             }
1:448ecb0:             throw sqle;
1:448ecb0:         }
1:448ecb0: 
1:3896fdd:    //jdbc 4.0 methods
1:448ecb0: 
1:eac0369:     /**
1:242c9bd:      * Sets the designated parameter to the given input stream.
1:242c9bd:      * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
1:242c9bd:      * parameter, it may be more practical to send it via a
1:242c9bd:      * <code>java.io.InputStream</code>. Data will be read from the stream as
1:242c9bd:      * needed until end-of-file is reached. The JDBC driver will do any
1:242c9bd:      * necessary conversion from ASCII to the database char format.
1:242c9bd:      *
1:242c9bd:      * <em>Note:</em> This stream object can either be a standard Java stream
1:242c9bd:      * object or your own subclass that implements the standard interface.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:242c9bd:      * @param x the Java input stream that contains the ASCII parameter value
1:242c9bd:      * @throws SQLException if a database access error occurs or this method is
1:242c9bd:      *      called on a closed <code>PreparedStatement</code>
1:242c9bd:      */
1:242c9bd:     public void setAsciiStream(int parameterIndex, InputStream x)
1:242c9bd:             throws SQLException {
1:d45f7d3:         checkAsciiStreamConditions(parameterIndex);
1:242c9bd:         java.io.Reader asciiStream = null;
1:242c9bd: 
1:242c9bd:         if (x != null) {
1:242c9bd:             // Use ISO-8859-1 and not US-ASCII as JDBC seems to define
1:242c9bd:             // ASCII as 8 bits. US-ASCII is 7.
1:242c9bd:             try {
1:242c9bd:                 asciiStream = new java.io.InputStreamReader(x, "ISO-8859-1");
1:242c9bd:             } catch (java.io.UnsupportedEncodingException uee) {
1:242c9bd:                 throw new SQLException(uee.getMessage());
1:242c9bd:             }
1:242c9bd:         }
1:242c9bd: 
1:242c9bd:         setCharacterStreamInternal(parameterIndex, asciiStream, true, -1);
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:242c9bd:      * Sets the designated parameter to the given <code>Reader</code> object.
1:242c9bd:      * When a very large UNICODE value is input to a LONGVARCHAR parameter, it
1:242c9bd:      * may be more practical to send it via a <code>java.io.Reader</code>
1:242c9bd:      * object. The data will be read from the stream as needed until
1:242c9bd:      * end-of-file is reached. The JDBC driver will do any necessary conversion
1:242c9bd:      * from UNICODE to the database char format.
1:242c9bd:      *
1:242c9bd:      * <em>Note:</em> This stream object can either be a standard Java stream
1:242c9bd:      * object or your own subclass that implements the standard interface.
1:242c9bd:      *
1:242c9bd:      * Using this lengthless overload is not less effective than using one
1:242c9bd:      * where the stream length is specified, but since there is no length
1:242c9bd:      * specified, the exact length check will not be performed.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:242c9bd:      * @param reader the <code>java.io.Reader</code> object that contains the
1:242c9bd:      *      Unicode data
1:242c9bd:      * @throws SQLException if a database access error occurs or this method is
1:242c9bd:      *      called on a closed <code>PreparedStatement</code>
1:242c9bd:      */
1:242c9bd:     public void setCharacterStream(int parameterIndex, Reader reader)
1:242c9bd:             throws SQLException {
1:d45f7d3:         checkCharacterStreamConditions(parameterIndex);
1:242c9bd:         setCharacterStreamInternal(parameterIndex, reader,
1:242c9bd:                                    true, -1);
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:242c9bd:      * Sets the designated parameter to a <code>Reader</code> object.
1:242c9bd:      * This method differs from the <code>setCharacterStream(int,Reader)</code>
1:242c9bd:      * method because it informs the driver that the parameter value should be
1:242c9bd:      * sent to the server as a <code>CLOB</code>. When the
1:242c9bd:      * <code>setCharacterStream</code> method is used, the driver may have to
1:242c9bd:      * do extra work to determine whether the parameter data should be sent to
1:242c9bd:      * the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex index of the first parameter is 1, the second is
1:242c9bd:      *      2, ...
1:242c9bd:      * @param reader an object that contains the data to set the parameter
1:242c9bd:      *      value to.
1:242c9bd:      * @throws SQLException if a database access error occurs, this method is
1:242c9bd:      *      called on a closed PreparedStatementor if parameterIndex does not
1:242c9bd:      *      correspond to a parameter marker in the SQL statement
1:242c9bd:      */
1:242c9bd:     public void setClob(int parameterIndex, Reader reader)
1:242c9bd:             throws SQLException {
1:242c9bd:         checkClobConditions(parameterIndex);
1:242c9bd:         setCharacterStreamInternal(parameterIndex, reader, true, -1);
1:242c9bd:     }
1:242c9bd: 
1:eac0369:     /**
1:3896fdd:      * Sets the designated parameter to a Reader object.
1:eac0369:      *
1:3896fdd:      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1:3896fdd:      * @param reader An object that contains the data to set the parameter value to.
1:3896fdd:      * @param length the number of characters in the parameter data.
1:3896fdd:      * @throws SQLException if parameterIndex does not correspond to a parameter
1:3896fdd:      * marker in the SQL statement, or if the length specified is less than zero.
1:eac0369:      *
1:eac0369:      */
1:eac0369: 
1:eac0369:     
1:3896fdd:     public void setClob(int parameterIndex, Reader reader, long length)
1:3896fdd:     throws SQLException{
1:242c9bd:         checkClobConditions(parameterIndex);
1:242c9bd:         setCharacterStreamInternal(parameterIndex, reader, false, length);
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:242c9bd:      * Sets the designated parameter to a <code>InputStream</code> object.
1:242c9bd:      * This method differs from the <code>setBinaryStream(int, InputStream)
1:242c9bd:      * </code>  method because it informs the driver that the parameter value
1:242c9bd:      * should be sent to the server as a <code>BLOB</code>. When the
1:242c9bd:      * <code>setBinaryStream</code> method is used, the driver may have to do
1:242c9bd:      * extra work to determine whether the parameter data should be sent to the
1:242c9bd:      * server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex index of the first parameter is 1, the second is
1:242c9bd:      *      2, ...
1:242c9bd:      * @param inputStream an object that contains the data to set the parameter
1:242c9bd:      *      value to.
1:242c9bd:      * @throws SQLException if a database access error occurs, this method is
1:242c9bd:      *      called on a closed <code>PreparedStatement</code> or if
1:242c9bd:      *      <code>parameterIndex</code> does not correspond to a parameter
1:242c9bd:      *      marker in the SQL statement
1:242c9bd:      */
1:242c9bd:     public void setBlob(int parameterIndex, InputStream inputStream)
1:242c9bd:             throws SQLException {
1:242c9bd:         checkBlobConditions(parameterIndex);
1:242c9bd:         setBinaryStreamInternal(parameterIndex, inputStream, true, -1);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:3896fdd:      * Sets the designated parameter to a InputStream object.
1:eac0369:      *
1:3896fdd:      * @param parameterIndex index of the first parameter is 1,
1:3896fdd:      * the second is 2, ...
1:3896fdd:      * @param inputStream An object that contains the data to set the parameter
1:3896fdd:      * value to.
1:3896fdd:      * @param length the number of bytes in the parameter data.
1:3896fdd:      * @throws SQLException if parameterIndex does not correspond
1:3896fdd:      * to a parameter marker in the SQL statement,  if the length specified
1:3896fdd:      * is less than zero or if the number of bytes in the inputstream does not match
1:3896fdd:      * the specfied length.
1:eac0369:      */
1:eac0369: 
1:eac0369:     
1:3896fdd:     public void setBlob(int parameterIndex, InputStream inputStream, long length)
1:3896fdd:     throws SQLException{
1:242c9bd:         checkBlobConditions(parameterIndex);
1:242c9bd:         setBinaryStreamInternal(parameterIndex, inputStream, false, length);
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     /**
1:242c9bd:      * Check general (pre)conditions for setBlob methods.
1:242c9bd:      *
1:242c9bd:      * @param parameterIndex 1-based index of the parameter.
1:242c9bd:      */
1:242c9bd:     private final void checkBlobConditions(int parameterIndex)
1:242c9bd:             throws SQLException {
1:050b616:         checkStatus();
1:242c9bd:         if (getParameterJDBCType(parameterIndex) != Types.BLOB) {
1:242c9bd:             throw dataTypeConversion(parameterIndex, "java.sql.Blob");
1:242c9bd:         }
1:eac0369:     }
1:f9a0689: 
1:b5f2776:     public final void setRowId(int parameterIndex, RowId x) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNString(int index, String value) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNCharacterStream(int parameterIndex, Reader value)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNCharacterStream(int index, Reader value, long length) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(int parameterIndex, Reader reader)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(int index, NClob value) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setNClob(int parameterIndex, Reader reader, long length)
1:b5f2776:             throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:b5f2776:     public final void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
1:b5f2776:         throw Util.notImplemented();
1:b5f2776:     }
1:b5f2776: 
1:f9a0689:     public final long getVersionCounter() throws SQLException {
1:f9a0689:         return preparedStatement.getVersionCounter();
1:f9a0689:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, scale);
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:   				batchStatements = new Vector<Object>();
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
0: public abstract class EmbedPreparedStatement
commit:6cc0702
/////////////////////////////////////////////////////////////////////////
1: 		if the parameter index is out of range. The parameterIndex is 1-based.
1: 		throws SQLException
1:     {
1:         try {
1:             DataTypeDescriptor dtd = preparedStatement.getParameterType( parameterIndex-1 );
1:             return (dtd == null) ? Types.OTHER : dtd.getTypeId().getJDBCTypeId();
1:             
1: 		} catch (StandardException t) { throw EmbedResultSet.noStateChangeException(t); }
/////////////////////////////////////////////////////////////////////////
1:             throws SQLException
1:     {
1:         try {
1:             DataTypeDescriptor dtd = preparedStatement.getParameterType( parameterIndex-1 );
1: 
1:             return (dtd == null) ? null : dtd.getTypeName();
1:             
1: 		} catch (StandardException t) { throw EmbedResultSet.noStateChangeException(t); }
commit:4c2fc4a
/////////////////////////////////////////////////////////////////////////
1: 		Util.checkForSupportedDataType(sqlType);
/////////////////////////////////////////////////////////////////////////
1: 		Util.checkForSupportedDataType(targetSqlType);
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:20b2fd9
/////////////////////////////////////////////////////////////////////////
1:             return (int) executeLargeUpdate();
1:         }
1: 
1:     /**
1:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:      * SQL statements that return nothing such as SQL DDL statements
1:      * can be executed. For use with
1:      * statements which may touch more than Integer.MAX_VALUE rows.
1:      */
1:         public final long executeLargeUpdate() throws SQLException {
1:             return updateCount;
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
0:             return (int) updateCount;
commit:9495437
/////////////////////////////////////////////////////////////////////////
1: 	  checkStatus();
1: 	  // need to synchronized to ensure that two threads
1: 	  // don't both create a Vector at the same time. This
1: 	  // would lead to one of the set of parameters being thrown
1: 	  // away
1:   	  synchronized (getConnectionSynchronization()) {
1:   			if (batchStatements == null)
0:   				batchStatements = new Vector();
1:           //get a clone of the parameterValueSet and save it in the vector
1:           //which will be used later on at the time of batch execution.
1:           //This way we will get a copy of the current statement's parameter
1:           //values rather than a pointer to the statement's parameter value
1:           //set which will change with every new statement in the batch.
1:           batchStatements.add(getParms().getClone());
1:           clearParameters();
1:   	  }
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
0:         // need to synchronize to ensure that two threads
0:         // don't both create a Vector at the same time. This
0:         // would lead to one of the set of parameters being thrown
0:         // away
0:         synchronized (getConnectionSynchronization()) {
0:             if (batchStatements == null)
0:                 batchStatements = new Vector();
1:             try {
0:                 //get a clone of the parameterValueSet and save it in the vector
0:                 //which will be used later on at the time of batch execution.
0:                 //This way we will get a copy of the current statement's parameter
0:                 //values rather than a pointer to the statement's parameter value
0:                 //set which will change with every new statement in the batch.
0:                 batchStatements.add(getParms().getClone());
0:                 clearParameters();
1:             } catch (StandardException t) {
1:                 throw EmbedResultSet.noStateChangeException(t);
1:             }
1:         }
commit:10608cf
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
/////////////////////////////////////////////////////////////////////////
1: 	/*
0: 	** Methods using BigDecimal, moved back into EmbedPreparedStatement
0: 	** since our small device implementation now requires CDC/FP 1.1, which
0:     ** supports BigDecimal.
1: 	*/
1: 	/**
1:      * Set a parameter to a java.lang.BigDecimal value.  
1:      * The driver converts this to a SQL NUMERIC value when
1:      * it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setBigDecimal(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (x instanceof BigDecimal) {
1: 			setBigDecimal(parameterIndex, (BigDecimal) x);
1: 		}
1: 		if (x instanceof BigInteger) {
1: 			setBigDecimal(parameterIndex, new BigDecimal( (BigInteger) x ) );
1: 			return;
1:         }
commit:ff02576
/////////////////////////////////////////////////////////////////////////
commit:59f54f8
/////////////////////////////////////////////////////////////////////////
0: 		if (x instanceof java.math.BigInteger) {
0: 			setLong(parameterIndex, ((java.math.BigInteger) x).longValue() );
1: 			return;
1: 		}
1: 		if (x instanceof java.util.Date) {
1: 			setTimestamp(parameterIndex, new Timestamp(  ((java.util.Date) x).getTime() ) );
1: 			return;
1: 		}
1: 		if (x instanceof java.util.Calendar) {
1: 			setTimestamp(parameterIndex, new Timestamp(  ((java.util.Calendar) x).getTime().getTime() ) );
1: 			return;
1: 		}
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:448ecb0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.BrokeredConnectionControl;
/////////////////////////////////////////////////////////////////////////
1:         
1:         private BrokeredConnectionControl bcc=null;
/////////////////////////////////////////////////////////////////////////
0:                 if (bcc!=null)
0:                         bcc.onStatementClose(this);
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 executeStatement(activation, true, false);
1:             } catch(SQLException sqle) {
1:                 checkStatementValidity(sqle);
1:             }
1:             
1:             if (SanityManager.DEBUG) {
1:                 if (results == null)
1:                     SanityManager.THROWASSERT("no results returned on executeQuery()");
1:             }
1:             
1:             return results;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         public final int executeUpdate() throws SQLException {
1:             try {
1:                 executeStatement(activation, false, true);
1:             } catch(SQLException sqle) {
1:                 checkStatementValidity(sqle);
1:             }
0:             return updateCount;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         public final boolean execute() throws SQLException {
1:             boolean ret=false;
1:             try{
1:                 ret = executeStatement(activation, false, false);
1:             } catch(SQLException sqle) {
1:                 checkStatementValidity(sqle);
1:             }
1:             return ret;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         /*
1:          * This method is used to initialize the BrokeredConnectionControl 
1:          * variable with its implementation. This method will be called in the  
1:          * BrokeredConnectionControl class 
1:          *
1:          * @param control used to call the onStatementClose and 
1:          * onStatementErrorOccurred methods that have logic to 
1:          * raise StatementEvents for the close and error events
1:          * on the PreparedStatement
1:          *
1:          */
1:         public void setBrokeredConnectionControl(BrokeredConnectionControl control) {
1:             bcc = control;
1:         }
1:         
1:         /*
1:          * Method calls onStatementError occurred on the 
1:          * BrokeredConnectionControl class after checking the 
1:          * SQLState of the SQLException thrown.
1:          */
1:         
1:         private void checkStatementValidity(SQLException sqle) throws SQLException {
1:             /*
0:              * The subclass of SQLException thrown when the SQLState class value is
0:              * '42'. This indicates that the in-progress query has violated SQL
0:              * syntax rules.
1:              *
1:              * Check if the exception has occurred because the connection
1:              * associated with the PreparedStatement has been closed
1:              *
0:              * This exception has the SQLState of 08003 which is represented
0:              * by the constant SQLState.ERROR_CLOSE
1:              */
0:             if(bcc != null && (sqle.getSQLState().equals("08003")
0:             || sqle.getSQLState().startsWith(SQLState.LSE_COMPILATION_PREFIX)) ) {
1:                 //call the BrokeredConnectionControl interface method
1:                 //onStatementErrorOccurred
0:                 bcc.onStatementErrorOccurred(this,sqle);
1:             }
1:             throw sqle;
1:         }
1:         
1:                
/////////////////////////////////////////////////////////////////////////
commit:3bfb5f0
/////////////////////////////////////////////////////////////////////////
1: 		return factory.newEmbedResultSetMetaData(resultDesc.getColumnInfo());
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1: 			//information in lcc will not work as it can be tampered by a nested transaction
commit:616634f
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the ParameterValueSet from the activation.
1: 	 * 
1: 	 * The caller of this method should be aware that the
1: 	 * activation associated with a Statement can change
1: 	 * and hence the ParameterValueSet returned by this
1: 	 * call should not be hold onto. An example of this
1: 	 * can be seen in EmbedCallableStatement.executeStatement
1: 	 * where at the beginning of the method, we check the
1: 	 * validity of the parameters. But we donot keep the
1: 	 * parameters in a local variable to use later. The reason
1: 	 * for this is that the next call in the method, 
1: 	 * super.executeStatement can recompile the statement and 
1: 	 * create a new activation if the statement plan has been 
1: 	 * invalidated. To account for this possibility, 
1: 	 * EmbedCallableStatement.executeStatement makes 
1: 	 * another call to get the ParameterValueSet before stuffing 
1: 	 * the output parameter value into the ParameterValueSet
1: 	 * object.
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception java.sql.SQLFeatureNotSupportedException if Derby does not
1:      * support the type specified in the {@code sqlType} parameter
commit:5465561
/////////////////////////////////////////////////////////////////////////
commit:863daa0
/////////////////////////////////////////////////////////////////////////
1:      * BrokeredPreparedStatement object. Hence when we call
/////////////////////////////////////////////////////////////////////////
1:          * BrokeredPreparedStatement object. Hence when we call
commit:8514aa2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                getParameterMetaData().getParameterTypeName(
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return new EmbedParameterSetMetaData(
/////////////////////////////////////////////////////////////////////////
1:         return newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH,
1:             getParameterMetaData().getParameterTypeName(column),
commit:b5f2776
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Array;
1: import java.sql.NClob;
1: import java.sql.ParameterMetaData;
1: import java.sql.Ref;
1: import java.sql.RowId;
1: import java.sql.SQLXML;
/////////////////////////////////////////////////////////////////////////
1:  * It supports JDBC 4.1.
1: public class EmbedPreparedStatement extends EmbedStatement
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Set a REF(&lt;structured-type&gt;) parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @param x an object representing data of an SQL REF Type
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setRef(int i, Ref x) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Set an Array parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @param x an object representing an SQL array
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setArray(int i, Array x) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 3.0
1:      *
1:      * Retrieves the number, types and properties of this PreparedStatement
1:      * object's parameters.
1:      *
1:      * @return a ParameterMetaData object that contains information about the
1:      * number, types and properties of this PreparedStatement object's
1:      * parameters.
1:      * @exception SQLException if a database access error occurs
1:      */
1:     public final ParameterMetaData getParameterMetaData()
1:             throws SQLException {
1:         checkStatus();
0:         return new EmbedParameterMetaData30(
1:                 getParms(), preparedStatement.getParameterTypes());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public final void setRowId(int parameterIndex, RowId x) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNString(int index, String value) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNCharacterStream(int parameterIndex, Reader value)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNCharacterStream(int index, Reader value, long length) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNClob(int index, NClob value) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setNClob(int parameterIndex, Reader reader, long length)
1:             throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
1:     public final void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
1:         throw Util.notImplemented();
1:     }
1: 
commit:f17b81f
/////////////////////////////////////////////////////////////////////////
0: public class EmbedPreparedStatement
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0:           batchStatements.add(getParms().getClone());
commit:e24d8ef
/////////////////////////////////////////////////////////////////////////
1:      * @deprecated
commit:dfce41f
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         /**
/////////////////////////////////////////////////////////////////////////
1:         /**
commit:3634d6e
/////////////////////////////////////////////////////////////////////////
0: 	private EngineParameterMetaData getEmbedParameterSetMetaData()
commit:10cc70b
/////////////////////////////////////////////////////////////////////////
1:                                      getParameterSQLType(parameterIndex));
/////////////////////////////////////////////////////////////////////////
1:                 utfIn = new ReaderToUTF8Stream(reader, usableLength,
0:                         truncationLength, getParameterSQLType(parameterIndex));
1:                 // Create a stream without exactness checks,
1:                 // but with a maximum limit.
1:                 utfIn = new ReaderToUTF8Stream(reader, colWidth,
0:                                 getParameterSQLType(parameterIndex));
1:             // the maximum length for the column. 
1:             // This is okay, based on the observation that
/////////////////////////////////////////////////////////////////////////
1:             RawToBinaryFormatStream rawStream;
0:                 // Force length to -1 for good measure.
1:                 DataTypeDescriptor dtd[] = 
1:                     preparedStatement.getParameterTypes();
1:                 rawStream = new RawToBinaryFormatStream(x,
1:                         dtd[parameterIndex -1].getMaximumWidth(),
1:                         dtd[parameterIndex -1].getTypeName());
1:             } else {
1:                 rawStream = new RawToBinaryFormatStream(x, (int)length);
1:                     rawStream, (int)length);
/////////////////////////////////////////////////////////////////////////
1:      * Return the SQL type name for the parameter.
1:      *
1:      * @param parameterIndex the 1-based index of the parameter
1:      * @return SQL name of the parameter
1:      * @throws SQLException if parameter is out of range
1:      */
1:     protected final String getParameterSQLType(int parameterIndex)
1:             throws SQLException {
0:         DataTypeDescriptor[] pTypes = getTypes(parameterIndex);
0:         return pTypes[parameterIndex-1].getTypeName();
1:     }
1: 
1:     /**
commit:27190db
/////////////////////////////////////////////////////////////////////////
1: 		// Byte and Short were added to the table in JDBC 4.0.
/////////////////////////////////////////////////////////////////////////
1: 		if (x instanceof Byte) {
1: 			setByte(parameterIndex, ((Byte) x).byteValue());
1: 			return;
1: 		}
1: 		if (x instanceof Short) {
1: 			setShort(parameterIndex, ((Short) x).shortValue());
1: 			return;
1: 		}
commit:d45f7d3
/////////////////////////////////////////////////////////////////////////
1:         checkAsciiStreamConditions(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         checkCharacterStreamConditions(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:      * Check general preconditions for setCharacterStream methods.
1:     private final void checkCharacterStreamConditions(int parameterIndex)
1:         if (!DataTypeDescriptor.isCharacterStreamAssignable(jdbcTypeId)) {
1:             throw dataTypeConversion(parameterIndex, "java.io.Reader");
1:         }
1:     }
1: 
1:     /**
1:      * Check general preconditions for setAsciiStream methods.
1:      *
1:      * @param parameterIndex 1-based index of the parameter.
1:      */
1:     private final void checkAsciiStreamConditions(int parameterIndex)
1:             throws SQLException {
1:         checkStatus();
1:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
1:         if (!DataTypeDescriptor.isAsciiStreamAssignable(jdbcTypeId)) {
1:             throw dataTypeConversion(parameterIndex,
1:                                      "java.io.InputStream(ASCII)");
/////////////////////////////////////////////////////////////////////////
1:      * Check general preconditions for setBinaryStream methods.
/////////////////////////////////////////////////////////////////////////
1:         if (!DataTypeDescriptor.isBinaryStreamAssignable(jdbcTypeId)) {
/////////////////////////////////////////////////////////////////////////
1:         checkAsciiStreamConditions(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         checkCharacterStreamConditions(parameterIndex);
commit:242c9bd
/////////////////////////////////////////////////////////////////////////
0:         checkCharacterStreamConditions(parameterIndex,
0:                                         "java.io.InputStream(ASCII)");
/////////////////////////////////////////////////////////////////////////
1:         setCharacterStreamInternal(parameterIndex, r, false, length);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         checkCharacterStreamConditions(parameterIndex, "java.io.Reader");
1:         setCharacterStreamInternal(parameterIndex, reader, false, length);
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Check general (pre)conditions for setXXXStream methods operating on
0:      * character streams.
1:      *
1:      * @param parameterIndex 1-based index of the parameter.
0:      * @param srcDataTypeDesc type description of the source data. Used in
0:      *          error message for data type conversion failure.
1:      */
0:     private final void checkCharacterStreamConditions(int parameterIndex,
0:                                                        String srcDataTypeDesc)
1:             throws SQLException {
1:         checkStatus();
1:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
0:         switch (jdbcTypeId) {
0:             case Types.CHAR:
0:             case Types.VARCHAR:
0:             case Types.LONGVARCHAR:
0:             case Types.CLOB:
0:                 break;
0:             default:
0:                 throw dataTypeConversion(parameterIndex, srcDataTypeDesc);
1:         }
1:     }
1:     /**
1:      * Set the given character stream for the specified parameter.
1:      *
1:      * If <code>lengthLess</code> is <code>true</code>, the following
1:      * conditions are either not checked or verified at the execution time
1:      * of the prepared statement:
1:      * <ol><li>If the stream length is negative.
1:      *     <li>If the stream's actual length equals the specified length.</ol>
1:      * The <code>lengthLess</code> variable was added to differentiate between
1:      * streams with invalid lengths and streams without known lengths.
1:      *
1:      * @param parameterIndex the 1-based index of the parameter to set.
1:      * @param reader the data.
1:      * @param lengthLess tells whether we know the length of the data or not.
1:      * @param length the length of the data. Ignored if <code>lengthLess</code>
1:      *          is <code>true</code>.
1:      */
1:                                             Reader reader,
1:                                             final boolean lengthLess,
1:                                             long length)
1:         // Check for negative length if length is specified.
1:         if (!lengthLess && length < 0)
1:             throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
/////////////////////////////////////////////////////////////////////////
1:         if (!lengthLess && length > Integer.MAX_VALUE)
1:         try {
1:             ReaderToUTF8Stream utfIn;
1:             ParameterValueSet pvs = getParms();
1:             // Need column width to figure out if truncation is needed
1:             DataTypeDescriptor dtd[] = preparedStatement
1:                     .getParameterTypes();
1:             int colWidth = dtd[parameterIndex - 1].getMaximumWidth();
0:             // Default to max column width. This will be used to limit the
0:             // amount of data read when operating on "lengthless" streams.
0:             int usableLength = colWidth;
1:             if (!lengthLess) {
1:                 // We cast the length from long to int. This wouldn't be
1:                 // appropriate if the limit of 2G-1 is decided to be increased
1:                 // at a later stage.
0:                 int intLength = (int)length;
1:                 int truncationLength = 0;
0:                 usableLength = intLength;
1:                 // Currently long varchar does not allow for truncation of
1:                 // trailing blanks.
1:                 // For char and varchar types, current mechanism of
1:                 // materializing when using streams seems fine given their max
1:                 // limits.
1:                 // This change is fix for DERBY-352: Insert of clobs using
1:                 // streams should not materialize the entire stream into memory
1:                 // In case of clobs, the truncation of trailing blanks is
1:                 // factored in when reading from the stream without
1:                 // materializing the entire stream, and so the special casing
1:                 // for clob below.
1:                 if (jdbcTypeId == Types.CLOB)
1:                 {
1: 
1:                     // It is possible that the length of the stream passed in
1:                     // is greater than the column width, in which case the data
1:                     // from the stream needs to be truncated.
1:                     // usableLength is the length of the data from stream that
1:                     // can be inserted which is min(colWidth,length) provided
1:                     // length - colWidth has trailing blanks only
0:                     // we have used intLength into which the length variable had
0:                     // been cast to an int and stored
0:                     if (intLength > colWidth) {
1:                         usableLength = colWidth;
0:                         truncationLength = intLength - usableLength;
1:                     }
1:                 // Create a stream with truncation.
0:                 utfIn = new ReaderToUTF8Stream(reader,
0:                                                usableLength,
0:                                                truncationLength);
1:             } else {
0:                 // Create a stream without exactness checks and truncation.
0:                 utfIn = new ReaderToUTF8Stream(reader,
0:                                             ReaderToUTF8Stream.UNKNOWN_LENGTH,
0:                                             0);
1:             // JDBC is one-based, DBMS is zero-based.
1:             // Note that for lengthless stream, usableLength will be
0:             // Integer.MIN_VALUE. This is okay, based on the observation that
1:             // setValue does not use the value for anything at all.
/////////////////////////////////////////////////////////////////////////
1:      * Sets the designated parameter to the given input stream.
1:      * When a very large binary value is input to a <code>LONGVARBINARY</code>
1:      * parameter, it may be more practical to send it via a
1:      * <code>java.io.InputStream</code> object. The data will be read from the
1:      * stream as needed until end-of-file is reached.
1:      *
1:      * <em>Note:</em> This stream object can either be a standard Java stream
1:      * object or your own subclass that implements the standard interface.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setBinaryStream(int parameterIndex, InputStream x)
1:             throws SQLException {
1:         checkBinaryStreamConditions(parameterIndex);
1:         setBinaryStreamInternal(parameterIndex, x, true, -1);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         checkBinaryStreamConditions(parameterIndex);
1:         setBinaryStreamInternal(parameterIndex, x, false, length);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the given stream for the specified parameter.
1:      *
1:      * If <code>lengthLess</code> is <code>true</code>, the following
1:      * conditions are either not checked or verified at the execution time
1:      * of the prepared statement:
1:      * <ol><li>If the stream length is negative.
1:      *     <li>If the stream's actual length equals the specified length.</ol>
1:      * The <code>lengthLess</code> variable was added to differentiate between
1:      * streams with invalid lengths and streams without known lengths.
1:      *
1:      * @param parameterIndex the 1-based index of the parameter to set.
1:      * @param x the data.
1:      * @param lengthLess tells whether we know the length of the data or not.
1:      * @param length the length of the data. Ignored if <code>lengthLess</code>
1:      *          is <code>true</code>.
1:      */
1:                                          final boolean lengthLess, long length)
1:         if ( !lengthLess && length < 0 )
/////////////////////////////////////////////////////////////////////////
1:         if ( !lengthLess && length > Integer.MAX_VALUE ) {
0:             // If stream is lengthless, force length to -1 to get the expected
0:             // behavior in RawToBinaryFormatStream.
1:             if (lengthLess) {
0:                 length = -1;
1:             }
1:             getParms().getParameterForSet(parameterIndex - 1).setValue(
0:                     new RawToBinaryFormatStream(x, (int)length), (int)length);
1:     /**
0:      * Check general (pre)conditions for setXXXStream methods operating on
0:      * binary streams.
1:      *
1:      * @param parameterIndex 1-based index of the parameter.
1:      */
1:     private final void checkBinaryStreamConditions(int parameterIndex)
1:             throws SQLException {
1:         checkStatus();
1:         int jdbcTypeId = getParameterJDBCType(parameterIndex);
0:         switch (jdbcTypeId) {
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:         case Types.LONGVARBINARY:
0:         case Types.BLOB:
0:             break;
0:         default:
1:             throw dataTypeConversion(parameterIndex, "java.io.InputStream");
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         checkBlobConditions(i);
/////////////////////////////////////////////////////////////////////////
1:             setBinaryStreamInternal(i, x.getBinaryStream(), false,
1:                     streamLength);
1:      * Check general (pre)conditions for setClob methods.
1:      *
1:      * @param parameterIndex 1-based index of the parameter.
1:      */
1:     private final void checkClobConditions(int parameterIndex)
1:             throws SQLException {
1:         checkStatus();
1:         if (getParameterJDBCType(parameterIndex) != Types.CLOB) {
1:             throw dataTypeConversion(parameterIndex, "java.sql.Clob");
1:         }
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:         checkClobConditions(i);
/////////////////////////////////////////////////////////////////////////
1:             setCharacterStreamInternal(i, x.getCharacterStream(),
1:                                        false, streamLength);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the designated parameter to the given input stream.
1:      * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
1:      * parameter, it may be more practical to send it via a
1:      * <code>java.io.InputStream</code>. Data will be read from the stream as
1:      * needed until end-of-file is reached. The JDBC driver will do any
1:      * necessary conversion from ASCII to the database char format.
1:      *
1:      * <em>Note:</em> This stream object can either be a standard Java stream
1:      * object or your own subclass that implements the standard interface.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the Java input stream that contains the ASCII parameter value
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setAsciiStream(int parameterIndex, InputStream x)
1:             throws SQLException {
0:         checkCharacterStreamConditions(parameterIndex,
0:                                         "java.io.InputStream(ASCII)");
1:         java.io.Reader asciiStream = null;
1: 
1:         if (x != null) {
1:             // Use ISO-8859-1 and not US-ASCII as JDBC seems to define
1:             // ASCII as 8 bits. US-ASCII is 7.
1:             try {
1:                 asciiStream = new java.io.InputStreamReader(x, "ISO-8859-1");
1:             } catch (java.io.UnsupportedEncodingException uee) {
1:                 throw new SQLException(uee.getMessage());
1:             }
1:         }
1: 
1:         setCharacterStreamInternal(parameterIndex, asciiStream, true, -1);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given <code>Reader</code> object.
1:      * When a very large UNICODE value is input to a LONGVARCHAR parameter, it
1:      * may be more practical to send it via a <code>java.io.Reader</code>
1:      * object. The data will be read from the stream as needed until
1:      * end-of-file is reached. The JDBC driver will do any necessary conversion
1:      * from UNICODE to the database char format.
1:      *
1:      * <em>Note:</em> This stream object can either be a standard Java stream
1:      * object or your own subclass that implements the standard interface.
1:      *
1:      * Using this lengthless overload is not less effective than using one
1:      * where the stream length is specified, but since there is no length
1:      * specified, the exact length check will not be performed.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param reader the <code>java.io.Reader</code> object that contains the
1:      *      Unicode data
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setCharacterStream(int parameterIndex, Reader reader)
1:             throws SQLException {
0:         checkCharacterStreamConditions(parameterIndex, "java.io.Reader");
1:         setCharacterStreamInternal(parameterIndex, reader,
1:                                    true, -1);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a <code>Reader</code> object.
1:      * This method differs from the <code>setCharacterStream(int,Reader)</code>
1:      * method because it informs the driver that the parameter value should be
1:      * sent to the server as a <code>CLOB</code>. When the
1:      * <code>setCharacterStream</code> method is used, the driver may have to
1:      * do extra work to determine whether the parameter data should be sent to
1:      * the server as a <code>LONGVARCHAR</code> or a <code>CLOB</code>.
1:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is
1:      *      2, ...
1:      * @param reader an object that contains the data to set the parameter
1:      *      value to.
1:      * @throws SQLException if a database access error occurs, this method is
1:      *      called on a closed PreparedStatementor if parameterIndex does not
1:      *      correspond to a parameter marker in the SQL statement
1:      */
1:     public void setClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         checkClobConditions(parameterIndex);
1:         setCharacterStreamInternal(parameterIndex, reader, true, -1);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         checkClobConditions(parameterIndex);
1:         setCharacterStreamInternal(parameterIndex, reader, false, length);
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a <code>InputStream</code> object.
1:      * This method differs from the <code>setBinaryStream(int, InputStream)
1:      * </code>  method because it informs the driver that the parameter value
1:      * should be sent to the server as a <code>BLOB</code>. When the
1:      * <code>setBinaryStream</code> method is used, the driver may have to do
1:      * extra work to determine whether the parameter data should be sent to the
1:      * server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
1:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is
1:      *      2, ...
1:      * @param inputStream an object that contains the data to set the parameter
1:      *      value to.
1:      * @throws SQLException if a database access error occurs, this method is
1:      *      called on a closed <code>PreparedStatement</code> or if
1:      *      <code>parameterIndex</code> does not correspond to a parameter
1:      *      marker in the SQL statement
1:      */
1:     public void setBlob(int parameterIndex, InputStream inputStream)
1:             throws SQLException {
1:         checkBlobConditions(parameterIndex);
1:         setBinaryStreamInternal(parameterIndex, inputStream, true, -1);
/////////////////////////////////////////////////////////////////////////
1:         checkBlobConditions(parameterIndex);
1:         setBinaryStreamInternal(parameterIndex, inputStream, false, length);
1:     }
1: 
1:     /**
1:      * Check general (pre)conditions for setBlob methods.
1:      *
1:      * @param parameterIndex 1-based index of the parameter.
1:      */
1:     private final void checkBlobConditions(int parameterIndex)
1:             throws SQLException {
1:         if (getParameterJDBCType(parameterIndex) != Types.BLOB) {
1:             throw dataTypeConversion(parameterIndex, "java.sql.Blob");
1:     }
commit:fe8446d
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * Sets the designated parameter to SQL <code>NULL</code>.
1:      * This version of the method <code>setNull</code> should
1:      * be used for user-defined types and REF type parameters.  Examples
1:      * of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and
1:      * named array types.
1:      *
1:      * @param paramIndex the first parameter is 1, the second is 2, ...
1:      * @param sqlType a value from <code>java.sql.Types</code>
1:      * @param typeName the fully-qualified name of an SQL user-defined type;
1:      *  ignored if the parameter is not a user-defined type or REF
1:      * @exception SQLException if a database access error occurs or
1:      * this method is called on a closed <code>PreparedStatement</code>
0:      * @exception SQLFeatureNotSupportedException if <code>sqlType</code> is
0:      * a <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>,
0:      * <code>DATALINK</code>, <code>JAVA_OBJECT</code>, <code>NCHAR</code>,
0:      * <code>NCLOB</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>,
0:      *  <code>REF</code>, <code>ROWID</code>, <code>SQLXML</code>
0:      * or  <code>STRUCT</code> data type and the JDBC driver does not support
0:      * this data type or if the JDBC driver does not support this method
1:      *
1:     public void setNull(int paramIndex,
1:         int sqlType,
1:         String typeName)
1:         throws SQLException {
1:         setNull(paramIndex,sqlType);
1:     }
commit:dbbf9ff
/////////////////////////////////////////////////////////////////////////
0: 		checkForSupportedDataType(sqlType);
/////////////////////////////////////////////////////////////////////////
0: 		checkForSupportedDataType(targetSqlType);
1: 
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:         checkForSupportedDataType(targetSqlType);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Checks whether a data type is supported for
0:      * <code>setObject(int, Object, int)</code> and
0:      * <code>setObject(int, Object, int, int)</code>.
1:      *
0:      * @param dataType the data type to check
0:      * @exception SQLException if the type is not supported
1:      */
0:     private void checkForSupportedDataType(int dataType) throws SQLException {
1: 
0:         // JDBC 4.0 javadoc for setObject() says:
1:         //
0:         // Throws: (...) SQLFeatureNotSupportedException - if
0:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
0:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
0:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
0:         // not support this data type
1:         //
0:         // Of these types, we only support BLOB, CLOB and
0:         // (sort of) JAVA_OBJECT.
1: 
0:         switch (dataType) {
0:         case Types.ARRAY:
0:         case JDBC30Translation.DATALINK:
0:         case JDBC40Translation.NCHAR:
0:         case JDBC40Translation.NCLOB:
0:         case JDBC40Translation.NVARCHAR:
0:         case JDBC40Translation.LONGNVARCHAR:
0:         case Types.REF:
0:         case JDBC40Translation.ROWID:
0:         case JDBC40Translation.SQLXML:
0:         case Types.STRUCT:
0:             throw newSQLException(SQLState.DATA_TYPE_NOT_SUPPORTED,
0:                                   Util.typeName(dataType));
1:         }
1:     }
1: 
commit:c511410
/////////////////////////////////////////////////////////////////////////
1:     public final void setAsciiStream(int parameterIndex, InputStream x, long length)
/////////////////////////////////////////////////////////////////////////
1:      * We do this inefficiently and read it all in here. The target type
1:      * is assumed to be a String.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1: 
1:     public final void setAsciiStream(int parameterIndex, InputStream x, int length)
1:     throws SQLException {
1:         setAsciiStream(parameterIndex,x,(long)length);
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 			  long length) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When a very large UNICODE value is input to a LONGVARCHAR
1:      * parameter, it may be more practical to send it via a
1:      * java.io.Reader. JDBC will read the data from the stream
1:      * as needed, until it reaches end-of-file.  The JDBC driver will
1:      * do any necessary conversion from UNICODE to the database char format.
1:      *
1:      * <P><B>Note:</B> This stream object can either be a standard
1:      * Java stream object or your own subclass that implements the
1:      * standard interface.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param reader the java reader which contains the UNICODE data
1:      * @param length the number of characters in the stream
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final void setCharacterStream(int parameterIndex,
1:         java.io.Reader reader,
1:         int length) throws SQLException {
1:         setCharacterStream(parameterIndex,reader,(long)length);
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:      * sets the parameter to the Binary stream
1:     public final void setBinaryStream(int parameterIndex, InputStream x, long length)
1: 	    throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * sets the parameter to the binary stream
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1:     public final void setBinaryStream(int parameterIndex, InputStream x, int length)
1:     throws SQLException {
1:         setBinaryStream(parameterIndex,x,(long)length);
1:     }
1: 
commit:7eed914
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// PreparedStatement is poolable by default
1: 		isPoolable = true;
/////////////////////////////////////////////////////////////////////////
commit:050b616
/////////////////////////////////////////////////////////////////////////
1: 		checkStatus();
/////////////////////////////////////////////////////////////////////////
1:     private void setCharacterStreamInternal(int parameterIndex,
/////////////////////////////////////////////////////////////////////////
1: 		checkStatus();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void setBinaryStreamInternal(int parameterIndex, InputStream x,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
/////////////////////////////////////////////////////////////////////////
1:         checkStatus();
commit:712b41b
/////////////////////////////////////////////////////////////////////////
1: 	 * Additional close to close our activation.
1: 	 * In the case that a XAConnection is involved in the creation of this
1: 	 * PreparedStatement for e.g in the following case
1: 	 *
1: 	 *      <code>
1: 	 *      XAConnection xaconn = xadatasource.getXAConnection();//where xadatasource is an object of XADataSource
1: 	 *      Connection conn = xaconnection.getConnection();
1: 	 *      PreparedStatement ps = conn.preparedStatement("values 1");
1: 	 *      </code>
1: 	 *
1: 	 * In the above case the PreparedStatement will actually be a 
0: 	 * BrokeredPreparedStatement40 object. Hence when we call 
1: 	 * bcc.onStatementClose and pass the PreparedStatement that caused it
1: 	 * applicationStatement will be the appropriate choice since it will 
1: 	 * contain the appropriate instance of PreparedStatement in each case
1: 	 *
1: 	 * @throws SQLException upon failure
1: 	 *
1: 		if (bcc!=null) {
1: 			java.sql.PreparedStatement ps_app = 
1: 				(java.sql.PreparedStatement)applicationStatement;
1: 			bcc.onStatementClose(ps_app);
1: 		}
/////////////////////////////////////////////////////////////////////////
1:          *
1:          * In the case that a XAConnection is involved in the creation of this
1:          * PreparedStatement for e.g in the following case
1:          *
1:          *      <code>
1:          *      XAConnection xaconn = xadatasource.getXAConnection();//where xadatasource is an object of XADataSource
1:          *      Connection conn = xaconnection.getConnection();
1:          *      PreparedStatement ps = conn.preparedStatement("values 1");
1:          *      </code>
1:          *
1:          * In the above case the PreparedStatement will actually be a 
0:          * BrokeredPreparedStatement40 object. Hence when we call 
1:          * bcc.onStatementClose and pass the PreparedStatement that caused it
1:          * applicationStatement will be the appropriate choice since it will 
1:          * contain the appropriate instance of PreparedStatement in each case
1:          *
1:             if(bcc != null && isClosed()) {
1:                 bcc.onStatementErrorOccurred((java.sql.PreparedStatement)
1:                                                 applicationStatement,sqle);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f9a0689
/////////////////////////////////////////////////////////////////////////
1: 
1:     public final long getVersionCounter() throws SQLException {
1:         return preparedStatement.getVersionCounter();
1:     }
commit:e8fb6d6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
/////////////////////////////////////////////////////////////////////////
1: 
1:                 GeneratedClass currAc = null;
1:                 ResultDescription resd = null;
1: 
1:                 synchronized(execp) {
1:                     // DERBY-3823 Some other thread may be repreparing
1:                     do {
1:                         while (!execp.upToDate()) {
1:                             execp.rePrepare(lcc);
1:                         }
1: 
1:                         currAc = execp.getActivationClass();
1:                         resd = execp.getResultDescription();
1:                     } while (currAc == null);
1:                 }
1: 
1:                 if (gcDuringGetMetaData == null ||
1:                         !gcDuringGetMetaData.equals(currAc.getName())) {
1:                     rMetaData = null;
1:                     gcDuringGetMetaData = currAc.getName();
1:                 }
1: 
1:                 if (rMetaData == null && resd != null) {
1:                     // Internally, the result description has information
1:                     // which is used for insert, update and delete statements
1:                     // Externally, we decided that statements which don't
1:                     // produce result sets such as insert, update and delete
1:                     // should not return ResultSetMetaData.  This is enforced
1:                     // here
1:                     String statementType = resd.getStatementType();
1:                     if (statementType.equals("INSERT") ||
1:                             statementType.equals("UPDATE") ||
1:                             statementType.equals("DELETE"))
1:                         rMetaData = null;
1:                     else
1:                         rMetaData = newEmbedResultSetMetaData(resd);
1:                 }
1: 
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
1:             } catch (Throwable t) {
1:                 throw handleException(t);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             InterruptStatus.restoreIntrFlagIfSeen();
/////////////////////////////////////////////////////////////////////////
1:                 InterruptStatus.restoreIntrFlagIfSeen(lcc);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a92196c
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // However, the following update was made to the JDBC API:
1:         // "Note: Not all databases allow for a non-typed Null to be sent to
1:         // the backend. For maximum portability, the setNull or the
1:         // setObject(int parameterIndex, Object x, int sqlType) method should
1:         // be used instead of setObject(int parameterIndex, Object x)."
1:         // Based on the above sentence, passing null is now allowed by Derby.
1:         // See DERBY-1938 for details.
1:             setNull(parameterIndex, colType);
1:             return;
commit:d92fa8c
/////////////////////////////////////////////////////////////////////////
1:      * Tells which header format to use when writing CLOBs into the store.
1:      * This is lazily set if we need it, and there are currently only two
1:      * valid header formats to choose between.
1:      * @see #usePreTenFiveHdrFormat()
1:     private Boolean usePreTenFiveHdrFormat;
/////////////////////////////////////////////////////////////////////////
1:             dvd.setStreamHeaderFormat(usePreTenFiveHdrFormat());
/////////////////////////////////////////////////////////////////////////
1:      * Determines which header format to use for CLOBs when writing them to
1:      * the store.
1:      * @return {@code true} if the pre Derby 10.5 header format is to be used,
1:      *      {@code false} if the new header format can be used (10.5 or newer)
1:     private Boolean usePreTenFiveHdrFormat()
1:         // Determine the version of the database we are accessing.
1:         if (usePreTenFiveHdrFormat == null) {
1:             usePreTenFiveHdrFormat = Boolean.valueOf(
1:                 !lcc.getDataDictionary().checkVersion(
1:                     DataDictionary.DD_VERSION_DERBY_10_5, null));
1:         return usePreTenFiveHdrFormat;
commit:d4953dd
/////////////////////////////////////////////////////////////////////////
1:             // Holds either UNKNOWN_LOGICAL_LENGTH or the exact logical length.
1:             int usableLength = DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH;
1:                 usableLength = (int)length;
/////////////////////////////////////////////////////////////////////////
1:                     if (usableLength > colWidth) {
1:                         truncationLength = usableLength - colWidth;
/////////////////////////////////////////////////////////////////////////
1:                 // Indicate that we don't know the logical length of the stream.
1:                 length = DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH;
commit:8f75194
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Tells if we're accessing a database in soft upgrade mode or not.
1:      * <p>
0:      * This is lazily set if we need it.
0:      * @see #isSoftUpgraded()
1:      */
0:     private Boolean inSoftUpgradeMode;
/////////////////////////////////////////////////////////////////////////
0:             dvd.setSoftUpgradeMode(isSoftUpgraded());
/////////////////////////////////////////////////////////////////////////
0:      * Tells if the database being accessed is soft upgraded or not.
1:      *
0:      * @return {@code true} if database is soft upgraded, {@code false} if not.
1:      * @throws StandardException if obtaining the access mode fails
1:      */
0:     private Boolean isSoftUpgraded()
1:             throws StandardException {
0:         // Determine if we are accessing a soft upgraded database or not.
1:         // This is required to write the correct stream header format for Clobs.
0:         if (inSoftUpgradeMode == null) {
0:             inSoftUpgradeMode = Boolean.valueOf(
0:                 lcc.getDataDictionary().checkVersion(
0:                     DataDictionary.DD_VERSION_CURRENT, null));
1:         }
0:         return inSoftUpgradeMode;
1:     }
1: 
1:     /**
commit:6f4c92a
/////////////////////////////////////////////////////////////////////////
1:                         dvd.getStreamHeaderGenerator());
1:                         getParameterSQLType(parameterIndex),
1:                         dvd.getStreamHeaderGenerator());
commit:7af6726
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:             final StringDataValue dvd = (StringDataValue)
1:                     getParms().getParameter(parameterIndex -1);
/////////////////////////////////////////////////////////////////////////
1:                         truncationLength, getParameterSQLType(parameterIndex),
0:                         dvd.generateStreamHeader(length));
0:                                 getParameterSQLType(parameterIndex),
0:                                 dvd.generateStreamHeader(-1));
/////////////////////////////////////////////////////////////////////////
1:             getParms().getParameterForSet(parameterIndex - 1).
1:                     setValue(utfIn, usableLength);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1e8a20f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				(lcc.getDefaultSchema(), sql,
1:                         resultSetConcurrency == java.sql.ResultSet.CONCUR_READ_ONLY,
1:                         forMetaData);
1: 			    activation = preparedStatement.getActivation(lcc,
1:                         resultSetType == java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE);
commit:a0118e1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
1:   				if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS)
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
1: 		if (colType == Types.JAVA_OBJECT) {
/////////////////////////////////////////////////////////////////////////
0:         case Types.DATALINK:
commit:4dbb0ff
/////////////////////////////////////////////////////////////////////////
1: 
0:             int truncationLength = 0;
/////////////////////////////////////////////////////////////////////////
0:                 if (intLength > colWidth) {                 
0:                     truncationLength = intLength - usableLength;
1:                 }
0:             ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(
0:                     reader, usableLength, truncationLength);
0:                 parameterIndex - 1).setValue(utfIn, usableLength);
commit:19f33c6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.ReaderToUTF8Stream;
commit:c56eceb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.RawToBinaryFormatStream;
commit:23b4f8b
/////////////////////////////////////////////////////////////////////////
1: 	boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
/////////////////////////////////////////////////////////////////////////
1: 	boolean executeStatement(Activation a,
/////////////////////////////////////////////////////////////////////////
1: 	final SQLException dataTypeConversion(int column, String sourceType)
commit:72cc553
/////////////////////////////////////////////////////////////////////////
1: 			    addWarning(preparedStatement.getCompileTimeWarnings());
commit:0c13195
/////////////////////////////////////////////////////////////////////////
1: 	void closeActions() throws SQLException {
commit:e334847
/////////////////////////////////////////////////////////////////////////
0: 						Reader reader, long length)
1:         checkStatus();
1: 	    int jdbcTypeId = getParameterJDBCType(parameterIndex);
1: 
1: 
1:         if (reader == null)  {
1:              setNull(parameterIndex, jdbcTypeId);
1:              return;
1:         /*
1:            The value stored should not exceed the maximum value that can be 
1:            stored in an integer 
1:            This checking needs to be done because currently derby does not
1:            support Clob sizes greater than 2G-1 
1:         */
0:    	    if (length > Integer.MAX_VALUE)
1:                throw newSQLException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE,
0:                   preparedStatement.getParameterTypes()
0:                   [parameterIndex-1].getSQLstring());
1:         /*
0:             We cast the length from long to int. This would'nt be appropriate if
0:             the limit of 2G-1 is decided to be increased at a later stage. 
1:         */
0:         int intLength = (int)length;		    
1: 
1: 	    try {
0:             int usableLength = intLength;
/////////////////////////////////////////////////////////////////////////
0:                 // we have used intLength into which the length variable had
0:                 // been cast to an int and stored  
0:                 if (colWidth < intLength)
0:                             limitIn, colWidth, intLength - usableLength);
0:                             limitIn,usableLength,intLength - usableLength);
/////////////////////////////////////////////////////////////////////////
1:             long streamLength = x.length();
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1:      * @param reader the java reader which contains the UNICODE data
commit:75fbaa9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:   <P><B>Supports</B>
0:    <UL>
0:    <LI> JSR169
0:    </UL>
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (setObjectConvert(parameterIndex, x))
1: 			return;
1: 
1: 	/**
0: 		Allow explict setObject conversions by sub-classes for classes
0: 		not supported by this variant. E.g. BigDecimal
0: 		This top-level implementation always returns false.
1: 
0: 		@return true if the object was set successfully, false if no valid
0: 		conversion exists.
1: 
0: 		@exception SQLException value could not be set.
1: 	*/
0: 	boolean setObjectConvert(int parameterIndex, Object x) throws SQLException
1: 	{
0: 		return false;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Set a BLOB parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @param x an object representing a BLOB
1:      */
1:     public void setBlob (int i, Blob x)
1:         throws SQLException
1:     {
0:         int colType;
1:         synchronized (getConnectionSynchronization())
1:         {
0:             colType = getParameterJDBCType(i);
1:         }
0: 		// DB2: only allow setBlob on a BLOB column.
0: 		if (colType != Types.BLOB)
0:             throw dataTypeConversion(i, "java.sql.Blob");
1: 
1: 		if (x == null)
1: 			setNull(i, Types.BLOB);
1: 		else
0: 			setBinaryStreamInternal(i, x.getBinaryStream(), -1);
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Set a CLOB parameter.
1:      *
1:      * @param i the first parameter is 1, the second is 2, ...
1:      * @param x an object representing a CLOB
1:      */
1:     public void setClob (int i, Clob x)
1:         throws SQLException
1:     {
0:         int colType;
1:         synchronized (getConnectionSynchronization())
1:         {
0:             colType = getParameterJDBCType(i);
1:         }
1: 
0: 		// DB2, only allow setClob on a CLOB column.
0: 		if (colType != Types.CLOB)
0:             throw dataTypeConversion(i, "java.sql.Clob");
1: 
1: 		if (x == null)
1: 			setNull(i, Types.CLOB);
1: 		else
0: 			setCharacterStreamInternal(i, x.getCharacterStream(), -1);
1: 	}
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedPreparedStatement
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.types.VariableSizeDataValue;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.PreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.io.LimitReader;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.JDBC20Translation;
1: 
1: import java.util.Calendar;
1: import java.util.Vector;
1: 
1: /*
1:  We would import these, but have name-overlap
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: */
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.sql.Clob;
1: import java.sql.Blob;
1: 
0: import java.math.BigDecimal;
1: import java.io.InputStream;
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.io.EOFException;
1: import java.io.Reader;
1: import java.sql.Types;
1: 
1: 
1: /**
1:  *
1:  * EmbedPreparedStatement is a local JDBC statement.
1:  *
1:  */
0: public abstract class EmbedPreparedStatement
0: 	extends EmbedStatement
0: 	implements java.sql.PreparedStatement
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	//Moving jdbc2.0 batch related code in this class because callableStatement in jdbc 20 needs
1: 	//this code too and it doesn't derive from prepared statement in jdbc 20 in our implementation.
1: 
1: 	protected ResultSetMetaData rMetaData;
1: 	//bug 4579-If the prepared statement was revalidated after doing getMetaData(), we
1: 	//should get the metadata info again on next getMetaData(). We store the generated
1: 	//class name in following variable during getMetaData() call. If it differs from the
1: 	//current generated class name, then that indicates a refetch of metadata is required.
1: 	private String			gcDuringGetMetaData;
1: 
1: 	protected PreparedStatement	preparedStatement;
1: 	private Activation			activation;
1: 
1: 	/*
1: 		Constructor assumes caller will setup context stack
1: 		and restore it.
1: 	 */
1: 	public EmbedPreparedStatement (EmbedConnection conn, String sql, boolean forMetaData,
1: 									  int resultSetType, int resultSetConcurrency,
1: 									  int resultSetHoldability,
1: 									  int autoGeneratedKeys,
1: 									  int[] columnIndexes,
1: 									  String[] columnNames)
1: 		throws SQLException {
1: 
1: 		super(conn, forMetaData, resultSetType, resultSetConcurrency, resultSetHoldability);
1: 
1: 		// if the sql string is null, raise an error
1: 		if (sql == null)
1:   			throw newSQLException(SQLState.NULL_SQL_TEXT);
1: 
1: 			// set up the SQLText in EmbedStatement
1: 			SQLText = sql;
1: 
1: 			try {
0: 			    preparedStatement = lcc.prepareInternalStatement(sql);
0: 				getWarnings(preparedStatement.getCompileTimeWarnings());
1: 
0: 			    activation = preparedStatement.getActivation(lcc, resultSetType == JDBC20Translation.TYPE_SCROLL_INSENSITIVE);
1: 
1: 				checkRequiresCallableStatement(activation);
1: 
1: 			//bug 4838 - save the auto-generated key information in activation. keeping this
0: 			//information in lcc will not work work as it can be tampered by a nested trasaction
0:   				if (autoGeneratedKeys == JDBC30Translation.RETURN_GENERATED_KEYS)
1:   					activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
1: 
1: 			} catch (Throwable t) {
1: 		    throw handleException(t);
1: 			}
1: 	}
1: 
1: 	/**
1: 		JDBC states that a Statement is closed when garbage collected.
1: 
1: 		@exception Throwable Allows any exception to be thrown during finalize
1: 	*/
1: 	protected void finalize() throws Throwable {
1: 		super.finalize();
1: 
1: 		/*
1: 		** We mark the activation as not being used and
1: 	 	** that is it.  We rely on the connection to sweep
1: 		** through the activations to find the ones that
1: 		** aren't in use, and to close them.  We cannot
1: 	 	** do a activation.close() here because there are
1: 		** synchronized methods under close that cannot
1: 		** be called during finalization.
1: 		*/
1: 		if (activation != null) 
1: 		{
1: 			activation.markUnused();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Statement interface
1: 		we override all Statement methods that take a SQL
1: 		string as they must thrown an exception in a PreparedStatement.
1: 		See the JDBC 3.0 spec.
1: 	 */
1: 	public final boolean execute(String sql) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String)");
1: 	}
1: 	public final boolean execute(String sql, int autoGenKeys) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int)");
1: 	}
1: 	public final boolean execute(String sql, int[] columnIndexes) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int[])");
1: 	}
1: 	public final boolean execute(String sql, String[] columnNames) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, String[])");
1: 	}
1: 	public final java.sql.ResultSet executeQuery(String sql) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeQuery(String)");
1: 	}
1: 	public final int executeUpdate(String sql) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String)");
1: 	}
1: 	public final int executeUpdate(String sql, int autoGenKeys) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int)");
1: 	}
1: 	public final int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int[])");
1: 	}
1: 	public final int executeUpdate(String sql, String[] columnNames) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, String[])");
1: 	}
1: 	public final void addBatch(String sql) throws SQLException {
1: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "addBatch(String)");
1: 	}
1: 
1: 
1: 	/**
0: 		Additional close to close our activation.
1: 
0: 		@exception SQLException	thrown on failure
1: 	 */
0: 	protected void closeActions() throws SQLException {
1: 
1: 		//we release the resource for preparedStatement
1: 		preparedStatement = null;
1: 
1: 		try{
1: 			setupContextStack();
1: 		} catch (SQLException se) {
1: 			//we may have already committed the transaction in which case
1: 			//setupContextStack will fail, the close should just return
1: 			return;
1: 		}
1: 		try
1: 		{
1: 		    activation.close();
1: 			activation = null;
1: 		} catch (Throwable t)
1: 		{
1: 			throw handleException(t);
1: 		} finally {
1: 		    restoreContextStack();
1: 		}
1: 	}
1: 	
1: 	/*
1: 	 * PreparedStatement interface; we have inherited from
1: 	 * EmbedStatement to get the Statement interface for
1: 	 * EmbedPreparedStatement (needed by PreparedStatement)
1: 	 * These are the JDBC interface comments, so we know
1: 	 * what to do.
1: 	 */
1: 
1: 	/**
1:      * A prepared SQL query is executed and its ResultSet is returned.
1:      *
1:      * @return a ResultSet that contains the data produced by the
1:      * query; never null
1: 	 * @exception SQLException thrown on failure.
1:      */
1: 	public final java.sql.ResultSet executeQuery() throws SQLException {
0: 		executeStatement(activation, true, false);
1: 
0: 		if (SanityManager.DEBUG) {
0: 			if (results == null)
0: 				SanityManager.THROWASSERT("no results returned on executeQuery()");
1: 		}
1: 
0: 		return results;
1: 	}
1: 
1:     /**
1:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
1:      * SQL statements that return nothing such as SQL DDL statements
1:      * can be executed.
1:      *
1:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
1:      * for SQL statements that return nothing
1: 	 * @exception SQLException thrown on failure.
1:      */
0: 	public final int executeUpdate() throws SQLException {
0: 		executeStatement(activation, false, true);
0: 		return updateCount;
1: 	}
1: 
1:     /**
1:      * Set a parameter to SQL NULL.
1:      *
1:      * <P><B>Note:</B> You must specify the parameter's SQL type.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param sqlType SQL type code defined by java.sql.Types
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setNull(int parameterIndex, int sqlType) throws SQLException {
1: 
1: 		checkStatus();
1: 
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1: 		
1: 		if (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {
1: 
1: 			throw dataTypeConversion(parameterIndex, Util.typeName(sqlType));
1: 		}
1: 		
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setToNull();
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
1: 	 * the driver converts this to a SQL BIT value when it sends it to the
1: 	 * database. But we don't have to do this, since the database engine
1: 	 * supports a boolean type.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1: 		
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java byte value.  The driver converts this
1:      * to a SQL TINYINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setByte(int parameterIndex, byte x) throws SQLException {
1: 
1: 		checkStatus();
1: 		try {
1: 
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java short value.  The driver converts this
1:      * to a SQL SMALLINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setShort(int parameterIndex, short x) throws SQLException {
1: 
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java int value.  The driver converts this
1:      * to a SQL INTEGER value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setInt(int parameterIndex, int x) throws SQLException {
1: 		checkStatus();
1: 
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java long value.  The driver converts this
1:      * to a SQL BIGINT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setLong(int parameterIndex, long x) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java float value.  The driver converts this
1:      * to a SQL FLOAT value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setFloat(int parameterIndex, float x) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java double value.  The driver converts this
1:      * to a SQL DOUBLE value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setDouble(int parameterIndex, double x) throws SQLException {
1: 		checkStatus();
1: 
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 
1: 	}
1: 
1:     /**
0:      * Set a parameter to a java.lang.BigDecimal value.  
0:      * The driver converts this to a SQL NUMERIC value when
0:      * it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
0:     public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1:     /**
1:      * Set a parameter to a Java String value.  The driver converts this
1:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
1:      * size relative to the driver's limits on VARCHARs) when it sends
1:      * it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setString(int parameterIndex, String x) throws SQLException {
1: 		checkStatus();		
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a Java array of bytes.  The driver converts
1:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
1:      * argument's size relative to the driver's limits on VARBINARYs)
1:      * when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setBytes(int parameterIndex, byte x[]) throws SQLException {
1: 		checkStatus();
1: 
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 
1: 	}
1: 
1:     /**
1:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:      * to a SQL DATE value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setDate(int parameterIndex, Date x) throws SQLException {
1:         setDate( parameterIndex, x, (Calendar) null);
1: 	}
1: 
1:     /**
1:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:      * to a SQL TIME value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setTime(int parameterIndex, Time x) throws SQLException {
1:         setTime( parameterIndex, x, (Calendar) null);
1: 	}
1: 
1:     /**
1:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setTimestamp(int parameterIndex, Timestamp x)
1: 	    throws SQLException {
1:         setTimestamp( parameterIndex, x, (Calendar) null);
1: 	}
1: 
1:     /**
1: 	 * We do this inefficiently and read it all in here. The target type
1: 	 * is assumed to be a String.
1:      * 
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream 
1: 	 * @exception SQLException thrown on failure.
1:      */
0:     public final void setAsciiStream(int parameterIndex, InputStream x, int length)
1: 	    throws SQLException {
1: 		checkStatus();
1: 
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1: 		
0: 		switch (jdbcTypeId) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
0: 		case Types.CLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.InputStream(ASCII)");
1: 		}
1: 
1: 		java.io.Reader r = null;
1: 
1: 		if (x != null)
1: 		{
1: 			// Use ISO-8859-1 and not US-ASCII as JDBC seems to define
1: 			// ASCII as 8 bits. US-ASCII is 7.
1: 			try {
1: 				r = new java.io.InputStreamReader(x, "ISO-8859-1");
1: 			} catch (java.io.UnsupportedEncodingException uee) {
1: 				throw new SQLException(uee.getMessage());
1: 			}
1: 		}
1: 
0: 		setCharacterStream(parameterIndex, r, length);
1: 	}
1: 
1:     /**
1: 		Deprecated in JDBC 3.0
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the
1:      * UNICODE parameter value
1:      * @param length the number of bytes in the stream
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void setUnicodeStream(int parameterIndex, InputStream x, int length)
1: 	    throws SQLException
1: 	{
1: 		throw Util.notImplemented("setUnicodeStream");
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * When a very large UNICODE value is input to a LONGVARCHAR
1:      * parameter, it may be more practical to send it via a
1:      * java.io.Reader. JDBC will read the data from the stream
1:      * as needed, until it reaches end-of-file.  The JDBC driver will
1:      * do any necessary conversion from UNICODE to the database char format.
1:      *
1:      * <P><B>Note:</B> This stream object can either be a standard
1:      * Java stream object or your own subclass that implements the
1:      * standard interface.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java reader which contains the UNICODE data
1:      * @param length the number of characters in the stream
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public final void setCharacterStream(int parameterIndex,
1:        			  java.io.Reader reader,
0: 			  int length) throws SQLException
1: 	{
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		switch (jdbcTypeId) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
0: 		case Types.CLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.Reader");
1: 		}
0: 		if (length < 0) //we are doing the check here and not in setCharacterStreamInternal becuase setClob needs to pass -1 for length.
1: 			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
1: 
0: 		if (reader == null)
1: 		{
1: 			setNull(parameterIndex, jdbcTypeId);
1: 			return;
1: 		}
1: 
0: 		setCharacterStreamInternal(parameterIndex, reader, length);
1: 	}
1: 
0:     protected void setCharacterStreamInternal(int parameterIndex,
0: 						Reader reader, int length)
1: 	    throws SQLException
1: 	{
1: 		checkStatus();
1: 
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1: 
1: 
1: 		try {
1: 			ParameterValueSet pvs = getParms();
1: 
0: 			LimitReader limitIn = new LimitReader(reader);
0: 			if (length != -1)
0: 				limitIn.setLimit(length);
0: 			ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(limitIn);
1: 
1: 			/* JDBC is one-based, DBMS is zero-based */
0: 			pvs.getParameterForSet(parameterIndex - 1).setValue(utfIn, length);
1: 
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * 
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream 
1: 	 * @exception SQLException thrown on failure.
1:      */
0:     public final void setBinaryStream(int parameterIndex, InputStream x, int length)
1: 	    throws SQLException
1: 		{
1: 
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		switch (jdbcTypeId) {
0: 		case Types.BINARY:
0: 		case Types.VARBINARY:
0: 		case Types.LONGVARBINARY:
0: 		case Types.BLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.InputStream");
1: 		}
0: 		if (length < 0) //we are doing the check here and not in setBinaryStreamInternal becuase setBlob needs to pass -1 for length.
1: 			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
1: 
0:     	setBinaryStreamInternal(parameterIndex, x, length);
1: 	}
1: 
0:     protected void setBinaryStreamInternal(int parameterIndex, InputStream x,
0: 				int length)
1: 	    throws SQLException
1: 	{
1: 		checkStatus();
1: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
1: 		if (x == null) {
1: 			setNull(parameterIndex, jdbcTypeId);
1:            	return;
1: 		}
1: 
1: 		try {
1: 
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(new RawToBinaryFormatStream(x, length), length);
1: 
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	JDBC 2.0	-	New public methods
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * JDBC 2.0
1:      *
0:      * Set null for user-named types and REF type parameters
1:      * 
1:      * @exception SQLException if a database-access error occurs.
1:      */
0: 	public void setNull(int paramIndex,
0: 						int sqlType,
0: 						String typeName)
1: 		 throws SQLException
1: 	{
0: 		throw Util.notImplemented("setNull");
1: 	}
1: 
1:     /**
1:      * JDBC 2.0
1:      *
1:      * Add a set of parameters to the batch.
1:      * 
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public void addBatch() throws SQLException {
1: 	  checkStatus();
1: 
0: 	  // need to synchronized to ensure that two threads
0: 	  // don't both create a Vector at the same time. This
0: 	  // would lead to one of the set of parameters being thrown
0: 	  // away
0:   	  synchronized (getConnectionSynchronization()) {
0:   			if (batchStatements == null)
0:   				batchStatements = new Vector();
1: 
0:           //get a clone of the parameterValueSet and save it in the vector
0:           //which will be used later on at the time of batch execution.
0:           //This way we will get a copy of the current statement's parameter
0:           //values rather than a pointer to the statement's parameter value
0:           //set which will change with every new statement in the batch.
0:           batchStatements.addElement(getParms().getClone());
0:           clearParameters();
1:   	  }
1:     }
1: 
0: 	protected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
1: 		
1: 		ParameterValueSet temp = (ParameterValueSet) batchElement;
1: 
1: 		int numberOfParameters = temp.getParameterCount();
1: 
1: 		for (int j=0; j<numberOfParameters; j++) {
1: 			temp.getParameter(j).setInto(this, j + 1);
1: 		}
1: 
1: 		return super.executeStatement(activation, false, true);
1: 	}
1: 
1:  
1: 
1:     /**
1:      * <P>In general, parameter values remain in force for repeated use of a
1:      * Statement. Setting a parameter value automatically clears its
1:      * previous value.  However, in some cases it is useful to immediately
1:      * release the resources used by the current parameter values; this can
1:      * be done by calling clearParameters.
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public void clearParameters() throws SQLException {
1: 		checkStatus();
1: 
1: 		ParameterValueSet pvs = getParms();
1: 		if (pvs != null)
1: 			pvs.clearParameters();
1: 	}
1: 
1:     /**
1: 	 * JDBC 2.0
1: 	 *
1:      * The number, types and properties of a ResultSet's columns
1:      * are provided by the getMetaData method.
1:      *
1:      * @return the description of a ResultSet's columns
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public java.sql.ResultSetMetaData getMetaData() throws SQLException
1: 	{
1: 		checkExecStatus();
0: 		synchronized (getConnectionSynchronization())
1: 		{
1: 			//reason for casting is getActivationClass is not available on PreparedStatement
1: 			ExecPreparedStatement execp = (ExecPreparedStatement)preparedStatement;
1: 
1: 			setupContextStack(); // make sure there's context
1: 
1: 			try {
0: 				//bug 4579 - if the statement is invalid, regenerate the metadata info
0: 				if (preparedStatement.isValid() == false)
1: 				{
0: 					//need to revalidate the statement here, otherwise getResultDescription would
0: 					//still have info from previous valid statement
0: 					preparedStatement.rePrepare(lcc);
0: 					rMetaData = null;
1: 				}
1: 				//bug 4579 - gcDuringGetMetaData will be null if this is the first time
1: 				//getMetaData call is made.
1: 				//Second check - if the statement was revalidated since last getMetaData call,
1: 				//then gcDuringGetMetaData wouldn't match with current generated class name
0: 				if (gcDuringGetMetaData == null || gcDuringGetMetaData.equals(execp.getActivationClass().getName()) == false)
1: 				{
0: 					rMetaData = null;
0: 					gcDuringGetMetaData = execp.getActivationClass().getName();
1: 				}
0: 				if (rMetaData == null)
1: 				{
0: 					ResultDescription resd = preparedStatement.getResultDescription();
0: 					if (resd != null)
1: 					{
0: 						// Internally, the result description has information
0: 						// which is used for insert, update and delete statements
0: 						// Externally, we decided that statements which don't
0: 						// produce result sets such as insert, update and delete
0: 						// should not return ResultSetMetaData.  This is enforced
0: 						// here
0: 						String statementType = resd.getStatementType();
0: 						if (statementType.equals("INSERT") ||
0: 								statementType.equals("UPDATE") ||
0: 								statementType.equals("DELETE"))
0: 							rMetaData = null;
0: 						else
0: 				    		rMetaData = newEmbedResultSetMetaData(resd);
1: 					}
1: 				}
1: 			} catch (Throwable t) {
1: 				throw handleException(t);
1: 			}	finally {
1: 				restoreContextStack();
1: 			}
1: 		}
1: 		return rMetaData;
1: 	}
1: 
1:     //----------------------------------------------------------------------
1:     // Advanced features:
1: 
1:     /**
1: 	 * The interface says that the type of the Object parameter must
1: 	 * be compatible with the type of the targetSqlType. We check that,
1: 	 * and if it flies, we expect the underlying engine to do the
1: 	 * required conversion once we pass in the value using its type.
1: 	 * So, an Integer converting to a CHAR is done via setInteger()
1: 	 * support on the underlying CHAR type.
1:      *
1:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
1:      *
1:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:      * @param x The object containing the input parameter value
1:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
1:      * sent to the database. The scale argument may further qualify this type.
1:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
1:      *          this is the number of digits after the decimal.  For all other
1:      *          types this value will be ignored,
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
1:             throws SQLException {
1: 
1: 		if (x == null) {
1: 			setNull(parameterIndex, targetSqlType);
1: 			return;
1: 		}
1: 
1: 		int paramJDBCType = getParameterJDBCType(parameterIndex);
1: 
1: 		if (paramJDBCType != java.sql.Types.JAVA_OBJECT) {
1: 			if (!DataTypeDescriptor.isJDBCTypeEquivalent(paramJDBCType, targetSqlType)) {
1: 				throw dataTypeConversion(parameterIndex, Util.typeName(targetSqlType));
1: 			}
1: 		}
1: 
1: 		setObject(parameterIndex, x);
1: 				
1: 		/*
1: 		* If the parameter type is DECIMAL or NUMERIC, then
1: 		* we need to set the correct scale  or set it 
1: 		* to the default which is zero for setObject.
1: 		*/
1: 		if ((paramJDBCType == Types.DECIMAL) || 
1: 			 (paramJDBCType == Types.NUMERIC))
1: 		{
1: 			setScale(parameterIndex, scale);
1: 		}	
1: 	}
1: 
1:     /**
1:       * This method is like setObject above, but assumes a scale of zero.
1: 	 * @exception SQLException thrown on failure.
1:       */
1:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
1: 		throws SQLException {
1: 		setObject(parameterIndex, x, targetSqlType, 0);
1: 	}
1: 
1:     /**
1:      * <p>Set the value of a parameter using an object; use the
1:      * java.lang equivalent objects for integral values.
1:      *
1:      * <p>The JDBC specification specifies a standard mapping from
1:      * Java Object types to SQL types.  The given argument java object
1:      * will be converted to the corresponding SQL type before being
1:      * sent to the database.
1:      *
1:      * <p>Note that this method may be used to pass datatabase
1:      * specific abstract data types, by using a Driver specific Java
1:      * type.
1:      *
1:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:      * @param x The object containing the input parameter value 
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     public final void setObject(int parameterIndex, Object x) throws SQLException {
1: 		checkStatus();	
1: 
1: 
1: 		int colType = getParameterJDBCType(parameterIndex);
1: 
1: 		// JDBC Tutorial and Reference books states in the PreparedStatement
1: 		// overview, that passing a untyped null into setObject() is not allowed.
1: 		// JCC disallows this, basically SQL can not handle a untyped NULL.
1: 		// Section 25.1.6 (Third edition), 24.1.5 (Second Edition)
1: 
1: 		if (x == null) {
0: 			//setNull(parameterIndex, colType);
0: 			//return;
0: 			throw dataTypeConversion(parameterIndex, "null");
1: 		}
1: 		
0: 		if (colType == org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT) {
1: 			try {
1: 				/* JDBC is one-based, DBMS is zero-based */
1: 				getParms().setParameterAsObject(parameterIndex - 1, x);
1: 				return;
1: 
1: 			} catch (Throwable t) {
1: 				throw EmbedResultSet.noStateChangeException(t);
1: 			}
1: 		}
1: 
1: 
1: 		// Need to do instanceof checks here so that the behaviour
1: 		// for these calls is consistent with the matching setXXX() value.
1: 
1: 		// These are the supported setObject conversions from JDBC 3.0 table B5
1: 
1: 		if (x instanceof String) {
1: 			setString(parameterIndex, (String) x);
1: 			return;
1: 		}
1: 
0: 		if (x instanceof BigDecimal) {
0: 			setBigDecimal(parameterIndex, (BigDecimal) x);
1: 			return;
1: 		}
1: 		if (x instanceof Boolean) {
1: 			setBoolean(parameterIndex, ((Boolean) x).booleanValue());
1: 			return;
1: 		}
1: 		if (x instanceof Integer) {
1: 			setInt(parameterIndex, ((Integer) x).intValue());
1: 			return;
1: 		}
1: 		if (x instanceof Long) {
1: 			setLong(parameterIndex, ((Long) x).longValue());
1: 			return;
1: 		}
1: 
1: 		if (x instanceof Float) {
1: 			setFloat(parameterIndex, ((Float) x).floatValue());
1: 			return;
1: 		}
1: 		if (x instanceof Double) {
1: 			setDouble(parameterIndex, ((Double) x).doubleValue());
1: 			return;
1: 		}
1: 
1: 		if (x instanceof byte[]) {
1: 			setBytes(parameterIndex, (byte[]) x);
1: 			return;
1: 		}
1: 
1: 		if (x instanceof Date) {
1: 			setDate(parameterIndex, (Date) x);
1: 			return;
1: 		}
1: 		if (x instanceof Time) {
1: 			setTime(parameterIndex, (Time) x);
1: 			return;
1: 		}
1: 		if (x instanceof Timestamp) {
1: 			setTimestamp(parameterIndex, (Timestamp) x);
1: 			return;
1: 		}
1: 
1: 		if (x instanceof Blob) {
1: 			setBlob(parameterIndex, (Blob) x);
1: 			return;
1: 		}
1: 		if (x instanceof Clob) {
1: 			setClob(parameterIndex, (Clob) x);
1: 			return;
1: 		}
1: 
1: 		
1: 		throw dataTypeConversion(parameterIndex, x.getClass().getName());
1: 
1: 	}
1: 
1:     /**
1:      * @see java.sql.Statement#execute
1: 	 * @exception SQLException thrown on failure.
1:      */
0:     public final boolean execute() throws SQLException {
0: 		return executeStatement(activation, false, false);
1: 	}
1:     /**
1:      * Set a parameter to a java.sql.Date value.  The driver converts this
1:      * to a SQL DATE value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setDate(int parameterIndex, java.sql.Date x, Calendar cal)
1: 	    throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a java.sql.Time value.  The driver converts this
1:      * to a SQL TIME value when it sends it to the database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTime(int parameterIndex, java.sql.Time x, Calendar cal)
1: 	    throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1: 
1: 		} catch (Throwable t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1:     /**
1:      * Set a parameter to a java.sql.Timestamp value.  The driver
1:      * converts this to a SQL TIMESTAMP value when it sends it to the
1:      * database.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the parameter value 
1:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public final void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal)
1: 	    throws SQLException 
1: 	{
1: 		checkStatus();
1: 		try {
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
1: 
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 	/**
0: 	 * Get the ParameterValueSet from the activation
1: 	 *
1: 	 *
1: 	 * @return	The ParameterValueSet for the activation
1: 	 *
1: 	 */
1: 	public final ParameterValueSet getParms() {
1: 
1: 		return activation.getParameterValueSet();
1: 	}
1: 
1: 
1: 	/**
0: 		Check the parameterINdex is in range and return the
0: 		array of type descriptors.
1: 
1: 		@exception SQLException parameter is out of range
1: 	*/
0: 	protected final DataTypeDescriptor[] getTypes(int parameterIndex)
1: 		throws SQLException {
1: 
0: 		DataTypeDescriptor[] types = preparedStatement.getParameterTypes();
1: 
0: 		if (types == null) {
0: 			throw newSQLException(SQLState.NO_INPUT_PARAMETERS);
1: 		}
1: 
0: 		/* Check that the parameterIndex is in range. */
0: 		if (parameterIndex < 1 ||
0: 				parameterIndex > types.length) {
1: 
0: 			/* This message matches the one used by the DBMS */
0: 			throw newSQLException(SQLState.LANG_INVALID_PARAM_POSITION, 
0:             new Integer(parameterIndex), new Integer(types.length));
1: 		}
0: 		return types;
1: 	}
1: 
1: 	/**
1: 		Get the target JDBC type for a parameter. Will throw exceptions
0: 		if the parameter index is out of range
1: 
1: 		@exception SQLException parameter is out of range
1: 	*/
1: 	protected int getParameterJDBCType(int parameterIndex)
1: 		throws SQLException {
1: 
0: 		DataTypeDescriptor[] types = getTypes(parameterIndex);
1: 
0: 		int type = types[parameterIndex -1] == null ? 
0: 			Types.OTHER :
0: 			types[parameterIndex - 1].getTypeId().getJDBCTypeId();
1: 
0: 		if (SanityManager.DEBUG) {
0: 			//int pmType = getEmbedParameterSetMetaData().getParameterType(parameterIndex);
0: 			//if (type != pmType) {
0: 				//SanityManager.THROWASSERT("MISMATCH PARAMETER META DATA param " + parameterIndex + " types " + type + " != " + pmType + "\n" + SQLText);
0: 			//}
1: 		}
1: 
0: 		return type;
1: 	}
1: 
1:     /**
1:      * Set the scale of a parameter.
1:      *
1:      * @param parameterIndex The first parameter is 1, the second is 2, ...
1:      * @param scale	The scale
1: 	 * @exception SQLException thrown on failure.
1:      */
1:     private void setScale(int parameterIndex, int scale)
1: 		throws SQLException 
1: 	{
1: 		checkStatus();
1: 
1: 		if (scale < 0)
0: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));
1: 		
1: 		try {
1: 
1: 			ParameterValueSet pvs = getParms();
1: 
1: 			/* JDBC is one-based, DBMS is zero-based */
1: 			DataValueDescriptor value = pvs.getParameter(parameterIndex - 1);
1: 
1: 
1: 			int origvaluelen = value.getLength();
1: 			((VariableSizeDataValue)
1: 						value).setWidth(VariableSizeDataValue.IGNORE_PRECISION, 
1: 							scale, 
1: 							false);
1: 
1: 			if (value.getLength() < origvaluelen)
1: 			{
1: 				activation.addWarning(StandardException.newWarning(SQLState.LANG_VALUE_TRUNCATED, value.getString()));
1: 			}
1: 
1: 		} catch (StandardException t) {
1: 			throw EmbedResultSet.noStateChangeException(t);
1: 		}
1: 	}
1: 
1: 
1: 	/**
0:     * Immitate the function in JDBC 3.0
1:     *
0:     * Retrieves the number, types and properties of this PreparedStatement
0:     * object's parameters.
1:     *
0:     * @return a EmbedParameterSetMetaData object that contains information about the
0:     * number, types and properties of this PreparedStatement object's parameters.
0:     * @exception SQLException if a database access error occurs
1: 	*/
0: 	public EmbedParameterSetMetaData getEmbedParameterSetMetaData()
1:     	throws SQLException
1: 	{
1: 	  checkExecStatus();
0: 	  return new EmbedParameterSetMetaData(
0: 				getParms(), preparedStatement.getParameterTypes());
1: 
1: 	}
1: 	/**
1:     * JDBC 3.0
1:     *
1:     * Sets the designated parameter to the given java.net.URL value. The driver
1:     * converts this to an SQL DATALINK value when it sends it to the database.
1:     *
1:     * @param parameterIndex - the first parameter is 1, the second is 2, ...
1:     * @param x - the java.net.URL object to be set
1:     * @exception SQLException Feature not implemented for now.
1: 	*/
1: 	public final void setURL(int parameterIndex, java.net.URL x)
1:     throws SQLException
1: 	{
1: 		throw Util.notImplemented();
1: 	}
1: 
1: 	//
1: 	// methods to be overridden in subimplementations
1: 	// that want to stay within their subimplementation.
1: 	//
1: 	protected EmbedResultSetMetaData newEmbedResultSetMetaData(ResultDescription resultDesc) {
1: 
0: 		return new EmbedResultSetMetaData(resultDesc.getColumnInfo());
1: 	}
1: 
1: 	public String toString() {
1: 
1: 		if (activation != null)
1: 			return activation.getPreparedStatement().getObjectName();
1: 		return super.toString();
1: 	}
1: 
1: 	/*
0: 	**
1: 	*/
1: 	public void transferParameters(EmbedPreparedStatement newStatement) throws SQLException {
1: 
1: 		try {
1: 			newStatement.activation.setParameters(getParms(), preparedStatement.getParameterTypes());
1: 		} catch (StandardException se) {
1: 			throw EmbedResultSet.noStateChangeException(se);
1: 		}
1: 	}
1: 
0: 	protected boolean executeStatement(Activation a,
1:                      boolean executeQuery, boolean executeUpdate)
1:                      throws SQLException {
1: 
1: 		checkExecStatus();
1: 		checkIfInMiddleOfBatch();
1: 		clearResultSets();
1: 		return super.executeStatement(a, executeQuery, executeUpdate);
1: 	}
1: 
0: 	protected final SQLException dataTypeConversion(int column, String sourceType)
1: 		throws SQLException {
0: 		SQLException se = newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, getEmbedParameterSetMetaData().getParameterTypeName(column),
1: 			sourceType);
0: 		return se;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:aadfd42
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineParameterMetaData;
1: import org.apache.derby.iapi.jdbc.EnginePreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 	implements EnginePreparedStatement
/////////////////////////////////////////////////////////////////////////
0:     * @return a EngineParameterMetaData object that contains information about the
0: 	public EngineParameterMetaData getEmbedParameterSetMetaData()
commit:3896fdd
/////////////////////////////////////////////////////////////////////////
0:     // By default a PreparedStatement is poolable when it is created
0:     //required for jdbc4.0 methods        
0:     private boolean isPoolable = true;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
1:    //jdbc 4.0 methods
0: 
0:    
0:     /**
1:      * Sets the designated parameter to a Reader object.
0:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1:      * @param reader An object that contains the data to set the parameter value to.
1:      * @param length the number of characters in the parameter data.
1:      * @throws SQLException if parameterIndex does not correspond to a parameter
1:      * marker in the SQL statement, or if the length specified is less than zero.
0:      *
0:      */
0: 
0:     
1:     public void setClob(int parameterIndex, Reader reader, long length)
1:     throws SQLException{
0:         int colType;
0:         synchronized(getConnectionSynchronization()) {
0:             colType = getParameterJDBCType(parameterIndex);
0:             if(colType != Types.CLOB)
0:                 throw dataTypeConversion(parameterIndex, "java.sql.Clob");
0:             
0:             setCharacterStreamInternal(parameterIndex,reader,length);
0:         }
0:     }
0: 
0:     /**
1:      * Sets the designated parameter to a InputStream object.
0:      *
1:      * @param parameterIndex index of the first parameter is 1,
1:      * the second is 2, ...
1:      * @param inputStream An object that contains the data to set the parameter
1:      * value to.
1:      * @param length the number of bytes in the parameter data.
1:      * @throws SQLException if parameterIndex does not correspond
1:      * to a parameter marker in the SQL statement,  if the length specified
1:      * is less than zero or if the number of bytes in the inputstream does not match
1:      * the specfied length.
0:      */
0: 
0:     
1:     public void setBlob(int parameterIndex, InputStream inputStream, long length)
1:     throws SQLException{
0:         int colType;
0:         synchronized (getConnectionSynchronization()) {
0:             colType = getParameterJDBCType(parameterIndex);
0:             if (colType != Types.BLOB)
0:                 throw dataTypeConversion(parameterIndex, "java.sql.Blob");
0:             
0:             setBinaryStreamInternal(parameterIndex,inputStream,length);
0:         }
0:     }        
0:     /**
0:      * Requests that a PreparedStatement be pooled or not.
0:      *
0:      * @param poolable requests that the statement be pooled if true and that the
0:      *                 statement not be pooled if false
0:      * @throws SQLException if the PreparedStatement has been closed.
0:      */
0:      
0:     public void setPoolable(boolean poolable)
0:     throws SQLException {
0:         // Assert the statement is still active (not closed)
0:         checkStatus();
0: 
0:         isPoolable = poolable;
0:     }
0:     
0:     /**
0:      * Returns the value of the statements poolable hint, indicating whether
0:      * pooling of the statement is requested.
0:      *
0:      * @return The value of the statement's poolable hint.
0:      * @throws SQLException if the PreparedStatement has been closed.
0:      */
0: 
0:     public boolean isPoolable()
0:     throws SQLException {
0:         // Assert the statement is still active (not closed)
0:         checkStatus();
0: 
0:         return isPoolable;
0:     }                
0:         
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2648e94
/////////////////////////////////////////////////////////////////////////
0: 				long length)
0: 
0:         if ( length < 0 ) 
0:             throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
0:         
0:         
1:         // max number of bytes that can be set to be inserted 
1:         // in Derby is 2Gb-1 (ie Integer.MAX_VALUE). 
1:         // (e.g into a blob column).
1:         // For now, we cast the length from long to int as a result.
1:         // If we ever decide to increase these limits for lets say blobs, 
1:         // in that case the cast to int would not be appropriate.
0:         if ( length > Integer.MAX_VALUE ) {
1:             throw newSQLException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE,
0:                getEmbedParameterSetMetaData().getParameterTypeName(
1:                    parameterIndex));
0:         }
0:         try {
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(new RawToBinaryFormatStream(x, (int)length), (int)length);
/////////////////////////////////////////////////////////////////////////
0:         {
1:             // Note, x.length() needs to be called before retrieving the
1:             // stream using x.getBinaryStream() because EmbedBlob.length()
1:             // will read from the stream and drain some part of the stream 
1:             // Hence the need to declare this local variable - streamLength
1:             long streamLength = x.length();
0:             setBinaryStreamInternal(i, x.getBinaryStream(), streamLength);
0:         }
commit:28030d7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         // currently the max number of chars that can be inserted
0:         // into a clob field is Integer.MAX_INT ( 2Gb -1)
0:         // setClob or setCharacterStream interfaces will eventually call 
0:         // this method and in setClob, a long is casted to an int; hence
0:         // check for -ve length
0:         if (length < 0) 
0:           throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
0:       
0: 	    
0: 		    
0:         if (reader == null)
0:         {
0:             setNull(parameterIndex, jdbcTypeId);
0:             return;
0:         }
0:            
0:             LimitReader limitIn = new LimitReader(reader);
0:             int usableLength = length;
0:             ReaderToUTF8Stream utfIn = null;
0:             // Currently long varchar does not allow for truncation of trailing
0:             // blanks.  
0:             // For char and varchar types, current mechanism of materializing
0:             // when using streams seems fine given their  max limits.
0:             // This change is fix for DERBY-352: Insert of clobs using streams
0:             // should not materialize the entire stream into memory
0:             // In case of clobs, the truncation of trailing blanks is factored
0:             // in when reading from the stream without materializing the entire
0:             // stream, and so the special casing for clob below.
0:             if (jdbcTypeId == Types.CLOB) 
0:             {
0:                 // Need column width to figure out if truncation is needed 
0:                 DataTypeDescriptor dtd[] = preparedStatement
0:                         .getParameterTypes();
0:                 int colWidth = dtd[parameterIndex - 1].getMaximumWidth();
0:                 // It is possible that the length of the stream passed in is
0:                 // greater than the column width, in which case the data from
0:                 // the stream needs to be truncated.
0:                 // usableLength is the length of the data from stream that can
0:                 // be inserted which is min(colWidth,length) provided 
0:                 // length - colWidth has trailing blanks only
0:                 if (colWidth < length)
0:                     usableLength = colWidth;
0:                 
0:                 // keep information with the stream about how much data needs 
0:                 // to be truncated, and colWidth info to give proper truncation
0:                 // message
0:                 utfIn = new ReaderToUTF8Stream(
0:                             limitIn, colWidth, length - usableLength);
0:             }
0:             else
0:             {
0:                 utfIn = new ReaderToUTF8Stream(
0:                             limitIn,usableLength,length - usableLength);
0:             }
0: 
0:             limitIn.setLimit(usableLength);
0: 
0:             /* JDBC is one-based, DBMS is zero-based */
0:             pvs.getParameterForSet(
0:                 parameterIndex - 1).setValue(utfIn,usableLength);
/////////////////////////////////////////////////////////////////////////
0:         if (length < 0) //we are doing the check here and not in setBinaryStreamInternal becuase setBlob needs to pass -1 for length.
0:             throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
/////////////////////////////////////////////////////////////////////////
0:  			setBinaryStreamInternal(i, x.getBinaryStream(), -1);
/////////////////////////////////////////////////////////////////////////
0:         {
1:             // 1. max number of characters that can be inserted into a clob column
1:             // is 2Gb-1 which is Integer.MAX_INT.
1:             // This means that we do not allow any inserts of clobs where
1:             // clob.length() > Integer.MAX_INT. For now, we cast the x.length()
1:             // to int as a result. This will work ok for valid clob values that
1:             // derby supports. If we ever decide to increase these limits for clobs, in that
1:             // case the cast of x.Length() to int would not be appropriate.
1:             // 2. Note, x.length() needs to be called before retrieving the
1:             // stream using x.getCharacterStream() because EmbedClob.length()
1:             // will read from the stream and drain the stream. 
1:             // Hence the need to declare this local variable - streamLength
0:             int streamLength = (int) x.length();
0: 
0:             setCharacterStreamInternal(i, x.getCharacterStream(), streamLength);
0:         }
0:         
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
0: 				(lcc.getDefaultSchema(), sql, resultSetConcurrency==JDBC20Translation.CONCUR_READ_ONLY, forMetaData);
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 			    preparedStatement = lcc.prepareInternalStatement
0: 				(lcc.getDefaultSchema(), sql, resultSetConcurrency==JDBC20Translation.CONCUR_READ_ONLY);
0: 			    
0: 			    getWarnings(preparedStatement.getCompileTimeWarnings());
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.LimitReader;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: 
0: import java.util.Calendar;
0: import java.util.Vector;
0: 
0: /*
0:  We would import these, but have name-overlap
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: */
0: import java.sql.ResultSetMetaData;
0: import java.sql.SQLException;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Clob;
0: import java.sql.Blob;
0: 
0: import java.math.BigDecimal;
0: import java.io.InputStream;
0: import java.io.DataInputStream;
0: import java.io.IOException;
0: import java.io.EOFException;
0: import java.io.Reader;
0: import java.sql.Types;
0: 
0: 
0: /**
0:  *
0:  * EmbedPreparedStatement is a local JDBC statement.
0:  *
0:  */
0: public abstract class EmbedPreparedStatement
0: 	extends EmbedStatement
0: 	implements java.sql.PreparedStatement
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	//Moving jdbc2.0 batch related code in this class because callableStatement in jdbc 20 needs
0: 	//this code too and it doesn't derive from prepared statement in jdbc 20 in our implementation.
0: 
0: 	protected ResultSetMetaData rMetaData;
0: 	//bug 4579-If the prepared statement was revalidated after doing getMetaData(), we
0: 	//should get the metadata info again on next getMetaData(). We store the generated
0: 	//class name in following variable during getMetaData() call. If it differs from the
0: 	//current generated class name, then that indicates a refetch of metadata is required.
0: 	private String			gcDuringGetMetaData;
0: 
0: 	protected PreparedStatement	preparedStatement;
0: 	private Activation			activation;
0: 
0: 	/*
0: 		Constructor assumes caller will setup context stack
0: 		and restore it.
0: 	 */
0: 	public EmbedPreparedStatement (EmbedConnection conn, String sql, boolean forMetaData,
0: 									  int resultSetType, int resultSetConcurrency,
0: 									  int resultSetHoldability,
0: 									  int autoGeneratedKeys,
0: 									  int[] columnIndexes,
0: 									  String[] columnNames)
0: 		throws SQLException {
0: 
0: 		super(conn, forMetaData, resultSetType, resultSetConcurrency, resultSetHoldability);
0: 
0: 		// if the sql string is null, raise an error
0: 		if (sql == null)
0:   			throw newSQLException(SQLState.NULL_SQL_TEXT);
0: 
0: 			// set up the SQLText in EmbedStatement
0: 			SQLText = sql;
0: 
0: 			try {
0: 			    preparedStatement = lcc.prepareInternalStatement(sql);
0: 				getWarnings(preparedStatement.getCompileTimeWarnings());
0: 
0: 			    activation = preparedStatement.getActivation(lcc, resultSetType == JDBC20Translation.TYPE_SCROLL_INSENSITIVE);
0: 
0: 				checkRequiresCallableStatement(activation);
0: 
0: 			//bug 4838 - save the auto-generated key information in activation. keeping this
0: 			//information in lcc will not work work as it can be tampered by a nested trasaction
0:   				if (autoGeneratedKeys == JDBC30Translation.RETURN_GENERATED_KEYS)
0:   					activation.setAutoGeneratedKeysResultsetInfo(columnIndexes, columnNames);
0: 
0: 			} catch (Throwable t) {
0: 		    throw handleException(t);
0: 			}
0: 	}
0: 
0: 	/**
0: 		JDBC states that a Statement is closed when garbage collected.
0: 
0: 		@exception Throwable Allows any exception to be thrown during finalize
0: 	*/
0: 	protected void finalize() throws Throwable {
0: 		super.finalize();
0: 
0: 		/*
0: 		** We mark the activation as not being used and
0: 	 	** that is it.  We rely on the connection to sweep
0: 		** through the activations to find the ones that
0: 		** aren't in use, and to close them.  We cannot
0: 	 	** do a activation.close() here because there are
0: 		** synchronized methods under close that cannot
0: 		** be called during finalization.
0: 		*/
0: 		if (activation != null) 
0: 		{
0: 			activation.markUnused();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Statement interface
0: 		we override all Statement methods that take a SQL
0: 		string as they must thrown an exception in a PreparedStatement.
0: 		See the JDBC 3.0 spec.
0: 	 */
0: 	public final boolean execute(String sql) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String)");
0: 	}
0: 	public final boolean execute(String sql, int autoGenKeys) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int)");
0: 	}
0: 	public final boolean execute(String sql, int[] columnIndexes) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, int[])");
0: 	}
0: 	public final boolean execute(String sql, String[] columnNames) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "execute(String, String[])");
0: 	}
0: 	public final java.sql.ResultSet executeQuery(String sql) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeQuery(String)");
0: 	}
0: 	public final int executeUpdate(String sql) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String)");
0: 	}
0: 	public final int executeUpdate(String sql, int autoGenKeys) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int)");
0: 	}
0: 	public final int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, int[])");
0: 	}
0: 	public final int executeUpdate(String sql, String[] columnNames) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "executeUpdate(String, String[])");
0: 	}
0: 	public final void addBatch(String sql) throws SQLException {
0: 		throw newSQLException(SQLState.NOT_FOR_PREPARED_STATEMENT, "addBatch(String)");
0: 	}
0: 
0: 
0: 	/**
0: 		Additional close to close our activation.
0: 
0: 		@exception SQLException	thrown on failure
0: 	 */
0: 	protected void closeActions() throws SQLException {
0: 
0: 		//we release the resource for preparedStatement
0: 		preparedStatement = null;
0: 
0: 		try{
0: 			setupContextStack();
0: 		} catch (SQLException se) {
0: 			//we may have already committed the transaction in which case
0: 			//setupContextStack will fail, the close should just return
0: 			return;
0: 		}
0: 		try
0: 		{
0: 		    activation.close();
0: 			activation = null;
0: 		} catch (Throwable t)
0: 		{
0: 			throw handleException(t);
0: 		} finally {
0: 		    restoreContextStack();
0: 		}
0: 	}
0: 	
0: 	/*
0: 	 * PreparedStatement interface; we have inherited from
0: 	 * EmbedStatement to get the Statement interface for
0: 	 * EmbedPreparedStatement (needed by PreparedStatement)
0: 	 * These are the JDBC interface comments, so we know
0: 	 * what to do.
0: 	 */
0: 
0: 	/**
0:      * A prepared SQL query is executed and its ResultSet is returned.
0:      *
0:      * @return a ResultSet that contains the data produced by the
0:      * query; never null
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final java.sql.ResultSet executeQuery() throws SQLException {
0: 		executeStatement(activation, true, false);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (results == null)
0: 				SanityManager.THROWASSERT("no results returned on executeQuery()");
0: 		}
0: 
0: 		return results;
0: 	}
0: 
0:     /**
0:      * Execute a SQL INSERT, UPDATE or DELETE statement. In addition,
0:      * SQL statements that return nothing such as SQL DDL statements
0:      * can be executed.
0:      *
0:      * @return either the row count for INSERT, UPDATE or DELETE; or 0
0:      * for SQL statements that return nothing
0: 	 * @exception SQLException thrown on failure.
0:      */
0: 	public final int executeUpdate() throws SQLException {
0: 		executeStatement(activation, false, true);
0: 		return updateCount;
0: 	}
0: 
0:     /**
0:      * Set a parameter to SQL NULL.
0:      *
0:      * <P><B>Note:</B> You must specify the parameter's SQL type.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param sqlType SQL type code defined by java.sql.Types
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setNull(int parameterIndex, int sqlType) throws SQLException {
0: 
0: 		checkStatus();
0: 
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		
0: 		if (!DataTypeDescriptor.isJDBCTypeEquivalent(jdbcTypeId, sqlType)) {
0: 
0: 			throw dataTypeConversion(parameterIndex, Util.typeName(sqlType));
0: 		}
0: 		
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setToNull();
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java boolean value.  According to the JDBC API spec,
0: 	 * the driver converts this to a SQL BIT value when it sends it to the
0: 	 * database. But we don't have to do this, since the database engine
0: 	 * supports a boolean type.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
0: 		
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java byte value.  The driver converts this
0:      * to a SQL TINYINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setByte(int parameterIndex, byte x) throws SQLException {
0: 
0: 		checkStatus();
0: 		try {
0: 
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java short value.  The driver converts this
0:      * to a SQL SMALLINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setShort(int parameterIndex, short x) throws SQLException {
0: 
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java int value.  The driver converts this
0:      * to a SQL INTEGER value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setInt(int parameterIndex, int x) throws SQLException {
0: 		checkStatus();
0: 
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java long value.  The driver converts this
0:      * to a SQL BIGINT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setLong(int parameterIndex, long x) throws SQLException {
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java float value.  The driver converts this
0:      * to a SQL FLOAT value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setFloat(int parameterIndex, float x) throws SQLException {
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java double value.  The driver converts this
0:      * to a SQL DOUBLE value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setDouble(int parameterIndex, double x) throws SQLException {
0: 		checkStatus();
0: 
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.lang.BigDecimal value.  
0:      * The driver converts this to a SQL NUMERIC value when
0:      * it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0:     /**
0:      * Set a parameter to a Java String value.  The driver converts this
0:      * to a SQL VARCHAR or LONGVARCHAR value (depending on the arguments
0:      * size relative to the driver's limits on VARCHARs) when it sends
0:      * it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setString(int parameterIndex, String x) throws SQLException {
0: 		checkStatus();		
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a Java array of bytes.  The driver converts
0:      * this to a SQL VARBINARY or LONGVARBINARY (depending on the
0:      * argument's size relative to the driver's limits on VARBINARYs)
0:      * when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setBytes(int parameterIndex, byte x[]) throws SQLException {
0: 		checkStatus();
0: 
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.sql.Date value.  The driver converts this
0:      * to a SQL DATE value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setDate(int parameterIndex, Date x) throws SQLException {
0:         setDate( parameterIndex, x, (Calendar) null);
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.sql.Time value.  The driver converts this
0:      * to a SQL TIME value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setTime(int parameterIndex, Time x) throws SQLException {
0:         setTime( parameterIndex, x, (Calendar) null);
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.sql.Timestamp value.  The driver
0:      * converts this to a SQL TIMESTAMP value when it sends it to the
0:      * database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setTimestamp(int parameterIndex, Timestamp x)
0: 	    throws SQLException {
0:         setTimestamp( parameterIndex, x, (Calendar) null);
0: 	}
0: 
0:     /**
0: 	 * We do this inefficiently and read it all in here. The target type
0: 	 * is assumed to be a String.
0:      * 
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java input stream which contains the ASCII parameter value
0:      * @param length the number of bytes in the stream 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setAsciiStream(int parameterIndex, InputStream x, int length)
0: 	    throws SQLException {
0: 		checkStatus();
0: 
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		
0: 		switch (jdbcTypeId) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
0: 		case Types.CLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.InputStream(ASCII)");
0: 		}
0: 
0: 		java.io.Reader r = null;
0: 
0: 		if (x != null)
0: 		{
0: 			// Use ISO-8859-1 and not US-ASCII as JDBC seems to define
0: 			// ASCII as 8 bits. US-ASCII is 7.
0: 			try {
0: 				r = new java.io.InputStreamReader(x, "ISO-8859-1");
0: 			} catch (java.io.UnsupportedEncodingException uee) {
0: 				throw new SQLException(uee.getMessage());
0: 			}
0: 		}
0: 
0: 		setCharacterStream(parameterIndex, r, length);
0: 	}
0: 
0:     /**
0: 		Deprecated in JDBC 3.0
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java input stream which contains the
0:      * UNICODE parameter value
0:      * @param length the number of bytes in the stream
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void setUnicodeStream(int parameterIndex, InputStream x, int length)
0: 	    throws SQLException
0: 	{
0: 		throw Util.notImplemented("setUnicodeStream");
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * When a very large UNICODE value is input to a LONGVARCHAR
0:      * parameter, it may be more practical to send it via a
0:      * java.io.Reader. JDBC will read the data from the stream
0:      * as needed, until it reaches end-of-file.  The JDBC driver will
0:      * do any necessary conversion from UNICODE to the database char format.
0:      *
0:      * <P><B>Note:</B> This stream object can either be a standard
0:      * Java stream object or your own subclass that implements the
0:      * standard interface.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java reader which contains the UNICODE data
0:      * @param length the number of characters in the stream
0:      * @exception SQLException if a database-access error occurs.
0:      */
0:     public final void setCharacterStream(int parameterIndex,
0:        			  java.io.Reader reader,
0: 			  int length) throws SQLException
0: 	{
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		switch (jdbcTypeId) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
0: 		case Types.CLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.Reader");
0: 		}
0: 		if (length < 0) //we are doing the check here and not in setCharacterStreamInternal becuase setClob needs to pass -1 for length.
0: 			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
0: 
0: 		if (reader == null)
0: 		{
0: 			setNull(parameterIndex, jdbcTypeId);
0: 			return;
0: 		}
0: 
0: 		setCharacterStreamInternal(parameterIndex, reader, length);
0: 	}
0: 
0:     protected void setCharacterStreamInternal(int parameterIndex,
0: 						Reader reader, int length)
0: 	    throws SQLException
0: 	{
0: 		checkStatus();
0: 
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 
0: 
0: 		try {
0: 			ParameterValueSet pvs = getParms();
0: 
0: 			LimitReader limitIn = new LimitReader(reader);
0: 			if (length != -1)
0: 				limitIn.setLimit(length);
0: 			ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(limitIn);
0: 
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			pvs.getParameterForSet(parameterIndex - 1).setValue(utfIn, length);
0: 
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * 
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the java input stream which contains the binary parameter value
0:      * @param length the number of bytes in the stream 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setBinaryStream(int parameterIndex, InputStream x, int length)
0: 	    throws SQLException
0: 		{
0: 
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		switch (jdbcTypeId) {
0: 		case Types.BINARY:
0: 		case Types.VARBINARY:
0: 		case Types.LONGVARBINARY:
0: 		case Types.BLOB:
0: 			break;
0: 		default:
0: 			throw dataTypeConversion(parameterIndex, "java.io.InputStream");
0: 		}
0: 		if (length < 0) //we are doing the check here and not in setBinaryStreamInternal becuase setBlob needs to pass -1 for length.
0: 			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
0: 
0:     	setBinaryStreamInternal(parameterIndex, x, length);
0: 	}
0: 
0:     protected void setBinaryStreamInternal(int parameterIndex, InputStream x,
0: 				int length)
0: 	    throws SQLException
0: 	{
0: 		checkStatus();
0: 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
0: 		if (x == null) {
0: 			setNull(parameterIndex, jdbcTypeId);
0:            	return;
0: 		}
0: 
0: 		try {
0: 
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(new RawToBinaryFormatStream(x, length), length);
0: 
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 2.0	-	New public methods
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Set null for user-named types and REF type parameters
0:      * 
0:      * @exception SQLException if a database-access error occurs.
0:      */
0: 	public void setNull(int paramIndex,
0: 						int sqlType,
0: 						String typeName)
0: 		 throws SQLException
0: 	{
0: 		throw Util.notImplemented("setNull");
0: 	}
0: 
0:     /**
0:      * JDBC 2.0
0:      *
0:      * Add a set of parameters to the batch.
0:      * 
0:      * @exception SQLException if a database-access error occurs.
0:      */
0:     public void addBatch() throws SQLException {
0: 	  checkStatus();
0: 
0: 	  // need to synchronized to ensure that two threads
0: 	  // don't both create a Vector at the same time. This
0: 	  // would lead to one of the set of parameters being thrown
0: 	  // away
0:   	  synchronized (getConnectionSynchronization()) {
0:   			if (batchStatements == null)
0:   				batchStatements = new Vector();
0: 
0:           //get a clone of the parameterValueSet and save it in the vector
0:           //which will be used later on at the time of batch execution.
0:           //This way we will get a copy of the current statement's parameter
0:           //values rather than a pointer to the statement's parameter value
0:           //set which will change with every new statement in the batch.
0:           batchStatements.addElement(getParms().getClone());
0:           clearParameters();
0:   	  }
0:     }
0: 
0: 	protected boolean executeBatchElement(Object batchElement) throws SQLException, StandardException {
0: 		
0: 		ParameterValueSet temp = (ParameterValueSet) batchElement;
0: 
0: 		int numberOfParameters = temp.getParameterCount();
0: 
0: 		for (int j=0; j<numberOfParameters; j++) {
0: 			temp.getParameter(j).setInto(this, j + 1);
0: 		}
0: 
0: 		return super.executeStatement(activation, false, true);
0: 	}
0: 
0:  
0: 
0:     /**
0:      * <P>In general, parameter values remain in force for repeated use of a
0:      * Statement. Setting a parameter value automatically clears its
0:      * previous value.  However, in some cases it is useful to immediately
0:      * release the resources used by the current parameter values; this can
0:      * be done by calling clearParameters.
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public void clearParameters() throws SQLException {
0: 		checkStatus();
0: 
0: 		ParameterValueSet pvs = getParms();
0: 		if (pvs != null)
0: 			pvs.clearParameters();
0: 	}
0: 
0:     /**
0: 	 * JDBC 2.0
0: 	 *
0:      * The number, types and properties of a ResultSet's columns
0:      * are provided by the getMetaData method.
0:      *
0:      * @return the description of a ResultSet's columns
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public java.sql.ResultSetMetaData getMetaData() throws SQLException
0: 	{
0: 		checkExecStatus();
0: 		synchronized (getConnectionSynchronization())
0: 		{
0: 			//reason for casting is getActivationClass is not available on PreparedStatement
0: 			ExecPreparedStatement execp = (ExecPreparedStatement)preparedStatement;
0: 
0: 			setupContextStack(); // make sure there's context
0: 
0: 			try {
0: 				//bug 4579 - if the statement is invalid, regenerate the metadata info
0: 				if (preparedStatement.isValid() == false)
0: 				{
0: 					//need to revalidate the statement here, otherwise getResultDescription would
0: 					//still have info from previous valid statement
0: 					preparedStatement.rePrepare(lcc);
0: 					rMetaData = null;
0: 				}
0: 				//bug 4579 - gcDuringGetMetaData will be null if this is the first time
0: 				//getMetaData call is made.
0: 				//Second check - if the statement was revalidated since last getMetaData call,
0: 				//then gcDuringGetMetaData wouldn't match with current generated class name
0: 				if (gcDuringGetMetaData == null || gcDuringGetMetaData.equals(execp.getActivationClass().getName()) == false)
0: 				{
0: 					rMetaData = null;
0: 					gcDuringGetMetaData = execp.getActivationClass().getName();
0: 				}
0: 				if (rMetaData == null)
0: 				{
0: 					ResultDescription resd = preparedStatement.getResultDescription();
0: 					if (resd != null)
0: 					{
0: 						// Internally, the result description has information
0: 						// which is used for insert, update and delete statements
0: 						// Externally, we decided that statements which don't
0: 						// produce result sets such as insert, update and delete
0: 						// should not return ResultSetMetaData.  This is enforced
0: 						// here
0: 						String statementType = resd.getStatementType();
0: 						if (statementType.equals("INSERT") ||
0: 								statementType.equals("UPDATE") ||
0: 								statementType.equals("DELETE"))
0: 							rMetaData = null;
0: 						else
0: 				    		rMetaData = newEmbedResultSetMetaData(resd);
0: 					}
0: 				}
0: 			} catch (Throwable t) {
0: 				throw handleException(t);
0: 			}	finally {
0: 				restoreContextStack();
0: 			}
0: 		}
0: 		return rMetaData;
0: 	}
0: 
0:     //----------------------------------------------------------------------
0:     // Advanced features:
0: 
0:     /**
0: 	 * The interface says that the type of the Object parameter must
0: 	 * be compatible with the type of the targetSqlType. We check that,
0: 	 * and if it flies, we expect the underlying engine to do the
0: 	 * required conversion once we pass in the value using its type.
0: 	 * So, an Integer converting to a CHAR is done via setInteger()
0: 	 * support on the underlying CHAR type.
0:      *
0:      * <p>If x is null, it won't tell us its type, so we pass it on to setNull
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @param x The object containing the input parameter value
0:      * @param targetSqlType The SQL type (as defined in java.sql.Types) to be 
0:      * sent to the database. The scale argument may further qualify this type.
0:      * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
0:      *          this is the number of digits after the decimal.  For all other
0:      *          types this value will be ignored,
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setObject(int parameterIndex, Object x, int targetSqlType, int scale)
0:             throws SQLException {
0: 
0: 		if (x == null) {
0: 			setNull(parameterIndex, targetSqlType);
0: 			return;
0: 		}
0: 
0: 		int paramJDBCType = getParameterJDBCType(parameterIndex);
0: 
0: 		if (paramJDBCType != java.sql.Types.JAVA_OBJECT) {
0: 			if (!DataTypeDescriptor.isJDBCTypeEquivalent(paramJDBCType, targetSqlType)) {
0: 				throw dataTypeConversion(parameterIndex, Util.typeName(targetSqlType));
0: 			}
0: 		}
0: 
0: 		setObject(parameterIndex, x);
0: 				
0: 		/*
0: 		* If the parameter type is DECIMAL or NUMERIC, then
0: 		* we need to set the correct scale  or set it 
0: 		* to the default which is zero for setObject.
0: 		*/
0: 		if ((paramJDBCType == Types.DECIMAL) || 
0: 			 (paramJDBCType == Types.NUMERIC))
0: 		{
0: 			setScale(parameterIndex, scale);
0: 		}	
0: 	}
0: 
0:     /**
0:       * This method is like setObject above, but assumes a scale of zero.
0: 	 * @exception SQLException thrown on failure.
0:       */
0:     public final void setObject(int parameterIndex, Object x, int targetSqlType)
0: 		throws SQLException {
0: 		setObject(parameterIndex, x, targetSqlType, 0);
0: 	}
0: 
0:     /**
0:      * <p>Set the value of a parameter using an object; use the
0:      * java.lang equivalent objects for integral values.
0:      *
0:      * <p>The JDBC specification specifies a standard mapping from
0:      * Java Object types to SQL types.  The given argument java object
0:      * will be converted to the corresponding SQL type before being
0:      * sent to the database.
0:      *
0:      * <p>Note that this method may be used to pass datatabase
0:      * specific abstract data types, by using a Driver specific Java
0:      * type.
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @param x The object containing the input parameter value 
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final void setObject(int parameterIndex, Object x) throws SQLException {
0: 		checkStatus();	
0: 
0: 
0: 		int colType = getParameterJDBCType(parameterIndex);
0: 
0: 		// JDBC Tutorial and Reference books states in the PreparedStatement
0: 		// overview, that passing a untyped null into setObject() is not allowed.
0: 		// JCC disallows this, basically SQL can not handle a untyped NULL.
0: 		// Section 25.1.6 (Third edition), 24.1.5 (Second Edition)
0: 
0: 		if (x == null) {
0: 			//setNull(parameterIndex, colType);
0: 			//return;
0: 			throw dataTypeConversion(parameterIndex, "null");
0: 		}
0: 		
0: 		if (colType == org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT) {
0: 			try {
0: 				/* JDBC is one-based, DBMS is zero-based */
0: 				getParms().setParameterAsObject(parameterIndex - 1, x);
0: 				return;
0: 
0: 			} catch (Throwable t) {
0: 				throw EmbedResultSet.noStateChangeException(t);
0: 			}
0: 		}
0: 
0: 
0: 		// Need to do instanceof checks here so that the behaviour
0: 		// for these calls is consistent with the matching setXXX() value.
0: 
0: 		// These are the supported setObject conversions from JDBC 3.0 table B5
0: 
0: 		if (x instanceof String) {
0: 			setString(parameterIndex, (String) x);
0: 			return;
0: 		}
0: 
0: 		if (x instanceof BigDecimal) {
0: 			setBigDecimal(parameterIndex, (BigDecimal) x);
0: 			return;
0: 		}
0: 		if (x instanceof Boolean) {
0: 			setBoolean(parameterIndex, ((Boolean) x).booleanValue());
0: 			return;
0: 		}
0: 		if (x instanceof Integer) {
0: 			setInt(parameterIndex, ((Integer) x).intValue());
0: 			return;
0: 		}
0: 		if (x instanceof Long) {
0: 			setLong(parameterIndex, ((Long) x).longValue());
0: 			return;
0: 		}
0: 
0: 		if (x instanceof Float) {
0: 			setFloat(parameterIndex, ((Float) x).floatValue());
0: 			return;
0: 		}
0: 		if (x instanceof Double) {
0: 			setDouble(parameterIndex, ((Double) x).doubleValue());
0: 			return;
0: 		}
0: 
0: 		if (x instanceof byte[]) {
0: 			setBytes(parameterIndex, (byte[]) x);
0: 			return;
0: 		}
0: 
0: 		if (x instanceof Date) {
0: 			setDate(parameterIndex, (Date) x);
0: 			return;
0: 		}
0: 		if (x instanceof Time) {
0: 			setTime(parameterIndex, (Time) x);
0: 			return;
0: 		}
0: 		if (x instanceof Timestamp) {
0: 			setTimestamp(parameterIndex, (Timestamp) x);
0: 			return;
0: 		}
0: 
0: 		if (x instanceof Blob) {
0: 			setBlob(parameterIndex, (Blob) x);
0: 			return;
0: 		}
0: 		if (x instanceof Clob) {
0: 			setClob(parameterIndex, (Clob) x);
0: 			return;
0: 		}
0: 
0: 		
0: 		throw dataTypeConversion(parameterIndex, x.getClass().getName());
0: 
0: 	}
0: 
0:     /**
0:      * @see java.sql.Statement#execute
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     public final boolean execute() throws SQLException {
0: 		return executeStatement(activation, false, false);
0: 	}
0:     /**
0:      * Set a parameter to a java.sql.Date value.  The driver converts this
0:      * to a SQL DATE value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public final void setDate(int parameterIndex, java.sql.Date x, Calendar cal)
0: 	    throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.sql.Time value.  The driver converts this
0:      * to a SQL TIME value when it sends it to the database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public final void setTime(int parameterIndex, java.sql.Time x, Calendar cal)
0: 	    throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
0: 
0: 		} catch (Throwable t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0:     /**
0:      * Set a parameter to a java.sql.Timestamp value.  The driver
0:      * converts this to a SQL TIMESTAMP value when it sends it to the
0:      * database.
0:      *
0:      * @param parameterIndex the first parameter is 1, the second is 2, ...
0:      * @param x the parameter value 
0:      * @exception SQLException Feature not implemented for now.
0:      */
0:     public final void setTimestamp(int parameterIndex, java.sql.Timestamp x, Calendar cal)
0: 	    throws SQLException 
0: 	{
0: 		checkStatus();
0: 		try {
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			getParms().getParameterForSet(parameterIndex - 1).setValue(x, cal);
0: 
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 	/**
0: 	 * Get the ParameterValueSet from the activation
0: 	 *
0: 	 *
0: 	 * @return	The ParameterValueSet for the activation
0: 	 *
0: 	 */
0: 	public final ParameterValueSet getParms() {
0: 
0: 		return activation.getParameterValueSet();
0: 	}
0: 
0: 
0: 	/**
0: 		Check the parameterINdex is in range and return the
0: 		array of type descriptors.
0: 
0: 		@exception SQLException parameter is out of range
0: 	*/
0: 	protected final DataTypeDescriptor[] getTypes(int parameterIndex)
0: 		throws SQLException {
0: 
0: 		DataTypeDescriptor[] types = preparedStatement.getParameterTypes();
0: 
0: 		if (types == null) {
0: 			throw newSQLException(SQLState.NO_INPUT_PARAMETERS);
0: 		}
0: 
0: 		/* Check that the parameterIndex is in range. */
0: 		if (parameterIndex < 1 ||
0: 				parameterIndex > types.length) {
0: 
0: 			/* This message matches the one used by the DBMS */
0: 			throw newSQLException(SQLState.LANG_INVALID_PARAM_POSITION, 
0:             new Integer(parameterIndex), new Integer(types.length));
0: 		}
0: 		return types;
0: 	}
0: 
0: 	/**
0: 		Get the target JDBC type for a parameter. Will throw exceptions
0: 		if the parameter index is out of range
0: 
0: 		@exception SQLException parameter is out of range
0: 	*/
0: 	protected int getParameterJDBCType(int parameterIndex)
0: 		throws SQLException {
0: 
0: 		DataTypeDescriptor[] types = getTypes(parameterIndex);
0: 
0: 		int type = types[parameterIndex -1] == null ? 
0: 			Types.OTHER :
0: 			types[parameterIndex - 1].getTypeId().getJDBCTypeId();
0: 
0: 		if (SanityManager.DEBUG) {
0: 			//int pmType = getEmbedParameterSetMetaData().getParameterType(parameterIndex);
0: 			//if (type != pmType) {
0: 				//SanityManager.THROWASSERT("MISMATCH PARAMETER META DATA param " + parameterIndex + " types " + type + " != " + pmType + "\n" + SQLText);
0: 			//}
0: 		}
0: 
0: 		return type;
0: 	}
0: 
0:     /**
0:      * Set the scale of a parameter.
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @param scale	The scale
0: 	 * @exception SQLException thrown on failure.
0:      */
0:     private void setScale(int parameterIndex, int scale)
0: 		throws SQLException 
0: 	{
0: 		checkStatus();
0: 
0: 		if (scale < 0)
0: 			throw newSQLException(SQLState.BAD_SCALE_VALUE, new Integer(scale));
0: 		
0: 		try {
0: 
0: 			ParameterValueSet pvs = getParms();
0: 
0: 			/* JDBC is one-based, DBMS is zero-based */
0: 			DataValueDescriptor value = pvs.getParameter(parameterIndex - 1);
0: 
0: 
0: 			int origvaluelen = value.getLength();
0: 			((VariableSizeDataValue)
0: 						value).setWidth(VariableSizeDataValue.IGNORE_PRECISION, 
0: 							scale, 
0: 							false);
0: 
0: 			if (value.getLength() < origvaluelen)
0: 			{
0: 				activation.addWarning(StandardException.newWarning(SQLState.LANG_VALUE_TRUNCATED, value.getString()));
0: 			}
0: 
0: 		} catch (StandardException t) {
0: 			throw EmbedResultSet.noStateChangeException(t);
0: 		}
0: 	}
0: 
0: 
0: 	/**
0:     * Immitate the function in JDBC 3.0
0:     *
0:     * Retrieves the number, types and properties of this PreparedStatement
0:     * object's parameters.
0:     *
0:     * @return a EmbedParameterSetMetaData object that contains information about the
0:     * number, types and properties of this PreparedStatement object's parameters.
0:     * @exception SQLException if a database access error occurs
0: 	*/
0: 	public EmbedParameterSetMetaData getEmbedParameterSetMetaData()
0:     	throws SQLException
0: 	{
0: 	  checkExecStatus();
0: 	  return new EmbedParameterSetMetaData(
0: 				getParms(), preparedStatement.getParameterTypes());
0: 
0: 	}
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Sets the designated parameter to the given java.net.URL value. The driver
0:     * converts this to an SQL DATALINK value when it sends it to the database.
0:     *
0:     * @param parameterIndex - the first parameter is 1, the second is 2, ...
0:     * @param x - the java.net.URL object to be set
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public final void setURL(int parameterIndex, java.net.URL x)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	//
0: 	// methods to be overridden in subimplementations
0: 	// that want to stay within their subimplementation.
0: 	//
0: 	protected EmbedResultSetMetaData newEmbedResultSetMetaData(ResultDescription resultDesc) {
0: 
0: 		return new EmbedResultSetMetaData(resultDesc.getColumnInfo());
0: 	}
0: 
0: 	public String toString() {
0: 
0: 		if (activation != null)
0: 			return activation.getPreparedStatement().getObjectName();
0: 		return super.toString();
0: 	}
0: 
0: 	/*
0: 	**
0: 	*/
0: 	public void transferParameters(EmbedPreparedStatement newStatement) throws SQLException {
0: 
0: 		try {
0: 			newStatement.activation.setParameters(getParms(), preparedStatement.getParameterTypes());
0: 		} catch (StandardException se) {
0: 			throw EmbedResultSet.noStateChangeException(se);
0: 		}
0: 	}
0: 
0: 	protected boolean executeStatement(Activation a,
0:                      boolean executeQuery, boolean executeUpdate)
0:                      throws SQLException {
0: 
0: 		checkExecStatus();
0: 		checkIfInMiddleOfBatch();
0: 		clearResultSets();
0: 		return super.executeStatement(a, executeQuery, executeUpdate);
0: 	}
0: 
0: 	protected final SQLException dataTypeConversion(int column, String sourceType)
0: 		throws SQLException {
0: 		SQLException se = newSQLException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, getEmbedParameterSetMetaData().getParameterTypeName(column),
0: 			sourceType);
0: 		return se;
0: 	}
0: }
============================================================================