1:eac0369: /*
1:7af6726: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLClob
1:52625a5: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
2:eac0369:  */
1:7ecc1f2: 
1:eac0369: package org.apache.derby.iapi.types;
8:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:cf0fdc4: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:cf0fdc4: 
1:52625a5: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:04acfa5: import org.apache.derby.iapi.services.io.CloneableStream;
1:7f0d066: import org.apache.derby.iapi.services.io.FormatIdInputStream;
1:2f2c745: import org.apache.derby.iapi.services.io.InputStreamUtil;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:52625a5: import org.apache.derby.iapi.util.UTF8Util;
1:eac0369: 
1:5b9a6d9: import org.apache.derby.shared.common.reference.SQLState;
1:5b9a6d9: 
1:cf0fdc4: import java.io.IOException;
1:cf0fdc4: import java.io.InputStream;
1:52625a5: import java.io.ObjectInput;
1:52625a5: import java.io.ObjectOutput;
1:7f0d066: import java.io.PushbackInputStream;
1:9548d38: import java.math.BigDecimal;
1:f38528a: import java.sql.Clob;
1:eac0369: import java.sql.Date;
1:f38528a: import java.sql.SQLException;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:0cab10f: import java.text.RuleBasedCollator;
1:eac0369: import java.util.Calendar;
1:eac0369: 
1:eac0369: 
1:cf0fdc4: /**
1:403684d:  * SQLClob represents a CLOB value with UCS_BASIC collation.
1:403684d:  * CLOB supports LIKE operator only for collation.
1:eac0369:  */
1:eac0369: public class SQLClob
1:eac0369: 	extends SQLVarchar
3:eac0369: {
1:52625a5:     /** The header generator used for 10.4 (or older) databases. */
1:52625a5:     private static final StreamHeaderGenerator TEN_FOUR_CLOB_HEADER_GENERATOR =
1:52625a5:             new ClobStreamHeaderGenerator(true);
1:7af6726: 
1:4bd0300:     /** The header generator used for 10.5 databases. */
1:4bd0300:     private static final StreamHeaderGenerator TEN_FIVE_CLOB_HEADER_GENERATOR =
1:4bd0300:             new ClobStreamHeaderGenerator(false);
1:4bd0300: 
1:7af6726:     /**
1:85de1e4:      * The maximum number of bytes used by the stream header.
1:85de1e4:      * <p>
1:85de1e4:      * Use the length specified by the ten five header generator.
1:85de1e4:      */
1:85de1e4:     private static final int MAX_STREAM_HEADER_LENGTH =
1:85de1e4:             TEN_FIVE_CLOB_HEADER_GENERATOR.getMaxHeaderLength();
1:85de1e4: 
1:85de1e4:     /**
1:cf0fdc4:      * The descriptor for the stream. If there is no stream this should be
1:cf0fdc4:      * {@code null}, which is also true if the descriptor hasen't been
1:cf0fdc4:      * constructed yet.
1:52625a5:      * <em>Note</em>: Always check if {@code stream} is non-null before using
1:52625a5:      * the information stored in the descriptor internally.
1:cf0fdc4:      */
1:cf0fdc4:     private CharacterStreamDescriptor csd;
1:cf0fdc4: 
1:52625a5:     /** Tells if the database is being accessed in soft upgrade mode. */
1:52625a5:     private Boolean inSoftUpgradeMode = null;
1:52625a5: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface.
1:eac0369: 	 *
1:eac0369: 	 * These are actually all implemented in the super-class, but we need
1:eac0369: 	 * to duplicate some of them here so they can be called by byte-code
1:eac0369: 	 * generation, which needs to know the class the method appears in.
1:7af6726: 	 */
1:7af6726: 
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return TypeId.CLOB_NAME;
5:eac0369: 	}
1:52625a5: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:04acfa5:     /**
1:04acfa5:      * Returns a clone of this CLOB value.
1:04acfa5:      * <p>
1:04acfa5:      * Unlike the other binary types, CLOBs can be very large. We try to clone
1:04acfa5:      * the underlying stream when possible to avoid having to materialize the
1:04acfa5:      * value into memory.
1:04acfa5:      *
1:04acfa5:      * @param forceMaterialization any streams representing the data value will
1:04acfa5:      *      be materialized if {@code true}, the data value will be kept as a
1:04acfa5:      *      stream if possible if {@code false}
1:04acfa5:      * @return A clone of this CLOB value.
1:04acfa5:      * @see DataValueDescriptor#cloneValue
1:04acfa5:      */
1:04acfa5:     public DataValueDescriptor cloneValue(boolean forceMaterialization) {
1:04acfa5:         // TODO: Add optimization for materializing "smallish" streams. This
1:04acfa5:         //       may be more effective because the data doesn't have to be
1:04acfa5:         //       decoded multiple times.
1:04acfa5:         final SQLClob clone = new SQLClob();
1:04acfa5:         // Copy the soft upgrade mode state.
1:04acfa5:         clone.inSoftUpgradeMode = inSoftUpgradeMode;
1:04acfa5:         
1:04acfa5:         // Shortcut cases where the value is NULL.
1:04acfa5:         if (isNull()) {
1:8f75194:             return clone;
1:04acfa5:         }
1:04acfa5: 
1:04acfa5:         if (!forceMaterialization) {
1:04acfa5:             if (stream != null && stream instanceof CloneableStream) {
1:04acfa5:                 int length = UNKNOWN_LOGICAL_LENGTH;
1:04acfa5:                 if (csd != null && csd.getCharLength() > 0) {
1:04acfa5:                     length = (int)csd.getCharLength();
1:04acfa5:                 }
1:04acfa5:                 clone.setValue(((CloneableStream)stream).cloneStream(), length);
1:04acfa5:             } else if (_clobValue != null) {
1:04acfa5:                 // Assumes the Clob object can be shared between value holders.
1:04acfa5:                 clone.setValue(_clobValue);
1:04acfa5:             }
1:04acfa5:             // At this point we may still not have cloned the value because we
1:04acfa5:             // have a stream that isn't cloneable.
1:04acfa5:             // TODO: Add functionality to materialize to temporary disk storage
1:04acfa5:             //       to avoid OOME for large CLOBs.
1:04acfa5:         }
1:04acfa5: 
1:04acfa5:         // See if we are forced to materialize the value, either because
1:04acfa5:         // requested by the user or because we don't know how to clone it.
1:04acfa5:         if (clone.isNull() || forceMaterialization) {
1:04acfa5:             try {
1:04acfa5:                 clone.setValue(getString());
1:04acfa5:             } catch (StandardException se) {
1:04acfa5:                 if (SanityManager.DEBUG) {
1:e7d2a42:                     SanityManager.THROWASSERT("Unexpected exception", se);
1:04acfa5:                 }
1:04acfa5:                 return null;
1:04acfa5:             }
1:04acfa5:         }
1:04acfa5:         return clone;
1:04acfa5:     }
1:eac0369: 
1:52625a5: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:8f75194:         SQLClob newClob = new SQLClob();
1:8f75194:         // Copy the soft upgrade mode state.
1:8f75194:         newClob.inSoftUpgradeMode = inSoftUpgradeMode;
1:8f75194:         return newClob;
1:eac0369: 	}
1:eac0369: 
1:0cab10f: 	/** @see StringDataValue#getValue(RuleBasedCollator) */
1:0cab10f: 	public StringDataValue getValue(RuleBasedCollator collatorForComparison)
1:eac0369: 	{
1:0cab10f: 		if (collatorForComparison == null)
1:0cab10f: 		{//null collatorForComparison means use UCS_BASIC for collation
1:0cab10f: 		    return this;			
1:0cab10f: 		} else {
1:0cab10f: 			//non-null collatorForComparison means use collator sensitive
1:0cab10f: 			//implementation of SQLClob
1:726b66f: 		     CollatorSQLClob s = new CollatorSQLClob(collatorForComparison);
1:0cab10f: 		     s.copyState(this);
1:0cab10f: 		     return s;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
2:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_CLOB_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * constructors
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public SQLClob()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLClob(String val)
1:eac0369: 	{
1:eac0369: 		super(val);
1:eac0369: 	}
1:eac0369: 
1:638f1b4: 	public SQLClob(Clob val)
1:638f1b4: 	{
1:638f1b4: 		super(val);
1:638f1b4: 	}
1:638f1b4: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/* @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.CLOB_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** disable conversions to/from most types for CLOB.
1:eac0369: 	** TEMP - real fix is to re-work class hierachy so
1:eac0369: 	** that CLOB is towards the root, not at the leaf.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public boolean	getBoolean() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("boolean");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public byte	getByte() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("byte");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public short	getShort() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("short");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int	getInt() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("int");
1:eac0369: 	}
1:eac0369: 
1:52625a5:     /**
1:52625a5:      * Returns the character length of this Clob.
1:52625a5:      * <p>
1:52625a5:      * If the value is stored as a stream, the stream header will be read. If
1:52625a5:      * the stream header doesn't contain the stream length, the whole stream
1:52625a5:      * will be decoded to determine the length.
1:52625a5:      *
1:52625a5:      * @return The character length of this Clob.
1:52625a5:      * @throws StandardException if obtaining the length fails
1:52625a5:      */
1:52625a5:     public int getLength() throws StandardException {
1:52625a5:         if (stream == null) {
1:52625a5:             return super.getLength();
1:52625a5:         }
1:961ecca:         //
1:961ecca:         // The following check was put in to fix DERBY-4544. We seem to get
1:961ecca:         // confused if we have to re-use non-resetable streams.
1:961ecca:         //
1:961ecca:         if ( !(stream instanceof Resetable) ) { return super.getLength(); }
1:961ecca:         
1:52625a5:         // The Clob is represented as a stream.
1:52625a5:         // Make sure we have a stream descriptor.
1:52625a5:         boolean repositionStream = (csd != null);
1:52625a5:         if (csd == null) {
1:52625a5:             getStreamWithDescriptor();
1:52625a5:             // We know the stream is at the first char position here.
1:52625a5:         }
1:52625a5:         if (csd.getCharLength() != 0) {
1:52625a5:             return (int)csd.getCharLength();
1:52625a5:         }
1:52625a5:         // We now know that the Clob is represented as a stream, but not if the
1:52625a5:         // length is unknown or actually zero. Check.
1:52625a5:         if (SanityManager.DEBUG) {
1:52625a5:             // The stream isn't expecetd to be position aware here.
1:52625a5:             SanityManager.ASSERT(!csd.isPositionAware());
1:52625a5:         }
1:52625a5:         long charLength = 0;
1:52625a5:         try {
1:52625a5:             if (repositionStream) {
1:0f92bc7:                 rewindStream(stream, csd.getDataOffset());
1:52625a5:             }
1:52625a5:             charLength = UTF8Util.skipUntilEOF(stream);
1:52625a5:             // We just drained the whole stream. Reset it.
1:0f92bc7:             rewindStream(stream, 0);
1:52625a5:         } catch (IOException ioe) {
1:52625a5:             throwStreamingIOException(ioe);
1:52625a5:         }
1:52625a5:         // Update the descriptor in two ways;
1:52625a5:         //   (1) Set the char length, whether it is zero or not.
1:52625a5:         //   (2) Set the current byte pos to zero.
1:52625a5:         csd = new CharacterStreamDescriptor.Builder().copyState(csd).
1:52625a5:                 charLength(charLength).curBytePos(0).
1:52625a5:                 curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).build();
1:52625a5:         return (int)charLength;
1:52625a5:     }
1:52625a5: 
1:eac0369: 	public long	getLong() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("long");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public float	getFloat() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("float");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public double	getDouble() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("double");
1:eac0369: 	}
1:2c6f0a2: 	public int typeToBigDecimal() throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		throw dataTypeConversion("java.math.BigDecimal");
1:2c6f0a2: 	}
1:eac0369: 	public byte[]	getBytes() throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("byte[]");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Date	getDate(java.util.Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Date");
1:eac0369: 	}
1:eac0369: 
1:cf0fdc4:     /**
1:a2a0ff2:      * @exception StandardException     Thrown on error
1:a2a0ff2:      */
1:a2a0ff2:     public Object   getObject() throws StandardException
1:a2a0ff2:     {
1:a2a0ff2:         if ( _clobValue != null ) { return _clobValue; }
1:a2a0ff2:         else
1:a2a0ff2:         {
1:a2a0ff2:             String stringValue = getString();
1:a2a0ff2: 
1:a2a0ff2:             if ( stringValue == null ) { return null; }
1:a2a0ff2:             else { return new HarmonySerialClob( stringValue.toCharArray() ); }
1:a2a0ff2:         }
1:a2a0ff2:     }
1:a2a0ff2: 
1:a2a0ff2:     /**
1:cf0fdc4:      * Returns a descriptor for the input stream for this CLOB value.
1:cf0fdc4:      * <p>
1:cf0fdc4:      * The descriptor contains information about header data, current positions,
1:cf0fdc4:      * length, whether the stream should be buffered or not, and if the stream
1:cf0fdc4:      * is capable of repositioning itself.
1:52625a5:      * <p>
1:52625a5:      * When this method returns, the stream is positioned on the first
1:52625a5:      * character position, such that the next read will return the first
1:52625a5:      * character in the stream.
1:cf0fdc4:      *
1:cf0fdc4:      * @return A descriptor for the stream, which includes a reference to the
1:cf0fdc4:      *      stream itself. If the value cannot be represented as a stream,
1:f552f7a:      *      {@code null} is returned instead of a descriptor.
1:cf0fdc4:      * @throws StandardException if obtaining the descriptor fails
1:cf0fdc4:      */
1:cf0fdc4:     public CharacterStreamDescriptor getStreamWithDescriptor()
1:cf0fdc4:             throws StandardException {
1:cf0fdc4:         if (stream == null) {
1:cf0fdc4:             // Lazily reset the descriptor here, to avoid further changes in
1:cf0fdc4:             // {@code SQLChar}.
1:cf0fdc4:             csd = null;
1:541361f:             throw StandardException.newException(
1:541361f:                     SQLState.LANG_STREAM_INVALID_ACCESS, getTypeName());
1:cf0fdc4:         }
1:cf0fdc4:         // NOTE: Getting down here several times is potentially dangerous.
1:cf0fdc4:         // When the stream is published, we can't assume we know the position
1:cf0fdc4:         // any more. The best we can do, which may hurt performance to some
1:cf0fdc4:         // degree in some non-recommended use-cases, is to reset the stream if
1:cf0fdc4:         // possible.
1:cf0fdc4:         if (csd != null) {
1:cf0fdc4:             if (stream instanceof Resetable) {
1:cf0fdc4:                 try {
1:52625a5:                     ((Resetable)stream).resetStream();
1:2f2c745:                     // Make sure the stream is in sync with the descriptor.
1:2f2c745:                     InputStreamUtil.skipFully(stream, csd.getCurBytePos());
1:2f2c745:                 } catch (IOException ioe) {
1:2f2c745:                     throwStreamingIOException(ioe);
1:2f2c745:                 }
1:cf0fdc4:             } else {
1:cf0fdc4:                 if (SanityManager.DEBUG) {
1:cf0fdc4:                     SanityManager.THROWASSERT("Unable to reset stream when " +
1:cf0fdc4:                             "fetched the second time: " + stream.getClass());
1:cf0fdc4:                 }
1:cf0fdc4:             }
1:cf0fdc4:         }
1:cf0fdc4: 
1:cf0fdc4:         if (csd == null) {
1:cf0fdc4:             // First time, read the header format of the stream.
1:cf0fdc4:             try {
1:52625a5:                 // Assume new header format, adjust later if necessary.
1:52625a5:                 byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:cf0fdc4:                 int read = stream.read(header);
1:5b9a6d9:                 // Expect at least two header bytes.
1:5b9a6d9:                 if (SanityManager.DEBUG) {
1:5b9a6d9:                     SanityManager.ASSERT(read > 1,
1:5b9a6d9:                             "Too few header bytes: " + read);
1:5b9a6d9:                 }
1:52625a5:                 HeaderInfo hdrInfo = investigateHeader(header, read);
1:52625a5:                 if (read > hdrInfo.headerLength()) {
1:52625a5:                     // We have read too much. Reset the stream.
1:6fe26f8:                     read = hdrInfo.headerLength();
1:0f92bc7:                     rewindStream(stream, read);
1:cf0fdc4:                 }
1:cf0fdc4:                 csd = new CharacterStreamDescriptor.Builder().stream(stream).
1:cf0fdc4:                     bufferable(false).positionAware(false).
1:52625a5:                     curCharPos(read == 0 ?
1:52625a5:                         CharacterStreamDescriptor.BEFORE_FIRST : 1).
1:52625a5:                     curBytePos(read).
1:52625a5:                     dataOffset(hdrInfo.headerLength()).
1:52625a5:                     byteLength(hdrInfo.byteLength()).
1:52625a5:                     charLength(hdrInfo.charLength()).build();
2:cf0fdc4:             } catch (IOException ioe) {
1:5b9a6d9:                 // Check here to see if the root cause is a container closed
1:5b9a6d9:                 // exception. If so, this most likely means that the Clob was
1:5b9a6d9:                 // accessed after a commit or rollback on the connection.
1:5b9a6d9:                 Throwable rootCause = ioe;
1:5b9a6d9:                 while (rootCause.getCause() != null) {
1:5b9a6d9:                     rootCause = rootCause.getCause();
1:5b9a6d9:                 }
1:5b9a6d9:                 if (rootCause instanceof StandardException) {
1:5b9a6d9:                     StandardException se = (StandardException)rootCause;
1:5b9a6d9:                     if (se.getMessageId().equals(
1:5b9a6d9:                             SQLState.DATA_CONTAINER_CLOSED)) {
1:5b9a6d9:                         throw StandardException.newException(
1:5b9a6d9:                                 SQLState.BLOB_ACCESSED_AFTER_COMMIT, ioe);
1:5b9a6d9:                     }
1:5b9a6d9:                 }
2:cf0fdc4:                 throwStreamingIOException(ioe);
1:cf0fdc4:             }
1:cf0fdc4:         }
1:cf0fdc4:         return this.csd;
1:cf0fdc4:     }
1:cf0fdc4: 
1:541361f:     /**
1:541361f:      * Tells if this CLOB value is, or will be, represented by a stream.
1:541361f:      *
1:541361f:      * @return {@code true} if the value is represented by a stream,
1:541361f:      *      {@code false} otherwise.
1:541361f:      */
1:541361f:     public boolean hasStream() {
1:541361f:         return stream != null;
1:541361f:     }
1:541361f: 
1:eac0369: 	public Time	getTime(java.util.Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Time");
1:cf0fdc4: 	}
1:cf0fdc4: 
1:eac0369: 	public Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throw dataTypeConversion("java.sql.Timestamp");
1:cf0fdc4: 	}
1:cf0fdc4:     
1:f73afdc:     /**
1:f73afdc:      * Gets a trace representation of the CLOB for debugging.
1:f73afdc:      *
1:f73afdc:      * @return a trace representation of the CLOB.
1:f73afdc:      */
1:f73afdc:     public final String getTraceString() throws StandardException {
1:f73afdc:         // Check if the value is SQL NULL.
1:f73afdc:         if (isNull()) {
1:f73afdc:             return "NULL";
1:cf0fdc4:         }
1:f73afdc: 
1:f73afdc:         // Check if we have a stream.
1:541361f:         if (hasStream()) {
1:4b66efc:             return (getTypeName() + "(" + getStream().toString() + ")");
1:f73afdc:         }
1:f73afdc: 
1:4b66efc:         return (getTypeName() + "(" + getLength() + ")");
1:f73afdc:     }
1:eac0369:     
1:eac0369:     /**
1:28030d7:      * Normalization method - this method may be called when putting
1:28030d7:      * a value into a SQLClob, for example, when inserting into a SQLClob
1:28030d7:      * column.  See NormalizeResultSet in execution.
1:28030d7:      * Per the SQL standard ,if the clob column is not big enough to 
1:28030d7:      * hold the value being inserted,truncation error will result
1:28030d7:      * if there are trailing non-blanks. Truncation of trailing blanks
1:28030d7:      * is allowed.
1:28030d7:      * @param desiredType   The type to normalize the source column to
1:28030d7:      * @param sourceValue   The value to normalize
1:28030d7:      *
1:28030d7:      *
1:28030d7:      * @exception StandardException             Thrown for null into
1:28030d7:      *                                          non-nullable column, and for
1:28030d7:      *                                          truncation error
1:eac0369:      */
1:eac0369: 
1:28030d7:     public void normalize(
1:28030d7:                 DataTypeDescriptor desiredType,
1:28030d7:                 DataValueDescriptor sourceValue)
1:eac0369:                     throws StandardException
1:eac0369:     {
1:28030d7:         // if sourceValue is of type clob, and has a stream,
1:28030d7:         // dont materialize it here (as the goal of using a stream is to
1:28030d7:         // not have to materialize whole object in memory in the server), 
1:28030d7:         // but instead truncation checks will be done when data is streamed in.
1:28030d7:         // (see ReaderToUTF8Stream) 
1:28030d7:         // if sourceValue is not a stream, then follow the same
1:28030d7:         // protocol as varchar type for normalization
1:28030d7:         if( sourceValue instanceof SQLClob)
1:eac0369:         {
1:28030d7:             SQLClob clob = (SQLClob)sourceValue;
1:28030d7:             if (clob.stream != null)
1:eac0369:             {
1:28030d7:                 copyState(clob);
1:28030d7:                 return;
1:f73afdc:             }
1:eac0369:         }
1:f38528a:         
1:28030d7:         super.normalize(desiredType,sourceValue);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public void setValue(Time theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Time");
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Timestamp");
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public void setValue(Date theValue, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.sql.Date");
1:eac0369: 	}
1:eac0369: 	
1:9548d38: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("java.math.BigDecimal");
1:eac0369: 	}
1:eac0369: 
1:cf0fdc4:     /**
1:cf0fdc4:      * Sets a new stream for this CLOB.
1:cf0fdc4:      *
1:cf0fdc4:      * @param stream the new stream
1:cf0fdc4:      */
1:cf0fdc4:     public final void setStream(InputStream stream) {
1:cf0fdc4:         super.setStream(stream);
1:cf0fdc4:         // Discard the old stream descriptor.
1:cf0fdc4:         this.csd = null;
1:cf0fdc4:     }
1:cf0fdc4: 
1:52625a5:     public final void restoreToNull() {
1:52625a5:         this.csd = null;
1:52625a5:         super.restoreToNull();
1:52625a5:     }
1:52625a5: 
1:eac0369: 	public void setValue(int theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("int");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(double theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("double");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(float theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("float");
1:eac0369: 	}
1:eac0369:  
1:eac0369: 	public void setValue(short theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("short");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(long theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("long");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setValue(byte theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("byte");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(boolean theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("boolean");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(byte[] theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		throwLangSetMismatch("byte[]");
1:eac0369: 	}
1:f38528a:     
1:f38528a:     /**
1:f38528a:      * Set the value from an non-null Java.sql.Clob object.
1:f38528a:      */
1:f38528a:     final void setObject(Object theValue)
1:f38528a:         throws StandardException
1:f38528a:     {
1:f38528a:         Clob vc = (Clob) theValue;
1:f38528a:         
1:f38528a:         try {
1:f38528a:             long vcl = vc.length();
1:f38528a:             if (vcl < 0L || vcl > Integer.MAX_VALUE)
1:f38528a:                 throw this.outOfRange();
1:5b9a6d9:             // For small values, just materialize the value.
1:5b9a6d9:             // NOTE: Using streams for the empty string ("") isn't supported
1:5b9a6d9:             // down this code path when in soft upgrade mode, because the code
1:5b9a6d9:             // reading the header bytes ends up reading zero bytes (i.e., it
1:5b9a6d9:             // doesn't get the header / EOF marker).
1:5b9a6d9:             if (vcl < 32*1024) {
1:5b9a6d9:                 setValue(vc.getSubString(1, (int)vcl));
1:5b9a6d9:             } else {
1:5b9a6d9:                 ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(
1:5b9a6d9:                         vc.getCharacterStream(), (int) vcl, 0, TypeId.CLOB_NAME,
1:5b9a6d9:                         getStreamHeaderGenerator());
1:5b9a6d9:                 setValue(utfIn, (int) vcl);
1:5b9a6d9:             }
1:f38528a:         } catch (SQLException e) {
1:f38528a:             throw dataTypeConversion("DAN-438-tmp");
1:f38528a:        }
1:f38528a:     }
1:f38528a: 
1:eac0369:     /**
1:52625a5:      * Writes the CLOB data value to the given destination stream using the
1:52625a5:      * modified UTF-8 format.
1:52625a5:      *
1:52625a5:      * @param out destination stream
1:52625a5:      * @throws IOException if writing to the destination stream fails
1:52625a5:      */
1:52625a5:     public void writeExternal(ObjectOutput out)
1:52625a5:             throws IOException {
1:52625a5:         super.writeClobUTF(out);
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Returns a stream header generator for a Clob.
1:52625a5:      * <p>
1:52625a5:      * <em>NOTE</em>: To guarantee a successful generation, one of the following
1:52625a5:      * two conditions must be met at header or EOF generation time:
1:d92fa8c:      * <ul> <li>{@code setStreamHeaderFormat} has been invoked before the header
1:52625a5:      *          generator was obtained.</li>
1:52625a5:      *      <li>There is context at generation time, such that the mode can be
1:52625a5:      *          determined by obtaining the database context and by consulting
1:52625a5:      *          the data dictionary.</li>
1:52625a5:      * </ul>
1:52625a5:      *
1:52625a5:      * @return A stream header generator.
1:52625a5:      */
1:52625a5:     public StreamHeaderGenerator getStreamHeaderGenerator() {
1:52625a5:         if (inSoftUpgradeMode == null) {
1:52625a5:             // We don't know which mode we are running in, return a generator
1:52625a5:             // the will check this when asked to generate the header.
1:52625a5:             return new ClobStreamHeaderGenerator(this);
1:52625a5:         } else {
1:52625a5:             if (inSoftUpgradeMode == Boolean.TRUE) {
1:52625a5:                 return TEN_FOUR_CLOB_HEADER_GENERATOR;
1:52625a5:             } else {
1:52625a5:                 return TEN_FIVE_CLOB_HEADER_GENERATOR;
1:52625a5:             }
1:52625a5:         }
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Tells whether the database is being accessed in soft upgrade mode or not.
1:52625a5:      *
1:52625a5:      * @param inSoftUpgradeMode {@code TRUE} if the database is accessed in
1:52625a5:      *      soft upgrade mode, {@code FALSE} is not, or {@code null} if unknown
1:52625a5:      */
1:d92fa8c:     public void setStreamHeaderFormat(Boolean inSoftUpgradeMode) {
1:52625a5:         this.inSoftUpgradeMode = inSoftUpgradeMode;
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Investigates the header and returns length information.
1:52625a5:      *
1:52625a5:      * @param hdr the raw header bytes
1:52625a5:      * @param bytesRead number of bytes written into the raw header bytes array
1:52625a5:      * @return The information obtained from the header.
1:52625a5:      * @throws IOException if the header format is invalid, or the stream
1:52625a5:      *      seems to have been corrupted
1:52625a5:      */
1:52625a5:     private HeaderInfo investigateHeader(byte[] hdr, int bytesRead)
1:52625a5:             throws IOException {
1:52625a5:         int dataOffset = MAX_STREAM_HEADER_LENGTH;
1:52625a5:         int utfLen = -1;
1:52625a5:         int strLen = -1;
1:52625a5: 
1:52625a5:         // Peek at the magic byte.
1:52625a5:         if (bytesRead < dataOffset || (hdr[2] & 0xF0) != 0xF0) {
1:52625a5:             // We either have a very short value with the old header
1:52625a5:             // format, or the stream is corrupted.
1:52625a5:             // Assume the former and check later (see further down).
1:52625a5:             dataOffset = 2;
1:52625a5:         }
1:52625a5: 
1:52625a5:         // Do we have a pre 10.5 header?
1:52625a5:         if (dataOffset == 2) {
1:52625a5:             // Note that we add the two bytes holding the header to the total
1:52625a5:             // length only if we know how long the user data is.
1:52625a5:             utfLen = ((hdr[0] & 0xFF) << 8) | ((hdr[1] & 0xFF));
1:52625a5:             // Sanity check for small streams:
1:52625a5:             // The header length pluss the encoded length must be equal to the
1:52625a5:             // number of bytes read.
1:52625a5:             if (bytesRead < MAX_STREAM_HEADER_LENGTH) {
1:52625a5:                 if (dataOffset + utfLen != bytesRead) {
1:52625a5:                     throw new IOException("Corrupted stream; headerLength=" +
1:52625a5:                             dataOffset + ", utfLen=" + utfLen + ", bytesRead=" +
1:52625a5:                             bytesRead);
1:52625a5:                 }
1:52625a5:             }
1:52625a5:             if (utfLen > 0) {
1:52625a5:                 utfLen += dataOffset;
1:52625a5:             }
1:52625a5:         } else if (dataOffset == 5) {
1:52625a5:             // We are dealing with the 10.5 stream header format.
1:52625a5:             int hdrFormat = hdr[2] & 0x0F;
1:52625a5:             switch (hdrFormat) {
1:52625a5:                 case 0: // 0xF0
1:52625a5:                     strLen = (
1:52625a5:                                 ((hdr[0] & 0xFF) << 24) |
1:52625a5:                                 ((hdr[1] & 0xFF) << 16) |
1:52625a5:                                 // Ignore the third byte (index 2).
1:52625a5:                                 ((hdr[3] & 0xFF) <<  8) |
1:52625a5:                                 ((hdr[4] & 0xFF) <<  0)
1:52625a5:                              );
1:52625a5:                     break;
1:52625a5:                 default:
1:52625a5:                     // We don't know how to handle this header format.
1:52625a5:                     throw new IOException("Invalid header format " +
1:52625a5:                             "identifier: " + hdrFormat + "(magic byte is 0x" +
1:52625a5:                             Integer.toHexString(hdr[2] & 0xFF) + ")");
1:52625a5:             }
1:52625a5:         }
1:52625a5:         if (SanityManager.DEBUG) {
1:52625a5:             SanityManager.ASSERT(utfLen > -1 || strLen > -1);
1:52625a5:         }
1:52625a5:         return new HeaderInfo(dataOffset, dataOffset == 5 ? strLen : utfLen);
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Reads and materializes the CLOB value from the stream.
1:52625a5:      *
1:52625a5:      * @param in source stream
1:52625a5:      * @throws java.io.UTFDataFormatException if an encoding error is detected
1:52625a5:      * @throws IOException if reading from the stream fails, or the content of
1:52625a5:      *      the stream header is invalid
1:52625a5:      */
1:52625a5:     public void readExternal(ObjectInput in)
1:52625a5:             throws IOException {
1:52625a5:         HeaderInfo hdrInfo;
1:52625a5:         if (csd != null) {
1:52625a5:             int hdrLen = (int)csd.getDataOffset();
1:52625a5:             int valueLength = (hdrLen == 5) ? (int)csd.getCharLength()
1:52625a5:                                             : (int)csd.getByteLength();
1:52625a5:             hdrInfo = new HeaderInfo(hdrLen, valueLength);
1:52625a5:             // Make sure the stream is correctly positioned.
1:0f92bc7:             rewindStream((InputStream)in, hdrLen);
1:52625a5:         } else {
1:0f92bc7:             final InputStream srcIn = (InputStream)in;
1:0f92bc7:             final boolean markSet = srcIn.markSupported();
1:5b9a6d9:             if (markSet) {
1:0f92bc7:                 srcIn.mark(MAX_STREAM_HEADER_LENGTH);
1:5b9a6d9:             }
1:52625a5:             byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:52625a5:             int read = in.read(header);
1:5b9a6d9:             // Expect at least two header bytes.
1:5b9a6d9:             if (SanityManager.DEBUG) {
1:5b9a6d9:                 SanityManager.ASSERT(read > 1, "Too few header bytes: " + read);
1:5b9a6d9:             }
1:52625a5:             hdrInfo = investigateHeader(header, read);
1:52625a5:             if (read > hdrInfo.headerLength()) {
1:7f0d066:                 // We read too much data. To "unread" the bytes, the following
1:7f0d066:                 // mechanisms will be attempted:
1:7f0d066:                 //  1) See if we set a mark on the stream, if so reset it.
1:7f0d066:                 //  2) If we have a FormatIdInputStream, use a
1:7f0d066:                 //     PushBackInputStream and use it as the source.
1:7f0d066:                 //  3) Try using the Resetable interface.
1:7f0d066:                 // To avoid silent data truncation / data corruption, we fail
1:7f0d066:                 // in step three if the stream isn't resetable.
1:5b9a6d9:                 if (markSet) {
1:7f0d066:                     // 1) Reset the stream to the previously set mark.
1:0f92bc7:                     srcIn.reset();
1:0f92bc7:                     InputStreamUtil.skipFully(srcIn, hdrInfo.headerLength());
1:7f0d066:                 } else if (in instanceof FormatIdInputStream) {
1:7f0d066:                     // 2) Add a push back stream on top of the underlying
1:7f0d066:                     // source, and unread the surplus bytes we read. Set the
1:7f0d066:                     // push back stream to be the source of the data input obj.
1:7f0d066:                     final int surplus = read - hdrInfo.headerLength();
1:7f0d066:                     FormatIdInputStream formatIn = (FormatIdInputStream)in;
1:7f0d066:                     PushbackInputStream pushbackIn = new PushbackInputStream(
1:7f0d066:                             formatIn.getInputStream(), surplus);
1:7f0d066:                     pushbackIn.unread(header, hdrInfo.headerLength(), surplus);
1:7f0d066:                     formatIn.setInput(pushbackIn);
1:7f0d066:                 } else {
1:7f0d066:                     // 3) Assume we have a store stream.
1:0f92bc7:                     rewindStream(srcIn, hdrInfo.headerLength());
1:5b9a6d9:                 }
1:52625a5:             }
1:52625a5:         }
1:52625a5:         // The data will be materialized in memory, in a char array.
1:5b9a6d9:         // Subtract the header length from the byte length if there is a byte
1:5b9a6d9:         // encoded in the header, otherwise the decode routine will try to read
1:5b9a6d9:         // too many bytes.
1:5b9a6d9:         int byteLength = 0; // zero is interpreted as unknown / unset
1:5b9a6d9:         if (hdrInfo.byteLength() != 0) {
1:5b9a6d9:             byteLength = hdrInfo.byteLength() - hdrInfo.headerLength();
1:5b9a6d9:         }
1:5b9a6d9:         super.readExternal(in, byteLength, hdrInfo.charLength());
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Reads and materializes the CLOB value from the stream.
1:52625a5:      *
1:52625a5:      * @param in source stream
1:52625a5:      * @throws java.io.UTFDataFormatException if an encoding error is detected
1:52625a5:      * @throws IOException if reading from the stream fails, or the content of
1:52625a5:      *      the stream header is invalid
1:52625a5:      */
1:52625a5:     public void readExternalFromArray(ArrayInputStream in)
1:52625a5:             throws IOException {
1:52625a5:         // It is expected that the position of the array input stream has been
1:52625a5:         // set to the correct position before this method is invoked.
1:52625a5:         int prevPos = in.getPosition();
1:52625a5:         byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:52625a5:         int read = in.read(header);
1:5b9a6d9:         // Expect at least two header bytes.
1:5b9a6d9:         if (SanityManager.DEBUG) {
1:5b9a6d9:             SanityManager.ASSERT(read > 1, "Too few header bytes: " + read);
1:5b9a6d9:         }
1:52625a5:         HeaderInfo hdrInfo = investigateHeader(header, read);
1:52625a5:         if (read > hdrInfo.headerLength()) {
1:52625a5:             // Reset stream. This path will only be taken for Clobs stored
1:52625a5:             // with the pre 10.5 stream header format.
1:52625a5:             // Note that we set the position to before the header again, since
1:52625a5:             // we know the header will be read again.
1:52625a5:             in.setPosition(prevPos);
1:52625a5:             super.readExternalFromArray(in);
1:52625a5:         } else {
1:52625a5:             // We read only header bytes, next byte is user data.
1:52625a5:             super.readExternalClobFromArray(in, hdrInfo.charLength());
1:52625a5:         }
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Rewinds the stream to the beginning and then skips the specified number
1:52625a5:      * of bytes.
1:52625a5:      *
1:0f92bc7:      * @param in input stream to rewind
1:0f92bc7:      * @param offset number of bytes to skip
1:52625a5:      * @throws IOException if resetting or reading from the stream fails
1:52625a5:      */
1:0f92bc7:     private void rewindStream(InputStream in, long offset)
1:52625a5:             throws IOException {
1:52625a5:         try {
1:0f92bc7:             ((Resetable)in).resetStream();
1:0f92bc7:             InputStreamUtil.skipFully(in, offset);
1:52625a5:         } catch (StandardException se) {
1:52625a5:             IOException ioe = new IOException(se.getMessage());
1:52625a5:             ioe.initCause(se);
1:52625a5:             throw ioe;
1:52625a5:         }
1:52625a5:     }
1:52625a5: 
1:52625a5:     /**
1:52625a5:      * Holder class for header information gathered from the raw byte header in 
1:52625a5:      * the stream.
1:52625a5:      */
1:52625a5:     //@Immutable
1:52625a5:     private static class HeaderInfo {
1:52625a5: 
1:52625a5:         /** The value length, either in bytes or characters. */
1:52625a5:         private final int valueLength;
1:52625a5:         /** The header length in bytes. */
1:52625a5:         private final int headerLength;
1:52625a5: 
1:52625a5:         /**
1:52625a5:          * Creates a new header info object.
1:52625a5:          *
1:52625a5:          * @param headerLength the header length in bytes
1:52625a5:          * @param valueLength the value length (chars or bytes)
1:52625a5:          */
1:52625a5:         HeaderInfo(int headerLength, int valueLength) {
1:52625a5:             this.headerLength = headerLength;
1:52625a5:             this.valueLength = valueLength;
1:52625a5:         }
1:52625a5: 
1:52625a5:         /**
1:52625a5:          * Returns the header length in bytes.
1:52625a5:          *
1:52625a5:          * @return Number of bytes occupied by the header.
1:52625a5:          */
1:52625a5:        int headerLength() {
1:52625a5:            return this.headerLength;
1:52625a5:        }
1:52625a5: 
1:52625a5:        /**
1:52625a5:         * Returns the character length encoded in the header, if any.
1:52625a5:         *
1:52625a5:         * @return A positive integer if a character count was encoded in the
1:52625a5:         *       header, or {@code 0} (zero) if the header contained byte length
1:52625a5:         *       information.
1:52625a5:         */
1:52625a5:        int charLength() {
1:52625a5:            return isCharLength() ? valueLength : 0;
1:52625a5:        }
1:52625a5: 
1:52625a5:        /**
1:52625a5:         * Returns the byte length encoded in the header, if any.
1:52625a5:         *
1:52625a5:         * @return A positive integer if a byte count was encoded in the
1:52625a5:         *       header, or {@code 0} (zero) if the header contained character
1:52625a5:         *       length information.
1:52625a5:         */
1:52625a5:        int byteLength() {
1:52625a5:            return isCharLength() ? 0 : valueLength;
1:52625a5:        }
1:52625a5: 
1:52625a5:        /**
1:52625a5:         * Tells whether the encoded length was in characters or bytes.
1:52625a5:         *
1:52625a5:         * @return {@code true} if the header contained a character count,
1:52625a5:         *       {@code false} if it contained a byte count.
1:52625a5:         */
1:52625a5:        boolean isCharLength() {
1:52625a5:            return (headerLength == 5);
1:52625a5:        }
1:52625a5: 
1:52625a5:        /**
1:52625a5:         * Returns a textual representation.
1:52625a5:         */
1:52625a5:        public String toString() {
1:52625a5:            return ("headerLength=" + headerLength + ", valueLength= " +
1:52625a5:                    valueLength + ", isCharLength=" + isCharLength());
1:52625a5:        }
1:52625a5:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1: 				SanityManager.THROWASSERT("Unexpected exception", se);
commit:10cc70b
/////////////////////////////////////////////////////////////////////////
0:                     (int) vcl, 0, TypeId.CLOB_NAME), (int) vcl);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:961ecca
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // The following check was put in to fix DERBY-4544. We seem to get
1:         // confused if we have to re-use non-resetable streams.
1:         //
1:         if ( !(stream instanceof Resetable) ) { return super.getLength(); }
1:         
commit:a2a0ff2
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException     Thrown on error
1:      */
1:     public Object   getObject() throws StandardException
1:     {
1:         if ( _clobValue != null ) { return _clobValue; }
1:         else
1:         {
1:             String stringValue = getString();
1: 
1:             if ( stringValue == null ) { return null; }
1:             else { return new HarmonySerialClob( stringValue.toCharArray() ); }
1:         }
1:     }
1: 
1:     /**
commit:638f1b4
/////////////////////////////////////////////////////////////////////////
1: 	public SQLClob(Clob val)
1: 	{
1: 		super(val);
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:85de1e4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * The maximum number of bytes used by the stream header.
1:      * <p>
1:      * Use the length specified by the ten five header generator.
1:      */
1:     private static final int MAX_STREAM_HEADER_LENGTH =
1:             TEN_FIVE_CLOB_HEADER_GENERATOR.getMaxHeaderLength();
1: 
1:     /**
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:             throw StandardException.newException(
1:                     SQLState.LANG_STREAM_INVALID_ACCESS, getTypeName());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells if this CLOB value is, or will be, represented by a stream.
1:      *
1:      * @return {@code true} if the value is represented by a stream,
1:      *      {@code false} otherwise.
1:      */
1:     public boolean hasStream() {
1:         return stream != null;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (hasStream()) {
commit:f552f7a
/////////////////////////////////////////////////////////////////////////
1:      *      {@code null} is returned instead of a descriptor.
commit:d92fa8c
/////////////////////////////////////////////////////////////////////////
1:      * <ul> <li>{@code setStreamHeaderFormat} has been invoked before the header
/////////////////////////////////////////////////////////////////////////
1:     public void setStreamHeaderFormat(Boolean inSoftUpgradeMode) {
commit:04acfa5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.CloneableStream;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a clone of this CLOB value.
1:      * <p>
1:      * Unlike the other binary types, CLOBs can be very large. We try to clone
1:      * the underlying stream when possible to avoid having to materialize the
1:      * value into memory.
1:      *
1:      * @param forceMaterialization any streams representing the data value will
1:      *      be materialized if {@code true}, the data value will be kept as a
1:      *      stream if possible if {@code false}
1:      * @return A clone of this CLOB value.
1:      * @see DataValueDescriptor#cloneValue
1:      */
1:     public DataValueDescriptor cloneValue(boolean forceMaterialization) {
1:         // TODO: Add optimization for materializing "smallish" streams. This
1:         //       may be more effective because the data doesn't have to be
1:         //       decoded multiple times.
1:         final SQLClob clone = new SQLClob();
1:         // Copy the soft upgrade mode state.
1:         clone.inSoftUpgradeMode = inSoftUpgradeMode;
1:         
1:         // Shortcut cases where the value is NULL.
1:         if (isNull()) {
1:         }
1: 
1:         if (!forceMaterialization) {
1:             if (stream != null && stream instanceof CloneableStream) {
1:                 int length = UNKNOWN_LOGICAL_LENGTH;
1:                 if (csd != null && csd.getCharLength() > 0) {
1:                     length = (int)csd.getCharLength();
1:                 }
1:                 clone.setValue(((CloneableStream)stream).cloneStream(), length);
1:             } else if (_clobValue != null) {
1:                 // Assumes the Clob object can be shared between value holders.
1:                 clone.setValue(_clobValue);
1:             }
1:             // At this point we may still not have cloned the value because we
1:             // have a stream that isn't cloneable.
1:             // TODO: Add functionality to materialize to temporary disk storage
1:             //       to avoid OOME for large CLOBs.
1:         }
1: 
1:         // See if we are forced to materialize the value, either because
1:         // requested by the user or because we don't know how to clone it.
1:         if (clone.isNull() || forceMaterialization) {
1:             try {
1:                 clone.setValue(getString());
1:             } catch (StandardException se) {
1:                 if (SanityManager.DEBUG) {
0:                     SanityManager.THROWASSERT("Unexpected exception", se);
1:                 }
1:                 return null;
1:             }
1:         }
1:         return clone;
1:     }
commit:854dd10
/////////////////////////////////////////////////////////////////////////
0: 	/** @see DataValueDescriptor#cloneValue */
0: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
commit:7f0d066
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FormatIdInputStream;
/////////////////////////////////////////////////////////////////////////
1: import java.io.PushbackInputStream;
/////////////////////////////////////////////////////////////////////////
1:                 // We read too much data. To "unread" the bytes, the following
1:                 // mechanisms will be attempted:
1:                 //  1) See if we set a mark on the stream, if so reset it.
1:                 //  2) If we have a FormatIdInputStream, use a
1:                 //     PushBackInputStream and use it as the source.
1:                 //  3) Try using the Resetable interface.
1:                 // To avoid silent data truncation / data corruption, we fail
1:                 // in step three if the stream isn't resetable.
1:                     // 1) Reset the stream to the previously set mark.
1:                 } else if (in instanceof FormatIdInputStream) {
1:                     // 2) Add a push back stream on top of the underlying
1:                     // source, and unread the surplus bytes we read. Set the
1:                     // push back stream to be the source of the data input obj.
1:                     final int surplus = read - hdrInfo.headerLength();
1:                     FormatIdInputStream formatIn = (FormatIdInputStream)in;
1:                     PushbackInputStream pushbackIn = new PushbackInputStream(
1:                             formatIn.getInputStream(), surplus);
1:                     pushbackIn.unread(header, hdrInfo.headerLength(), surplus);
1:                     formatIn.setInput(pushbackIn);
1:                 } else {
1:                     // 3) Assume we have a store stream.
commit:8f75194
/////////////////////////////////////////////////////////////////////////
0:             SQLClob clone = new SQLClob(getString());
1:             // Copy the soft upgrade mode state.
0:             clone.inSoftUpgradeMode = inSoftUpgradeMode;
1:             return clone;
/////////////////////////////////////////////////////////////////////////
1:         SQLClob newClob = new SQLClob();
0:         // Copy the soft upgrade mode state.
1:         newClob.inSoftUpgradeMode = inSoftUpgradeMode;
1:         return newClob;
commit:0f92bc7
/////////////////////////////////////////////////////////////////////////
1:                 rewindStream(stream, csd.getDataOffset());
1:             rewindStream(stream, 0);
/////////////////////////////////////////////////////////////////////////
1:                     rewindStream(stream, read);
/////////////////////////////////////////////////////////////////////////
1:             rewindStream((InputStream)in, hdrLen);
1:             final InputStream srcIn = (InputStream)in;
1:             final boolean markSet = srcIn.markSupported();
1:                 srcIn.mark(MAX_STREAM_HEADER_LENGTH);
/////////////////////////////////////////////////////////////////////////
1:                     srcIn.reset();
1:                     InputStreamUtil.skipFully(srcIn, hdrInfo.headerLength());
0:                 } else if (in instanceof Resetable) {
1:                     rewindStream(srcIn, hdrInfo.headerLength());
/////////////////////////////////////////////////////////////////////////
1:      * @param in input stream to rewind
1:      * @param offset number of bytes to skip
1:     private void rewindStream(InputStream in, long offset)
1:             ((Resetable)in).resetStream();
1:             InputStreamUtil.skipFully(in, offset);
commit:5b9a6d9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 // Expect at least two header bytes.
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.ASSERT(read > 1,
1:                             "Too few header bytes: " + read);
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 // Check here to see if the root cause is a container closed
1:                 // exception. If so, this most likely means that the Clob was
1:                 // accessed after a commit or rollback on the connection.
1:                 Throwable rootCause = ioe;
1:                 while (rootCause.getCause() != null) {
1:                     rootCause = rootCause.getCause();
1:                 }
1:                 if (rootCause instanceof StandardException) {
1:                     StandardException se = (StandardException)rootCause;
1:                     if (se.getMessageId().equals(
1:                             SQLState.DATA_CONTAINER_CLOSED)) {
1:                         throw StandardException.newException(
1:                                 SQLState.BLOB_ACCESSED_AFTER_COMMIT, ioe);
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             // For small values, just materialize the value.
1:             // NOTE: Using streams for the empty string ("") isn't supported
1:             // down this code path when in soft upgrade mode, because the code
1:             // reading the header bytes ends up reading zero bytes (i.e., it
1:             // doesn't get the header / EOF marker).
1:             if (vcl < 32*1024) {
1:                 setValue(vc.getSubString(1, (int)vcl));
1:             } else {
1:                 ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(
1:                         vc.getCharacterStream(), (int) vcl, 0, TypeId.CLOB_NAME,
1:                         getStreamHeaderGenerator());
1:                 setValue(utfIn, (int) vcl);
1:             }
/////////////////////////////////////////////////////////////////////////
0:             final boolean markSet = stream.markSupported();
1:             if (markSet) {
0:                 stream.mark(MAX_STREAM_HEADER_LENGTH);
1:             }
1:             // Expect at least two header bytes.
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(read > 1, "Too few header bytes: " + read);
1:             }
0:                 // First see if we set a mark on the stream and can reset it.
0:                 // If not, try using the Resetable interface.
1:                 if (markSet) {
0:                     // Stream is not a store Resetable one, use mark/reset
0:                     // functionality instead.
0:                     stream.reset();
0:                     InputStreamUtil.skipFully(stream, hdrInfo.headerLength());
0:                 } else if (stream instanceof Resetable) {
0:                     // We have a store stream.
0:                     rewindStream(hdrInfo.headerLength());
1:                 }
1:         // Subtract the header length from the byte length if there is a byte
1:         // encoded in the header, otherwise the decode routine will try to read
1:         // too many bytes.
1:         int byteLength = 0; // zero is interpreted as unknown / unset
1:         if (hdrInfo.byteLength() != 0) {
1:             byteLength = hdrInfo.byteLength() - hdrInfo.headerLength();
1:         }
1:         super.readExternal(in, byteLength, hdrInfo.charLength());
/////////////////////////////////////////////////////////////////////////
1:         // Expect at least two header bytes.
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(read > 1, "Too few header bytes: " + read);
1:         }
commit:6fe26f8
/////////////////////////////////////////////////////////////////////////
1:                     read = hdrInfo.headerLength();
0:                     rewindStream(read);
commit:52625a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.util.UTF8Util;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
/////////////////////////////////////////////////////////////////////////
0:     /** The maximum number of bytes used by the stream header. */
0:     private static final int MAX_STREAM_HEADER_LENGTH = 5;
1: 
1:     /** The header generator used for 10.4 (or older) databases. */
1:     private static final StreamHeaderGenerator TEN_FOUR_CLOB_HEADER_GENERATOR =
1:             new ClobStreamHeaderGenerator(true);
/////////////////////////////////////////////////////////////////////////
1:      * <em>Note</em>: Always check if {@code stream} is non-null before using
1:      * the information stored in the descriptor internally.
1:     /** Tells if the database is being accessed in soft upgrade mode. */
1:     private Boolean inSoftUpgradeMode = null;
1: 
/////////////////////////////////////////////////////////////////////////
0:         // TODO: Should this be rewritten to clone the stream instead of
0:         //       materializing the value if possible?
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the character length of this Clob.
1:      * <p>
1:      * If the value is stored as a stream, the stream header will be read. If
1:      * the stream header doesn't contain the stream length, the whole stream
1:      * will be decoded to determine the length.
1:      *
1:      * @return The character length of this Clob.
1:      * @throws StandardException if obtaining the length fails
1:      */
1:     public int getLength() throws StandardException {
1:         if (stream == null) {
1:             return super.getLength();
1:         }
1:         // The Clob is represented as a stream.
1:         // Make sure we have a stream descriptor.
1:         boolean repositionStream = (csd != null);
1:         if (csd == null) {
1:             getStreamWithDescriptor();
1:             // We know the stream is at the first char position here.
1:         }
1:         if (csd.getCharLength() != 0) {
1:             return (int)csd.getCharLength();
1:         }
1:         // We now know that the Clob is represented as a stream, but not if the
1:         // length is unknown or actually zero. Check.
1:         if (SanityManager.DEBUG) {
1:             // The stream isn't expecetd to be position aware here.
1:             SanityManager.ASSERT(!csd.isPositionAware());
1:         }
1:         long charLength = 0;
1:         try {
1:             if (repositionStream) {
0:                 rewindStream(csd.getDataOffset());
1:             }
1:             charLength = UTF8Util.skipUntilEOF(stream);
1:             // We just drained the whole stream. Reset it.
0:             rewindStream(0);
1:         } catch (IOException ioe) {
1:             throwStreamingIOException(ioe);
1:         }
1:         // Update the descriptor in two ways;
1:         //   (1) Set the char length, whether it is zero or not.
1:         //   (2) Set the current byte pos to zero.
1:         csd = new CharacterStreamDescriptor.Builder().copyState(csd).
1:                 charLength(charLength).curBytePos(0).
1:                 curCharPos(CharacterStreamDescriptor.BEFORE_FIRST).build();
1:         return (int)charLength;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * When this method returns, the stream is positioned on the first
1:      * character position, such that the next read will return the first
1:      * character in the stream.
/////////////////////////////////////////////////////////////////////////
1:                 // Assume new header format, adjust later if necessary.
1:                 byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:                 HeaderInfo hdrInfo = investigateHeader(header, read);
1:                 if (read > hdrInfo.headerLength()) {
1:                     // We have read too much. Reset the stream.
1:                     ((Resetable)stream).resetStream();
0:                     read = 0;
1:                     curCharPos(read == 0 ?
1:                         CharacterStreamDescriptor.BEFORE_FIRST : 1).
1:                     curBytePos(read).
1:                     dataOffset(hdrInfo.headerLength()).
1:                     byteLength(hdrInfo.byteLength()).
1:                     charLength(hdrInfo.charLength()).build();
/////////////////////////////////////////////////////////////////////////
1:     public final void restoreToNull() {
1:         this.csd = null;
1:         super.restoreToNull();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Writes the CLOB data value to the given destination stream using the
1:      * modified UTF-8 format.
1:      *
1:      * @param out destination stream
1:      * @throws IOException if writing to the destination stream fails
1:      */
1:     public void writeExternal(ObjectOutput out)
1:             throws IOException {
1:         super.writeClobUTF(out);
1:     }
1: 
1:     /**
1:      * Returns a stream header generator for a Clob.
1:      * <p>
1:      * <em>NOTE</em>: To guarantee a successful generation, one of the following
1:      * two conditions must be met at header or EOF generation time:
0:      * <ul> <li>{@code setSoftUpgradeMode} has been invoked before the header
1:      *          generator was obtained.</li>
1:      *      <li>There is context at generation time, such that the mode can be
1:      *          determined by obtaining the database context and by consulting
1:      *          the data dictionary.</li>
1:      * </ul>
1:      *
1:      * @return A stream header generator.
1:      */
1:     public StreamHeaderGenerator getStreamHeaderGenerator() {
1:         if (inSoftUpgradeMode == null) {
1:             // We don't know which mode we are running in, return a generator
1:             // the will check this when asked to generate the header.
1:             return new ClobStreamHeaderGenerator(this);
1:         } else {
1:             if (inSoftUpgradeMode == Boolean.TRUE) {
1:                 return TEN_FOUR_CLOB_HEADER_GENERATOR;
1:             } else {
1:                 return TEN_FIVE_CLOB_HEADER_GENERATOR;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Tells whether the database is being accessed in soft upgrade mode or not.
1:      *
1:      * @param inSoftUpgradeMode {@code TRUE} if the database is accessed in
1:      *      soft upgrade mode, {@code FALSE} is not, or {@code null} if unknown
1:      */
0:     public void setSoftUpgradeMode(Boolean inSoftUpgradeMode) {
1:         this.inSoftUpgradeMode = inSoftUpgradeMode;
1:     }
1: 
1:     /**
1:      * Investigates the header and returns length information.
1:      *
1:      * @param hdr the raw header bytes
1:      * @param bytesRead number of bytes written into the raw header bytes array
1:      * @return The information obtained from the header.
1:      * @throws IOException if the header format is invalid, or the stream
1:      *      seems to have been corrupted
1:      */
1:     private HeaderInfo investigateHeader(byte[] hdr, int bytesRead)
1:             throws IOException {
1:         int dataOffset = MAX_STREAM_HEADER_LENGTH;
1:         int utfLen = -1;
1:         int strLen = -1;
1: 
1:         // Peek at the magic byte.
1:         if (bytesRead < dataOffset || (hdr[2] & 0xF0) != 0xF0) {
1:             // We either have a very short value with the old header
1:             // format, or the stream is corrupted.
1:             // Assume the former and check later (see further down).
1:             dataOffset = 2;
1:         }
1: 
1:         // Do we have a pre 10.5 header?
1:         if (dataOffset == 2) {
1:             // Note that we add the two bytes holding the header to the total
1:             // length only if we know how long the user data is.
1:             utfLen = ((hdr[0] & 0xFF) << 8) | ((hdr[1] & 0xFF));
1:             // Sanity check for small streams:
1:             // The header length pluss the encoded length must be equal to the
1:             // number of bytes read.
1:             if (bytesRead < MAX_STREAM_HEADER_LENGTH) {
1:                 if (dataOffset + utfLen != bytesRead) {
1:                     throw new IOException("Corrupted stream; headerLength=" +
1:                             dataOffset + ", utfLen=" + utfLen + ", bytesRead=" +
1:                             bytesRead);
1:                 }
1:             }
1:             if (utfLen > 0) {
1:                 utfLen += dataOffset;
1:             }
1:         } else if (dataOffset == 5) {
1:             // We are dealing with the 10.5 stream header format.
1:             int hdrFormat = hdr[2] & 0x0F;
1:             switch (hdrFormat) {
1:                 case 0: // 0xF0
1:                     strLen = (
1:                                 ((hdr[0] & 0xFF) << 24) |
1:                                 ((hdr[1] & 0xFF) << 16) |
1:                                 // Ignore the third byte (index 2).
1:                                 ((hdr[3] & 0xFF) <<  8) |
1:                                 ((hdr[4] & 0xFF) <<  0)
1:                              );
1:                     break;
1:                 default:
1:                     // We don't know how to handle this header format.
1:                     throw new IOException("Invalid header format " +
1:                             "identifier: " + hdrFormat + "(magic byte is 0x" +
1:                             Integer.toHexString(hdr[2] & 0xFF) + ")");
1:             }
1:         }
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(utfLen > -1 || strLen > -1);
1:         }
1:         return new HeaderInfo(dataOffset, dataOffset == 5 ? strLen : utfLen);
1:     }
1: 
1:     /**
1:      * Reads and materializes the CLOB value from the stream.
1:      *
1:      * @param in source stream
1:      * @throws java.io.UTFDataFormatException if an encoding error is detected
1:      * @throws IOException if reading from the stream fails, or the content of
1:      *      the stream header is invalid
1:      */
1:     public void readExternal(ObjectInput in)
1:             throws IOException {
1:         HeaderInfo hdrInfo;
1:         if (csd != null) {
1:             int hdrLen = (int)csd.getDataOffset();
1:             int valueLength = (hdrLen == 5) ? (int)csd.getCharLength()
1:                                             : (int)csd.getByteLength();
1:             hdrInfo = new HeaderInfo(hdrLen, valueLength);
1:             // Make sure the stream is correctly positioned.
0:             rewindStream(hdrLen);
1:         } else {
1:             byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:             int read = in.read(header);
1:             hdrInfo = investigateHeader(header, read);
1:             if (read > hdrInfo.headerLength()) {
0:                 // We read too much data, reset and position on the first byte
0:                 // of the user data.
0:                 rewindStream(hdrInfo.headerLength());
1:             }
1:         }
1:         // The data will be materialized in memory, in a char array.
0:         super.readExternal(in, hdrInfo.byteLength(), hdrInfo.charLength());
1:     }
1: 
1:     /**
1:      * Reads and materializes the CLOB value from the stream.
1:      *
1:      * @param in source stream
1:      * @throws java.io.UTFDataFormatException if an encoding error is detected
1:      * @throws IOException if reading from the stream fails, or the content of
1:      *      the stream header is invalid
1:      */
1:     public void readExternalFromArray(ArrayInputStream in)
1:             throws IOException {
1:         // It is expected that the position of the array input stream has been
1:         // set to the correct position before this method is invoked.
1:         int prevPos = in.getPosition();
1:         byte[] header = new byte[MAX_STREAM_HEADER_LENGTH];
1:         int read = in.read(header);
1:         HeaderInfo hdrInfo = investigateHeader(header, read);
1:         if (read > hdrInfo.headerLength()) {
1:             // Reset stream. This path will only be taken for Clobs stored
1:             // with the pre 10.5 stream header format.
1:             // Note that we set the position to before the header again, since
1:             // we know the header will be read again.
1:             in.setPosition(prevPos);
1:             super.readExternalFromArray(in);
1:         } else {
1:             // We read only header bytes, next byte is user data.
1:             super.readExternalClobFromArray(in, hdrInfo.charLength());
1:         }
1:     }
1: 
1:     /**
1:      * Rewinds the stream to the beginning and then skips the specified number
1:      * of bytes.
1:      *
0:      * @param pos number of bytes to skip
1:      * @throws IOException if resetting or reading from the stream fails
1:      */
0:     private void rewindStream(long pos)
1:             throws IOException {
1:         try {
0:             ((Resetable)stream).resetStream();
0:             InputStreamUtil.skipFully(stream, pos);
1:         } catch (StandardException se) {
1:             IOException ioe = new IOException(se.getMessage());
1:             ioe.initCause(se);
1:             throw ioe;
1:         }
1:     }
1: 
1:     /**
1:      * Holder class for header information gathered from the raw byte header in 
1:      * the stream.
1:      */
1:     //@Immutable
1:     private static class HeaderInfo {
1: 
1:         /** The value length, either in bytes or characters. */
1:         private final int valueLength;
1:         /** The header length in bytes. */
1:         private final int headerLength;
1: 
1:         /**
1:          * Creates a new header info object.
1:          *
1:          * @param headerLength the header length in bytes
1:          * @param valueLength the value length (chars or bytes)
1:          */
1:         HeaderInfo(int headerLength, int valueLength) {
1:             this.headerLength = headerLength;
1:             this.valueLength = valueLength;
1:         }
1: 
1:         /**
1:          * Returns the header length in bytes.
1:          *
1:          * @return Number of bytes occupied by the header.
1:          */
1:        int headerLength() {
1:            return this.headerLength;
1:        }
1: 
1:        /**
1:         * Returns the character length encoded in the header, if any.
1:         *
1:         * @return A positive integer if a character count was encoded in the
1:         *       header, or {@code 0} (zero) if the header contained byte length
1:         *       information.
1:         */
1:        int charLength() {
1:            return isCharLength() ? valueLength : 0;
1:        }
1: 
1:        /**
1:         * Returns the byte length encoded in the header, if any.
1:         *
1:         * @return A positive integer if a byte count was encoded in the
1:         *       header, or {@code 0} (zero) if the header contained character
1:         *       length information.
1:         */
1:        int byteLength() {
1:            return isCharLength() ? 0 : valueLength;
1:        }
1: 
1:        /**
1:         * Tells whether the encoded length was in characters or bytes.
1:         *
1:         * @return {@code true} if the header contained a character count,
1:         *       {@code false} if it contained a byte count.
1:         */
1:        boolean isCharLength() {
1:            return (headerLength == 5);
1:        }
1: 
1:        /**
1:         * Returns a textual representation.
1:         */
1:        public String toString() {
1:            return ("headerLength=" + headerLength + ", valueLength= " +
1:                    valueLength + ", isCharLength=" + isCharLength());
1:        }
1:     }
commit:4bd0300
/////////////////////////////////////////////////////////////////////////
1:     /** The header generator used for 10.5 databases. */
1:     private static final StreamHeaderGenerator TEN_FIVE_CLOB_HEADER_GENERATOR =
1:             new ClobStreamHeaderGenerator(false);
1: 
commit:6f4c92a
/////////////////////////////////////////////////////////////////////////
0:                     getStreamHeaderGenerator());
commit:2f2c745
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.InputStreamUtil;
/////////////////////////////////////////////////////////////////////////
1:                     // Make sure the stream is in sync with the descriptor.
1:                     InputStreamUtil.skipFully(stream, csd.getCurBytePos());
1:                 } catch (IOException ioe) {
1:                     throwStreamingIOException(ioe);
1:                 }
commit:cf0fdc4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The descriptor for the stream. If there is no stream this should be
1:      * {@code null}, which is also true if the descriptor hasen't been
1:      * constructed yet.
1:      */
1:     private CharacterStreamDescriptor csd;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns a descriptor for the input stream for this CLOB value.
1:      * <p>
1:      * The descriptor contains information about header data, current positions,
1:      * length, whether the stream should be buffered or not, and if the stream
1:      * is capable of repositioning itself.
1:      *
1:      * @return A descriptor for the stream, which includes a reference to the
1:      *      stream itself. If the value cannot be represented as a stream,
0:      *      {@code null} is returned instead of a decsriptor.
1:      * @throws StandardException if obtaining the descriptor fails
1:      */
1:     public CharacterStreamDescriptor getStreamWithDescriptor()
1:             throws StandardException {
1:         if (stream == null) {
1:             // Lazily reset the descriptor here, to avoid further changes in
1:             // {@code SQLChar}.
1:             csd = null;
0:             return null;
1:         }
1:         // NOTE: Getting down here several times is potentially dangerous.
1:         // When the stream is published, we can't assume we know the position
1:         // any more. The best we can do, which may hurt performance to some
1:         // degree in some non-recommended use-cases, is to reset the stream if
1:         // possible.
1:         if (csd != null) {
1:             if (stream instanceof Resetable) {
1:                 try {
0:                     ((Resetable)stream).resetStream();
1:                     } catch (IOException ioe) {
1:                         throwStreamingIOException(ioe);
1:                     }
1:             } else {
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT("Unable to reset stream when " +
1:                             "fetched the second time: " + stream.getClass());
1:                 }
1:             }
1:         }
1: 
1:         if (csd == null) {
1:             // First time, read the header format of the stream.
0:             // NOTE: For now, just read the old header format.
1:             try {
0:                 final int dataOffset = 2;
0:                 byte[] header = new byte[dataOffset];
1:                 int read = stream.read(header);
0:                 if (read != dataOffset) {
0:                     String hdr = "[";
0:                     for (int i=0; i < read; i++) {
0:                         hdr += Integer.toHexString(header[i] & 0xff);
1:                     }
0:                     throw new IOException("Invalid stream header length " +
0:                             read + ", got " + hdr + "]");
1:                 }
1: 
0:                 // Note that we add the two bytes holding the header *ONLY* if
0:                 // we know how long the user data is.
0:                 long utflen = ((header[0] & 0xff) << 8) | ((header[1] & 0xff));
0:                 if (utflen > 0) {
0:                     utflen += dataOffset;
1:                 }
1: 
1:                 csd = new CharacterStreamDescriptor.Builder().stream(stream).
1:                     bufferable(false).positionAware(false).
0:                     curCharPos(1).curBytePos(dataOffset).
0:                     dataOffset(dataOffset).byteLength(utflen).build();
1:             } catch (IOException ioe) {
1:                 throwStreamingIOException(ioe);
1:             }
1:         }
1:         return this.csd;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets a new stream for this CLOB.
1:      *
1:      * @param stream the new stream
1:      */
1:     public final void setStream(InputStream stream) {
1:         super.setStream(stream);
1:         // Discard the old stream descriptor.
1:         this.csd = null;
1:     }
1: 
commit:7af6726
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Static stream header holder with the header used for a 10.5
0:      * stream with unknown char length. This header will be used with 10.5, and
0:      * possibly later databases. The expected EOF marker is '0xE0 0x00 0x00'.
1:      */
0:     protected static final StreamHeaderHolder UNKNOWN_LEN_10_5_HEADER_HOLDER =
0:             new StreamHeaderHolder(
0:                     new byte[] {0x00, 0x00, (byte)0xF0, 0x00, 0x00},
0:                     new byte[] {24, 16, -1, 8, 0}, true, true);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:             ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(
0:                     vc.getCharacterStream(), (int) vcl, 0, TypeId.CLOB_NAME,
0:                     generateStreamHeader(vcl));
0:             setValue(utfIn, (int) vcl);
commit:4b66efc
/////////////////////////////////////////////////////////////////////////
1:             return (getTypeName() + "(" + getStream().toString() + ")");
1:         return (getTypeName() + "(" + getLength() + ")");
commit:f73afdc
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets a trace representation of the CLOB for debugging.
1:      *
1:      * @return a trace representation of the CLOB.
1:      */
1:     public final String getTraceString() throws StandardException {
1:         // Check if the value is SQL NULL.
1:         if (isNull()) {
1:             return "NULL";
1:         }
1: 
1:         // Check if we have a stream.
0:         if (getStream() != null) {
0:             return ("CLOB(" + getStream().toString() + ")");
1:         }
1: 
0:         return ("CLOB(" + getLength() + ")");
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:726b66f
/////////////////////////////////////////////////////////////////////////
1: 		     CollatorSQLClob s = new CollatorSQLClob(collatorForComparison);
commit:403684d
/////////////////////////////////////////////////////////////////////////
1:  * SQLClob represents a CLOB value with UCS_BASIC collation.
1:  * CLOB supports LIKE operator only for collation.
commit:f38528a
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Set the value from an non-null Java.sql.Clob object.
1:      */
1:     final void setObject(Object theValue)
1:         throws StandardException
1:     {
1:         Clob vc = (Clob) theValue;
1:         
1:         try {
1:             long vcl = vc.length();
1:             if (vcl < 0L || vcl > Integer.MAX_VALUE)
1:                 throw this.outOfRange();
1:             
0:             setValue(new ReaderToUTF8Stream(vc.getCharacterStream(),
0:                     (int) vcl, 0), (int) vcl);
1:             
1:         } catch (SQLException e) {
1:             throw dataTypeConversion("DAN-438-tmp");
1:        }
1:     }
commit:806114c
/////////////////////////////////////////////////////////////////////////
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
1: 	public int typeToBigDecimal() throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.math.BigDecimal");
1: 	}
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0: 	public void setBigDecimal(Number bigDecimal) throws StandardException
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLClob
1: 
0:    Copyright 2003, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.math.BigDecimal;
1: 
1: import java.util.Calendar;
1: 
1: 
1: /**
0:  * SQLClob uses SQLVarchar by inheritance.
0:  * It satisfies the DataValueDescriptor interfaces (i.e., OrderableDataType). It implements a String
0:  * holder, e.g. for storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction.
0:  * <p>
0:  * Because OrderableDataType is a subclass of DataType,
0:  * SQLLongvarchar can play a role in either a DataType/ValueRow
0:  * or a OrderableDataType/KeyRow, interchangeably.
1:  */
1: public class SQLClob
1: 	extends SQLVarchar
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
1: 	/*
1: 	 * DataValueDescriptor interface.
1: 	 *
1: 	 * These are actually all implemented in the super-class, but we need
1: 	 * to duplicate some of them here so they can be called by byte-code
1: 	 * generation, which needs to know the class the method appears in.
1: 	 */
1: 
1: 	public String getTypeName()
1: 	{
1: 		return TypeId.CLOB_NAME;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
0: 		try
1: 		{
0: 			return new SQLClob(getString());
1: 		}
0: 		catch (StandardException se)
1: 		{
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
0: 			return null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 *
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
0: 		return new SQLClob();
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_CLOB_ID;
1: 	}
1: 
1: 	/*
1: 	 * constructors
1: 	 */
1: 
1: 	public SQLClob()
1: 	{
1: 	}
1: 
1: 	public SQLClob(String val)
1: 	{
1: 		super(val);
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/* @see DataValueDescriptor#typePrecedence */
1: 	public int typePrecedence()
1: 	{
1: 		return TypeId.CLOB_PRECEDENCE;
1: 	}
1: 
1: 	/*
1: 	** disable conversions to/from most types for CLOB.
1: 	** TEMP - real fix is to re-work class hierachy so
1: 	** that CLOB is towards the root, not at the leaf.
1: 	*/
1: 
0: 	public Object	getObject() throws StandardException
1: 	{
0: 		throw dataTypeConversion("java.lang.Object");
1: 	}
1: 
1: 	public boolean	getBoolean() throws StandardException
1: 	{
1: 		throw dataTypeConversion("boolean");
1: 	}
1: 
1: 	public byte	getByte() throws StandardException
1: 	{
1: 		throw dataTypeConversion("byte");
1: 	}
1: 
1: 	public short	getShort() throws StandardException
1: 	{
1: 		throw dataTypeConversion("short");
1: 	}
1: 
1: 	public int	getInt() throws StandardException
1: 	{
1: 		throw dataTypeConversion("int");
1: 	}
1: 
1: 	public long	getLong() throws StandardException
1: 	{
1: 		throw dataTypeConversion("long");
1: 	}
1: 
1: 	public float	getFloat() throws StandardException
1: 	{
1: 		throw dataTypeConversion("float");
1: 	}
1: 
1: 	public double	getDouble() throws StandardException
1: 	{
1: 		throw dataTypeConversion("double");
1: 	}
0: 	public BigDecimal	getBigDecimal() throws StandardException
1: 	{
0: 		throw dataTypeConversion("java.math.BigDecimal");
1: 	}
1: 	public byte[]	getBytes() throws StandardException
1: 	{
1: 		throw dataTypeConversion("byte[]");
1: 	}
1: 
1: 	public Date	getDate(java.util.Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Date");
1: 	}
1: 
1: 	public Time	getTime(java.util.Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Time");
1: 	}
1: 
1: 	public Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException
1: 	{
1: 		throw dataTypeConversion("java.sql.Timestamp");
1: 	}
1: 
1: 	public void setValue(Time theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Time");
1: 	}
1: 	
1: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Timestamp");
1: 	}
1: 	
1: 	public void setValue(Date theValue, Calendar cal) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.sql.Date");
1: 	}
1: 	
0: 	public void setValue(BigDecimal theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("java.math.BigDecimal");
1: 	}
1: 
1: 	public void setValue(int theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("int");
1: 	}
1: 
1: 	public void setValue(double theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("double");
1: 	}
1: 
1: 	public void setValue(float theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("float");
1: 	}
1:  
1: 	public void setValue(short theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("short");
1: 	}
1: 
1: 	public void setValue(long theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("long");
1: 	}
1: 
1: 
1: 	public void setValue(byte theValue) throws StandardException
1: 	{
0: 		new Throwable("FRED").printStackTrace(System.out);
1: 		throwLangSetMismatch("byte");
1: 	}
1: 
1: 	public void setValue(boolean theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("boolean");
1: 	}
1: 
1: 	public void setValue(byte[] theValue) throws StandardException
1: 	{
1: 		throwLangSetMismatch("byte[]");
1: 	}
1: 
0: 	public void setValue(Object theValue)
1: 		throws StandardException
1: 	{
0: 		if (theValue == null)
0: 			setToNull();
0: 		else
0: 			throwLangSetMismatch(theValue);
1: 	}
1: 
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0cab10f
/////////////////////////////////////////////////////////////////////////
1: import java.text.RuleBasedCollator;
/////////////////////////////////////////////////////////////////////////
1: 	/** @see StringDataValue#getValue(RuleBasedCollator) */
1: 	public StringDataValue getValue(RuleBasedCollator collatorForComparison)
0: 	{
1: 		if (collatorForComparison == null)
1: 		{//null collatorForComparison means use UCS_BASIC for collation
1: 		    return this;			
1: 		} else {
1: 			//non-null collatorForComparison means use collator sensitive
1: 			//implementation of SQLClob
0: 		     CollatorSQLClob s = new CollatorSQLClob();
1: 		     s.copyState(this);
0: 		     s.setCollator(collatorForComparison);
1: 		     return s;
0: 		}
0: 	}
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28030d7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:     
0:     
0:     /**
1:      * Normalization method - this method may be called when putting
1:      * a value into a SQLClob, for example, when inserting into a SQLClob
1:      * column.  See NormalizeResultSet in execution.
1:      * Per the SQL standard ,if the clob column is not big enough to 
1:      * hold the value being inserted,truncation error will result
1:      * if there are trailing non-blanks. Truncation of trailing blanks
1:      * is allowed.
1:      * @param desiredType   The type to normalize the source column to
1:      * @param sourceValue   The value to normalize
1:      *
1:      *
1:      * @exception StandardException             Thrown for null into
1:      *                                          non-nullable column, and for
1:      *                                          truncation error
0:      */
0: 
1:     public void normalize(
1:                 DataTypeDescriptor desiredType,
1:                 DataValueDescriptor sourceValue)
0:                     throws StandardException
0:     {
1:         // if sourceValue is of type clob, and has a stream,
1:         // dont materialize it here (as the goal of using a stream is to
1:         // not have to materialize whole object in memory in the server), 
1:         // but instead truncation checks will be done when data is streamed in.
1:         // (see ReaderToUTF8Stream) 
1:         // if sourceValue is not a stream, then follow the same
1:         // protocol as varchar type for normalization
1:         if( sourceValue instanceof SQLClob)
0:         {
1:             SQLClob clob = (SQLClob)sourceValue;
1:             if (clob.stream != null)
0:             {
1:                 copyState(clob);
1:                 return;
0:             }
0:         }
0:         
1:         super.normalize(desiredType,sourceValue);
0:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:65ade68
/////////////////////////////////////////////////////////////////////////
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2003, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.math.BigDecimal;
0: 
0: import java.util.Calendar;
0: 
0: 
0: /**
0:  * SQLClob uses SQLVarchar by inheritance.
0:  * It satisfies the DataValueDescriptor interfaces (i.e., OrderableDataType). It implements a String
0:  * holder, e.g. for storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction.
0:  * <p>
0:  * Because OrderableDataType is a subclass of DataType,
0:  * SQLLongvarchar can play a role in either a DataType/ValueRow
0:  * or a OrderableDataType/KeyRow, interchangeably.
0:  */
0: public class SQLClob
0: 	extends SQLVarchar
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2003_2004;
0: 	/*
0: 	 * DataValueDescriptor interface.
0: 	 *
0: 	 * These are actually all implemented in the super-class, but we need
0: 	 * to duplicate some of them here so they can be called by byte-code
0: 	 * generation, which needs to know the class the method appears in.
0: 	 */
0: 
0: 	public String getTypeName()
0: 	{
0: 		return TypeId.CLOB_NAME;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		try
0: 		{
0: 			return new SQLClob(getString());
0: 		}
0: 		catch (StandardException se)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Unexpected exception " + se);
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 *
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLClob();
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_CLOB_ID;
0: 	}
0: 
0: 	/*
0: 	 * constructors
0: 	 */
0: 
0: 	public SQLClob()
0: 	{
0: 	}
0: 
0: 	public SQLClob(String val)
0: 	{
0: 		super(val);
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/* @see DataValueDescriptor#typePrecedence */
0: 	public int typePrecedence()
0: 	{
0: 		return TypeId.CLOB_PRECEDENCE;
0: 	}
0: 
0: 	/*
0: 	** disable conversions to/from most types for CLOB.
0: 	** TEMP - real fix is to re-work class hierachy so
0: 	** that CLOB is towards the root, not at the leaf.
0: 	*/
0: 
0: 	public Object	getObject() throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.lang.Object");
0: 	}
0: 
0: 	public boolean	getBoolean() throws StandardException
0: 	{
0: 		throw dataTypeConversion("boolean");
0: 	}
0: 
0: 	public byte	getByte() throws StandardException
0: 	{
0: 		throw dataTypeConversion("byte");
0: 	}
0: 
0: 	public short	getShort() throws StandardException
0: 	{
0: 		throw dataTypeConversion("short");
0: 	}
0: 
0: 	public int	getInt() throws StandardException
0: 	{
0: 		throw dataTypeConversion("int");
0: 	}
0: 
0: 	public long	getLong() throws StandardException
0: 	{
0: 		throw dataTypeConversion("long");
0: 	}
0: 
0: 	public float	getFloat() throws StandardException
0: 	{
0: 		throw dataTypeConversion("float");
0: 	}
0: 
0: 	public double	getDouble() throws StandardException
0: 	{
0: 		throw dataTypeConversion("double");
0: 	}
0: 	public BigDecimal	getBigDecimal() throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.math.BigDecimal");
0: 	}
0: 	public byte[]	getBytes() throws StandardException
0: 	{
0: 		throw dataTypeConversion("byte[]");
0: 	}
0: 
0: 	public Date	getDate(java.util.Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Date");
0: 	}
0: 
0: 	public Time	getTime(java.util.Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Time");
0: 	}
0: 
0: 	public Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException
0: 	{
0: 		throw dataTypeConversion("java.sql.Timestamp");
0: 	}
0: 
0: 	public void setValue(Time theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Time");
0: 	}
0: 	
0: 	public void setValue(Timestamp theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Timestamp");
0: 	}
0: 	
0: 	public void setValue(Date theValue, Calendar cal) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.sql.Date");
0: 	}
0: 	
0: 	public void setValue(BigDecimal theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("java.math.BigDecimal");
0: 	}
0: 
0: 	public void setValue(int theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("int");
0: 	}
0: 
0: 	public void setValue(double theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("double");
0: 	}
0: 
0: 	public void setValue(float theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("float");
0: 	}
0:  
0: 	public void setValue(short theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("short");
0: 	}
0: 
0: 	public void setValue(long theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("long");
0: 	}
0: 
0: 
0: 	public void setValue(byte theValue) throws StandardException
0: 	{
0: 		new Throwable("FRED").printStackTrace(System.out);
0: 		throwLangSetMismatch("byte");
0: 	}
0: 
0: 	public void setValue(boolean theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("boolean");
0: 	}
0: 
0: 	public void setValue(byte[] theValue) throws StandardException
0: 	{
0: 		throwLangSetMismatch("byte[]");
0: 	}
0: 
0: 	public void setValue(Object theValue)
0: 		throws StandardException
0: 	{
0: 		if (theValue == null)
0: 			setToNull();
0: 		else
0: 			throwLangSetMismatch(theValue);
0: 	}
0: 
0: }
============================================================================