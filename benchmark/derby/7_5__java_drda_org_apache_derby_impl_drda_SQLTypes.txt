1:eac0369: /*
15:eac0369: 
1:d7258ed:    Derby - Class org.apache.derby.impl.drda.SQLTypes
1:d7258ed: 
1:59e5225:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:    contributor license agreements.  See the NOTICE file distributed with
1:59e5225:    this work for additional information regarding copyright ownership.
1:59e5225:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:    (the "License"); you may not use this file except in compliance with
1:59e5225:    the License.  You may obtain a copy of the License at
1:d7258ed: 
1:d7258ed:       http://www.apache.org/licenses/LICENSE-2.0
1:d7258ed: 
1:d7258ed:    Unless required by applicable law or agreed to in writing, software
1:d7258ed:    distributed under the License is distributed on an "AS IS" BASIS,
1:d7258ed:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:d7258ed:    See the License for the specific language governing permissions and
1:d7258ed:    limitations under the License.
1:d7258ed: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.drda;
1:eac0369: 
1:eac0369: import java.sql.SQLException;
1:db4c995: import java.sql.Types;
1:90731d5: import org.apache.derby.iapi.reference.DRDAConstants;
1:eac0369: 
1:7df5ffe: class SQLTypes {
1:eac0369: 
1:eac0369:   // define final statics for the fdoca type codes here!!!
1:eac0369: 
1:eac0369:   // hide the default constructor
1:eac0369:   private SQLTypes() {}
1:eac0369: 
1:eac0369: 
4:eac0369:   /**
1:eac0369:    * Map DB2 SQL Type to JDBC Type
2:eac0369:    * 
1:eac0369:    * @param sqlType SQL Type to convert
1:eac0369:    * @param length storage length of type
1:eac0369:    * @param ccsid ccsid of type
1:eac0369:    *
1:eac0369:    * @return Corresponding JDBC Type 
1:eac0369:    */
1:eac0369: 
1:eac0369:   static protected int mapDB2SqlTypeToJdbcType (int sqlType, long length, int ccsid)
2:eac0369:   {
1:eac0369:     switch (getNonNullableSqlType (sqlType)) { // mask the isNullable bit
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_SMALL:
1:eac0369:       return java.sql.Types.SMALLINT;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_INTEGER:
1:eac0369:       return java.sql.Types.INTEGER;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_BIGINT:
1:eac0369:       return java.sql.Types.BIGINT;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_FLOAT:
1:eac0369:       if (length == 16)                  // can map to either NUMERIC or DECIMAL!!! @sxg
1:eac0369:         return java.sql.Types.DECIMAL;
1:eac0369:       else if (length == 8)              // can map to either DOUBLE or FLOAT!!! @sxg
1:eac0369:         return java.sql.Types.DOUBLE;
1:eac0369:       else if (length == 4)
1:eac0369:         return java.sql.Types.REAL;
1:eac0369:       else
1:eac0369:         return 0;
1:eac0369:         //throw new BugCheckException ("Encountered unexpected float length");
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_DECIMAL:            // can map to either NUMERIC or DECIMAL!!! @sxg
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_ZONED:              // can map to either NUMERIC or DECIMAL!!! @sxg
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_NUMERIC:            // can map to either NUMERIC or DECIMAL!!! @sxg
1:eac0369:       return java.sql.Types.DECIMAL;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_CHAR:    // mixed and single byte
1:eac0369:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:eac0369:         return java.sql.Types.BINARY;
1:eac0369:       else
1:eac0369:         return java.sql.Types.CHAR;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_CSTR:    // SBCS null terminated 
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_GRAPHIC: // fixed character DBCS
1:eac0369:       return java.sql.Types.CHAR;
1:eac0369:     // use ccsid to distinguish between BINARY and CHAR, VARBINARY and VARCHAR, LONG... !!! -j/p/s
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_VARGRAPH:  // variable character DBCS
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_VARCHAR:   // variable character SBCS/Mixed
1:eac0369:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:eac0369:         return java.sql.Types.VARBINARY;
1:eac0369:       else
1:eac0369:         return java.sql.Types.VARCHAR;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_LSTR:      // pascal string SBCS/Mixed
1:eac0369:       return java.sql.Types.VARCHAR;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_LONGRAPH:  // long varchar DBCS
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_LONG:      // long varchar SBCS/Mixed
1:eac0369:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:eac0369:         return java.sql.Types.LONGVARBINARY;
1:eac0369:       else
1:eac0369:         return java.sql.Types.LONGVARCHAR;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_DATE:
1:eac0369:       return java.sql.Types.DATE;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_TIME:
1:eac0369:       return java.sql.Types.TIME;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_TIMESTAMP:
1:eac0369:       return java.sql.Types.TIMESTAMP;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_CLOB:    // large object character SBCS/Mixed
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_DBCLOB:  // large object character DBCS
1:eac0369:       return java.sql.Types.CLOB;
1:90731d5:     case DRDAConstants.DB2_SQLTYPE_BLOB:    // large object bytes
1:4f996a4:         case DRDAConstants.DB2_SQLTYPE_BLOB_LOCATOR:
1:4f996a4:         case DRDAConstants.DB2_SQLTYPE_CLOB_LOCATOR:
1:4f996a4:         case DRDAConstants.DB2_SQLTYPE_DBCLOB_LOCATOR:
1:eac0369:       return java.sql.Types.BLOB;
2:eac0369:     default:
2:eac0369:       //throw new BugCheckException ("Encountered unexpected type code");
1:eac0369:       return 0;
2:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Map jdbc type to the DB2 DRDA SQL Types expected by jcc.
1:4f996a4:      *@param jdbctype  - jdbc Type to convert
1:4f996a4:      *@param nullable - whether the type is nullable
1:4f996a4:      **/
1:4f996a4: 
1:eac0369:     
1:eac0369:  /**  Map JDBC Type to DB2 SqlType
1:eac0369:   * @param jdbctype   JDBC Type from java.sql.Types
1:eac0369:   * @param nullable   true if this is a nullable type
1:4f996a4:      * @param appRequester - state variable for the connection
1:eac0369:   * @param outlen     output parameter with type length
1:eac0369:   *
1:eac0369:   * @return Corresponding DB2 SQL Type (See DRDA Manual FD:OCA Meta 
1:eac0369:   *          Data Summary, page 245)
1:eac0369:   * 
1:eac0369:   * @exception SQLException thrown for unrecognized SQLType
1:eac0369:   */
1:eac0369: 
1:506f4c8:     static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable, AppRequester appRequester,
1:4f996a4:                                                int[] outlen)
1:4f996a4:      throws SQLException
1:eac0369:   {
1:4f996a4:       int nullAddVal =0;
1:eac0369: 
1:4f996a4:       if (nullable) 
1:4f996a4:           nullAddVal =1; 
1:4f996a4:       
1:4f996a4:       // Call FdocaConstants just to get the length
1:4f996a4:       FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,appRequester,outlen);
1:90731d5: 
1:4f996a4:       switch(jdbctype)
1:4f996a4:       {
1:4f996a4:           case Types.BOOLEAN:
1:eff3919:               if ( appRequester.supportsBooleanValues() )
1:eff3919:               {
1:eff3919:                   return DRDAConstants.DB2_SQLTYPE_BOOLEAN + nullAddVal;
1:eff3919:               }
1:eff3919:               else
1:eff3919:               {
1:eff3919:                   return DRDAConstants.DB2_SQLTYPE_SMALL + nullAddVal;
1:eff3919:               }
1:4f996a4:           case java.sql.Types.BIT:
1:4f996a4:           case java.sql.Types.TINYINT:
1:4f996a4:           case java.sql.Types.SMALLINT:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_SMALL + nullAddVal;
1:4f996a4:           case java.sql.Types.INTEGER:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_INTEGER + nullAddVal;
1:4f996a4:           case java.sql.Types.BIGINT:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_BIGINT + nullAddVal;
1:4f996a4:           case java.sql.Types.DOUBLE:
1:4f996a4:           case java.sql.Types.REAL:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_FLOAT + nullAddVal;
1:4f996a4:           case java.sql.Types.DECIMAL:
1:4f996a4:           case java.sql.Types.NUMERIC:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_DECIMAL + nullAddVal;
1:4f996a4:           case java.sql.Types.DATE:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_DATE + nullAddVal;
1:4f996a4:           case java.sql.Types.TIME:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_TIME + nullAddVal;
1:4f996a4:           case java.sql.Types.TIMESTAMP:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_TIMESTAMP + nullAddVal;
1:4f996a4:           case java.sql.Types.CHAR:
1:4f996a4:               return  DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;    // null terminated SBCS/Mixed
1:4f996a4:           case java.sql.Types.BINARY:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;
1:eac0369: 
1:4f996a4:           case java.sql.Types.VARCHAR:
1:4f996a4:           case java.sql.Types.VARBINARY:
1:db9a013:               return  DRDAConstants.DB2_SQLTYPE_VARCHAR + nullAddVal;
1:4f996a4:           case java.sql.Types.LONGVARBINARY:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:4f996a4:           case java.sql.Types.JAVA_OBJECT:
1:506f4c8:               if ( appRequester.supportsUDTs() )
1:506f4c8:               {
1:506f4c8:                   return DRDAConstants.DB2_SQLTYPE_FAKE_UDT + nullAddVal;
1:506f4c8:               }
1:506f4c8:               else
1:506f4c8:               {
1:506f4c8:                   return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:506f4c8:               }
1:4f996a4:           case java.sql.Types.BLOB:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_BLOB + nullAddVal;
1:4f996a4:           case java.sql.Types.CLOB:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_CLOB + nullAddVal;
1:4f996a4:           case java.sql.Types.LONGVARCHAR:
1:4f996a4:               return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:4f996a4:           case java.sql.Types.ARRAY:
1:4f996a4:           case java.sql.Types.DISTINCT:
1:4f996a4:           case java.sql.Types.NULL:
1:4f996a4:           case java.sql.Types.OTHER:
1:4f996a4:           case java.sql.Types.REF:
1:4f996a4:           case java.sql.Types.STRUCT:
1:4f996a4:               throw new SQLException("Jdbc type" + jdbctype + "not Supported yet");
1:4f996a4:             default:
1:4f996a4:                 throw new SQLException ("unrecognized sql type: " + jdbctype);
1:4f996a4:               //throw new BugCheckException ("Encountered unexpected type code");
1:eac0369: 
1:4f996a4:       }
1:eac0369:   }
1:eac0369: 
1:4f996a4:     /**
1:4f996a4:      * Translate DB2 SQL Type to the non-nullable type.
1:4f996a4:      * @param sqlType DB2 SQL Type
1:4f996a4:      *
1:4f996a4:      * @return The Non-Nullable DB2 SQL Type.
1:4f996a4:      */
1:eac0369:    protected  static int getNonNullableSqlType (int sqlType)
1:eac0369:   {
1:eac0369:     return sqlType & ~1;
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:               return  DRDAConstants.DB2_SQLTYPE_VARCHAR + nullAddVal;
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:         case DRDAConstants.DB2_SQLTYPE_BLOB_LOCATOR:
1:         case DRDAConstants.DB2_SQLTYPE_CLOB_LOCATOR:
1:         case DRDAConstants.DB2_SQLTYPE_DBCLOB_LOCATOR:
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Map jdbc type to the DB2 DRDA SQL Types expected by jcc.
1:      *@param jdbctype  - jdbc Type to convert
1:      *@param nullable - whether the type is nullable
1:      **/
1:     
1:      * @param appRequester - state variable for the connection
/////////////////////////////////////////////////////////////////////////
1:                                                int[] outlen)
1:      throws SQLException
1:       int nullAddVal =0;
1:       if (nullable) 
1:           nullAddVal =1; 
1:       
1:       // Call FdocaConstants just to get the length
1:       FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,appRequester,outlen);
1:       switch(jdbctype)
1:       {
1:           case Types.BOOLEAN:
/////////////////////////////////////////////////////////////////////////
1:           case java.sql.Types.BIT:
1:           case java.sql.Types.TINYINT:
1:           case java.sql.Types.SMALLINT:
1:               return DRDAConstants.DB2_SQLTYPE_SMALL + nullAddVal;
1:           case java.sql.Types.INTEGER:
1:               return DRDAConstants.DB2_SQLTYPE_INTEGER + nullAddVal;
1:           case java.sql.Types.BIGINT:
1:               return DRDAConstants.DB2_SQLTYPE_BIGINT + nullAddVal;
1:           case java.sql.Types.DOUBLE:
1:           case java.sql.Types.REAL:
1:               return DRDAConstants.DB2_SQLTYPE_FLOAT + nullAddVal;
1:           case java.sql.Types.DECIMAL:
1:           case java.sql.Types.NUMERIC:
1:               return DRDAConstants.DB2_SQLTYPE_DECIMAL + nullAddVal;
1:           case java.sql.Types.DATE:
1:               return DRDAConstants.DB2_SQLTYPE_DATE + nullAddVal;
1:           case java.sql.Types.TIME:
1:               return DRDAConstants.DB2_SQLTYPE_TIME + nullAddVal;
1:           case java.sql.Types.TIMESTAMP:
1:               return DRDAConstants.DB2_SQLTYPE_TIMESTAMP + nullAddVal;
1:           case java.sql.Types.CHAR:
1:               return  DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;    // null terminated SBCS/Mixed
1:           case java.sql.Types.BINARY:
1:               return DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;
1:           case java.sql.Types.VARCHAR:
1:           case java.sql.Types.VARBINARY:
0:               return  DRDAConstants.DB2_SQLTYPE_VARCHAR + nullAddVal;              
1:           case java.sql.Types.LONGVARBINARY:
1:               return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:           case java.sql.Types.JAVA_OBJECT:
/////////////////////////////////////////////////////////////////////////
1:           case java.sql.Types.BLOB:
1:               return DRDAConstants.DB2_SQLTYPE_BLOB + nullAddVal;
1:           case java.sql.Types.CLOB:
1:               return DRDAConstants.DB2_SQLTYPE_CLOB + nullAddVal;
1:           case java.sql.Types.LONGVARCHAR:
1:               return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:           case java.sql.Types.ARRAY:
1:           case java.sql.Types.DISTINCT:
1:           case java.sql.Types.NULL:
1:           case java.sql.Types.OTHER:
1:           case java.sql.Types.REF:
1:           case java.sql.Types.STRUCT:
1:               throw new SQLException("Jdbc type" + jdbctype + "not Supported yet");
1:             default:
1:                 throw new SQLException ("unrecognized sql type: " + jdbctype);
1:               //throw new BugCheckException ("Encountered unexpected type code");
1:       }
1:     /**
1:      * Translate DB2 SQL Type to the non-nullable type.
1:      * @param sqlType DB2 SQL Type
1:      *
1:      * @return The Non-Nullable DB2 SQL Type.
1:      */
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eff3919
/////////////////////////////////////////////////////////////////////////
1:               if ( appRequester.supportsBooleanValues() )
1:               {
1:                   return DRDAConstants.DB2_SQLTYPE_BOOLEAN + nullAddVal;
1:               }
1:               else
1:               {
1:                   return DRDAConstants.DB2_SQLTYPE_SMALL + nullAddVal;
1:               }
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
0: 	 * @param appRequester - state variable for the connection
/////////////////////////////////////////////////////////////////////////
1:     static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable, AppRequester appRequester,
/////////////////////////////////////////////////////////////////////////
0: 	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,appRequester,outlen);
/////////////////////////////////////////////////////////////////////////
1:               if ( appRequester.supportsUDTs() )
1:               {
1:                   return DRDAConstants.DB2_SQLTYPE_FAKE_UDT + nullAddVal;
1:               }
1:               else
1:               {
1:                   return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
1:               }
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
/////////////////////////////////////////////////////////////////////////
0: 	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,outlen);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		  case Types.BOOLEAN:
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
1: class SQLTypes {
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
/////////////////////////////////////////////////////////////////////////
0:     case DRDAConstants.DB2_SQLTYPE_BOOLEAN:
0:       return JDBC30Translation.BOOLEAN;
1:     case DRDAConstants.DB2_SQLTYPE_SMALL:
1:     case DRDAConstants.DB2_SQLTYPE_INTEGER:
1:     case DRDAConstants.DB2_SQLTYPE_BIGINT:
1:     case DRDAConstants.DB2_SQLTYPE_FLOAT:
/////////////////////////////////////////////////////////////////////////
1:     case DRDAConstants.DB2_SQLTYPE_DECIMAL:            // can map to either NUMERIC or DECIMAL!!! @sxg
1:     case DRDAConstants.DB2_SQLTYPE_ZONED:              // can map to either NUMERIC or DECIMAL!!! @sxg
1:     case DRDAConstants.DB2_SQLTYPE_NUMERIC:            // can map to either NUMERIC or DECIMAL!!! @sxg
1:     case DRDAConstants.DB2_SQLTYPE_CHAR:    // mixed and single byte
1:     case DRDAConstants.DB2_SQLTYPE_CSTR:    // SBCS null terminated 
1:     case DRDAConstants.DB2_SQLTYPE_GRAPHIC: // fixed character DBCS
1:     case DRDAConstants.DB2_SQLTYPE_VARGRAPH:  // variable character DBCS
1:     case DRDAConstants.DB2_SQLTYPE_VARCHAR:   // variable character SBCS/Mixed
1:     case DRDAConstants.DB2_SQLTYPE_LSTR:      // pascal string SBCS/Mixed
1:     case DRDAConstants.DB2_SQLTYPE_LONGRAPH:  // long varchar DBCS
1:     case DRDAConstants.DB2_SQLTYPE_LONG:      // long varchar SBCS/Mixed
1:     case DRDAConstants.DB2_SQLTYPE_DATE:
1:     case DRDAConstants.DB2_SQLTYPE_TIME:
1:     case DRDAConstants.DB2_SQLTYPE_TIMESTAMP:
1:     case DRDAConstants.DB2_SQLTYPE_CLOB:    // large object character SBCS/Mixed
1:     case DRDAConstants.DB2_SQLTYPE_DBCLOB:  // large object character DBCS
1:     case DRDAConstants.DB2_SQLTYPE_BLOB:    // large object bytes
0: 		case DRDAConstants.DB2_SQLTYPE_BLOB_LOCATOR:
0: 		case DRDAConstants.DB2_SQLTYPE_CLOB_LOCATOR:
0: 		case DRDAConstants.DB2_SQLTYPE_DBCLOB_LOCATOR:
/////////////////////////////////////////////////////////////////////////
0:  static protected int mapJdbcTypeToDB2SqlType (AppRequester appRequester, int jdbctype, boolean nullable,
/////////////////////////////////////////////////////////////////////////
0: 	  FdocaConstants.mapJdbcTypeToDrdaType( appRequester, jdbctype,nullable,outlen);
0: 	  jdbctype = FdocaConstants.clipJdbcType( appRequester, jdbctype );
1: 	  
0: 			  return DRDAConstants.DB2_SQLTYPE_BOOLEAN + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_SMALL + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_INTEGER + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_BIGINT + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_FLOAT + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_DECIMAL + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_DATE + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_TIME + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_TIMESTAMP + nullAddVal;
0: 			  return  DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;    // null terminated SBCS/Mixed
0: 			  return DRDAConstants.DB2_SQLTYPE_CHAR + nullAddVal;
0: 			  return  DRDAConstants.DB2_SQLTYPE_VARCHAR + nullAddVal;			  
0: 			  return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_BLOB + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_CLOB + nullAddVal;
0: 			  return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
commit:d7258ed
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.drda.SQLTypes
1: 
0:    Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:141cd31
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.drda;
1: 
0: import java.sql.Types;
1: import java.sql.SQLException;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: 
1: 
0: public class SQLTypes {
1: 
1:   /**
0:      IBM Copyright &copy notice.
1:   */
0:   public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
1: 
0:   //----------------------------------------------------------------------------
0:   protected final static int DB2_SQLTYPE_DATE = 384;        // DATE
0:   protected final static int DB2_SQLTYPE_NDATE = 385;
0:   protected final static int DB2_SQLTYPE_TIME = 388;        // TIME
0:   protected final static int DB2_SQLTYPE_NTIME = 389;
0:   protected final static int DB2_SQLTYPE_TIMESTAMP = 392;   // TIMESTAMP
0:   protected final static int DB2_SQLTYPE_NTIMESTAMP = 393;
0:   protected final static int DB2_SQLTYPE_DATALINK = 396;    // DATALINK
0:   protected final static int DB2_SQLTYPE_NDATALINK = 397;
1: 
0:   protected final static int DB2_SQLTYPE_BLOB = 404;        // BLOB
0:   protected final static int DB2_SQLTYPE_NBLOB = 405;
0:   protected final static int DB2_SQLTYPE_CLOB = 408;        // CLOB
0:   protected final static int DB2_SQLTYPE_NCLOB = 409;
0:   protected final static int DB2_SQLTYPE_DBCLOB = 412;      // DBCLOB
0:   protected final static int DB2_SQLTYPE_NDBCLOB = 413;
1: 
0:   protected final static int DB2_SQLTYPE_VARCHAR = 448;     // VARCHAR(i) - varying length string
0:   protected final static int DB2_SQLTYPE_NVARCHAR = 449;
0:   protected final static int DB2_SQLTYPE_CHAR = 452;        // CHAR(i) - fixed length
0:   protected final static int DB2_SQLTYPE_NCHAR = 453;
0:   protected final static int DB2_SQLTYPE_LONG = 456;        // LONG VARCHAR - varying length string
0:   protected final static int DB2_SQLTYPE_NLONG = 457;
0:   protected final static int DB2_SQLTYPE_CSTR = 460;        // SBCS - null terminated
0:   protected final static int DB2_SQLTYPE_NCSTR = 461;
0:   protected final static int DB2_SQLTYPE_VARGRAPH = 464;    // VARGRAPHIC(i) - varying length
0:                                                   // graphic string (2 byte length)
0:   protected final static int DB2_SQLTYPE_NVARGRAPH = 465;
0:   protected final static int DB2_SQLTYPE_GRAPHIC = 468;     // GRAPHIC(i) - fixed length graphic string                                                             */
0:   protected final static int DB2_SQLTYPE_NGRAPHIC = 469;
0:   protected final static int DB2_SQLTYPE_LONGRAPH = 472;    // LONG VARGRAPHIC(i) - varying length graphic string                                              */
0:   protected final static int DB2_SQLTYPE_NLONGRAPH = 473;
0:   protected final static int DB2_SQLTYPE_LSTR = 476;        // varying length string for Pascal (1-byte length)                                                     */
0:   protected final static int DB2_SQLTYPE_NLSTR = 477;
1: 
0:   protected final static int DB2_SQLTYPE_FLOAT = 480;       // FLOAT - 4 or 8 byte floating point
0:   protected final static int DB2_SQLTYPE_NFLOAT = 481;
0:   protected final static int DB2_SQLTYPE_DECIMAL = 484;     // DECIMAL (m,n)
0:   protected final static int DB2_SQLTYPE_NDECIMAL = 485;
0:   protected final static int DB2_SQLTYPE_ZONED = 488;       // Zoned Decimal -> DECIMAL(m,n)
0:   protected final static int DB2_SQLTYPE_NZONED = 489;
1: 
0:   protected final static int DB2_SQLTYPE_BIGINT = 492;      // BIGINT - 8-byte signed integer
0:   protected final static int DB2_SQLTYPE_NBIGINT = 493;
0:   protected final static int DB2_SQLTYPE_INTEGER = 496;     // INTEGER
0:   protected final static int DB2_SQLTYPE_NINTEGER = 497;
0:   protected final static int DB2_SQLTYPE_SMALL = 500;       // SMALLINT - 2-byte signed integer                                                                    */
0:   protected final static int DB2_SQLTYPE_NSMALL = 501;
1: 
0:   protected final static int DB2_SQLTYPE_NUMERIC = 504;     // NUMERIC -> DECIMAL (m,n)
0:   protected final static int DB2_SQLTYPE_NNUMERIC = 505;
1: 
0:   protected final static int DB2_SQLTYPE_ROWID = 904;           // ROWID
0:   protected final static int DB2_SQLTYPE_NROWID = 905;
0:   protected final static int DB2_SQLTYPE_BLOB_LOCATOR = 960;    // BLOB locator
0:   protected final static int DB2_SQLTYPE_NBLOB_LOCATOR = 961;
0:   protected final static int DB2_SQLTYPE_CLOB_LOCATOR = 964;    // CLOB locator
0:   protected final static int DB2_SQLTYPE_NCLOB_LOCATOR = 965;
0:   protected final static int DB2_SQLTYPE_DBCLOB_LOCATOR = 968;  // DBCLOB locator
0:   protected final static int DB2_SQLTYPE_NDBCLOB_LOCATOR = 969;
1: 
1:   // define final statics for the fdoca type codes here!!!
1: 
1:   // hide the default constructor
1:   private SQLTypes() {}
1: 
1: 
1:   /**
1:    * Map DB2 SQL Type to JDBC Type
1:    * 
1:    * @param sqlType SQL Type to convert
1:    * @param length storage length of type
1:    * @param ccsid ccsid of type
1:    *
1:    * @return Corresponding JDBC Type 
1:    */
1: 
1:   static protected int mapDB2SqlTypeToJdbcType (int sqlType, long length, int ccsid)
1:   {
1:     switch (getNonNullableSqlType (sqlType)) { // mask the isNullable bit
0:     case DB2_SQLTYPE_SMALL:
1:       return java.sql.Types.SMALLINT;
0:     case DB2_SQLTYPE_INTEGER:
1:       return java.sql.Types.INTEGER;
0:     case DB2_SQLTYPE_BIGINT:
1:       return java.sql.Types.BIGINT;
0:     case DB2_SQLTYPE_FLOAT:
1:       if (length == 16)                  // can map to either NUMERIC or DECIMAL!!! @sxg
1:         return java.sql.Types.DECIMAL;
1:       else if (length == 8)              // can map to either DOUBLE or FLOAT!!! @sxg
1:         return java.sql.Types.DOUBLE;
1:       else if (length == 4)
1:         return java.sql.Types.REAL;
1:       else
1:         return 0;
1:         //throw new BugCheckException ("Encountered unexpected float length");
0:     case DB2_SQLTYPE_DECIMAL:            // can map to either NUMERIC or DECIMAL!!! @sxg
0:     case DB2_SQLTYPE_ZONED:              // can map to either NUMERIC or DECIMAL!!! @sxg
0:     case DB2_SQLTYPE_NUMERIC:            // can map to either NUMERIC or DECIMAL!!! @sxg
1:       return java.sql.Types.DECIMAL;
0:     case DB2_SQLTYPE_CHAR:    // mixed and single byte
1:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:         return java.sql.Types.BINARY;
1:       else
1:         return java.sql.Types.CHAR;
0:     case DB2_SQLTYPE_CSTR:    // SBCS null terminated 
0:     case DB2_SQLTYPE_GRAPHIC: // fixed character DBCS
1:       return java.sql.Types.CHAR;
1:     // use ccsid to distinguish between BINARY and CHAR, VARBINARY and VARCHAR, LONG... !!! -j/p/s
0:     case DB2_SQLTYPE_VARGRAPH:  // variable character DBCS
0:     case DB2_SQLTYPE_VARCHAR:   // variable character SBCS/Mixed
1:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:         return java.sql.Types.VARBINARY;
1:       else
1:         return java.sql.Types.VARCHAR;
0:     case DB2_SQLTYPE_LSTR:      // pascal string SBCS/Mixed
1:       return java.sql.Types.VARCHAR;
0:     case DB2_SQLTYPE_LONGRAPH:  // long varchar DBCS
0:     case DB2_SQLTYPE_LONG:      // long varchar SBCS/Mixed
1:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
1:         return java.sql.Types.LONGVARBINARY;
1:       else
1:         return java.sql.Types.LONGVARCHAR;
0:     case DB2_SQLTYPE_DATE:
1:       return java.sql.Types.DATE;
0:     case DB2_SQLTYPE_TIME:
1:       return java.sql.Types.TIME;
0:     case DB2_SQLTYPE_TIMESTAMP:
1:       return java.sql.Types.TIMESTAMP;
0:     case DB2_SQLTYPE_CLOB:    // large object character SBCS/Mixed
0:     case DB2_SQLTYPE_DBCLOB:  // large object character DBCS
1:       return java.sql.Types.CLOB;
0:     case DB2_SQLTYPE_BLOB:    // large object bytes
0: 		case DB2_SQLTYPE_BLOB_LOCATOR:
0: 		case DB2_SQLTYPE_CLOB_LOCATOR:
0: 		case DB2_SQLTYPE_DBCLOB_LOCATOR:
1:       return java.sql.Types.BLOB;
1:     default:
1:       //throw new BugCheckException ("Encountered unexpected type code");
1:       return 0;
1:     }
1:   }
1: 
1: 
1: 	/**
0: 	 * Map jdbc type to the DB2 DRDA SQL Types expected by jcc.
0: 	 *@param jdbctype  - jdbc Type to convert
0: 	 *@param nullable - whether the type is nullable
0: 	 **/
1: 
1: 	
1:  /**  Map JDBC Type to DB2 SqlType
1:   * @param jdbctype   JDBC Type from java.sql.Types
1:   * @param nullable   true if this is a nullable type
1:   * @param outlen     output parameter with type length
1:   *
1:   * @return Corresponding DB2 SQL Type (See DRDA Manual FD:OCA Meta 
1:   *          Data Summary, page 245)
1:   * 
1:   * @exception SQLException thrown for unrecognized SQLType
1:   */
1: 
0:  static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
0: 											   int[] outlen)
0: 	 throws SQLException
1:   {
0: 	  int nullAddVal =0;
1: 
0: 	  if (nullable) 
0: 		  nullAddVal =1; 
1: 	  
0: 	  // Call FdocaConstants just to get the length
0: 	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,outlen);
1: 
0: 	  switch(jdbctype)
1: 	  {
0: 		  case JDBC30Translation.BOOLEAN:
0: 		  case java.sql.Types.BIT:
0: 		  case java.sql.Types.TINYINT:
0: 		  case java.sql.Types.SMALLINT:
0: 			  return DB2_SQLTYPE_SMALL + nullAddVal;
0: 		  case java.sql.Types.INTEGER:
0: 			  return DB2_SQLTYPE_INTEGER + nullAddVal;
0: 		  case java.sql.Types.BIGINT:
0: 			  return DB2_SQLTYPE_BIGINT + nullAddVal;
0: 		  case java.sql.Types.DOUBLE:
0: 		  case java.sql.Types.REAL:
0: 			  return DB2_SQLTYPE_FLOAT + nullAddVal;
0: 		  case java.sql.Types.DECIMAL:
0: 		  case java.sql.Types.NUMERIC:
0: 			  return DB2_SQLTYPE_DECIMAL + nullAddVal;
0: 		  case java.sql.Types.DATE:
0: 			  return DB2_SQLTYPE_DATE + nullAddVal;
0: 		  case java.sql.Types.TIME:
0: 			  return DB2_SQLTYPE_TIME + nullAddVal;
0: 		  case java.sql.Types.TIMESTAMP:
0: 			  return DB2_SQLTYPE_TIMESTAMP + nullAddVal;
0: 		  case java.sql.Types.CHAR:
0: 			  return  DB2_SQLTYPE_CHAR + nullAddVal;    // null terminated SBCS/Mixed
0: 		  case java.sql.Types.BINARY:
0: 			  return DB2_SQLTYPE_CHAR + nullAddVal;
1: 
0: 		  case java.sql.Types.VARCHAR:
0: 		  case java.sql.Types.VARBINARY:
0: 			  return  DB2_SQLTYPE_VARCHAR + nullAddVal;			  
0: 		  case java.sql.Types.LONGVARBINARY:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.JAVA_OBJECT:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.BLOB:
0: 			  return DB2_SQLTYPE_BLOB + nullAddVal;
0: 		  case java.sql.Types.CLOB:
0: 			  return DB2_SQLTYPE_CLOB + nullAddVal;
0: 		  case java.sql.Types.LONGVARCHAR:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.ARRAY:
0: 		  case java.sql.Types.DISTINCT:
0: 		  case java.sql.Types.NULL:
0: 		  case java.sql.Types.OTHER:
0: 		  case java.sql.Types.REF:
0: 		  case java.sql.Types.STRUCT:
0: 			  throw new SQLException("Jdbc type" + jdbctype + "not Supported yet");
1: 			default:
0: 				throw new SQLException ("unrecognized sql type: " + jdbctype);
1: 			  //throw new BugCheckException ("Encountered unexpected type code");
1: 
1: 	  }
1:   }
1: 
1: 	/**
0: 	 * Translate DB2 SQL Type to the non-nullable type.
0: 	 * @param sqlType DB2 SQL Type
1: 	 *
0: 	 * @return The Non-Nullable DB2 SQL Type.
1: 	 */
1:    protected  static int getNonNullableSqlType (int sqlType)
1:   {
1:     return sqlType & ~1;
1:   }
1: 
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.drda
0:    (C) Copyright IBM Corp. 2002, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.drda;
0: 
0: import java.sql.Types;
0: import java.sql.SQLException;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: 
0: 
0: public class SQLTypes {
0: 
0:   /**
0:      IBM Copyright &copy notice.
0:   */
0:   public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2002_2004;
0: 
0:   //----------------------------------------------------------------------------
0:   protected final static int DB2_SQLTYPE_DATE = 384;        // DATE
0:   protected final static int DB2_SQLTYPE_NDATE = 385;
0:   protected final static int DB2_SQLTYPE_TIME = 388;        // TIME
0:   protected final static int DB2_SQLTYPE_NTIME = 389;
0:   protected final static int DB2_SQLTYPE_TIMESTAMP = 392;   // TIMESTAMP
0:   protected final static int DB2_SQLTYPE_NTIMESTAMP = 393;
0:   protected final static int DB2_SQLTYPE_DATALINK = 396;    // DATALINK
0:   protected final static int DB2_SQLTYPE_NDATALINK = 397;
0: 
0:   protected final static int DB2_SQLTYPE_BLOB = 404;        // BLOB
0:   protected final static int DB2_SQLTYPE_NBLOB = 405;
0:   protected final static int DB2_SQLTYPE_CLOB = 408;        // CLOB
0:   protected final static int DB2_SQLTYPE_NCLOB = 409;
0:   protected final static int DB2_SQLTYPE_DBCLOB = 412;      // DBCLOB
0:   protected final static int DB2_SQLTYPE_NDBCLOB = 413;
0: 
0:   protected final static int DB2_SQLTYPE_VARCHAR = 448;     // VARCHAR(i) - varying length string
0:   protected final static int DB2_SQLTYPE_NVARCHAR = 449;
0:   protected final static int DB2_SQLTYPE_CHAR = 452;        // CHAR(i) - fixed length
0:   protected final static int DB2_SQLTYPE_NCHAR = 453;
0:   protected final static int DB2_SQLTYPE_LONG = 456;        // LONG VARCHAR - varying length string
0:   protected final static int DB2_SQLTYPE_NLONG = 457;
0:   protected final static int DB2_SQLTYPE_CSTR = 460;        // SBCS - null terminated
0:   protected final static int DB2_SQLTYPE_NCSTR = 461;
0:   protected final static int DB2_SQLTYPE_VARGRAPH = 464;    // VARGRAPHIC(i) - varying length
0:                                                   // graphic string (2 byte length)
0:   protected final static int DB2_SQLTYPE_NVARGRAPH = 465;
0:   protected final static int DB2_SQLTYPE_GRAPHIC = 468;     // GRAPHIC(i) - fixed length graphic string                                                             */
0:   protected final static int DB2_SQLTYPE_NGRAPHIC = 469;
0:   protected final static int DB2_SQLTYPE_LONGRAPH = 472;    // LONG VARGRAPHIC(i) - varying length graphic string                                              */
0:   protected final static int DB2_SQLTYPE_NLONGRAPH = 473;
0:   protected final static int DB2_SQLTYPE_LSTR = 476;        // varying length string for Pascal (1-byte length)                                                     */
0:   protected final static int DB2_SQLTYPE_NLSTR = 477;
0: 
0:   protected final static int DB2_SQLTYPE_FLOAT = 480;       // FLOAT - 4 or 8 byte floating point
0:   protected final static int DB2_SQLTYPE_NFLOAT = 481;
0:   protected final static int DB2_SQLTYPE_DECIMAL = 484;     // DECIMAL (m,n)
0:   protected final static int DB2_SQLTYPE_NDECIMAL = 485;
0:   protected final static int DB2_SQLTYPE_ZONED = 488;       // Zoned Decimal -> DECIMAL(m,n)
0:   protected final static int DB2_SQLTYPE_NZONED = 489;
0: 
0:   protected final static int DB2_SQLTYPE_BIGINT = 492;      // BIGINT - 8-byte signed integer
0:   protected final static int DB2_SQLTYPE_NBIGINT = 493;
0:   protected final static int DB2_SQLTYPE_INTEGER = 496;     // INTEGER
0:   protected final static int DB2_SQLTYPE_NINTEGER = 497;
0:   protected final static int DB2_SQLTYPE_SMALL = 500;       // SMALLINT - 2-byte signed integer                                                                    */
0:   protected final static int DB2_SQLTYPE_NSMALL = 501;
0: 
0:   protected final static int DB2_SQLTYPE_NUMERIC = 504;     // NUMERIC -> DECIMAL (m,n)
0:   protected final static int DB2_SQLTYPE_NNUMERIC = 505;
0: 
0:   protected final static int DB2_SQLTYPE_ROWID = 904;           // ROWID
0:   protected final static int DB2_SQLTYPE_NROWID = 905;
0:   protected final static int DB2_SQLTYPE_BLOB_LOCATOR = 960;    // BLOB locator
0:   protected final static int DB2_SQLTYPE_NBLOB_LOCATOR = 961;
0:   protected final static int DB2_SQLTYPE_CLOB_LOCATOR = 964;    // CLOB locator
0:   protected final static int DB2_SQLTYPE_NCLOB_LOCATOR = 965;
0:   protected final static int DB2_SQLTYPE_DBCLOB_LOCATOR = 968;  // DBCLOB locator
0:   protected final static int DB2_SQLTYPE_NDBCLOB_LOCATOR = 969;
0: 
0:   // define final statics for the fdoca type codes here!!!
0: 
0:   // hide the default constructor
0:   private SQLTypes() {}
0: 
0: 
0:   /**
0:    * Map DB2 SQL Type to JDBC Type
0:    * 
0:    * @param sqlType SQL Type to convert
0:    * @param length storage length of type
0:    * @param ccsid ccsid of type
0:    *
0:    * @return Corresponding JDBC Type 
0:    */
0: 
0:   static protected int mapDB2SqlTypeToJdbcType (int sqlType, long length, int ccsid)
0:   {
0:     switch (getNonNullableSqlType (sqlType)) { // mask the isNullable bit
0:     case DB2_SQLTYPE_SMALL:
0:       return java.sql.Types.SMALLINT;
0:     case DB2_SQLTYPE_INTEGER:
0:       return java.sql.Types.INTEGER;
0:     case DB2_SQLTYPE_BIGINT:
0:       return java.sql.Types.BIGINT;
0:     case DB2_SQLTYPE_FLOAT:
0:       if (length == 16)                  // can map to either NUMERIC or DECIMAL!!! @sxg
0:         return java.sql.Types.DECIMAL;
0:       else if (length == 8)              // can map to either DOUBLE or FLOAT!!! @sxg
0:         return java.sql.Types.DOUBLE;
0:       else if (length == 4)
0:         return java.sql.Types.REAL;
0:       else
0:         return 0;
0:         //throw new BugCheckException ("Encountered unexpected float length");
0:     case DB2_SQLTYPE_DECIMAL:            // can map to either NUMERIC or DECIMAL!!! @sxg
0:     case DB2_SQLTYPE_ZONED:              // can map to either NUMERIC or DECIMAL!!! @sxg
0:     case DB2_SQLTYPE_NUMERIC:            // can map to either NUMERIC or DECIMAL!!! @sxg
0:       return java.sql.Types.DECIMAL;
0:     case DB2_SQLTYPE_CHAR:    // mixed and single byte
0:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
0:         return java.sql.Types.BINARY;
0:       else
0:         return java.sql.Types.CHAR;
0:     case DB2_SQLTYPE_CSTR:    // SBCS null terminated 
0:     case DB2_SQLTYPE_GRAPHIC: // fixed character DBCS
0:       return java.sql.Types.CHAR;
0:     // use ccsid to distinguish between BINARY and CHAR, VARBINARY and VARCHAR, LONG... !!! -j/p/s
0:     case DB2_SQLTYPE_VARGRAPH:  // variable character DBCS
0:     case DB2_SQLTYPE_VARCHAR:   // variable character SBCS/Mixed
0:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
0:         return java.sql.Types.VARBINARY;
0:       else
0:         return java.sql.Types.VARCHAR;
0:     case DB2_SQLTYPE_LSTR:      // pascal string SBCS/Mixed
0:       return java.sql.Types.VARCHAR;
0:     case DB2_SQLTYPE_LONGRAPH:  // long varchar DBCS
0:     case DB2_SQLTYPE_LONG:      // long varchar SBCS/Mixed
0:       if (ccsid == 0xffff || ccsid == 0) // we think UW returns 0, and 390 returns 0xffff, doublecheck !!!
0:         return java.sql.Types.LONGVARBINARY;
0:       else
0:         return java.sql.Types.LONGVARCHAR;
0:     case DB2_SQLTYPE_DATE:
0:       return java.sql.Types.DATE;
0:     case DB2_SQLTYPE_TIME:
0:       return java.sql.Types.TIME;
0:     case DB2_SQLTYPE_TIMESTAMP:
0:       return java.sql.Types.TIMESTAMP;
0:     case DB2_SQLTYPE_CLOB:    // large object character SBCS/Mixed
0:     case DB2_SQLTYPE_DBCLOB:  // large object character DBCS
0:       return java.sql.Types.CLOB;
0:     case DB2_SQLTYPE_BLOB:    // large object bytes
0: 		case DB2_SQLTYPE_BLOB_LOCATOR:
0: 		case DB2_SQLTYPE_CLOB_LOCATOR:
0: 		case DB2_SQLTYPE_DBCLOB_LOCATOR:
0:       return java.sql.Types.BLOB;
0:     default:
0:       //throw new BugCheckException ("Encountered unexpected type code");
0:       return 0;
0:     }
0:   }
0: 
0: 
0: 	/**
0: 	 * Map jdbc type to the DB2 DRDA SQL Types expected by jcc.
0: 	 *@param jdbctype  - jdbc Type to convert
0: 	 *@param nullable - whether the type is nullable
0: 	 **/
0: 
0: 	
0:  /**  Map JDBC Type to DB2 SqlType
0:   * @param jdbctype   JDBC Type from java.sql.Types
0:   * @param nullable   true if this is a nullable type
0:   * @param outlen     output parameter with type length
0:   *
0:   * @return Corresponding DB2 SQL Type (See DRDA Manual FD:OCA Meta 
0:   *          Data Summary, page 245)
0:   * 
0:   * @exception SQLException thrown for unrecognized SQLType
0:   */
0: 
0:  static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
0: 											   int[] outlen)
0: 	 throws SQLException
0:   {
0: 	  int nullAddVal =0;
0: 
0: 	  if (nullable) 
0: 		  nullAddVal =1; 
0: 	  
0: 	  // Call FdocaConstants just to get the length
0: 	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,outlen);
0: 
0: 	  switch(jdbctype)
0: 	  {
0: 		  case JDBC30Translation.BOOLEAN:
0: 		  case java.sql.Types.BIT:
0: 		  case java.sql.Types.TINYINT:
0: 		  case java.sql.Types.SMALLINT:
0: 			  return DB2_SQLTYPE_SMALL + nullAddVal;
0: 		  case java.sql.Types.INTEGER:
0: 			  return DB2_SQLTYPE_INTEGER + nullAddVal;
0: 		  case java.sql.Types.BIGINT:
0: 			  return DB2_SQLTYPE_BIGINT + nullAddVal;
0: 		  case java.sql.Types.DOUBLE:
0: 		  case java.sql.Types.REAL:
0: 			  return DB2_SQLTYPE_FLOAT + nullAddVal;
0: 		  case java.sql.Types.DECIMAL:
0: 		  case java.sql.Types.NUMERIC:
0: 			  return DB2_SQLTYPE_DECIMAL + nullAddVal;
0: 		  case java.sql.Types.DATE:
0: 			  return DB2_SQLTYPE_DATE + nullAddVal;
0: 		  case java.sql.Types.TIME:
0: 			  return DB2_SQLTYPE_TIME + nullAddVal;
0: 		  case java.sql.Types.TIMESTAMP:
0: 			  return DB2_SQLTYPE_TIMESTAMP + nullAddVal;
0: 		  case java.sql.Types.CHAR:
0: 			  return  DB2_SQLTYPE_CHAR + nullAddVal;    // null terminated SBCS/Mixed
0: 		  case java.sql.Types.BINARY:
0: 			  return DB2_SQLTYPE_CHAR + nullAddVal;
0: 
0: 		  case java.sql.Types.VARCHAR:
0: 		  case java.sql.Types.VARBINARY:
0: 			  return  DB2_SQLTYPE_VARCHAR + nullAddVal;			  
0: 		  case java.sql.Types.LONGVARBINARY:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.JAVA_OBJECT:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.BLOB:
0: 			  return DB2_SQLTYPE_BLOB + nullAddVal;
0: 		  case java.sql.Types.CLOB:
0: 			  return DB2_SQLTYPE_CLOB + nullAddVal;
0: 		  case java.sql.Types.LONGVARCHAR:
0: 			  return DB2_SQLTYPE_LONG + nullAddVal;
0: 		  case java.sql.Types.ARRAY:
0: 		  case java.sql.Types.DISTINCT:
0: 		  case java.sql.Types.NULL:
0: 		  case java.sql.Types.OTHER:
0: 		  case java.sql.Types.REF:
0: 		  case java.sql.Types.STRUCT:
0: 			  throw new SQLException("Jdbc type" + jdbctype + "not Supported yet");
0: 			default:
0: 				throw new SQLException ("unrecognized sql type: " + jdbctype);
0: 			  //throw new BugCheckException ("Encountered unexpected type code");
0: 
0: 	  }
0:   }
0: 
0: 	/**
0: 	 * Translate DB2 SQL Type to the non-nullable type.
0: 	 * @param sqlType DB2 SQL Type
0: 	 *
0: 	 * @return The Non-Nullable DB2 SQL Type.
0: 	 */
0:    protected  static int getNonNullableSqlType (int sqlType)
0:   {
0:     return sqlType & ~1;
0:   }
0: 
0: 
0: }
============================================================================