1:33776ff: /*
25:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.Utils
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:33776ff: 
1:69e3d06: import java.math.BigDecimal;
1:d506170: import java.sql.SQLException;
1:f271471: import org.apache.derby.shared.common.reference.MessageId;
1:d506170: 
1:33776ff: // Self-contained utilities.
1:33776ff: // Don't reference any other driver classes, except Configuration, from within this class.
1:70f7692: 
1:70f7692: public final class Utils {
1:70f7692: 
1:1146825:     /**
1:1146825:      * Quote an SQL identifier by enclosing it in double-quote characters
1:1146825:      * and escaping any double-quote characters with an extra double-quote
1:1146825:      * character.
1:1146825:      *
1:1146825:      * @param identifier the identifier to quote
1:1146825:      * @return the quoted identifier
1:1146825:      */
1:1146825:     static String quoteSqlIdentifier(String identifier) {
1:1146825:         // In the common case the length of the return value is the length of
1:1146825:         // the identifier plus the two surrounding double quotes. Use that as
1:1146825:         // the initial capacity of the buffer.
1:1146825:         StringBuffer retValue = new StringBuffer(identifier.length() + 2);
1:1146825: 
1:1146825:         final char quote = '"';
1:1146825: 
1:1146825:         retValue.append(quote);
1:1146825: 
1:1146825:         for (int i = 0; i < identifier.length(); i++) {
1:1146825:             char ch = identifier.charAt(i);
1:1146825:             if (ch == quote) {
1:1146825:                 retValue.append(quote);
1:1146825:             }
1:1146825:             retValue.append(ch);
1:1146825:         }
1:69e3d06: 
1:1146825:         retValue.append(quote);
1:69e3d06: 
1:1146825:         return retValue.toString();
1:1146825:     }
1:1146825: 
1:70f7692:     static String getStringFromBytes(byte[] bytes) {
1:70f7692:         if (bytes == null) {
2:70f7692:             return "{}";
15:70f7692:         }
1:70f7692:         StringBuffer stringBuffer = new StringBuffer(bytes.length * 6 + 4);
2:70f7692:         stringBuffer.append("{ ");
1:70f7692:         for (int i = 0; i < bytes.length; i++) {
1:70f7692:             stringBuffer.append("0x");
1:70f7692:             stringBuffer.append(Integer.toHexString(bytes[i] & 0xff));
1:70f7692:             if (i != bytes.length - 1) {
2:70f7692:                 stringBuffer.append(", ");
1:70f7692:             }
1:70f7692:         }
2:70f7692:         stringBuffer.append(" }");
2:70f7692:         return stringBuffer.toString();
1:70f7692:     }
1:1146825: 
1:70f7692:     static String getStringFromInts(int[] ints) {
1:70f7692:         if (ints == null) {
1:70f7692:             return "{}";
1:70f7692:         }
2:70f7692:         StringBuffer stringBuffer = new StringBuffer();
1:70f7692:         stringBuffer.append("{ ");
1:70f7692:         for (int i = 0; i < ints.length; i++) {
1:70f7692:             stringBuffer.append(String.valueOf(ints[i]));
1:70f7692:             if (i != ints.length - 1) {
1:70f7692:                 stringBuffer.append(", ");
1:70f7692:             }
1:70f7692:         }
1:70f7692:         stringBuffer.append(" }");
1:70f7692:         return stringBuffer.toString();
1:70f7692:     }
1:1146825: 
1:69e3d06:     static public int computeBigDecimalPrecision(BigDecimal decimal) {
1:70f7692:         byte[] bBytes = decimal.unscaledValue().abs().toByteArray();
1:70f7692: 
1:70f7692:         if (byteArrayCmp(bBytes, tenRadixArr[tenRadixArr.length - 1]) >= 0) {
1:69e3d06:             throw new IllegalArgumentException(
1:f271471:                 SqlException.getMessageUtil().
1:f271471:                     getTextMessage(MessageId.CONN_PRECISION_TOO_LARGE));
1:70f7692:         }
1:70f7692: 
1:70f7692:         int lo = 0, hi = tenRadixArr.length - 1, mi = (hi + lo) / 2;
1:70f7692:         do {
1:70f7692:             int compare = byteArrayCmp(bBytes, tenRadixArr[mi]);
1:70f7692:             if (compare == 1) {
1:70f7692:                 lo = mi;
1:70f7692:             } else if (compare == -1) {
1:70f7692:                 hi = mi;
4:70f7692:             } else {
1:70f7692:                 break;
1:70f7692:             }
1:70f7692: 
1:70f7692:             mi = (hi + lo) / 2;
1:70f7692:         } while (mi != lo);
1:70f7692: 
1:70f7692:         return (mi + 1);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Used only by computeBigDecimalPrecision()
1:70f7692:     private static int byteArrayCmp(byte[] arg1, byte[] arg2) {
1:70f7692:         int arg1Offset = 0;
1:70f7692:         int arg2Offset = 0;
1:70f7692:         int length;
1:70f7692:         if (arg1.length > arg2.length) {
1:70f7692:             int diff = arg1.length - arg2.length;
1:70f7692:             for (; arg1Offset < diff; arg1Offset++) {
1:70f7692:                 if (arg1[arg1Offset] != 0) {
1:70f7692:                     return 1;
1:70f7692:                 }
1:70f7692:             }
1:70f7692:             length = arg2.length;
1:70f7692:         } else if (arg1.length < arg2.length) {
1:70f7692:             int diff = arg2.length - arg1.length;
1:70f7692:             for (; arg2Offset < diff; arg2Offset++) {
1:70f7692:                 if (arg2[arg2Offset] != 0) {
1:70f7692:                     return -1;
1:70f7692:                 }
1:70f7692:             }
1:70f7692:             length = arg1.length;
1:70f7692:         } else {
1:70f7692:             length = arg1.length;
1:70f7692:         }
1:70f7692: 
1:70f7692:         for (int i = 0; i < length; i++) {
1:70f7692:             int b1 = arg1[arg1Offset + i] & 0xFF;
1:70f7692:             int b2 = arg2[arg2Offset + i] & 0xFF;
1:70f7692:             if (b1 > b2) {
1:70f7692:                 return 1;
1:70f7692:             } else if (b1 < b2) {
1:70f7692:                 return -1;
1:70f7692:             }
1:70f7692:         }
2:70f7692:         return 0;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Used only by computeBigDecimalPrecision()
1:70f7692:     // byte array of 1, 10, 100, 1000, 10000, ..., 10^31 for
1:70f7692:     // fast computing the length a BigDecimal.
1:70f7692:     private static byte[][] tenRadixArr = {
1:70f7692:         {(byte) 0x01}, // 10^0
1:70f7692:         {(byte) 0x0A}, // 10^1
1:70f7692:         {(byte) 0x64}, // 10^2
1:70f7692:         {(byte) 0x03, (byte) 0xe8}, // 10^3
1:70f7692:         {(byte) 0x27, (byte) 0x10}, // 10^4
1:70f7692:         {(byte) 0x01, (byte) 0x86, (byte) 0xa0}, // 10^5
1:70f7692:         {(byte) 0x0f, (byte) 0x42, (byte) 0x40}, // 10^6
1:70f7692:         {(byte) 0x98, (byte) 0x96, (byte) 0x80}, // 10^7
1:70f7692:         {(byte) 0x05, (byte) 0xf5, (byte) 0xe1, (byte) 0x00}, // 10^8
1:70f7692:         {(byte) 0x3b, (byte) 0x9a, (byte) 0xca, (byte) 0x00}, // 10^9
1:70f7692:         {(byte) 0x02, (byte) 0x54, (byte) 0x0b, (byte) 0xe4, (byte) 0x00}, // 10^10
1:70f7692:         {(byte) 0x17, (byte) 0x48, (byte) 0x76, (byte) 0xe8, (byte) 0x00}, // 10^11
1:70f7692:         {(byte) 0xe8, (byte) 0xd4, (byte) 0xa5, (byte) 0x10, (byte) 0x00}, // 10^12
1:70f7692:         {(byte) 0x09, (byte) 0x18, (byte) 0x4e, (byte) 0x72, (byte) 0xa0, (byte) 0x00}, // 10^13
1:70f7692:         {(byte) 0x5a, (byte) 0xf3, (byte) 0x10, (byte) 0x7a, (byte) 0x40, (byte) 0x00}, // 10^14
1:70f7692:         {(byte) 0x03, (byte) 0x8d, (byte) 0x7e, (byte) 0xa4, (byte) 0xc6, (byte) 0x80, (byte) 0x00}, // 10^15
1:70f7692:         {(byte) 0x23, (byte) 0x86, (byte) 0xf2, (byte) 0x6f, (byte) 0xc1, (byte) 0x00, (byte) 0x00}, // 10^16
1:70f7692:         {(byte) 0x01, (byte) 0x63, (byte) 0x45, (byte) 0x78, (byte) 0x5d, (byte) 0x8a, (byte) 0x00, (byte) 0x00}, // 10^17
1:70f7692:         {(byte) 0x0d, (byte) 0xe0, (byte) 0xb6, (byte) 0xb3, (byte) 0xa7, (byte) 0x64, (byte) 0x00, (byte) 0x00}, // 10^18
1:70f7692:         {(byte) 0x8a, (byte) 0xc7, (byte) 0x23, (byte) 0x04, (byte) 0x89, (byte) 0xe8, (byte) 0x00, (byte) 0x00}, // 10^19
1:70f7692:         {(byte) 0x05, (byte) 0x6b, (byte) 0xc7, (byte) 0x5e, (byte) 0x2d, (byte) 0x63, (byte) 0x10, (byte) 0x00, (byte) 0x00}, // 10^20
1:70f7692:         {(byte) 0x36, (byte) 0x35, (byte) 0xc9, (byte) 0xad, (byte) 0xc5, (byte) 0xde, (byte) 0xa0, (byte) 0x00, (byte) 0x00}, // 10^21
1:70f7692:         {(byte) 0x02, (byte) 0x1e, (byte) 0x19, (byte) 0xe0, (byte) 0xc9, (byte) 0xba, (byte) 0xb2, (byte) 0x40, (byte) 0x00, (byte) 0x00}, // 10^22
1:70f7692:         {(byte) 0x15, (byte) 0x2d, (byte) 0x02, (byte) 0xc7, (byte) 0xe1, (byte) 0x4a, (byte) 0xf6, (byte) 0x80, (byte) 0x00, (byte) 0x00}, // 10^23
1:70f7692:         {(byte) 0xd3, (byte) 0xc2, (byte) 0x1b, (byte) 0xce, (byte) 0xcc, (byte) 0xed, (byte) 0xa1, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^24
1:70f7692:         {(byte) 0x08, (byte) 0x45, (byte) 0x95, (byte) 0x16, (byte) 0x14, (byte) 0x01, (byte) 0x48, (byte) 0x4a, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^25
1:70f7692:         {(byte) 0x52, (byte) 0xb7, (byte) 0xd2, (byte) 0xdc, (byte) 0xc8, (byte) 0x0c, (byte) 0xd2, (byte) 0xe4, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^26
1:70f7692:         {(byte) 0x03, (byte) 0x3b, (byte) 0x2e, (byte) 0x3c, (byte) 0x9f, (byte) 0xd0, (byte) 0x80, (byte) 0x3c, (byte) 0xe8, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^27
1:70f7692:         {(byte) 0x20, (byte) 0x4f, (byte) 0xce, (byte) 0x5e, (byte) 0x3e, (byte) 0x25, (byte) 0x02, (byte) 0x61, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^28
1:70f7692:         {(byte) 0x01, (byte) 0x43, (byte) 0x1e, (byte) 0x0f, (byte) 0xae, (byte) 0x6d, (byte) 0x72, (byte) 0x17, (byte) 0xca, (byte) 0xa0, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^29
1:70f7692:         {(byte) 0x0c, (byte) 0x9f, (byte) 0x2c, (byte) 0x9c, (byte) 0xd0, (byte) 0x46, (byte) 0x74, (byte) 0xed, (byte) 0xea, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^30
1:70f7692:         {(byte) 0x7e, (byte) 0x37, (byte) 0xbe, (byte) 0x20, (byte) 0x22, (byte) 0xc0, (byte) 0x91, (byte) 0x4b, (byte) 0x26, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00}  // 10^31
1:70f7692:     };
1:70f7692: 
1:70f7692:     static public int getSqlcodeFromSqlca(Sqlca sqlca) {
2:70f7692:         if (sqlca == null) {
1:70f7692:             return 0;
1:70f7692:         }
1:70f7692:         return sqlca.getSqlCode();
1:70f7692:     }
1:70f7692: 
1:f26c60c:     /** Squash an array of longs into an array of ints */
1:f26c60c:     public static  int[]   squashLongs( long[] longs )
1:f26c60c:     {
1:f26c60c:         int count = (longs == null) ? 0 : longs.length;
1:f26c60c:         int[]   ints = new int[ count ];
1:f26c60c:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1:f26c60c: 
1:f26c60c:         return ints;
1:f26c60c:     }
1:f26c60c: 
2:70f7692:     // latestException is assumed to be non-null, accumulatedExceptions can be null
1:d506170:     public static SQLException accumulateSQLException(SQLException latestException,
1:d506170:                                                       SQLException accumulatedExceptions) {
1:d506170:         if (accumulatedExceptions == null) {
1:d506170:             return latestException;
1:d506170:         } else {
1:d506170:             accumulatedExceptions.setNextException(latestException);
1:d506170:             return accumulatedExceptions;
1:d506170:         }
1:d506170:     }
1:d506170: 
1:70f7692:     public static SqlException accumulateSQLException(SqlException latestException,
1:70f7692:                                                       SqlException accumulatedExceptions) {
1:70f7692:         if (accumulatedExceptions == null) {
2:70f7692:             return latestException;
1:70f7692:         } else {
1:70f7692:             accumulatedExceptions.setNextException(latestException);
1:70f7692:             return accumulatedExceptions;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     public static boolean isSqlTypeNullable(int sqlType) {
1:70f7692:         return (sqlType | 0x01) == sqlType;
1:70f7692:     }
1:70f7692: 
1:0326967:     static int getNonNullableSqlType(int sqlType) {
1:70f7692:         return sqlType & ~1;
1:70f7692:     }
1:70f7692: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:0326967
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     static int getNonNullableSqlType(int sqlType) {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
0: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     static public int computeBigDecimalPrecision(BigDecimal decimal) {
1:             throw new IllegalArgumentException(
/////////////////////////////////////////////////////////////////////////
0:     static public void checkForNegativePositiveSqlcard(
0:             Sqlca sqlca,
0:             ClientStatement statement) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
0:     static public void checkForNegativePositiveSqlcard(
0:             Sqlca sqlca,
0:             ClientResultSet resultSet) throws SqlException {
1: 
/////////////////////////////////////////////////////////////////////////
0:         case Types.BIGINT:
0:         case Types.BINARY:
0:         case Types.BIT:
0:         case Types.CHAR:
0:         case Types.DATE:
0:         case Types.DECIMAL:
0:         case Types.DOUBLE:
0:         case Types.REAL:
0:         case Types.INTEGER:
0:         case Types.LONGVARBINARY:
0:         case Types.LONGVARCHAR:
0:         case Types.NULL:
0:         case Types.NUMERIC:
0:         case Types.OTHER:
0:         case Types.FLOAT:
0:         case Types.SMALLINT:
0:         case Types.TIME:
0:         case Types.TIMESTAMP:
0:         case Types.TINYINT:
0:         case Types.VARBINARY:
0:         case Types.VARCHAR:
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
0:     static public long getUpdateCountFromSqlcard(Sqlca sqlca) {
/////////////////////////////////////////////////////////////////////////
1:     /** Squash an array of longs into an array of ints */
1:     public static  int[]   squashLongs( long[] longs )
1:     {
1:         int count = (longs == null) ? 0 : longs.length;
1:         int[]   ints = new int[ count ];
1:         for ( int i = 0; i < count; i++ ) { ints[ i ] = (int) longs[ i ]; }
1: 
1:         return ints;
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1146825
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Quote an SQL identifier by enclosing it in double-quote characters
1:      * and escaping any double-quote characters with an extra double-quote
1:      * character.
1:      *
1:      * @param identifier the identifier to quote
1:      * @return the quoted identifier
1:      */
1:     static String quoteSqlIdentifier(String identifier) {
1:         // In the common case the length of the return value is the length of
1:         // the identifier plus the two surrounding double quotes. Use that as
1:         // the initial capacity of the buffer.
1:         StringBuffer retValue = new StringBuffer(identifier.length() + 2);
1: 
1:         final char quote = '"';
1: 
1:         retValue.append(quote);
1: 
1:         for (int i = 0; i < identifier.length(); i++) {
1:             char ch = identifier.charAt(i);
1:             if (ch == quote) {
1:                 retValue.append(quote);
1:             }
1:             retValue.append(ch);
1:         }
1: 
1:         retValue.append(quote);
1: 
1:         return retValue.toString();
1:     }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6391648
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1:                 SqlException.getMessageUtil().
1:                     getTextMessage(MessageId.CONN_PRECISION_TOO_LARGE));
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.SQLBit;
0: import org.apache.derby.shared.common.i18n.MessageUtil;
/////////////////////////////////////////////////////////////////////////
0:             throw new java.lang.IllegalArgumentException(
0:                 MessageUtil.getCompleteMessage("J105",
0:                     SqlException.CLIENT_MESSAGE_RESOURCE_NAME,
0:                     (Object[])null));
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static SQLException accumulateSQLException(SQLException latestException,
1:                                                       SQLException accumulatedExceptions) {
1:         if (accumulatedExceptions == null) {
1:             return latestException;
1:         } else {
1:             accumulatedExceptions.setNextException(latestException);
1:             return accumulatedExceptions;
1:         }
1:     }
1: 
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: public final class Utils {
1:     static String getStringFromBytes(byte[] bytes) {
1:         if (bytes == null) {
1:             return "{}";
1:         }
1:         StringBuffer stringBuffer = new StringBuffer(bytes.length * 6 + 4);
1:         stringBuffer.append("{ ");
1:         for (int i = 0; i < bytes.length; i++) {
1:             stringBuffer.append("0x");
1:             stringBuffer.append(Integer.toHexString(bytes[i] & 0xff));
1:             if (i != bytes.length - 1) {
1:                 stringBuffer.append(", ");
1:             }
1:         }
1:         stringBuffer.append(" }");
1:         return stringBuffer.toString();
1:     static String getStringFromInts(int[] ints) {
1:         if (ints == null) {
1:             return "{}";
1:         }
1:         StringBuffer stringBuffer = new StringBuffer();
1:         stringBuffer.append("{ ");
1:         for (int i = 0; i < ints.length; i++) {
1:             stringBuffer.append(String.valueOf(ints[i]));
1:             if (i != ints.length - 1) {
1:                 stringBuffer.append(", ");
1:             }
1:         }
1:         stringBuffer.append(" }");
1:         return stringBuffer.toString();
0:     static String getStringFromStrings(String[] strings) {
0:         if (strings == null) {
1:             return "{}";
1:         }
1:         StringBuffer stringBuffer = new StringBuffer();
1:         stringBuffer.append("{ ");
0:         for (int i = 0; i < strings.length; i++) {
0:             stringBuffer.append(strings[i]);
0:             if (i != strings.length - 1) {
1:                 stringBuffer.append(", ");
1:             }
1:         }
1:         stringBuffer.append(" }");
1:         return stringBuffer.toString();
0:     static public int computeBigDecimalPrecision(java.math.BigDecimal decimal) {
1:         byte[] bBytes = decimal.unscaledValue().abs().toByteArray();
1: 
1:         if (byteArrayCmp(bBytes, tenRadixArr[tenRadixArr.length - 1]) >= 0) {
0:             throw new java.lang.IllegalArgumentException("Precision exceeds 31 digits!");
1:         }
1: 
1:         int lo = 0, hi = tenRadixArr.length - 1, mi = (hi + lo) / 2;
1:         do {
1:             int compare = byteArrayCmp(bBytes, tenRadixArr[mi]);
1:             if (compare == 1) {
1:                 lo = mi;
1:             } else if (compare == -1) {
1:                 hi = mi;
1:             } else {
1:                 break;
1:             }
1: 
1:             mi = (hi + lo) / 2;
1:         } while (mi != lo);
1: 
1:         return (mi + 1);
1:     // Used only by computeBigDecimalPrecision()
1:     private static int byteArrayCmp(byte[] arg1, byte[] arg2) {
1:         int arg1Offset = 0;
1:         int arg2Offset = 0;
1:         int length;
1:         if (arg1.length > arg2.length) {
1:             int diff = arg1.length - arg2.length;
1:             for (; arg1Offset < diff; arg1Offset++) {
1:                 if (arg1[arg1Offset] != 0) {
1:                     return 1;
1:                 }
1:             }
1:             length = arg2.length;
1:         } else if (arg1.length < arg2.length) {
1:             int diff = arg2.length - arg1.length;
1:             for (; arg2Offset < diff; arg2Offset++) {
1:                 if (arg2[arg2Offset] != 0) {
1:                     return -1;
1:                 }
1:             }
1:             length = arg1.length;
1:         } else {
1:             length = arg1.length;
1:         }
1: 
1:         for (int i = 0; i < length; i++) {
1:             int b1 = arg1[arg1Offset + i] & 0xFF;
1:             int b2 = arg2[arg2Offset + i] & 0xFF;
1:             if (b1 > b2) {
1:                 return 1;
1:             } else if (b1 < b2) {
1:                 return -1;
1:             }
1:         }
1:         return 0;
1:     // Used only by computeBigDecimalPrecision()
1:     // byte array of 1, 10, 100, 1000, 10000, ..., 10^31 for
1:     // fast computing the length a BigDecimal.
1:     private static byte[][] tenRadixArr = {
1:         {(byte) 0x01}, // 10^0
1:         {(byte) 0x0A}, // 10^1
1:         {(byte) 0x64}, // 10^2
1:         {(byte) 0x03, (byte) 0xe8}, // 10^3
1:         {(byte) 0x27, (byte) 0x10}, // 10^4
1:         {(byte) 0x01, (byte) 0x86, (byte) 0xa0}, // 10^5
1:         {(byte) 0x0f, (byte) 0x42, (byte) 0x40}, // 10^6
1:         {(byte) 0x98, (byte) 0x96, (byte) 0x80}, // 10^7
1:         {(byte) 0x05, (byte) 0xf5, (byte) 0xe1, (byte) 0x00}, // 10^8
1:         {(byte) 0x3b, (byte) 0x9a, (byte) 0xca, (byte) 0x00}, // 10^9
1:         {(byte) 0x02, (byte) 0x54, (byte) 0x0b, (byte) 0xe4, (byte) 0x00}, // 10^10
1:         {(byte) 0x17, (byte) 0x48, (byte) 0x76, (byte) 0xe8, (byte) 0x00}, // 10^11
1:         {(byte) 0xe8, (byte) 0xd4, (byte) 0xa5, (byte) 0x10, (byte) 0x00}, // 10^12
1:         {(byte) 0x09, (byte) 0x18, (byte) 0x4e, (byte) 0x72, (byte) 0xa0, (byte) 0x00}, // 10^13
1:         {(byte) 0x5a, (byte) 0xf3, (byte) 0x10, (byte) 0x7a, (byte) 0x40, (byte) 0x00}, // 10^14
1:         {(byte) 0x03, (byte) 0x8d, (byte) 0x7e, (byte) 0xa4, (byte) 0xc6, (byte) 0x80, (byte) 0x00}, // 10^15
1:         {(byte) 0x23, (byte) 0x86, (byte) 0xf2, (byte) 0x6f, (byte) 0xc1, (byte) 0x00, (byte) 0x00}, // 10^16
1:         {(byte) 0x01, (byte) 0x63, (byte) 0x45, (byte) 0x78, (byte) 0x5d, (byte) 0x8a, (byte) 0x00, (byte) 0x00}, // 10^17
1:         {(byte) 0x0d, (byte) 0xe0, (byte) 0xb6, (byte) 0xb3, (byte) 0xa7, (byte) 0x64, (byte) 0x00, (byte) 0x00}, // 10^18
1:         {(byte) 0x8a, (byte) 0xc7, (byte) 0x23, (byte) 0x04, (byte) 0x89, (byte) 0xe8, (byte) 0x00, (byte) 0x00}, // 10^19
1:         {(byte) 0x05, (byte) 0x6b, (byte) 0xc7, (byte) 0x5e, (byte) 0x2d, (byte) 0x63, (byte) 0x10, (byte) 0x00, (byte) 0x00}, // 10^20
1:         {(byte) 0x36, (byte) 0x35, (byte) 0xc9, (byte) 0xad, (byte) 0xc5, (byte) 0xde, (byte) 0xa0, (byte) 0x00, (byte) 0x00}, // 10^21
1:         {(byte) 0x02, (byte) 0x1e, (byte) 0x19, (byte) 0xe0, (byte) 0xc9, (byte) 0xba, (byte) 0xb2, (byte) 0x40, (byte) 0x00, (byte) 0x00}, // 10^22
1:         {(byte) 0x15, (byte) 0x2d, (byte) 0x02, (byte) 0xc7, (byte) 0xe1, (byte) 0x4a, (byte) 0xf6, (byte) 0x80, (byte) 0x00, (byte) 0x00}, // 10^23
1:         {(byte) 0xd3, (byte) 0xc2, (byte) 0x1b, (byte) 0xce, (byte) 0xcc, (byte) 0xed, (byte) 0xa1, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^24
1:         {(byte) 0x08, (byte) 0x45, (byte) 0x95, (byte) 0x16, (byte) 0x14, (byte) 0x01, (byte) 0x48, (byte) 0x4a, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^25
1:         {(byte) 0x52, (byte) 0xb7, (byte) 0xd2, (byte) 0xdc, (byte) 0xc8, (byte) 0x0c, (byte) 0xd2, (byte) 0xe4, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^26
1:         {(byte) 0x03, (byte) 0x3b, (byte) 0x2e, (byte) 0x3c, (byte) 0x9f, (byte) 0xd0, (byte) 0x80, (byte) 0x3c, (byte) 0xe8, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^27
1:         {(byte) 0x20, (byte) 0x4f, (byte) 0xce, (byte) 0x5e, (byte) 0x3e, (byte) 0x25, (byte) 0x02, (byte) 0x61, (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^28
1:         {(byte) 0x01, (byte) 0x43, (byte) 0x1e, (byte) 0x0f, (byte) 0xae, (byte) 0x6d, (byte) 0x72, (byte) 0x17, (byte) 0xca, (byte) 0xa0, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^29
1:         {(byte) 0x0c, (byte) 0x9f, (byte) 0x2c, (byte) 0x9c, (byte) 0xd0, (byte) 0x46, (byte) 0x74, (byte) 0xed, (byte) 0xea, (byte) 0x40, (byte) 0x00, (byte) 0x00, (byte) 0x00}, // 10^30
1:         {(byte) 0x7e, (byte) 0x37, (byte) 0xbe, (byte) 0x20, (byte) 0x22, (byte) 0xc0, (byte) 0x91, (byte) 0x4b, (byte) 0x26, (byte) 0x80, (byte) 0x00, (byte) 0x00, (byte) 0x00}  // 10^31
1:     };
0:     // If the input string is short, pad it with blanks.
0:     // If the input string is long, truncate it.
0:     static public String padOrTruncate(String s, int fixedLength) {
0:         if (s.length() >= fixedLength) // we need to truncate
0:         {
0:             return s.substring(0, fixedLength);
0:         } else { // we need to pad
0:             StringBuffer buffer = new StringBuffer(s);
0:             for (int i = 0; i < fixedLength - s.length(); i++) {
0:                 buffer.append(" ");
1:             }
0:             return buffer.toString();
1:         }
0:     static public void checkForNegativePositiveSqlcard(Sqlca sqlca, Statement statement) throws SqlException {
0:         if (sqlca != null) {
0:             int sqlcode = sqlca.getSqlCode();
0:             if (sqlcode < 0) {
0:                 throw new SqlException(statement.agent_.logWriter_, sqlca);
1:             } else {
0:                 if (sqlcode > 0) {
0:                     statement.accumulateWarning(new SqlWarning(statement.agent_.logWriter_, sqlca));
1:                 }
1:             }
1:         }
0:     static public void checkForNegativePositiveSqlcard(Sqlca sqlca, ResultSet resultSet) throws SqlException {
0:         if (sqlca != null) {
0:             int sqlcode = sqlca.getSqlCode();
0:             if (sqlcode < 0) {
0:                 throw new SqlException(resultSet.agent_.logWriter_, sqlca);
1:             } else {
0:                 if (sqlcode > 0) {
0:                     resultSet.accumulateWarning(new SqlWarning(resultSet.agent_.logWriter_, sqlca));
1:                 }
1:             }
1:         }
1:     }
1:     static public int getSqlcodeFromSqlca(Sqlca sqlca) {
1:         if (sqlca == null) {
1:             return 0;
1:         }
1:         return sqlca.getSqlCode();
1:     }
1: 
0:     static public int getUpdateCountFromSqlcard(Sqlca sqlca) {
1:         if (sqlca == null) {
1:             return 0;
1:         } else {
0:             return sqlca.getUpdateCount();
1:         }
1:     }
1: 
0:     public static int min(int i, int j) {
0:         return (i < j) ? i : j;
1:     }
1: 
0:     public static int max(int i, int j) {
0:         return (i < j) ? j : i;
1:     }
1: 
1:     // latestException is assumed to be non-null, accumulatedExceptions can be null
1:     public static SqlException accumulateSQLException(SqlException latestException,
1:                                                       SqlException accumulatedExceptions) {
1:         if (accumulatedExceptions == null) {
1:             return latestException;
1:         } else {
1:             accumulatedExceptions.setNextException(latestException);
1:             return accumulatedExceptions;
1:         }
1:     }
1: 
1:     // latestException is assumed to be non-null, accumulatedExceptions can be null
0:     public static SqlWarning accumulateSQLWarning(SqlWarning latestException,
0:                                                   SqlWarning accumulatedExceptions) {
0:         latestException.setNextException(accumulatedExceptions);
1:         return latestException;
1:     }
1: 
0:     // just a thought...
0:     static String getSQLTypeName(int sqlType) {
0:         switch (sqlType) {
0:         case java.sql.Types.BIGINT:
0:             return "BIGINT";
0:         case java.sql.Types.BINARY:
0:             return "BINARY";
0:         case java.sql.Types.BIT:
0:             return "BIT";
0:         case java.sql.Types.CHAR:
0:             return "CHAR";
0:         case java.sql.Types.DATE:
0:             return "DATE";
0:         case java.sql.Types.DECIMAL:
0:             return "DECIMAL";
0:         case java.sql.Types.DOUBLE:
0:             return "DOUBLE";
0:         case java.sql.Types.REAL:
0:             return "REAL";
0:         case java.sql.Types.INTEGER:
0:             return "INTEGER";
0:         case java.sql.Types.LONGVARBINARY:
0:             return "LONGVARBINARY";
0:         case java.sql.Types.LONGVARCHAR:
0:             return "LONGVARCHAR";
0:         case java.sql.Types.NULL:
0:             return "NULL";
0:         case java.sql.Types.NUMERIC:
0:             return "NUMERIC";
0:         case java.sql.Types.OTHER:
0:             return "OTHER";
0:         case java.sql.Types.FLOAT:
0:             return "FLOAT";
0:         case java.sql.Types.SMALLINT:
0:             return "SMALLINT";
0:         case java.sql.Types.TIME:
0:             return "TIME";
0:         case java.sql.Types.TIMESTAMP:
0:             return "TIMESTAMP";
0:         case java.sql.Types.TINYINT:
0:             return "TINYINT";
0:         case java.sql.Types.VARBINARY:
0:             return "VARBINARY";
0:         case java.sql.Types.VARCHAR:
0:             return "VARCHAR";
0:         default:
0:             return null;
1:         }
1:     }
1: 
1:     public static boolean isSqlTypeNullable(int sqlType) {
1:         return (sqlType | 0x01) == sqlType;
1:     }
1: 
0:     public static int getNonNullableSqlType(int sqlType) {
1:         return sqlType & ~1;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.Utils
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
1: // Self-contained utilities.
1: // Don't reference any other driver classes, except Configuration, from within this class.
0: public final class Utils
0: {
1: 
0:   static String getStringFromBytes (byte[] bytes)
0:   {
0:     if (bytes == null) return "{}";
0:     StringBuffer stringBuffer = new StringBuffer (bytes.length*6 + 4);
0:     stringBuffer.append ("{ ");
0:     for (int i=0; i < bytes.length; i++) {
0:       stringBuffer.append ("0x");
0:       stringBuffer.append (Integer.toHexString (bytes[i] & 0xff));
0:       if (i != bytes.length - 1) stringBuffer.append (", ");
0:     }
0:     stringBuffer.append (" }");
0:     return stringBuffer.toString();
0:   }
1: 
0:   static String getStringFromInts (int[] ints)
0:   {
0:     if (ints == null) return "{}";
0:     StringBuffer stringBuffer = new StringBuffer ();
0:     stringBuffer.append ("{ ");
0:     for (int i=0; i < ints.length; i++) {
0:       stringBuffer.append (String.valueOf (ints[i]));
0:       if (i != ints.length - 1) stringBuffer.append (", ");
0:     }
0:     stringBuffer.append (" }");
0:     return stringBuffer.toString();
0:   }
1: 
0:   static String getStringFromStrings (String[] strings)
0:   {
0:     if (strings == null) return "{}";
0:     StringBuffer stringBuffer = new StringBuffer ();
0:     stringBuffer.append ("{ ");
0:     for (int i=0; i < strings.length; i++) {
0:       stringBuffer.append (strings[i]);
0:       if (i != strings.length - 1) stringBuffer.append (", ");
0:     }
0:     stringBuffer.append (" }");
0:     return stringBuffer.toString();
0:   }
1: 
0:   static public int computeBigDecimalPrecision (java.math.BigDecimal decimal)
0:   {
0:     byte[] bBytes = decimal.unscaledValue().abs().toByteArray();
1: 
0:     if (byteArrayCmp (bBytes, tenRadixArr[tenRadixArr.length-1]) >= 0)
0:       throw new java.lang.IllegalArgumentException ("Precision exceeds 31 digits!");
1: 
0:     int lo=0, hi=tenRadixArr.length-1, mi=(hi+lo)/2;
0:     do {
0:       int compare = byteArrayCmp (bBytes, tenRadixArr[mi]);
0:       if (compare == 1)
0:         lo = mi;
0:       else if (compare == -1)
0:         hi = mi;
0:       else
0:         break;
1: 
0:       mi = (hi+lo)/2;
0:     }
0:     while (mi != lo);
1: 
0:     return (mi+1);
0:   }
1: 
0:   // Used only by computeBigDecimalPrecision()
0:   private static int byteArrayCmp (byte[] arg1, byte[] arg2)
0:   {
0:     int arg1Offset = 0;
0:     int arg2Offset = 0;
0:     int length;
0:     if (arg1.length > arg2.length) {
0:       int diff = arg1.length-arg2.length;
0:       for (; arg1Offset<diff; arg1Offset++)
0:         if (arg1[arg1Offset] != 0) return 1;
0:       length = arg2.length;
0:     }
0:     else if (arg1.length < arg2.length) {
0:       int diff = arg2.length-arg1.length;
0:       for (; arg2Offset<diff; arg2Offset++)
0:         if (arg2[arg2Offset] != 0) return -1;
0:       length = arg1.length;
0:     }
0:     else {
0:       length = arg1.length;
0:     }
1: 
0:     for (int i=0; i<length; i++) {
0:       int b1 = arg1[arg1Offset+i] & 0xFF;
0:       int b2 = arg2[arg2Offset+i] & 0xFF;
0:       if (b1 > b2)
0:         return 1;
0:       else if (b1 < b2)
0:           return -1;
0:     }
0:     return 0;
0:   }
1: 
0:   // Used only by computeBigDecimalPrecision()
0:   // byte array of 1, 10, 100, 1000, 10000, ..., 10^31 for
0:   // fast computing the length a BigDecimal.
0:   private static byte[][] tenRadixArr = {
0:     { (byte)0x01 }, // 10^0
0:     { (byte)0x0A }, // 10^1
0:     { (byte)0x64 }, // 10^2
0:     { (byte)0x03, (byte)0xe8 }, // 10^3
0:     { (byte)0x27, (byte)0x10 }, // 10^4
0:     { (byte)0x01, (byte)0x86, (byte)0xa0 }, // 10^5
0:     { (byte)0x0f, (byte)0x42, (byte)0x40 }, // 10^6
0:     { (byte)0x98, (byte)0x96, (byte)0x80 }, // 10^7
0:     { (byte)0x05, (byte)0xf5, (byte)0xe1, (byte)0x00 }, // 10^8
0:     { (byte)0x3b, (byte)0x9a, (byte)0xca, (byte)0x00 }, // 10^9
0:     { (byte)0x02, (byte)0x54, (byte)0x0b, (byte)0xe4, (byte)0x00 }, // 10^10
0:     { (byte)0x17, (byte)0x48, (byte)0x76, (byte)0xe8, (byte)0x00 }, // 10^11
0:     { (byte)0xe8, (byte)0xd4, (byte)0xa5, (byte)0x10, (byte)0x00 }, // 10^12
0:     { (byte)0x09, (byte)0x18, (byte)0x4e, (byte)0x72, (byte)0xa0, (byte)0x00 }, // 10^13
0:     { (byte)0x5a, (byte)0xf3, (byte)0x10, (byte)0x7a, (byte)0x40, (byte)0x00 }, // 10^14
0:     { (byte)0x03, (byte)0x8d, (byte)0x7e, (byte)0xa4, (byte)0xc6, (byte)0x80, (byte)0x00 }, // 10^15
0:     { (byte)0x23, (byte)0x86, (byte)0xf2, (byte)0x6f, (byte)0xc1, (byte)0x00, (byte)0x00 }, // 10^16
0:     { (byte)0x01, (byte)0x63, (byte)0x45, (byte)0x78, (byte)0x5d, (byte)0x8a, (byte)0x00, (byte)0x00 }, // 10^17
0:     { (byte)0x0d, (byte)0xe0, (byte)0xb6, (byte)0xb3, (byte)0xa7, (byte)0x64, (byte)0x00, (byte)0x00 }, // 10^18
0:     { (byte)0x8a, (byte)0xc7, (byte)0x23, (byte)0x04, (byte)0x89, (byte)0xe8, (byte)0x00, (byte)0x00 }, // 10^19
0:     { (byte)0x05, (byte)0x6b, (byte)0xc7, (byte)0x5e, (byte)0x2d, (byte)0x63, (byte)0x10, (byte)0x00, (byte)0x00 }, // 10^20
0:     { (byte)0x36, (byte)0x35, (byte)0xc9, (byte)0xad, (byte)0xc5, (byte)0xde, (byte)0xa0, (byte)0x00, (byte)0x00 }, // 10^21
0:     { (byte)0x02, (byte)0x1e, (byte)0x19, (byte)0xe0, (byte)0xc9, (byte)0xba, (byte)0xb2, (byte)0x40, (byte)0x00, (byte)0x00 }, // 10^22
0:     { (byte)0x15, (byte)0x2d, (byte)0x02, (byte)0xc7, (byte)0xe1, (byte)0x4a, (byte)0xf6, (byte)0x80, (byte)0x00, (byte)0x00 }, // 10^23
0:     { (byte)0xd3, (byte)0xc2, (byte)0x1b, (byte)0xce, (byte)0xcc, (byte)0xed, (byte)0xa1, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^24
0:     { (byte)0x08, (byte)0x45, (byte)0x95, (byte)0x16, (byte)0x14, (byte)0x01, (byte)0x48, (byte)0x4a, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^25
0:     { (byte)0x52, (byte)0xb7, (byte)0xd2, (byte)0xdc, (byte)0xc8, (byte)0x0c, (byte)0xd2, (byte)0xe4, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^26
0:     { (byte)0x03, (byte)0x3b, (byte)0x2e, (byte)0x3c, (byte)0x9f, (byte)0xd0, (byte)0x80, (byte)0x3c, (byte)0xe8, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^27
0:     { (byte)0x20, (byte)0x4f, (byte)0xce, (byte)0x5e, (byte)0x3e, (byte)0x25, (byte)0x02, (byte)0x61, (byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^28
0:     { (byte)0x01, (byte)0x43, (byte)0x1e, (byte)0x0f, (byte)0xae, (byte)0x6d, (byte)0x72, (byte)0x17, (byte)0xca, (byte)0xa0, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^29
0:     { (byte)0x0c, (byte)0x9f, (byte)0x2c, (byte)0x9c, (byte)0xd0, (byte)0x46, (byte)0x74, (byte)0xed, (byte)0xea, (byte)0x40, (byte)0x00, (byte)0x00, (byte)0x00 }, // 10^30
0:     { (byte)0x7e, (byte)0x37, (byte)0xbe, (byte)0x20, (byte)0x22, (byte)0xc0, (byte)0x91, (byte)0x4b, (byte)0x26, (byte)0x80, (byte)0x00, (byte)0x00, (byte)0x00 }  // 10^31
0:   };
1: 
0:   // If the input string is short, pad it with blanks.
0:   // If the input string is long, truncate it.
0:   static public String padOrTruncate (String s, int fixedLength)
0:   {
0:     if (s.length() >= fixedLength) // we need to truncate
0:       return s.substring (0, fixedLength);
0:     else { // we need to pad
0:       StringBuffer buffer = new StringBuffer (s);
0:       for (int i = 0; i < fixedLength - s.length(); i++)
0:         buffer.append (" ");
0:       return buffer.toString();
0:     }
0:   }
1: 
0:   static public void checkForNegativePositiveSqlcard (Sqlca sqlca, Statement statement) throws SqlException
0:   {
0:     if (sqlca != null) {
0:       int sqlcode = sqlca.getSqlCode ();
0:       if (sqlcode < 0) {
0:         throw new SqlException (statement.agent_.logWriter_, sqlca);
0:       }
0:       else {
0:         if (sqlcode > 0)
0:           statement.accumulateWarning (new SqlWarning (statement.agent_.logWriter_, sqlca));
0:       }
0:     }
0:   }
1: 
0:   static public void checkForNegativePositiveSqlcard (Sqlca sqlca, ResultSet resultSet) throws SqlException
0:   {
0:     if (sqlca != null) {
0:       int sqlcode = sqlca.getSqlCode ();
0:       if (sqlcode < 0) {
0:         throw new SqlException (resultSet.agent_.logWriter_, sqlca);
0:       }
0:       else {
0:         if (sqlcode > 0)
0:           resultSet.accumulateWarning (new SqlWarning (resultSet.agent_.logWriter_, sqlca));
0:       }
0:     }
0:   }
1: 
0:   static public int getSqlcodeFromSqlca (Sqlca sqlca)
0:   {
0:     if (sqlca == null)
0:       return 0;
0:     return sqlca.getSqlCode();
0:   }
1: 
0:   static public int getUpdateCountFromSqlcard (Sqlca sqlca)
0:   {
0:     if (sqlca == null)
0:       return 0;
0:     else
0:       return sqlca.getUpdateCount();
0:   }
1: 
0:   public static int min (int i, int j)
0:   {
0:     return (i < j) ? i : j;
0:   }
1: 
0:   public static int max (int i, int j)
0:   {
0:     return (i < j) ? j : i;
0:   }
1: 
0:   // latestException is assumed to be non-null, accumulatedExceptions can be null
0:   public static SqlException accumulateSQLException (SqlException latestException,
0:                                                      SqlException accumulatedExceptions)
0:   {
0:     if (accumulatedExceptions == null)
0:       return latestException;
0:     else {
0:       accumulatedExceptions.setNextException (latestException);
0:       return accumulatedExceptions;
0:     }
0:   }
1: 
0:   // latestException is assumed to be non-null, accumulatedExceptions can be null
0:   public static SqlWarning accumulateSQLWarning (SqlWarning latestException,
0:                                                    SqlWarning accumulatedExceptions)
0:   {
0:     latestException.setNextException (accumulatedExceptions);
0:     return latestException;
0:   }
1: 
0:   // just a thought...
0:   static String getSQLTypeName (int sqlType)
0:   {
0:     switch (sqlType) {
0:     case java.sql.Types.BIGINT:
0:       return "BIGINT";
0:     case java.sql.Types.BINARY:
0:       return "BINARY";
0:     case java.sql.Types.BIT:
0:       return "BIT";
0:     case java.sql.Types.CHAR:
0:       return "CHAR";
0:     case java.sql.Types.DATE:
0:       return "DATE";
0:     case java.sql.Types.DECIMAL:
0:       return "DECIMAL";
0:     case java.sql.Types.DOUBLE:
0:       return "DOUBLE";
0:     case java.sql.Types.REAL:
0:       return "REAL";
0:     case java.sql.Types.INTEGER:
0:       return "INTEGER";
0:     case java.sql.Types.LONGVARBINARY:
0:       return "LONGVARBINARY";
0:     case java.sql.Types.LONGVARCHAR:
0:       return "LONGVARCHAR";
0:     case java.sql.Types.NULL:
0:       return "NULL";
0:     case java.sql.Types.NUMERIC:
0:       return "NUMERIC";
0:     case java.sql.Types.OTHER:
0:       return "OTHER";
0:     case java.sql.Types.FLOAT:
0:       return "FLOAT";
0:     case java.sql.Types.SMALLINT:
0:       return "SMALLINT";
0:     case java.sql.Types.TIME:
0:       return "TIME";
0:     case java.sql.Types.TIMESTAMP:
0:       return "TIMESTAMP";
0:     case java.sql.Types.TINYINT:
0:       return "TINYINT";
0:     case java.sql.Types.VARBINARY:
0:       return "VARBINARY";
0:     case java.sql.Types.VARCHAR:
0:       return "VARCHAR";
0:     default:
0:       return null;
0:     }
0:   }
1: 
0:   public static boolean isSqlTypeNullable (int sqlType)
0:   {
0:     return (sqlType | 0x01) == sqlType;
0:   }
1: 
0:   public static int getNonNullableSqlType (int sqlType)
0:   {
0:     return sqlType & ~1;
0:   }
0: }
============================================================================