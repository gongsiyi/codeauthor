1:bbc927c: /*
1:bbc927c: 
1:bbc927c:    Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
1:06dbbcf: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:bbc927c: 
1:bbc927c:       http://www.apache.org/licenses/LICENSE-2.0
1:bbc927c: 
1:bbc927c:    Unless required by applicable law or agreed to in writing, software
1:bbc927c:    distributed under the License is distributed on an "AS IS" BASIS,
1:bbc927c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bbc927c:    See the License for the specific language governing permissions and
1:bbc927c:    limitations under the License.
1:bbc927c: 
1:bbc927c:  */
1:bbc927c: 
1:bbc927c: package org.apache.derbyTesting.functionTests.tests.store;
1:bbc927c: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:bbc927c: 
1:06dbbcf: import java.sql.CallableStatement;
1:bbc927c: import java.sql.Connection;
1:bbc927c: import java.sql.PreparedStatement;
1:06dbbcf: import java.sql.ResultSet;
1:bbc927c: import java.sql.SQLException;
1:bbc927c: import java.sql.Statement;
1:bbc927c: 
1:bbc927c: import org.apache.derby.tools.ij;
1:bbc927c: 
1:bbc927c: 
1:bbc927c: public class OnlineCompressTest extends BaseTest
1:bbc927c: {
1:e3647c1:     boolean verbose = false;
1:bbc927c: 
1:dcd9a8e:     public OnlineCompressTest()
1:bbc927c:     {
2:bbc927c:     }
1:bbc927c: 
1:b8ddf44:     /**
1:06dbbcf:      * call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE() system procedure.
1:b8ddf44:      * <p>
1:06dbbcf:      * Utility test function to call the system procedure.
1:44fe060:      *
1:06dbbcf:      **/
1:bd54198:     protected void callCompress(
1:06dbbcf:     Connection  conn,
2:06dbbcf:     String      schemaName,
1:965be70:     String      tableName,
1:06dbbcf:     boolean     purgeRows,
1:06dbbcf:     boolean     defragmentRows,
1:965be70:     boolean     truncateEnd,
1:965be70:     boolean     commit_operation)
1:06dbbcf:         throws SQLException
1:06dbbcf:     {
1:06dbbcf:         CallableStatement cstmt = 
1:06dbbcf:             conn.prepareCall(
1:06dbbcf:                 "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1:06dbbcf:         cstmt.setString(1, schemaName);
1:06dbbcf:         cstmt.setString(2, tableName);
1:06dbbcf:         cstmt.setInt   (3, purgeRows      ? 1 : 0);
1:06dbbcf:         cstmt.setInt   (4, defragmentRows ? 1 : 0);
1:06dbbcf:         cstmt.setInt   (5, truncateEnd    ? 1 : 0);
1:06dbbcf: 
1:06dbbcf:         cstmt.execute();
1:06dbbcf: 
1:965be70:         if (commit_operation)
1:965be70:             conn.commit();
1:06dbbcf:     }
1:06dbbcf: 
1:44fe060:     /**
1:e3647c1:      * Create and load a table.
1:e3647c1:      * <p>
1:e3647c1:      * If create_table is set creates a test data table with indexes.
1:e3647c1:      * Loads num_rows into the table.  This table defaults to 32k page size.
1:e3647c1:      * This schema fits 25 rows per page
1:e3647c1:      * <p>
1:44fe060:      *
1:e3647c1:      *
1:e3647c1:      * @param conn          Connection to use for sql execution.
1:44fe060:      * @param create_table  If true, create new table - otherwise load into
1:44fe060:      *                      existing table.
1:44fe060:      * @param tblname       table to use.
1:e3647c1:      * @param num_rows      number of rows to add to the table.
1:e3647c1:      *
1:e3647c1: 	 * @exception  StandardException  Standard exception policy.
1:e3647c1:      **/
1:bd54198:     protected void createAndLoadTable(
1:06dbbcf:     Connection  conn,
1:f824190:     boolean     create_table,
1:f824190:     String      tblname,
1:bd54198:     int         num_rows,
1:bd54198:     int         start_value)
1:06dbbcf:         throws SQLException
1:06dbbcf:     {
1:f824190:         if (create_table)
1:06dbbcf:         {
1:bbc927c:             Statement s = conn.createStatement();
1:06dbbcf: 
1:bbc927c:             s.execute(
1:bbc927c:                 "create table " + tblname + 
1:06dbbcf:                     "(keycol int, indcol1 int, indcol2 int, indcol3 int, data1 varchar(2000), data2 varchar(2000))");
1:f824190:             s.close();
1:06dbbcf:         }
1:06dbbcf: 
1:bbc927c:         PreparedStatement insert_stmt = 
1:bbc927c:             conn.prepareStatement(
1:bbc927c:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?)");
1:06dbbcf: 
1:bbc927c:         char[]  data1_data = new char[500];
1:bbc927c:         char[]  data2_data = new char[500];
1:06dbbcf: 
1:bbc927c:         for (int i = 0; i < data1_data.length; i++)
1:06dbbcf:         {
1:bbc927c:             data1_data[i] = 'a';
1:bbc927c:             data2_data[i] = 'b';
1:06dbbcf:         }
1:bbc927c: 
1:bbc927c:         String  data1_str = new String(data1_data);
1:bbc927c:         String  data2_str = new String(data2_data);
1:bbc927c: 
1:04a2f12:         int row_count = 0;
1:04a2f12:         try
1:04a2f12:         {
1:bd54198:             for (int i = start_value; row_count < num_rows; row_count++, i++)
1:06dbbcf:             {
1:bd54198:                 insert_stmt.setInt(1, i);               // keycol
1:bd54198:                 insert_stmt.setInt(2, i * 10);          // indcol1
1:bd54198:                 insert_stmt.setInt(3, i * 100);         // indcol2
1:bd54198:                 insert_stmt.setInt(4, -i);              // indcol3
1:bd54198:                 insert_stmt.setString(5, data1_str);    // data1_data
1:bd54198:                 insert_stmt.setString(6, data2_str);    // data2_data
1:06dbbcf: 
1:04a2f12:                 insert_stmt.execute();
1:04a2f12:             }
1:04a2f12:         }
1:04a2f12:         catch (SQLException sqle)
1:04a2f12:         {
1:04a2f12:             System.out.println(
1:04a2f12:                 "Exception while trying to insert row number: " + row_count);
1:04a2f12:             throw sqle;
1:06dbbcf:         }
1:06dbbcf: 
1:06dbbcf:         if (create_table)
1:06dbbcf:         {
1:06dbbcf:             Statement s = conn.createStatement();
1:06dbbcf: 
1:06dbbcf:             s.execute(
1:06dbbcf:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:06dbbcf:                     "(keycol)");
1:06dbbcf:             s.execute(
1:06dbbcf:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:06dbbcf:                     "(indcol1)");
1:06dbbcf:             s.execute(
1:06dbbcf:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:06dbbcf:                     "(indcol2)");
1:06dbbcf:             s.execute(
1:06dbbcf:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:06dbbcf:                     "(indcol3)");
1:06dbbcf:             s.close();
1:06dbbcf:         }
1:06dbbcf: 
1:965be70:         conn.commit();
1:06dbbcf:     }
1:06dbbcf: 
1:44fe060:     /**
1:f824190:      * Create and load a table with large columns.
1:06dbbcf:      * <p>
1:f824190:      * If create_table is set creates a test data table with indexes.
1:f824190:      * Loads num_rows into the table.  This table defaults to 32k page size.
1:06dbbcf:      * <p>
1:e3647c1:      *
1:06dbbcf:      *
1:f824190:      * @param conn          Connection to use for sql execution.
1:e3647c1:      * @param create_table  If true, create new table - otherwise load into
1:e3647c1:      *                      existing table.
1:e3647c1:      * @param tblname       table to use.
1:f824190:      * @param num_rows      number of rows to add to the table.
1:f824190:      * @param start_value   Starting number from which num_rows are inserted
1:06dbbcf:      * @exception  StandardException  Standard exception policy.
1:06dbbcf:      **/
1:f824190:     protected void createAndLoadLargeTable(
1:06dbbcf:     Connection  conn,
1:06dbbcf:     boolean     create_table,
1:06dbbcf:     String      tblname,
1:f824190:     int         num_rows,
1:f824190:     int         start_value)
1:06dbbcf:         throws SQLException
1:06dbbcf:     {
1:06dbbcf:         if (create_table)
1:06dbbcf:         {
1:06dbbcf:             Statement s = conn.createStatement();
1:06dbbcf: 
1:f824190: 	    // Derby-606. Note that this table is currently only used by Test6.
1:f824190: 	    // Test6 needs data be to spread over 2 AllocExtents
1:f824190: 	    // and this table schema is chosen so that the required scenario
1:f824190: 	    // is exposed in minimum test execution time.
1:06dbbcf:             s.execute(
1:06dbbcf:                 "create table " + tblname + 
1:f824190:                     "(keycol int, indcol1 int, indcol2 int, data1 char(24), data2 char(24), data3 char(24)," +
1:f824190: 			    "data4 char(24), data5 char(24), data6 char(24), data7 char(24), data8 char(24)," + 
1:f824190: 			    "data9 char(24), data10 char(24), inddec1 decimal(8), indcol3 int, indcol4 int, data11 varchar(50))");
1:06dbbcf:             s.close();
1:06dbbcf:         }
1:06dbbcf: 
1:f824190:         PreparedStatement insert_stmt = 
1:f824190:             conn.prepareStatement(
1:f824190:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:06dbbcf: 
1:f824190:         char[]  data1_data = new char[24];
1:f824190:         char[]  data2_data = new char[24];
1:f824190:         char[]  data3_data = new char[24];
1:f824190:         char[]  data4_data = new char[24];
1:f824190:         char[]  data5_data = new char[24];
1:f824190:         char[]  data6_data = new char[24];
1:f824190:         char[]  data7_data = new char[24];
1:f824190:         char[]  data8_data = new char[24];
1:f824190:         char[]  data9_data = new char[24];
1:f824190:         char[]  data10_data = new char[24];
1:f824190:         char[]  data11_data = new char[50];
1:06dbbcf: 
1:f824190:         for (int i = 0; i < data1_data.length; i++) 
1:06dbbcf: 	{
1:f824190:             data1_data[i] = 'a';
1:f824190:             data2_data[i] = 'b';
1:f824190:             data3_data[i] = 'c';
1:f824190:             data4_data[i] = 'd';
1:f824190:             data5_data[i] = 'e';
1:f824190:             data6_data[i] = 'f';
1:f824190:             data7_data[i] = 'g';
1:f824190:             data8_data[i] = 'h';
1:f824190:             data9_data[i] = 'i';
1:f824190:             data10_data[i] = 'j';
1:06dbbcf: 	}
1:f824190: 	for( int i=0; i < data11_data.length; i++) 
1:06dbbcf: 	{
1:f824190: 	    data11_data[i] = 'z';
1:06dbbcf:         }
1:06dbbcf: 
1:f824190:         String  data1_str = new String(data1_data);
1:f824190:         String  data2_str = new String(data2_data);
1:f824190:         String  data3_str = new String(data3_data);
1:f824190:         String  data4_str = new String(data4_data);
1:f824190:         String  data5_str = new String(data5_data);
1:f824190:         String  data6_str = new String(data6_data);
1:f824190:         String  data7_str = new String(data7_data);
1:f824190:         String  data8_str = new String(data8_data);
1:f824190:         String  data9_str = new String(data9_data);
1:f824190:         String  data10_str = new String(data10_data);
1:f824190:         String  data11_str = new String(data11_data);
1:06dbbcf: 
1:f824190:         int row_count = 0;
1:f824190:         try
1:06dbbcf:         {
1:f824190:             for (int i = start_value; row_count < num_rows; row_count++, i++)
1:bbc927c:             {
1:bbc927c:                 insert_stmt.setInt(1, i);               // keycol
1:bbc927c:                 insert_stmt.setInt(2, i * 10);          // indcol1
1:bbc927c:                 insert_stmt.setInt(3, i * 100);         // indcol2
1:f824190:                 insert_stmt.setString(4, data1_str);    // data1_data
1:f824190:                 insert_stmt.setString(5, data2_str);    // data2_data
1:f824190:                 insert_stmt.setString(6, data3_str);    // data3_data
1:f824190:                 insert_stmt.setString(7, data4_str);    // data4_data
1:f824190:                 insert_stmt.setString(8, data5_str);    // data5_data
1:f824190:                 insert_stmt.setString(9, data6_str);    // data6_data
1:f824190:                 insert_stmt.setString(10, data7_str);    // data7_data
1:f824190:                 insert_stmt.setString(11, data8_str);    // data8_data
1:f824190:                 insert_stmt.setString(12, data9_str);    // data9_data
1:f824190:                 insert_stmt.setString(13, data10_str);    // data10_data
1:f824190:                 insert_stmt.setInt(14, i * 20);          // indcol3
1:f824190:                 insert_stmt.setInt(15, i * 200);         // indcol4
1:f824190: 		insert_stmt.setInt(16, i * 50);
1:f824190:                 insert_stmt.setString(17, data11_str);    // data11_data
1:06dbbcf: 
1:06dbbcf:                 insert_stmt.execute();
1:06dbbcf:             }
1:06dbbcf:         }
1:f824190:         catch (SQLException sqle)
1:bbc927c:         {
2:06dbbcf:             System.out.println(
1:f824190:                 "Exception while trying to insert row number: " + row_count);
1:f824190:             throw sqle;
1:bbc927c:         }
1:06dbbcf: 
1:f824190:         if (create_table)
1:bbc927c:         {
2:f824190:             Statement s = conn.createStatement();
1:bbc927c: 
2:f824190:             s.execute(
1:f824190:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:f824190:                     "(keycol)");
1:f824190:             s.execute(
1:f824190:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:f824190:                     "(indcol1)");
1:f824190:             s.execute(
1:f824190:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:f824190:                     "(indcol2)");
1:f824190:             s.execute(
1:f824190:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:f824190:                     "(indcol3)");
1:f824190:             s.close();
1:bbc927c:         }
1:bbc927c: 
1:965be70:         conn.commit();
1:bbc927c:     }
1:bbc927c: 
1:e3647c1:     /**
1:44fe060:      * Create and load a table with long columns and long rows.
1:44fe060:      * <p>
1:44fe060:      * If create_table is set creates a test data table with indexes.
1:44fe060:      * Loads num_rows into the table.  This table defaults to 32k page size.
1:44fe060:      * <p>
1:b8ddf44:      * schema of table:
1:b8ddf44:      *     keycol   int, 
1:44fe060:      *     longcol1 clob(200k),
1:44fe060:      *     longrow1 varchar(10000),
1:44fe060:      *     longrow2 varchar(10000),
1:44fe060:      *     longrow3 varchar(10000),
1:44fe060:      *     longrow4 varchar(10000),
1:44fe060:      *     indcol1  int, 
1:44fe060:      *     indcol2  int, 
1:44fe060:      *     indcol3  int, 
1:44fe060:      *     data1    varchar(2000), 
1:44fe060:      *     data2    varchar(2000)
1:44fe060:      *     longrow5 varchar(10000),
1:44fe060:      *     longrow6 varchar(10000),
1:44fe060:      *     longrow7 varchar(10000),
1:44fe060:      *     longrow8 varchar(10000),
1:44fe060:      *     longcol2 clob(200k),
1:b8ddf44:      *
1:44fe060:      *
1:44fe060:      * @param conn          Connection to use for sql execution.
1:b8ddf44:      * @param create_table  If true, create new table - otherwise load into
1:b8ddf44:      *                      existing table.
1:b8ddf44:      * @param tblname       table to use.
1:44fe060:      * @param num_rows      number of rows to add to the table.
1:44fe060:      *
1:44fe060: 	 * @exception  StandardException  Standard exception policy.
1:44fe060:      **/
1:44fe060:     private void createAndLoadLongTable(
1:44fe060:     Connection  conn,
1:44fe060:     boolean     create_table,
1:44fe060:     String      tblname,
1:44fe060:     int         num_rows)
1:44fe060:         throws SQLException
1:44fe060:     {
1:44fe060:         if (create_table)
1:44fe060:         {
1:44fe060:             Statement s = conn.createStatement();
1:44fe060: 
1:44fe060:             s.execute(
1:44fe060:                 "create table " + tblname + 
1:44fe060:                 " (keycol   int, longcol1 clob(200k), longrow1 varchar(10000), longrow2 varchar(10000), longrow3 varchar(10000), longrow4 varchar(10000), indcol1  int, indcol2  int, indcol3  int, data1    varchar(2000), data2    varchar(2000), longrow5 varchar(10000), longrow6 varchar(10000), longrow7 varchar(10000), longrow8 varchar(10000), longcol2 clob(200k))");
1:44fe060:             s.close();
1:44fe060:         }
1:44fe060: 
1:44fe060:         PreparedStatement insert_stmt = 
1:44fe060:             conn.prepareStatement(
1:44fe060:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:44fe060: 
1:44fe060:         char[]  data1_data = new char[500];
1:44fe060:         char[]  data2_data = new char[500];
1:44fe060: 
1:44fe060:         for (int i = 0; i < data1_data.length; i++)
1:44fe060:         {
1:44fe060:             data1_data[i] = 'a';
1:44fe060:             data2_data[i] = 'b';
1:44fe060:         }
1:44fe060:         String  data1_str = new String(data1_data);
1:44fe060:         String  data2_str = new String(data2_data);
1:44fe060: 
1:44fe060:         // some data to force row to be bigger than a page, ie. long row
1:44fe060:         char[] data3_data = new char[10000];
1:44fe060:         char[] data4_data = new char[10000];
1:44fe060: 
1:44fe060:         for (int i = 0; i < data3_data.length; i++)
1:44fe060:         {
1:44fe060:             data3_data[i] = 'c';
1:44fe060:             data4_data[i] = 'd';
1:44fe060:         }
1:44fe060:         String  data3_str = new String(data3_data);
1:44fe060:         String  data4_str = new String(data4_data);
1:44fe060: 
1:44fe060:         // some data for the long columns
1:44fe060:         char[] data5_data = new char[200000];
1:44fe060:         char[] data6_data = new char[200000];
1:44fe060: 
1:44fe060:         for (int i = 0; i < data5_data.length; i++)
1:44fe060:         {
1:44fe060:             data5_data[i] = 'e';
1:44fe060:             data6_data[i] = 'f';
1:44fe060:         }
1:44fe060: 
1:44fe060:         String  data5_str = new String(data5_data);
1:44fe060:         String  data6_str = new String(data6_data);
1:44fe060: 
1:44fe060:         for (int i = 0; i < num_rows; i++)
1:44fe060:         {
1:44fe060:             insert_stmt.setInt(1, i);               // keycol
1:44fe060:             insert_stmt.setString(2, data5_str);    // longcol1
1:44fe060:             insert_stmt.setString(3, data3_str);    // longrow1
1:44fe060:             insert_stmt.setString(4, data3_str);    // longrow2
1:44fe060:             insert_stmt.setString(5, data3_str);    // longrow3
1:44fe060:             insert_stmt.setString(6, data3_str);    // longrow4
1:44fe060:             insert_stmt.setInt(7, i * 10);          // indcol1
1:44fe060:             insert_stmt.setInt(8, i * 100);         // indcol2
1:44fe060:             insert_stmt.setInt(9, -i);              // indcol3
1:44fe060:             insert_stmt.setString(10, data1_str);   // data1_data
1:44fe060:             insert_stmt.setString(11, data2_str);   // data2_data
1:44fe060:             insert_stmt.setString(12, data4_str);   // longrow5
1:44fe060:             insert_stmt.setString(13, data4_str);   // longrow6
1:44fe060:             insert_stmt.setString(14, data4_str);   // longrow7
1:44fe060:             insert_stmt.setString(15, data4_str);   // longrow8
1:44fe060:             insert_stmt.setString(16, data5_str);   // longcol2
1:44fe060: 
1:44fe060:             insert_stmt.execute();
1:44fe060:         }
1:44fe060: 
1:44fe060:         if (create_table)
1:44fe060:         {
1:44fe060:             Statement s = conn.createStatement();
1:44fe060: 
1:44fe060:             s.execute(
1:44fe060:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:44fe060:                     "(keycol)");
1:44fe060:             s.execute(
1:44fe060:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:44fe060:                     "(indcol1)");
1:44fe060:             s.execute(
1:44fe060:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:44fe060:                     "(indcol2)");
1:44fe060:             s.execute(
1:44fe060:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:44fe060:                     "(indcol3)");
1:44fe060:             s.close();
1:44fe060:         }
1:44fe060: 
1:44fe060:         conn.commit();
1:44fe060:     }
1:44fe060: 
1:06dbbcf:     private void log_wrong_count(
1:06dbbcf:     String  error_msg,
1:06dbbcf:     String  table_name,
1:06dbbcf:     int     num_rows,
1:06dbbcf:     int     expected_val,
1:06dbbcf:     int     actual_val,
1:06dbbcf:     int[]   before_info,
1:06dbbcf:     int[]   after_info)
1:06dbbcf:     {
1:06dbbcf:         System.out.println(error_msg);
1:06dbbcf:         System.out.println("ERROR: for " + num_rows + " row  test. Expected " + expected_val + ", but got " + actual_val );
1:965be70:         System.out.println("before_info:");
1:965be70:         System.out.println(
1:965be70:         "    IS_INDEX         =" + before_info[SPACE_INFO_IS_INDEX]     + 
1:965be70:         "\n    NUM_ALLOC        =" + before_info[SPACE_INFO_NUM_ALLOC]    +
1:965be70:         "\n    NUM_FREE         =" + before_info[SPACE_INFO_NUM_FREE]     +
1:b8ddf44:         "\n    NUM_UNFILLED     =" + before_info[SPACE_INFO_NUM_UNFILLED] +
1:965be70:         "\n    PAGE_SIZE        =" + before_info[SPACE_INFO_PAGE_SIZE]    +
1:965be70:         "\n    ESTIMSPACESAVING =" + before_info[SPACE_INFO_ESTIMSPACESAVING]);
1:965be70:         System.out.println("after_info:");
1:965be70:         System.out.println(
1:b8ddf44:         "    IS_INDEX         =" + after_info[SPACE_INFO_IS_INDEX]       + 
1:965be70:         "\n    NUM_ALLOC        =" + after_info[SPACE_INFO_NUM_ALLOC]    +
1:965be70:         "\n    NUM_FREE         =" + after_info[SPACE_INFO_NUM_FREE]     +
1:b8ddf44:         "\n    NUM_UNFILLED     =" + after_info[SPACE_INFO_NUM_UNFILLED] +
1:965be70:         "\n    PAGE_SIZE        =" + after_info[SPACE_INFO_PAGE_SIZE]    +
1:965be70:         "\n    ESTIMSPACESAVING =" + after_info[SPACE_INFO_ESTIMSPACESAVING]);
1:06dbbcf:     }
1:06dbbcf: 
1:06dbbcf: 
1:965be70:     private void deleteAllRows(
1:06dbbcf:     Connection  conn,
1:06dbbcf:     boolean     create_table,
1:44fe060:     boolean     long_table,
1:06dbbcf:     String      schemaName,
1:965be70:     String      table_name,
1:965be70:     int         num_rows) 
1:06dbbcf:         throws SQLException 
1:06dbbcf:     {
1:06dbbcf:         testProgress(
1:965be70:             "begin deleteAllRows," + num_rows + " row test, create = " + 
1:965be70:                 create_table + ".");
1:06dbbcf: 
1:06dbbcf: 
1:44fe060:         if (long_table)
1:44fe060:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:44fe060:         else
1:bd54198:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
1:06dbbcf: 
1:06dbbcf:         if (verbose)
1:06dbbcf:             testProgress("Calling compress.");
1:06dbbcf: 
1:06dbbcf:         // compress with no deletes should not affect size
1:965be70:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:965be70:         callCompress(conn, "APP", table_name, true, true, true, true);
1:965be70:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:06dbbcf: 
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:06dbbcf:         {
1:965be70:             log_wrong_count(
3:965be70:                 "Expected no alloc page change.", 
4:965be70:                 table_name, num_rows, 
3:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
3:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:06dbbcf:         }
1:06dbbcf: 
1:06dbbcf:         if (verbose)
1:06dbbcf:             testProgress("calling consistency checker.");
1:06dbbcf: 
1:06dbbcf:         if (!checkConsistency(conn, schemaName, table_name))
1:06dbbcf:         {
1:06dbbcf:             logError("conistency check failed.");
1:06dbbcf:         }
1:06dbbcf: 
1:06dbbcf:         testProgress("no delete case complete.");
1:06dbbcf: 
1:06dbbcf:         // delete all the rows.
1:965be70:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:965be70:         executeQuery(conn, "delete from " + table_name, true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:dc1acc4: 
1:06dbbcf:         if (verbose)
1:06dbbcf:             testProgress("deleted all rows, now calling compress.");
1:dc1acc4: 
1:965be70:         callCompress(conn, "APP", table_name, true, true, true, true);
1:965be70:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:dc1acc4: 
1:06dbbcf:         // An empty table has 2 pages, one allocation page and the 1st page
1:06dbbcf:         // which will have a system row in it.  The space vti only reports
1:06dbbcf:         // a count of the user pages so the count is 1.
1:06dbbcf:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:06dbbcf:         {
1:965be70:             log_wrong_count(
1:06dbbcf:                 "Expected all pages to be truncated.",
1:06dbbcf:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:06dbbcf:         }
1:06dbbcf: 
1:06dbbcf:         if (verbose)
1:06dbbcf:             testProgress("calling consistency checker.");
1:06dbbcf: 
1:06dbbcf:         if (!checkConsistency(conn, schemaName, table_name))
1:06dbbcf:         {
1:06dbbcf:             logError("conistency check failed.");
1:06dbbcf:         }
1:06dbbcf: 
1:06dbbcf:         testProgress("delete all rows case succeeded.");
1:965be70: 
1:f576b26:         conn.commit();
1:06dbbcf: 
1:965be70:         testProgress("end deleteAllRows," + num_rows + " row test.");
1:965be70:     }
1:965be70: 
1:04a2f12:     private void simpleDeleteAllRows(
1:04a2f12:     Connection  conn,
1:04a2f12:     boolean     create_table,
1:04a2f12:     boolean     long_table,
1:04a2f12:     String      schemaName,
1:04a2f12:     String      table_name,
1:04a2f12:     int         num_rows) 
1:04a2f12:         throws SQLException 
1:04a2f12:     {
1:04a2f12:         testProgress(
1:04a2f12:             "begin simpleDeleteAllRows," + num_rows + " row test, create = " + 
1:04a2f12:                 create_table + ".");
1:04a2f12: 
1:04a2f12: 
1:04a2f12:         if (long_table)
1:04a2f12:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:04a2f12:         else
1:bd54198:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
1:04a2f12: 
1:04a2f12:         if (verbose)
1:04a2f12:             testProgress("Calling compress.");
1:04a2f12: 
1:04a2f12:         // compress with no deletes should not affect size
1:04a2f12:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:04a2f12:         callCompress(conn, "APP", table_name, true, true, true, true);
1:04a2f12:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:04a2f12: 
1:04a2f12:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:04a2f12:         {
1:04a2f12:             log_wrong_count(
1:04a2f12:                 "Expected no alloc page change.", 
1:04a2f12:                 table_name, num_rows, 
1:04a2f12:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:04a2f12:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:04a2f12:                 ret_before, ret_after);
1:04a2f12:         }
1:04a2f12: 
1:04a2f12:         testProgress("no delete case complete.");
1:04a2f12: 
1:04a2f12:         // delete all the rows.
1:04a2f12:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:04a2f12:         executeQuery(conn, "delete from " + table_name, true);
1:04a2f12: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:04a2f12: 
1:04a2f12:         if (verbose)
1:04a2f12:             testProgress("deleted all rows, now calling compress.");
1:04a2f12: 
1:04a2f12:         callCompress(conn, "APP", table_name, true, true, true, true);
1:04a2f12:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:04a2f12: 
1:04a2f12:         // An empty table has 2 pages, one allocation page and the 1st page
1:04a2f12:         // which will have a system row in it.  The space vti only reports
1:04a2f12:         // a count of the user pages so the count is 1.
1:04a2f12:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:04a2f12:         {
1:04a2f12:             log_wrong_count(
1:04a2f12:                 "Expected all pages to be truncated.",
1:04a2f12:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:04a2f12:                 ret_before, ret_after);
1:04a2f12:         }
1:04a2f12: 
1:04a2f12:         testProgress("delete all rows case succeeded.");
1:04a2f12: 
1:04a2f12:         conn.commit();
1:965be70: 
1:04a2f12:         testProgress("end simple deleteAllRows," + num_rows + " row test.");
1:04a2f12:     }
1:04a2f12: 
1:965be70:     /**
1:965be70:      * Check/exercise purge pass phase.
1:965be70:      * <p>
1:965be70:      * Assumes that either test creates the table, or called on an empty
1:965be70:      * table with no committed deleted rows or free pages in the middle of
1:965be70:      * the table in it.
1:965be70:      * <p>
1:965be70:      *
1:965be70: 	 * @exception  StandardException  Standard exception policy.
1:965be70:      **/
1:965be70:     private void checkPurgePhase(
1:965be70:     Connection  conn,
1:965be70:     boolean     create_table,
1:44fe060:     boolean     long_table,
1:965be70:     String      schemaName,
1:965be70:     String      table_name,
1:965be70:     int         num_rows) 
1:965be70:         throws SQLException 
1:965be70:     {
1:965be70:         testProgress(
1:965be70:             "begin checkPurgePhase" + num_rows + " row test, create = " + 
1:965be70:                 create_table + ".");
1:965be70: 
1:44fe060:         if (long_table)
1:44fe060:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:44fe060:         else
1:bd54198:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
1:965be70: 
1:965be70:         // dump_table(conn, schemaName, table_name, false);
1:965be70: 
1:965be70:         // delete all the rows, but don't commit the delete
2:965be70:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, false);
1:965be70:         executeQuery(conn, "delete from " + table_name, false);
1:965be70: 
1:965be70: 
1:965be70:         // dump_table(conn, schemaName, table_name, false);
1:965be70: 
2:965be70:         // Purge pass on non-committed deleted rows should do nothing.  
1:965be70: 
1:965be70:         // System.out.println("lock info before compress call:\n " + get_lock_info(conn, true));
1:965be70: 
2:965be70:         // Calling compress with just the "purge" pass option, no commit called.
2:965be70:         callCompress(conn, "APP", table_name, true, false, false, false);
1:965be70: 
2:965be70:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1:965be70: 
1:965be70:         // expect no change in the number of allocated pages!
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no alloc page change(1).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
2:965be70:         // expect no change in the number of free pages, if there are there
2:965be70:         // is a problem with purge locking recognizing committed deleted rows.
4:965be70:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no free page change(1).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_FREE], 
1:965be70:                 ret_after[SPACE_INFO_NUM_FREE],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:965be70:         // Test that it is ok to call multiple purge passes in single xact.
1:965be70: 
1:965be70:         // Calling compress with just the "purge" pass option, no commit called.
1:965be70:         callCompress(conn, "APP", table_name, true, false, false, false);
2:965be70:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1:965be70: 
1:965be70:         // expect no change in the number of allocated pages!
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no alloc page change(2).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:965be70:         // expect no change in the number of free pages, if there are there
1:965be70:         // is a problem with purge locking recognizing committed deleted rows.
1:965be70:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no free page change(2).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_FREE], 
1:965be70:                 ret_after[SPACE_INFO_NUM_FREE],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:965be70:         // since table was just loaded a defragment pass also should
2:965be70:         // not find anything to do.
1:965be70:         
2:965be70:         // Calling compress with just the "defragment" option, no commit called.
1:965be70: 
1:965be70:         // currently the defragment option requires a table level lock in
1:965be70:         // the nested user transaction, which will conflict and cause a
1:965be70:         // lock timeout.
1:965be70: 
1:965be70:         try
1:965be70:         {
2:965be70:             callCompress(conn, "APP", table_name, false, true, false, false);
1:965be70:             
1:965be70:             logError("Defragment pass did not get a lock timeout.");
1:965be70:         }
1:965be70:         catch (SQLException sqle)
1:965be70:         {
1:965be70:             // ignore exception.
1:965be70:         }
1:965be70: 
1:965be70:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1:965be70: 
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:965be70:         {
1:965be70:             log_wrong_count(
2:965be70:                 "Expected no alloc page change(3).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:965be70:         {
1:965be70:             log_wrong_count(
2:965be70:                 "Expected no free page change(3).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_FREE], 
1:965be70:                 ret_after[SPACE_INFO_NUM_FREE],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:06dbbcf: 
1:965be70:         // make sure table is back to all deleted row state.  lock timeout
1:965be70:         // will abort transaction.
1:04a2f12: 
1:04a2f12:         // delete all rows and commit.
1:965be70:         executeQuery(conn, "delete from " + table_name, true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:04a2f12: 
1:04a2f12:         // compress all space and commit.
1:965be70:         callCompress(conn, "APP", table_name, true, true, true, true);
1:04a2f12: 
1:04a2f12:         // add back all rows and commit.
1:44fe060:         if (long_table)
1:44fe060:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:44fe060:         else
1:bd54198:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
1:965be70:         conn.commit();
1:04a2f12: 
1:04a2f12:         // delete all rows, and NO commit.
1:965be70:         executeQuery(conn, "delete from " + table_name, false);
1:965be70: 
1:965be70: 
1:965be70:         // Calling compress with just the truncate option, may change allocated
1:965be70:         // and free page count as they system may have preallocated pages to
1:965be70:         // the end of the file as part of the load.  The file can't shrink
1:965be70:         // any more than the free page count before the compress.
1:965be70: 
1:965be70:         // running the truncate pass only.  If it compresses anything it is
1:965be70:         // just the preallocated pages at end of the file.
1:965be70: 
1:965be70:         // currently the defragment option requires a table level lock in
1:965be70:         // the nested user transaction, which will conflict and cause a
1:965be70:         // lock timeout.
1:965be70: 
1:965be70: 
1:4a0b580:         ret_before = getSpaceInfo(conn, "APP", table_name, false);
1:965be70:         callCompress(conn, "APP", table_name, false, false, true, false);
1:965be70:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1:965be70: 
1:965be70:         // expect no change in the number of allocated pages!
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:965be70:         {
1:965be70:             log_wrong_count(
1:4a0b580:                 "Expected no alloc page change(4).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:4a0b580:         // The only space that truncate only pass can free are free pages 
1:4a0b580:         // located at end of file, so after free space can be anywhere from 
1:4a0b580:         // what it was before to 0 pages.
1:4a0b580:         if (ret_after[SPACE_INFO_NUM_FREE] > ret_before[SPACE_INFO_NUM_FREE])
1:965be70:         {
1:965be70:             log_wrong_count(
1:4a0b580:                 "Expected no increase in free pages(4).", 
1:965be70:                 table_name, num_rows, 
1:965be70:                 ret_before[SPACE_INFO_NUM_FREE], 
1:965be70:                 ret_after[SPACE_INFO_NUM_FREE],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:06dbbcf: 
1:965be70:         // now commit the deletes, run all phases and make sure empty table
1:965be70:         // results.
1:965be70:         conn.commit();
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:965be70: 
1:965be70:         // check the table.  Note that this will accumulate locks and
1:965be70:         // will commit the transaction.
1:965be70:         if (!checkConsistency(conn, schemaName, table_name))
1:965be70:         {
1:965be70:             logError("conistency check failed.");
1:965be70:         }
1:965be70: 
1:965be70:         // test running each phase in order.
1:965be70:         callCompress(conn, "APP", table_name, true,  false, false, false);
1:965be70:         callCompress(conn, "APP", table_name, false, true,  false, false);
1:965be70:         callCompress(conn, "APP", table_name, false, false, true , false);
1:965be70:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1:965be70: 
1:965be70:         // An empty table has 2 pages, one allocation page and the 1st page
1:965be70:         // which will have a system row in it.  The space vti only reports
1:965be70:         // a count of the user pages so the count is 1.
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected all pages to be truncated.",
1:965be70:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70:         if (ret_after[SPACE_INFO_NUM_FREE] != 0)
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no free page after all pages truncated.",
1:965be70:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:965be70: 
1:965be70:         if (verbose)
1:965be70:             testProgress("calling consistency checker.");
1:965be70: 
1:965be70:         if (!checkConsistency(conn, schemaName, table_name))
1:965be70:         {
1:965be70:             logError("conistency check failed.");
1:965be70:         }
1:965be70: 
1:965be70:         testProgress("end checkPurgePhase" + num_rows + " row test.");
1:06dbbcf:     }
1:06dbbcf: 
1:06dbbcf:     /**
1:44fe060:      * Test 1 - various # page tests, regular row/columns
1:06dbbcf:      * <p>
1:965be70:      * perform a number of insert/delete/compress operations on a variety
1:965be70:      * of sized tables, use space allocation information to verify that
1:965be70:      * compression is happening and use consistency checker to verify that
1:965be70:      * tables and indexes are all valid following the operations.
1:965be70:      * <p>
1:06dbbcf:      * loop through testing interesting row count cases.  The cases are
1:965be70:      * 0    rows  - basic edge case, 2 page table: 1 alloc, 1 user page
1:965be70:      * 1    row   - another edge case, 2 page table: 1 alloc, 1 user page
1:965be70:      * 50   rows  - 3 page table case: 1 alloc, 1 user page, 1 user page freed
1:965be70:      * 4000 rows  - reasonable number of pages to test out, still 1 alloc page
1:06dbbcf:      *
1:965be70:      * note that row numbers greater than 4000 may lead to lock escalation
1:965be70:      * issues, if queries like "delete from x" are used to delete all the 
1:965be70:      * rows.
1:965be70:      *
1:06dbbcf:      * <p>
1:06dbbcf:      *
1:06dbbcf:      **/
1:965be70:     private void test1(
1:965be70:     Connection  conn,
1:965be70:     String      test_name,
1:965be70:     String      table_name)
1:06dbbcf:         throws SQLException 
1:06dbbcf:     {
1:04a2f12:         beginTest(conn, test_name);
1:04a2f12: 
1:965be70:         int[] test_cases = {0, 1, 50, 4000};
1:44fe060: 
1:06dbbcf:         for (int i = 0; i < test_cases.length; i++)
1:06dbbcf:         {
1:06dbbcf:             // first create new table and run the tests.
1:965be70:             deleteAllRows(
1:44fe060:                 conn, true, false, "APP", table_name, test_cases[i]);
1:44fe060: 
1:06dbbcf:             // now rerun tests on existing table, which had all rows deleted
1:06dbbcf:             // and truncated.
1:965be70:             deleteAllRows(
1:44fe060:                 conn, false, false, "APP", table_name, test_cases[i]);
1:965be70: 
1:965be70:             checkPurgePhase(
1:44fe060:                 conn, false, false, "APP", table_name, test_cases[i]);
1:965be70: 
1:965be70:             executeQuery(conn, "drop table " + table_name, true);
1:965be70:         }
1:965be70: 
1:965be70:         endTest(conn, test_name);
1:965be70:     }
1:965be70: 
1:f576b26:     /**
1:04a2f12:      * Test 2 - check repeated delete tests.
1:965be70:      * <p>
1:04a2f12:      * There was a timing error where test1 would usually pass, but 
1:04a2f12:      * repeated execution of this test found a timing problem with
1:04a2f12:      * allocation using an "unallocated" page and getting an I/O error.
1:06dbbcf:      *
1:965be70:      **/
1:965be70:     private void test2(
1:965be70:     Connection  conn,
1:965be70:     String      test_name,
1:44fe060:     String      table_name)
1:44fe060:         throws SQLException 
1:44fe060:     {
1:965be70:         beginTest(conn, test_name);
1:04a2f12: 
1:04a2f12:         int[] test_cases = {4000};
1:04a2f12: 
1:04a2f12:         for (int i = 0; i < test_cases.length; i++)
1:04a2f12:         {
1:04a2f12:             // first create new table and run the tests.
1:04a2f12:             simpleDeleteAllRows(
1:04a2f12:                 conn, true, false, "APP", table_name, test_cases[i]);
1:04a2f12: 
1:04a2f12:             for (int j = 0; j < 100; j++)
1:04a2f12:             {
1:04a2f12: 
1:04a2f12:                 // now rerun tests on existing table, which had all rows deleted
1:04a2f12:                 // and truncated.
1:04a2f12:                 deleteAllRows(
1:04a2f12:                     conn, false, false, "APP", table_name, test_cases[i]);
1:04a2f12:             }
1:04a2f12: 
1:04a2f12:             executeQuery(conn, "drop table " + table_name, true);
1:04a2f12:         }
1:04a2f12: 
1:04a2f12:         endTest(conn, test_name);
1:44fe060:     }
1:04a2f12: 
1:04a2f12: 
1:44fe060: 
1:04a2f12:     /**
1:44fe060:      * Test 3 - various # page tests, long row and long columns
1:44fe060:      * <p>
1:44fe060:      * perform a number of insert/delete/compress operations on a variety
1:44fe060:      * of sized tables, use space allocation information to verify that
1:44fe060:      * compression is happening and use consistency checker to verify that
1:44fe060:      * tables and indexes are all valid following the operations.
1:44fe060:      * <p>
1:44fe060:      * loop through testing interesting row count cases.  The cases are
1:44fe060:      * 0    rows  - basic edge case
1:44fe060:      * 1    row   - another edge case
1:44fe060:      * 100  rows  - ~50 meg table
1:44fe060:      * 4000 rows  - ~2 gig table
1:44fe060:      *
1:44fe060:      * note that row numbers greater than 4000 may lead to lock escalation
1:44fe060:      * issues, if queries like "delete from x" are used to delete all the 
1:44fe060:      * rows.
1:44fe060:      *
1:44fe060:      * <p>
1:44fe060:      *
1:44fe060:      **/
1:44fe060:     private void test3(
1:44fe060:     Connection  conn,
1:44fe060:     String      test_name,
1:44fe060:     String      table_name)
1:965be70:         throws SQLException 
1:965be70:     {
1:965be70:         beginTest(conn, test_name);
1:965be70: 
1:44fe060:         // note that 500 rows took 30 minutes on a ~1.5 ghz laptop
1:44fe060:         int[] test_cases = {1, 2, 50};
1:965be70: 
1:44fe060:         for (int i = 0; i < test_cases.length; i++)
1:965be70:         {
1:44fe060:             // first create new table and run the tests.
1:44fe060:             deleteAllRows(
1:44fe060:                 conn, true, true, "APP", table_name, test_cases[i]);
1:965be70: 
1:44fe060:             // now rerun tests on existing table, which had all rows deleted
1:44fe060:             // and truncated.
1:44fe060:             deleteAllRows(
1:44fe060:                 conn, false, true, "APP", table_name, test_cases[i]);
1:44fe060: 
1:44fe060:             checkPurgePhase(
1:44fe060:                 conn, false, true, "APP", table_name, test_cases[i]);
1:965be70: 
1:44fe060:             executeQuery(conn, "drop table " + table_name, true);
1:44fe060:         }
1:965be70: 
1:965be70:         endTest(conn, test_name);
1:965be70:     }
1:965be70: 
1:965be70:     /**
1:04a2f12:      * Test 4 - check repeated delete tests.
1:04a2f12:      * <p>
1:04a2f12:      * There was a timing error where test1 would usually pass, but 
1:04a2f12:      * repeated execution of this test found a timing problem with
1:04a2f12:      * allocation using an "unallocated" page and getting an I/O error.
1:04a2f12:      *
1:04a2f12:      **/
1:04a2f12:     private void test4(
1:04a2f12:     Connection  conn,
1:04a2f12:     String      test_name,
1:04a2f12:     String      table_name)
1:04a2f12:         throws SQLException 
1:04a2f12:     {
1:04a2f12:         beginTest(conn, test_name);
1:04a2f12: 
1:04a2f12:         int[] test_cases = {4000};
1:04a2f12: 
1:04a2f12:         for (int i = 0; i < test_cases.length; i++)
1:04a2f12:         {
1:04a2f12: 
1:04a2f12:             for (int j = 0; j < 100; j++)
1:04a2f12:             {
1:04a2f12:                 // first create new table and run the tests.
1:04a2f12:                 simpleDeleteAllRows(
1:04a2f12:                     conn, true, false, "APP", table_name, test_cases[i]);
1:04a2f12: 
1:04a2f12:                 // now rerun tests on existing table, which had all rows deleted
1:04a2f12:                 // and truncated.
1:04a2f12:                 deleteAllRows(
1:04a2f12:                     conn, false, false, "APP", table_name, test_cases[i]);
1:04a2f12: 
1:04a2f12:                 executeQuery(conn, "drop table " + table_name, true);
1:04a2f12:             }
1:965be70: 
1:04a2f12:         }
1:965be70: 
1:04a2f12:         endTest(conn, test_name);
1:04a2f12:     }
1:965be70: 
1:06dbbcf:     /**
1:b8ddf44:      * Create and load table for test5.
1:06dbbcf:      * <p>
1:44fe060:      * schema of table:
1:44fe060:      *     keycol   int, 
1:b8ddf44:      *     onehalf  int, 
1:b8ddf44:      *     onethird int, 
1:b8ddf44:      *     c        varchar(300)
1:b8ddf44:      *
1:b8ddf44:      * @param conn          Connection to use for sql execution.
1:df4020d:      * @param schemaName the schema to use.
1:df4020d:      * @param table_name the table to use.
1:b8ddf44:      * @param num_rows      number of rows to add to the table.
1:06dbbcf:      *
1:b8ddf44: 	 * @exception  StandardException  Standard exception policy.
1:b8ddf44:      **/
1:b8ddf44:     private void test5_load(
1:b8ddf44:     Connection  conn,
1:b8ddf44:     String      schemaName,
1:b8ddf44:     String      table_name,
1:b8ddf44:     int         num_rows)
1:b8ddf44:         throws SQLException
1:b8ddf44:     {
1:b8ddf44:         Statement s = conn.createStatement();
1:b8ddf44: 
1:b8ddf44:         s.execute(
1:b8ddf44:             "create table " + table_name + 
1:b8ddf44:             " (keycol integer primary key, onehalf integer, onethird integer, c varchar(300))");
1:b8ddf44:         s.close();
1:b8ddf44: 
1:b8ddf44:         PreparedStatement insert_stmt = 
1:b8ddf44:             conn.prepareStatement(
1:b8ddf44:                 "insert into " + table_name + " values(?, ?, ?, ?)");
1:b8ddf44: 
1:b8ddf44:         char[]  data1_data = new char[200];
1:b8ddf44: 
1:b8ddf44:         for (int i = 0; i < data1_data.length; i++)
1:b8ddf44:         {
1:b8ddf44:             data1_data[i] = 'b';
1:b8ddf44:         }
1:b8ddf44:         String  data1_str = new String(data1_data);
1:b8ddf44: 
1:b8ddf44:         for (int i = 0; i < num_rows; i++)
1:b8ddf44:         {
1:b8ddf44:             insert_stmt.setInt(1, i);               // keycol
1:b8ddf44:             insert_stmt.setInt(2, i % 2);           // onehalf:  0 or 1 
1:b8ddf44:             insert_stmt.setInt(3, i % 3);           // onethird: 0, 1, or 3
1:b8ddf44:             insert_stmt.setString(4, data1_str);    // c
1:b8ddf44:             insert_stmt.execute();
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         conn.commit();
1:b8ddf44:     }
1:b8ddf44:     
1:b8ddf44:     /**
1:b8ddf44:      * Execute test5, simple defragement test. 
1:b8ddf44:      * <p>
1:b8ddf44:      * o delete every other row, defragment
1:b8ddf44:      * o delete every third row, defragment
1:b8ddf44:      * o delete last 1000 rows, defragment
1:b8ddf44:      * o delete first 512 rows, defragment.
1:b8ddf44:      * <p>
1:b8ddf44:      * run test with at least 2000 rows.
1:b8ddf44:      **/
1:b8ddf44:     private void test5_run(
1:b8ddf44:     Connection  conn,
1:b8ddf44:     String      schemaName,
1:b8ddf44:     String      table_name,
1:b8ddf44:     int         num_rows)
1:b8ddf44:         throws SQLException
1:b8ddf44:     {
1:b8ddf44:         testProgress("begin test5: " + num_rows + " row test.");
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("Calling compress.");
1:b8ddf44: 
1:b8ddf44:         // compress with no deletes should not affect size
1:b8ddf44:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44:         callCompress(conn, "APP", table_name, true, true, true, true);
1:b8ddf44:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44: 
1:b8ddf44:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:b8ddf44:         {
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "Expected no alloc page change.", 
1:b8ddf44:                 table_name, num_rows, 
1:b8ddf44:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:b8ddf44:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("calling consistency checker.");
1:b8ddf44: 
1:b8ddf44:         if (!checkConsistency(conn, schemaName, table_name))
1:b8ddf44:         {
1:b8ddf44:             logError("conistency check failed.");
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         // DELETE EVERY OTHER ROW, COMPRESS, CHECK
1:b8ddf44:         //
1:b8ddf44:         //
1:b8ddf44: 
1:b8ddf44:         // delete all the rows every other row.
1:b8ddf44:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44:         executeQuery(
1:b8ddf44:             conn, "delete from " + table_name + " where onehalf = 0", true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("deleted every other row, now calling compress.");
1:b8ddf44: 
1:b8ddf44:         callCompress(conn, "APP", table_name, true, true, true, true);
1:b8ddf44:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44: 
1:b8ddf44:         if (total_pages(ret_after) != total_pages(ret_before))
1:b8ddf44:         {
1:b8ddf44:             // currently deleting every other row does not add free or unfilled
1:b8ddf44:             // pages to the container so defragment has nowhere to put the rows.
1:b8ddf44: 
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "Expected no truncation.",
1:b8ddf44:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("calling consistency checker.");
1:b8ddf44: 
1:b8ddf44:         if (!checkConsistency(conn, schemaName, table_name))
1:b8ddf44:         {
1:b8ddf44:             logError("conistency check failed.");
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         // DELETE EVERY THIRD ROW in original dataset, COMPRESS, CHECK
1:b8ddf44:         //
1:b8ddf44:         //
1:b8ddf44: 
1:b8ddf44:         // delete every third row
1:b8ddf44:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44:         executeQuery(
1:b8ddf44:             conn, "delete from " + table_name + " where onethird = 0", true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("deleted every third row, now calling compress.");
1:b8ddf44: 
1:b8ddf44:         callCompress(conn, "APP", table_name, true, true, true, true);
1:b8ddf44:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44: 
1:b8ddf44:         if (total_pages(ret_after) != total_pages(ret_before))
1:b8ddf44:         {
1:b8ddf44:             // currently deleting every third row does not create any free 
1:b8ddf44:             // or unfilled pages so defragment has no place to move rows.
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "Expected no truncation.",
1:b8ddf44:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("calling consistency checker.");
1:b8ddf44: 
1:b8ddf44:         if (!checkConsistency(conn, schemaName, table_name))
1:b8ddf44:         {
1:b8ddf44:             logError("conistency check failed.");
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         // DELETE top "half" of rows in original dataset, COMPRESS, CHECK
1:b8ddf44:         //
1:b8ddf44:         //
1:b8ddf44: 
1:b8ddf44:         // delete top "half" of the rows in the original dataset.
1:b8ddf44:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44:         executeQuery(
1:b8ddf44:             conn, "delete from " + table_name + " where keycol > " + 
1:b8ddf44:             (num_rows / 2), true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("deleted top half of the rows, now calling compress.");
1:b8ddf44: 
1:b8ddf44:         callCompress(conn, "APP", table_name, true, true, true, true);
1:b8ddf44:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44: 
1:b8ddf44:         // compress should be able to clean up about 1/2 of the pages.
1:b8ddf44:         if (verbose)
1:b8ddf44:         {
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "deleted top half keys, spaceinfo:",
1:b8ddf44:                 table_name, num_rows, 
1:b8ddf44:                 ((total_pages(ret_before) / 2) + 2),
1:b8ddf44:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (total_pages(ret_after) > ((total_pages(ret_before) / 2) + 2))
1:b8ddf44:         {
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "Expected at least " + 
1:b8ddf44:                 (ret_before[SPACE_INFO_NUM_ALLOC] / 2 + 2) +
1:b8ddf44:                 " pages to be truncated.",
1:b8ddf44:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("calling consistency checker.");
1:b8ddf44: 
1:b8ddf44:         if (!checkConsistency(conn, schemaName, table_name))
1:b8ddf44:         {
1:b8ddf44:             logError("conistency check failed.");
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         // DELETE 1st 500 rows in original dataset, COMPRESS, CHECK
1:b8ddf44:         //
1:b8ddf44:         //
1:b8ddf44: 
1:b8ddf44:         // delete keys less than 500
1:b8ddf44:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44:         executeQuery(
1:b8ddf44:             conn, "delete from " + table_name + " where keycol < 500 ", true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("deleted keys < 500, now calling compress.");
1:b8ddf44: 
1:b8ddf44:         callCompress(conn, "APP", table_name, true, true, true, true);
1:b8ddf44:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:         {
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "deleted bottom 500 keys, spaceinfo:",
1:b8ddf44:                 table_name, num_rows, 
1:b8ddf44:                 (total_pages(ret_before) - 33),
1:b8ddf44:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         // The bottom 500 keys, assuming 4k pages, takes about 33 pages
1:b8ddf44:         if (total_pages(ret_after) > (total_pages(ret_before) - 33))
1:b8ddf44:         {
1:b8ddf44:             log_wrong_count(
1:b8ddf44:                 "Expected at least 33 pages reclaimed.",
1:b8ddf44:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:b8ddf44:                 ret_before, ret_after);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         if (verbose)
1:b8ddf44:             testProgress("calling consistency checker.");
1:b8ddf44: 
1:b8ddf44:         if (!checkConsistency(conn, schemaName, table_name))
1:b8ddf44:         {
1:b8ddf44:             logError("conistency check failed.");
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44: 
1:b8ddf44:         conn.commit();
1:b8ddf44: 
1:b8ddf44:         testProgress("end test5: " + num_rows + " row test.");
1:b8ddf44:     }
1:b8ddf44: 
1:b8ddf44:     /**
1:b8ddf44:      * Cleanup after test5_run
1:b8ddf44:      **/
1:b8ddf44:     private void test5_cleanup(
1:b8ddf44:     Connection  conn,
1:b8ddf44:     String      schemaName,
1:b8ddf44:     String      table_name,
1:b8ddf44:     int         num_rows)
1:b8ddf44:         throws SQLException
1:b8ddf44:     {
1:b8ddf44:         executeQuery(conn, "drop table " + table_name, true);
1:b8ddf44:     }
1:b8ddf44: 
1:b8ddf44:     /**
1:b8ddf44:      * Test 5 - simple defragment test.
1:b8ddf44:      * <p>
1:b8ddf44:      * Create dataset and then:
1:b8ddf44:      * o delete every other row, defragment
1:b8ddf44:      * o delete every third row, defragment
1:b8ddf44:      * o delete last 1000 rows, defragment
1:b8ddf44:      * o delete first 512 rows, defragment.
1:b8ddf44:      * <p>
1:b8ddf44:      * run test with at least 2000 rows.
1:b8ddf44:      *
1:b8ddf44:      **/
1:b8ddf44:     private void test5(
1:b8ddf44:     Connection  conn,
1:b8ddf44:     String      test_name,
1:b8ddf44:     String      table_name)
1:b8ddf44:         throws SQLException 
1:b8ddf44:     {
1:b8ddf44:         beginTest(conn, test_name);
1:b8ddf44: 
1:b8ddf44:         int[] test_cases = {2000, 10000};
1:b8ddf44: 
1:b8ddf44:         for (int i = 0; i < test_cases.length; i++)
1:b8ddf44:         {
1:b8ddf44:             test5_load(conn, "APP", table_name, test_cases[i]);
1:b8ddf44:             test5_run(conn, "APP", table_name, test_cases[i]);
1:b8ddf44:             test5_cleanup(conn, "APP", table_name, test_cases[i]);
1:b8ddf44:         }
1:b8ddf44: 
1:b8ddf44:         endTest(conn, test_name);
1:b8ddf44:     }
1:b8ddf44: 
1:06dbbcf:     /**
1:f824190:      * Test 6 - Online compress test for table that spans more than 1 AllocExtent.
1:06dbbcf:      * <p>
1:f824190:      * Create dataset with Data spread over more than 1 AllcExtent and then:
1:f824190:      * delete enough rows so that the last AllocExtent is empty.
1:f824190:      * Try OnlineCompress with Purge, Defragment and Truncate
2:06dbbcf:      * <p>
1:f824190:      * run test with at least 103000 rows.
2:06dbbcf:      *
1:06dbbcf:      **/
1:f824190:     private void test6(
1:06dbbcf:     Connection  conn,
1:f824190:     String      test_name,
1:f824190:     String      table_name)
2:bbc927c:         throws SQLException 
1:965be70:     {
1:f824190:         beginTest(conn, test_name);
1:965be70: 
1:f824190:         int[] noRows = {104000};
1:06dbbcf: 
1:f824190:         for (int i = 0; i < noRows.length; i++)
1:965be70:         {
1:f824190:             // first create new table and run the tests.
1:f824190:             createAndLoadLargeTable(conn, true, table_name, noRows[i], 0);
1:06dbbcf: 
1:06dbbcf:         if (verbose)
1:f824190:             testProgress("Calling compress.");
1:06dbbcf: 
1:f824190:         // compress with no deletes should not affect size
1:f824190:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:f824190:         callCompress(conn, "APP", table_name, true, true, true, true);
1:f824190:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:06dbbcf: 
1:965be70:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:965be70:         {
1:965be70:             log_wrong_count(
1:965be70:                 "Expected no alloc page change.", 
1:f824190:                 table_name, noRows[i], 
1:965be70:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:965be70:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:06dbbcf: 
1:f824190:         testProgress("no delete case complete.");
1:bbc927c: 
1:f824190:         // delete all the rows.
1:f824190:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:f824190:         executeQuery(conn, "delete from " + table_name, true);
1:bbc927c: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:bbc927c: 
2:06dbbcf:         conn.commit();
1:bbc927c: 
2:f824190:         if (verbose)
1:f824190:             testProgress("deleted all rows, now calling compress.");
1:bbc927c: 
1:f824190:         callCompress(conn, "APP", table_name, true, true, true, true);
1:f824190:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1:bbc927c: 
1:f824190:         // An empty table has 2 pages, one allocation page and the 1st page
1:f824190:         // which will have a system row in it.  The space vti only reports
1:f824190:         // a count of the user pages so the count is 1.
1:f824190:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:bbc927c:         {
1:965be70:             log_wrong_count(
1:f824190:                 "Expected all pages to be truncated.",
1:f824190:                 table_name, noRows[i], 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:965be70:                 ret_before, ret_after);
1:965be70:         }
1:bbc927c: 
1:f824190:         testProgress("delete all rows case succeeded.");
1:bbc927c: 
1:f824190:         testProgress("end simple deleteAllRows," + noRows[i] + " row test.");
1:bbc927c: 
1:965be70:             executeQuery(conn, "drop table " + table_name, true);
1:06dbbcf:         }
1:bbc927c: 
1:f824190:         endTest(conn, test_name);
1:06dbbcf:     }
10:f824190: 
1:06dbbcf:     /**
1:f576b26:      * Test 7 - Online compress test for fetching more rows than buffer limit.
1:f576b26:      * <p>
1:f576b26:      * For smaller row size, if number of rows per page is more than max buffer
1:f576b26:      * size, then check if the remaining rows are also fetched for Compress 
1:f576b26:      * Operation
1:f576b26:      * <p>
1:f576b26:      **/
1:f576b26:     private void test7(
1:f576b26:     Connection  conn,
1:f576b26:     String      test_name,
1:f576b26:     String      table_name)
1:f576b26:         throws SQLException 
1:f576b26:     {
1:f576b26:         beginTest(conn, test_name);
1:f576b26: 
1:f576b26:         Statement s = conn.createStatement();
1:f576b26: 
1:f576b26:         s.execute("create table " + table_name + "(keycol int)");
1:f576b26:         s.close();
1:f576b26:         PreparedStatement insert_stmt = 
1:f576b26:             conn.prepareStatement("insert into " + table_name + " values(?)");
1:f576b26:         try
1:f576b26:         {
1:f576b26:             for (int i = 0; i < 1200; i++)
1:f576b26:             {
1:f576b26:                 insert_stmt.setInt(1, i);
1:f576b26: 
1:f576b26:                 insert_stmt.execute();
1:f576b26:             }
1:f576b26:         }
1:f576b26:         catch (SQLException sqle)
1:f576b26:         {
1:f576b26:             System.out.println(
1:f576b26:                 "Exception while trying to insert a row");
1:f576b26:             throw sqle;
1:f576b26:         }
1:f576b26:         conn.commit();
1:f576b26: 
1:f576b26:         // delete the front rows leaving the last 200.  Post commit may reclaim
1:f576b26:         // space on pages where all rows are deleted.  
1:f576b26:         executeQuery(
1:f576b26:             conn, "delete from " + table_name + " where keycol < 1000", true);
1:dc1acc4: 
1:dc1acc4:         callWaitForPostCommit(conn);
1:f576b26: 
1:f576b26:         conn.commit();
1:f576b26: 
1:f576b26:         if (verbose)
1:f576b26:             testProgress("deleted first 1000 rows, now calling compress.");
1:f576b26: 
1:f576b26:         callCompress(conn, "APP", table_name, true, true, true, true);
1:f576b26: 
1:f576b26:         testProgress("delete rows case succeeded.");
1:f576b26: 
1:f576b26:         executeQuery(conn, "drop table " + table_name, true);
1:f576b26: 
1:f576b26:         endTest(conn, test_name);
1:f576b26:     }
1:f824190: 
1:bbc927c:     public void testList(Connection conn)
1:bbc927c:         throws SQLException
1:bbc927c:     {
1:965be70:         test1(conn, "test1", "TEST1");
1:04a2f12:         // test2(conn, "test2", "TEST2");
1:44fe060:         test3(conn, "test3", "TEST3");
1:b8ddf44:         // test4(conn, "test4", "TEST4");
1:b8ddf44:         test5(conn, "test5", "TEST5");
1:f576b26:         test6(conn, "test6", "TEST6");
1:f576b26:         test7(conn, "test7", "TEST7");
1:bbc927c:     }
1:bbc927c: 
1:dc1acc4:     public static void callWaitForPostCommit(Connection conn) 
1:dc1acc4:             throws SQLException {
1:dc1acc4:         CallableStatement cstmt = 
1:dc1acc4:                 conn.prepareCall(
1:dc1acc4:                     "call wait_for_post_commit()");
1:dc1acc4:         cstmt.execute();
1:dc1acc4:         cstmt.close();
1:dc1acc4:     }
1:dc1acc4:     
1:bbc927c:     public static void main(String[] argv) 
1:bbc927c:         throws Throwable
1:bbc927c:     {
1:bbc927c:         OnlineCompressTest test = new OnlineCompressTest();
1:bbc927c: 
1:bbc927c:    		ij.getPropertyArg(argv); 
1:bbc927c:         Connection conn = ij.startJBMS();
1:dc1acc4:         
1:dc1acc4:         Statement stmt = conn.createStatement();
1:dc1acc4:         // Create a procedure to be called before checking on contents
1:dc1acc4:         // to ensure that the background worker thread has completed 
1:dc1acc4:         // all the post-commit work.
1:dc1acc4:         stmt.execute(
1:dc1acc4:             "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() " +
1:dc1acc4:             "LANGUAGE JAVA EXTERNAL NAME " +
1:dc1acc4:             "'org.apache.derbyTesting.functionTests.util." +
1:dc1acc4:             "T_Access.waitForPostCommitToFinish' " +
1:dc1acc4:             "PARAMETER STYLE JAVA");
1:bbc927c:         conn.setAutoCommit(false);
1:dc1acc4:         stmt.close();
1:bbc927c: 
1:bbc927c:         try
1:bbc927c:         {
1:bbc927c:             test.testList(conn);
1:bbc927c:         }
1:bbc927c:         catch (SQLException sqle)
1:bbc927c:         {
1:bbc927c: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
1:bbc927c:                 System.out, sqle);
1:bbc927c: 			sqle.printStackTrace(System.out);
1:bbc927c: 		}
1:bbc927c:     }
1:bbc927c: }
============================================================================
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:dc1acc4
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:         callWaitForPostCommit(conn);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static void callWaitForPostCommit(Connection conn) 
1:             throws SQLException {
1:         CallableStatement cstmt = 
1:                 conn.prepareCall(
1:                     "call wait_for_post_commit()");
1:         cstmt.execute();
1:         cstmt.close();
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         
1:         Statement stmt = conn.createStatement();
1:         // Create a procedure to be called before checking on contents
1:         // to ensure that the background worker thread has completed 
1:         // all the post-commit work.
1:         stmt.execute(
1:             "CREATE PROCEDURE WAIT_FOR_POST_COMMIT() " +
1:             "LANGUAGE JAVA EXTERNAL NAME " +
1:             "'org.apache.derbyTesting.functionTests.util." +
1:             "T_Access.waitForPostCommitToFinish' " +
1:             "PARAMETER STYLE JAVA");
1:         stmt.close();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6d14e04
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f576b26
/////////////////////////////////////////////////////////////////////////
1:         conn.commit();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test 7 - Online compress test for fetching more rows than buffer limit.
1:      * <p>
1:      * For smaller row size, if number of rows per page is more than max buffer
1:      * size, then check if the remaining rows are also fetched for Compress 
1:      * Operation
1:      * <p>
1:      **/
1:     private void test7(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
1:         throws SQLException 
1:     {
1:         beginTest(conn, test_name);
1: 
1:         Statement s = conn.createStatement();
1: 
1:         s.execute("create table " + table_name + "(keycol int)");
1:         s.close();
1:         PreparedStatement insert_stmt = 
1:             conn.prepareStatement("insert into " + table_name + " values(?)");
1:         try
1:         {
1:             for (int i = 0; i < 1200; i++)
1:             {
1:                 insert_stmt.setInt(1, i);
1: 
1:                 insert_stmt.execute();
1:             }
1:         }
1:         catch (SQLException sqle)
1:         {
1:             System.out.println(
1:                 "Exception while trying to insert a row");
1:             throw sqle;
1:         }
1:         conn.commit();
1: 
1:         // delete the front rows leaving the last 200.  Post commit may reclaim
1:         // space on pages where all rows are deleted.  
1:         executeQuery(
1:             conn, "delete from " + table_name + " where keycol < 1000", true);
1: 
1:         conn.commit();
1: 
1:         if (verbose)
1:             testProgress("deleted first 1000 rows, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1: 
1:         testProgress("delete rows case succeeded.");
1: 
1:         executeQuery(conn, "drop table " + table_name, true);
1: 
1:         endTest(conn, test_name);
1:     }
/////////////////////////////////////////////////////////////////////////
1:         test6(conn, "test6", "TEST6");
1:         test7(conn, "test7", "TEST7");
commit:b8ddf44
/////////////////////////////////////////////////////////////////////////
1:         "\n    NUM_UNFILLED     =" + before_info[SPACE_INFO_NUM_UNFILLED] +
1:         "    IS_INDEX         =" + after_info[SPACE_INFO_IS_INDEX]       + 
1:         "\n    NUM_UNFILLED     =" + after_info[SPACE_INFO_NUM_UNFILLED] +
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create and load table for test5.
1:      * <p>
1:      * schema of table:
1:      *     keycol   int, 
1:      *     onehalf  int, 
1:      *     onethird int, 
1:      *     c        varchar(300)
1:      *
1:      * @param conn          Connection to use for sql execution.
1:      * @param create_table  If true, create new table - otherwise load into
1:      *                      existing table.
1:      * @param tblname       table to use.
1:      * @param num_rows      number of rows to add to the table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void test5_load(
1:     Connection  conn,
1:     String      schemaName,
1:     String      table_name,
1:     int         num_rows)
1:         throws SQLException
1:     {
1:         Statement s = conn.createStatement();
1: 
1:         s.execute(
1:             "create table " + table_name + 
1:             " (keycol integer primary key, onehalf integer, onethird integer, c varchar(300))");
1:         s.close();
1: 
1:         PreparedStatement insert_stmt = 
1:             conn.prepareStatement(
1:                 "insert into " + table_name + " values(?, ?, ?, ?)");
1: 
1:         char[]  data1_data = new char[200];
1: 
1:         for (int i = 0; i < data1_data.length; i++)
1:         {
1:             data1_data[i] = 'b';
1:         }
1:         String  data1_str = new String(data1_data);
1: 
1:         for (int i = 0; i < num_rows; i++)
1:         {
1:             insert_stmt.setInt(1, i);               // keycol
1:             insert_stmt.setInt(2, i % 2);           // onehalf:  0 or 1 
1:             insert_stmt.setInt(3, i % 3);           // onethird: 0, 1, or 3
1:             insert_stmt.setString(4, data1_str);    // c
1:             insert_stmt.execute();
1:         }
1: 
1:         conn.commit();
1:     }
1:     
1:     /**
1:      * Execute test5, simple defragement test. 
1:      * <p>
1:      * o delete every other row, defragment
1:      * o delete every third row, defragment
1:      * o delete last 1000 rows, defragment
1:      * o delete first 512 rows, defragment.
1:      * <p>
1:      * run test with at least 2000 rows.
1:      **/
1:     private void test5_run(
1:     Connection  conn,
1:     String      schemaName,
1:     String      table_name,
1:     int         num_rows)
1:         throws SQLException
1:     {
1:         testProgress("begin test5: " + num_rows + " row test.");
1: 
1:         if (verbose)
1:             testProgress("Calling compress.");
1: 
1:         // compress with no deletes should not affect size
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         // DELETE EVERY OTHER ROW, COMPRESS, CHECK
1:         //
1:         //
1: 
1:         // delete all the rows every other row.
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(
1:             conn, "delete from " + table_name + " where onehalf = 0", true);
1: 
1:         if (verbose)
1:             testProgress("deleted every other row, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         if (total_pages(ret_after) != total_pages(ret_before))
1:         {
1:             // currently deleting every other row does not add free or unfilled
1:             // pages to the container so defragment has nowhere to put the rows.
1: 
1:             log_wrong_count(
1:                 "Expected no truncation.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         // DELETE EVERY THIRD ROW in original dataset, COMPRESS, CHECK
1:         //
1:         //
1: 
1:         // delete every third row
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(
1:             conn, "delete from " + table_name + " where onethird = 0", true);
1: 
1:         if (verbose)
1:             testProgress("deleted every third row, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         if (total_pages(ret_after) != total_pages(ret_before))
1:         {
1:             // currently deleting every third row does not create any free 
1:             // or unfilled pages so defragment has no place to move rows.
1:             log_wrong_count(
1:                 "Expected no truncation.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         // DELETE top "half" of rows in original dataset, COMPRESS, CHECK
1:         //
1:         //
1: 
1:         // delete top "half" of the rows in the original dataset.
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(
1:             conn, "delete from " + table_name + " where keycol > " + 
1:             (num_rows / 2), true);
1: 
1:         if (verbose)
1:             testProgress("deleted top half of the rows, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         // compress should be able to clean up about 1/2 of the pages.
1:         if (verbose)
1:         {
1:             log_wrong_count(
1:                 "deleted top half keys, spaceinfo:",
1:                 table_name, num_rows, 
1:                 ((total_pages(ret_before) / 2) + 2),
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (total_pages(ret_after) > ((total_pages(ret_before) / 2) + 2))
1:         {
1:             log_wrong_count(
1:                 "Expected at least " + 
1:                 (ret_before[SPACE_INFO_NUM_ALLOC] / 2 + 2) +
1:                 " pages to be truncated.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         // DELETE 1st 500 rows in original dataset, COMPRESS, CHECK
1:         //
1:         //
1: 
1:         // delete keys less than 500
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(
1:             conn, "delete from " + table_name + " where keycol < 500 ", true);
1: 
1:         if (verbose)
1:             testProgress("deleted keys < 500, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         if (verbose)
1:         {
1:             log_wrong_count(
1:                 "deleted bottom 500 keys, spaceinfo:",
1:                 table_name, num_rows, 
1:                 (total_pages(ret_before) - 33),
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // The bottom 500 keys, assuming 4k pages, takes about 33 pages
1:         if (total_pages(ret_after) > (total_pages(ret_before) - 33))
1:         {
1:             log_wrong_count(
1:                 "Expected at least 33 pages reclaimed.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1: 
1:         conn.commit();
1: 
1:         testProgress("end test5: " + num_rows + " row test.");
1:     }
1: 
1:     /**
1:      * Cleanup after test5_run
1:      **/
1:     private void test5_cleanup(
1:     Connection  conn,
1:     String      schemaName,
1:     String      table_name,
1:     int         num_rows)
1:         throws SQLException
1:     {
1:         executeQuery(conn, "drop table " + table_name, true);
1:     }
1: 
1:     /**
1:      * Test 5 - simple defragment test.
1:      * <p>
1:      * Create dataset and then:
1:      * o delete every other row, defragment
1:      * o delete every third row, defragment
1:      * o delete last 1000 rows, defragment
1:      * o delete first 512 rows, defragment.
1:      * <p>
1:      * run test with at least 2000 rows.
1:      *
1:      **/
1:     private void test5(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
1:         throws SQLException 
1:     {
1:         beginTest(conn, test_name);
1: 
1:         int[] test_cases = {2000, 10000};
1: 
1:         for (int i = 0; i < test_cases.length; i++)
1:         {
1:             test5_load(conn, "APP", table_name, test_cases[i]);
1:             test5_run(conn, "APP", table_name, test_cases[i]);
1:             test5_cleanup(conn, "APP", table_name, test_cases[i]);
1:         }
1: 
1:         endTest(conn, test_name);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // test4(conn, "test4", "TEST4");
1:         test5(conn, "test5", "TEST5");
commit:0ce6b77
/////////////////////////////////////////////////////////////////////////
commit:bd54198
/////////////////////////////////////////////////////////////////////////
1:     protected void callCompress(
/////////////////////////////////////////////////////////////////////////
1:     protected void createAndLoadTable(
1:     int         num_rows,
1:     int         start_value)
/////////////////////////////////////////////////////////////////////////
1:             for (int i = start_value; row_count < num_rows; row_count++, i++)
1:                 insert_stmt.setInt(1, i);               // keycol
1:                 insert_stmt.setInt(2, i * 10);          // indcol1
1:                 insert_stmt.setInt(3, i * 100);         // indcol2
1:                 insert_stmt.setInt(4, -i);              // indcol3
1:                 insert_stmt.setString(5, data1_str);    // data1_data
1:                 insert_stmt.setString(6, data2_str);    // data2_data
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
/////////////////////////////////////////////////////////////////////////
1:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
/////////////////////////////////////////////////////////////////////////
1:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
/////////////////////////////////////////////////////////////////////////
1:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
commit:04a2f12
/////////////////////////////////////////////////////////////////////////
1:         int row_count = 0;
1:         try
0:             for (;row_count < num_rows; row_count++)
1:             {
0:                 insert_stmt.setInt(1, row_count);               // keycol
0:                 insert_stmt.setInt(2, row_count * 10);          // indcol1
0:                 insert_stmt.setInt(3, row_count * 100);         // indcol2
0:                 insert_stmt.setInt(4, -row_count);              // indcol3
0:                 insert_stmt.setString(5, data1_str);            // data1_data
0:                 insert_stmt.setString(6, data2_str);            // data2_data
1:                 insert_stmt.execute();
1:             }
1:         }
1:         catch (SQLException sqle)
1:         {
1:             System.out.println(
1:                 "Exception while trying to insert row number: " + row_count);
1:             throw sqle;
/////////////////////////////////////////////////////////////////////////
1:     private void simpleDeleteAllRows(
1:     Connection  conn,
1:     boolean     create_table,
1:     boolean     long_table,
1:     String      schemaName,
1:     String      table_name,
1:     int         num_rows) 
1:         throws SQLException 
1:     {
1:         testProgress(
1:             "begin simpleDeleteAllRows," + num_rows + " row test, create = " + 
1:                 create_table + ".");
1: 
1: 
1:         if (long_table)
1:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows);
1: 
1:         if (verbose)
1:             testProgress("Calling compress.");
1: 
1:         // compress with no deletes should not affect size
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         testProgress("no delete case complete.");
1: 
1:         // delete all the rows.
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(conn, "delete from " + table_name, true);
1: 
1:         if (verbose)
1:             testProgress("deleted all rows, now calling compress.");
1: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
1: 
1:         // An empty table has 2 pages, one allocation page and the 1st page
1:         // which will have a system row in it.  The space vti only reports
1:         // a count of the user pages so the count is 1.
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:         {
1:             log_wrong_count(
1:                 "Expected all pages to be truncated.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         testProgress("delete all rows case succeeded.");
1: 
1:         conn.commit();
1: 
1:         testProgress("end simple deleteAllRows," + num_rows + " row test.");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         // delete all rows and commit.
1: 
1:         // compress all space and commit.
1: 
1:         // add back all rows and commit.
1: 
1:         // delete all rows, and NO commit.
/////////////////////////////////////////////////////////////////////////
1:      * Test 2 - check repeated delete tests.
1:      * There was a timing error where test1 would usually pass, but 
1:      * repeated execution of this test found a timing problem with
1:      * allocation using an "unallocated" page and getting an I/O error.
/////////////////////////////////////////////////////////////////////////
1:         beginTest(conn, test_name);
1: 
1:         int[] test_cases = {4000};
1: 
1:         for (int i = 0; i < test_cases.length; i++)
1:         {
1:             // first create new table and run the tests.
1:             simpleDeleteAllRows(
1:                 conn, true, false, "APP", table_name, test_cases[i]);
1: 
1:             for (int j = 0; j < 100; j++)
1:             {
1: 
1:                 // now rerun tests on existing table, which had all rows deleted
1:                 // and truncated.
1:                 deleteAllRows(
1:                     conn, false, false, "APP", table_name, test_cases[i]);
1:             }
1: 
1:             executeQuery(conn, "drop table " + table_name, true);
1:         }
1: 
1:         endTest(conn, test_name);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test 4 - check repeated delete tests.
1:      * <p>
1:      * There was a timing error where test1 would usually pass, but 
1:      * repeated execution of this test found a timing problem with
1:      * allocation using an "unallocated" page and getting an I/O error.
1:      *
1:      **/
1:     private void test4(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
1:         throws SQLException 
1:     {
1:         beginTest(conn, test_name);
1: 
1:         int[] test_cases = {4000};
1: 
1:         for (int i = 0; i < test_cases.length; i++)
1:         {
1: 
1:             for (int j = 0; j < 100; j++)
1:             {
1:                 // first create new table and run the tests.
1:                 simpleDeleteAllRows(
1:                     conn, true, false, "APP", table_name, test_cases[i]);
1: 
1:                 // now rerun tests on existing table, which had all rows deleted
1:                 // and truncated.
1:                 deleteAllRows(
1:                     conn, false, false, "APP", table_name, test_cases[i]);
1: 
1:                 executeQuery(conn, "drop table " + table_name, true);
1:             }
1: 
1:         }
1: 
1:         endTest(conn, test_name);
1:     }
1: 
1:         // test2(conn, "test2", "TEST2");
0:         // test4(conn, "test2", "TEST2");
commit:44fe060
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create and load a table with long columns and long rows.
1:      * <p>
1:      * If create_table is set creates a test data table with indexes.
1:      * Loads num_rows into the table.  This table defaults to 32k page size.
1:      * <p>
1:      * schema of table:
1:      *     keycol   int, 
1:      *     longcol1 clob(200k),
1:      *     longrow1 varchar(10000),
1:      *     longrow2 varchar(10000),
1:      *     longrow3 varchar(10000),
1:      *     longrow4 varchar(10000),
1:      *     indcol1  int, 
1:      *     indcol2  int, 
1:      *     indcol3  int, 
1:      *     data1    varchar(2000), 
1:      *     data2    varchar(2000)
1:      *     longrow5 varchar(10000),
1:      *     longrow6 varchar(10000),
1:      *     longrow7 varchar(10000),
1:      *     longrow8 varchar(10000),
1:      *     longcol2 clob(200k),
1:      *
1:      *
1:      * @param conn          Connection to use for sql execution.
1:      * @param create_table  If true, create new table - otherwise load into
1:      *                      existing table.
1:      * @param tblname       table to use.
1:      * @param num_rows      number of rows to add to the table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void createAndLoadLongTable(
1:     Connection  conn,
1:     boolean     create_table,
1:     String      tblname,
1:     int         num_rows)
1:         throws SQLException
1:     {
1:         if (create_table)
1:         {
1:             Statement s = conn.createStatement();
1: 
1:             s.execute(
1:                 "create table " + tblname + 
1:                 " (keycol   int, longcol1 clob(200k), longrow1 varchar(10000), longrow2 varchar(10000), longrow3 varchar(10000), longrow4 varchar(10000), indcol1  int, indcol2  int, indcol3  int, data1    varchar(2000), data2    varchar(2000), longrow5 varchar(10000), longrow6 varchar(10000), longrow7 varchar(10000), longrow8 varchar(10000), longcol2 clob(200k))");
1:             s.close();
1:         }
1: 
1:         PreparedStatement insert_stmt = 
1:             conn.prepareStatement(
1:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 
1:         char[]  data1_data = new char[500];
1:         char[]  data2_data = new char[500];
1: 
1:         for (int i = 0; i < data1_data.length; i++)
1:         {
1:             data1_data[i] = 'a';
1:             data2_data[i] = 'b';
1:         }
1:         String  data1_str = new String(data1_data);
1:         String  data2_str = new String(data2_data);
1: 
1:         // some data to force row to be bigger than a page, ie. long row
1:         char[] data3_data = new char[10000];
1:         char[] data4_data = new char[10000];
1: 
1:         for (int i = 0; i < data3_data.length; i++)
1:         {
1:             data3_data[i] = 'c';
1:             data4_data[i] = 'd';
1:         }
1:         String  data3_str = new String(data3_data);
1:         String  data4_str = new String(data4_data);
1: 
1:         // some data for the long columns
1:         char[] data5_data = new char[200000];
1:         char[] data6_data = new char[200000];
1: 
1:         for (int i = 0; i < data5_data.length; i++)
1:         {
1:             data5_data[i] = 'e';
1:             data6_data[i] = 'f';
1:         }
1: 
1:         String  data5_str = new String(data5_data);
1:         String  data6_str = new String(data6_data);
1: 
1:         for (int i = 0; i < num_rows; i++)
1:         {
1:             insert_stmt.setInt(1, i);               // keycol
1:             insert_stmt.setString(2, data5_str);    // longcol1
1:             insert_stmt.setString(3, data3_str);    // longrow1
1:             insert_stmt.setString(4, data3_str);    // longrow2
1:             insert_stmt.setString(5, data3_str);    // longrow3
1:             insert_stmt.setString(6, data3_str);    // longrow4
1:             insert_stmt.setInt(7, i * 10);          // indcol1
1:             insert_stmt.setInt(8, i * 100);         // indcol2
1:             insert_stmt.setInt(9, -i);              // indcol3
1:             insert_stmt.setString(10, data1_str);   // data1_data
1:             insert_stmt.setString(11, data2_str);   // data2_data
1:             insert_stmt.setString(12, data4_str);   // longrow5
1:             insert_stmt.setString(13, data4_str);   // longrow6
1:             insert_stmt.setString(14, data4_str);   // longrow7
1:             insert_stmt.setString(15, data4_str);   // longrow8
1:             insert_stmt.setString(16, data5_str);   // longcol2
1: 
1:             insert_stmt.execute();
1:         }
1: 
1:         if (create_table)
1:         {
1:             Statement s = conn.createStatement();
1: 
1:             s.execute(
1:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:                     "(keycol)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:                     "(indcol1)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:                     "(indcol2)");
1:             s.execute(
1:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:                     "(indcol3)");
1:             s.close();
1:         }
1: 
1:         conn.commit();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     boolean     long_table,
/////////////////////////////////////////////////////////////////////////
1:         if (long_table)
1:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows);
/////////////////////////////////////////////////////////////////////////
1:     boolean     long_table,
/////////////////////////////////////////////////////////////////////////
1:         if (long_table)
1:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows);
/////////////////////////////////////////////////////////////////////////
1:         if (long_table)
1:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
1:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows);
/////////////////////////////////////////////////////////////////////////
1:      * Test 1 - various # page tests, regular row/columns
/////////////////////////////////////////////////////////////////////////
1:                 conn, true, false, "APP", table_name, test_cases[i]);
1:                 conn, false, false, "APP", table_name, test_cases[i]);
1:                 conn, false, false, "APP", table_name, test_cases[i]);
/////////////////////////////////////////////////////////////////////////
0:      * Test 2 - check transaction roll backs
1:      *
1:     String      table_name)
1:         throws SQLException 
1:     {
1:     }
1: 
1: 
1: 
1:     /**
1:      * Test 3 - various # page tests, long row and long columns
1:      * <p>
1:      * perform a number of insert/delete/compress operations on a variety
1:      * of sized tables, use space allocation information to verify that
1:      * compression is happening and use consistency checker to verify that
1:      * tables and indexes are all valid following the operations.
1:      * <p>
1:      * loop through testing interesting row count cases.  The cases are
1:      * 0    rows  - basic edge case
1:      * 1    row   - another edge case
1:      * 100  rows  - ~50 meg table
1:      * 4000 rows  - ~2 gig table
1:      *
1:      * note that row numbers greater than 4000 may lead to lock escalation
1:      * issues, if queries like "delete from x" are used to delete all the 
1:      * rows.
1:      *
1:      * <p>
1:      *
1:      **/
1:     private void test3(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
1:         // note that 500 rows took 30 minutes on a ~1.5 ghz laptop
1:         int[] test_cases = {1, 2, 50};
1:         for (int i = 0; i < test_cases.length; i++)
1:             // first create new table and run the tests.
1:             deleteAllRows(
1:                 conn, true, true, "APP", table_name, test_cases[i]);
1:             // now rerun tests on existing table, which had all rows deleted
1:             // and truncated.
1:             deleteAllRows(
1:                 conn, false, true, "APP", table_name, test_cases[i]);
1:             checkPurgePhase(
1:                 conn, false, true, "APP", table_name, test_cases[i]);
1:             executeQuery(conn, "drop table " + table_name, true);
1:         }
1: 
1:         test3(conn, "test3", "TEST3");
commit:4a0b580
/////////////////////////////////////////////////////////////////////////
1:         ret_before = getSpaceInfo(conn, "APP", table_name, false);
/////////////////////////////////////////////////////////////////////////
1:                 "Expected no alloc page change(4).", 
1:         // The only space that truncate only pass can free are free pages 
1:         // located at end of file, so after free space can be anywhere from 
1:         // what it was before to 0 pages.
1:         if (ret_after[SPACE_INFO_NUM_FREE] > ret_before[SPACE_INFO_NUM_FREE])
1:                 "Expected no increase in free pages(4).", 
commit:dcd9a8e
/////////////////////////////////////////////////////////////////////////
1:     public OnlineCompressTest()
commit:965be70
/////////////////////////////////////////////////////////////////////////
1:     boolean     truncateEnd,
1:     boolean     commit_operation)
/////////////////////////////////////////////////////////////////////////
1:         if (commit_operation)
1:             conn.commit();
/////////////////////////////////////////////////////////////////////////
1:     String      tableName,
0:     boolean     commit_xact)
/////////////////////////////////////////////////////////////////////////
0:         if (commit_xact)
1:             conn.commit();
/////////////////////////////////////////////////////////////////////////
0:     String      stmt_str,
0:     boolean     commit_query)
0:         stmt.close();
0:         if (commit_query)
1:             conn.commit();
/////////////////////////////////////////////////////////////////////////
1:         System.out.println("before_info:");
1:         System.out.println(
1:         "    IS_INDEX         =" + before_info[SPACE_INFO_IS_INDEX]     + 
1:         "\n    NUM_ALLOC        =" + before_info[SPACE_INFO_NUM_ALLOC]    +
1:         "\n    NUM_FREE         =" + before_info[SPACE_INFO_NUM_FREE]     +
1:         "\n    PAGE_SIZE        =" + before_info[SPACE_INFO_PAGE_SIZE]    +
1:         "\n    ESTIMSPACESAVING =" + before_info[SPACE_INFO_ESTIMSPACESAVING]);
1:         System.out.println("after_info:");
1:         System.out.println(
0:         "    IS_INDEX         =" + after_info[SPACE_INFO_IS_INDEX]     + 
1:         "\n    NUM_ALLOC        =" + after_info[SPACE_INFO_NUM_ALLOC]    +
1:         "\n    NUM_FREE         =" + after_info[SPACE_INFO_NUM_FREE]     +
1:         "\n    PAGE_SIZE        =" + after_info[SPACE_INFO_PAGE_SIZE]    +
1:         "\n    ESTIMSPACESAVING =" + after_info[SPACE_INFO_ESTIMSPACESAVING]);
1:     private void deleteAllRows(
1:             "begin deleteAllRows," + num_rows + " row test, create = " + 
1:                 create_table + ".");
/////////////////////////////////////////////////////////////////////////
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
/////////////////////////////////////////////////////////////////////////
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(conn, "delete from " + table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
/////////////////////////////////////////////////////////////////////////
1:         testProgress("end deleteAllRows," + num_rows + " row test.");
1:     }
1: 
1:     /**
1:      * Check/exercise purge pass phase.
1:      * <p>
1:      * Assumes that either test creates the table, or called on an empty
1:      * table with no committed deleted rows or free pages in the middle of
1:      * the table in it.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void checkPurgePhase(
1:     Connection  conn,
1:     boolean     create_table,
1:     String      schemaName,
1:     String      table_name,
1:     int         num_rows) 
1:         throws SQLException 
1:     {
1:         testProgress(
1:             "begin checkPurgePhase" + num_rows + " row test, create = " + 
1:                 create_table + ".");
1: 
0:         createAndLoadTable(conn, create_table, table_name, num_rows);
1: 
1:         // dump_table(conn, schemaName, table_name, false);
1: 
1:         // delete all the rows, but don't commit the delete
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, false);
1:         executeQuery(conn, "delete from " + table_name, false);
1: 
1: 
1:         // dump_table(conn, schemaName, table_name, false);
1: 
1:         // Purge pass on non-committed deleted rows should do nothing.  
1: 
1:         // System.out.println("lock info before compress call:\n " + get_lock_info(conn, true));
1: 
1:         // Calling compress with just the "purge" pass option, no commit called.
1:         callCompress(conn, "APP", table_name, true, false, false, false);
1: 
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         // expect no change in the number of allocated pages!
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change(1).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // expect no change in the number of free pages, if there are there
1:         // is a problem with purge locking recognizing committed deleted rows.
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no free page change(1).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_FREE], 
1:                 ret_after[SPACE_INFO_NUM_FREE],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // Test that it is ok to call multiple purge passes in single xact.
1: 
1:         // Calling compress with just the "purge" pass option, no commit called.
1:         callCompress(conn, "APP", table_name, true, false, false, false);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         // expect no change in the number of allocated pages!
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change(2).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // expect no change in the number of free pages, if there are there
1:         // is a problem with purge locking recognizing committed deleted rows.
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no free page change(2).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_FREE], 
1:                 ret_after[SPACE_INFO_NUM_FREE],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // since table was just loaded a defragment pass also should
1:         // not find anything to do.
1:         
1:         // Calling compress with just the "defragment" option, no commit called.
1: 
1:         // currently the defragment option requires a table level lock in
1:         // the nested user transaction, which will conflict and cause a
1:         // lock timeout.
1: 
1:         try
1:         {
1:             callCompress(conn, "APP", table_name, false, true, false, false);
1:             
1:             logError("Defragment pass did not get a lock timeout.");
1:         }
1:         catch (SQLException sqle)
1:         {
1:             // ignore exception.
1:         }
1: 
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change(3).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no free page change(3).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_FREE], 
1:                 ret_after[SPACE_INFO_NUM_FREE],
1:                 ret_before, ret_after);
1:         }
1: 
1: 
1:         // make sure table is back to all deleted row state.  lock timeout
1:         // will abort transaction.
1:         executeQuery(conn, "delete from " + table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
0:         createAndLoadTable(conn, create_table, table_name, num_rows);
1:         conn.commit();
1:         executeQuery(conn, "delete from " + table_name, false);
1: 
1: 
1:         // Calling compress with just the truncate option, may change allocated
1:         // and free page count as they system may have preallocated pages to
1:         // the end of the file as part of the load.  The file can't shrink
1:         // any more than the free page count before the compress.
1: 
1:         // running the truncate pass only.  If it compresses anything it is
1:         // just the preallocated pages at end of the file.
1: 
1:         // currently the defragment option requires a table level lock in
1:         // the nested user transaction, which will conflict and cause a
1:         // lock timeout.
1: 
1: 
1:         callCompress(conn, "APP", table_name, false, false, true, false);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         // expect no change in the number of allocated pages!
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change(3).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // expect no change in the number of free pages, if there are there
1:         // is a problem with purge locking recognizing committed deleted rows.
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no free page change(3).", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_FREE], 
1:                 ret_after[SPACE_INFO_NUM_FREE],
1:                 ret_before, ret_after);
1:         }
1: 
1:         // now commit the deletes, run all phases and make sure empty table
1:         // results.
1:         conn.commit();
1: 
1:         // check the table.  Note that this will accumulate locks and
1:         // will commit the transaction.
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         // test running each phase in order.
1:         callCompress(conn, "APP", table_name, true,  false, false, false);
1:         callCompress(conn, "APP", table_name, false, true,  false, false);
1:         callCompress(conn, "APP", table_name, false, false, true , false);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         // An empty table has 2 pages, one allocation page and the 1st page
1:         // which will have a system row in it.  The space vti only reports
1:         // a count of the user pages so the count is 1.
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:         {
1:             log_wrong_count(
1:                 "Expected all pages to be truncated.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1:         if (ret_after[SPACE_INFO_NUM_FREE] != 0)
1:         {
1:             log_wrong_count(
1:                 "Expected no free page after all pages truncated.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         testProgress("end checkPurgePhase" + num_rows + " row test.");
1:      * perform a number of insert/delete/compress operations on a variety
1:      * of sized tables, use space allocation information to verify that
1:      * compression is happening and use consistency checker to verify that
1:      * tables and indexes are all valid following the operations.
1:      * <p>
1:      * 0    rows  - basic edge case, 2 page table: 1 alloc, 1 user page
1:      * 1    row   - another edge case, 2 page table: 1 alloc, 1 user page
1:      * 50   rows  - 3 page table case: 1 alloc, 1 user page, 1 user page freed
1:      * 4000 rows  - reasonable number of pages to test out, still 1 alloc page
1:      * note that row numbers greater than 4000 may lead to lock escalation
1:      * issues, if queries like "delete from x" are used to delete all the 
1:      * rows.
1:      *
1:     private void test1(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
1:         beginTest(conn, test_name);
1:         int[] test_cases = {0, 1, 50, 4000};
1:             deleteAllRows(
0:                 conn, true, "APP", table_name, test_cases[i]);
1:             deleteAllRows(
0:                 conn, false, "APP", table_name, test_cases[i]);
1: 
1:             checkPurgePhase(
0:                 conn, false, "APP", table_name, test_cases[i]);
1: 
1:             executeQuery(conn, "drop table " + table_name, true);
1:         endTest(conn, test_name);
1:     /**
0:      * Purge of uncommitted deletes should not do anything.
1:      * <p>
0:      * In the same transaction insert a number of rows, delete them all
0:      * and then run the purge operation.  The purge operation should find
0:      * the rows deleted but not do anything with them as the transaction
0:      * has not committed.
1:      **/
1:     private void test2(
1:     Connection  conn,
1:     String      test_name,
1:     String      table_name,
1:     int         num_rows)
1:         throws SQLException 
1:     {
1:         beginTest(conn, test_name);
1: 
0:         createAndLoadTable(conn, true, table_name, num_rows);
1: 
1:         // Purge pass on non-committed deleted rows should do nothing.  
1: 
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         // Calling compress with just the "purge" pass option, no commit called.
1:         callCompress(conn, "APP", table_name, true, false, false, false);
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
0:         // since table was just loaded there a defragment pass also should
1:         // not find anything to do.
1:         
1:         // Calling compress with just the "defragment" option, no commit called.
1:         callCompress(conn, "APP", table_name, false, true, false, false);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
1: 
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
1:         {
1:             log_wrong_count(
1:                 "Expected no alloc page change.", 
1:                 table_name, num_rows, 
1:                 ret_before[SPACE_INFO_NUM_ALLOC], 
1:                 ret_after[SPACE_INFO_NUM_ALLOC],
1:                 ret_before, ret_after);
1:         }
1: 
1:         executeQuery(conn, "drop table " + table_name, true);
1: 
1:         endTest(conn, test_name);
1:     }
1: 
1: 
1:         test1(conn, "test1", "TEST1");
0:         // test2(conn, "test2", "TEST2", 10000);
/////////////////////////////////////////////////////////////////////////
commit:e3647c1
/////////////////////////////////////////////////////////////////////////
1:     boolean verbose = false;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create and load a table.
1:      * <p>
1:      * If create_table is set creates a test data table with indexes.
1:      * Loads num_rows into the table.  This table defaults to 32k page size.
1:      * This schema fits 25 rows per page
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param conn          Connection to use for sql execution.
1:      * @param create_table  If true, create new table - otherwise load into
1:      *                      existing table.
1:      * @param tblname       table to use.
1:      * @param num_rows      number of rows to add to the table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
/////////////////////////////////////////////////////////////////////////
0:      * 50 rows     - 3 page table case: 1 alloc, 1 user page, 1 user page freed
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
0:     boolean verbose = true;
1:     /**
1:      * call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE() system procedure.
1:      * <p>
1:      * Utility test function to call the system procedure.
1:      *
1:      **/
0:     private void callCompress(
1:     Connection  conn,
1:     String      schemaName,
0:     String      tableName,
1:     boolean     purgeRows,
1:     boolean     defragmentRows,
0:     boolean     truncateEnd)
1:         throws SQLException
1:     {
1:         CallableStatement cstmt = 
1:             conn.prepareCall(
1:                 "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
1:         cstmt.setString(1, schemaName);
1:         cstmt.setString(2, tableName);
1:         cstmt.setInt   (3, purgeRows      ? 1 : 0);
1:         cstmt.setInt   (4, defragmentRows ? 1 : 0);
1:         cstmt.setInt   (5, truncateEnd    ? 1 : 0);
1: 
1:         cstmt.execute();
1: 
1:         conn.commit();
1:     }
1: 
1:     /**
0:      * call the space table vti.
1:      * <p>
0:      * Utility test function to call the space table vti to get information
0:      * about allocated and free pages.  Information is passed back in an
0:      * int array as follows:
0:      *   is_index                 = ret_info[0];
0:      *   num_alloc                = ret_info[1];
0:      *   num_free                 = ret_info[2];
0:      *   page_size                = ret_info[3];
0:      *   estimate_space_savings   = ret_info[4];
1:      * <p>
1:      *
0: 	 * @return the space information about the table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     private static final int SPACE_INFO_IS_INDEX        = 0;
0:     private static final int SPACE_INFO_NUM_ALLOC       = 1;
0:     private static final int SPACE_INFO_NUM_FREE        = 2;
0:     private static final int SPACE_INFO_PAGE_SIZE       = 3;
0:     private static final int SPACE_INFO_ESTIMSPACESAVING = 4;
0:     private int[] getSpaceInfo(
1:     Connection  conn,
1:     String      schemaName,
0:     String      tableName)
1: 		throws SQLException
1:     {
0:         String stmt_str = 
0:             "select conglomeratename, isindex, numallocatedpages, numfreepages, pagesize, estimspacesaving from new org.apache.derby.diag.SpaceTable('" +
0:             tableName + "') t where isindex = 0";
0:         PreparedStatement space_stmt = conn.prepareStatement(stmt_str);
0:         ResultSet rs = space_stmt.executeQuery();
1: 
0:         if (!rs.next())
1:         {
0:             if (SanityManager.DEBUG)
1:             {
0:                 SanityManager.THROWASSERT(
0:                     "No rows returned from space table query on table: " +
0:                     schemaName + "." + tableName);
1:             }
1:         }
1: 
0:         int[] ret_info = new int[5];
0:         String conglomerate_name        = rs.getString(1);
0:         for (int i = 0; i < 5; i++)
1:         {
0:             ret_info[i] = rs.getInt(i + 2);
1:         }
1: 
0:         if (rs.next())
1:         {
0:             if (SanityManager.DEBUG)
1:             {
0:                 SanityManager.THROWASSERT(
0:                     "More than one row returned from space query on table: " +
0:                     schemaName + "." + tableName);
1:             }
1:         }
1: 
1:         if (verbose)
1:         {
1:             System.out.println(
0:                 "Space information for " + schemaName + "." + tableName + ":");
0:             System.out.println("isindex = " + ret_info[SPACE_INFO_IS_INDEX]);
0:             System.out.println("num_alloc = " + ret_info[SPACE_INFO_NUM_ALLOC]);
0:             System.out.println("num_free = " + ret_info[SPACE_INFO_NUM_FREE]);
0:             System.out.println("page_size = " + ret_info[SPACE_INFO_PAGE_SIZE]);
1:             System.out.println(
0:                 "estimspacesaving = " + ret_info[SPACE_INFO_ESTIMSPACESAVING]);
1:         }
1: 
0:         rs.close();
1: 
1:         conn.commit();
1: 
0:         return(ret_info);
1:     }
1: 
1: 
1:     /**
0:      * Determine if inplace compress did it's job.
1:      * <p>
0:      * Figuring out if inplace compress in a fully reproducible way is hard
0:      * because derby has background threads which when given a chance do some
0:      * of the space reclamation work that this routine does, so the absolute
0:      * number of pages sometimes varies depending on machine/OS/JVM issues.
1:      * <p>
0:      * The approach here is to verify that at least N pages where reclaimed,
0:      * assuming other varience is an acceptable difference based on background
0:      * thread activity.  
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      **/
0:     private boolean checkBaseTableSpaceParameters(
1:     Connection  conn,
1:     String      schemaName,
0:     String      tableName,
0:     boolean     check_allocated_pages,
0:     int         max_allocated_pages,
0:     boolean     check_free_pages,
0:     int         max_free_pages)
1: 		throws SQLException
1:     {
0:         int[] ret_info = getSpaceInfo(conn, schemaName, tableName);
1: 
0:         int    is_index                 = ret_info[0];
0:         int    num_alloc                = ret_info[1];
0:         int    num_free                 = ret_info[2];
0:         int    page_size                = ret_info[3];
0:         int    estimate_space_savings   = ret_info[4];
1: 
0:         return(true);
1:     }
1: 
1: 
1:     boolean     create_table,
1:     String      tblname,
0:     int         num_rows)
1:         if (create_table)
1:         {
1:             Statement s = conn.createStatement();
1:             s.execute(
1:                 "create table " + tblname + 
1:                     "(keycol int, indcol1 int, indcol2 int, indcol3 int, data1 varchar(2000), data2 varchar(2000))");
1:             s.close();
1:         }
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < num_rows; i++)
/////////////////////////////////////////////////////////////////////////
1: 
1:             insert_stmt.execute();
1:         }
1: 
1:         if (create_table)
1:         {
1:             Statement s = conn.createStatement();
1: 
1:             s.execute(
1:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:                     "(keycol)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:                     "(indcol1)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:                     "(indcol2)");
1:             s.execute(
1:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:                     "(indcol3)");
1:             s.close();
0:     private void executeQuery(
1:     Connection  conn,
0:     String      stmt_str)
1:         throws SQLException
1:     {
0:         Statement stmt = conn.createStatement();
0:         stmt.executeUpdate(stmt_str);
0:         conn.commit();
1:     }
1: 
1:     private void log_wrong_count(
1:     String  error_msg,
1:     String  table_name,
1:     int     num_rows,
1:     int     expected_val,
1:     int     actual_val,
1:     int[]   before_info,
1:     int[]   after_info)
1:     {
1:         System.out.println(error_msg);
1:         System.out.println("ERROR: for " + num_rows + " row  test. Expected " + expected_val + ", but got " + actual_val );
1:     }
1: 
1: 
0:     private void row_count_based_tests(
1:     Connection  conn,
1:     boolean     create_table,
0:     boolean     drop_table,
0:     String      schemaName,
0:     String      table_name,
0:     int         num_rows) 
1:         throws SQLException 
1:     {
1:         testProgress(
0:             "begin " + num_rows + " row test, create = " + 
0:                 create_table + ", drop = " + drop_table + ".");
1: 
1: 
0:         createAndLoadTable(conn, create_table, table_name, num_rows);
1: 
1:         if (verbose)
1:             testProgress("Calling compress.");
1: 
1:         // compress with no deletes should not affect size
0:         int[] ret_before = getSpaceInfo(conn, "APP", table_name);
0:         callCompress(conn, "APP", table_name, true, true, true);
0:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name);
1: 
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
1:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change.", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         testProgress("no delete case complete.");
1: 
1:         // delete all the rows.
0:         ret_before = getSpaceInfo(conn, "APP", table_name);
0:         executeQuery(conn, "delete from " + table_name);
0:         conn.commit();
1: 
1:         if (verbose)
1:             testProgress("deleted all rows, now calling compress.");
1: 
0:         callCompress(conn, "APP", table_name, true, true, true);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name);
1: 
1:         // An empty table has 2 pages, one allocation page and the 1st page
1:         // which will have a system row in it.  The space vti only reports
1:         // a count of the user pages so the count is 1.
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
1:         {
0:             log_wrong_count(
1:                 "Expected all pages to be truncated.",
1:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
1:         }
1: 
1:         if (verbose)
1:             testProgress("calling consistency checker.");
1: 
1:         if (!checkConsistency(conn, schemaName, table_name))
1:         {
1:             logError("conistency check failed.");
1:         }
1: 
1:         testProgress("delete all rows case succeeded.");
1: 
1: 
0:         if (drop_table)
0:             executeQuery(conn, "drop table " + table_name);
1: 
0:         conn.commit();
1: 
0:         testProgress("end " + num_rows + " row test.");
1:     }
1: 
1:     /**
0:      * Test 1 alloc page test cases.
1:      * <p>
1:      * loop through testing interesting row count cases.  The cases are
0:      * 0  rows     - basic edge case, 2 page table: 1 alloc, 1 user page
0:      * 1  row      - another edge case, 2 page table: 1 alloc, 1 user page
0:      * TODO        - 3 page table case: 1 alloc, 1 user page, 1 user page freed
0:      * 10000 rows  - reasonable number of pages to test out, still 1 alloc page
1:      *
0:      * These tests can be run relatively quickly, not a lot of rows needed.
1:      * <p>
1:      *
1:      **/
0:         int[] test_cases = {0, 1, 50, 10000};
1:         for (int i = 0; i < test_cases.length; i++)
1:         {
1:             // first create new table and run the tests.
0:             row_count_based_tests(
0:                 conn, true, false, "APP", "TEST1", test_cases[i]);
1: 
1:             // now rerun tests on existing table, which had all rows deleted
1:             // and truncated.
0:             row_count_based_tests(
0:                 conn, false, true, "APP", "TEST1", test_cases[i]);
1:         }
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
0: import org.apache.derby.iapi.db.OnlineCompress;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import org.apache.derby.tools.ij;
1: 
1: 
1: public class OnlineCompressTest extends BaseTest
1: {
1: 
0:     OnlineCompressTest()
1:     {
1:     }
1: 
1: 
0:     private void createAndLoadTable(
0:     Connection  conn,
0:     String      tblname)
1:         throws SQLException
1:     {
1:         Statement s = conn.createStatement();
1: 
1:         s.execute(
1:             "create table " + tblname + 
0:                 "(keycol int, indcol1 int, indcol2 int, indcol3 int, data1 varchar(2000), data2 varchar(2000))");
1: 
1:         PreparedStatement insert_stmt = 
1:             conn.prepareStatement(
1:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?)");
1: 
1:         char[]  data1_data = new char[500];
1:         char[]  data2_data = new char[500];
1: 
1:         for (int i = 0; i < data1_data.length; i++)
1:         {
1:             data1_data[i] = 'a';
1:             data2_data[i] = 'b';
1:         }
1: 
1:         String  data1_str = new String(data1_data);
1:         String  data2_str = new String(data2_data);
1: 
0:         for (int i = 0; i < 10000; i++)
1:         {
1:             insert_stmt.setInt(1, i);               // keycol
1:             insert_stmt.setInt(2, i * 10);          // indcol1
1:             insert_stmt.setInt(3, i * 100);         // indcol2
0:             insert_stmt.setInt(4, -i);              // indcol3
0:             insert_stmt.setString(5, data1_str);   // data1_data
0:             insert_stmt.setString(6, data2_str);   // data2_data
1:         }
1: 
0:         conn.commit();
1:     }
1: 
0:     private void test1(Connection conn) 
1:         throws SQLException 
1:     {
0:         beginTest(conn, "test1");
1: 
0:         createAndLoadTable(conn, "test1");
1: 
0:         OnlineCompress.compressTable("APP", "TEST1", true, true, true);
1: 
0:         endTest(conn, "test1");
1:     }
1: 
1:     public void testList(Connection conn)
1:         throws SQLException
1:     {
0:         test1(conn);
1:     }
1: 
1:     public static void main(String[] argv) 
1:         throws Throwable
1:     {
1:         OnlineCompressTest test = new OnlineCompressTest();
1: 
1:    		ij.getPropertyArg(argv); 
1:         Connection conn = ij.startJBMS();
0:         System.out.println("conn 2 from ij.startJBMS() = " + conn);
1:         conn.setAutoCommit(false);
1: 
1:         try
1:         {
1:             test.testList(conn);
1:         }
1:         catch (SQLException sqle)
1:         {
1: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
1:                 System.out, sqle);
1: 			sqle.printStackTrace(System.out);
1: 		}
1:     }
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1:      * @param schemaName the schema to use.
1:      * @param table_name the table to use.
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:f824190
/////////////////////////////////////////////////////////////////////////
1:      * Create and load a table with large columns.
0:      * <p>
1:      * If create_table is set creates a test data table with indexes.
1:      * Loads num_rows into the table.  This table defaults to 32k page size.
0:      * <p>
0:      *
0:      *
1:      * @param conn          Connection to use for sql execution.
0:      * @param create_table  If true, create new table - otherwise load into
0:      *                      existing table.
0:      * @param tblname       table to use.
1:      * @param num_rows      number of rows to add to the table.
1:      * @param start_value   Starting number from which num_rows are inserted
0:      * @exception  StandardException  Standard exception policy.
0:      **/
1:     protected void createAndLoadLargeTable(
0:     Connection  conn,
1:     boolean     create_table,
1:     String      tblname,
1:     int         num_rows,
1:     int         start_value)
0:         throws SQLException
0:     {
1:         if (create_table)
0:         {
1:             Statement s = conn.createStatement();
1: 
1: 	    // Derby-606. Note that this table is currently only used by Test6.
1: 	    // Test6 needs data be to spread over 2 AllocExtents
1: 	    // and this table schema is chosen so that the required scenario
1: 	    // is exposed in minimum test execution time.
1:             s.execute(
0:                 "create table " + tblname + 
1:                     "(keycol int, indcol1 int, indcol2 int, data1 char(24), data2 char(24), data3 char(24)," +
1: 			    "data4 char(24), data5 char(24), data6 char(24), data7 char(24), data8 char(24)," + 
1: 			    "data9 char(24), data10 char(24), inddec1 decimal(8), indcol3 int, indcol4 int, data11 varchar(50))");
1:             s.close();
0:         }
1: 
1:         PreparedStatement insert_stmt = 
1:             conn.prepareStatement(
1:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 
1:         char[]  data1_data = new char[24];
1:         char[]  data2_data = new char[24];
1:         char[]  data3_data = new char[24];
1:         char[]  data4_data = new char[24];
1:         char[]  data5_data = new char[24];
1:         char[]  data6_data = new char[24];
1:         char[]  data7_data = new char[24];
1:         char[]  data8_data = new char[24];
1:         char[]  data9_data = new char[24];
1:         char[]  data10_data = new char[24];
1:         char[]  data11_data = new char[50];
1: 
1:         for (int i = 0; i < data1_data.length; i++) 
0: 	{
1:             data1_data[i] = 'a';
1:             data2_data[i] = 'b';
1:             data3_data[i] = 'c';
1:             data4_data[i] = 'd';
1:             data5_data[i] = 'e';
1:             data6_data[i] = 'f';
1:             data7_data[i] = 'g';
1:             data8_data[i] = 'h';
1:             data9_data[i] = 'i';
1:             data10_data[i] = 'j';
0: 	}
1: 	for( int i=0; i < data11_data.length; i++) 
0: 	{
1: 	    data11_data[i] = 'z';
0:         }
1: 
1:         String  data1_str = new String(data1_data);
1:         String  data2_str = new String(data2_data);
1:         String  data3_str = new String(data3_data);
1:         String  data4_str = new String(data4_data);
1:         String  data5_str = new String(data5_data);
1:         String  data6_str = new String(data6_data);
1:         String  data7_str = new String(data7_data);
1:         String  data8_str = new String(data8_data);
1:         String  data9_str = new String(data9_data);
1:         String  data10_str = new String(data10_data);
1:         String  data11_str = new String(data11_data);
1: 
1:         int row_count = 0;
1:         try
0:         {
1:             for (int i = start_value; row_count < num_rows; row_count++, i++)
0:             {
0:                 insert_stmt.setInt(1, i);               // keycol
0:                 insert_stmt.setInt(2, i * 10);          // indcol1
0:                 insert_stmt.setInt(3, i * 100);         // indcol2
1:                 insert_stmt.setString(4, data1_str);    // data1_data
1:                 insert_stmt.setString(5, data2_str);    // data2_data
1:                 insert_stmt.setString(6, data3_str);    // data3_data
1:                 insert_stmt.setString(7, data4_str);    // data4_data
1:                 insert_stmt.setString(8, data5_str);    // data5_data
1:                 insert_stmt.setString(9, data6_str);    // data6_data
1:                 insert_stmt.setString(10, data7_str);    // data7_data
1:                 insert_stmt.setString(11, data8_str);    // data8_data
1:                 insert_stmt.setString(12, data9_str);    // data9_data
1:                 insert_stmt.setString(13, data10_str);    // data10_data
1:                 insert_stmt.setInt(14, i * 20);          // indcol3
1:                 insert_stmt.setInt(15, i * 200);         // indcol4
1: 		insert_stmt.setInt(16, i * 50);
1:                 insert_stmt.setString(17, data11_str);    // data11_data
1: 
0:                 insert_stmt.execute();
0:             }
0:         }
1:         catch (SQLException sqle)
0:         {
0:             System.out.println(
1:                 "Exception while trying to insert row number: " + row_count);
1:             throw sqle;
0:         }
1: 
1:         if (create_table)
0:         {
1:             Statement s = conn.createStatement();
1: 
1:             s.execute(
1:                 "create index " + tblname + "_idx_keycol on " + tblname +
1:                     "(keycol)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
1:                     "(indcol1)");
1:             s.execute(
1:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
1:                     "(indcol2)");
1:             s.execute(
1:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
1:                     "(indcol3)");
1:             s.close();
0:         }
1: 
0:         conn.commit();
0:     }
1: 
0:     /**
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Test 6 - Online compress test for table that spans more than 1 AllocExtent.
0:      * <p>
1:      * Create dataset with Data spread over more than 1 AllcExtent and then:
1:      * delete enough rows so that the last AllocExtent is empty.
1:      * Try OnlineCompress with Purge, Defragment and Truncate
0:      * <p>
1:      * run test with at least 103000 rows.
0:      *
0:      **/
1:     private void test6(
0:     Connection  conn,
1:     String      test_name,
1:     String      table_name)
0:         throws SQLException 
0:     {
1:         beginTest(conn, test_name);
0: 
1:         int[] noRows = {104000};
0: 
1:         for (int i = 0; i < noRows.length; i++)
0:         {
1:             // first create new table and run the tests.
1:             createAndLoadLargeTable(conn, true, table_name, noRows[i], 0);
0: 
1:         if (verbose)
1:             testProgress("Calling compress.");
0: 
1:         // compress with no deletes should not affect size
1:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change.", 
1:                 table_name, noRows[i], 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
1:         testProgress("no delete case complete.");
0: 
1:         // delete all the rows.
1:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
1:         executeQuery(conn, "delete from " + table_name, true);
0: 	conn.commit();
0: 
1:         if (verbose)
1:             testProgress("deleted all rows, now calling compress.");
0: 
1:         callCompress(conn, "APP", table_name, true, true, true, true);
1:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
1:         // An empty table has 2 pages, one allocation page and the 1st page
1:         // which will have a system row in it.  The space vti only reports
1:         // a count of the user pages so the count is 1.
1:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
0:         {
0:             log_wrong_count(
1:                 "Expected all pages to be truncated.",
1:                 table_name, noRows[i], 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
1:         testProgress("delete all rows case succeeded.");
0: 
1:         testProgress("end simple deleteAllRows," + noRows[i] + " row test.");
0: 
0:             executeQuery(conn, "drop table " + table_name, true);
0:         }
0: 
1:         endTest(conn, test_name);
0:     }
/////////////////////////////////////////////////////////////////////////
0: 	test6(conn, "test6", "TEST6");
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: 
0: import org.apache.derby.iapi.db.OnlineCompress;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: 
0: import org.apache.derby.tools.ij;
0: 
0: 
0: public class OnlineCompressTest extends BaseTest
0: {
0:     boolean verbose = false;
0: 
0:     public OnlineCompressTest()
0:     {
0:     }
0: 
0:     /**
0:      * call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE() system procedure.
0:      * <p>
0:      * Utility test function to call the system procedure.
0:      *
0:      **/
0:     protected void callCompress(
0:     Connection  conn,
0:     String      schemaName,
0:     String      tableName,
0:     boolean     purgeRows,
0:     boolean     defragmentRows,
0:     boolean     truncateEnd,
0:     boolean     commit_operation)
0:         throws SQLException
0:     {
0:         CallableStatement cstmt = 
0:             conn.prepareCall(
0:                 "call SYSCS_UTIL.SYSCS_INPLACE_COMPRESS_TABLE(?, ?, ?, ?, ?)");
0:         cstmt.setString(1, schemaName);
0:         cstmt.setString(2, tableName);
0:         cstmt.setInt   (3, purgeRows      ? 1 : 0);
0:         cstmt.setInt   (4, defragmentRows ? 1 : 0);
0:         cstmt.setInt   (5, truncateEnd    ? 1 : 0);
0: 
0:         cstmt.execute();
0: 
0:         if (commit_operation)
0:             conn.commit();
0:     }
0: 
0:     /**
0:      * call the space table vti.
0:      * <p>
0:      * Utility test function to call the space table vti to get information
0:      * about allocated and free pages.  Information is passed back in an
0:      * int array as follows:
0:      *   is_index                 = ret_info[0];
0:      *   num_alloc                = ret_info[1];
0:      *   num_free                 = ret_info[2];
0:      *   page_size                = ret_info[3];
0:      *   estimate_space_savings   = ret_info[4];
0:      * <p>
0:      *
0: 	 * @return the space information about the table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private static final int SPACE_INFO_IS_INDEX        = 0;
0:     private static final int SPACE_INFO_NUM_ALLOC       = 1;
0:     private static final int SPACE_INFO_NUM_FREE        = 2;
0:     private static final int SPACE_INFO_PAGE_SIZE       = 3;
0:     private static final int SPACE_INFO_ESTIMSPACESAVING = 4;
0:     private int[] getSpaceInfo(
0:     Connection  conn,
0:     String      schemaName,
0:     String      tableName,
0:     boolean     commit_xact)
0: 		throws SQLException
0:     {
0:         String stmt_str = 
0:             "select conglomeratename, isindex, numallocatedpages, numfreepages, pagesize, estimspacesaving from new org.apache.derby.diag.SpaceTable('" +
0:             tableName + "') t where isindex = 0";
0:         PreparedStatement space_stmt = conn.prepareStatement(stmt_str);
0:         ResultSet rs = space_stmt.executeQuery();
0: 
0:         if (!rs.next())
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "No rows returned from space table query on table: " +
0:                     schemaName + "." + tableName);
0:             }
0:         }
0: 
0:         int[] ret_info = new int[5];
0:         String conglomerate_name        = rs.getString(1);
0:         for (int i = 0; i < 5; i++)
0:         {
0:             ret_info[i] = rs.getInt(i + 2);
0:         }
0: 
0:         if (rs.next())
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "More than one row returned from space query on table: " +
0:                     schemaName + "." + tableName);
0:             }
0:         }
0: 
0:         if (verbose)
0:         {
0:             System.out.println(
0:                 "Space information for " + schemaName + "." + tableName + ":");
0:             System.out.println("isindex = " + ret_info[SPACE_INFO_IS_INDEX]);
0:             System.out.println("num_alloc = " + ret_info[SPACE_INFO_NUM_ALLOC]);
0:             System.out.println("num_free = " + ret_info[SPACE_INFO_NUM_FREE]);
0:             System.out.println("page_size = " + ret_info[SPACE_INFO_PAGE_SIZE]);
0:             System.out.println(
0:                 "estimspacesaving = " + ret_info[SPACE_INFO_ESTIMSPACESAVING]);
0:         }
0: 
0:         rs.close();
0: 
0:         if (commit_xact)
0:             conn.commit();
0: 
0:         return(ret_info);
0:     }
0: 
0: 
0:     /**
0:      * Create and load a table.
0:      * <p>
0:      * If create_table is set creates a test data table with indexes.
0:      * Loads num_rows into the table.  This table defaults to 32k page size.
0:      * This schema fits 25 rows per page
0:      * <p>
0:      *
0:      *
0:      * @param conn          Connection to use for sql execution.
0:      * @param create_table  If true, create new table - otherwise load into
0:      *                      existing table.
0:      * @param tblname       table to use.
0:      * @param num_rows      number of rows to add to the table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void createAndLoadTable(
0:     Connection  conn,
0:     boolean     create_table,
0:     String      tblname,
0:     int         num_rows,
0:     int         start_value)
0:         throws SQLException
0:     {
0:         if (create_table)
0:         {
0:             Statement s = conn.createStatement();
0: 
0:             s.execute(
0:                 "create table " + tblname + 
0:                     "(keycol int, indcol1 int, indcol2 int, indcol3 int, data1 varchar(2000), data2 varchar(2000))");
0:             s.close();
0:         }
0: 
0:         PreparedStatement insert_stmt = 
0:             conn.prepareStatement(
0:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?)");
0: 
0:         char[]  data1_data = new char[500];
0:         char[]  data2_data = new char[500];
0: 
0:         for (int i = 0; i < data1_data.length; i++)
0:         {
0:             data1_data[i] = 'a';
0:             data2_data[i] = 'b';
0:         }
0: 
0:         String  data1_str = new String(data1_data);
0:         String  data2_str = new String(data2_data);
0: 
0:         int row_count = 0;
0:         try
0:         {
0:             for (int i = start_value; row_count < num_rows; row_count++, i++)
0:             {
0:                 insert_stmt.setInt(1, i);               // keycol
0:                 insert_stmt.setInt(2, i * 10);          // indcol1
0:                 insert_stmt.setInt(3, i * 100);         // indcol2
0:                 insert_stmt.setInt(4, -i);              // indcol3
0:                 insert_stmt.setString(5, data1_str);    // data1_data
0:                 insert_stmt.setString(6, data2_str);    // data2_data
0: 
0:                 insert_stmt.execute();
0:             }
0:         }
0:         catch (SQLException sqle)
0:         {
0:             System.out.println(
0:                 "Exception while trying to insert row number: " + row_count);
0:             throw sqle;
0:         }
0: 
0:         if (create_table)
0:         {
0:             Statement s = conn.createStatement();
0: 
0:             s.execute(
0:                 "create index " + tblname + "_idx_keycol on " + tblname +
0:                     "(keycol)");
0:             s.execute(
0:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
0:                     "(indcol1)");
0:             s.execute(
0:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
0:                     "(indcol2)");
0:             s.execute(
0:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
0:                     "(indcol3)");
0:             s.close();
0:         }
0: 
0:         conn.commit();
0:     }
0: 
0:     /**
0:      * Create and load a table with long columns and long rows.
0:      * <p>
0:      * If create_table is set creates a test data table with indexes.
0:      * Loads num_rows into the table.  This table defaults to 32k page size.
0:      * <p>
0:      * schema of table:
0:      *     keycol   int, 
0:      *     longcol1 clob(200k),
0:      *     longrow1 varchar(10000),
0:      *     longrow2 varchar(10000),
0:      *     longrow3 varchar(10000),
0:      *     longrow4 varchar(10000),
0:      *     indcol1  int, 
0:      *     indcol2  int, 
0:      *     indcol3  int, 
0:      *     data1    varchar(2000), 
0:      *     data2    varchar(2000)
0:      *     longrow5 varchar(10000),
0:      *     longrow6 varchar(10000),
0:      *     longrow7 varchar(10000),
0:      *     longrow8 varchar(10000),
0:      *     longcol2 clob(200k),
0:      *
0:      *
0:      * @param conn          Connection to use for sql execution.
0:      * @param create_table  If true, create new table - otherwise load into
0:      *                      existing table.
0:      * @param tblname       table to use.
0:      * @param num_rows      number of rows to add to the table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private void createAndLoadLongTable(
0:     Connection  conn,
0:     boolean     create_table,
0:     String      tblname,
0:     int         num_rows)
0:         throws SQLException
0:     {
0:         if (create_table)
0:         {
0:             Statement s = conn.createStatement();
0: 
0:             s.execute(
0:                 "create table " + tblname + 
0:                 " (keycol   int, longcol1 clob(200k), longrow1 varchar(10000), longrow2 varchar(10000), longrow3 varchar(10000), longrow4 varchar(10000), indcol1  int, indcol2  int, indcol3  int, data1    varchar(2000), data2    varchar(2000), longrow5 varchar(10000), longrow6 varchar(10000), longrow7 varchar(10000), longrow8 varchar(10000), longcol2 clob(200k))");
0:             s.close();
0:         }
0: 
0:         PreparedStatement insert_stmt = 
0:             conn.prepareStatement(
0:                 "insert into " + tblname + " values(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
0: 
0:         char[]  data1_data = new char[500];
0:         char[]  data2_data = new char[500];
0: 
0:         for (int i = 0; i < data1_data.length; i++)
0:         {
0:             data1_data[i] = 'a';
0:             data2_data[i] = 'b';
0:         }
0:         String  data1_str = new String(data1_data);
0:         String  data2_str = new String(data2_data);
0: 
0:         // some data to force row to be bigger than a page, ie. long row
0:         char[] data3_data = new char[10000];
0:         char[] data4_data = new char[10000];
0: 
0:         for (int i = 0; i < data3_data.length; i++)
0:         {
0:             data3_data[i] = 'c';
0:             data4_data[i] = 'd';
0:         }
0:         String  data3_str = new String(data3_data);
0:         String  data4_str = new String(data4_data);
0: 
0:         // some data for the long columns
0:         char[] data5_data = new char[200000];
0:         char[] data6_data = new char[200000];
0: 
0:         for (int i = 0; i < data5_data.length; i++)
0:         {
0:             data5_data[i] = 'e';
0:             data6_data[i] = 'f';
0:         }
0: 
0:         String  data5_str = new String(data5_data);
0:         String  data6_str = new String(data6_data);
0: 
0:         for (int i = 0; i < num_rows; i++)
0:         {
0:             insert_stmt.setInt(1, i);               // keycol
0:             insert_stmt.setString(2, data5_str);    // longcol1
0:             insert_stmt.setString(3, data3_str);    // longrow1
0:             insert_stmt.setString(4, data3_str);    // longrow2
0:             insert_stmt.setString(5, data3_str);    // longrow3
0:             insert_stmt.setString(6, data3_str);    // longrow4
0:             insert_stmt.setInt(7, i * 10);          // indcol1
0:             insert_stmt.setInt(8, i * 100);         // indcol2
0:             insert_stmt.setInt(9, -i);              // indcol3
0:             insert_stmt.setString(10, data1_str);   // data1_data
0:             insert_stmt.setString(11, data2_str);   // data2_data
0:             insert_stmt.setString(12, data4_str);   // longrow5
0:             insert_stmt.setString(13, data4_str);   // longrow6
0:             insert_stmt.setString(14, data4_str);   // longrow7
0:             insert_stmt.setString(15, data4_str);   // longrow8
0:             insert_stmt.setString(16, data5_str);   // longcol2
0: 
0:             insert_stmt.execute();
0:         }
0: 
0:         if (create_table)
0:         {
0:             Statement s = conn.createStatement();
0: 
0:             s.execute(
0:                 "create index " + tblname + "_idx_keycol on " + tblname +
0:                     "(keycol)");
0:             s.execute(
0:                 "create index " + tblname + "_idx_indcol1 on " + tblname +
0:                     "(indcol1)");
0:             s.execute(
0:                 "create index " + tblname + "_idx_indcol2 on " + tblname +
0:                     "(indcol2)");
0:             s.execute(
0:                 "create unique index " + tblname + "_idx_indcol3 on " + tblname +
0:                     "(indcol3)");
0:             s.close();
0:         }
0: 
0:         conn.commit();
0:     }
0: 
0:     private void log_wrong_count(
0:     String  error_msg,
0:     String  table_name,
0:     int     num_rows,
0:     int     expected_val,
0:     int     actual_val,
0:     int[]   before_info,
0:     int[]   after_info)
0:     {
0:         System.out.println(error_msg);
0:         System.out.println("ERROR: for " + num_rows + " row  test. Expected " + expected_val + ", but got " + actual_val );
0:         System.out.println("before_info:");
0:         System.out.println(
0:         "    IS_INDEX         =" + before_info[SPACE_INFO_IS_INDEX]     + 
0:         "\n    NUM_ALLOC        =" + before_info[SPACE_INFO_NUM_ALLOC]    +
0:         "\n    NUM_FREE         =" + before_info[SPACE_INFO_NUM_FREE]     +
0:         "\n    PAGE_SIZE        =" + before_info[SPACE_INFO_PAGE_SIZE]    +
0:         "\n    ESTIMSPACESAVING =" + before_info[SPACE_INFO_ESTIMSPACESAVING]);
0:         System.out.println("after_info:");
0:         System.out.println(
0:         "    IS_INDEX         =" + after_info[SPACE_INFO_IS_INDEX]     + 
0:         "\n    NUM_ALLOC        =" + after_info[SPACE_INFO_NUM_ALLOC]    +
0:         "\n    NUM_FREE         =" + after_info[SPACE_INFO_NUM_FREE]     +
0:         "\n    PAGE_SIZE        =" + after_info[SPACE_INFO_PAGE_SIZE]    +
0:         "\n    ESTIMSPACESAVING =" + after_info[SPACE_INFO_ESTIMSPACESAVING]);
0:     }
0: 
0: 
0:     private void deleteAllRows(
0:     Connection  conn,
0:     boolean     create_table,
0:     boolean     long_table,
0:     String      schemaName,
0:     String      table_name,
0:     int         num_rows) 
0:         throws SQLException 
0:     {
0:         testProgress(
0:             "begin deleteAllRows," + num_rows + " row test, create = " + 
0:                 create_table + ".");
0: 
0: 
0:         if (long_table)
0:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
0:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
0: 
0:         if (verbose)
0:             testProgress("Calling compress.");
0: 
0:         // compress with no deletes should not affect size
0:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
0:         callCompress(conn, "APP", table_name, true, true, true, true);
0:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change.", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         if (verbose)
0:             testProgress("calling consistency checker.");
0: 
0:         if (!checkConsistency(conn, schemaName, table_name))
0:         {
0:             logError("conistency check failed.");
0:         }
0: 
0:         testProgress("no delete case complete.");
0: 
0:         // delete all the rows.
0:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
0:         executeQuery(conn, "delete from " + table_name, true);
0: 
0:         if (verbose)
0:             testProgress("deleted all rows, now calling compress.");
0: 
0:         callCompress(conn, "APP", table_name, true, true, true, true);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
0:         // An empty table has 2 pages, one allocation page and the 1st page
0:         // which will have a system row in it.  The space vti only reports
0:         // a count of the user pages so the count is 1.
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
0:         {
0:             log_wrong_count(
0:                 "Expected all pages to be truncated.",
0:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         if (verbose)
0:             testProgress("calling consistency checker.");
0: 
0:         if (!checkConsistency(conn, schemaName, table_name))
0:         {
0:             logError("conistency check failed.");
0:         }
0: 
0:         testProgress("delete all rows case succeeded.");
0: 
0:         conn.commit();
0: 
0:         testProgress("end deleteAllRows," + num_rows + " row test.");
0:     }
0: 
0:     private void simpleDeleteAllRows(
0:     Connection  conn,
0:     boolean     create_table,
0:     boolean     long_table,
0:     String      schemaName,
0:     String      table_name,
0:     int         num_rows) 
0:         throws SQLException 
0:     {
0:         testProgress(
0:             "begin simpleDeleteAllRows," + num_rows + " row test, create = " + 
0:                 create_table + ".");
0: 
0: 
0:         if (long_table)
0:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
0:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
0: 
0:         if (verbose)
0:             testProgress("Calling compress.");
0: 
0:         // compress with no deletes should not affect size
0:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, true);
0:         callCompress(conn, "APP", table_name, true, true, true, true);
0:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change.", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         testProgress("no delete case complete.");
0: 
0:         // delete all the rows.
0:         ret_before = getSpaceInfo(conn, "APP", table_name, true);
0:         executeQuery(conn, "delete from " + table_name, true);
0: 
0:         if (verbose)
0:             testProgress("deleted all rows, now calling compress.");
0: 
0:         callCompress(conn, "APP", table_name, true, true, true, true);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, true);
0: 
0:         // An empty table has 2 pages, one allocation page and the 1st page
0:         // which will have a system row in it.  The space vti only reports
0:         // a count of the user pages so the count is 1.
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
0:         {
0:             log_wrong_count(
0:                 "Expected all pages to be truncated.",
0:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         testProgress("delete all rows case succeeded.");
0: 
0:         conn.commit();
0: 
0:         testProgress("end simple deleteAllRows," + num_rows + " row test.");
0:     }
0: 
0:     /**
0:      * Check/exercise purge pass phase.
0:      * <p>
0:      * Assumes that either test creates the table, or called on an empty
0:      * table with no committed deleted rows or free pages in the middle of
0:      * the table in it.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private void checkPurgePhase(
0:     Connection  conn,
0:     boolean     create_table,
0:     boolean     long_table,
0:     String      schemaName,
0:     String      table_name,
0:     int         num_rows) 
0:         throws SQLException 
0:     {
0:         testProgress(
0:             "begin checkPurgePhase" + num_rows + " row test, create = " + 
0:                 create_table + ".");
0: 
0:         if (long_table)
0:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
0:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
0: 
0:         // dump_table(conn, schemaName, table_name, false);
0: 
0:         // delete all the rows, but don't commit the delete
0:         int[] ret_before = getSpaceInfo(conn, "APP", table_name, false);
0:         executeQuery(conn, "delete from " + table_name, false);
0: 
0: 
0:         // dump_table(conn, schemaName, table_name, false);
0: 
0:         // Purge pass on non-committed deleted rows should do nothing.  
0: 
0:         // System.out.println("lock info before compress call:\n " + get_lock_info(conn, true));
0: 
0:         // Calling compress with just the "purge" pass option, no commit called.
0:         callCompress(conn, "APP", table_name, true, false, false, false);
0: 
0:         int[] ret_after  = getSpaceInfo(conn, "APP", table_name, false);
0: 
0:         // expect no change in the number of allocated pages!
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change(1).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // expect no change in the number of free pages, if there are there
0:         // is a problem with purge locking recognizing committed deleted rows.
0:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
0:         {
0:             log_wrong_count(
0:                 "Expected no free page change(1).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_FREE], 
0:                 ret_after[SPACE_INFO_NUM_FREE],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // Test that it is ok to call multiple purge passes in single xact.
0: 
0:         // Calling compress with just the "purge" pass option, no commit called.
0:         callCompress(conn, "APP", table_name, true, false, false, false);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
0: 
0:         // expect no change in the number of allocated pages!
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change(2).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // expect no change in the number of free pages, if there are there
0:         // is a problem with purge locking recognizing committed deleted rows.
0:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
0:         {
0:             log_wrong_count(
0:                 "Expected no free page change(2).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_FREE], 
0:                 ret_after[SPACE_INFO_NUM_FREE],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // since table was just loaded a defragment pass also should
0:         // not find anything to do.
0:         
0:         // Calling compress with just the "defragment" option, no commit called.
0: 
0:         // currently the defragment option requires a table level lock in
0:         // the nested user transaction, which will conflict and cause a
0:         // lock timeout.
0: 
0:         try
0:         {
0:             callCompress(conn, "APP", table_name, false, true, false, false);
0:             
0:             logError("Defragment pass did not get a lock timeout.");
0:         }
0:         catch (SQLException sqle)
0:         {
0:             // ignore exception.
0:         }
0: 
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
0: 
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change(3).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0:         if (ret_after[SPACE_INFO_NUM_FREE] != ret_before[SPACE_INFO_NUM_FREE])
0:         {
0:             log_wrong_count(
0:                 "Expected no free page change(3).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_FREE], 
0:                 ret_after[SPACE_INFO_NUM_FREE],
0:                 ret_before, ret_after);
0:         }
0: 
0: 
0:         // make sure table is back to all deleted row state.  lock timeout
0:         // will abort transaction.
0: 
0:         // delete all rows and commit.
0:         executeQuery(conn, "delete from " + table_name, true);
0: 
0:         // compress all space and commit.
0:         callCompress(conn, "APP", table_name, true, true, true, true);
0: 
0:         // add back all rows and commit.
0:         if (long_table)
0:             createAndLoadLongTable(conn, create_table, table_name, num_rows);
0:         else
0:             createAndLoadTable(conn, create_table, table_name, num_rows, 0);
0:         conn.commit();
0: 
0:         // delete all rows, and NO commit.
0:         executeQuery(conn, "delete from " + table_name, false);
0: 
0: 
0:         // Calling compress with just the truncate option, may change allocated
0:         // and free page count as they system may have preallocated pages to
0:         // the end of the file as part of the load.  The file can't shrink
0:         // any more than the free page count before the compress.
0: 
0:         // running the truncate pass only.  If it compresses anything it is
0:         // just the preallocated pages at end of the file.
0: 
0:         // currently the defragment option requires a table level lock in
0:         // the nested user transaction, which will conflict and cause a
0:         // lock timeout.
0: 
0: 
0:         ret_before = getSpaceInfo(conn, "APP", table_name, false);
0:         callCompress(conn, "APP", table_name, false, false, true, false);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
0: 
0:         // expect no change in the number of allocated pages!
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != ret_before[SPACE_INFO_NUM_ALLOC])
0:         {
0:             log_wrong_count(
0:                 "Expected no alloc page change(4).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_ALLOC], 
0:                 ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // The only space that truncate only pass can free are free pages 
0:         // located at end of file, so after free space can be anywhere from 
0:         // what it was before to 0 pages.
0:         if (ret_after[SPACE_INFO_NUM_FREE] > ret_before[SPACE_INFO_NUM_FREE])
0:         {
0:             log_wrong_count(
0:                 "Expected no increase in free pages(4).", 
0:                 table_name, num_rows, 
0:                 ret_before[SPACE_INFO_NUM_FREE], 
0:                 ret_after[SPACE_INFO_NUM_FREE],
0:                 ret_before, ret_after);
0:         }
0: 
0:         // now commit the deletes, run all phases and make sure empty table
0:         // results.
0:         conn.commit();
0: 
0:         // check the table.  Note that this will accumulate locks and
0:         // will commit the transaction.
0:         if (!checkConsistency(conn, schemaName, table_name))
0:         {
0:             logError("conistency check failed.");
0:         }
0: 
0:         // test running each phase in order.
0:         callCompress(conn, "APP", table_name, true,  false, false, false);
0:         callCompress(conn, "APP", table_name, false, true,  false, false);
0:         callCompress(conn, "APP", table_name, false, false, true , false);
0:         ret_after  = getSpaceInfo(conn, "APP", table_name, false);
0: 
0:         // An empty table has 2 pages, one allocation page and the 1st page
0:         // which will have a system row in it.  The space vti only reports
0:         // a count of the user pages so the count is 1.
0:         if (ret_after[SPACE_INFO_NUM_ALLOC] != 1)
0:         {
0:             log_wrong_count(
0:                 "Expected all pages to be truncated.",
0:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0:         if (ret_after[SPACE_INFO_NUM_FREE] != 0)
0:         {
0:             log_wrong_count(
0:                 "Expected no free page after all pages truncated.",
0:                 table_name, num_rows, 1, ret_after[SPACE_INFO_NUM_ALLOC],
0:                 ret_before, ret_after);
0:         }
0: 
0:         if (verbose)
0:             testProgress("calling consistency checker.");
0: 
0:         if (!checkConsistency(conn, schemaName, table_name))
0:         {
0:             logError("conistency check failed.");
0:         }
0: 
0:         testProgress("end checkPurgePhase" + num_rows + " row test.");
0:     }
0: 
0:     /**
0:      * Test 1 - various # page tests, regular row/columns
0:      * <p>
0:      * perform a number of insert/delete/compress operations on a variety
0:      * of sized tables, use space allocation information to verify that
0:      * compression is happening and use consistency checker to verify that
0:      * tables and indexes are all valid following the operations.
0:      * <p>
0:      * loop through testing interesting row count cases.  The cases are
0:      * 0    rows  - basic edge case, 2 page table: 1 alloc, 1 user page
0:      * 1    row   - another edge case, 2 page table: 1 alloc, 1 user page
0:      * 50   rows  - 3 page table case: 1 alloc, 1 user page, 1 user page freed
0:      * 4000 rows  - reasonable number of pages to test out, still 1 alloc page
0:      *
0:      * note that row numbers greater than 4000 may lead to lock escalation
0:      * issues, if queries like "delete from x" are used to delete all the 
0:      * rows.
0:      *
0:      * <p>
0:      *
0:      **/
0:     private void test1(
0:     Connection  conn,
0:     String      test_name,
0:     String      table_name)
0:         throws SQLException 
0:     {
0:         beginTest(conn, test_name);
0: 
0:         int[] test_cases = {0, 1, 50, 4000};
0: 
0:         for (int i = 0; i < test_cases.length; i++)
0:         {
0:             // first create new table and run the tests.
0:             deleteAllRows(
0:                 conn, true, false, "APP", table_name, test_cases[i]);
0: 
0:             // now rerun tests on existing table, which had all rows deleted
0:             // and truncated.
0:             deleteAllRows(
0:                 conn, false, false, "APP", table_name, test_cases[i]);
0: 
0:             checkPurgePhase(
0:                 conn, false, false, "APP", table_name, test_cases[i]);
0: 
0:             executeQuery(conn, "drop table " + table_name, true);
0:         }
0: 
0:         endTest(conn, test_name);
0:     }
0: 
0:     /**
0:      * Test 2 - check repeated delete tests.
0:      * <p>
0:      * There was a timing error where test1 would usually pass, but 
0:      * repeated execution of this test found a timing problem with
0:      * allocation using an "unallocated" page and getting an I/O error.
0:      *
0:      **/
0:     private void test2(
0:     Connection  conn,
0:     String      test_name,
0:     String      table_name)
0:         throws SQLException 
0:     {
0:         beginTest(conn, test_name);
0: 
0:         int[] test_cases = {4000};
0: 
0:         for (int i = 0; i < test_cases.length; i++)
0:         {
0:             // first create new table and run the tests.
0:             simpleDeleteAllRows(
0:                 conn, true, false, "APP", table_name, test_cases[i]);
0: 
0:             for (int j = 0; j < 100; j++)
0:             {
0: 
0:                 // now rerun tests on existing table, which had all rows deleted
0:                 // and truncated.
0:                 deleteAllRows(
0:                     conn, false, false, "APP", table_name, test_cases[i]);
0:             }
0: 
0:             executeQuery(conn, "drop table " + table_name, true);
0:         }
0: 
0:         endTest(conn, test_name);
0:     }
0: 
0: 
0: 
0:     /**
0:      * Test 3 - various # page tests, long row and long columns
0:      * <p>
0:      * perform a number of insert/delete/compress operations on a variety
0:      * of sized tables, use space allocation information to verify that
0:      * compression is happening and use consistency checker to verify that
0:      * tables and indexes are all valid following the operations.
0:      * <p>
0:      * loop through testing interesting row count cases.  The cases are
0:      * 0    rows  - basic edge case
0:      * 1    row   - another edge case
0:      * 100  rows  - ~50 meg table
0:      * 4000 rows  - ~2 gig table
0:      *
0:      * note that row numbers greater than 4000 may lead to lock escalation
0:      * issues, if queries like "delete from x" are used to delete all the 
0:      * rows.
0:      *
0:      * <p>
0:      *
0:      **/
0:     private void test3(
0:     Connection  conn,
0:     String      test_name,
0:     String      table_name)
0:         throws SQLException 
0:     {
0:         beginTest(conn, test_name);
0: 
0:         // note that 500 rows took 30 minutes on a ~1.5 ghz laptop
0:         int[] test_cases = {1, 2, 50};
0: 
0:         for (int i = 0; i < test_cases.length; i++)
0:         {
0:             // first create new table and run the tests.
0:             deleteAllRows(
0:                 conn, true, true, "APP", table_name, test_cases[i]);
0: 
0:             // now rerun tests on existing table, which had all rows deleted
0:             // and truncated.
0:             deleteAllRows(
0:                 conn, false, true, "APP", table_name, test_cases[i]);
0: 
0:             checkPurgePhase(
0:                 conn, false, true, "APP", table_name, test_cases[i]);
0: 
0:             executeQuery(conn, "drop table " + table_name, true);
0:         }
0: 
0:         endTest(conn, test_name);
0:     }
0: 
0:     /**
0:      * Test 4 - check repeated delete tests.
0:      * <p>
0:      * There was a timing error where test1 would usually pass, but 
0:      * repeated execution of this test found a timing problem with
0:      * allocation using an "unallocated" page and getting an I/O error.
0:      *
0:      **/
0:     private void test4(
0:     Connection  conn,
0:     String      test_name,
0:     String      table_name)
0:         throws SQLException 
0:     {
0:         beginTest(conn, test_name);
0: 
0:         int[] test_cases = {4000};
0: 
0:         for (int i = 0; i < test_cases.length; i++)
0:         {
0: 
0:             for (int j = 0; j < 100; j++)
0:             {
0:                 // first create new table and run the tests.
0:                 simpleDeleteAllRows(
0:                     conn, true, false, "APP", table_name, test_cases[i]);
0: 
0:                 // now rerun tests on existing table, which had all rows deleted
0:                 // and truncated.
0:                 deleteAllRows(
0:                     conn, false, false, "APP", table_name, test_cases[i]);
0: 
0:                 executeQuery(conn, "drop table " + table_name, true);
0:             }
0: 
0:         }
0: 
0:         endTest(conn, test_name);
0:     }
0: 
0: 
0: 
0:     public void testList(Connection conn)
0:         throws SQLException
0:     {
0:         test1(conn, "test1", "TEST1");
0:         // test2(conn, "test2", "TEST2");
0:         test3(conn, "test3", "TEST3");
0:         // test4(conn, "test2", "TEST2");
0:     }
0: 
0:     public static void main(String[] argv) 
0:         throws Throwable
0:     {
0:         OnlineCompressTest test = new OnlineCompressTest();
0: 
0:    		ij.getPropertyArg(argv); 
0:         Connection conn = ij.startJBMS();
0:         conn.setAutoCommit(false);
0: 
0:         try
0:         {
0:             test.testList(conn);
0:         }
0:         catch (SQLException sqle)
0:         {
0: 			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
0:                 System.out, sqle);
0: 			sqle.printStackTrace(System.out);
0: 		}
0:     }
0: }
============================================================================