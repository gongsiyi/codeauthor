1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.Predicate
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
28:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3541af3: import java.util.HashSet;
1:3541af3: import java.util.Set;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * A Predicate represents a top level predicate.
7:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class Predicate extends QueryTreeNode implements OptimizablePredicate,
1:3bb140c:                                                         Comparable<Predicate>
16:eac0369: {
1:eac0369: 	/* Top of the predicate */
1:eac0369: 	AndNode		andNode;
1:eac0369: 	boolean		pushable;
1:eac0369: 	/* Bit map of referenced tables */
1:eac0369: 	JBitSet		referencedSet;
1:eac0369: 	/* Join clauses are placed into equivalence classes when applying transitive
1:eac0369: 	 * closure for join clauses.  This is useful for eliminating redundant predicates.
1:eac0369: 	 */
1:eac0369: 	int			equivalenceClass = -1;
1:eac0369: 	int			indexPosition;
1:eac0369: 	protected boolean startKey;
1:eac0369: 	protected boolean stopKey;
1:eac0369: 	protected boolean isQualifier;
1:eac0369: 
1:eac0369: 	/* Hashtable used for tracking the search clause types that have been
1:eac0369: 	 * pushed through this predicate (if an equijoin) via transitive closure.
1:eac0369: 	 */
1:71c8e86:     private Set<Integer> searchClauses;
1:eac0369: 
1:6718a25: 	// Whether or not this predicate has been scoped; see the
1:6718a25: 	// getPredScopedForResultSet() method of this class for more.
1:6718a25: 	private boolean scoped;
1:6718a25: 
1:eac0369: 	/**
1:3bb140c:      * Constructor.
1:eac0369: 	 *
1:eac0369: 	 * @param andNode		The top of the predicate	 
1:eac0369: 	 * @param referencedSet	Bit map of referenced tables
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     Predicate(AndNode andNode, JBitSet referencedSet, ContextManager cm)
1:eac0369: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.andNode = andNode;
1:eac0369: 		pushable = false;
1:3bb140c:         this.referencedSet = referencedSet;
1:6718a25: 		scoped = false;
17:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:6718a25: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#getReferencedMap
1:eac0369: 	 */
1:eac0369: 	public JBitSet getReferencedMap()
1:6718a25: 	{
1:eac0369: 		return referencedSet;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasSubquery
1:eac0369: 	 */
1:eac0369: 	public boolean hasSubquery()
1:eac0369: 	{
1:eac0369: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
1:eac0369: 		 * on whether or not it contains a subquery or method call, but we do not
1:eac0369: 		 * record the underlying info.
1:eac0369: 		 */
1:eac0369: 		return ! pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasMethodCall
1:eac0369: 	 */
1:eac0369: 	public boolean hasMethodCall()
1:eac0369: 	{
1:eac0369: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
1:eac0369: 		 * on whether or not it contains a subquery or method call, but we do not
1:eac0369: 		 * record the underlying info.
1:eac0369: 		 */
1:eac0369: 		return ! pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#markStartKey */
1:eac0369: 	public void markStartKey()
1:eac0369: 	{
1:eac0369: 		startKey = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#isStartKey */
1:eac0369: 	public boolean isStartKey()
1:eac0369: 	{
1:eac0369: 		return startKey;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#markStopKey */
1:eac0369: 	public void markStopKey()
1:eac0369: 	{
1:eac0369: 		stopKey = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#isStopKey */
1:eac0369: 	public boolean isStopKey()
1:eac0369: 	{
1:eac0369: 		return stopKey;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#markQualifier */
1:eac0369: 	public void markQualifier()
1:eac0369: 	{
1:eac0369: 		isQualifier = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#isQualifier */
1:eac0369: 	public boolean isQualifier()
1:eac0369: 	{
1:eac0369: 		return isQualifier;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#compareWithKnownConstant */
1:eac0369: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
1:eac0369: 	{
1:eac0369: 		boolean retval = false;
1:1ad3b32: 		RelationalOperator relop = getRelop();
1:eac0369: 
1:eac0369: 		/* if this is for "in" operator node's dynamic start/stop key, relop is
1:eac0369: 		 * null, and it's not comparing with constant, beetle 3858
1:eac0369: 		 */
1:1ad3b32: 		if (!isRelationalOpPredicate())
1:6718a25: 			return false;
1:eac0369: 
1:eac0369: 		if (relop.compareWithKnownConstant(optTable, considerParameters))
1:eac0369: 			retval = true;
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int hasEqualOnColumnList(int[] baseColumnPositions,
7:eac0369: 										Optimizable optTable)
4:eac0369: 		throws StandardException
1:eac0369: 	{
3:eac0369: 		RelationalOperator relop = getRelop();
1:eac0369: 
1:1ad3b32: 		if (!isRelationalOpPredicate())
1:eac0369: 			return -1;
1:eac0369: 		
1:eac0369: 		if (!(relop.getOperator() == RelationalOperator.EQUALS_RELOP))
1:eac0369: 			return -1;
1:eac0369: 			
1:eac0369: 		for (int i = 0; i < baseColumnPositions.length; i++)
1:eac0369: 		{
1:eac0369: 			ColumnReference cr = relop.getColumnOperand(optTable, 
1:eac0369: 														baseColumnPositions[i]);
1:eac0369: 		
1:eac0369: 			if (cr == null)
1:eac0369: 				continue;
1:eac0369: 			
1:eac0369: 			if (relop.selfComparison(cr))
1:eac0369: 				continue;
1:eac0369: 
1:eac0369: 			// If I made it thus far in the loop, we've found
1:eac0369: 			// something.
1:eac0369: 			return i;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see OptimizablePredicate#getCompareValue
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getCompareValue(Optimizable optTable)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(compareWithKnownConstant(optTable, true),
1:eac0369: 				"Cannot get the compare value if not comparing with a known constant.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		RelationalOperator relop = getRelop();
1:eac0369: 
1:eac0369: 		return relop.getCompareValue(optTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#equalsComparisonWithConstantExpression */
1:eac0369: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		boolean retval = false;
1:eac0369: 
1:1ad3b32: 		if (isRelationalOpPredicate())
1:eac0369: 		{
1:1ad3b32: 			retval = getRelop().equalsComparisonWithConstantExpression(optTable);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#selectivity */
1:eac0369: 	public double selectivity(Optimizable optTable)
1:d5bc20f: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		return andNode.getLeftOperand().selectivity(optTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see OptimizablePredicate#getIndexPosition */
1:eac0369: 	public int getIndexPosition()
1:eac0369: 	{
1:eac0369: 		return indexPosition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* Comparable interface */
1:eac0369: 
1:3bb140c:     public int compareTo(Predicate other)
1:eac0369: 	{
1:3bb140c:         Predicate otherPred = other;
1:eac0369: 
1:eac0369: 		/* Not all operators are "equal". If the predicates are on the
1:eac0369: 		 * same key column, then a "=" opertor takes precedence over all
1:eac0369: 		 * other operators.  This ensures that the "=" will be both the start
1:eac0369: 		 * and stop predicates.  Otherwise, we could end up with it being one
1:eac0369: 		 * but not the other and get incorrect results.
1:eac0369: 		 *
1:eac0369: 		 * Also, we want "<>" to come after all the other operators.
1:eac0369: 		 * Other parts of the optimizer use the first predicate on an index
1:eac0369: 		 * column to determine the cost of using the index, so we want the
1:eac0369: 		 * "<>" to come last because it's not useful for limiting the scan.
1:eac0369: 		 *
1:eac0369: 		 * In other words, P1 is before() P2 if:
1:eac0369: 		 *		o  The P1.indexPosition < P2.indexPosition
1:eac0369: 		 *	or  o  P1.indexPosition == P2.indexPosition and
1:eac0369: 		 *		   P1's operator is ("=" or IS NULL) and
1:eac0369: 		 *		   P2's operator is not ("=" or IS NULL)
1:eac0369: 		 * or	o  P1.indexPosition == P2.indexPosition and
1:eac0369: 		 *		   P1's operator is not ("<>" or IS NOT NULL) and
1:eac0369: 		 *		   P2's operator is ("<>" or IS NOT NULL)
1:eac0369: 		 *
1:eac0369: 		 * (We have to impose an arbitrary, but reproducible ordering
1:eac0369: 		 * on the the "=" predicates on the same column, otherwise an
1:eac0369: 		 * ASSERTion, that after the predicates are order, Pn+1 is not
1:eac0369: 		 * before() Pn, will be violated.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int otherIndexPosition = otherPred.getIndexPosition();
1:eac0369: 
1:eac0369: 		if (indexPosition < otherIndexPosition)
1:eac0369: 			return -1;
1:eac0369: 
1:eac0369: 		if (indexPosition > otherIndexPosition)
1:eac0369: 			return 1;
1:eac0369: 
1:eac0369: 		// initialize these flags as if they are for "in" operator, then
1:eac0369: 		// change them if they are not
1:eac0369: 		//
1:eac0369: 		boolean thisIsEquals = false, otherIsEquals = false;
1:eac0369: 		boolean thisIsNotEquals = true, otherIsNotEquals = true;
1:eac0369: 
1:70f168c: 		/* The call to "isRelationalOpPredicate()" will return false
1:70f168c: 		 * for a "probe predicate" because a probe predicate is really
1:70f168c: 		 * a disguised IN list. But when it comes to sorting, the probe
1:70f168c: 		 * predicate (which is of the form "<col> = ?") should be treated
1:70f168c: 		 * as an equality--i.e. it should have precedence over any non-
1:70f168c: 		 * equals predicate, per the comment at the start of this
1:70f168c: 		 * method.  So that's what we're checking here.
1:70f168c: 		 */
1:70f168c: 		if (this.isRelationalOpPredicate() || // this is not "in" or
1:70f168c: 			this.isInListProbePredicate())    // this is a probe predicate
1:eac0369: 		{
1:eac0369: 			int thisOperator = ((RelationalOperator)andNode.getLeftOperand()).getOperator();
1:eac0369: 			thisIsEquals = (thisOperator == RelationalOperator.EQUALS_RELOP ||
1:eac0369: 								thisOperator == RelationalOperator.IS_NULL_RELOP);
1:eac0369: 			thisIsNotEquals = (thisOperator == RelationalOperator.NOT_EQUALS_RELOP ||
1:eac0369: 								   thisOperator == RelationalOperator.IS_NOT_NULL_RELOP);
1:eac0369: 		}
1:70f168c: 
1:70f168c: 		if (otherPred.isRelationalOpPredicate() || // other is not "in" or
1:70f168c: 			otherPred.isInListProbePredicate())    // other is a probe predicate
1:eac0369: 		{
1:eac0369: 			int	otherOperator = ((RelationalOperator)(otherPred.getAndNode().getLeftOperand())).getOperator();
1:eac0369: 			otherIsEquals = (otherOperator == RelationalOperator.EQUALS_RELOP ||
1:eac0369: 								 otherOperator == RelationalOperator.IS_NULL_RELOP);
1:eac0369: 			otherIsNotEquals = (otherOperator == RelationalOperator.NOT_EQUALS_RELOP ||
1:eac0369: 								 otherOperator == RelationalOperator.IS_NOT_NULL_RELOP);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean thisIsBefore = (thisIsEquals && ! otherIsEquals) || ( ! thisIsNotEquals && otherIsNotEquals);
1:eac0369: 		if (thisIsBefore)
1:eac0369: 			return -1;
1:eac0369: 
1:eac0369: 		boolean otherIsBefore = (otherIsEquals && ! thisIsEquals) || ( ! otherIsNotEquals && thisIsNotEquals);
1:eac0369: 		if (otherIsBefore)
1:eac0369: 			return 1;
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the andNode.
1:eac0369: 	 *
1:eac0369: 	 * @return AndNode	The andNode.
1:eac0369: 	 */
1:3bb140c:     AndNode getAndNode()
1:eac0369: 	{
1:eac0369: 		return andNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the andNode.
1:eac0369: 	 *
1:eac0369: 	 * @param andNode	The new andNode.
1:eac0369: 	 */
1:3bb140c:     void setAndNode(AndNode andNode)
1:eac0369: 	{
1:eac0369: 		this.andNode = andNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the pushable.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the predicate is pushable.
1:eac0369: 	 */
1:3bb140c:     boolean getPushable()
1:eac0369: 	{
1:eac0369: 		return pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6718a25: 	 * Set whether or not this predicate is pushable.  This method
1:6718a25: 	 * is intended for use when creating a copy of the predicate, ex
1:6718a25: 	 * for predicate pushdown.  We choose not to add this assignment
1:6718a25: 	 * to copyFields() because the comments for that method say that
1:6718a25: 	 * it should copy all fields _except_ the two specified at init
1:6718a25: 	 * time; "pushable" is one of the two specified at init time.
1:6718a25: 	 *
1:6718a25: 	 * @param pushable Whether or not the predicate is pushable.
1:6718a25: 	 */
1:3bb140c:     void setPushable(boolean pushable) {
1:6718a25: 		this.pushable = pushable;
1:6718a25: 	}
1:6718a25: 
1:6718a25: 	/**
1:eac0369: 	 * Return the referencedSet.
1:eac0369: 	 *
1:eac0369: 	 * @return JBitSet	The referencedSet.
1:eac0369: 	 */
1:3bb140c:     JBitSet getReferencedSet()
1:eac0369: 	{
1:eac0369: 		return referencedSet;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the equivalence class, if any, for this predicate.
1:eac0369: 	 *
1:eac0369: 	 * @param equivalenceClass	The equivalence class for this predicate.
1:eac0369: 	 */
1:eac0369: 	void setEquivalenceClass(int equivalenceClass)
1:eac0369: 	{
1:eac0369: 		this.equivalenceClass = equivalenceClass;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the equivalenceClass for this predicate.
1:eac0369: 	 *
1:eac0369: 	 * @return The equivalenceClass for this predicate.
1:eac0369: 	 */
1:eac0369: 	int getEquivalenceClass()
1:eac0369: 	{
1:eac0369: 		return equivalenceClass;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void categorize() throws StandardException
1:eac0369: 	{
1:eac0369: 		pushable = andNode.categorize(referencedSet, false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the RelationalOperator on the left side of the AND node, if
1:eac0369: 	 * there is one.  If the left side is not a RelationalOperator, return
1:eac0369: 	 * null.
1:eac0369: 	 *
1:eac0369: 	 * @return	The RelationalOperator on the left side of the AND node,
1:eac0369: 	 *			if any.
1:eac0369: 	 */
1:3bb140c:     RelationalOperator getRelop()
1:eac0369: 	{
1:eac0369: 		
1:eac0369: 		if (andNode.getLeftOperand() instanceof RelationalOperator)
1:eac0369: 		{
1:eac0369: 			return (RelationalOperator) andNode.getLeftOperand();
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:8380265: 		}
1:eac0369: 	}
1:8380265: 
1:3bb140c:     final boolean isOrList()
1:8380265:     {
1:eac0369:         return(andNode.getLeftOperand() instanceof OrNode);
1:eac0369:     }
1:eac0369: 
1:8380265:     /**
1:eac0369:      * Is this predicate a possible Qualifier for store?
1:eac0369:      * <p>
1:eac0369:      * Current 2 types of predicates can be pushed to store: 
1:eac0369:      *   1) RelationalOperator - 
1:eac0369:      *      represented with by left operand as instance of RelationalOperator.
1:eac0369:      *   2) A single And'd term of a list of OR terms
1:eac0369:      *      represented by left operand as instance of OrNode.
1:eac0369:      *
1:eac0369:      * More checking specific operator's terms to see if they are finally
1:eac0369:      * pushable to store.  In the final push at execution each term of the AND 
1:eac0369:      * or OR must be a Relational operator with a column reference on one side 
1:eac0369:      * and a constant on the other.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @return true if term is wither a AND of a RelationalOperator, or an
1:eac0369:      *              OR of one or more Relational Operators.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:3bb140c:     final boolean isStoreQualifier()
1:eac0369:     {
1:eac0369: 		if ((andNode.getLeftOperand() instanceof RelationalOperator) ||
1:eac0369: 		    (andNode.getLeftOperand() instanceof OrNode))
1:eac0369: 		{
1:eac0369:             return(true);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369:             return(false);
1:eac0369: 		}
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is this predicate an pushable OR list?
1:eac0369:      * <p>
1:eac0369:      * Does the predicate represent a AND'd list of OR term's, all of which
1:eac0369:      * are pushable.  To be pushable each of OR terms must be a legal 
1:eac0369:      * qualifier, which is a column reference on one side of a Relational
1:eac0369:      * operator and a constant on the other.
1:eac0369:      *
1:eac0369: 	 * @return true if the predicate is a pushable set of OR clauses.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:3bb140c:     final boolean isPushableOrClause(Optimizable optTable)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         boolean ret_val = true;
1:eac0369: 
1:eac0369:         if (andNode.getLeftOperand() instanceof OrNode)
1:eac0369:         {
1:eac0369:             QueryTreeNode node = andNode.getLeftOperand();
1:eac0369: 
1:eac0369:             while (node instanceof OrNode)
1:eac0369:             {
1:eac0369:                 OrNode or_node = (OrNode) node;
1:eac0369: 
1:eac0369:                 if (or_node.getLeftOperand() instanceof RelationalOperator)
1:eac0369:                 {
1:eac0369:                     // if any term of the OR clause is not a qualifier, then
1:eac0369:                     // reject the entire OR clause.
1:0be2d6e:                     if (!((RelationalOperator) or_node.getLeftOperand()).
1:0be2d6e:                         isQualifier(optTable, true))
1:eac0369:                     {
1:eac0369:                         // one of the terms is not a pushable Qualifier.
1:eac0369:                         return(false);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     node = or_node.getRightOperand();
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // one of the terms is not a RelationalOperator
1:eac0369: 
1:eac0369:                     return(false);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             return(true);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // Not an OR list
1:eac0369:             return(false);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this predicate has been used
1:eac0369: 	 * to add a new search clause of the specified type via transitive closure.
1:eac0369: 	 * NOTE: This can only be true if this is an equijoin
1:eac0369: 	 * between 2 column references.
1:eac0369: 	 *
1:eac0369: 	 * @param ro	The search clause that we are currently considering
1:eac0369: 	 *				as the source for transitive closure
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not this predicate has been used
1:eac0369: 	 *			to add a new search clause of the specified type via transitive 
1:eac0369:      *			closure.
1:8380265: 	 */
1:eac0369: 	boolean transitiveSearchClauseAdded(RelationalOperator ro)
1:eac0369: 	{
1:3541af3:         return searchClauses != null &&
1:bb5be6f:             searchClauses.contains(ro.getOperator());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark this predicate as having been used to add a new predicate
1:eac0369: 	 * of the specified type via transitive closure on search clauses.
1:eac0369: 	 *
1:eac0369: 	 * @param ro	The search clause that we are currently considering
1:eac0369: 	 *				as the source for transitive closure
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	void setTransitiveSearchClauseAdded(RelationalOperator ro)
1:eac0369: 	{
1:3541af3:         if (searchClauses == null) {
1:71c8e86:             searchClauses = new HashSet<Integer>();
1:3541af3:         }
1:eac0369: 		/* I have to remember that this ro has been added to this predicate as a
1:eac0369: 		 * transitive search clause.
1:eac0369: 		 */
1:bb5be6f:         searchClauses.add(ro.getOperator());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the start operator for this predicate for a scan.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The optimizable table, so we can tell which side of
1:eac0369: 	 *					the operator the search column is on.
1:eac0369: 	 *
1:eac0369: 	 * @return	The start operator for a start key on this column.
1:eac0369: 	 */
1:eac0369: 	int getStartOperator(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(startKey, "Getting a start operator from a Predicate that's not a start key.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* if it's for "in" operator's dynamic start key, operator is GE,
1:eac0369: 		 * beetle 3858
1:eac0369: 		 */
1:eac0369: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
1:eac0369: 			return ScanController.GE;
1:eac0369: 
1:eac0369: 		return getRelop().getStartOperator(optTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	int getStopOperator(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(stopKey, "Getting a stop operator from a Predicate that's not a stop key.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		 /* if it's for "in" operator's dynamic stop key, operator is GT,
1:eac0369: 		  * beetle 3858
1:eac0369: 		  */
1:eac0369: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
1:eac0369: 			return ScanController.GT;
1:eac0369: 
1:eac0369: 		return getRelop().getStopOperator(optTable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the position of the index column that this predicate restricts
1:eac0369: 	 *
1:eac0369: 	 * @param indexPosition	The position of the index column that this
1:eac0369: 	 *						predicate restricts.
1:eac0369: 	 */
1:eac0369: 	void setIndexPosition(int indexPosition)
1:eac0369: 	{
1:eac0369: 		this.indexPosition = indexPosition;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clear the start/stop position and qualifier flags
1:eac0369: 	 */
1:eac0369: 	void clearScanFlags()
1:eac0369: 	{
1:eac0369: 		startKey = false;
1:eac0369: 		stopKey = false;
2:eac0369: 		isQualifier = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	void generateExpressionOperand(Optimizable optTable,
1:eac0369: 										int columnPosition,
1:eac0369: 										ExpressionClassBuilder acb,
1:eac0369: 										MethodBuilder mb)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		getRelop().generateExpressionOperand(optTable,
1:eac0369: 													columnPosition,
1:eac0369: 													acb,
1:eac0369: 													mb);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:6718a25: 			return binaryRelOpColRefsToString() + "\nreferencedSet: " +
1:6718a25: 				referencedSet  + "\n" + "pushable: " + pushable + "\n" +
1:f6fa942: 				"isQualifier: " + isQualifier + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:6718a25: 
1:eac0369: 	/**
1:6718a25: 	 * Get a string version of the column references for this predicate
1:6718a25: 	 * IF it's a binary relational operator.  We only print out the
1:6718a25: 	 * names of the operands if they are column references; otherwise
1:6718a25: 	 * we just print a dummy value.  This is for debugging purposes
1:6718a25: 	 * only--it's a convenient way to see what columns the predicate
1:6718a25: 	 * is referencing, especially when tracing through code and printing
1:6718a25: 	 * assert failure.
1:6718a25: 	 */
1:3bb140c:     String binaryRelOpColRefsToString()
1:6718a25: 	{
1:6718a25: 		// We only consider binary relational operators here.
1:6718a25: 		if (!(getAndNode().getLeftOperand()
1:6718a25: 			instanceof BinaryRelationalOperatorNode))
1:6718a25: 		{
1:6718a25: 			return "";
1:6718a25: 		}
1:6718a25: 
1:6718a25: 		final String DUMMY_VAL = "<expr>";
1:3bb140c:         java.lang.StringBuilder sBuf = new java.lang.StringBuilder();
1:6718a25: 		BinaryRelationalOperatorNode opNode =
1:6718a25: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1:6eeba4f: 
1:6718a25: 		// Get left operand's name.
1:6718a25: 		if (opNode.getLeftOperand() instanceof ColumnReference)
1:6eeba4f: 		{
1:6718a25: 			sBuf.append(
1:2706d1f:                     ((ColumnReference)opNode.getLeftOperand()).getTableName());
1:2706d1f:             sBuf.append('.');
1:2706d1f:             sBuf.append(
1:2706d1f:                     ((ColumnReference)opNode.getLeftOperand()).getColumnName());
1:6eeba4f: 		}
1:6718a25: 		else
1:6718a25: 			sBuf.append(DUMMY_VAL);
1:6718a25: 
1:6718a25: 		// Get the operator type.
1:2706d1f:         sBuf.append(' ');
1:2706d1f:         sBuf.append(opNode.operator);
1:2706d1f:         sBuf.append(' ');
1:6718a25: 
1:6718a25: 		// Get right operand's name.
1:6718a25: 		if (opNode.getRightOperand() instanceof ColumnReference) {
1:6718a25: 			sBuf.append(
1:6718a25: 				((ColumnReference)opNode.getRightOperand()).getTableName() +
2:6718a25: 				"." +
1:6718a25: 				((ColumnReference)opNode.getRightOperand()).getColumnName()
2:6718a25: 			);
1:6718a25: 		}
1:6718a25: 		else
1:6718a25: 			sBuf.append(DUMMY_VAL);
1:6718a25: 
1:6718a25: 		return sBuf.toString();
1:6718a25: 	}
1:6718a25: 
1:6718a25: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:6718a25: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			printLabel(depth, "andNode: ");
1:eac0369: 			andNode.treePrint(depth + 1);
1:eac0369: 			super.printSubNodes(depth);
1:6718a25: 		}
1:6718a25: 	}
1:6718a25: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:6718a25: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (andNode != null)
1:eac0369: 		{
1:eac0369: 			andNode = (AndNode)andNode.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Copy all fields of this Predicate (except the two that
1:eac0369: 	 * are set from 'init').
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:3bb140c:     void copyFields(Predicate otherPred) {
1:eac0369: 
1:eac0369: 		this.equivalenceClass = otherPred.getEquivalenceClass();
1:eac0369: 		this.indexPosition = otherPred.getIndexPosition();
1:eac0369: 		this.startKey = otherPred.isStartKey();
1:eac0369: 		this.stopKey = otherPred.isStopKey();
1:eac0369: 		this.isQualifier = otherPred.isQualifier();
1:3541af3:         this.searchClauses = otherPred.searchClauses;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:6718a25: 	 * Determine whether or not this predicate is eligible for
1:6718a25: 	 * push-down into subqueries.  Right now the only predicates
1:6718a25: 	 * we consider to be eligible are those which 1) are Binary
1:0be2d6e: 	 * Relational operator nodes and 2) have a column reference
1:0be2d6e: 	 * on BOTH sides, each of which has a reference to a base
1:0be2d6e: 	 * table somewhere beneath it.
1:6718a25: 	 *
1:6718a25: 	 * @return Whether or not this predicate is eligible to be
1:6718a25: 	 *  pushed into subqueries.
1:6718a25: 	 */
1:6718a25: 	protected boolean pushableToSubqueries()
1:6718a25: 		throws StandardException
1:6718a25: 	{
1:0be2d6e: 		if (!isJoinPredicate())
1:6eeba4f: 			return false;
1:6718a25: 
1:6eeba4f: 		// Make sure both column references ultimately point to base
1:6eeba4f: 		// tables.  If, for example, either column reference points to a
1:6eeba4f: 		// a literal or an aggregate, then we do not push the predicate.
1:6eeba4f: 		// This is because pushing involves remapping the references--
1:6eeba4f: 		// but if the reference doesn't have a base table beneath it,
1:6eeba4f: 		// the notion of "remapping" it doesn't (seem to) apply.  RESOLVE:
1:6eeba4f: 		// it might be okay to make the "remap" operation a no-op for
1:6eeba4f: 		// such column references, but it's not clear whether that's
1:6eeba4f: 		// always a safe option; further investigation required.
1:0be2d6e: 
1:0be2d6e: 		BinaryRelationalOperatorNode opNode =
1:0be2d6e: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1:6eeba4f: 
1:6eeba4f: 		JBitSet tNums = new JBitSet(getReferencedSet().size());
1:6eeba4f: 		BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNums);
1:6eeba4f: 		opNode.getLeftOperand().accept(btnVis);
1:6eeba4f: 		if (tNums.getFirstSetBit() == -1)
1:6eeba4f: 			return false;
1:6eeba4f: 
1:6eeba4f: 		tNums.clearAll();
1:6eeba4f: 		opNode.getRightOperand().accept(btnVis);
1:6eeba4f: 		if (tNums.getFirstSetBit() == -1)
1:6eeba4f: 			return false;
1:6eeba4f: 
1:6eeba4f: 		return true;
1:6718a25: 	}
1:6718a25: 
1:6718a25: 	/**
1:0be2d6e: 	 * Is this predicate a join predicate?  In order to be so,
1:0be2d6e: 	 * it must be a binary relational operator node that has
1:0be2d6e: 	 * a column reference on both sides.
1:0be2d6e: 	 *
1:0be2d6e: 	 * @return Whether or not this is a join predicate.
1:0be2d6e: 	 */
1:0be2d6e: 	protected boolean isJoinPredicate()
1:0be2d6e: 	{
1:0be2d6e: 		// If the predicate isn't a binary relational operator,
1:0be2d6e: 		// then it's not a join predicate.
1:0be2d6e: 		if (!(getAndNode().getLeftOperand()
1:0be2d6e: 			instanceof BinaryRelationalOperatorNode))
1:0be2d6e: 		{
1:0be2d6e: 			return false;
1:0be2d6e: 		}
1:0be2d6e: 
1:0be2d6e: 		BinaryRelationalOperatorNode opNode =
1:0be2d6e: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1:0be2d6e: 
1:df88f63: 		// If both sides are column references AND they point to different
1:df88f63: 		// tables, then this is a join pred.
1:0be2d6e: 		return ((opNode.getLeftOperand() instanceof ColumnReference) &&
1:df88f63: 			(opNode.getRightOperand() instanceof ColumnReference) &&
1:df88f63: 			(((ColumnReference)opNode.getLeftOperand()).getTableNumber() !=
1:df88f63: 			((ColumnReference)opNode.getRightOperand()).getTableNumber()));
1:0be2d6e: 	}
1:0be2d6e: 
1:0be2d6e: 	/**
1:6718a25: 	 * If this predicate's operator is a BinaryRelationalOperatorNode,
1:6718a25: 	 * then look at the operands and return a new, equivalent predicate
1:6718a25: 	 * that is "scoped" to the received ResultSetNode.  By "scoped" we
1:6718a25: 	 * mean that the operands, which shold be column references, have been
1:6718a25: 	 * mapped to the appropriate result columns in the received RSN.
1:6718a25: 	 * This is useful for pushing predicates from outer queries down
1:6718a25: 	 * into inner queries, in which case the column references need
1:6718a25: 	 * to be remapped.
1:6718a25: 	 *
1:6718a25: 	 * For example, let V1 represent
1:6718a25: 	 *
1:6718a25: 	 *    select i,j from t1 UNION select i,j from t2
1:6718a25: 	 * 
1:6718a25: 	 * and V2 represent
1:6718a25: 	 *
1:6718a25: 	 *    select a,b from t3 UNION select a,b from t4
1:6718a25: 	 * 
1:6718a25: 	 * Then assume we have the following query:
1:6718a25: 	 *
1:6718a25: 	 *    select * from V1, V2 where V1.j = V2.b
1:6718a25: 	 *
1:6718a25: 	 * Let's further assume that this Predicate object represents the
1:6718a25: 	 * "V1.j = V2.b" operator and that the childRSN we received
1:6718a25: 	 * as a parameter represents one of the subqueries to which we
1:6718a25: 	 * want to push the predicate; let's say it's:
1:6718a25: 	 *
1:6718a25: 	 *    select i,j from t1
1:6718a25: 	 *
1:6718a25: 	 * Then this method will return a new predicate whose binary
1:6718a25: 	 * operator represents the expression "T1.j = V2.b" (that is, V1.j
1:6718a25: 	 * will be mapped to the corresponding column in T1).  For more on
1:6718a25: 	 * how that mapping is made, see the "getScopedOperand()" method
1:6718a25: 	 * in BinaryRelationalOperatorNode.java.
1:6718a25: 	 *
1:6718a25: 	 * ASSUMPTION: We should only get to this method if we know that
1:6718a25: 	 * at least one operand in this predicate can and should be mapped
1:6718a25: 	 * to the received childRSN.  For an example of where that check is
1:6718a25: 	 * made, see the pushOptPredicate() method in SetOperatorNode.java.
1:6718a25: 	 *
1:6718a25: 	 * @param parentRSNsTables Set of all table numbers referenced by
1:6718a25: 	 *  the ResultSetNode that is _parent_ to the received childRSN.
1:6718a25: 	 *  We need this to make sure we don't scope the operands to a
1:6718a25: 	 *  ResultSetNode to which they don't apply.
1:6718a25: 	 * @param childRSN The result set node for which we want to create
1:6718a25: 	 *  a scoped predicate.
1:df88f63: 	 * @param whichRC If not -1 then this tells us which ResultColumn
1:df88f63: 	 *  in the received childRSN we need to use for the scoped predicate;
1:df88f63: 	 *  if -1 then the column position of the scoped column reference
1:df88f63: 	 *  will be stored in this array and passed back to the caller.
1:6718a25: 	 * @return A new predicate whose operands have been scoped to the
1:6718a25: 	 *  received childRSN.
1:6718a25: 	 */
1:6718a25: 	protected Predicate getPredScopedForResultSet(
1:df88f63: 		JBitSet parentRSNsTables, ResultSetNode childRSN,
1:df88f63: 		int [] whichRC) throws StandardException
1:6718a25: 	{
1:6718a25: 		// We only deal with binary relational operators here.
2:6718a25: 		if (!(getAndNode().getLeftOperand()
2:6718a25: 			instanceof BinaryRelationalOperatorNode))
1:6718a25: 		{
1:6718a25: 			return this;
1:6718a25: 		}
1:6718a25: 
1:6718a25: 		// The predicate must have an AndNode in CNF, so we
1:6718a25: 		// need to create an AndNode representing:
1:6718a25: 		//    <scoped_bin_rel_op> AND TRUE
1:6718a25: 		// First create the boolean constant for TRUE.
1:3bb140c:         ValueNode trueNode = new BooleanConstantNode(true, getContextManager());
1:6718a25: 
2:6718a25: 		BinaryRelationalOperatorNode opNode =
2:6718a25: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1:6718a25: 
1:6718a25: 		// Create a new op node with left and right operands that point
1:6718a25: 		// to the received result set's columns as appropriate.
1:6718a25: 		BinaryRelationalOperatorNode newOpNode = 
1:3bb140c:             new BinaryRelationalOperatorNode(
1:2706d1f:                 opNode.kind,
1:6718a25: 				opNode.getScopedOperand(
1:6718a25: 					BinaryRelationalOperatorNode.LEFT,
1:6718a25: 					parentRSNsTables,
1:df88f63: 					childRSN,
1:df88f63: 					whichRC),
1:6718a25: 				opNode.getScopedOperand(
1:6718a25: 					BinaryRelationalOperatorNode.RIGHT,
1:6718a25: 					parentRSNsTables,
1:df88f63: 					childRSN,
1:df88f63: 					whichRC),
1:3bb140c:                 opNode.getForQueryRewrite(),
4:6718a25: 				getContextManager());
1:6718a25: 
1:6718a25: 		// Bind the new op node.
1:6718a25: 		newOpNode.bindComparisonOperator();
1:6718a25: 
1:6718a25: 		// Create and bind a new AND node in CNF form,
1:6718a25: 		// i.e. "<newOpNode> AND TRUE".
1:3bb140c:         AndNode newAnd = new AndNode(newOpNode, trueNode, getContextManager());
1:6718a25: 		newAnd.postBindFixup();
1:6718a25: 
1:6718a25: 		// Categorize the new AND node; among other things, this
1:6718a25: 		// call sets up the new operators's referenced table map,
1:6718a25: 		// which is important for correct pushing of the new
1:6718a25: 		// predicate.
1:6718a25: 		JBitSet tableMap = new JBitSet(
1:6718a25: 			childRSN.getReferencedTableMap().size());
1:6718a25: 		newAnd.categorize(tableMap, false);
1:6718a25: 
1:6718a25: 		// Now put the pieces together to get a new predicate.
1:3bb140c:         Predicate newPred =
1:3bb140c:                 new Predicate(newAnd, tableMap, getContextManager());
1:6718a25: 
1:6718a25: 		// Copy all of this predicates other fields into the new predicate.
1:6718a25: 		newPred.clearScanFlags();
1:6718a25: 		newPred.copyFields(this);
1:6718a25: 		newPred.setPushable(getPushable());
1:6718a25: 
1:6718a25: 		// Take note of the fact that the new predicate is scoped for
1:6718a25: 		// the sake of pushing; we need this information during optimization
1:6718a25: 		// to figure out what we should and should not "pull" back up.
1:6718a25: 		newPred.markAsScopedForPush();
1:6718a25: 		return newPred;
1:6718a25: 	}
1:6718a25: 
1:6718a25: 	/**
1:6718a25: 	 * Indicate that this predicate is a scoped copy of some other
1:6718a25: 	 * predicate (i.e. it was created as the result of a call to
1:6718a25: 	 * getPredScopedForResultSet() on some other predicate).
1:6718a25: 	 */
1:6718a25: 	protected void markAsScopedForPush() {
1:6718a25: 		this.scoped = true;
1:6718a25: 	}
1:6718a25: 
1:6718a25: 	/**
1:6718a25: 	 * Return whether or not this predicate is a scoped copy of
1:6718a25: 	 * another predicate.
1:6718a25: 	 */
1:6718a25: 	protected boolean isScopedForPush() {
1:6718a25: 		return scoped;
1:6718a25: 	}
1:6718a25: 
1:df88f63: 	/**
1:df88f63: 	 * When remapping a "normal" (i.e. non-scoped) predicate both
1:df88f63: 	 * of the predicate's operands are remapped and that's it.
1:df88f63: 	 * But when remapping a scoped predicate, things are slightly
1:df88f63: 	 * different.  This method handles remapping of scoped predicates.
1:df88f63: 	 *
1:df88f63: 	 * We know that, for a scoped predicate, exactly one operand has
1:df88f63: 	 * been scoped for a specific target result set; the other operand
1:df88f63: 	 * is pointing to some other instance of FromTable with which the
1:df88f63: 	 * target result set is to be joined (see getScopedOperand() in
1:df88f63: 	 * BinaryRelationalOperatorNode.java).  For every level of the
1:df88f63: 	 * query through which the scoped predicate is pushed, we have
1:df88f63: 	 * to perform a remap operation of the scoped operand.  We do
1:df88f63: 	 * *not*, however, remap the non-scoped operand.  The reason
1:df88f63: 	 * is that the non-scoped operand is already pointing to the
1:df88f63: 	 * result set against which it must be evaluated.  As the scoped
1:df88f63: 	 * predicate is pushed down the query tree, the non-scoped
1:df88f63: 	 * operand should not change where it's pointing and thus should
1:df88f63: 	 * not be remapped.  For example, assume we have a query whose
1:df88f63: 	 * tree has the following form:
1:df88f63: 	 *
1:df88f63: 	 *               SELECT[0] 
1:df88f63: 	 *                /     \ 
1:df88f63: 	 *              PRN      PRN 
1:df88f63: 	 *               |        |
1:df88f63: 	 *          SELECT[4]   UNION
1:df88f63: 	 *           |           /   \ 
1:df88f63: 	 *          PRN     SELECT[1]  SELECT[2] 
1:df88f63: 	 *           |         |          | 
1:dbed020: 	 *       [FBT:T1]     PRN        PRN 
1:df88f63: 	 *                     |          |
1:dbed020: 	 *                SELECT[3]  [FromBaseTable:T2]
1:df88f63: 	 *                     |
1:df88f63: 	 *                    PRN
1:df88f63: 	 *                     |
1:dbed020: 	 *             [FromBaseTable:T3]
1:df88f63: 	 *
1:df88f63: 	 * Assume also that we have some predicate "SELECT[4].i = <UNION>.j".
1:df88f63: 	 * If the optimizer decides to push the predicate to the UNION
1:df88f63: 	 * node, it (the predicate) will be scoped to the UNION's children,
1:df88f63: 	 * yielding something like "SELECT[4].i = SELECT[1].j" for the
1:df88f63: 	 * left child and "SELECT[4].i = SELECT[2].j" for the right child.
1:df88f63: 	 * These scoped predicates will then be pushed to the PRNs above
1:df88f63: 	 * SELECT[3] and T2, respectively.  As part of that pushing
1:df88f63: 	 * process a call to PRN.pushOptPredicate() will occur, which
1:df88f63: 	 * brings us to this method.  So let's assume we're here for
1:df88f63: 	 * the scoped predicate "SELECT[4].i = SELECT[1].j".  Then we want
1:df88f63: 	 * to remap the scoped operand, "SELECT[1].j", so that it will
1:df88f63: 	 * point to the correct column in "SELECT[3]".  We do NOT, however,
1:df88f63: 	 * want to remap the non-scoped operand "SELECT[4].i" because that
1:df88f63: 	 * operand is already pointing to the correct result set--namely,
1:df88f63: 	 * to a column in SELECT[4].  That non-scoped operand should not
1:df88f63: 	 * change regardless of how far down the UNION subtree the scoped
1:df88f63: 	 * predicate is pushed.
1:df88f63: 	 * 
1:df88f63: 	 * If we did try to remap the non-scoped operand, it would end up
1:df88f63: 	 * pointing to result sets too low in the tree, which could lead to
1:df88f63: 	 * execution-time errors.  So when we remap a scoped predicate, we
1:df88f63: 	 * have to make sure we only remap the scoped operand.  That's what
1:df88f63: 	 * this method does.
1:df88f63: 	 *
1:df88f63: 	 * @return True if this predicate is a scoped predicate, in which
1:df88f63: 	 *  case we performed a one-sided remap.  False if the predicate is
1:df88f63: 	 *  not scoped; the caller can then make the calls to perform a
1:df88f63: 	 *  "normal" remap on this predicate.
1:df88f63: 	 */
1:df88f63: 	protected boolean remapScopedPred()
1:df88f63: 	{
1:df88f63: 		if (!scoped)
1:df88f63: 			return false;
1:df88f63: 
1:df88f63: 		/* Note: right now the only predicates we scope are those
1:df88f63: 		 * which are join predicates and all scoped predicates will
1:df88f63: 		 * have the same relational operator as the predicates from
1:df88f63: 		 * which they were scoped.  Thus if we get here, we know
1:df88f63: 		 * that andNode's leftOperand must be an instance of
1:df88f63: 		 * BinaryRelationalOperatorNode (and therefore the following
1:df88f63: 		 * cast is safe).
1:df88f63: 		 */
1:df88f63: 		BinaryRelationalOperatorNode binRelOp =
1:df88f63: 			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
1:df88f63: 
1:3bb140c:         ValueNode operand;
1:df88f63: 
1:df88f63: 		if (SanityManager.DEBUG)
1:df88f63: 		{
1:df88f63: 			/* If this predicate is scoped then one (and only one) of
1:df88f63: 			 * its operands should be scoped.  Note that it's possible
1:df88f63: 			 * for an operand to be scoped to a non-ColumnReference
1:df88f63: 			 * value; if either operand is not a ColumnReference, then
1:df88f63: 			 * that operand must be the scoped operand.
1:df88f63: 			 */
1:df88f63: 			operand = binRelOp.getLeftOperand();
1:df88f63: 			boolean leftIsScoped =
1:df88f63: 				!(operand instanceof ColumnReference) ||
1:df88f63: 					((ColumnReference)operand).isScoped();
1:df88f63: 
1:df88f63: 			operand = binRelOp.getRightOperand();
1:df88f63: 			boolean rightIsScoped =
1:df88f63: 				!(operand instanceof ColumnReference) ||
1:df88f63: 					((ColumnReference)operand).isScoped();
1:df88f63: 
1:df88f63: 			SanityManager.ASSERT(leftIsScoped ^ rightIsScoped,
1:df88f63: 				"All scoped predicates should have exactly one scoped " +
1:df88f63: 				"operand, but '" + binaryRelOpColRefsToString() +
1:df88f63: 				"' has " + (leftIsScoped ? "TWO" : "NONE") + ".");
1:df88f63: 		}
1:df88f63: 
1:df88f63: 		// Find the scoped operand and remap it.
1:df88f63: 		operand = binRelOp.getLeftOperand();
1:df88f63: 		if ((operand instanceof ColumnReference) &&
1:df88f63: 			((ColumnReference)operand).isScoped())
1:df88f63: 		{
1:df88f63: 			// Left operand is the scoped operand.
1:df88f63: 			((ColumnReference)operand).remapColumnReferences();
1:df88f63: 		}
1:df88f63: 		else
1:df88f63: 		{
1:df88f63: 			operand = binRelOp.getRightOperand();
1:df88f63: 			if ((operand instanceof ColumnReference) &&
1:df88f63: 				((ColumnReference)operand).isScoped())
1:df88f63: 			{
1:df88f63: 				// Right operand is the scoped operand.
1:df88f63: 				((ColumnReference)operand).remapColumnReferences();
1:df88f63: 			}
1:df88f63: 
1:df88f63: 			// Else scoped operand is not a ColumnReference, which
1:df88f63: 			// means it can't (and doesn't need to) be remapped. So
1:df88f63: 			// just fall through and return.
1:df88f63: 		}
1:df88f63: 
1:df88f63: 		return true;
1:df88f63: 	}
1:df88f63: 
1:df88f63: 	/**
1:df88f63: 	 * Return true if this predicate is scoped AND the scoped
1:df88f63: 	 * operand is a ColumnReference that points to a source result
1:df88f63: 	 * set.  If the scoped operand is not a ColumnReference that
1:df88f63: 	 * points to a source result set then it must be pointing to
1:df88f63: 	 * some kind of expression, such as a literal (ex. 'strlit'),
1:df88f63: 	 * an aggregate value (ex. "count(*)"), or the result of a
1:df88f63: 	 * function (ex. "sin(i)") or operator (ex. "i+1").
1:df88f63: 	 *
1:df88f63: 	 * This method is used when pushing predicates to determine how
1:df88f63: 	 * far down the query tree a scoped predicate needs to be pushed
1:df88f63: 	 * to allow for successful evaluation of the scoped operand.  If
1:df88f63: 	 * the scoped operand is not pointing to a source result set
1:df88f63: 	 * then it should not be pushed any further down tree.  The reason
1:df88f63: 	 * is that evaluation of the expression to which the operand is
1:df88f63: 	 * pointing may depend on other values from the current level
1:df88f63: 	 * in the tree (ex. "sin(i)" depends on the value of "i", which
1:df88f63: 	 * could be a column at the predicate's current level).  If we
1:df88f63: 	 * pushed the predicate further down, those values could become
1:df88f63: 	 * inaccessible, leading to execution-time errors.
1:df88f63: 	 *
1:df88f63: 	 * If, on the other hand, the scoped operand *is* pointing to
1:df88f63: 	 * a source result set, then we want to push it further down
1:df88f63: 	 * the tree until it reaches that result set, which allows
1:df88f63: 	 * evaluation of this predicate to occur as close to store as
1:df88f63: 	 * possible.  This method doesn't actually do the push, it just
1:df88f63: 	 * returns "true" and then the caller can push as appropriate.
1:df88f63: 	 */
1:df88f63: 	protected boolean isScopedToSourceResultSet()
1:df88f63: 		throws StandardException
1:df88f63: 	{
1:df88f63: 		if (!scoped)
1:df88f63: 			return false;
1:df88f63: 
1:df88f63: 		/* Note: right now the only predicates we scope are those
1:df88f63: 		 * which are join predicates and all scoped predicates will
1:df88f63: 		 * have the same relational operator as the predicates from
1:df88f63: 		 * which they were scoped.  Thus if we get here, we know
1:df88f63: 		 * that andNode's leftOperand must be an instance of
1:df88f63: 		 * BinaryRelationalOperatorNode (and therefore the following
1:df88f63: 		 * cast is safe).
1:df88f63: 		 */
1:df88f63: 		BinaryRelationalOperatorNode binRelOp =
1:df88f63: 			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
1:df88f63: 
1:df88f63: 		ValueNode operand = binRelOp.getLeftOperand();
1:df88f63: 
1:df88f63: 		/* If operand isn't a ColumnReference then is must be the
1:df88f63: 		 * scoped operand.  This is because both operands have to
1:df88f63: 		 * be column references in order for scoping to occur (as
1:df88f63: 		 * per pushableToSubqueries()) and only the scoped operand
1:df88f63: 		 * can change (esp. can become a non-ColumnReference) as
1:df88f63: 		 * part of the scoping process.  And since it's not a
1:df88f63: 		 * ColumnReference it can't be "a ColumnReference that
1:df88f63: 		 * points to a source result set", so return false.
1:df88f63: 		 */
1:df88f63: 		if (!(operand instanceof ColumnReference))
1:df88f63: 			return false;
1:df88f63: 
1:df88f63: 		/* If the operand is a ColumnReference and is scoped,
1:df88f63: 		 * then see if it is pointing to a ResultColumn whose
1:df88f63: 		 * expression is either another a CR or a Virtual
1:df88f63: 		 * ColumnNode.  If it is then that operand applies
1:df88f63: 		 * to a source result set further down the tree and
1:df88f63: 		 * thus we return true.
1:df88f63: 		 */
1:3bb140c:         ValueNode exp;
1:df88f63: 		ColumnReference cRef = (ColumnReference)operand;
1:df88f63: 		if (cRef.isScoped())
1:df88f63: 		{
1:df88f63: 			exp = cRef.getSource().getExpression();
1:df88f63: 			return ((exp instanceof VirtualColumnNode) ||
1:df88f63: 				(exp instanceof ColumnReference));
1:df88f63: 		}
1:df88f63: 
1:df88f63: 		operand = binRelOp.getRightOperand();
1:df88f63: 		if (!(operand instanceof ColumnReference))
1:df88f63: 			return false;
1:df88f63: 
1:df88f63: 		cRef = (ColumnReference)operand;
1:df88f63: 		if (SanityManager.DEBUG)
1:df88f63: 		{
1:df88f63: 			// If we got here then the left operand was NOT the scoped
1:df88f63: 			// operand; make sure the right one is scoped, then.
1:df88f63: 			SanityManager.ASSERT(cRef.isScoped(),
1:df88f63: 				"All scoped predicates should have exactly one scoped " +
1:df88f63: 				"operand, but '" + binaryRelOpColRefsToString() +
1:df88f63: 				"has NONE.");
1:df88f63: 		}
1:df88f63: 
1:df88f63: 		exp = cRef.getSource().getExpression();
1:df88f63: 		return ((exp instanceof VirtualColumnNode) ||
1:df88f63: 			(exp instanceof ColumnReference));
1:df88f63: 	}
1:1ad3b32: 
1:1ad3b32: 	/**
1:1ad3b32: 	 * Return whether or not this predicate corresponds to a legitimate
1:1ad3b32: 	 * relational operator.
1:1ad3b32: 	 *
1:1ad3b32: 	 * @return False if there is no relational operator for this predicate
1:1ad3b32: 	 *  OR if this predicate is an internal "probe predicate" (in which
1:1ad3b32: 	 *  case it "looks" like we have a relational operator but in truth
1:1ad3b32: 	 *  it's a disguised IN-list operator). True otherwise.
1:1ad3b32: 	 */
1:1ad3b32: 	protected boolean isRelationalOpPredicate()
1:1ad3b32: 	{
1:9d82913: 		/* The isRelationalOperator() method on the ValueNode
1:9d82913: 		 * interface tells us what we need to know, so all we have
1:9d82913: 		 * to do is call that method on the left child of our AND node.
1:9d82913: 		 * Note that BinaryRelationalOperatorNode.isRelationalOperator()
1:9d82913: 		 * includes logic to determine whether or not it (the BRON) is
1:9d82913: 		 * really a disguised IN-list operator--and if so, it will
1:9d82913: 		 * return false (which is what we want).
1:9d82913: 		 */
1:9d82913: 		return andNode.getLeftOperand().isRelationalOperator();
1:1ad3b32: 	}
1:1ad3b32: 
1:1ad3b32: 	/**
1:9d82913: 	 * Return whether or not this predicate is an IN-list probe
1:9d82913: 	 * predicate.
1:9d82913: 	 */
1:9d82913: 	protected boolean isInListProbePredicate()
1:9d82913: 	{
1:9d82913: 		/* The isInListProbeNode() method on the ValueNode interface
1:9d82913: 		 * tells us what we need to know, so all we have to do is call
1:9d82913: 		 * that method on the left child of our AND node.
1:9d82913: 		 */
1:9d82913: 		return andNode.getLeftOperand().isInListProbeNode();
1:9d82913: 	}
1:9d82913: 
1:9d82913: 	/**
1:9d82913: 	 * If this predicate corresponds to an IN-list, return the underlying
1:9d82913: 	 * InListOperatorNode from which it was built.  There are two forms
1:9d82913: 	 * to check for:
1:9d82913: 	 *
1:9d82913: 	 *  1. This predicate is an IN-list "probe predicate", in which case
1:9d82913: 	 *     the underlying InListOpNode is stored within the binary relational
1:9d82913: 	 *     operator that is the left operand of this predicate's AND node.
1:9d82913: 	 *
1:9d82913: 	 *  2. This predicate corresponds to an IN-list that could _not_ be
1:9d82913: 	 *     transformed into a "probe predicate" (i.e. the IN-list contains
1:9d82913: 	 *     one or more non-parameter, non-constant values). In that case
1:9d82913: 	 *     the underlying InListOpNode is simply the left operand of
1:9d82913: 	 *     this predicate's AND node.
1:9d82913: 	 *
1:9d82913: 	 * If this predicate does not correspond to an IN-list in any way,
1:9d82913: 	 * this method will return null.
1:1ad3b32: 	 */
1:1ad3b32: 	protected InListOperatorNode getSourceInList()
1:1ad3b32: 	{
1:9d82913: 		return getSourceInList(false);
1:9d82913: 	}
1:9d82913: 
1:9d82913: 	/**
1:9d82913: 	 * Does the work of getSourceInList() above, but can also be called
1:9d82913: 	 * directly with an argument to indicate whether or not we should
1:9d82913: 	 * limit ourselves to probe predicates.
1:9d82913: 	 *
1:9d82913: 	 * @param probePredOnly If true, only get the source IN list for this
1:9d82913: 	 *   predicate *if* it is an IN-list probe predicate.  If false,
1:9d82913: 	 *   return the underlying InListOperatorNode (if it exists) regardless
1:9d82913: 	 *   of whether this is a probe predicate or an un-transformed IN-list
1:9d82913: 	 *   pred.
1:9d82913: 	 * 
1:9d82913: 	 * @return Underlying InListOp for this predicate (depending on
1:9d82913: 	 *   the value of probePredOnly), or null if this predicate does
1:9d82913: 	 *   not correspond to an IN-list in any way.
1:9d82913: 	 */
1:9d82913: 	protected InListOperatorNode getSourceInList(boolean probePredOnly)
1:9d82913: 	{
1:9d82913: 		ValueNode vn = andNode.getLeftOperand();
1:9d82913: 		if (isInListProbePredicate())
1:9d82913: 			return ((BinaryRelationalOperatorNode)vn).getInListOp();
1:9d82913: 
1:9d82913: 		if (probePredOnly)
1:9d82913: 			return null;
1:9d82913: 
1:9d82913: 		if (vn instanceof InListOperatorNode)
1:9d82913: 			return (InListOperatorNode)vn;
1:9d82913: 
1:1ad3b32: 		return null;
1:1ad3b32: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *       [FBT:T1]     PRN        PRN 
1: 	 *                SELECT[3]  [FromBaseTable:T2]
1: 	 *             [FromBaseTable:T3]
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     private Set<Integer> searchClauses;
/////////////////////////////////////////////////////////////////////////
1:             searchClauses = new HashSet<Integer>();
commit:f6fa942
/////////////////////////////////////////////////////////////////////////
1: 				"isQualifier: " + isQualifier + "\n" +
commit:468162a
/////////////////////////////////////////////////////////////////////////
0: 				referencedSet  + "\n" + "isQualifier: " + isQualifier + "\n" +
commit:df88f63
/////////////////////////////////////////////////////////////////////////
1: 		// If both sides are column references AND they point to different
1: 		// tables, then this is a join pred.
1: 			(opNode.getRightOperand() instanceof ColumnReference) &&
1: 			(((ColumnReference)opNode.getLeftOperand()).getTableNumber() !=
1: 			((ColumnReference)opNode.getRightOperand()).getTableNumber()));
/////////////////////////////////////////////////////////////////////////
1: 	 * @param whichRC If not -1 then this tells us which ResultColumn
1: 	 *  in the received childRSN we need to use for the scoped predicate;
1: 	 *  if -1 then the column position of the scoped column reference
1: 	 *  will be stored in this array and passed back to the caller.
1: 		JBitSet parentRSNsTables, ResultSetNode childRSN,
1: 		int [] whichRC) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 					childRSN,
1: 					whichRC),
1: 					childRSN,
1: 					whichRC),
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * When remapping a "normal" (i.e. non-scoped) predicate both
1: 	 * of the predicate's operands are remapped and that's it.
1: 	 * But when remapping a scoped predicate, things are slightly
1: 	 * different.  This method handles remapping of scoped predicates.
1: 	 *
1: 	 * We know that, for a scoped predicate, exactly one operand has
1: 	 * been scoped for a specific target result set; the other operand
1: 	 * is pointing to some other instance of FromTable with which the
1: 	 * target result set is to be joined (see getScopedOperand() in
1: 	 * BinaryRelationalOperatorNode.java).  For every level of the
1: 	 * query through which the scoped predicate is pushed, we have
1: 	 * to perform a remap operation of the scoped operand.  We do
1: 	 * *not*, however, remap the non-scoped operand.  The reason
1: 	 * is that the non-scoped operand is already pointing to the
1: 	 * result set against which it must be evaluated.  As the scoped
1: 	 * predicate is pushed down the query tree, the non-scoped
1: 	 * operand should not change where it's pointing and thus should
1: 	 * not be remapped.  For example, assume we have a query whose
1: 	 * tree has the following form:
1: 	 *
1: 	 *               SELECT[0] 
1: 	 *                /     \ 
1: 	 *              PRN      PRN 
1: 	 *               |        |
1: 	 *          SELECT[4]   UNION
1: 	 *           |           /   \ 
1: 	 *          PRN     SELECT[1]  SELECT[2] 
1: 	 *           |         |          | 
0: 	 *       <FBT:T1>     PRN        PRN 
1: 	 *                     |          |
0: 	 *                SELECT[3]  <FromBaseTable:T2> 
1: 	 *                     |
1: 	 *                    PRN
1: 	 *                     |
0: 	 *             <FromBaseTable:T3>
1: 	 *
1: 	 * Assume also that we have some predicate "SELECT[4].i = <UNION>.j".
1: 	 * If the optimizer decides to push the predicate to the UNION
1: 	 * node, it (the predicate) will be scoped to the UNION's children,
1: 	 * yielding something like "SELECT[4].i = SELECT[1].j" for the
1: 	 * left child and "SELECT[4].i = SELECT[2].j" for the right child.
1: 	 * These scoped predicates will then be pushed to the PRNs above
1: 	 * SELECT[3] and T2, respectively.  As part of that pushing
1: 	 * process a call to PRN.pushOptPredicate() will occur, which
1: 	 * brings us to this method.  So let's assume we're here for
1: 	 * the scoped predicate "SELECT[4].i = SELECT[1].j".  Then we want
1: 	 * to remap the scoped operand, "SELECT[1].j", so that it will
1: 	 * point to the correct column in "SELECT[3]".  We do NOT, however,
1: 	 * want to remap the non-scoped operand "SELECT[4].i" because that
1: 	 * operand is already pointing to the correct result set--namely,
1: 	 * to a column in SELECT[4].  That non-scoped operand should not
1: 	 * change regardless of how far down the UNION subtree the scoped
1: 	 * predicate is pushed.
1: 	 * 
1: 	 * If we did try to remap the non-scoped operand, it would end up
1: 	 * pointing to result sets too low in the tree, which could lead to
1: 	 * execution-time errors.  So when we remap a scoped predicate, we
1: 	 * have to make sure we only remap the scoped operand.  That's what
1: 	 * this method does.
1: 	 *
1: 	 * @return True if this predicate is a scoped predicate, in which
1: 	 *  case we performed a one-sided remap.  False if the predicate is
1: 	 *  not scoped; the caller can then make the calls to perform a
1: 	 *  "normal" remap on this predicate.
1: 	 */
1: 	protected boolean remapScopedPred()
1: 	{
1: 		if (!scoped)
1: 			return false;
1: 
1: 		/* Note: right now the only predicates we scope are those
1: 		 * which are join predicates and all scoped predicates will
1: 		 * have the same relational operator as the predicates from
1: 		 * which they were scoped.  Thus if we get here, we know
1: 		 * that andNode's leftOperand must be an instance of
1: 		 * BinaryRelationalOperatorNode (and therefore the following
1: 		 * cast is safe).
1: 		 */
1: 		BinaryRelationalOperatorNode binRelOp =
1: 			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
1: 
0: 		ValueNode operand = null;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			/* If this predicate is scoped then one (and only one) of
1: 			 * its operands should be scoped.  Note that it's possible
1: 			 * for an operand to be scoped to a non-ColumnReference
1: 			 * value; if either operand is not a ColumnReference, then
1: 			 * that operand must be the scoped operand.
1: 			 */
1: 			operand = binRelOp.getLeftOperand();
1: 			boolean leftIsScoped =
1: 				!(operand instanceof ColumnReference) ||
1: 					((ColumnReference)operand).isScoped();
1: 
1: 			operand = binRelOp.getRightOperand();
1: 			boolean rightIsScoped =
1: 				!(operand instanceof ColumnReference) ||
1: 					((ColumnReference)operand).isScoped();
1: 
1: 			SanityManager.ASSERT(leftIsScoped ^ rightIsScoped,
1: 				"All scoped predicates should have exactly one scoped " +
1: 				"operand, but '" + binaryRelOpColRefsToString() +
1: 				"' has " + (leftIsScoped ? "TWO" : "NONE") + ".");
1: 		}
1: 
1: 		// Find the scoped operand and remap it.
1: 		operand = binRelOp.getLeftOperand();
1: 		if ((operand instanceof ColumnReference) &&
1: 			((ColumnReference)operand).isScoped())
1: 		{
1: 			// Left operand is the scoped operand.
1: 			((ColumnReference)operand).remapColumnReferences();
1: 		}
1: 		else
1: 		{
1: 			operand = binRelOp.getRightOperand();
1: 			if ((operand instanceof ColumnReference) &&
1: 				((ColumnReference)operand).isScoped())
1: 			{
1: 				// Right operand is the scoped operand.
1: 				((ColumnReference)operand).remapColumnReferences();
1: 			}
1: 
1: 			// Else scoped operand is not a ColumnReference, which
1: 			// means it can't (and doesn't need to) be remapped. So
1: 			// just fall through and return.
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Return true if this predicate is scoped AND the scoped
1: 	 * operand is a ColumnReference that points to a source result
1: 	 * set.  If the scoped operand is not a ColumnReference that
1: 	 * points to a source result set then it must be pointing to
1: 	 * some kind of expression, such as a literal (ex. 'strlit'),
1: 	 * an aggregate value (ex. "count(*)"), or the result of a
1: 	 * function (ex. "sin(i)") or operator (ex. "i+1").
1: 	 *
1: 	 * This method is used when pushing predicates to determine how
1: 	 * far down the query tree a scoped predicate needs to be pushed
1: 	 * to allow for successful evaluation of the scoped operand.  If
1: 	 * the scoped operand is not pointing to a source result set
1: 	 * then it should not be pushed any further down tree.  The reason
1: 	 * is that evaluation of the expression to which the operand is
1: 	 * pointing may depend on other values from the current level
1: 	 * in the tree (ex. "sin(i)" depends on the value of "i", which
1: 	 * could be a column at the predicate's current level).  If we
1: 	 * pushed the predicate further down, those values could become
1: 	 * inaccessible, leading to execution-time errors.
1: 	 *
1: 	 * If, on the other hand, the scoped operand *is* pointing to
1: 	 * a source result set, then we want to push it further down
1: 	 * the tree until it reaches that result set, which allows
1: 	 * evaluation of this predicate to occur as close to store as
1: 	 * possible.  This method doesn't actually do the push, it just
1: 	 * returns "true" and then the caller can push as appropriate.
1: 	 */
1: 	protected boolean isScopedToSourceResultSet()
1: 		throws StandardException
1: 	{
1: 		if (!scoped)
1: 			return false;
1: 
1: 		/* Note: right now the only predicates we scope are those
1: 		 * which are join predicates and all scoped predicates will
1: 		 * have the same relational operator as the predicates from
1: 		 * which they were scoped.  Thus if we get here, we know
1: 		 * that andNode's leftOperand must be an instance of
1: 		 * BinaryRelationalOperatorNode (and therefore the following
1: 		 * cast is safe).
1: 		 */
1: 		BinaryRelationalOperatorNode binRelOp =
1: 			(BinaryRelationalOperatorNode)andNode.getLeftOperand();
1: 
1: 		ValueNode operand = binRelOp.getLeftOperand();
1: 
1: 		/* If operand isn't a ColumnReference then is must be the
1: 		 * scoped operand.  This is because both operands have to
1: 		 * be column references in order for scoping to occur (as
1: 		 * per pushableToSubqueries()) and only the scoped operand
1: 		 * can change (esp. can become a non-ColumnReference) as
1: 		 * part of the scoping process.  And since it's not a
1: 		 * ColumnReference it can't be "a ColumnReference that
1: 		 * points to a source result set", so return false.
1: 		 */
1: 		if (!(operand instanceof ColumnReference))
1: 			return false;
1: 
1: 		/* If the operand is a ColumnReference and is scoped,
1: 		 * then see if it is pointing to a ResultColumn whose
1: 		 * expression is either another a CR or a Virtual
1: 		 * ColumnNode.  If it is then that operand applies
1: 		 * to a source result set further down the tree and
1: 		 * thus we return true.
1: 		 */
0: 		ValueNode exp = null;
1: 		ColumnReference cRef = (ColumnReference)operand;
1: 		if (cRef.isScoped())
1: 		{
1: 			exp = cRef.getSource().getExpression();
1: 			return ((exp instanceof VirtualColumnNode) ||
1: 				(exp instanceof ColumnReference));
1: 		}
1: 
1: 		operand = binRelOp.getRightOperand();
1: 		if (!(operand instanceof ColumnReference))
1: 			return false;
1: 
1: 		cRef = (ColumnReference)operand;
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			// If we got here then the left operand was NOT the scoped
1: 			// operand; make sure the right one is scoped, then.
1: 			SanityManager.ASSERT(cRef.isScoped(),
1: 				"All scoped predicates should have exactly one scoped " +
1: 				"operand, but '" + binaryRelOpColRefsToString() +
1: 				"has NONE.");
1: 		}
1: 
1: 		exp = cRef.getSource().getExpression();
1: 		return ((exp instanceof VirtualColumnNode) ||
1: 			(exp instanceof ColumnReference));
1: 	}
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             searchClauses.contains(ro.getOperator());
/////////////////////////////////////////////////////////////////////////
1:         searchClauses.add(ro.getOperator());
commit:1cb3709
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3541af3
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.Set;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
0:     private Set searchClauses;
/////////////////////////////////////////////////////////////////////////
1:         return searchClauses != null &&
0:             searchClauses.contains(ReuseFactory.getInteger(ro.getOperator()));
/////////////////////////////////////////////////////////////////////////
1:         if (searchClauses == null) {
0:             searchClauses = new HashSet();
1:         }
0:         searchClauses.add(ReuseFactory.getInteger(ro.getOperator()));
/////////////////////////////////////////////////////////////////////////
1:         this.searchClauses = otherPred.searchClauses;
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (andNode != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     ((ColumnReference)opNode.getLeftOperand()).getTableName());
1:             sBuf.append('.');
1:             sBuf.append(
1:                     ((ColumnReference)opNode.getLeftOperand()).getColumnName());
1:         sBuf.append(' ');
1:         sBuf.append(opNode.operator);
1:         sBuf.append(' ');
/////////////////////////////////////////////////////////////////////////
1:                 opNode.kind,
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.store.access.ScanController;
1:                                                         Comparable<Predicate>
/////////////////////////////////////////////////////////////////////////
1:      * Constructor.
1:      * @param cm            The context manager
1:     Predicate(AndNode andNode, JBitSet referencedSet, ContextManager cm)
1:         super(cm);
0:         setNodeType(C_NodeTypes.PREDICATE);
1:         this.andNode = andNode;
1:         this.referencedSet = referencedSet;
/////////////////////////////////////////////////////////////////////////
1:     public int compareTo(Predicate other)
1:         Predicate otherPred = other;
/////////////////////////////////////////////////////////////////////////
1:     AndNode getAndNode()
/////////////////////////////////////////////////////////////////////////
1:     void setAndNode(AndNode andNode)
/////////////////////////////////////////////////////////////////////////
1:     boolean getPushable()
/////////////////////////////////////////////////////////////////////////
1:     void setPushable(boolean pushable) {
/////////////////////////////////////////////////////////////////////////
1:     JBitSet getReferencedSet()
/////////////////////////////////////////////////////////////////////////
1:     void categorize() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     RelationalOperator getRelop()
/////////////////////////////////////////////////////////////////////////
1:     final boolean isOrList()
/////////////////////////////////////////////////////////////////////////
1:     final boolean isStoreQualifier()
/////////////////////////////////////////////////////////////////////////
1:     final boolean isPushableOrClause(Optimizable optTable)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String binaryRelOpColRefsToString()
/////////////////////////////////////////////////////////////////////////
1:         java.lang.StringBuilder sBuf = new java.lang.StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     void copyFields(Predicate otherPred) {
/////////////////////////////////////////////////////////////////////////
1:         ValueNode trueNode = new BooleanConstantNode(true, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             new BinaryRelationalOperatorNode(
/////////////////////////////////////////////////////////////////////////
1:                 opNode.getForQueryRewrite(),
/////////////////////////////////////////////////////////////////////////
1:         AndNode newAnd = new AndNode(newOpNode, trueNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         Predicate newPred =
1:                 new Predicate(newAnd, tableMap, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         ValueNode operand;
/////////////////////////////////////////////////////////////////////////
1:         ValueNode exp;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0: 					Boolean.valueOf(opNode.getForQueryRewrite()),
author:Army
-------------------------------------------------------------------------------
commit:70f168c
/////////////////////////////////////////////////////////////////////////
1: 		/* The call to "isRelationalOpPredicate()" will return false
1: 		 * for a "probe predicate" because a probe predicate is really
1: 		 * a disguised IN list. But when it comes to sorting, the probe
1: 		 * predicate (which is of the form "<col> = ?") should be treated
1: 		 * as an equality--i.e. it should have precedence over any non-
1: 		 * equals predicate, per the comment at the start of this
1: 		 * method.  So that's what we're checking here.
1: 		 */
1: 		if (this.isRelationalOpPredicate() || // this is not "in" or
1: 			this.isInListProbePredicate())    // this is a probe predicate
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if (otherPred.isRelationalOpPredicate() || // other is not "in" or
1: 			otherPred.isInListProbePredicate())    // other is a probe predicate
commit:9d82913
/////////////////////////////////////////////////////////////////////////
1: 		/* The isRelationalOperator() method on the ValueNode
1: 		 * interface tells us what we need to know, so all we have
1: 		 * to do is call that method on the left child of our AND node.
1: 		 * Note that BinaryRelationalOperatorNode.isRelationalOperator()
1: 		 * includes logic to determine whether or not it (the BRON) is
1: 		 * really a disguised IN-list operator--and if so, it will
1: 		 * return false (which is what we want).
1: 		 */
1: 		return andNode.getLeftOperand().isRelationalOperator();
1: 	 * Return whether or not this predicate is an IN-list probe
1: 	 * predicate.
1: 	 */
1: 	protected boolean isInListProbePredicate()
1: 	{
1: 		/* The isInListProbeNode() method on the ValueNode interface
1: 		 * tells us what we need to know, so all we have to do is call
1: 		 * that method on the left child of our AND node.
1: 		 */
1: 		return andNode.getLeftOperand().isInListProbeNode();
1: 	}
1: 
1: 	/**
1: 	 * If this predicate corresponds to an IN-list, return the underlying
1: 	 * InListOperatorNode from which it was built.  There are two forms
1: 	 * to check for:
1: 	 *
1: 	 *  1. This predicate is an IN-list "probe predicate", in which case
1: 	 *     the underlying InListOpNode is stored within the binary relational
1: 	 *     operator that is the left operand of this predicate's AND node.
1: 	 *
1: 	 *  2. This predicate corresponds to an IN-list that could _not_ be
1: 	 *     transformed into a "probe predicate" (i.e. the IN-list contains
1: 	 *     one or more non-parameter, non-constant values). In that case
1: 	 *     the underlying InListOpNode is simply the left operand of
1: 	 *     this predicate's AND node.
1: 	 *
1: 	 * If this predicate does not correspond to an IN-list in any way,
1: 	 * this method will return null.
1: 		return getSourceInList(false);
1: 	}
1: 
1: 	/**
1: 	 * Does the work of getSourceInList() above, but can also be called
1: 	 * directly with an argument to indicate whether or not we should
1: 	 * limit ourselves to probe predicates.
1: 	 *
1: 	 * @param probePredOnly If true, only get the source IN list for this
1: 	 *   predicate *if* it is an IN-list probe predicate.  If false,
1: 	 *   return the underlying InListOperatorNode (if it exists) regardless
1: 	 *   of whether this is a probe predicate or an un-transformed IN-list
1: 	 *   pred.
1: 	 * 
1: 	 * @return Underlying InListOp for this predicate (depending on
1: 	 *   the value of probePredOnly), or null if this predicate does
1: 	 *   not correspond to an IN-list in any way.
1: 	 */
1: 	protected InListOperatorNode getSourceInList(boolean probePredOnly)
1: 	{
1: 		ValueNode vn = andNode.getLeftOperand();
1: 		if (isInListProbePredicate())
1: 			return ((BinaryRelationalOperatorNode)vn).getInListOp();
1: 
1: 		if (probePredOnly)
1: 			return null;
1: 
1: 		if (vn instanceof InListOperatorNode)
1: 			return (InListOperatorNode)vn;
1: 
commit:cbdc90c
/////////////////////////////////////////////////////////////////////////
commit:8380265
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * If this predicate is an IN-list "probe predicate" then "revert"
0: 	 * it back to its original IN-list form.  This turns out to be
0: 	 * very easy: we just set the left operand of andNode to be the
0: 	 * original InListOperatorNode (if non-null).
1: 	 */
0: 	protected void revertToSourceInList()
1: 	{
0: 		InListOperatorNode ilon = getSourceInList();
0: 		if (ilon != null)
0: 			andNode.setLeftOperand(ilon);
0: 		return;
1: 	}
commit:1ad3b32
/////////////////////////////////////////////////////////////////////////
1: 		if (!isRelationalOpPredicate())
/////////////////////////////////////////////////////////////////////////
1: 		if (!isRelationalOpPredicate())
/////////////////////////////////////////////////////////////////////////
1: 		if (isRelationalOpPredicate())
1: 			retval = getRelop().equalsComparisonWithConstantExpression(optTable);
/////////////////////////////////////////////////////////////////////////
0: 		if (this.isRelationalOpPredicate()) // this is not "in"
/////////////////////////////////////////////////////////////////////////
0: 		if (otherPred.isRelationalOpPredicate()) // other is not "in"
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return whether or not this predicate corresponds to a legitimate
1: 	 * relational operator.
1: 	 *
1: 	 * @return False if there is no relational operator for this predicate
1: 	 *  OR if this predicate is an internal "probe predicate" (in which
1: 	 *  case it "looks" like we have a relational operator but in truth
1: 	 *  it's a disguised IN-list operator). True otherwise.
1: 	 */
1: 	protected boolean isRelationalOpPredicate()
1: 	{
0: 		return ((getRelop() != null) && (getSourceInList() == null));
1: 	}
1: 
1: 	/**
0: 	 * If this predicate is an IN-list "probe predicate" then return
0: 	 * the InListOperatorNode from which it was built.  Otherwise
0: 	 * return null.
1: 	 */
1: 	protected InListOperatorNode getSourceInList()
1: 	{
1: 		RelationalOperator relop = getRelop();
0: 		if (relop instanceof BinaryRelationalOperatorNode)
0: 			return ((BinaryRelationalOperatorNode)relop).getInListOp();
1: 		return null;
1: 	}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0be2d6e
/////////////////////////////////////////////////////////////////////////
1:                     if (!((RelationalOperator) or_node.getLeftOperand()).
1:                         isQualifier(optTable, true))
/////////////////////////////////////////////////////////////////////////
1: 	 * Relational operator nodes and 2) have a column reference
1: 	 * on BOTH sides, each of which has a reference to a base
1: 	 * table somewhere beneath it.
/////////////////////////////////////////////////////////////////////////
1: 		if (!isJoinPredicate())
/////////////////////////////////////////////////////////////////////////
1: 		BinaryRelationalOperatorNode opNode =
1: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 * Is this predicate a join predicate?  In order to be so,
1: 	 * it must be a binary relational operator node that has
1: 	 * a column reference on both sides.
1: 	 *
1: 	 * @return Whether or not this is a join predicate.
1: 	 */
1: 	protected boolean isJoinPredicate()
1: 	{
1: 		// If the predicate isn't a binary relational operator,
1: 		// then it's not a join predicate.
1: 		if (!(getAndNode().getLeftOperand()
1: 			instanceof BinaryRelationalOperatorNode))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		BinaryRelationalOperatorNode opNode =
1: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1: 
0: 		// If both sides are column references then this is a join pred.
1: 		return ((opNode.getLeftOperand() instanceof ColumnReference) &&
0: 			(opNode.getRightOperand() instanceof ColumnReference));
1: 	}
1: 
1: 	/**
commit:6eeba4f
/////////////////////////////////////////////////////////////////////////
0: 	 * Relational operator nodes, 2) have a column reference
0: 	 * on BOTH sides, and 3) have column references such that
0: 	 * each column reference has a reference to a base table
0: 	 * somewhere beneath it.
/////////////////////////////////////////////////////////////////////////
0: 		// If either side is not a column reference, we don't push.
0: 		if (!((opNode.getLeftOperand() instanceof ColumnReference) &&
0: 			(opNode.getRightOperand() instanceof ColumnReference)))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		// Make sure both column references ultimately point to base
1: 		// tables.  If, for example, either column reference points to a
1: 		// a literal or an aggregate, then we do not push the predicate.
1: 		// This is because pushing involves remapping the references--
1: 		// but if the reference doesn't have a base table beneath it,
1: 		// the notion of "remapping" it doesn't (seem to) apply.  RESOLVE:
1: 		// it might be okay to make the "remap" operation a no-op for
1: 		// such column references, but it's not clear whether that's
1: 		// always a safe option; further investigation required.
1: 
1: 		JBitSet tNums = new JBitSet(getReferencedSet().size());
1: 		BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNums);
1: 		opNode.getLeftOperand().accept(btnVis);
1: 		if (tNums.getFirstSetBit() == -1)
1: 			return false;
1: 
1: 		tNums.clearAll();
1: 		opNode.getRightOperand().accept(btnVis);
1: 		if (tNums.getFirstSetBit() == -1)
1: 			return false;
1: 
1: 		return true;
commit:6718a25
/////////////////////////////////////////////////////////////////////////
1: 	// Whether or not this predicate has been scoped; see the
1: 	// getPredScopedForResultSet() method of this class for more.
1: 	private boolean scoped;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		scoped = false;
/////////////////////////////////////////////////////////////////////////
1: 	 * Set whether or not this predicate is pushable.  This method
1: 	 * is intended for use when creating a copy of the predicate, ex
1: 	 * for predicate pushdown.  We choose not to add this assignment
1: 	 * to copyFields() because the comments for that method say that
1: 	 * it should copy all fields _except_ the two specified at init
1: 	 * time; "pushable" is one of the two specified at init time.
1: 	 *
1: 	 * @param pushable Whether or not the predicate is pushable.
1: 	 */
0: 	public void setPushable(boolean pushable) {
1: 		this.pushable = pushable;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 			return binaryRelOpColRefsToString() + "\nreferencedSet: " +
1: 				referencedSet  + "\n" + "pushable: " + pushable + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 	 * Get a string version of the column references for this predicate
1: 	 * IF it's a binary relational operator.  We only print out the
1: 	 * names of the operands if they are column references; otherwise
1: 	 * we just print a dummy value.  This is for debugging purposes
1: 	 * only--it's a convenient way to see what columns the predicate
1: 	 * is referencing, especially when tracing through code and printing
1: 	 * assert failure.
1: 	 */
0: 	public String binaryRelOpColRefsToString()
1: 	{
1: 		// We only consider binary relational operators here.
1: 		if (!(getAndNode().getLeftOperand()
1: 			instanceof BinaryRelationalOperatorNode))
1: 		{
1: 			return "";
1: 		}
1: 
1: 		final String DUMMY_VAL = "<expr>";
0: 		java.lang.StringBuffer sBuf = new java.lang.StringBuffer();
1: 		BinaryRelationalOperatorNode opNode =
1: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1: 
1: 		// Get left operand's name.
1: 		if (opNode.getLeftOperand() instanceof ColumnReference)
1: 		{
1: 			sBuf.append(
0: 				((ColumnReference)opNode.getLeftOperand()).getTableName() +
1: 				"." +
0: 				((ColumnReference)opNode.getLeftOperand()).getColumnName()
1: 			);
1: 		}
1: 		else
1: 			sBuf.append(DUMMY_VAL);
1: 
1: 		// Get the operator type.
0: 		sBuf.append(" " + opNode.operator + " ");
1: 
1: 		// Get right operand's name.
1: 		if (opNode.getRightOperand() instanceof ColumnReference) {
1: 			sBuf.append(
1: 				((ColumnReference)opNode.getRightOperand()).getTableName() +
1: 				"." +
1: 				((ColumnReference)opNode.getRightOperand()).getColumnName()
1: 			);
1: 		}
1: 		else
1: 			sBuf.append(DUMMY_VAL);
1: 
1: 		return sBuf.toString();
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Determine whether or not this predicate is eligible for
1: 	 * push-down into subqueries.  Right now the only predicates
1: 	 * we consider to be eligible are those which 1) are Binary
0: 	 * Relational operator nodes, and 2) have a column reference
0: 	 * on BOTH sides.
1: 	 *
1: 	 * @return Whether or not this predicate is eligible to be
1: 	 *  pushed into subqueries.
1: 	 */
1: 	protected boolean pushableToSubqueries()
1: 		throws StandardException
1: 	{
0: 		// If the predicate isn't a binary relational operator,
0: 		// then we don't push it.
1: 		if (!(getAndNode().getLeftOperand()
1: 			instanceof BinaryRelationalOperatorNode))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		BinaryRelationalOperatorNode opNode =
1: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1: 
0: 		return ((opNode.getLeftOperand() instanceof ColumnReference) &&
0: 				(opNode.getRightOperand() instanceof ColumnReference));
1: 	}
1: 
1: 	/**
1: 	 * If this predicate's operator is a BinaryRelationalOperatorNode,
1: 	 * then look at the operands and return a new, equivalent predicate
1: 	 * that is "scoped" to the received ResultSetNode.  By "scoped" we
1: 	 * mean that the operands, which shold be column references, have been
1: 	 * mapped to the appropriate result columns in the received RSN.
1: 	 * This is useful for pushing predicates from outer queries down
1: 	 * into inner queries, in which case the column references need
1: 	 * to be remapped.
1: 	 *
1: 	 * For example, let V1 represent
1: 	 *
1: 	 *    select i,j from t1 UNION select i,j from t2
1: 	 * 
1: 	 * and V2 represent
1: 	 *
1: 	 *    select a,b from t3 UNION select a,b from t4
1: 	 * 
1: 	 * Then assume we have the following query:
1: 	 *
1: 	 *    select * from V1, V2 where V1.j = V2.b
1: 	 *
1: 	 * Let's further assume that this Predicate object represents the
1: 	 * "V1.j = V2.b" operator and that the childRSN we received
1: 	 * as a parameter represents one of the subqueries to which we
1: 	 * want to push the predicate; let's say it's:
1: 	 *
1: 	 *    select i,j from t1
1: 	 *
1: 	 * Then this method will return a new predicate whose binary
1: 	 * operator represents the expression "T1.j = V2.b" (that is, V1.j
1: 	 * will be mapped to the corresponding column in T1).  For more on
1: 	 * how that mapping is made, see the "getScopedOperand()" method
1: 	 * in BinaryRelationalOperatorNode.java.
1: 	 *
1: 	 * ASSUMPTION: We should only get to this method if we know that
1: 	 * at least one operand in this predicate can and should be mapped
1: 	 * to the received childRSN.  For an example of where that check is
1: 	 * made, see the pushOptPredicate() method in SetOperatorNode.java.
1: 	 *
1: 	 * @param parentRSNsTables Set of all table numbers referenced by
1: 	 *  the ResultSetNode that is _parent_ to the received childRSN.
1: 	 *  We need this to make sure we don't scope the operands to a
1: 	 *  ResultSetNode to which they don't apply.
1: 	 * @param childRSN The result set node for which we want to create
1: 	 *  a scoped predicate.
1: 	 * @return A new predicate whose operands have been scoped to the
1: 	 *  received childRSN.
1: 	 */
1: 	protected Predicate getPredScopedForResultSet(
0: 		JBitSet parentRSNsTables, ResultSetNode childRSN)
1: 		throws StandardException
1: 	{
1: 		// We only deal with binary relational operators here.
1: 		if (!(getAndNode().getLeftOperand()
1: 			instanceof BinaryRelationalOperatorNode))
1: 		{
1: 			return this;
1: 		}
1: 
1: 		// The predicate must have an AndNode in CNF, so we
1: 		// need to create an AndNode representing:
1: 		//    <scoped_bin_rel_op> AND TRUE
1: 		// First create the boolean constant for TRUE.
0: 		ValueNode trueNode = (ValueNode) getNodeFactory().getNode(
0: 			C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0: 			Boolean.TRUE,
1: 			getContextManager());
1: 
1: 		BinaryRelationalOperatorNode opNode =
1: 			(BinaryRelationalOperatorNode)getAndNode().getLeftOperand();
1: 
1: 		// Create a new op node with left and right operands that point
1: 		// to the received result set's columns as appropriate.
1: 		BinaryRelationalOperatorNode newOpNode = 
0: 			(BinaryRelationalOperatorNode) getNodeFactory().getNode(
0: 				opNode.getNodeType(),
1: 				opNode.getScopedOperand(
1: 					BinaryRelationalOperatorNode.LEFT,
1: 					parentRSNsTables,
0: 					childRSN),
1: 				opNode.getScopedOperand(
1: 					BinaryRelationalOperatorNode.RIGHT,
1: 					parentRSNsTables,
0: 					childRSN),
1: 				getContextManager());
1: 
1: 		// Bind the new op node.
1: 		newOpNode.bindComparisonOperator();
1: 
1: 		// Create and bind a new AND node in CNF form,
1: 		// i.e. "<newOpNode> AND TRUE".
0: 		AndNode newAnd = (AndNode) getNodeFactory().getNode(
0: 			C_NodeTypes.AND_NODE,
0: 			newOpNode,
0: 			trueNode,
1: 			getContextManager());
1: 		newAnd.postBindFixup();
1: 
1: 		// Categorize the new AND node; among other things, this
1: 		// call sets up the new operators's referenced table map,
1: 		// which is important for correct pushing of the new
1: 		// predicate.
1: 		JBitSet tableMap = new JBitSet(
1: 			childRSN.getReferencedTableMap().size());
1: 		newAnd.categorize(tableMap, false);
1: 
1: 		// Now put the pieces together to get a new predicate.
0: 		Predicate newPred = (Predicate) getNodeFactory().getNode(
0: 			C_NodeTypes.PREDICATE,
0: 			newAnd,
0: 			tableMap,
1: 			getContextManager());
1: 
1: 		// Copy all of this predicates other fields into the new predicate.
1: 		newPred.clearScanFlags();
1: 		newPred.copyFields(this);
1: 		newPred.setPushable(getPushable());
1: 
1: 		// Take note of the fact that the new predicate is scoped for
1: 		// the sake of pushing; we need this information during optimization
1: 		// to figure out what we should and should not "pull" back up.
1: 		newPred.markAsScopedForPush();
1: 		return newPred;
1: 	}
1: 
1: 	/**
1: 	 * Indicate that this predicate is a scoped copy of some other
1: 	 * predicate (i.e. it was created as the result of a call to
1: 	 * getPredScopedForResultSet() on some other predicate).
1: 	 */
1: 	protected void markAsScopedForPush() {
1: 		this.scoped = true;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this predicate is a scoped copy of
1: 	 * another predicate.
1: 	 */
1: 	protected boolean isScopedForPush() {
1: 		return scoped;
1: 	}
1: 
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.Predicate
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.ArrayList;
0: import java.util.Hashtable;
1: 
1: /**
1:  * A Predicate represents a top level predicate.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
1: public final class Predicate extends QueryTreeNode implements OptimizablePredicate,
0: 														Comparable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/* Top of the predicate */
1: 	AndNode		andNode;
1: 	boolean		pushable;
1: 	/* Bit map of referenced tables */
1: 	JBitSet		referencedSet;
1: 	/* Join clauses are placed into equivalence classes when applying transitive
1: 	 * closure for join clauses.  This is useful for eliminating redundant predicates.
1: 	 */
1: 	int			equivalenceClass = -1;
1: 	int			indexPosition;
1: 	protected boolean startKey;
1: 	protected boolean stopKey;
1: 	protected boolean isQualifier;
1: 
1: 	/* Hashtable used for tracking the search clause types that have been
1: 	 * pushed through this predicate (if an equijoin) via transitive closure.
1: 	 */
0: 	private Hashtable searchClauseHT;
1: 
1: 	/**
0: 	 * Initializer.
1: 	 *
1: 	 * @param andNode		The top of the predicate	 
1: 	 * @param referencedSet	Bit map of referenced tables
1: 	 */
1: 
0: 	public void init(Object andNode, Object referencedSet)
1: 	{
0: 		this.andNode = (AndNode) andNode;
1: 		pushable = false;
0: 		this.referencedSet = (JBitSet) referencedSet;
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#getReferencedMap
1: 	 */
1: 	public JBitSet getReferencedMap()
1: 	{
1: 		return referencedSet;
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasSubquery
1: 	 */
1: 	public boolean hasSubquery()
1: 	{
1: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
1: 		 * on whether or not it contains a subquery or method call, but we do not
1: 		 * record the underlying info.
1: 		 */
1: 		return ! pushable;
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasMethodCall
1: 	 */
1: 	public boolean hasMethodCall()
1: 	{
1: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
1: 		 * on whether or not it contains a subquery or method call, but we do not
1: 		 * record the underlying info.
1: 		 */
1: 		return ! pushable;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#markStartKey */
1: 	public void markStartKey()
1: 	{
1: 		startKey = true;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#isStartKey */
1: 	public boolean isStartKey()
1: 	{
1: 		return startKey;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#markStopKey */
1: 	public void markStopKey()
1: 	{
1: 		stopKey = true;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#isStopKey */
1: 	public boolean isStopKey()
1: 	{
1: 		return stopKey;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#markQualifier */
1: 	public void markQualifier()
1: 	{
1: 		isQualifier = true;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#isQualifier */
1: 	public boolean isQualifier()
1: 	{
1: 		return isQualifier;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#compareWithKnownConstant */
1: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
1: 	{
1: 		boolean retval = false;
1: 		RelationalOperator relop = getRelop();
1: 
1: 		/* if this is for "in" operator node's dynamic start/stop key, relop is
1: 		 * null, and it's not comparing with constant, beetle 3858
1: 		 */
0: 		if (relop == null)
0: 			return false;
1: 
1: 		if (relop.compareWithKnownConstant(optTable, considerParameters))
1: 			retval = true;
1: 
1: 		return retval;
1: 	}
1: 
1: 	public int hasEqualOnColumnList(int[] baseColumnPositions,
1: 										Optimizable optTable)
1: 		throws StandardException
1: 	{
1: 		RelationalOperator relop = getRelop();
1: 
0: 		if (relop == null)
1: 			return -1;
1: 		
1: 		if (!(relop.getOperator() == RelationalOperator.EQUALS_RELOP))
1: 			return -1;
1: 			
1: 		for (int i = 0; i < baseColumnPositions.length; i++)
1: 		{
1: 			ColumnReference cr = relop.getColumnOperand(optTable, 
1: 														baseColumnPositions[i]);
1: 		
1: 			if (cr == null)
1: 				continue;
1: 			
1: 			if (relop.selfComparison(cr))
1: 				continue;
1: 
1: 			// If I made it thus far in the loop, we've found
1: 			// something.
1: 			return i;
1: 		}
1: 		
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 	 * @see OptimizablePredicate#getCompareValue
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataValueDescriptor getCompareValue(Optimizable optTable)
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(compareWithKnownConstant(optTable, true),
1: 				"Cannot get the compare value if not comparing with a known constant.");
1: 		}
1: 
1: 		RelationalOperator relop = getRelop();
1: 
1: 		return relop.getCompareValue(optTable);
1: 	}
1: 
1: 	/** @see OptimizablePredicate#equalsComparisonWithConstantExpression */
1: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
1: 	{
1: 		RelationalOperator relop = getRelop();
1: 		boolean retval = false;
1: 
0: 		if (relop != null)
1: 		{
0: 			retval = relop.equalsComparisonWithConstantExpression(optTable);
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	/** @see OptimizablePredicate#selectivity */
1: 	public double selectivity(Optimizable optTable)
1: 	{
1: 		return andNode.getLeftOperand().selectivity(optTable);
1: 	}
1: 
1: 	/** @see OptimizablePredicate#getIndexPosition */
1: 	public int getIndexPosition()
1: 	{
1: 		return indexPosition;
1: 	}
1: 
1: 
1: 	/* Comparable interface */
1: 
0: 	public int compareTo(Object other)
1: 	{
0: 		Predicate	otherPred = (Predicate) other;
1: 
1: 		/* Not all operators are "equal". If the predicates are on the
1: 		 * same key column, then a "=" opertor takes precedence over all
1: 		 * other operators.  This ensures that the "=" will be both the start
1: 		 * and stop predicates.  Otherwise, we could end up with it being one
1: 		 * but not the other and get incorrect results.
1: 		 *
1: 		 * Also, we want "<>" to come after all the other operators.
1: 		 * Other parts of the optimizer use the first predicate on an index
1: 		 * column to determine the cost of using the index, so we want the
1: 		 * "<>" to come last because it's not useful for limiting the scan.
1: 		 *
1: 		 * In other words, P1 is before() P2 if:
1: 		 *		o  The P1.indexPosition < P2.indexPosition
1: 		 *	or  o  P1.indexPosition == P2.indexPosition and
1: 		 *		   P1's operator is ("=" or IS NULL) and
1: 		 *		   P2's operator is not ("=" or IS NULL)
1: 		 * or	o  P1.indexPosition == P2.indexPosition and
1: 		 *		   P1's operator is not ("<>" or IS NOT NULL) and
1: 		 *		   P2's operator is ("<>" or IS NOT NULL)
1: 		 *
1: 		 * (We have to impose an arbitrary, but reproducible ordering
1: 		 * on the the "=" predicates on the same column, otherwise an
1: 		 * ASSERTion, that after the predicates are order, Pn+1 is not
1: 		 * before() Pn, will be violated.
1: 		 */
1: 
1: 		int otherIndexPosition = otherPred.getIndexPosition();
1: 
1: 		if (indexPosition < otherIndexPosition)
1: 			return -1;
1: 
1: 		if (indexPosition > otherIndexPosition)
1: 			return 1;
1: 
1: 		// initialize these flags as if they are for "in" operator, then
1: 		// change them if they are not
1: 		//
1: 		boolean thisIsEquals = false, otherIsEquals = false;
1: 		boolean thisIsNotEquals = true, otherIsNotEquals = true;
1: 
0: 		if (getRelop() != null)		// this is not "in"
1: 		{
1: 			int thisOperator = ((RelationalOperator)andNode.getLeftOperand()).getOperator();
1: 			thisIsEquals = (thisOperator == RelationalOperator.EQUALS_RELOP ||
1: 								thisOperator == RelationalOperator.IS_NULL_RELOP);
1: 			thisIsNotEquals = (thisOperator == RelationalOperator.NOT_EQUALS_RELOP ||
1: 								   thisOperator == RelationalOperator.IS_NOT_NULL_RELOP);
1: 		}
0: 		if (otherPred.getRelop() != null)		// other is not "in"
1: 		{
1: 			int	otherOperator = ((RelationalOperator)(otherPred.getAndNode().getLeftOperand())).getOperator();
1: 			otherIsEquals = (otherOperator == RelationalOperator.EQUALS_RELOP ||
1: 								 otherOperator == RelationalOperator.IS_NULL_RELOP);
1: 			otherIsNotEquals = (otherOperator == RelationalOperator.NOT_EQUALS_RELOP ||
1: 								 otherOperator == RelationalOperator.IS_NOT_NULL_RELOP);
1: 		}
1: 
1: 		boolean thisIsBefore = (thisIsEquals && ! otherIsEquals) || ( ! thisIsNotEquals && otherIsNotEquals);
1: 		if (thisIsBefore)
1: 			return -1;
1: 
1: 		boolean otherIsBefore = (otherIsEquals && ! thisIsEquals) || ( ! otherIsNotEquals && thisIsNotEquals);
1: 		if (otherIsBefore)
1: 			return 1;
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Return the andNode.
1: 	 *
1: 	 * @return AndNode	The andNode.
1: 	 */
0: 	public AndNode getAndNode()
1: 	{
1: 		return andNode;
1: 	}
1: 
1: 	/**
1: 	 * Set the andNode.
1: 	 *
1: 	 * @param andNode	The new andNode.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setAndNode(AndNode andNode)
1: 	{
1: 		this.andNode = andNode;
1: 	}
1: 
1: 	/**
1: 	 * Return the pushable.
1: 	 *
1: 	 * @return boolean	Whether or not the predicate is pushable.
1: 	 */
0: 	public boolean getPushable()
1: 	{
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Return the referencedSet.
1: 	 *
1: 	 * @return JBitSet	The referencedSet.
1: 	 */
0: 	public JBitSet getReferencedSet()
1: 	{
1: 		return referencedSet;
1: 	}
1: 
1: 	/**
1: 	 * Set the equivalence class, if any, for this predicate.
1: 	 *
1: 	 * @param equivalenceClass	The equivalence class for this predicate.
1: 	 *
0: 	 * @return	Nothing.
1: 	 */
1: 	void setEquivalenceClass(int equivalenceClass)
1: 	{
1: 		this.equivalenceClass = equivalenceClass;
1: 	}
1: 
1: 	/**
1: 	 * Get the equivalenceClass for this predicate.
1: 	 *
1: 	 * @return The equivalenceClass for this predicate.
1: 	 */
1: 	int getEquivalenceClass()
1: 	{
1: 		return equivalenceClass;
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 *
0: 	 * @return None.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void categorize() throws StandardException
1: 	{
1: 		pushable = andNode.categorize(referencedSet, false);
1: 	}
1: 
1: 	/**
1: 	 * Get the RelationalOperator on the left side of the AND node, if
1: 	 * there is one.  If the left side is not a RelationalOperator, return
1: 	 * null.
1: 	 *
1: 	 * @return	The RelationalOperator on the left side of the AND node,
1: 	 *			if any.
1: 	 */
0: 	public RelationalOperator getRelop()
1: 	{
1: 		
1: 		if (andNode.getLeftOperand() instanceof RelationalOperator)
1: 		{
1: 			return (RelationalOperator) andNode.getLeftOperand();
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
0: 	public final boolean isOrList()
1:     {
1:         return(andNode.getLeftOperand() instanceof OrNode);
1:     }
1: 
1:     /**
1:      * Is this predicate a possible Qualifier for store?
1:      * <p>
1:      * Current 2 types of predicates can be pushed to store: 
1:      *   1) RelationalOperator - 
1:      *      represented with by left operand as instance of RelationalOperator.
1:      *   2) A single And'd term of a list of OR terms
1:      *      represented by left operand as instance of OrNode.
1:      *
1:      * More checking specific operator's terms to see if they are finally
1:      * pushable to store.  In the final push at execution each term of the AND 
1:      * or OR must be a Relational operator with a column reference on one side 
1:      * and a constant on the other.
1:      *
1:      *
1: 	 * @return true if term is wither a AND of a RelationalOperator, or an
1:      *              OR of one or more Relational Operators.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	public final boolean isStoreQualifier()
1:     {
1: 		if ((andNode.getLeftOperand() instanceof RelationalOperator) ||
1: 		    (andNode.getLeftOperand() instanceof OrNode))
1: 		{
1:             return(true);
1: 		}
1: 		else
1: 		{
1:             return(false);
1: 		}
1:     }
1: 
1:     /**
1:      * Is this predicate an pushable OR list?
1:      * <p>
1:      * Does the predicate represent a AND'd list of OR term's, all of which
1:      * are pushable.  To be pushable each of OR terms must be a legal 
1:      * qualifier, which is a column reference on one side of a Relational
1:      * operator and a constant on the other.
1:      *
1: 	 * @return true if the predicate is a pushable set of OR clauses.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	public final boolean isPushableOrClause(Optimizable optTable)
1:         throws StandardException
1: 	{
1:         boolean ret_val = true;
1: 
1:         if (andNode.getLeftOperand() instanceof OrNode)
1:         {
1:             QueryTreeNode node = andNode.getLeftOperand();
1: 
1:             while (node instanceof OrNode)
1:             {
1:                 OrNode or_node = (OrNode) node;
1: 
1:                 if (or_node.getLeftOperand() instanceof RelationalOperator)
1:                 {
1:                     // if any term of the OR clause is not a qualifier, then
1:                     // reject the entire OR clause.
0:                     if (!((RelationalOperator) or_node.getLeftOperand()).isQualifier(optTable))
1:                     {
1:                         // one of the terms is not a pushable Qualifier.
1:                         return(false);
1:                     }
1: 
1:                     node = or_node.getRightOperand();
1:                 }
1:                 else
1:                 {
1:                     // one of the terms is not a RelationalOperator
1: 
1:                     return(false);
1:                 }
1:             }
1: 
1:             return(true);
1:         }
1:         else
1:         {
1:             // Not an OR list
1:             return(false);
1:         }
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this predicate has been used
1: 	 * to add a new search clause of the specified type via transitive closure.
1: 	 * NOTE: This can only be true if this is an equijoin
1: 	 * between 2 column references.
1: 	 *
1: 	 * @param ro	The search clause that we are currently considering
1: 	 *				as the source for transitive closure
1: 	 *
1: 	 * @return	Whether or not this predicate has been used
1: 	 *			to add a new search clause of the specified type via transitive 
1:      *			closure.
1: 	 */
1: 	boolean transitiveSearchClauseAdded(RelationalOperator ro)
1: 	{
0: 		if (searchClauseHT == null || 
0: 			searchClauseHT.get(new Integer(ro.getOperator())) == null)
1: 		{
0: 			return false;
1: 		}
1: 		else
1: 		{
0: 			return true;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Mark this predicate as having been used to add a new predicate
1: 	 * of the specified type via transitive closure on search clauses.
1: 	 *
1: 	 * @param ro	The search clause that we are currently considering
1: 	 *				as the source for transitive closure
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void setTransitiveSearchClauseAdded(RelationalOperator ro)
1: 	{
0: 		if (searchClauseHT == null)
1: 		{
0: 			searchClauseHT = new Hashtable();
1: 		}
1: 		/* I have to remember that this ro has been added to this predicate as a
1: 		 * transitive search clause.
1: 		 */
0: 		Integer i = new Integer(ro.getOperator());
0: 		searchClauseHT.put(i, i);
1: 	}
1: 
1: 	/**
1: 	 * Get the start operator for this predicate for a scan.
1: 	 *
1: 	 * @param optTable	The optimizable table, so we can tell which side of
1: 	 *					the operator the search column is on.
1: 	 *
1: 	 * @return	The start operator for a start key on this column.
1: 	 */
1: 	int getStartOperator(Optimizable optTable)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(startKey, "Getting a start operator from a Predicate that's not a start key.");
1: 		}
1: 
1: 		/* if it's for "in" operator's dynamic start key, operator is GE,
1: 		 * beetle 3858
1: 		 */
1: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
1: 			return ScanController.GE;
1: 
1: 		return getRelop().getStartOperator(optTable);
1: 	}
1: 
1: 	int getStopOperator(Optimizable optTable)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(stopKey, "Getting a stop operator from a Predicate that's not a stop key.");
1: 		}
1: 
1: 		 /* if it's for "in" operator's dynamic stop key, operator is GT,
1: 		  * beetle 3858
1: 		  */
1: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
1: 			return ScanController.GT;
1: 
1: 		return getRelop().getStopOperator(optTable);
1: 	}
1: 
1: 	/**
1: 	 * Set the position of the index column that this predicate restricts
1: 	 *
1: 	 * @param indexPosition	The position of the index column that this
1: 	 *						predicate restricts.
1: 	 */
1: 	void setIndexPosition(int indexPosition)
1: 	{
1: 		this.indexPosition = indexPosition;
1: 	}
1: 
1: 	/**
1: 	 * Clear the start/stop position and qualifier flags
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void clearScanFlags()
1: 	{
1: 		startKey = false;
1: 		stopKey = false;
1: 		isQualifier = false;
1: 	}
1: 
1: 	/**
0: 	 * Clear the qualifier flag.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void clearQualifierFlag()
1: 	{
1: 		isQualifier = false;
1: 	}
1: 
1: 	void generateExpressionOperand(Optimizable optTable,
1: 										int columnPosition,
1: 										ExpressionClassBuilder acb,
1: 										MethodBuilder mb)
1: 				throws StandardException
1: 	{
1: 		getRelop().generateExpressionOperand(optTable,
1: 													columnPosition,
1: 													acb,
1: 													mb);
1: 	}
1: 
0: 	void generateAbsoluteColumnId(MethodBuilder mb,
1: 										Optimizable optTable)
1: 	{
0: 		getRelop().generateAbsoluteColumnId(mb, optTable);
1: 	}
1: 
0: 	void generateRelativeColumnId(MethodBuilder mb,
1: 										Optimizable optTable)
1: 	{
0: 		getRelop().generateRelativeColumnId(mb, optTable);
1: 	}
1: 
0: 	void generateOperator(MethodBuilder mb,
1: 								Optimizable optTable)
1: 	{
0: 		getRelop().generateOperator(mb, optTable);
1: 	}
1: 
0: 	void generateQualMethod(ExpressionClassBuilder acb,
0: 								MethodBuilder mb,
1: 								Optimizable optTable)
1: 					throws StandardException
1: 	{
0: 		getRelop().generateQualMethod(acb, mb, optTable);
1: 	}
1: 
0: 	void generateOrderedNulls(MethodBuilder mb)
1: 	{
0: 		getRelop().generateOrderedNulls(mb);
1: 	}
1: 
0: 	void generateNegate(MethodBuilder mb,
1: 								Optimizable optTable)
1: 	{
0: 		getRelop().generateNegate(mb, optTable);
1: 	}
1: 
0: 	void generateOrderableVariantType(MethodBuilder mb,
1: 								Optimizable optTable)
1: 					throws StandardException
1: 	{
0: 		int variantType = getRelop().getOrderableVariantType(optTable);
0: 		mb.push(variantType);
1: 
1: 	}
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "referencedSet: " + referencedSet  + "\n" +
0: 			   "pushable: " + pushable + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			printLabel(depth, "andNode: ");
1: 			andNode.treePrint(depth + 1);
1: 			super.printSubNodes(depth);
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (andNode != null && !v.stopTraversal())
1: 		{
1: 			andNode = (AndNode)andNode.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: 
1: 	/**
1: 	 * Copy all fields of this Predicate (except the two that
1: 	 * are set from 'init').
1: 	 *
1: 	 */
1: 
0: 	public void copyFields(Predicate otherPred) {
1: 
1: 		this.equivalenceClass = otherPred.getEquivalenceClass();
1: 		this.indexPosition = otherPred.getIndexPosition();
1: 		this.startKey = otherPred.isStartKey();
1: 		this.stopKey = otherPred.isStopKey();
1: 		this.isQualifier = otherPred.isQualifier();
0: 		this.searchClauseHT = otherPred.getSearchClauseHT();
1: 
1: 	}
1: 
1: 	/**
0: 	 * Get the search clause Hash Table.
1: 	 */
1: 
0: 	public Hashtable getSearchClauseHT() {
0: 		return searchClauseHT;
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.ArrayList;
0: import java.util.Hashtable;
0: 
0: /**
0:  * A Predicate represents a top level predicate.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public final class Predicate extends QueryTreeNode implements OptimizablePredicate,
0: 														Comparable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* Top of the predicate */
0: 	AndNode		andNode;
0: 	boolean		pushable;
0: 	/* Bit map of referenced tables */
0: 	JBitSet		referencedSet;
0: 	/* Join clauses are placed into equivalence classes when applying transitive
0: 	 * closure for join clauses.  This is useful for eliminating redundant predicates.
0: 	 */
0: 	int			equivalenceClass = -1;
0: 	int			indexPosition;
0: 	protected boolean startKey;
0: 	protected boolean stopKey;
0: 	protected boolean isQualifier;
0: 
0: 	/* Hashtable used for tracking the search clause types that have been
0: 	 * pushed through this predicate (if an equijoin) via transitive closure.
0: 	 */
0: 	private Hashtable searchClauseHT;
0: 
0: 	/**
0: 	 * Initializer.
0: 	 *
0: 	 * @param andNode		The top of the predicate	 
0: 	 * @param referencedSet	Bit map of referenced tables
0: 	 */
0: 
0: 	public void init(Object andNode, Object referencedSet)
0: 	{
0: 		this.andNode = (AndNode) andNode;
0: 		pushable = false;
0: 		this.referencedSet = (JBitSet) referencedSet;
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#getReferencedMap
0: 	 */
0: 	public JBitSet getReferencedMap()
0: 	{
0: 		return referencedSet;
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasSubquery
0: 	 */
0: 	public boolean hasSubquery()
0: 	{
0: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
0: 		 * on whether or not it contains a subquery or method call, but we do not
0: 		 * record the underlying info.
0: 		 */
0: 		return ! pushable;
0: 	}
0: 
0: 	/**
0: 	 * @see org.apache.derby.iapi.sql.compile.OptimizablePredicate#hasMethodCall
0: 	 */
0: 	public boolean hasMethodCall()
0: 	{
0: 		/* RESOLVE - Currently, we record whether or not a predicate is pushable based
0: 		 * on whether or not it contains a subquery or method call, but we do not
0: 		 * record the underlying info.
0: 		 */
0: 		return ! pushable;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#markStartKey */
0: 	public void markStartKey()
0: 	{
0: 		startKey = true;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#isStartKey */
0: 	public boolean isStartKey()
0: 	{
0: 		return startKey;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#markStopKey */
0: 	public void markStopKey()
0: 	{
0: 		stopKey = true;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#isStopKey */
0: 	public boolean isStopKey()
0: 	{
0: 		return stopKey;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#markQualifier */
0: 	public void markQualifier()
0: 	{
0: 		isQualifier = true;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#isQualifier */
0: 	public boolean isQualifier()
0: 	{
0: 		return isQualifier;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#compareWithKnownConstant */
0: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
0: 	{
0: 		boolean retval = false;
0: 		RelationalOperator relop = getRelop();
0: 
0: 		/* if this is for "in" operator node's dynamic start/stop key, relop is
0: 		 * null, and it's not comparing with constant, beetle 3858
0: 		 */
0: 		if (relop == null)
0: 			return false;
0: 
0: 		if (relop.compareWithKnownConstant(optTable, considerParameters))
0: 			retval = true;
0: 
0: 		return retval;
0: 	}
0: 
0: 	public int hasEqualOnColumnList(int[] baseColumnPositions,
0: 										Optimizable optTable)
0: 		throws StandardException
0: 	{
0: 		RelationalOperator relop = getRelop();
0: 
0: 		if (relop == null)
0: 			return -1;
0: 		
0: 		if (!(relop.getOperator() == RelationalOperator.EQUALS_RELOP))
0: 			return -1;
0: 			
0: 		for (int i = 0; i < baseColumnPositions.length; i++)
0: 		{
0: 			ColumnReference cr = relop.getColumnOperand(optTable, 
0: 														baseColumnPositions[i]);
0: 		
0: 			if (cr == null)
0: 				continue;
0: 			
0: 			if (relop.selfComparison(cr))
0: 				continue;
0: 
0: 			// If I made it thus far in the loop, we've found
0: 			// something.
0: 			return i;
0: 		}
0: 		
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 	 * @see OptimizablePredicate#getCompareValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor getCompareValue(Optimizable optTable)
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(compareWithKnownConstant(optTable, true),
0: 				"Cannot get the compare value if not comparing with a known constant.");
0: 		}
0: 
0: 		RelationalOperator relop = getRelop();
0: 
0: 		return relop.getCompareValue(optTable);
0: 	}
0: 
0: 	/** @see OptimizablePredicate#equalsComparisonWithConstantExpression */
0: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
0: 	{
0: 		RelationalOperator relop = getRelop();
0: 		boolean retval = false;
0: 
0: 		if (relop != null)
0: 		{
0: 			retval = relop.equalsComparisonWithConstantExpression(optTable);
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/** @see OptimizablePredicate#selectivity */
0: 	public double selectivity(Optimizable optTable)
0: 	{
0: 		return andNode.getLeftOperand().selectivity(optTable);
0: 	}
0: 
0: 	/** @see OptimizablePredicate#getIndexPosition */
0: 	public int getIndexPosition()
0: 	{
0: 		return indexPosition;
0: 	}
0: 
0: 
0: 	/* Comparable interface */
0: 
0: 	public int compareTo(Object other)
0: 	{
0: 		Predicate	otherPred = (Predicate) other;
0: 
0: 		/* Not all operators are "equal". If the predicates are on the
0: 		 * same key column, then a "=" opertor takes precedence over all
0: 		 * other operators.  This ensures that the "=" will be both the start
0: 		 * and stop predicates.  Otherwise, we could end up with it being one
0: 		 * but not the other and get incorrect results.
0: 		 *
0: 		 * Also, we want "<>" to come after all the other operators.
0: 		 * Other parts of the optimizer use the first predicate on an index
0: 		 * column to determine the cost of using the index, so we want the
0: 		 * "<>" to come last because it's not useful for limiting the scan.
0: 		 *
0: 		 * In other words, P1 is before() P2 if:
0: 		 *		o  The P1.indexPosition < P2.indexPosition
0: 		 *	or  o  P1.indexPosition == P2.indexPosition and
0: 		 *		   P1's operator is ("=" or IS NULL) and
0: 		 *		   P2's operator is not ("=" or IS NULL)
0: 		 * or	o  P1.indexPosition == P2.indexPosition and
0: 		 *		   P1's operator is not ("<>" or IS NOT NULL) and
0: 		 *		   P2's operator is ("<>" or IS NOT NULL)
0: 		 *
0: 		 * (We have to impose an arbitrary, but reproducible ordering
0: 		 * on the the "=" predicates on the same column, otherwise an
0: 		 * ASSERTion, that after the predicates are order, Pn+1 is not
0: 		 * before() Pn, will be violated.
0: 		 */
0: 
0: 		int otherIndexPosition = otherPred.getIndexPosition();
0: 
0: 		if (indexPosition < otherIndexPosition)
0: 			return -1;
0: 
0: 		if (indexPosition > otherIndexPosition)
0: 			return 1;
0: 
0: 		// initialize these flags as if they are for "in" operator, then
0: 		// change them if they are not
0: 		//
0: 		boolean thisIsEquals = false, otherIsEquals = false;
0: 		boolean thisIsNotEquals = true, otherIsNotEquals = true;
0: 
0: 		if (getRelop() != null)		// this is not "in"
0: 		{
0: 			int thisOperator = ((RelationalOperator)andNode.getLeftOperand()).getOperator();
0: 			thisIsEquals = (thisOperator == RelationalOperator.EQUALS_RELOP ||
0: 								thisOperator == RelationalOperator.IS_NULL_RELOP);
0: 			thisIsNotEquals = (thisOperator == RelationalOperator.NOT_EQUALS_RELOP ||
0: 								   thisOperator == RelationalOperator.IS_NOT_NULL_RELOP);
0: 		}
0: 		if (otherPred.getRelop() != null)		// other is not "in"
0: 		{
0: 			int	otherOperator = ((RelationalOperator)(otherPred.getAndNode().getLeftOperand())).getOperator();
0: 			otherIsEquals = (otherOperator == RelationalOperator.EQUALS_RELOP ||
0: 								 otherOperator == RelationalOperator.IS_NULL_RELOP);
0: 			otherIsNotEquals = (otherOperator == RelationalOperator.NOT_EQUALS_RELOP ||
0: 								 otherOperator == RelationalOperator.IS_NOT_NULL_RELOP);
0: 		}
0: 
0: 		boolean thisIsBefore = (thisIsEquals && ! otherIsEquals) || ( ! thisIsNotEquals && otherIsNotEquals);
0: 		if (thisIsBefore)
0: 			return -1;
0: 
0: 		boolean otherIsBefore = (otherIsEquals && ! thisIsEquals) || ( ! otherIsNotEquals && thisIsNotEquals);
0: 		if (otherIsBefore)
0: 			return 1;
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Return the andNode.
0: 	 *
0: 	 * @return AndNode	The andNode.
0: 	 */
0: 	public AndNode getAndNode()
0: 	{
0: 		return andNode;
0: 	}
0: 
0: 	/**
0: 	 * Set the andNode.
0: 	 *
0: 	 * @param andNode	The new andNode.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setAndNode(AndNode andNode)
0: 	{
0: 		this.andNode = andNode;
0: 	}
0: 
0: 	/**
0: 	 * Return the pushable.
0: 	 *
0: 	 * @return boolean	Whether or not the predicate is pushable.
0: 	 */
0: 	public boolean getPushable()
0: 	{
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Return the referencedSet.
0: 	 *
0: 	 * @return JBitSet	The referencedSet.
0: 	 */
0: 	public JBitSet getReferencedSet()
0: 	{
0: 		return referencedSet;
0: 	}
0: 
0: 	/**
0: 	 * Set the equivalence class, if any, for this predicate.
0: 	 *
0: 	 * @param equivalenceClass	The equivalence class for this predicate.
0: 	 *
0: 	 * @return	Nothing.
0: 	 */
0: 	void setEquivalenceClass(int equivalenceClass)
0: 	{
0: 		this.equivalenceClass = equivalenceClass;
0: 	}
0: 
0: 	/**
0: 	 * Get the equivalenceClass for this predicate.
0: 	 *
0: 	 * @return The equivalenceClass for this predicate.
0: 	 */
0: 	int getEquivalenceClass()
0: 	{
0: 		return equivalenceClass;
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 *
0: 	 * @return None.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void categorize() throws StandardException
0: 	{
0: 		pushable = andNode.categorize(referencedSet, false);
0: 	}
0: 
0: 	/**
0: 	 * Get the RelationalOperator on the left side of the AND node, if
0: 	 * there is one.  If the left side is not a RelationalOperator, return
0: 	 * null.
0: 	 *
0: 	 * @return	The RelationalOperator on the left side of the AND node,
0: 	 *			if any.
0: 	 */
0: 	public RelationalOperator getRelop()
0: 	{
0: 		
0: 		if (andNode.getLeftOperand() instanceof RelationalOperator)
0: 		{
0: 			return (RelationalOperator) andNode.getLeftOperand();
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
0: 
0: 	public final boolean isOrList()
0:     {
0:         return(andNode.getLeftOperand() instanceof OrNode);
0:     }
0: 
0:     /**
0:      * Is this predicate a possible Qualifier for store?
0:      * <p>
0:      * Current 2 types of predicates can be pushed to store: 
0:      *   1) RelationalOperator - 
0:      *      represented with by left operand as instance of RelationalOperator.
0:      *   2) A single And'd term of a list of OR terms
0:      *      represented by left operand as instance of OrNode.
0:      *
0:      * More checking specific operator's terms to see if they are finally
0:      * pushable to store.  In the final push at execution each term of the AND 
0:      * or OR must be a Relational operator with a column reference on one side 
0:      * and a constant on the other.
0:      *
0:      *
0: 	 * @return true if term is wither a AND of a RelationalOperator, or an
0:      *              OR of one or more Relational Operators.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public final boolean isStoreQualifier()
0:     {
0: 		if ((andNode.getLeftOperand() instanceof RelationalOperator) ||
0: 		    (andNode.getLeftOperand() instanceof OrNode))
0: 		{
0:             return(true);
0: 		}
0: 		else
0: 		{
0:             return(false);
0: 		}
0:     }
0: 
0:     /**
0:      * Is this predicate an pushable OR list?
0:      * <p>
0:      * Does the predicate represent a AND'd list of OR term's, all of which
0:      * are pushable.  To be pushable each of OR terms must be a legal 
0:      * qualifier, which is a column reference on one side of a Relational
0:      * operator and a constant on the other.
0:      *
0: 	 * @return true if the predicate is a pushable set of OR clauses.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public final boolean isPushableOrClause(Optimizable optTable)
0:         throws StandardException
0: 	{
0:         boolean ret_val = true;
0: 
0:         if (andNode.getLeftOperand() instanceof OrNode)
0:         {
0:             QueryTreeNode node = andNode.getLeftOperand();
0: 
0:             while (node instanceof OrNode)
0:             {
0:                 OrNode or_node = (OrNode) node;
0: 
0:                 if (or_node.getLeftOperand() instanceof RelationalOperator)
0:                 {
0:                     // if any term of the OR clause is not a qualifier, then
0:                     // reject the entire OR clause.
0:                     if (!((RelationalOperator) or_node.getLeftOperand()).isQualifier(optTable))
0:                     {
0:                         // one of the terms is not a pushable Qualifier.
0:                         return(false);
0:                     }
0: 
0:                     node = or_node.getRightOperand();
0:                 }
0:                 else
0:                 {
0:                     // one of the terms is not a RelationalOperator
0: 
0:                     return(false);
0:                 }
0:             }
0: 
0:             return(true);
0:         }
0:         else
0:         {
0:             // Not an OR list
0:             return(false);
0:         }
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this predicate has been used
0: 	 * to add a new search clause of the specified type via transitive closure.
0: 	 * NOTE: This can only be true if this is an equijoin
0: 	 * between 2 column references.
0: 	 *
0: 	 * @param ro	The search clause that we are currently considering
0: 	 *				as the source for transitive closure
0: 	 *
0: 	 * @return	Whether or not this predicate has been used
0: 	 *			to add a new search clause of the specified type via transitive 
0:      *			closure.
0: 	 */
0: 	boolean transitiveSearchClauseAdded(RelationalOperator ro)
0: 	{
0: 		if (searchClauseHT == null || 
0: 			searchClauseHT.get(new Integer(ro.getOperator())) == null)
0: 		{
0: 			return false;
0: 		}
0: 		else
0: 		{
0: 			return true;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Mark this predicate as having been used to add a new predicate
0: 	 * of the specified type via transitive closure on search clauses.
0: 	 *
0: 	 * @param ro	The search clause that we are currently considering
0: 	 *				as the source for transitive closure
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void setTransitiveSearchClauseAdded(RelationalOperator ro)
0: 	{
0: 		if (searchClauseHT == null)
0: 		{
0: 			searchClauseHT = new Hashtable();
0: 		}
0: 		/* I have to remember that this ro has been added to this predicate as a
0: 		 * transitive search clause.
0: 		 */
0: 		Integer i = new Integer(ro.getOperator());
0: 		searchClauseHT.put(i, i);
0: 	}
0: 
0: 	/**
0: 	 * Get the start operator for this predicate for a scan.
0: 	 *
0: 	 * @param optTable	The optimizable table, so we can tell which side of
0: 	 *					the operator the search column is on.
0: 	 *
0: 	 * @return	The start operator for a start key on this column.
0: 	 */
0: 	int getStartOperator(Optimizable optTable)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(startKey, "Getting a start operator from a Predicate that's not a start key.");
0: 		}
0: 
0: 		/* if it's for "in" operator's dynamic start key, operator is GE,
0: 		 * beetle 3858
0: 		 */
0: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
0: 			return ScanController.GE;
0: 
0: 		return getRelop().getStartOperator(optTable);
0: 	}
0: 
0: 	int getStopOperator(Optimizable optTable)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(stopKey, "Getting a stop operator from a Predicate that's not a stop key.");
0: 		}
0: 
0: 		 /* if it's for "in" operator's dynamic stop key, operator is GT,
0: 		  * beetle 3858
0: 		  */
0: 		if (andNode.getLeftOperand() instanceof InListOperatorNode)
0: 			return ScanController.GT;
0: 
0: 		return getRelop().getStopOperator(optTable);
0: 	}
0: 
0: 	/**
0: 	 * Set the position of the index column that this predicate restricts
0: 	 *
0: 	 * @param indexPosition	The position of the index column that this
0: 	 *						predicate restricts.
0: 	 */
0: 	void setIndexPosition(int indexPosition)
0: 	{
0: 		this.indexPosition = indexPosition;
0: 	}
0: 
0: 	/**
0: 	 * Clear the start/stop position and qualifier flags
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void clearScanFlags()
0: 	{
0: 		startKey = false;
0: 		stopKey = false;
0: 		isQualifier = false;
0: 	}
0: 
0: 	/**
0: 	 * Clear the qualifier flag.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void clearQualifierFlag()
0: 	{
0: 		isQualifier = false;
0: 	}
0: 
0: 	void generateExpressionOperand(Optimizable optTable,
0: 										int columnPosition,
0: 										ExpressionClassBuilder acb,
0: 										MethodBuilder mb)
0: 				throws StandardException
0: 	{
0: 		getRelop().generateExpressionOperand(optTable,
0: 													columnPosition,
0: 													acb,
0: 													mb);
0: 	}
0: 
0: 	void generateAbsoluteColumnId(MethodBuilder mb,
0: 										Optimizable optTable)
0: 	{
0: 		getRelop().generateAbsoluteColumnId(mb, optTable);
0: 	}
0: 
0: 	void generateRelativeColumnId(MethodBuilder mb,
0: 										Optimizable optTable)
0: 	{
0: 		getRelop().generateRelativeColumnId(mb, optTable);
0: 	}
0: 
0: 	void generateOperator(MethodBuilder mb,
0: 								Optimizable optTable)
0: 	{
0: 		getRelop().generateOperator(mb, optTable);
0: 	}
0: 
0: 	void generateQualMethod(ExpressionClassBuilder acb,
0: 								MethodBuilder mb,
0: 								Optimizable optTable)
0: 					throws StandardException
0: 	{
0: 		getRelop().generateQualMethod(acb, mb, optTable);
0: 	}
0: 
0: 	void generateOrderedNulls(MethodBuilder mb)
0: 	{
0: 		getRelop().generateOrderedNulls(mb);
0: 	}
0: 
0: 	void generateNegate(MethodBuilder mb,
0: 								Optimizable optTable)
0: 	{
0: 		getRelop().generateNegate(mb, optTable);
0: 	}
0: 
0: 	void generateOrderableVariantType(MethodBuilder mb,
0: 								Optimizable optTable)
0: 					throws StandardException
0: 	{
0: 		int variantType = getRelop().getOrderableVariantType(optTable);
0: 		mb.push(variantType);
0: 
0: 	}
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "referencedSet: " + referencedSet  + "\n" +
0: 			   "pushable: " + pushable + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			printLabel(depth, "andNode: ");
0: 			andNode.treePrint(depth + 1);
0: 			super.printSubNodes(depth);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (andNode != null && !v.stopTraversal())
0: 		{
0: 			andNode = (AndNode)andNode.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: 
0: 	/**
0: 	 * Copy all fields of this Predicate (except the two that
0: 	 * are set from 'init').
0: 	 *
0: 	 */
0: 
0: 	public void copyFields(Predicate otherPred) {
0: 
0: 		this.equivalenceClass = otherPred.getEquivalenceClass();
0: 		this.indexPosition = otherPred.getIndexPosition();
0: 		this.startKey = otherPred.isStartKey();
0: 		this.stopKey = otherPred.isStopKey();
0: 		this.isQualifier = otherPred.isQualifier();
0: 		this.searchClauseHT = otherPred.getSearchClauseHT();
0: 
0: 	}
0: 
0: 	/**
0: 	 * Get the search clause Hash Table.
0: 	 */
0: 
0: 	public Hashtable getSearchClauseHT() {
0: 		return searchClauseHT;
0: 	}
0: 
0: }
============================================================================