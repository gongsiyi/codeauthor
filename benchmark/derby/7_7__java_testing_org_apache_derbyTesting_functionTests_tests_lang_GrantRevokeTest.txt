2:97734e3: /*
11:97734e3: 
1:97734e3: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest
1:97734e3: 
1:97734e3: Licensed to the Apache Software Foundation (ASF) under one or more
1:97734e3: contributor license agreements.  See the NOTICE file distributed with
1:97734e3: this work for additional information regarding copyright ownership.
1:97734e3: The ASF licenses this file to You under the Apache License, Version 2.0
1:97734e3: (the "License"); you may not use this file except in compliance with
1:97734e3: the License.  You may obtain a copy of the License at
1:97734e3: 
1:97734e3: http://www.apache.org/licenses/LICENSE-2.0
1:97734e3: 
1:97734e3: Unless required by applicable law or agreed to in writing, software
1:97734e3: distributed under the License is distributed on an "AS IS" BASIS,
1:97734e3: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:97734e3: See the License for the specific language governing permissions and
1:97734e3: limitations under the License.
1:97734e3: 
2:97734e3: */
1:97734e3: 
1:97734e3: package org.apache.derbyTesting.functionTests.tests.lang;
1:97734e3: 
1:f3110ed: import java.sql.CallableStatement;
1:97734e3: import java.sql.Connection;
1:97734e3: import java.sql.DatabaseMetaData;
1:97734e3: import java.sql.PreparedStatement;
1:97734e3: import java.sql.ResultSet;
1:97734e3: import java.sql.SQLException;
1:97734e3: import java.sql.Statement;
1:97734e3: import java.sql.Types;
1:97734e3: import java.util.ArrayList;
1:f1512cd: import java.util.Locale;
1:1ae02c9: import junit.framework.Test;
1:97734e3: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:97734e3: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:97734e3: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:97734e3: import org.apache.derbyTesting.junit.JDBC;
1:97734e3: import org.apache.derbyTesting.junit.TestConfiguration;
1:97734e3: 
1:97734e3: /**
1:97734e3:  * Test SQL GRANT and REVOKE statements
1:97734e3:  */
1:97734e3: public class GrantRevokeTest extends BaseJDBCTestCase {
1:97734e3: 
1:97734e3: 	public GrantRevokeTest(String name) {
1:97734e3: 		super(name);
15:97734e3: 	}
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * The set of users available for grant/revoke testing
1:97734e3: 	 */
1:97734e3: 	public final static String[] users = new String[] { "TEST_DBO","U1","U2","U3","U4"};
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * Most tests run in embedded only, since they are only checking DDL
1:97734e3: 	 * statements. Metadata methods test also runs in client/server mode.
1:97734e3: 	 */
1:97734e3: 	public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite();
1:97734e3: 		
1:97734e3: 		// following is useful for debugging the lock timeout seen in rollback tests,
1:97734e3: 		// can connect via network server and look at the lock table.
1:97734e3: 		//suite.addTest(TestConfiguration.clientServerDecorator(basesuite()));
1:97734e3: 		
1:97734e3: 		suite.addTest(basesuite());
1:97734e3: 		suite.addTest(TestConfiguration.clientServerDecorator(new GrantRevokeTest("testGrantDatabaseMetaDataMethods")));
1:97734e3: 
1:97734e3: 		return suite;
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * One set of grant/revoke tests for either client/server or embedded.
1:97734e3: 	 */
1:97734e3: 	public static Test basesuite() {
1:1ae02c9:         Test test = new BaseTestSuite(GrantRevokeTest.class);
1:1fec7db: 
1:1fec7db:         // DERBY-6238: Dump the contents of the lock table on lock timeout.
1:1fec7db:         // Helps debug intermittent lock timeouts seen in the test.
1:1fec7db:         test = DatabasePropertyTestSetup.singleProperty(
1:1fec7db:                 test, "derby.locks.deadlockTrace", "true");
1:1fec7db: 
1:1fec7db:         test = new CleanDatabaseTestSetup(test) {
1:97734e3: 	    	protected void decorateSQL(Statement s) throws SQLException {
1:97734e3: 	    		s.execute("create schema s1");
1:97734e3: 	    		s.execute("create schema s2");
1:97734e3: 	    		s.execute("create table s1.t1(c1 int, c2 int, c3 int)");
1:97734e3: 	    		s.execute("create table s2.t1(c1 int, c2 int, c3 int)");
1:97734e3: 	    		s.execute("create table s2.t2(c1 int, c2 int, c3 int)");
1:97734e3: 	    		s.execute("create table s2.t3(c1 int, c2 int, c3 int)");
1:97734e3: 	    	    s.execute("create table s2.noPerms(c1 int, c2 int, c3 int)");
1:97734e3: 	    	    s.execute("create function s1.f1() returns int" +
1:97734e3: 	    	        "  language java parameter style java" +
1:97734e3: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1F1'" +
1:97734e3: 	    	        "  no sql called on null input");
1:97734e3: 	    	    /*
1:97734e3: 	    	     * RESOLVE Derby does not implement SPECIFIC names
1:97734e3: 	    	       
1:97734e3: 	    	       s.execute("create function s2.f1() returns int" +
1:97734e3:                              "  specific s2.s2sp1" +
1:97734e3: 	    	                 "  language java parameter style java" +
1:97734e3: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1a'" +
1:97734e3: 	    	                 "  no sql called on null input");
1:97734e3: 	    	     * RESOLVE Derby doesn't seem to support function overloading. It doesn't allow us to create two
1:97734e3: 	    	     * functions with the same name but different signatures. (Though the StaticMethodCallNode.bindExpression
1:97734e3: 	    	     * method does have code to handle overloaded methods). So we cannot throughly test
1:97734e3: 	    	     * grant/revoke on overloaded procedures.
1:97734e3: 	    	        	         
1:97734e3: 	    	       s.execute("create function s2.f1( p1 char(8)) returns int" +
1:97734e3: 	    	                 "  language java parameter style java" +
1:97734e3: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1b'" +
1:97734e3: 	    	                 "  no sql called on null input");
1:97734e3: 	    	       s.execute("create function s2.f1( char(8), char(8)) returns int" +
1:97734e3: 	    	                 "  language java parameter style java" +
1:97734e3: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1c'" +
1:97734e3: 	    	                 "  no sql called on null input");
1:97734e3: 	    	       s.execute("create function s2.f1( int) returns int" +
1:97734e3: 	    	                 "  language java parameter style java" +
1:97734e3: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1d'" +
1:97734e3: 	    	                 "  no sql called on null input");
1:97734e3: 	    	      
1:97734e3: 	    	       NOTE: This function definition does not match the s2F2() definition
1:97734e3: 	    	             in this class, and thus is not used.
1:97734e3: 	    	       s.execute("create function s2.f2( p1 char(8), p2 integer) returns int" +
1:97734e3: 	    	                 "  language java parameter style java" +
1:97734e3: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s2F2'" +
1:97734e3: 	    	                 "  no sql called on null input");
1:97734e3:                  */
1:97734e3: 	    	   
1:97734e3: 	    	   // functions and procedures are supposed to have separate name spaces. Make sure that this does
1:97734e3: 	    	   // not confuse grant/revoke.
1:97734e3: 	    	   s.execute("create procedure s1.f1( )" +
1:97734e3: 	    	        "  language java parameter style java" +
1:97734e3: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1F1P'" +
1:97734e3: 	    	        "  no sql called on null input");
1:97734e3: 	    	   s.execute("create procedure s1.p1( )" +
1:97734e3: 	    	        "  language java parameter style java" +
1:97734e3: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1P1'" +
1:97734e3: 	    	        "  no sql called on null input");
1:7bfb37a: 
1:7bfb37a: 
1:7bfb37a:                // DERBY-5292: Definer's rights in views
1:7bfb37a:                s.execute("create schema appl");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE TABLE appl.\"TBL_Tasks\"" +
1:7bfb37a:                    "(\"TaskID\" integer NOT NULL " +
1:7bfb37a:                    "                    GENERATED ALWAYS AS IDENTITY," +
1:7bfb37a:                    " \"Task\" varchar(64) NOT NULL," +
1:7bfb37a:                    " \"AssignedTo\" varchar(64) NOT NULL," +
1:7bfb37a:                    "CONSTRAINT \"PK_Tasks\" PRIMARY KEY (\"TaskID\"))");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE TABLE appl.\"TBL_Priorities\"" +
1:7bfb37a:                    "(\"TaskID\" integer NOT NULL," +
1:7bfb37a:                    " \"Priority\" integer NOT NULL," +
1:7bfb37a:                    " \"SeqNbr\" integer NOT NULL," +
1:7bfb37a:                    "CONSTRAINT \"PK_Priorities\" PRIMARY KEY " +
1:7bfb37a:                    "  (\"TaskID\", \"Priority\"))");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE VIEW appl.\"VW_MyTasks\" AS " +
1:7bfb37a:                    "    SELECT * FROM appl.\"TBL_Tasks\" " +
1:7bfb37a:                    "WHERE \"AssignedTo\" = SESSION_USER");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE VIEW appl.\"VW_MyPriorityTasks\" AS " +
1:7bfb37a:                    "    SELECT t.\"TaskID\", t.\"Task\", p.\"Priority\"" +
1:7bfb37a:                    "    FROM appl.\"TBL_Tasks\" AS t," +
1:7bfb37a:                    "         appl.\"TBL_Priorities\" AS p " +
1:7bfb37a:                    "    WHERE p.\"TaskID\" = t.\"TaskID\" " +
1:7bfb37a:                    "          AND t.\"AssignedTo\" = SESSION_USER");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE VIEW appl.\"VW2_MyPriorityTasks\" AS " +
1:7bfb37a:                    "    SELECT t.\"TaskID\", t.\"Task\", p.\"Priority\" " +
1:7bfb37a:                    "    FROM appl.\"TBL_Tasks\" AS t INNER JOIN " +
1:7bfb37a:                    "         appl.\"TBL_Priorities\" AS p ON " +
1:7bfb37a:                    "         p.\"TaskID\" = t.\"TaskID\" " +
1:7bfb37a:                    "    WHERE t.\"AssignedTo\" = SESSION_USER");
1:7bfb37a:                s.execute(
1:7bfb37a:                    "CREATE VIEW appl.\"VW3_MyPriorityTasks\" AS " +
1:7bfb37a:                    "    SELECT t.\"TaskID\", t.\"Task\" " +
1:7bfb37a:                    "    FROM appl.\"TBL_Tasks\" AS t " +
1:7bfb37a:                    "    WHERE t.\"AssignedTo\" = SESSION_USER " +
1:7bfb37a:                    "    AND EXISTS " +
1:7bfb37a:                    "        (SELECT * FROM appl.\"TBL_Priorities\" AS p " +
1:7bfb37a:                    "         WHERE p.\"TaskID\" = t.\"TaskID\")");
1:97734e3: 	    	}
1:97734e3: 	    };
1:1fec7db:         test = DatabasePropertyTestSetup.builtinAuthentication(
1:1fec7db:                 test, users, "grantrevoke");
1:97734e3:         test = TestConfiguration.sqlAuthorizationDecorator(test);
1:97734e3: 	    
1:97734e3: 	    return test;
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	public void testSimpleGrant() throws Exception {
1:97734e3: 		grant("select", "s1", "t1", users[1]);
1:97734e3: 		assertSelectPrivilege(true, users[1], "s1", "t1", null);
2:97734e3: 		assertSelectPrivilege(false, users[2], "s1", "t1", null);
1:65fd9e9: 		assertSelectPrivilege(false, users[2], "s2", "t1", null);
1:65fd9e9: 		assertSelectPrivilege(false, users[2], "s2", "t2", null);
1:97734e3: 		revoke("select", "s1", "t1", users[1]);
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	public void testAllPrivileges() throws Exception {
1:97734e3: 		grant("all privileges", "s2", "t1", new String[] {users[2], users[3]});
1:97734e3: 		assertAllPrivileges(false, users[1], "S2", "T1", null);
1:97734e3: 		assertAllPrivileges(true, users[2], "S2", "T1", null);
1:97734e3: 		assertAllPrivileges(true, users[3], "S2", "T1", null);
1:97734e3: 		assertSelectPrivilege(false, users[1], "s1", "t1", null);
1:97734e3: 		assertSelectPrivilege(false, users[1], "s2", "t2", null);
1:97734e3: 		revoke("all privileges", "s2", "t1", new String[] {users[2], users[3]});
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	public void testColumnPrivileges() throws Exception {
1:97734e3: 		grant("select(c1),update(c3,c2),references(c3,c1,c2)", "s1", "t1", users[4]);
1:97734e3: 		assertSelectPrivilege(true, users[4], "s1", "t1", new String[] {"c1"});
1:97734e3: 		assertSelectPrivilege(false, users[4], "s1", "t1", new String[] {"c2"});
1:97734e3: 		assertSelectPrivilege(false, users[4], "s1", "t1", new String[] {"c3"});
1:97734e3: 		assertSelectPrivilege(false, users[4], "s1", "t1", null);
1:97734e3: 		assertUpdatePrivilege(false, users[4], "S1", "T1", new String[] {"C1"});
1:1ea5dac: 		assertUpdatePrivilege(true, users[4], "S1", "T1", new String[] {"C2", "C3"});
1:97734e3: 		assertReferencesPrivilege(true, users[4], "s1", "t1", new String[] {"c1","c2","c3"});
1:97734e3: 		revoke("select(c1),update(c3,c2),references(c3,c1,c2)", "s1", "t1", users[4]);
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	public void testFunctionWithSameProcedureName() throws Exception {
1:97734e3: 		grant("execute", "function s1", "f1", users[1]);
1:97734e3: 		assertFunctionPrivilege( true, users[1], "S1", "F1", false);
1:97734e3: 		assertProcedurePrivilege( false, users[1], "S1", "F1");
1:97734e3: 		assertFunctionPrivilege( false, users[2], "S1", "F1", false);
1:97734e3: 		revoke("execute", "function s1", "f1", users[1]);
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	public void testGrantOnProcedure() throws Exception {
1:97734e3: 		grant("execute", "procedure s1", "p1", users[1]);
1:97734e3: 		assertProcedurePrivilege( true, users[1], "S1", "P1");
1:97734e3: 		assertFunctionPrivilege( false, users[1], "S1", "P1", true);
1:97734e3: 		assertProcedurePrivilege( false, users[2], "S1", "P1");
1:97734e3: 		assertFunctionPrivilege( false, users[2], "S1", "P1", true);
1:97734e3: 		revoke("execute", "procedure s1", "p1", users[1]);
1:97734e3: 	}
1:97734e3: 	
1:97734e3:     public void testPublicTablePrivileges() throws Exception {
1:97734e3:     	grant("select, references(c1)", "s2", "t2", "public");
1:97734e3:     	assertSelectPrivilege(true, users[4], "S2", "T2", null);
1:97734e3:         assertSelectPrivilege(true, users[1], "S2", "T2", null);
1:97734e3:         assertSelectPrivilege(false, users[4], "S2", "NOPERMS", null);
1:97734e3:         assertUpdatePrivilege(false, users[4], "S2", "T2", null);
1:97734e3:         assertReferencesPrivilege(true, users[4], "S2", "T2",
1:97734e3:                                  new String[] {"C1"});
1:97734e3:         assertReferencesPrivilege(false, users[4], "S2", "T2", null);
1:97734e3:     	revoke("select, references(c1)", "s2", "t2", "public");
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testPublicRoutinePrivileges() throws Exception {
1:97734e3:         grant("execute", "procedure s1", "p1", "public");
1:97734e3:         grant("execute", "procedure s1", "p1", users[1]);        
1:97734e3: 		assertProcedurePrivilege(true, users[1], "S1", "P1");
1:97734e3: 		assertProcedurePrivilege(true, users[4], "S1", "P1");
1:97734e3:         revoke("execute", "procedure s1", "p1", "public");
1:97734e3:         // user1 should still have execute privilege
1:97734e3:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:97734e3:         assertProcedurePrivilege(false, users[4], "S1", "P1");
1:97734e3:         revoke("execute", "procedure s1", "p1", users[1]);
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3:     }
1:97734e3: 
1:97734e3:     /**
1:97734e3:      * Test grant statements before, during, and after a rolled-back
1:97734e3:      * transaction
1:97734e3:      */
1:97734e3:     public void testGrantRollbackAndCommit() throws SQLException {
1:97734e3:     
1:97734e3:     	// NOTE: grantrevoke.java originally used S2.F2 for the function
1:97734e3:     	// below, but the signature on the function didn't match the
1:97734e3:     	// declaration, so was not used properly. Have substituted
1:97734e3:     	// function S1.F1 here to get the testcase to pass.
1:97734e3:     	
1:97734e3:     	// NOTE 2: executing the grant statements on the owner connection
1:97734e3:     	//         leads to a lock timeout when asserting any privilege?
1:97734e3:     	
1:97734e3:     	Connection oc = openUserConnection(users[0]);
1:97734e3:     	oc.setAutoCommit(false);
1:97734e3:     	
1:97734e3:     	// set up some privileges and check them
1:97734e3:     	grant(oc, "select", "s2", "t2", "public");
1:97734e3:     	oc.commit();
1:97734e3: 
1:97734e3:         assertSelectPrivilege(true, users[3], "S2", "T2", null);
1:97734e3:         assertUpdatePrivilege(false, users[3], "S2", "T2", null);
1:97734e3:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:97734e3:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:     	
1:97734e3:     	// alter some privileges, assert that they were granted.
1:97734e3:         grant(oc, "select(c2),delete", "s2", "t3", users[1]);
1:97734e3:         grant(oc, "trigger", "s2", "t2", "public");
1:97734e3:     	grant(oc, "execute", "function s1", "f1", users[1]);
1:97734e3:         // the following asserts fail due to lock timeout
1:97734e3:     	//assertSelectPrivilege(true, users[1], "s2", "t3", new String[] {"C2"});
1:97734e3:         //assertDeletePrivilege(true, users[1], "s2", "t3");
1:97734e3:         //assertTriggerPrivilege(true, users[2], "S2", "T2");
1:97734e3:         //assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         
1:97734e3:         // roll it back and assert the privileges were not granted.
1:97734e3:         oc.rollback();
1:97734e3:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:97734e3:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:         
1:97734e3:         // do it again... 
1:97734e3:         grant(oc, "select(c2),delete", "s2", "t3", users[1]);
1:97734e3:         grant(oc, "trigger", "s2", "t2", "public");
1:97734e3:     	grant(oc, "execute", "function s1", "f1", users[1]);
1:97734e3:         // the following asserts fail due to lock timeout
1:97734e3:     	//assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C2"});
1:97734e3:         //assertDeletePrivilege(true, users[1], "S2", "T3");
1:97734e3:         //assertTriggerPrivilege(true, users[2], "S2", "T2");
1:97734e3:         //assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         
1:97734e3:         // commit and ensure the permissions are correct
1:97734e3:         oc.commit();
1:97734e3:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C2"});
1:97734e3:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:97734e3:         assertTriggerPrivilege( true, users[2], "S2", "T2");
1:97734e3:         assertFunctionPrivilege( true, users[1], "S1", "F1", false);
1:97734e3:        
1:97734e3:     	// remove any permissions we granted
1:97734e3:     	revoke(oc, "select", "s2", "t2", "public");
1:97734e3:     	revoke(oc, "select(c2),delete", "s2", "t3", users[1]);
1:97734e3:         revoke(oc, "trigger", "s2", "t2", "public");
1:97734e3:     	revoke(oc, "execute", "function s1", "f1", users[1]);
1:97734e3:     	oc.commit();
1:97734e3:     	oc.setAutoCommit(false);
1:97734e3:         assertSelectPrivilege(false, users[3], "S2", "T2", null);
1:97734e3:         assertUpdatePrivilege(false, users[3], "S2", "T2", null);
1:97734e3:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:97734e3:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:     	
1:97734e3:     	oc.close();
1:97734e3:     	
1:97734e3:     }
1:97734e3: 	/**
1:97734e3: 	 * Test Grant/Revoke related DatabaseMetaData methods.
1:97734e3: 	 */
1:97734e3:     public void testGrantDatabaseMetaDataMethods() throws Exception{
1:97734e3:     	DatabaseMetaData dm = getConnection().getMetaData();
1:97734e3:     	assertFalse("GrantRevoke: DatabaseMetaData.supportsCatalogsInPrivilegeDefinitionSupport", dm.supportsCatalogsInPrivilegeDefinitions());
1:97734e3:     	assertTrue("GrantRevoke: DatabaseMetaData.supportsSchemasInPrivilegeDefinitions", dm.supportsSchemasInPrivilegeDefinitions());
1:97734e3:     }
1:97734e3:     
1:97734e3:     /* Revoke test methods begin here */
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Test revoke statements when user already has no permissions.
1:97734e3:      */
1:97734e3:     public void testRevokeWithNoPermissions() throws Exception {
1:97734e3:         // assert users don't already have these privileges.
1:97734e3:     	assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(false, users[2], "S1", "T1", new String[] {"C2"});
1:97734e3:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3:         
1:97734e3:         // no unexpected exception should be thrown revoking these privileges.
1:97734e3:         revoke("all privileges", "s1", "t1", users[1]);
1:97734e3:     	assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(false, users[1], "S1", "T1", new String[] {"C2"});
1:97734e3:         revoke("execute", "procedure s1", "p1", users[1]);
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3:         revoke("select(c2), update(c1,c3)", "s1", "t1", users[2]);
1:97734e3:         assertSelectPrivilege(false, users[2], "S1", "T1", new String[] {"C2"});
1:97734e3:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C3"});  
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testRevokeSingleTableSingleUser() throws Exception {
1:97734e3:     	grant("all privileges", "s2", "t1", users[1]);
1:97734e3:         grant("update(c3)", "s2", "t1", users[1]);
1:97734e3:         assertSelectPrivilege(true, users[1], "S2", "T1", null);
1:97734e3:         assertUpdatePrivilege(true, users[1], "S2", "T1", new String[] {"C3"});  
1:97734e3:         
1:97734e3:         revoke("update", "S2", "t1", users[1]);
1:97734e3:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:97734e3:         assertUpdatePrivilege( false, users[1], "S2", "T1", null);
1:97734e3:         assertUpdatePrivilege( false, users[1], "S2", "T1", new String[] {"C3"});
1:97734e3:         assertInsertPrivilege( true, users[1], "S2", "T1", null);
1:97734e3:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:97734e3:         assertReferencesPrivilege( true, users[1], "S2", "T1", null);
1:97734e3:         assertTriggerPrivilege( true, users[1], "S2", "T1");
1:97734e3:         
1:97734e3:         revoke("all privileges", "s2", "t1", users[1]);
1:97734e3:         assertAllPrivileges(false, users[1], "S2", "T1", null);
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testRevokeMultiplePermissionsMultipleUsers() throws SQLException {
1:97734e3:     	grant("select", "s1", "t1", new String[] {users[1], users[2], users[3]});
1:97734e3:     	grant("update(c1,c2,c3)", "s1", "t1", users[1]);
1:97734e3:     	grant("update(c3)", "s1", "t1", users[2]);
1:97734e3:     	grant("trigger", "s1", "t1", users[1]);
1:97734e3:         assertSelectPrivilege(true, users[1], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(true, users[2], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(true, users[3], "S1", "T1", null);
1:97734e3:         // DatabaseMetaData.getTablePrivileges() returns false for the following
1:97734e3:         // due to column privileges for table being used, so assert
1:97734e3:         // with null for columns is disabled
1:97734e3:         //assertUpdatePrivilege(true, users[1], "S1", "T1", null);  
1:97734e3:         assertUpdatePrivilege(true, users[1], "S1", "T1", new String[] {"C1", "C2", "C3" }); 
1:97734e3:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C2"});
1:97734e3:         assertUpdatePrivilege(true, users[2], "S1", "T1", new String[] {"C3"});
1:97734e3:         assertTriggerPrivilege(true, users[1], "S1", "T1");
1:97734e3:         assertTriggerPrivilege(false, users[2], "S1", "T1");
1:97734e3:         
1:97734e3:         revoke("select, update(c2,c3)", "s1", "t1", new String[] {users[1], users[2], users[3]});
1:97734e3:         assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(false, users[2], "S1", "T1", null);
1:97734e3:         assertSelectPrivilege(false, users[3], "S1", "T1", null);
1:97734e3:         assertUpdatePrivilege(true, users[1], "S1", "T1", new String[] {"C1"});  
1:97734e3:         assertUpdatePrivilege(false, users[1], "S1", "T1", new String[] {"C2", "C3"});
1:97734e3:         assertUpdatePrivilege(false, users[2], "S1", "T1", null);
1:97734e3:         assertTriggerPrivilege(true, users[1], "S1", "T1");
1:97734e3:         assertTriggerPrivilege(false, users[2], "S1", "T1");
1:97734e3:        
1:97734e3:         revoke("update", "s1", "t1", users[1]);
1:97734e3:         assertUpdatePrivilege(false, users[1], "S1", "T1", new String[] {"C1"});  
1:97734e3:         assertUpdatePrivilege(false, users[1], "S1", "T1", null);
1:97734e3:      
1:97734e3:         revoke("all privileges", "s1", "t1", users[1]);
1:97734e3:         assertAllPrivileges(false, users[1], "S1", "T1", null);
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testRevokeExecutePrivileges() throws Exception {
1:97734e3:     	grant("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:97734e3:         grant("execute", "procedure s1", "f1", users[1]);
1:97734e3:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertProcedurePrivilege(true, users[1], "S1", "F1");
1:97734e3:         
1:97734e3:         revoke("execute", "function s1", "f1", users[1]);
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertProcedurePrivilege(true, users[1], "S1", "F1");
1:97734e3:         
1:97734e3:         grant("execute", "function s1", "f1", users[1]);
1:97734e3:         revoke("execute", "procedure s1", "f1", users[1]);
1:97734e3:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "F1");
1:97734e3:         
1:97734e3:     	revoke("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(false, users[2], "S1", "F1", false);
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "F1");
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testRevokeWithPublicPrivilege() throws Exception {
1:97734e3:         grant("select, delete", "s2", "t1", "public");
1:97734e3:         grant("select, delete", "s2", "t1", new String[] {users[1], users[2]});
1:97734e3:         grant("update(c1,c3)", "s2", "t1", "public");
1:97734e3:         grant("update(c1,c3)", "s2", "t1", new String[] {users[1], users[2]});
1:97734e3:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege( true, users[2], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege( true, users[4], "S2", "T1", null);
1:97734e3:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:97734e3:         assertDeletePrivilege( true, users[2], "S2", "T1");
1:97734e3:         assertDeletePrivilege( true, users[4], "S2", "T1");
1:97734e3:         assertUpdatePrivilege( true, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege( true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege( true, users[4], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3: 
1:97734e3:         // revoke from user, should still be able to access via public privilege
1:97734e3:         revoke("select, update(c1,c3), delete", "S2", "T1", users[1]);
1:97734e3:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege( true, users[2], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege( true, users[4], "S2", "T1", null);
1:97734e3:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:97734e3:         assertDeletePrivilege( true, users[2], "S2", "T1");
1:97734e3:         assertDeletePrivilege( true, users[4], "S2", "T1");
1:97734e3:         assertUpdatePrivilege( true, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege( true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege( true, users[4], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:        
1:97734e3:         // now, revoke public permissions
1:97734e3:         revoke("select, update(c1,c3), delete", "S2", "t1", "public");
1:97734e3:         assertSelectPrivilege(false, users[1], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege(true, users[2], "S2", "T1", null);
1:97734e3:         assertSelectPrivilege(false, users[4], "S2", "T1", null);
1:97734e3:         assertDeletePrivilege(false, users[1], "S2", "T1");
1:97734e3:         assertDeletePrivilege(true, users[2], "S2", "T1");
1:97734e3:         assertDeletePrivilege(false, users[4], "S2", "T1");
1:97734e3:         assertUpdatePrivilege(false, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege(true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3:         assertUpdatePrivilege(false, users[4], "S2", "T1", new String[] {"C1", "C3"});
1:97734e3: 
1:97734e3:         // clean up
1:97734e3:         revoke("all privileges", "S2", "t1", users[2]);
1:97734e3:         assertAllPrivileges(false, users[2], "S2", "T1", null);
1:97734e3:      }
1:97734e3:     
1:97734e3:     public void testRevokeExecuteWithPublicPrivilege() throws Exception {
1:97734e3:         grant("execute", "function s1", "f1", "public");
1:97734e3:         grant("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:97734e3:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[4], "S1", "F1", false);
1:97734e3:         
1:97734e3:         //revoke from user, should still be able to execute through public privilege
1:97734e3:         revoke("execute", "function s1", "f1", users[1]);
1:97734e3:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[4], "S1", "F1", false);
1:97734e3:    
1:97734e3:         revoke("execute", "function s1", "f1", "public");
1:97734e3:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:97734e3:         assertFunctionPrivilege(false, users[4], "S1", "F1", false);
1:97734e3:         
1:97734e3:         // clean up
1:f3110ed:         revoke("execute", "function s1", "f1", users[2]);
1:97734e3:         assertFunctionPrivilege(false, users[2], "s1", "F1", false);
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testRevokeRollbackAndCommit() throws Exception {
1:97734e3:         
1:97734e3:     	// open a connection as database owner.
1:97734e3:     	Connection oc = openUserConnection(users[0]);
1:97734e3:     	oc.setAutoCommit(false);
1:97734e3:    	
1:97734e3:     	//set up some permissions
1:97734e3:         grant(oc, "select(c1,c2), update(c1), insert, delete", "s2", "t3", users[1]);
1:97734e3:         grant(oc, "select, references", "s2", "t3", users[2]);
1:97734e3:         grant(oc, "select", "s2", "t3", users[3]);
1:97734e3:         grant(oc, "execute", "procedure s1", "p1", users[1]);
1:97734e3:         oc.commit();
1:97734e3:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] { "C1", "C2"});
1:97734e3:         assertUpdatePrivilege(true, users[1], "S2", "T3", new String[] { "C1"});
1:97734e3:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:97734e3:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:97734e3:         assertSelectPrivilege(true, users[2], "S2", "T3", null);
1:97734e3:         assertReferencesPrivilege(true, users[2], "S2", "T3", null);
1:97734e3:         assertSelectPrivilege(true, users[3], "S2", "T3", null);
1:97734e3:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:97734e3:     	
1:97734e3:     	// revoke the privileges and verify they were revoked.
1:97734e3:         revoke(oc, "select(c2), update(c1), delete", "s2", "t3", users[1]);
1:97734e3:         revoke(oc, "select, references", "s2", "t3", users[2]);
1:97734e3:         revoke(oc, "select", "s2", "t3", users[3]);
1:97734e3:         revoke(oc, "execute", "procedure s1", "p1", users[1]);
1:97734e3:         // these asserts fail before rollback due to lock timeout
1:97734e3:         //assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C1"});
1:97734e3:         //assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2", "C3"});
1:97734e3:         //assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:97734e3:         //assertInsertPrivilege(false, users[1], "S2", "T3", null);
1:97734e3:         //assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         //assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         //assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         //assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:97734e3:         //assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3: 
1:97734e3:         // rollback and verify that we have them again.
1:97734e3:         oc.rollback();
1:97734e3:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:97734e3:         assertUpdatePrivilege(true, users[1], "S2", "T3", new String[] {"C1"});
1:97734e3:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:97734e3:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:97734e3:         assertSelectPrivilege(true, users[2], "S2", "T3", null);
1:97734e3:         assertReferencesPrivilege(true, users[2], "S2", "T3", null);
1:97734e3:         assertSelectPrivilege(true, users[3], "S2", "T3", null);
1:97734e3:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:97734e3:         
1:97734e3:     	// revoke again, verify they were revoked.
1:97734e3:         revoke(oc, "select(c2), update(c1), delete", "s2", "t3", users[1]);
1:97734e3:         revoke(oc, "select, references", "s2", "t3", users[2]);
1:97734e3:         revoke(oc, "select", "s2", "t3", users[3]);
1:97734e3:         revoke(oc, "execute", "procedure s1", "p1", users[1]);
1:97734e3:         // these asserts fail before commit due to lock timeout
1:97734e3:         //assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:97734e3:         //assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:97734e3:         //assertInsertPrivilege(false, users[1], "S2", "T3", null);
1:97734e3:         //assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         //assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         //assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         //assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:97734e3:         //assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3:         
1:97734e3:         //commit and verify again
1:97734e3:         oc.commit();
1:97734e3:         oc.setAutoCommit(true);
1:97734e3:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:97734e3:         assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:97734e3:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:97734e3:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:97734e3:         assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:97734e3:         assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:97734e3:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:97734e3:         
1:97734e3:     }
1:97734e3:     
1:97734e3:     /*
1:97734e3:      * TODO - write tests for abandoned views / triggers / constraints
1:97734e3:      * 
1:97734e3:     public void testAbandonedView() {
1:97734e3:     	//TODO
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testAbandonedTrigger() {
1:97734e3:         //TODO	
1:97734e3:     }
1:97734e3: 
1:97734e3:     public void testAbandonedConstraint() {
1:97734e3:     	//TODO
1:97734e3:     }
1:97734e3:     */
1:97734e3:     
1:97734e3:     /* Begin standard error cases */
1:97734e3:     
1:97734e3:     public void testInvalidGrantAction() throws Exception {
10:97734e3:     	try {
1:97734e3:             grant("xx", "s1", "t1", users[1]);
9:97734e3:     	} catch (SQLException e) {
9:97734e3:         	assertSQLState("42X01", e);
1:97734e3:         }
1:97734e3:     }
1:f3110ed: 
1:97734e3:     public void testInvalidReservedWordAction() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("between", "s1", "t1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:             	assertSQLState("42X01", e);
1:97734e3:     	}
1:97734e3:         
1:f3110ed:         assertCompileError("42X01", "grant select on schema t1 to " + users[1]);
1:97734e3: 
1:f3110ed:         assertCompileError("42X01",  "grant select on decimal t1 to " + users[1]);
1:97734e3:     }
1:97734e3: 
1:97734e3:     public void testGrantOnNonexistantColumn() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("select(nosuchCol)", "s1", "t1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42X14", e);
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantSchema() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("select", "nosuch", "t1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y07", e);
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantTable() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("select(nosuchCol)", "s1", "nosuch", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42X05", e);
1:97734e3:         }
1:97734e3:     }
1:97734e3: 
1:97734e3:     public void testGrantOnFunctionWithBadSchema() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "function nosuch", "f0", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y07", e);
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantFunction() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "function s1", "nosuch", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y03", e);
1:f1512cd:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
1:7585584:         	    assertEquals("'S1.NOSUCH' is not recognized as a function.", e.getMessage());
1:f1512cd:         	}
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantFunctionForProcedure() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "function s1", "p1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y03", e);
1:f1512cd:             if ( Locale.getDefault().getLanguage().equals("en") ) {
1:7585584:                 assertEquals("'S1.P1' is not recognized as a function.", e.getMessage());
1:f1512cd:             }
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnProcedureWithBadSchema() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "procedure nosuch", "f0", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y07", e);
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantProcedure() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "procedure s1", "nosuch", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y03", e);
1:f1512cd:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
1:7585584:         	    assertEquals("'S1.NOSUCH' is not recognized as a procedure.", e.getMessage());
1:f1512cd:         	}
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantOnNonexistantProcedureForFunction() throws Exception {
1:97734e3:     	try {
1:97734e3:             grant("execute", "procedure s1", "f2", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:         	assertSQLState("42Y03", e);
1:f1512cd:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
1:7585584:         	    assertEquals("'S1.F2' is not recognized as a procedure.", e.getMessage());
1:f1512cd:         	}
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantExecuteOnTable() throws Exception {
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:                 "grant execute on table s1.t1 to " + users[1]);
1:f3110ed:      }
1:97734e3:     
1:97734e3:     public void testGrantSelectOnRoutine() throws Exception {
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:                 "grant select on function s1.f1 to " + users[1]);
1:f3110ed:    	
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:                 "grant select on procedure s1.p1 to " + users[1]);
1:f3110ed:    }
1:97734e3:     
1:97734e3:     public void testGrantExecuteWithRestrict() throws Exception {
1:97734e3:     	// restrict invalid in grant statement
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:                 "grant execute on function s1.f1 to " + users[1] + " restrict");
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantRevokeWithoutRestrict() throws Exception {
1:97734e3:     	// restrict invalid in grant statement
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:                "revoke execute on function s1.f1 from " + users[0]);
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantRevokeSelectWithRestrict() throws Exception {
1:97734e3:     	// restrict invalid in grant statement
1:f3110ed:         assertCompileError("42X01",
1:f3110ed:     	     "revoke select on s1.t1 from " + users[0] + " restrict");
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantDeleteWithColumnList() throws Exception {
1:97734e3:     	try {
1:97734e3:     		grant("delete(c1)", "s1", "t1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		assertSQLState("42X01", e);
1:97734e3:     	}
1:97734e3:     }
1:97734e3:     
1:97734e3:     public void testGrantTriggerWithColumnList() throws Exception {
1:97734e3:     	try {
1:97734e3:     		grant("trigger(c1)", "s1", "t1", users[1]);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		assertSQLState("42X01", e);
1:97734e3:     	}
1:97734e3:     }
1:97734e3:     
1:97734e3:     /* End standard error cases */
1:97734e3:     
1:97734e3:     /* Begin testcases from grantRevokeDDL */
1:97734e3: 
1:97734e3:     public void testOtherUserCannotRevokeOwnerPrivileges() throws SQLException {
1:97734e3:     	grant("select", "s1", "t1", "public");
1:97734e3:     	grant("insert", "s1", "t1", users[1]);
1:97734e3:     	grant("update", "s1", "t1", users[1]);
1:97734e3:     	grant("delete", "s1", "t1", users[1]);
1:97734e3:     	grant("update(c1)", "s1", "t1", users[2]);
1:97734e3:         try {
1:97734e3:         	revoke(users[2], "select", "s1", "t1", "public");
1:97734e3:         } catch (SQLException e) {
1:8f3b0b9:             assertSQLState("42506", e);
1:97734e3:         }
1:97734e3:         try {
1:97734e3:         	revoke(users[2], "select", "s1", "t1", users[0]);
1:97734e3:         } catch (SQLException e) {
1:8f3b0b9:             assertSQLState("42509", e);
1:97734e3:         }
1:97734e3:         try {
1:97734e3:         	revoke(users[2], "insert", "s1", "t1", users[1]);
1:97734e3:         } catch (SQLException e) {
1:8f3b0b9:             assertSQLState("42506", e);
1:97734e3:         }
1:97734e3:         try {
1:97734e3:         	revoke(users[2], "update(c1)", "s1", "t1", users[2]);
1:97734e3:         } catch (SQLException e) {
1:8f3b0b9:             assertSQLState("42506", e);
1:97734e3:         }
1:8a319fb:         
1:8a319fb:         // clean up
1:8a319fb:         revoke("select", "s1", "t1", "public");
1:8a319fb:         revoke("all privileges", "s1", "t1", users[1]);
1:8a319fb:         revoke("all privileges", "s1", "t1", users[2]);
1:8a319fb:         assertAllPrivileges(false, users[1], "S1", "T1", null);
1:8a319fb:         assertAllPrivileges(false, users[2], "S1", "T1", null);
1:7bfb37a:         
1:97734e3:     }
1:8a319fb: 
1:7bfb37a:     /**
1:7bfb37a:      * DERBY-5292
1:7bfb37a:      */
1:7bfb37a:     public void testViewDefinersRights () throws Exception {
1:7bfb37a: 
1:7bfb37a:         grant("select", "appl", "\"VW_MyTasks\"", users[1]);
1:7bfb37a:         grant("select", "appl", "\"VW_MyPriorityTasks\"", users[1]);
1:7bfb37a:         grant("select", "appl", "\"VW2_MyPriorityTasks\"", users[1]);
1:7bfb37a:         grant("select", "appl", "\"VW3_MyPriorityTasks\"", users[1]);
1:7bfb37a: 
1:7bfb37a:         // OK before fix
1:7bfb37a:         assertSelectPrivilege(
1:7bfb37a:             true, users[1], "appl", "\"VW_MyTasks\"", null);
1:7bfb37a:         assertSelectPrivilege(
1:7bfb37a:             true, users[1], "appl", "\"VW_MyPriorityTasks\"", null);
1:7bfb37a: 
1:7bfb37a:         // Failed before fix
1:7bfb37a:         assertSelectPrivilege(
1:7bfb37a:             true, users[1], "appl", "\"VW2_MyPriorityTasks\"", null);
1:7bfb37a:         assertSelectPrivilege(
1:7bfb37a:             true, users[1], "appl", "\"VW3_MyPriorityTasks\"", null);
1:7bfb37a:     }
1:7bfb37a: 
1:97734e3:     /* End testcases from grantRevokeDDL */
1:97734e3:     
1:97734e3:     /* Begin utility methods specific to grant / revoke */
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Grant a single permission to a single user.
1:97734e3:      * Utility method that takes a single string for user instead
1:97734e3:      * of an array of Strings.
1:97734e3:      * 
1:97734e3:      * @param perm Permission to grant
1:97734e3:      * @param schema Schema on which to grant permission
1:97734e3:      * @param table Table on which to grant permission
1:97734e3:      * @param user User to grant permission to
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void grant(String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		grant(perm, schema, table, new String[] {user});
1:97734e3: 	}
1:97734e3: 	
1:97734e3:     /**
1:97734e3:      * Grant a single permission from a specific user to a single user.
1:97734e3:      * Utility method that takes a single string for user instead
1:97734e3:      * of an array of Strings.
1:97734e3:      * 
1:97734e3:      * @param grantor Grantor of permission
1:97734e3:      * @param perm Permission to grant
1:97734e3:      * @param schema Schema on which to grant permission
1:97734e3:      * @param table Table on which to grant permission
1:97734e3:      * @param user User to grant permission to
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void grant(String grantor, String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		Connection c = openUserConnection(grantor);
1:97734e3: 		grant(c, perm, schema, table, user);
1:97734e3: 		c.close();
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * Grant a SQL permission to a set of users.
1:97734e3: 	 * 
1:97734e3: 	 * @param perm The permission to grant
1:97734e3: 	 * @param schema the schema on which to grant the permission
1:97734e3: 	 * @param table the table on which to grant the permission
1:97734e3: 	 * @param users an Array of users to grant the permission
1:97734e3: 	 * @throws Exception throws all exceptions
1:97734e3: 	 */
1:97734e3: 	void grant(String perm, String schema, String table, String[] users) throws SQLException {
1:97734e3: 		StringBuffer command = new StringBuffer("grant " + perm + " on " + schema + "." + table + " to " + users[0]);
1:97734e3: 		for (int i = 1; i < users.length; i++ ) {
1:97734e3: 		    command.append("," + users[i]);
1:97734e3: 		}
1:97734e3:         
1:97734e3: 		// default connection is for database owner.
1:97734e3: 		Statement s = getConnection().createStatement();
1:97734e3: 		s.executeUpdate(command.toString());
1:97734e3: 		s.close();
1:97734e3: 	}
1:97734e3: 	
1:97734e3:     /**
1:97734e3:      * Grant a single permission to a single user for a given connection.
1:97734e3:      * Callers of this method should ensure that they close the Connection
1:97734e3:      * that is passed in. Used primarily in rollback tests where we want to ensure
1:97734e3:      * the grant/revoke statements are being called by the database owner.
1:97734e3:      * 
1:97734e3:      * @param c the Connection used to execute the grant statement
1:97734e3:      * @param perm Permission to grant
1:97734e3:      * @param schema Schema on which to grant permission
1:97734e3:      * @param table Table on which to grant permission
1:97734e3:      * @param user User to grant permission to
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void grant(Connection c, String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		Statement s = c.createStatement();
1:97734e3: 		s.executeUpdate("grant " + perm + " on " + schema + "." + table + " to " + user);
1:97734e3: 		s.close();
1:97734e3: 	}
1:97734e3: 	
1:97734e3:     /**
1:97734e3:      * Revoke a single permission from a single user.
1:97734e3:      * Utility method that takes a single string for user instead
1:97734e3:      * of an array of Strings.
1:97734e3:      * 
1:97734e3:      * @param perm Permission to revoke
1:97734e3:      * @param schema Schema on which to revoke permission
1:97734e3:      * @param table Table on which to revoke permission
1:97734e3:      * @param user User to revoke permissions
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void revoke(String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		revoke(perm, schema, table, new String[] {user});
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 
1:97734e3:     /**
1:97734e3:      * Revoke a single permission from a specific user to a single user.
1:97734e3:      * Utility method that takes a single string for user instead
1:97734e3:      * of an array of Strings.
1:97734e3:      * 
1:97734e3:      * @param revoker Grantor of permission
1:97734e3:      * @param perm Permission to revoke
1:97734e3:      * @param schema Schema on which to revoke permission
1:97734e3:      * @param table Table on which to revoke permission
1:97734e3:      * @param user User to revoke permission to
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void revoke(String revoker, String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		Connection c = openUserConnection(revoker);
1:97734e3: 		revoke(c, perm, schema, table, user);
1:97734e3: 		c.close();
1:97734e3: 	}
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * Revoke a SQL permission from a set of users.
1:97734e3: 	 * 
1:97734e3: 	 * @param perm The permission to revoke
1:97734e3: 	 * @param schema the schema on which to revoke the permission
1:97734e3: 	 * @param table the table on which to revoke the permission
1:97734e3: 	 * @param users an array of users to revoke the permission
1:97734e3: 	 * @throws Exception throws all exceptions
1:97734e3: 	 */
1:97734e3: 	void revoke(String perm, String schema, String table, String[] users) throws SQLException {
1:97734e3: 		StringBuffer command = new StringBuffer("revoke " + perm + " on " + schema + "." + table + " from " + users[0]);
1:97734e3: 		for (int i = 1; i < users.length; i++ ) {
1:97734e3: 		    command.append("," + users[i]);
1:97734e3: 		}
1:97734e3: 		//add restrict to revoke execute... 
1:97734e3: 		if (perm.equalsIgnoreCase("execute"))
1:97734e3: 			command.append(" restrict");
1:f3110ed:         
1:f3110ed:         Statement s = createStatement();
1:f3110ed:         s.executeUpdate(command.toString());
1:f3110ed:         s.close();
1:97734e3: 	}
1:97734e3: 
1:97734e3:     /**
1:97734e3:      * Revoke a single permission to a single user for a given connection.
1:97734e3:      * Callers of this method should ensure that they close the Connection
1:97734e3:      * that is passed in. Used primarily in rollback tests where we want to ensure
1:97734e3:      * the grant/revoke statements are being called by the database owner.
1:97734e3:      * 
1:97734e3:      * @param c the connection to execute the revoke statement
1:97734e3:      * @param perm Permission to revoke
1:97734e3:      * @param schema Schema on which to revoke permission
1:97734e3:      * @param table Table on which to revoke permission
1:97734e3:      * @param user User to revoke permission
1:97734e3:      * @throws Exception throws all exceptions
1:97734e3:      */
1:97734e3: 	void revoke(Connection c, String perm, String schema, String table, String user) throws SQLException {
1:97734e3: 		Statement s = c.createStatement();
1:97734e3: 		s.execute("revoke " + perm + " on " + schema + "." + table + " from " + user + (perm.equalsIgnoreCase("execute") ? " restrict" : ""));
1:97734e3: 		s.close();
1:97734e3: 	}
1:97734e3: 	
1:97734e3:     /* End utility methods specific to grant / revoke */
1:97734e3: 	
1:97734e3: 	/**
1:97734e3: 	 * Utility function to test grant/revoke
1:97734e3: 	 * @return 1
1:97734e3: 	 */
1:97734e3:     public static int s1F1()
4:97734e3:     {
1:97734e3:         return 1;
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Another utility function to test grant/revoke - placeholder for
1:97734e3:      * future if SPECIFIC names are implemented.
1:97734e3:      * @return 1
1:97734e3:      */
1:97734e3:     public static int s2F1a()
1:97734e3:     {
1:97734e3:         return 1;
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Another utility function to test grant/revoke
1:97734e3:      * @return 1
1:97734e3:      */
1:97734e3:     public static int s2F2()
1:97734e3:     {
1:97734e3:         return 1;
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Utility method to test procedure with identical name to a
1:97734e3:      * function
1:97734e3:      */
1:97734e3:     public static void s1F1P( )
1:97734e3:     {
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * A utility method to test procedures with test grant/revoke
1:97734e3:      */
1:97734e3:     public static void s1P1( )
1:97734e3:     {
1:97734e3:     }
1:97734e3:     
1:97734e3:     /* 
1:97734e3:      * public methods for asserting privileges begin here
1:97734e3:      * May move to BaseJDBCTestCase if appropriate.
1:97734e3:      */
1:97734e3:     
1:97734e3: 
1:97734e3:     /**
1:97734e3:      * Assert all privileges for a given user / schema / table / column set
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege whether we expect the given user to have the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
2:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check for the user
1:97734e3:      */
1:97734e3:     public void assertAllPrivileges(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:97734e3:     	assertSelectPrivilege(hasPrivilege, user, schema, table, columns);
1:97734e3:     	assertDeletePrivilege(hasPrivilege, user, schema, table);
1:97734e3:     	assertInsertPrivilege(hasPrivilege, user, schema, table, columns);
1:97734e3:     	assertUpdatePrivilege(hasPrivilege, user, schema, table, columns);
1:97734e3:     	assertReferencesPrivilege(hasPrivilege, user, schema, table, columns);
1:97734e3:        	assertTriggerPrivilege(hasPrivilege, user, schema, table);
1:97734e3:     }
1:97734e3:     
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has select privilege on a given table / column
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertSelectPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException{
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:     	try {
1:97734e3:     	    boolean b = s.execute("select " + columnListAsString(columns) + " from " + schema + "." + table);
1:1fec7db:             assertTrue("expected no SELECT permission on table", hasPrivilege);
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		if (!hasPrivilege) {
1:8f3b0b9:     			assertSQLState("42502", e);
1:97734e3:     		} else {
1:1fec7db:                 printStackTrace(e);
1:1fec7db:                 fail("Unexpected lack of select privilege", e);
1:97734e3:     		}
1:97734e3:     	}
1:97734e3:         s.close();
1:97734e3:     	c.close();
1:f3110ed:     	
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "SELECT", user, schema, table, columns);
1:97734e3:     }
1:f3110ed:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has delete privilege on a given table / column
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertDeletePrivilege(boolean hasPrivilege, String user, String schema, String table) throws SQLException {
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:     	try {
1:97734e3:     	    boolean b = s.execute("delete from " + schema + "." + table);
1:1fec7db:             assertTrue("expected no DELETE permission on table", hasPrivilege);
1:f3110ed: 
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		if (!hasPrivilege) {
1:8f3b0b9:     			assertSQLState("42500", e);
1:97734e3:     		} else {
1:1fec7db:                 printStackTrace(e);
1:1fec7db:                 fail("Unexpected lack of delete privilege", e);
1:97734e3:     		}
1:97734e3:     	}
1:97734e3:     	s.close();
1:97734e3:     	c.close();
1:97734e3:     	
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "DELETE", user, schema, table, null);
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has insert privilege on a given table / column
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertInsertPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:97734e3:    	
1:97734e3:     	// NOTE - getColumns returns empty result set if schema / table names not capitalized.
1:97734e3:         // TODO - should implement asserting insert privilege on a subset of columns at some point
1:97734e3:     	
1:3ce8a04:     	Connection c = openUserConnection(user);
1:97734e3: 
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:     	try {
1:97734e3:     		StringBuffer command = new StringBuffer("insert into " + schema + "." + table + " values (");
1:97734e3:     		ResultSet rs = c.getMetaData().getColumns( null, schema, table, null);
1:97734e3:             boolean first = true;
1:97734e3:             while(rs.next())
1:97734e3:             {
1:97734e3:                 if(first)
1:97734e3:                     first = false;
1:97734e3:                 else
1:97734e3:                     command.append(",");
1:97734e3:                 appendColumnValue(command, rs.getInt(5));
1:97734e3:             }
1:97734e3:             rs.close();
1:97734e3:             command.append(")");
1:97734e3:     	    int i = s.executeUpdate(command.toString());
1:1fec7db:             assertTrue("expected no INSERT permission on table", hasPrivilege);
1:f3110ed: 
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		if (!hasPrivilege) {
1:8f3b0b9:     			assertSQLState("42500", e);
1:97734e3:     		} else {
1:1fec7db:                 fail("Unexpected lack of insert privilege on " +
1:1fec7db:                      JDBC.escape(schema, table) + " by " + user, e);
1:97734e3:     		}
1:97734e3:     	}
1:97734e3:     	s.close();
1:f3110ed:     	c.close();
1:97734e3:     	
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "INSERT", user, schema, table, columns);
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has update privilege on a given table / column
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertUpdatePrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:97734e3:  
1:97734e3:     	String[] checkColumns = (columns == null) ? getAllColumns(schema, table) : columns;
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:     	int columnCount = 0;
1:97734e3:     	boolean checkCount;
1:97734e3:     	for (int i = 0; i < checkColumns.length; i++) {
1:97734e3:     		checkCount = false;
1:97734e3:   
1:97734e3:     		try {
1:97734e3:     			// if possible, get count of rows to verify update rows
1:97734e3:     			try {
1:97734e3:     				ResultSet countRS = s.executeQuery("select count(" + checkColumns[i] +") from " + schema + "." + table);
1:97734e3:     			    if (!countRS.next()) {
1:97734e3:     				    fail("Could not get count on " + checkColumns[i] + " to verify update");
1:97734e3:     			    }
1:97734e3:     			    columnCount = countRS.getInt(1);
1:97734e3:     			    checkCount = true;
1:97734e3:     			} catch (SQLException e) {
1:97734e3:                     // may not have select privilege on the column, in
1:97734e3:     				// which case, we simply don't verify the count.
1:1fec7db:                     assertSQLState("42502", e);
1:97734e3:     			}
1:97734e3:     			
1:97734e3:     			StringBuffer command = new StringBuffer("update " + schema + "." + table + " set " + checkColumns[i] + "=");
1:97734e3:         		ResultSet rs = c.getMetaData().getColumns( (String) null, schema, table, checkColumns[i]);
1:97734e3:                 if (!rs.next())
1:97734e3:                 {
1:97734e3:                 	fail("Could not get column metadata for " + checkColumns[i]);
1:97734e3:                 }
1:97734e3:                 appendColumnValue(command, rs.getInt( 5));
1:97734e3:                 rs.close();
1:97734e3:         	    int actualCount = s.executeUpdate(command.toString());
1:97734e3:         	    if (hasPrivilege && checkCount)
1:97734e3:         	    {
1:97734e3:         	    	// update count should equal select count
1:97734e3:         	        assertEquals(columnCount, actualCount);
1:97734e3:         	    }
1:1fec7db: 
1:1fec7db:                 assertTrue("expected no UPDATE permission on table",
1:1fec7db:                            hasPrivilege);
1:ab91c04: 
1:97734e3:     		} catch (SQLException e) {
1:97734e3:         		if (!hasPrivilege) {
1:8f3b0b9:         			assertSQLState("42502", e);
1:97734e3:         		} else {
1:1fec7db:                     printStackTrace(e);
1:1fec7db:                     fail("Unexpected lack of privilege to update on " +
1:1fec7db:                          JDBC.escape(schema, table) + " by " + user, e);
1:97734e3:         		}
1:97734e3:         	}
1:97734e3:         }
1:f3110ed: 
1:97734e3:         s.close();
1:97734e3:     	c.close();
1:97734e3:     	
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "UPDATE", user, schema, table, columns);
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has references privilege on a given table / column
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertReferencesPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:97734e3: 
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "REFERENCES", user, schema, table, columns);
1:97734e3:     	
1:97734e3:     	/* no way to empirically test any arbitrary column can be
1:97734e3:     	 * referenced, as the column that is to be referenced must be
1:97734e3:     	 * a primary key or a unique constraint. Leaving this here, as it
1:97734e3:     	 * might form the useful basis of another assert method for cases
1:97734e3:     	 * where we know this to be certain.
1:97734e3:     	
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:         for (int i = 0; i < columns.length; i++) {
1:97734e3:             // if it works, need to assert this as false.
1:97734e3:         	boolean b = true;
1:97734e3:         	try {
1:97734e3:         	    if (columns == null) {
1:97734e3:             	    b = s.execute("create table referencestest (c1 " + getColumnDataType(schema, table, columns[i]) + " references " + schema + "." + table + ")" );
1:97734e3:         	    } else {
1:97734e3:         	        b = s.execute("create table referencestest (c1 " + getColumnDataType(schema, table, columns[i]) + " references " + schema + "." + table + "(" + column + "))" );
1:97734e3:         	    }
1:97734e3:         	} catch (SQLException e) {
1:97734e3:         		if (!hasPrivilege) {
1:8f3b0b9:         			assertSQLState("42502", e);
1:97734e3:         		} else {
1:1fec7db:                     printStackTrace(e);
1:1fec7db:                     fail("Unexpected lack of references privilege", e);
1:97734e3:         		}
1:97734e3:         	}
1:97734e3:         	// no rows updated, so false.
1:97734e3:         	assertFalse(b);
1:97734e3:         	s.execute("drop table referencestest");   	
1:97734e3:         }
1:97734e3:         s.close();
1:97734e3:         c.close();
1:97734e3:         */
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has trigger execute privilege on a given table / column
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertTriggerPrivilege(boolean hasPrivilege, String user, String schema, String table) throws SQLException {
1:97734e3:     	
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	c.setAutoCommit(false);
1:97734e3:     	
1:97734e3:     	Statement s = c.createStatement();
1:97734e3:     	try {
1:97734e3:     	    int i = s.executeUpdate("create trigger \"" + table + "Trig\" after insert on " +
1:97734e3:     	    		              schema + "." + table + " for each row values 1");
4:97734e3:     	    if (hasPrivilege)
1:97734e3:     	    {
1:97734e3:     	        assertEquals(0, i); 
1:97734e3:     	    }
1:1fec7db:             assertTrue("expected no TRIGGER permission on table", hasPrivilege);
1:f3110ed: 
1:97734e3:     	} catch (SQLException e) {
1:97734e3:     		if (!hasPrivilege) {
1:3ce8a04:     			assertSQLState("42500", e);
1:97734e3:     		} else {
1:1fec7db:                 printStackTrace(e);
1:1fec7db:                 fail("Unexpected lack of trigger privilege on " +
1:1fec7db:                      JDBC.escape(schema, table) + " by " + user, e);
1:97734e3:     		}
1:97734e3:     	}
1:97734e3:     	
1:97734e3:     	c.rollback();
1:97734e3:         s.close();
1:97734e3:     	c.close();
1:97734e3: 
1:97734e3:     	assertPrivilegeMetadata(hasPrivilege, "TRIGGER", user, schema, table, null);
1:97734e3:  
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has function execute privilege on a given table / column
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param function the function to check
1:97734e3:      * @param forProcedure true if checking for lack of function execute privilege against procedure of same name.
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertFunctionPrivilege(boolean hasPrivilege, String user, String schema, String function, boolean forProcedure) throws SQLException {
1:97734e3:         Connection c = openUserConnection(user);
1:97734e3:         
1:97734e3:         String functioncall = "values " + schema + "." + function + "()";
1:97734e3:  
1:97734e3: 	    PreparedStatement ps = null;
1:97734e3: 	    ResultSet rs = null;
1:97734e3: 		try {
1:97734e3: 		    ps = c.prepareStatement(functioncall);
1:97734e3: 		    rs = ps.executeQuery();
1:1fec7db:             assertTrue("expected no EXECUTE permission on function",
1:1fec7db:                        hasPrivilege);
1:f3110ed: 
1:97734e3: 		} catch (SQLException e) {
1:97734e3: 			if (!hasPrivilege){
1:97734e3: 				if (forProcedure) 
1:97734e3: 					assertSQLState("42Y03", e);
1:97734e3: 				else 
1:8f3b0b9: 					assertSQLState("42504", e);
1:97734e3: 			} else {
1:1fec7db:                 printStackTrace(e);
1:1fec7db:                 fail("Unexpected lack of function execute privilege", e);
1:97734e3: 			}
1:97734e3: 		}
1:97734e3: 		if (ps != null)
1:97734e3: 			ps.close();
1:97734e3: 		if (rs != null)
1:97734e3: 			rs.close();
1:1fec7db: 
1:1fec7db:         c.close();
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Assert that a user has procedure execute privilege on a given table / column
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege whether or not the user has the privilege
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:1b318a6:      * @param procedure the name of the procedure to check
1:97734e3:      * @throws SQLException throws all exceptions
1:97734e3:      */
1:97734e3:     public void assertProcedurePrivilege(boolean hasPrivilege, String user, String schema, String procedure) throws SQLException {
1:97734e3:         Connection c = openUserConnection(user);
1:97734e3:         
1:97734e3:         String procedurecall = "call " + schema + "." + procedure + "()";
1:97734e3:         
1:f3110ed: 		CallableStatement ps = c.prepareCall(procedurecall);
1:97734e3: 		ResultSet rs = null;
1:97734e3: 		try {
1:97734e3: 			ps.execute();
1:97734e3: 			rs = ps.getResultSet();
1:1fec7db:             assertTrue("expected no EXECUTE permission on procedure",
1:1fec7db:                        hasPrivilege);
1:97734e3: 		} catch (SQLException e) {
1:3ce8a04: 			if (!hasPrivilege)
1:8f3b0b9: 				assertSQLState("42504", e);
1:97734e3: 			else {
1:1fec7db:                 printStackTrace(e);
1:1fec7db:                 fail("Unexpected lack of procedure execute privilege", e);
1:97734e3: 			}
1:97734e3: 		}
1:97734e3: 		ps.close();
1:97734e3: 		if (rs != null)
1:97734e3: 		{
1:97734e3: 				rs.close();
1:97734e3: 		}
1:97734e3:         c.close();
1:97734e3:     }
1:f3110ed:     
1:97734e3:     /**
1:97734e3:      * Assert that a specific privilege exists by checking the
1:97734e3:      * database metadata available to a user
1:97734e3:      * 
1:97734e3:      * @param hasPrivilege true if we expect the caller to have the privilege
1:97734e3:      * @param type type of privilege, e.g. SELECT, INSERT, DELETE, etc.
1:97734e3:      * @param user the user to check
1:97734e3:      * @param schema the schema to check
1:97734e3:      * @param table the table to check
1:97734e3:      * @param columns the set of columns to check, or all columns if null
1:97734e3:      * @throws SQLException
1:97734e3:      */
1:97734e3:     public void assertPrivilegeMetadata(boolean hasPrivilege, String type, String user, String schema, String table, String[] columns) throws SQLException {
1:97734e3:         
1:97734e3:     	Connection c = openUserConnection(user);
1:97734e3:     	DatabaseMetaData dm = c.getMetaData();
1:7bfb37a:         schema = JDBC.identifierToCNF(schema);
1:7bfb37a:         table  = JDBC.identifierToCNF(table);
1:7bfb37a:         ResultSet rs = dm.getTablePrivileges(null, schema, table);
1:97734e3:      	boolean found = false;
1:97734e3:     	// check getTablePrivileges
1:97734e3:     	if (columns == null) {
1:97734e3:         	while (rs.next())
1:97734e3:         	{
1:7e85449:         	// also verify that grantor and is_grantable can be obtained
1:7e85449:         	// Derby doesn't currently support the for grant option, the
1:7e85449:         	// grantor is always the object owner - in this test, TEST_DBO,
1:7e85449:         	// and is_grantable is always 'NO'
1:7e85449:           	    assertEquals(rs.getString(4),"TEST_DBO");
1:7e85449:           	    assertEquals(rs.getString(7),"NO");
1:97734e3:           	    if (rs.getString(6).equals(type)) {
1:97734e3:         	    	String privUser = rs.getString(5);
1:97734e3:         	    	if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1:97734e3:         	    		found = true;
1:97734e3:         	    	}
1:97734e3:         	    }
1:97734e3:         	}
1:97734e3:         	assertEquals(hasPrivilege, found);
1:97734e3:         	rs.close();
1:97734e3:     	}
1:97734e3: 
1:97734e3:     	// check getColumnPrivileges()
1:97734e3:     	ResultSet cp = null;
1:97734e3:     	if (columns == null) {
1:97734e3:     		/*
1:97734e3:     		 * Derby does not record table level privileges in SYSCOLPERMS,
1:97734e3:     		 * so the following does not work. If it is ever changed so that
1:97734e3:     		 * getColumnPrivileges returns proper results for table level privileges,
1:97734e3:     		 * this can be reenabled.
1:97734e3:     		 * 
1:97734e3:         	ResultSet cols = dm.getColumns(null, schema.toUpperCase(), table.toUpperCase(), null);
1:97734e3: 			int foundCount = 0;
1:97734e3: 			int colCount = 0;
1:97734e3:         	while (cols.next())
1:97734e3:         	{
1:97734e3: 				colCount++;
1:97734e3:     			String col = cols.getString(4);
1:97734e3:     			//System.out.println("getting column privs for " + col);
1:97734e3:     			cp = dm.getColumnPrivileges(null, schema.toUpperCase(), table.toUpperCase(), col);
1:97734e3: 
1:97734e3:     			while (cp.next()) {
1:97734e3: 
1:97734e3: 					//System.out.println(schema + "." + table + ": "
1:97734e3: 					//		+ cp.getString(4) + ", " + cp.getString(5) + ", "
1:97734e3: 					//		+ cp.getString(6) + ", " + cp.getString(7));
1:97734e3: 					if (cp.getString(7).equals(type)) {
1:97734e3: 						String privUser = cp.getString(6);
1:97734e3: 						if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1:97734e3: 							foundCount++;
1:97734e3: 						}
1:97734e3: 					}
1:97734e3: 				}
1:97734e3:         	}
1:97734e3: 			if (hasPrivilege) {
1:97734e3: 				assertEquals(colCount, foundCount);
1:97734e3: 			} else {
1:97734e3: 			    assertFalse(colCount == foundCount);
1:97734e3: 			}
1:97734e3: 			*/
1:97734e3:     	} else {
1:97734e3:     		// or, check the given columns
1:97734e3:     		for (int i = 0; i < columns.length; i++) {
1:97734e3:     			cp = dm.getColumnPrivileges(null, schema.toUpperCase(), table.toUpperCase(), columns[i].toUpperCase());
1:97734e3:     			found = false;
1:97734e3:     			while (cp.next()) {
1:7e85449:     			// also verify that grantor and is_grantable are valid
1:7e85449:     			// Derby doesn't currently support for grant, so
1:7e85449:     			// grantor is always the object owner - in this test, 
1:7e85449:     			// TEST_DBO, and getColumnPrivileges casts 'NO' for 
1:7e85449:     			// is_grantable for supported column-related privileges
1:7e85449: 					assertEquals("TEST_DBO", cp.getString(5));
1:7e85449: 					assertEquals("NO", cp.getString(8));
1:97734e3: 					if (cp.getString(7).equals(type)) {
1:97734e3: 						String privUser = cp.getString(6);
1:97734e3: 						if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1:97734e3: 							found = true;
1:97734e3: 						}
1:97734e3: 					}
1:97734e3:     			}
1:97734e3:     			if (hasPrivilege)
1:97734e3:     				assertTrue(found);
1:97734e3:     		}        	
1:97734e3:     	}
1:97734e3: 		if (cp != null)
1:97734e3: 			cp.close();
1:97734e3:     	
1:97734e3:     	c.close();
1:97734e3:     }
1:97734e3:     
1:97734e3:     /* End assert methods */
1:97734e3:     
1:97734e3:     /* Begin helper methods */
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Append a particular SQL datatype value to the given StringBuffer
1:97734e3:      * 
1:97734e3:      * @param sb the StringBuffer to append the value
1:97734e3:      * @param type the java.sql.Types value to append
1:97734e3:      */
1:97734e3:     static void appendColumnValue(StringBuffer sb, int type)
1:97734e3:     {
1:97734e3:         switch(type)
1:97734e3:         {
1:97734e3:         case Types.BIGINT:
1:97734e3:         case Types.DECIMAL:
1:97734e3:         case Types.DOUBLE:
1:97734e3:         case Types.FLOAT:
1:97734e3:         case Types.INTEGER:
1:97734e3:         case Types.NUMERIC:
1:97734e3:         case Types.REAL:
1:97734e3:         case Types.SMALLINT:
1:97734e3:         case Types.TINYINT:
1:97734e3:             sb.append("0");
1:97734e3:             break;
1:97734e3: 
1:97734e3:         case Types.CHAR:
1:97734e3:         case Types.VARCHAR:
1:97734e3:             sb.append("' '");
1:97734e3:             break;
1:97734e3: 
1:97734e3:         case Types.DATE:
1:97734e3:             sb.append("CURRENT_DATE");
1:97734e3:             break;
1:97734e3: 
1:97734e3:         case Types.TIME:
1:97734e3:             sb.append("CURRENT_TIME");
1:97734e3:             break;
1:97734e3: 
1:97734e3:         case Types.TIMESTAMP:
1:97734e3:             sb.append("CURRENT_TIMESTAMP");
1:97734e3:             break;
1:97734e3: 
1:97734e3:         default:
1:97734e3:             sb.append("null");
1:97734e3:             break;
1:97734e3:         }
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Return the given String array as a comma separated String
1:97734e3:      * 
1:97734e3:      * @param columns an array of columns to format
1:97734e3:      * @return a comma separated String of the column names
1:97734e3:      */
1:97734e3:     static String columnListAsString(String[] columns) {
1:97734e3:     	if (columns == null) {
1:97734e3:     		return "*";
1:97734e3:     	}
1:97734e3:     	
1:97734e3:     	StringBuffer sb = new StringBuffer(columns[0]);
1:97734e3: 		for (int i = 1; i < columns.length; i++ ) {
1:97734e3: 		    sb.append("," + columns[i]);
1:97734e3: 		}
1:97734e3: 		return sb.toString();
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Get all the columns in a given schema / table
1:97734e3:      * 
1:97734e3:      * @return an array of Strings with the column names
1:97734e3:      * @throws SQLException
1:97734e3:      */    
1:97734e3:     String[] getAllColumns(String schema, String table) throws SQLException
1:97734e3:     {
1:97734e3:     	DatabaseMetaData dbmd = getConnection().getMetaData();
1:3f5c48a:         ArrayList<String> columnList = new ArrayList<String>();
1:97734e3:         ResultSet rs = dbmd.getColumns( (String) null, schema, table, (String) null);
1:97734e3:         while(rs.next())
1:97734e3:         {
1:97734e3:             columnList.add(rs.getString(4));
1:97734e3:         }
1:97734e3:           
1:3f5c48a:         return columnList.toArray(new String[columnList.size()]);
1:97734e3:     }
1:97734e3:     
1:97734e3:     /**
1:97734e3:      * Given a schema, table, and column as Strings, return the datatype of
1:97734e3:      * the column as a String.
1:97734e3:      * 
1:97734e3:      * @param schema the schema for the table in which the column resides
1:97734e3:      * @param table the table containing the column to check
1:97734e3:      * @param column the column to get the data type as a String
1:97734e3:      * @return the Type of the column as a String
1:97734e3:      * @throws SQLException
1:97734e3:      */
1:97734e3:     String getColumnDataType(String schema, String table, String column) throws SQLException {
1:97734e3:     	DatabaseMetaData dm = getConnection().getMetaData();
1:97734e3:     	ResultSet rs = dm.getColumns(null, schema, table, column);
1:97734e3:     	
1:97734e3:     	int type = 0;
1:97734e3:     	while (rs.next()) {
1:97734e3:     		type = rs.getInt(5);
1:97734e3:     	}
1:97734e3:     	rs.close();
1:97734e3:     	return JDBC.sqlNameFromJdbc(type);
1:97734e3:     }
1:97734e3: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite();
/////////////////////////////////////////////////////////////////////////
1:         Test test = new BaseTestSuite(GrantRevokeTest.class);
commit:7bfb37a
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:                // DERBY-5292: Definer's rights in views
1:                s.execute("create schema appl");
1:                s.execute(
1:                    "CREATE TABLE appl.\"TBL_Tasks\"" +
1:                    "(\"TaskID\" integer NOT NULL " +
1:                    "                    GENERATED ALWAYS AS IDENTITY," +
1:                    " \"Task\" varchar(64) NOT NULL," +
1:                    " \"AssignedTo\" varchar(64) NOT NULL," +
1:                    "CONSTRAINT \"PK_Tasks\" PRIMARY KEY (\"TaskID\"))");
1:                s.execute(
1:                    "CREATE TABLE appl.\"TBL_Priorities\"" +
1:                    "(\"TaskID\" integer NOT NULL," +
1:                    " \"Priority\" integer NOT NULL," +
1:                    " \"SeqNbr\" integer NOT NULL," +
1:                    "CONSTRAINT \"PK_Priorities\" PRIMARY KEY " +
1:                    "  (\"TaskID\", \"Priority\"))");
1:                s.execute(
1:                    "CREATE VIEW appl.\"VW_MyTasks\" AS " +
1:                    "    SELECT * FROM appl.\"TBL_Tasks\" " +
1:                    "WHERE \"AssignedTo\" = SESSION_USER");
1:                s.execute(
1:                    "CREATE VIEW appl.\"VW_MyPriorityTasks\" AS " +
1:                    "    SELECT t.\"TaskID\", t.\"Task\", p.\"Priority\"" +
1:                    "    FROM appl.\"TBL_Tasks\" AS t," +
1:                    "         appl.\"TBL_Priorities\" AS p " +
1:                    "    WHERE p.\"TaskID\" = t.\"TaskID\" " +
1:                    "          AND t.\"AssignedTo\" = SESSION_USER");
1:                s.execute(
1:                    "CREATE VIEW appl.\"VW2_MyPriorityTasks\" AS " +
1:                    "    SELECT t.\"TaskID\", t.\"Task\", p.\"Priority\" " +
1:                    "    FROM appl.\"TBL_Tasks\" AS t INNER JOIN " +
1:                    "         appl.\"TBL_Priorities\" AS p ON " +
1:                    "         p.\"TaskID\" = t.\"TaskID\" " +
1:                    "    WHERE t.\"AssignedTo\" = SESSION_USER");
1:                s.execute(
1:                    "CREATE VIEW appl.\"VW3_MyPriorityTasks\" AS " +
1:                    "    SELECT t.\"TaskID\", t.\"Task\" " +
1:                    "    FROM appl.\"TBL_Tasks\" AS t " +
1:                    "    WHERE t.\"AssignedTo\" = SESSION_USER " +
1:                    "    AND EXISTS " +
1:                    "        (SELECT * FROM appl.\"TBL_Priorities\" AS p " +
1:                    "         WHERE p.\"TaskID\" = t.\"TaskID\")");
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * DERBY-5292
1:      */
1:     public void testViewDefinersRights () throws Exception {
1: 
1:         grant("select", "appl", "\"VW_MyTasks\"", users[1]);
1:         grant("select", "appl", "\"VW_MyPriorityTasks\"", users[1]);
1:         grant("select", "appl", "\"VW2_MyPriorityTasks\"", users[1]);
1:         grant("select", "appl", "\"VW3_MyPriorityTasks\"", users[1]);
1: 
1:         // OK before fix
1:         assertSelectPrivilege(
1:             true, users[1], "appl", "\"VW_MyTasks\"", null);
1:         assertSelectPrivilege(
1:             true, users[1], "appl", "\"VW_MyPriorityTasks\"", null);
1: 
1:         // Failed before fix
1:         assertSelectPrivilege(
1:             true, users[1], "appl", "\"VW2_MyPriorityTasks\"", null);
1:         assertSelectPrivilege(
1:             true, users[1], "appl", "\"VW3_MyPriorityTasks\"", null);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         schema = JDBC.identifierToCNF(schema);
1:         table  = JDBC.identifierToCNF(table);
1:         ResultSet rs = dm.getTablePrivileges(null, schema, table);
commit:65fd9e9
/////////////////////////////////////////////////////////////////////////
1: 		assertSelectPrivilege(false, users[2], "s2", "t1", null);
1: 		assertSelectPrivilege(false, users[2], "s2", "t2", null);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1fec7db
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Test test = new TestSuite(GrantRevokeTest.class);
1: 
1:         // DERBY-6238: Dump the contents of the lock table on lock timeout.
1:         // Helps debug intermittent lock timeouts seen in the test.
1:         test = DatabasePropertyTestSetup.singleProperty(
1:                 test, "derby.locks.deadlockTrace", "true");
1: 
1:         test = new CleanDatabaseTestSetup(test) {
/////////////////////////////////////////////////////////////////////////
1:         test = DatabasePropertyTestSetup.builtinAuthentication(
1:                 test, users, "grantrevoke");
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no SELECT permission on table", hasPrivilege);
1:                 printStackTrace(e);
1:                 fail("Unexpected lack of select privilege", e);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no DELETE permission on table", hasPrivilege);
1:                 printStackTrace(e);
1:                 fail("Unexpected lack of delete privilege", e);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no INSERT permission on table", hasPrivilege);
1:                 fail("Unexpected lack of insert privilege on " +
1:                      JDBC.escape(schema, table) + " by " + user, e);
/////////////////////////////////////////////////////////////////////////
1:                     assertSQLState("42502", e);
/////////////////////////////////////////////////////////////////////////
1: 
1:                 assertTrue("expected no UPDATE permission on table",
1:                            hasPrivilege);
1:                     printStackTrace(e);
1:                     fail("Unexpected lack of privilege to update on " +
1:                          JDBC.escape(schema, table) + " by " + user, e);
/////////////////////////////////////////////////////////////////////////
1:                     printStackTrace(e);
1:                     fail("Unexpected lack of references privilege", e);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no TRIGGER permission on table", hasPrivilege);
1:                 printStackTrace(e);
1:                 fail("Unexpected lack of trigger privilege on " +
1:                      JDBC.escape(schema, table) + " by " + user, e);
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no EXECUTE permission on function",
1:                        hasPrivilege);
/////////////////////////////////////////////////////////////////////////
1:                 printStackTrace(e);
1:                 fail("Unexpected lack of function execute privilege", e);
1: 
1:         c.close();
/////////////////////////////////////////////////////////////////////////
1:             assertTrue("expected no EXECUTE permission on procedure",
1:                        hasPrivilege);
1:                 printStackTrace(e);
1:                 fail("Unexpected lack of procedure execute privilege", e);
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> columnList = new ArrayList<String>();
1:         return columnList.toArray(new String[columnList.size()]);
commit:7585584
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("'S1.NOSUCH' is not recognized as a function.", e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("'S1.P1' is not recognized as a function.", e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("'S1.NOSUCH' is not recognized as a procedure.", e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:             assertEquals("'S1.F2' is not recognized as a procedure.", e.getMessage());
commit:8f3b0b9
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("42506", e);
1:             assertSQLState("42509", e);
1:             assertSQLState("42506", e);
1:             assertSQLState("42506", e);
/////////////////////////////////////////////////////////////////////////
1:     			assertSQLState("42502", e);
/////////////////////////////////////////////////////////////////////////
1:     			assertSQLState("42500", e);
/////////////////////////////////////////////////////////////////////////
1:     			assertSQLState("42502", e);
/////////////////////////////////////////////////////////////////////////
1:         			assertSQLState("42502", e);
/////////////////////////////////////////////////////////////////////////
0:         			assertSQLState("42502", e);
/////////////////////////////////////////////////////////////////////////
1:     			assertSQLState("42500", e);
/////////////////////////////////////////////////////////////////////////
1: 					assertSQLState("42504", e);
/////////////////////////////////////////////////////////////////////////
1: 				assertSQLState("42504", e);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:f1512cd
/////////////////////////////////////////////////////////////////////////
1: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
0:         	    assertEquals("'S1.NOSUCH' is not recognized as a function.", e.getMessage());
1:         	}
/////////////////////////////////////////////////////////////////////////
1:             if ( Locale.getDefault().getLanguage().equals("en") ) {
0:                 assertEquals("'S1.P1' is not recognized as a function.", e.getMessage());
1:             }
/////////////////////////////////////////////////////////////////////////
1:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
0:         	    assertEquals("'S1.NOSUCH' is not recognized as a procedure.", e.getMessage());
1:         	}
/////////////////////////////////////////////////////////////////////////
1:         	if ( Locale.getDefault().getLanguage().equals("en") ) {
0:         	    assertEquals("'S1.F2' is not recognized as a procedure.", e.getMessage());
1:         	}
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8a319fb
/////////////////////////////////////////////////////////////////////////
1:         
1:         // clean up
1:         revoke("select", "s1", "t1", "public");
1:         revoke("all privileges", "s1", "t1", users[1]);
1:         revoke("all privileges", "s1", "t1", users[2]);
1:         assertAllPrivileges(false, users[1], "S1", "T1", null);
1:         assertAllPrivileges(false, users[2], "S1", "T1", null);
1:         
commit:7e85449
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         	// also verify that grantor and is_grantable can be obtained
1:         	// Derby doesn't currently support the for grant option, the
1:         	// grantor is always the object owner - in this test, TEST_DBO,
1:         	// and is_grantable is always 'NO'
1:           	    assertEquals(rs.getString(4),"TEST_DBO");
1:           	    assertEquals(rs.getString(7),"NO");
/////////////////////////////////////////////////////////////////////////
1:     			// also verify that grantor and is_grantable are valid
1:     			// Derby doesn't currently support for grant, so
1:     			// grantor is always the object owner - in this test, 
1:     			// TEST_DBO, and getColumnPrivileges casts 'NO' for 
1:     			// is_grantable for supported column-related privileges
1: 					assertEquals("TEST_DBO", cp.getString(5));
1: 					assertEquals("NO", cp.getString(8));
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1ea5dac
/////////////////////////////////////////////////////////////////////////
1: 		assertUpdatePrivilege(true, users[4], "S1", "T1", new String[] {"C2", "C3"});
commit:3ce8a04
/////////////////////////////////////////////////////////////////////////
1:     	Connection c = openUserConnection(user);
/////////////////////////////////////////////////////////////////////////
1:             if (!hasPrivilege)
0:                fail("expected no INSERT permission on table");
1:     			assertSQLState("42500", e);
/////////////////////////////////////////////////////////////////////////
0:                 if (!hasPrivilege)
0:                   fail("expected no UPDATE permission on table");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ab91c04
/////////////////////////////////////////////////////////////////////////
0:             // DERBY-2893 INSERT seems to succeed.
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 // DERBY-2893 UPDATE seems to succeed.
commit:f3110ed
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:         revoke("execute", "function s1", "f1", users[2]);
/////////////////////////////////////////////////////////////////////////
1:         
1:         assertCompileError("42X01", "grant select on schema t1 to " + users[1]);
1:         assertCompileError("42X01",  "grant select on decimal t1 to " + users[1]);
/////////////////////////////////////////////////////////////////////////
1:         assertCompileError("42X01",
1:                 "grant execute on table s1.t1 to " + users[1]);
1:      }
1:         assertCompileError("42X01",
1:                 "grant select on function s1.f1 to " + users[1]);
1:    	
1:         assertCompileError("42X01",
1:                 "grant select on procedure s1.p1 to " + users[1]);
1:    }
1:         assertCompileError("42X01",
1:                 "grant execute on function s1.f1 to " + users[1] + " restrict");
1:         assertCompileError("42X01",
1:                "revoke execute on function s1.f1 from " + users[0]);
1:         assertCompileError("42X01",
1:     	     "revoke select on s1.t1 from " + users[0] + " restrict");
/////////////////////////////////////////////////////////////////////////
1:         
1:         Statement s = createStatement();
1:         s.executeUpdate(command.toString());
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:             
0:             if (!hasPrivilege)
0:                 fail("expected no SELECT permission on table");
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (!hasPrivilege)
0:                 fail("expected no DELETE permission on table");
1: 
/////////////////////////////////////////////////////////////////////////
0:             //if (!hasPrivilege)
0:             //    fail("expected no INSERT permission on table");
1: 
/////////////////////////////////////////////////////////////////////////
0:                 //if (!hasPrivilege)
0:                 //    fail("expected no UPDATE permission on table");
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (!hasPrivilege)
0:                 fail("expected no TRIGGER permission on table");
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (!hasPrivilege)
0:                 fail("expected no EXECUTE permission on function");
1: 
/////////////////////////////////////////////////////////////////////////
1: 		CallableStatement ps = c.prepareCall(procedurecall);
0:             if (!hasPrivilege)
0:                 fail("expected no EXECUTE permission on procedure");
1: 
/////////////////////////////////////////////////////////////////////////
1:         c.close();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:1b318a6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param procedure the name of the procedure to check
commit:97734e3
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.io.UnsupportedEncodingException;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import java.util.ArrayList;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * Test SQL GRANT and REVOKE statements
1:  */
1: public class GrantRevokeTest extends BaseJDBCTestCase {
1: 
1: 	public GrantRevokeTest(String name) {
1: 		super(name);
1: 	}
1: 	
1: 	/**
1: 	 * The set of users available for grant/revoke testing
1: 	 */
1: 	public final static String[] users = new String[] { "TEST_DBO","U1","U2","U3","U4"};
1: 	
1: 	/**
1: 	 * Most tests run in embedded only, since they are only checking DDL
1: 	 * statements. Metadata methods test also runs in client/server mode.
0: 	 * @return
1: 	 */
1: 	public static Test suite() {
0: 		TestSuite suite = new TestSuite();
1: 		
1: 		// following is useful for debugging the lock timeout seen in rollback tests,
1: 		// can connect via network server and look at the lock table.
1: 		//suite.addTest(TestConfiguration.clientServerDecorator(basesuite()));
1: 		
1: 		suite.addTest(basesuite());
1: 		suite.addTest(TestConfiguration.clientServerDecorator(new GrantRevokeTest("testGrantDatabaseMetaDataMethods")));
1: 
1: 		return suite;
1: 	}
1: 	
1: 	/**
1: 	 * One set of grant/revoke tests for either client/server or embedded.
1: 	 */
1: 	public static Test basesuite() {
0: 		Test basesuite = new TestSuite(GrantRevokeTest.class);
0: 		Test clean = new CleanDatabaseTestSetup(basesuite) {
1: 	    	protected void decorateSQL(Statement s) throws SQLException {
1: 	    		s.execute("create schema s1");
1: 	    		s.execute("create schema s2");
1: 	    		s.execute("create table s1.t1(c1 int, c2 int, c3 int)");
1: 	    		s.execute("create table s2.t1(c1 int, c2 int, c3 int)");
1: 	    		s.execute("create table s2.t2(c1 int, c2 int, c3 int)");
1: 	    		s.execute("create table s2.t3(c1 int, c2 int, c3 int)");
1: 	    	    s.execute("create table s2.noPerms(c1 int, c2 int, c3 int)");
1: 	    	    s.execute("create function s1.f1() returns int" +
1: 	    	        "  language java parameter style java" +
1: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1F1'" +
1: 	    	        "  no sql called on null input");
1: 	    	    /*
1: 	    	     * RESOLVE Derby does not implement SPECIFIC names
1: 	    	       
1: 	    	       s.execute("create function s2.f1() returns int" +
1:                              "  specific s2.s2sp1" +
1: 	    	                 "  language java parameter style java" +
1: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1a'" +
1: 	    	                 "  no sql called on null input");
1: 	    	     * RESOLVE Derby doesn't seem to support function overloading. It doesn't allow us to create two
1: 	    	     * functions with the same name but different signatures. (Though the StaticMethodCallNode.bindExpression
1: 	    	     * method does have code to handle overloaded methods). So we cannot throughly test
1: 	    	     * grant/revoke on overloaded procedures.
1: 	    	        	         
1: 	    	       s.execute("create function s2.f1( p1 char(8)) returns int" +
1: 	    	                 "  language java parameter style java" +
1: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1b'" +
1: 	    	                 "  no sql called on null input");
1: 	    	       s.execute("create function s2.f1( char(8), char(8)) returns int" +
1: 	    	                 "  language java parameter style java" +
1: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1c'" +
1: 	    	                 "  no sql called on null input");
1: 	    	       s.execute("create function s2.f1( int) returns int" +
1: 	    	                 "  language java parameter style java" +
1: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.grantRevoke.s2F1d'" +
1: 	    	                 "  no sql called on null input");
1: 	    	      
1: 	    	       NOTE: This function definition does not match the s2F2() definition
1: 	    	             in this class, and thus is not used.
1: 	    	       s.execute("create function s2.f2( p1 char(8), p2 integer) returns int" +
1: 	    	                 "  language java parameter style java" +
1: 	    	                 "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s2F2'" +
1: 	    	                 "  no sql called on null input");
1:                  */
1: 	    	   
1: 	    	   // functions and procedures are supposed to have separate name spaces. Make sure that this does
1: 	    	   // not confuse grant/revoke.
1: 	    	   s.execute("create procedure s1.f1( )" +
1: 	    	        "  language java parameter style java" +
1: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1F1P'" +
1: 	    	        "  no sql called on null input");
1: 	    	   s.execute("create procedure s1.p1( )" +
1: 	    	        "  language java parameter style java" +
1: 	    	        "  external name 'org.apache.derbyTesting.functionTests.tests.lang.GrantRevokeTest.s1P1'" +
1: 	    	        "  no sql called on null input");
1: 	    	}
1: 	    };
0: 		Test test = DatabasePropertyTestSetup.builtinAuthentication(
0: 				clean, users, "grantrevoke");
1:         test = TestConfiguration.sqlAuthorizationDecorator(test);
1: 	    
1: 	    return test;
1: 	}
1: 	
1: 	public void testSimpleGrant() throws Exception {
1: 		grant("select", "s1", "t1", users[1]);
1: 		assertSelectPrivilege(true, users[1], "s1", "t1", null);
1: 		assertSelectPrivilege(false, users[2], "s1", "t1", null);
1: 		assertSelectPrivilege(false, users[2], "s1", "t1", null);
1: 		revoke("select", "s1", "t1", users[1]);
1: 	}
1: 	
1: 	public void testAllPrivileges() throws Exception {
1: 		grant("all privileges", "s2", "t1", new String[] {users[2], users[3]});
1: 		assertAllPrivileges(false, users[1], "S2", "T1", null);
1: 		assertAllPrivileges(true, users[2], "S2", "T1", null);
1: 		assertAllPrivileges(true, users[3], "S2", "T1", null);
1: 		assertSelectPrivilege(false, users[1], "s1", "t1", null);
1: 		assertSelectPrivilege(false, users[1], "s2", "t2", null);
1: 		revoke("all privileges", "s2", "t1", new String[] {users[2], users[3]});
1: 	}
1: 	
1: 	public void testColumnPrivileges() throws Exception {
1: 		grant("select(c1),update(c3,c2),references(c3,c1,c2)", "s1", "t1", users[4]);
1: 		assertSelectPrivilege(true, users[4], "s1", "t1", new String[] {"c1"});
1: 		assertSelectPrivilege(false, users[4], "s1", "t1", new String[] {"c2"});
1: 		assertSelectPrivilege(false, users[4], "s1", "t1", new String[] {"c3"});
1: 		assertSelectPrivilege(false, users[4], "s1", "t1", null);
1: 		assertUpdatePrivilege(false, users[4], "S1", "T1", new String[] {"C1"});
0: 		assertUpdatePrivilege(false, users[4], "S1", "T1", new String[] {"C2", "C3"});
1: 		assertReferencesPrivilege(true, users[4], "s1", "t1", new String[] {"c1","c2","c3"});
1: 		revoke("select(c1),update(c3,c2),references(c3,c1,c2)", "s1", "t1", users[4]);
1: 	}
1: 	
1: 	public void testFunctionWithSameProcedureName() throws Exception {
1: 		grant("execute", "function s1", "f1", users[1]);
1: 		assertFunctionPrivilege( true, users[1], "S1", "F1", false);
1: 		assertProcedurePrivilege( false, users[1], "S1", "F1");
1: 		assertFunctionPrivilege( false, users[2], "S1", "F1", false);
1: 		revoke("execute", "function s1", "f1", users[1]);
1: 	}
1: 	
1: 	public void testGrantOnProcedure() throws Exception {
1: 		grant("execute", "procedure s1", "p1", users[1]);
1: 		assertProcedurePrivilege( true, users[1], "S1", "P1");
1: 		assertFunctionPrivilege( false, users[1], "S1", "P1", true);
1: 		assertProcedurePrivilege( false, users[2], "S1", "P1");
1: 		assertFunctionPrivilege( false, users[2], "S1", "P1", true);
1: 		revoke("execute", "procedure s1", "p1", users[1]);
1: 	}
1: 	
1:     public void testPublicTablePrivileges() throws Exception {
1:     	grant("select, references(c1)", "s2", "t2", "public");
1:     	assertSelectPrivilege(true, users[4], "S2", "T2", null);
1:         assertSelectPrivilege(true, users[1], "S2", "T2", null);
1:         assertSelectPrivilege(false, users[4], "S2", "NOPERMS", null);
1:         assertUpdatePrivilege(false, users[4], "S2", "T2", null);
1:         assertReferencesPrivilege(true, users[4], "S2", "T2",
1:                                  new String[] {"C1"});
1:         assertReferencesPrivilege(false, users[4], "S2", "T2", null);
1:     	revoke("select, references(c1)", "s2", "t2", "public");
1:     }
1:     
1:     public void testPublicRoutinePrivileges() throws Exception {
1:         grant("execute", "procedure s1", "p1", "public");
1:         grant("execute", "procedure s1", "p1", users[1]);        
1: 		assertProcedurePrivilege(true, users[1], "S1", "P1");
1: 		assertProcedurePrivilege(true, users[4], "S1", "P1");
1:         revoke("execute", "procedure s1", "p1", "public");
1:         // user1 should still have execute privilege
1:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:         assertProcedurePrivilege(false, users[4], "S1", "P1");
1:         revoke("execute", "procedure s1", "p1", users[1]);
1:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:     }
1: 
1:     /**
1:      * Test grant statements before, during, and after a rolled-back
1:      * transaction
1:      */
1:     public void testGrantRollbackAndCommit() throws SQLException {
1:     
1:     	// NOTE: grantrevoke.java originally used S2.F2 for the function
1:     	// below, but the signature on the function didn't match the
1:     	// declaration, so was not used properly. Have substituted
1:     	// function S1.F1 here to get the testcase to pass.
1:     	
1:     	// NOTE 2: executing the grant statements on the owner connection
1:     	//         leads to a lock timeout when asserting any privilege?
1:     	
1:     	Connection oc = openUserConnection(users[0]);
1:     	oc.setAutoCommit(false);
1:     	
1:     	// set up some privileges and check them
1:     	grant(oc, "select", "s2", "t2", "public");
1:     	oc.commit();
1: 
1:         assertSelectPrivilege(true, users[3], "S2", "T2", null);
1:         assertUpdatePrivilege(false, users[3], "S2", "T2", null);
1:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:     	
1:     	// alter some privileges, assert that they were granted.
1:         grant(oc, "select(c2),delete", "s2", "t3", users[1]);
1:         grant(oc, "trigger", "s2", "t2", "public");
1:     	grant(oc, "execute", "function s1", "f1", users[1]);
1:         // the following asserts fail due to lock timeout
1:     	//assertSelectPrivilege(true, users[1], "s2", "t3", new String[] {"C2"});
1:         //assertDeletePrivilege(true, users[1], "s2", "t3");
1:         //assertTriggerPrivilege(true, users[2], "S2", "T2");
1:         //assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         
1:         // roll it back and assert the privileges were not granted.
1:         oc.rollback();
1:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:         
1:         // do it again... 
1:         grant(oc, "select(c2),delete", "s2", "t3", users[1]);
1:         grant(oc, "trigger", "s2", "t2", "public");
1:     	grant(oc, "execute", "function s1", "f1", users[1]);
1:         // the following asserts fail due to lock timeout
1:     	//assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C2"});
1:         //assertDeletePrivilege(true, users[1], "S2", "T3");
1:         //assertTriggerPrivilege(true, users[2], "S2", "T2");
1:         //assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         
1:         // commit and ensure the permissions are correct
1:         oc.commit();
1:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C2"});
1:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:         assertTriggerPrivilege( true, users[2], "S2", "T2");
1:         assertFunctionPrivilege( true, users[1], "S1", "F1", false);
1:        
1:     	// remove any permissions we granted
1:     	revoke(oc, "select", "s2", "t2", "public");
1:     	revoke(oc, "select(c2),delete", "s2", "t3", users[1]);
1:         revoke(oc, "trigger", "s2", "t2", "public");
1:     	revoke(oc, "execute", "function s1", "f1", users[1]);
1:     	oc.commit();
1:     	oc.setAutoCommit(false);
1:         assertSelectPrivilege(false, users[3], "S2", "T2", null);
1:         assertUpdatePrivilege(false, users[3], "S2", "T2", null);
1:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2"});
1:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:         assertTriggerPrivilege(false, users[2], "S2", "T2");
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:     	
1:     	oc.close();
1:     	
1:     }
1: 	/**
1: 	 * Test Grant/Revoke related DatabaseMetaData methods.
1: 	 */
1:     public void testGrantDatabaseMetaDataMethods() throws Exception{
1:     	DatabaseMetaData dm = getConnection().getMetaData();
1:     	assertFalse("GrantRevoke: DatabaseMetaData.supportsCatalogsInPrivilegeDefinitionSupport", dm.supportsCatalogsInPrivilegeDefinitions());
1:     	assertTrue("GrantRevoke: DatabaseMetaData.supportsSchemasInPrivilegeDefinitions", dm.supportsSchemasInPrivilegeDefinitions());
1:     }
1:     
1:     /* Revoke test methods begin here */
1:     
1:     /**
1:      * Test revoke statements when user already has no permissions.
1:      */
1:     public void testRevokeWithNoPermissions() throws Exception {
1:         // assert users don't already have these privileges.
1:     	assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:         assertSelectPrivilege(false, users[2], "S1", "T1", new String[] {"C2"});
1:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C3"});
1:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:         
1:         // no unexpected exception should be thrown revoking these privileges.
1:         revoke("all privileges", "s1", "t1", users[1]);
1:     	assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:         assertSelectPrivilege(false, users[1], "S1", "T1", new String[] {"C2"});
1:         revoke("execute", "procedure s1", "p1", users[1]);
1:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:         revoke("select(c2), update(c1,c3)", "s1", "t1", users[2]);
1:         assertSelectPrivilege(false, users[2], "S1", "T1", new String[] {"C2"});
1:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C3"});  
1:     }
1:     
1:     public void testRevokeSingleTableSingleUser() throws Exception {
1:     	grant("all privileges", "s2", "t1", users[1]);
1:         grant("update(c3)", "s2", "t1", users[1]);
1:         assertSelectPrivilege(true, users[1], "S2", "T1", null);
1:         assertUpdatePrivilege(true, users[1], "S2", "T1", new String[] {"C3"});  
1:         
1:         revoke("update", "S2", "t1", users[1]);
1:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:         assertUpdatePrivilege( false, users[1], "S2", "T1", null);
1:         assertUpdatePrivilege( false, users[1], "S2", "T1", new String[] {"C3"});
1:         assertInsertPrivilege( true, users[1], "S2", "T1", null);
1:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:         assertReferencesPrivilege( true, users[1], "S2", "T1", null);
1:         assertTriggerPrivilege( true, users[1], "S2", "T1");
1:         
1:         revoke("all privileges", "s2", "t1", users[1]);
1:         assertAllPrivileges(false, users[1], "S2", "T1", null);
1:     }
1:     
1:     public void testRevokeMultiplePermissionsMultipleUsers() throws SQLException {
1:     	grant("select", "s1", "t1", new String[] {users[1], users[2], users[3]});
1:     	grant("update(c1,c2,c3)", "s1", "t1", users[1]);
1:     	grant("update(c3)", "s1", "t1", users[2]);
1:     	grant("trigger", "s1", "t1", users[1]);
1:         assertSelectPrivilege(true, users[1], "S1", "T1", null);
1:         assertSelectPrivilege(true, users[2], "S1", "T1", null);
1:         assertSelectPrivilege(true, users[3], "S1", "T1", null);
1:         // DatabaseMetaData.getTablePrivileges() returns false for the following
1:         // due to column privileges for table being used, so assert
1:         // with null for columns is disabled
1:         //assertUpdatePrivilege(true, users[1], "S1", "T1", null);  
1:         assertUpdatePrivilege(true, users[1], "S1", "T1", new String[] {"C1", "C2", "C3" }); 
1:         assertUpdatePrivilege(false, users[2], "S1", "T1", new String[] {"C1", "C2"});
1:         assertUpdatePrivilege(true, users[2], "S1", "T1", new String[] {"C3"});
1:         assertTriggerPrivilege(true, users[1], "S1", "T1");
1:         assertTriggerPrivilege(false, users[2], "S1", "T1");
1:         
1:         revoke("select, update(c2,c3)", "s1", "t1", new String[] {users[1], users[2], users[3]});
1:         assertSelectPrivilege(false, users[1], "S1", "T1", null);
1:         assertSelectPrivilege(false, users[2], "S1", "T1", null);
1:         assertSelectPrivilege(false, users[3], "S1", "T1", null);
1:         assertUpdatePrivilege(true, users[1], "S1", "T1", new String[] {"C1"});  
1:         assertUpdatePrivilege(false, users[1], "S1", "T1", new String[] {"C2", "C3"});
1:         assertUpdatePrivilege(false, users[2], "S1", "T1", null);
1:         assertTriggerPrivilege(true, users[1], "S1", "T1");
1:         assertTriggerPrivilege(false, users[2], "S1", "T1");
1:        
1:         revoke("update", "s1", "t1", users[1]);
1:         assertUpdatePrivilege(false, users[1], "S1", "T1", new String[] {"C1"});  
1:         assertUpdatePrivilege(false, users[1], "S1", "T1", null);
1:      
1:         revoke("all privileges", "s1", "t1", users[1]);
1:         assertAllPrivileges(false, users[1], "S1", "T1", null);
1:     }
1:     
1:     public void testRevokeExecutePrivileges() throws Exception {
1:     	grant("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:         grant("execute", "procedure s1", "f1", users[1]);
1:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertProcedurePrivilege(true, users[1], "S1", "F1");
1:         
1:         revoke("execute", "function s1", "f1", users[1]);
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertProcedurePrivilege(true, users[1], "S1", "F1");
1:         
1:         grant("execute", "function s1", "f1", users[1]);
1:         revoke("execute", "procedure s1", "f1", users[1]);
1:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertProcedurePrivilege(false, users[1], "S1", "F1");
1:         
1:     	revoke("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(false, users[2], "S1", "F1", false);
1:         assertProcedurePrivilege(false, users[1], "S1", "F1");
1:     }
1:     
1:     public void testRevokeWithPublicPrivilege() throws Exception {
1:         grant("select, delete", "s2", "t1", "public");
1:         grant("select, delete", "s2", "t1", new String[] {users[1], users[2]});
1:         grant("update(c1,c3)", "s2", "t1", "public");
1:         grant("update(c1,c3)", "s2", "t1", new String[] {users[1], users[2]});
1:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:         assertSelectPrivilege( true, users[2], "S2", "T1", null);
1:         assertSelectPrivilege( true, users[4], "S2", "T1", null);
1:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:         assertDeletePrivilege( true, users[2], "S2", "T1");
1:         assertDeletePrivilege( true, users[4], "S2", "T1");
1:         assertUpdatePrivilege( true, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege( true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege( true, users[4], "S2", "T1", new String[] {"C1", "C3"});
1: 
1:         // revoke from user, should still be able to access via public privilege
1:         revoke("select, update(c1,c3), delete", "S2", "T1", users[1]);
1:         assertSelectPrivilege( true, users[1], "S2", "T1", null);
1:         assertSelectPrivilege( true, users[2], "S2", "T1", null);
1:         assertSelectPrivilege( true, users[4], "S2", "T1", null);
1:         assertDeletePrivilege( true, users[1], "S2", "T1");
1:         assertDeletePrivilege( true, users[2], "S2", "T1");
1:         assertDeletePrivilege( true, users[4], "S2", "T1");
1:         assertUpdatePrivilege( true, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege( true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege( true, users[4], "S2", "T1", new String[] {"C1", "C3"});
1:        
1:         // now, revoke public permissions
1:         revoke("select, update(c1,c3), delete", "S2", "t1", "public");
1:         assertSelectPrivilege(false, users[1], "S2", "T1", null);
1:         assertSelectPrivilege(true, users[2], "S2", "T1", null);
1:         assertSelectPrivilege(false, users[4], "S2", "T1", null);
1:         assertDeletePrivilege(false, users[1], "S2", "T1");
1:         assertDeletePrivilege(true, users[2], "S2", "T1");
1:         assertDeletePrivilege(false, users[4], "S2", "T1");
1:         assertUpdatePrivilege(false, users[1], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege(true, users[2], "S2", "T1", new String[] {"C1", "C3"});
1:         assertUpdatePrivilege(false, users[4], "S2", "T1", new String[] {"C1", "C3"});
1: 
1:         // clean up
1:         revoke("all privileges", "S2", "t1", users[2]);
1:         assertAllPrivileges(false, users[2], "S2", "T1", null);
1:      }
1:     
1:     public void testRevokeExecuteWithPublicPrivilege() throws Exception {
1:         grant("execute", "function s1", "f1", "public");
1:         grant("execute", "function s1", "f1", new String[] {users[1], users[2]});
1:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[4], "S1", "F1", false);
1:         
1:         //revoke from user, should still be able to execute through public privilege
1:         revoke("execute", "function s1", "f1", users[1]);
1:         assertFunctionPrivilege(true, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[4], "S1", "F1", false);
1:    
1:         revoke("execute", "function s1", "f1", "public");
1:         assertFunctionPrivilege(false, users[1], "S1", "F1", false);
1:         assertFunctionPrivilege(true, users[2], "S1", "F1", false);
1:         assertFunctionPrivilege(false, users[4], "S1", "F1", false);
1:         
1:         // clean up
0:         revoke("execute", "function s1", "t1", users[2]);
1:         assertFunctionPrivilege(false, users[2], "s1", "F1", false);
1:     }
1:     
1:     public void testRevokeRollbackAndCommit() throws Exception {
1:         
1:     	// open a connection as database owner.
1:     	Connection oc = openUserConnection(users[0]);
1:     	oc.setAutoCommit(false);
1:    	
1:     	//set up some permissions
1:         grant(oc, "select(c1,c2), update(c1), insert, delete", "s2", "t3", users[1]);
1:         grant(oc, "select, references", "s2", "t3", users[2]);
1:         grant(oc, "select", "s2", "t3", users[3]);
1:         grant(oc, "execute", "procedure s1", "p1", users[1]);
1:         oc.commit();
1:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] { "C1", "C2"});
1:         assertUpdatePrivilege(true, users[1], "S2", "T3", new String[] { "C1"});
1:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:         assertSelectPrivilege(true, users[2], "S2", "T3", null);
1:         assertReferencesPrivilege(true, users[2], "S2", "T3", null);
1:         assertSelectPrivilege(true, users[3], "S2", "T3", null);
1:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:     	
1:     	// revoke the privileges and verify they were revoked.
1:         revoke(oc, "select(c2), update(c1), delete", "s2", "t3", users[1]);
1:         revoke(oc, "select, references", "s2", "t3", users[2]);
1:         revoke(oc, "select", "s2", "t3", users[3]);
1:         revoke(oc, "execute", "procedure s1", "p1", users[1]);
1:         // these asserts fail before rollback due to lock timeout
1:         //assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C1"});
1:         //assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C2", "C3"});
1:         //assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:         //assertInsertPrivilege(false, users[1], "S2", "T3", null);
1:         //assertDeletePrivilege(false, users[1], "S2", "T3");
1:         //assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:         //assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:         //assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:         //assertProcedurePrivilege(false, users[1], "S1", "P1");
1: 
1:         // rollback and verify that we have them again.
1:         oc.rollback();
1:         assertSelectPrivilege(true, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:         assertUpdatePrivilege(true, users[1], "S2", "T3", new String[] {"C1"});
1:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:         assertDeletePrivilege(true, users[1], "S2", "T3");
1:         assertSelectPrivilege(true, users[2], "S2", "T3", null);
1:         assertReferencesPrivilege(true, users[2], "S2", "T3", null);
1:         assertSelectPrivilege(true, users[3], "S2", "T3", null);
1:         assertProcedurePrivilege(true, users[1], "S1", "P1");
1:         
1:     	// revoke again, verify they were revoked.
1:         revoke(oc, "select(c2), update(c1), delete", "s2", "t3", users[1]);
1:         revoke(oc, "select, references", "s2", "t3", users[2]);
1:         revoke(oc, "select", "s2", "t3", users[3]);
1:         revoke(oc, "execute", "procedure s1", "p1", users[1]);
1:         // these asserts fail before commit due to lock timeout
1:         //assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:         //assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:         //assertInsertPrivilege(false, users[1], "S2", "T3", null);
1:         //assertDeletePrivilege(false, users[1], "S2", "T3");
1:         //assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:         //assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:         //assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:         //assertProcedurePrivilege(false, users[1], "S1", "P1");
1:         
1:         //commit and verify again
1:         oc.commit();
1:         oc.setAutoCommit(true);
1:         assertSelectPrivilege(false, users[1], "S2", "T3", new String[] {"C1", "C2"});
1:         assertUpdatePrivilege(false, users[1], "S2", "T3", new String[] {"C1"});
1:         assertInsertPrivilege(true, users[1], "S2", "T3", null);
1:         assertDeletePrivilege(false, users[1], "S2", "T3");
1:         assertSelectPrivilege(false, users[2], "S2", "T3", null);
1:         assertReferencesPrivilege(false, users[2], "S2", "T3", null);
1:         assertSelectPrivilege(false, users[3], "S2", "T3", null);
1:         assertProcedurePrivilege(false, users[1], "S1", "P1");
1:         
1:     }
1:     
1:     /*
1:      * TODO - write tests for abandoned views / triggers / constraints
1:      * 
1:     public void testAbandonedView() {
1:     	//TODO
1:     }
1:     
1:     public void testAbandonedTrigger() {
1:         //TODO	
1:     }
1: 
1:     public void testAbandonedConstraint() {
1:     	//TODO
1:     }
1:     */
1:     
1:     /*
0:      * TODO - write more extensive tests for DatabaseMetaData.getColumnPrivileges()
0:      *        and DatabaseMetaData.getTablePrivileges(). Specifically,
0:      *        would be nice to have some test cases which verify grantor
0:      *         and is_grantable are valid.
1:      */
1:     
1:     /* Begin standard error cases */
1:     
1:     public void testInvalidGrantAction() throws Exception {
1:     	try {
1:             grant("xx", "s1", "t1", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1: 
1:     public void testInvalidReservedWordAction() throws Exception {
1:     	try {
1:             grant("between", "s1", "t1", users[1]);
1:     	} catch (SQLException e) {
1:             	assertSQLState("42X01", e);
1:     	}
1: 
1:     	try {
0:             runSQLCommands("grant select on schema t1 to " + users[1]);
1:     	} catch (SQLException e) {
1:             	assertSQLState("42X01", e);
1:     	}
1:     	
1:     	try {
0:             runSQLCommands("grant select on decimal t1 to " + users[1]);
1:     	} catch (SQLException e) {
1:             	assertSQLState("42X01", e);
1:     	} 
1:     }
1: 
1:     public void testGrantOnNonexistantColumn() throws Exception {
1:     	try {
1:             grant("select(nosuchCol)", "s1", "t1", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X14", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantSchema() throws Exception {
1:     	try {
1:             grant("select", "nosuch", "t1", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y07", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantTable() throws Exception {
1:     	try {
1:             grant("select(nosuchCol)", "s1", "nosuch", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X05", e);
1:         }
1:     }
1: 
1:     public void testGrantOnFunctionWithBadSchema() throws Exception {
1:     	try {
1:             grant("execute", "function nosuch", "f0", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y07", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantFunction() throws Exception {
1:     	try {
1:             grant("execute", "function s1", "nosuch", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y03", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantFunctionForProcedure() throws Exception {
1:     	try {
1:             grant("execute", "function s1", "p1", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y03", e);
1:         }
1:     }
1:     
1:     public void testGrantOnProcedureWithBadSchema() throws Exception {
1:     	try {
1:             grant("execute", "procedure nosuch", "f0", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y07", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantProcedure() throws Exception {
1:     	try {
1:             grant("execute", "procedure s1", "nosuch", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y03", e);
1:         }
1:     }
1:     
1:     public void testGrantOnNonexistantProcedureForFunction() throws Exception {
1:     	try {
1:             grant("execute", "procedure s1", "f2", users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42Y03", e);
1:         }
1:     }
1:     
1:     public void testGrantExecuteOnTable() throws Exception {
1:     	try {
0:             runSQLCommands("grant execute on table s1.t1 to " + users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1:     
1:     public void testGrantSelectOnRoutine() throws Exception {
1:     	try {
0:             runSQLCommands("grant select on function s1.f1 to " + users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     	
1:     	try {
0:             runSQLCommands("grant select on procedure s1.p1 to " + users[1]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1:     
1:     public void testGrantExecuteWithRestrict() throws Exception {
1:     	// restrict invalid in grant statement
1:     	try {
0:             runSQLCommands("grant execute on function s1.f1 to " + users[1] + " restrict");
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1:     
1:     public void testGrantRevokeWithoutRestrict() throws Exception {
1:     	// restrict invalid in grant statement
1:     	try {
0:             runSQLCommands("revoke execute on function s1.f1 from " + users[0]);
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1:     
1:     public void testGrantRevokeSelectWithRestrict() throws Exception {
1:     	// restrict invalid in grant statement
1:     	try {
0:             runSQLCommands("revoke select on s1.t1 from " + users[0] + " restrict");
1:     	} catch (SQLException e) {
1:         	assertSQLState("42X01", e);
1:         }
1:     }
1:     
1:     public void testGrantDeleteWithColumnList() throws Exception {
1:     	try {
1:     		grant("delete(c1)", "s1", "t1", users[1]);
1:     	} catch (SQLException e) {
1:     		assertSQLState("42X01", e);
1:     	}
1:     }
1:     
1:     public void testGrantTriggerWithColumnList() throws Exception {
1:     	try {
1:     		grant("trigger(c1)", "s1", "t1", users[1]);
1:     	} catch (SQLException e) {
1:     		assertSQLState("42X01", e);
1:     	}
1:     }
1:     
1:     /* End standard error cases */
1:     
1:     /* Begin testcases from grantRevokeDDL */
1: 
1:     public void testOtherUserCannotRevokeOwnerPrivileges() throws SQLException {
1:     	grant("select", "s1", "t1", "public");
1:     	grant("insert", "s1", "t1", users[1]);
1:     	grant("update", "s1", "t1", users[1]);
1:     	grant("delete", "s1", "t1", users[1]);
1:     	grant("update(c1)", "s1", "t1", users[2]);
1:         try {
1:         	revoke(users[2], "select", "s1", "t1", "public");
1:         } catch (SQLException e) {
0:         	assertSQLState("2850C", e);
1:         }
1:         try {
1:         	revoke(users[2], "select", "s1", "t1", users[0]);
1:         } catch (SQLException e) {
0:         	assertSQLState("2850F", e);
1:         }
1:         try {
1:         	revoke(users[2], "insert", "s1", "t1", users[1]);
1:         } catch (SQLException e) {
0:         	assertSQLState("2850C", e);
1:         }
1:         try {
1:         	revoke(users[2], "update(c1)", "s1", "t1", users[2]);
1:         } catch (SQLException e) {
0:         	assertSQLState("2850C", e);
1:         }
1:     }
1:     
1:     /* End testcases from grantRevokeDDL */
1:     
1:     /* Begin utility methods specific to grant / revoke */
1:     
1:     /**
1:      * Grant a single permission to a single user.
1:      * Utility method that takes a single string for user instead
1:      * of an array of Strings.
1:      * 
1:      * @param perm Permission to grant
1:      * @param schema Schema on which to grant permission
1:      * @param table Table on which to grant permission
1:      * @param user User to grant permission to
1:      * @throws Exception throws all exceptions
1:      */
1: 	void grant(String perm, String schema, String table, String user) throws SQLException {
1: 		grant(perm, schema, table, new String[] {user});
1: 	}
1: 	
1:     /**
1:      * Grant a single permission from a specific user to a single user.
1:      * Utility method that takes a single string for user instead
1:      * of an array of Strings.
1:      * 
1:      * @param grantor Grantor of permission
1:      * @param perm Permission to grant
1:      * @param schema Schema on which to grant permission
1:      * @param table Table on which to grant permission
1:      * @param user User to grant permission to
1:      * @throws Exception throws all exceptions
1:      */
1: 	void grant(String grantor, String perm, String schema, String table, String user) throws SQLException {
1: 		Connection c = openUserConnection(grantor);
1: 		grant(c, perm, schema, table, user);
1: 		c.close();
1: 	}
1: 	
1: 	/**
1: 	 * Grant a SQL permission to a set of users.
1: 	 * 
1: 	 * @param perm The permission to grant
1: 	 * @param schema the schema on which to grant the permission
1: 	 * @param table the table on which to grant the permission
1: 	 * @param users an Array of users to grant the permission
1: 	 * @throws Exception throws all exceptions
1: 	 */
1: 	void grant(String perm, String schema, String table, String[] users) throws SQLException {
1: 		StringBuffer command = new StringBuffer("grant " + perm + " on " + schema + "." + table + " to " + users[0]);
1: 		for (int i = 1; i < users.length; i++ ) {
1: 		    command.append("," + users[i]);
1: 		}
1:         
1: 		// default connection is for database owner.
1: 		Statement s = getConnection().createStatement();
1: 		s.executeUpdate(command.toString());
1: 		s.close();
1: 	}
1: 	
1:     /**
1:      * Grant a single permission to a single user for a given connection.
1:      * Callers of this method should ensure that they close the Connection
1:      * that is passed in. Used primarily in rollback tests where we want to ensure
1:      * the grant/revoke statements are being called by the database owner.
1:      * 
1:      * @param c the Connection used to execute the grant statement
1:      * @param perm Permission to grant
1:      * @param schema Schema on which to grant permission
1:      * @param table Table on which to grant permission
1:      * @param user User to grant permission to
1:      * @throws Exception throws all exceptions
1:      */
1: 	void grant(Connection c, String perm, String schema, String table, String user) throws SQLException {
1: 		Statement s = c.createStatement();
1: 		s.executeUpdate("grant " + perm + " on " + schema + "." + table + " to " + user);
1: 		s.close();
1: 	}
1: 	
1:     /**
1:      * Revoke a single permission from a single user.
1:      * Utility method that takes a single string for user instead
1:      * of an array of Strings.
1:      * 
1:      * @param perm Permission to revoke
1:      * @param schema Schema on which to revoke permission
1:      * @param table Table on which to revoke permission
1:      * @param user User to revoke permissions
1:      * @throws Exception throws all exceptions
1:      */
1: 	void revoke(String perm, String schema, String table, String user) throws SQLException {
1: 		revoke(perm, schema, table, new String[] {user});
1: 	}
1: 	
1: 
1:     /**
1:      * Revoke a single permission from a specific user to a single user.
1:      * Utility method that takes a single string for user instead
1:      * of an array of Strings.
1:      * 
1:      * @param revoker Grantor of permission
1:      * @param perm Permission to revoke
1:      * @param schema Schema on which to revoke permission
1:      * @param table Table on which to revoke permission
1:      * @param user User to revoke permission to
1:      * @throws Exception throws all exceptions
1:      */
1: 	void revoke(String revoker, String perm, String schema, String table, String user) throws SQLException {
1: 		Connection c = openUserConnection(revoker);
1: 		revoke(c, perm, schema, table, user);
1: 		c.close();
1: 	}
1: 	
1: 	/**
1: 	 * Revoke a SQL permission from a set of users.
1: 	 * 
1: 	 * @param perm The permission to revoke
1: 	 * @param schema the schema on which to revoke the permission
1: 	 * @param table the table on which to revoke the permission
1: 	 * @param users an array of users to revoke the permission
1: 	 * @throws Exception throws all exceptions
1: 	 */
1: 	void revoke(String perm, String schema, String table, String[] users) throws SQLException {
1: 		StringBuffer command = new StringBuffer("revoke " + perm + " on " + schema + "." + table + " from " + users[0]);
1: 		for (int i = 1; i < users.length; i++ ) {
1: 		    command.append("," + users[i]);
1: 		}
1: 		//add restrict to revoke execute... 
1: 		if (perm.equalsIgnoreCase("execute"))
1: 			command.append(" restrict");
1: 		try {
0: 			runSQLCommands(command.toString());
0: 		} catch (UnsupportedEncodingException e) {
0: 			fail(e.getMessage());
1: 		}
1: 	}
1: 
1:     /**
1:      * Revoke a single permission to a single user for a given connection.
1:      * Callers of this method should ensure that they close the Connection
1:      * that is passed in. Used primarily in rollback tests where we want to ensure
1:      * the grant/revoke statements are being called by the database owner.
1:      * 
1:      * @param c the connection to execute the revoke statement
1:      * @param perm Permission to revoke
1:      * @param schema Schema on which to revoke permission
1:      * @param table Table on which to revoke permission
1:      * @param user User to revoke permission
1:      * @throws Exception throws all exceptions
1:      */
1: 	void revoke(Connection c, String perm, String schema, String table, String user) throws SQLException {
1: 		Statement s = c.createStatement();
1: 		s.execute("revoke " + perm + " on " + schema + "." + table + " from " + user + (perm.equalsIgnoreCase("execute") ? " restrict" : ""));
1: 		s.close();
1: 	}
1: 	
1:     /* End utility methods specific to grant / revoke */
1: 	
1: 	/**
1: 	 * Utility function to test grant/revoke
1: 	 * @return 1
1: 	 */
1:     public static int s1F1()
1:     {
1:         return 1;
1:     }
1:     
1:     /**
1:      * Another utility function to test grant/revoke - placeholder for
1:      * future if SPECIFIC names are implemented.
1:      * @return 1
1:      */
1:     public static int s2F1a()
1:     {
1:         return 1;
1:     }
1:     
1:     /**
1:      * Another utility function to test grant/revoke
1:      * @return 1
1:      */
1:     public static int s2F2()
1:     {
1:         return 1;
1:     }
1:     
1:     /**
1:      * Utility method to test procedure with identical name to a
1:      * function
1:      */
1:     public static void s1F1P( )
1:     {
1:     }
1:     
1:     /**
1:      * A utility method to test procedures with test grant/revoke
1:      */
1:     public static void s1P1( )
1:     {
1:     }
1:     
1:     /* 
1:      * public methods for asserting privileges begin here
1:      * May move to BaseJDBCTestCase if appropriate.
1:      */
1:     
1: 
1:     /**
1:      * Assert all privileges for a given user / schema / table / column set
1:      * 
1:      * @param hasPrivilege whether we expect the given user to have the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check for the user
1:      */
1:     public void assertAllPrivileges(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:     	assertSelectPrivilege(hasPrivilege, user, schema, table, columns);
1:     	assertDeletePrivilege(hasPrivilege, user, schema, table);
1:     	assertInsertPrivilege(hasPrivilege, user, schema, table, columns);
1:     	assertUpdatePrivilege(hasPrivilege, user, schema, table, columns);
1:     	assertReferencesPrivilege(hasPrivilege, user, schema, table, columns);
1:        	assertTriggerPrivilege(hasPrivilege, user, schema, table);
1:     }
1:     
1:     
1:     /**
1:      * Assert that a user has select privilege on a given table / column
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertSelectPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException{
1:     	Connection c = openUserConnection(user);
1:     	
1:     	Statement s = c.createStatement();
1:     	try {
1:     	    boolean b = s.execute("select " + columnListAsString(columns) + " from " + schema + "." + table);
1:     	    if (hasPrivilege)
1:     	    {
0:     	        assertEquals(true, b);
1:     	    }
1:     	} catch (SQLException e) {
1:     		if (!hasPrivilege) {
0:     			assertSQLState("28508", e);
1:     		} else {
0:     			e.printStackTrace();
0:     			fail("Unexpected lack of select privilege.");
1:     		}
1:     	}
1:         s.close();
1:     	c.close();
1:     	
1:     	assertPrivilegeMetadata(hasPrivilege, "SELECT", user, schema, table, columns);
1:     }
1:     
1:     /**
1:      * Assert that a user has delete privilege on a given table / column
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertDeletePrivilege(boolean hasPrivilege, String user, String schema, String table) throws SQLException {
1:     	Connection c = openUserConnection(user);
1:     	
1:     	Statement s = c.createStatement();
1:     	try {
1:     	    boolean b = s.execute("delete from " + schema + "." + table);
1:     	    if (hasPrivilege)
1:     	    {
0:     	        // b is false if no rows updated.
1:     	    }
1:     	} catch (SQLException e) {
1:     		if (!hasPrivilege) {
0:     			assertSQLState("28506", e);
1:     		} else {
0:     			fail("Unexpected lack of delete privilege.");
0:     			e.printStackTrace();
1:     		}
1:     	}
1:     	s.close();
1:     	c.close();
1:     	
1:     	assertPrivilegeMetadata(hasPrivilege, "DELETE", user, schema, table, null);
1:     }
1:     
1:     /**
1:      * Assert that a user has insert privilege on a given table / column
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertInsertPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:    	
1:     	// NOTE - getColumns returns empty result set if schema / table names not capitalized.
1:         // TODO - should implement asserting insert privilege on a subset of columns at some point
1:     	
0:     	Connection c = openUserConnection(users[0]);
1: 
1:     	Statement s = c.createStatement();
1:     	try {
1:     		StringBuffer command = new StringBuffer("insert into " + schema + "." + table + " values (");
1:     		ResultSet rs = c.getMetaData().getColumns( null, schema, table, null);
1:             boolean first = true;
1:             while(rs.next())
1:             {
1:                 if(first)
1:                     first = false;
1:                 else
1:                     command.append(",");
1:                 appendColumnValue(command, rs.getInt(5));
1:             }
1:             rs.close();
1:             command.append(")");
1:     	    int i = s.executeUpdate(command.toString());
1:     	    if (hasPrivilege)
1:     	    {
0:     	        assertEquals(1, i);
1:     	    }
1:     	} catch (SQLException e) {
1:     		if (!hasPrivilege) {
0:     			assertSQLState("28508", e);
1:     		} else {
0:     			fail("Unexpected lack of insert privilege on " + schema + "." + table + " by " + user);
1:     		}
1:     	}
1:     	s.close();
1:     	c.close();
1:     	
1:     	assertPrivilegeMetadata(hasPrivilege, "INSERT", user, schema, table, columns);
1:     }
1:     
1:     /**
1:      * Assert that a user has update privilege on a given table / column
1:      * 
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertUpdatePrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1:  
1:     	String[] checkColumns = (columns == null) ? getAllColumns(schema, table) : columns;
1:     	Connection c = openUserConnection(user);
1:     	
1:     	Statement s = c.createStatement();
1:     	int columnCount = 0;
1:     	boolean checkCount;
1:     	for (int i = 0; i < checkColumns.length; i++) {
1:     		checkCount = false;
1:   
1:     		try {
1:     			// if possible, get count of rows to verify update rows
1:     			try {
1:     				ResultSet countRS = s.executeQuery("select count(" + checkColumns[i] +") from " + schema + "." + table);
1:     			    if (!countRS.next()) {
1:     				    fail("Could not get count on " + checkColumns[i] + " to verify update");
1:     			    }
1:     			    columnCount = countRS.getInt(1);
1:     			    checkCount = true;
1:     			} catch (SQLException e) {
1:                     // may not have select privilege on the column, in
1:     				// which case, we simply don't verify the count.
1:     			}
1:     			
1:     			StringBuffer command = new StringBuffer("update " + schema + "." + table + " set " + checkColumns[i] + "=");
1:         		ResultSet rs = c.getMetaData().getColumns( (String) null, schema, table, checkColumns[i]);
1:                 if (!rs.next())
1:                 {
1:                 	fail("Could not get column metadata for " + checkColumns[i]);
1:                 }
1:                 appendColumnValue(command, rs.getInt( 5));
1:                 rs.close();
1:         	    int actualCount = s.executeUpdate(command.toString());
1:         	    if (hasPrivilege && checkCount)
1:         	    {
1:         	    	// update count should equal select count
1:         	        assertEquals(columnCount, actualCount);
1:         	    }
1:     		} catch (SQLException e) {
1:         		if (!hasPrivilege) {
0:         			assertSQLState("28508", e);
1:         		} else {
0:         			e.printStackTrace();
0:         			fail("Unexpected lack of privilege to update on " + schema + "." + table + " by " + user);
1:         		}
1:         	}
1:         }
1: 
1:         s.close();
1:     	c.close();
1:     	
1:     	assertPrivilegeMetadata(hasPrivilege, "UPDATE", user, schema, table, columns);
1:     }
1:     
1:     /**
1:      * Assert that a user has references privilege on a given table / column
1:      * 
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertReferencesPrivilege(boolean hasPrivilege, String user, String schema, String table, String[] columns) throws SQLException {
1: 
1:     	assertPrivilegeMetadata(hasPrivilege, "REFERENCES", user, schema, table, columns);
1:     	
1:     	/* no way to empirically test any arbitrary column can be
1:     	 * referenced, as the column that is to be referenced must be
1:     	 * a primary key or a unique constraint. Leaving this here, as it
1:     	 * might form the useful basis of another assert method for cases
1:     	 * where we know this to be certain.
1:     	
1:     	Connection c = openUserConnection(user);
1:     	Statement s = c.createStatement();
1:         for (int i = 0; i < columns.length; i++) {
1:             // if it works, need to assert this as false.
1:         	boolean b = true;
1:         	try {
1:         	    if (columns == null) {
1:             	    b = s.execute("create table referencestest (c1 " + getColumnDataType(schema, table, columns[i]) + " references " + schema + "." + table + ")" );
1:         	    } else {
1:         	        b = s.execute("create table referencestest (c1 " + getColumnDataType(schema, table, columns[i]) + " references " + schema + "." + table + "(" + column + "))" );
1:         	    }
1:         	} catch (SQLException e) {
1:         		if (!hasPrivilege) {
0:         			assertSQLState("28508", e);
1:         		} else {
0:         			e.printStackTrace();
0:         			fail("Unexpected lack of references privilege");
1:         		}
1:         	}
1:         	// no rows updated, so false.
1:         	assertFalse(b);
1:         	s.execute("drop table referencestest");   	
1:         }
1:         s.close();
1:         c.close();
1:         */
1:     }
1:     
1:     /**
1:      * Assert that a user has trigger execute privilege on a given table / column
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertTriggerPrivilege(boolean hasPrivilege, String user, String schema, String table) throws SQLException {
1:     	
1:     	Connection c = openUserConnection(user);
1:     	c.setAutoCommit(false);
1:     	
1:     	Statement s = c.createStatement();
1:     	try {
1:     	    int i = s.executeUpdate("create trigger \"" + table + "Trig\" after insert on " +
1:     	    		              schema + "." + table + " for each row values 1");
1:     	    if (hasPrivilege)
1:     	    {
1:     	        assertEquals(0, i); 
1:     	    }
1:     	} catch (SQLException e) {
1:     		if (!hasPrivilege) {
0:     			assertSQLState("28506", e);
1:     		} else {
0:     			e.printStackTrace();
0:     			fail("Unexpected lack of trigger privilege on " + schema + "." + table + " by " + user);
1:     		}
1:     	}
1:     	
1:     	c.rollback();
1:         s.close();
1:     	c.close();
1: 
1:     	assertPrivilegeMetadata(hasPrivilege, "TRIGGER", user, schema, table, null);
1:  
1:     }
1:     
1:     /**
1:      * Assert that a user has function execute privilege on a given table / column
1:      * 
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param function the function to check
1:      * @param forProcedure true if checking for lack of function execute privilege against procedure of same name.
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertFunctionPrivilege(boolean hasPrivilege, String user, String schema, String function, boolean forProcedure) throws SQLException {
1:         Connection c = openUserConnection(user);
1:         
1:         String functioncall = "values " + schema + "." + function + "()";
1:  
1: 	    PreparedStatement ps = null;
1: 	    ResultSet rs = null;
1: 		try {
1: 		    ps = c.prepareStatement(functioncall);
1: 		    rs = ps.executeQuery();
1: 		} catch (SQLException e) {
1: 			if (!hasPrivilege){
1: 				if (forProcedure) 
1: 					assertSQLState("42Y03", e);
1: 				else 
0:    				    assertSQLState("2850A", e);
1: 			} else {
0: 				e.printStackTrace();
0: 				fail("Unexpected lack of function execute privilege");
1: 			}
1: 		}
1: 		if (ps != null)
1: 			ps.close();
1: 		if (rs != null)
1: 			rs.close();
1:     }
1:     
1:     /**
1:      * Assert that a user has procedure execute privilege on a given table / column
1:      * 
1:      * @param hasPrivilege whether or not the user has the privilege
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @throws SQLException throws all exceptions
1:      */
1:     public void assertProcedurePrivilege(boolean hasPrivilege, String user, String schema, String procedure) throws SQLException {
1:         Connection c = openUserConnection(user);
1:         
1:         String procedurecall = "call " + schema + "." + procedure + "()";
1:         
0: 		PreparedStatement ps = c.prepareStatement(procedurecall);
1: 		ResultSet rs = null;
1: 		try {
1: 			ps.execute();
1: 			rs = ps.getResultSet();
1: 		} catch (SQLException e) {
0: 			if (!hasPrivilege)
0: 				assertSQLState("2850A", e);
1: 			else {
0: 				e.printStackTrace();
0: 				fail("Unexpected lack of procedure execute privilege.");
1: 			}
1: 		}
1: 		ps.close();
1: 		if (rs != null)
1: 		{
1: 				rs.close();
1: 		}
1:     }
1:     
1:     /**
1:      * Assert that a specific privilege exists by checking the
1:      * database metadata available to a user
1:      * 
1:      * @param hasPrivilege true if we expect the caller to have the privilege
1:      * @param type type of privilege, e.g. SELECT, INSERT, DELETE, etc.
1:      * @param user the user to check
1:      * @param schema the schema to check
1:      * @param table the table to check
1:      * @param columns the set of columns to check, or all columns if null
1:      * @throws SQLException
1:      */
1:     public void assertPrivilegeMetadata(boolean hasPrivilege, String type, String user, String schema, String table, String[] columns) throws SQLException {
1:         
1:     	Connection c = openUserConnection(user);
1:     	DatabaseMetaData dm = c.getMetaData();
0:     	ResultSet rs = dm.getTablePrivileges(null, schema.toUpperCase(), table.toUpperCase());
1:      	boolean found = false;
1:     	
1:     	// check getTablePrivileges
1:     	if (columns == null) {
1:         	while (rs.next())
1:         	{
1:           	    if (rs.getString(6).equals(type)) {
1:         	    	String privUser = rs.getString(5);
1:         	    	if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1:         	    		found = true;
1:         	    	}
1:         	    }
1:         	}
1:         	assertEquals(hasPrivilege, found);
1:         	rs.close();
1:     	}
1: 
1:     	// check getColumnPrivileges()
1:     	ResultSet cp = null;
1:     	if (columns == null) {
1:     		/*
1:     		 * Derby does not record table level privileges in SYSCOLPERMS,
1:     		 * so the following does not work. If it is ever changed so that
1:     		 * getColumnPrivileges returns proper results for table level privileges,
1:     		 * this can be reenabled.
1:     		 * 
1:         	ResultSet cols = dm.getColumns(null, schema.toUpperCase(), table.toUpperCase(), null);
1: 			int foundCount = 0;
1: 			int colCount = 0;
1:         	while (cols.next())
1:         	{
1: 				colCount++;
1:     			String col = cols.getString(4);
1:     			//System.out.println("getting column privs for " + col);
1:     			cp = dm.getColumnPrivileges(null, schema.toUpperCase(), table.toUpperCase(), col);
1: 
1:     			while (cp.next()) {
1: 
1: 					//System.out.println(schema + "." + table + ": "
1: 					//		+ cp.getString(4) + ", " + cp.getString(5) + ", "
1: 					//		+ cp.getString(6) + ", " + cp.getString(7));
1: 					if (cp.getString(7).equals(type)) {
1: 						String privUser = cp.getString(6);
1: 						if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1: 							foundCount++;
1: 						}
1: 					}
1: 				}
1:         	}
1: 			if (hasPrivilege) {
1: 				assertEquals(colCount, foundCount);
1: 			} else {
1: 			    assertFalse(colCount == foundCount);
1: 			}
1: 			*/
1:     	} else {
1:     		// or, check the given columns
1:     		for (int i = 0; i < columns.length; i++) {
1:     			cp = dm.getColumnPrivileges(null, schema.toUpperCase(), table.toUpperCase(), columns[i].toUpperCase());
1:     			found = false;
1:     			while (cp.next()) {
1: 					if (cp.getString(7).equals(type)) {
1: 						String privUser = cp.getString(6);
1: 						if (privUser.equals(user) || privUser.equals("PUBLIC")) {
1: 							found = true;
1: 						}
1: 					}
1:     			}
1:     			if (hasPrivilege)
1:     				assertTrue(found);
1:     		}        	
1:     	}
1: 		if (cp != null)
1: 			cp.close();
1:     	
1:     	c.close();
1:     }
1:     
1:     /* End assert methods */
1:     
1:     /* Begin helper methods */
1:     
1:     /**
1:      * Append a particular SQL datatype value to the given StringBuffer
1:      * 
1:      * @param sb the StringBuffer to append the value
1:      * @param type the java.sql.Types value to append
1:      */
1:     static void appendColumnValue(StringBuffer sb, int type)
1:     {
1:         switch(type)
1:         {
1:         case Types.BIGINT:
1:         case Types.DECIMAL:
1:         case Types.DOUBLE:
1:         case Types.FLOAT:
1:         case Types.INTEGER:
1:         case Types.NUMERIC:
1:         case Types.REAL:
1:         case Types.SMALLINT:
1:         case Types.TINYINT:
1:             sb.append("0");
1:             break;
1: 
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:             sb.append("' '");
1:             break;
1: 
1:         case Types.DATE:
1:             sb.append("CURRENT_DATE");
1:             break;
1: 
1:         case Types.TIME:
1:             sb.append("CURRENT_TIME");
1:             break;
1: 
1:         case Types.TIMESTAMP:
1:             sb.append("CURRENT_TIMESTAMP");
1:             break;
1: 
1:         default:
1:             sb.append("null");
1:             break;
1:         }
1:     }
1:     
1:     /**
1:      * Return the given String array as a comma separated String
1:      * 
1:      * @param columns an array of columns to format
1:      * @return a comma separated String of the column names
1:      */
1:     static String columnListAsString(String[] columns) {
1:     	if (columns == null) {
1:     		return "*";
1:     	}
1:     	
1:     	StringBuffer sb = new StringBuffer(columns[0]);
1: 		for (int i = 1; i < columns.length; i++ ) {
1: 		    sb.append("," + columns[i]);
1: 		}
1: 		return sb.toString();
1:     }
1:     
1:     /**
1:      * Get all the columns in a given schema / table
1:      * 
1:      * @return an array of Strings with the column names
1:      * @throws SQLException
1:      */    
1:     String[] getAllColumns(String schema, String table) throws SQLException
1:     {
1:     	DatabaseMetaData dbmd = getConnection().getMetaData();
0:         ArrayList columnList = new ArrayList();
1:         ResultSet rs = dbmd.getColumns( (String) null, schema, table, (String) null);
1:         while(rs.next())
1:         {
1:             columnList.add(rs.getString(4));
1:         }
1:           
0:         return (String[]) columnList.toArray(new String[0]);
1:     }
1:     
1:     /**
1:      * Given a schema, table, and column as Strings, return the datatype of
1:      * the column as a String.
1:      * 
1:      * @param schema the schema for the table in which the column resides
1:      * @param table the table containing the column to check
1:      * @param column the column to get the data type as a String
1:      * @return the Type of the column as a String
1:      * @throws SQLException
1:      */
1:     String getColumnDataType(String schema, String table, String column) throws SQLException {
1:     	DatabaseMetaData dm = getConnection().getMetaData();
1:     	ResultSet rs = dm.getColumns(null, schema, table, column);
1:     	
1:     	int type = 0;
1:     	while (rs.next()) {
1:     		type = rs.getInt(5);
1:     	}
1:     	rs.close();
1:     	return JDBC.sqlNameFromJdbc(type);
1:     }
1: }
============================================================================