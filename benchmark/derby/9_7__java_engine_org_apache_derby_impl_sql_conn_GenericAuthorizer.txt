1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.conn.GenericAuthorizer
1:345de35: 
1:575d6a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:575d6a1:    contributor license agreements.  See the NOTICE file distributed with
1:575d6a1:    this work for additional information regarding copyright ownership.
1:575d6a1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:575d6a1:    (the "License"); you may not use this file except in compliance with
1:575d6a1:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.conn;
1:eac0369: 
1:801cf0d: import java.util.List;
1:eac0369: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:801cf0d: import org.apache.derby.iapi.error.StandardException;
1:801cf0d: import org.apache.derby.iapi.reference.Property;
1:801cf0d: import org.apache.derby.iapi.reference.SQLState;
1:801cf0d: import org.apache.derby.iapi.services.property.PersistentSet;
1:801cf0d: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:801cf0d: import org.apache.derby.iapi.sql.Activation;
1:801cf0d: import org.apache.derby.iapi.sql.conn.Authorizer;
1:801cf0d: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:b7730e4: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
1:801cf0d: import org.apache.derby.iapi.util.IdUtil;
1:801cf0d: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:801cf0d: class GenericAuthorizer implements Authorizer
1:eac0369: {
1:eac0369: 	//
1:eac0369: 	//Enumerations for user access levels.
1:eac0369: 	private static final int NO_ACCESS = 0;
1:eac0369: 	private static final int READ_ACCESS = 1;
1:eac0369: 	private static final int FULL_ACCESS = 2;
1:eac0369: 	
1:eac0369: 	//
1:eac0369: 	//Configurable userAccessLevel - derived from Database level
1:eac0369: 	//access control lists + database boot time controls.
1:eac0369: 	private int userAccessLevel;
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	//Connection's readOnly status
1:eac0369:     boolean readOnlyConnection;
1:eac0369: 
1:eac0369: 	private final LanguageConnectionContext lcc;
1:eac0369: 	
1:9f60172:     GenericAuthorizer(LanguageConnectionContext lcc)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		this.lcc = lcc;
1:eac0369: 
1:9ac3a76: 		refresh();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Return true if the connection must remain readOnly
1:eac0369: 	  */
1:eac0369: 	private boolean connectionMustRemainReadOnly()
1:eac0369: 	{
1:eac0369: 		if (lcc.getDatabase().isReadOnly() ||
1:eac0369: 			(userAccessLevel==READ_ACCESS))
1:eac0369: 			return true;
1:eac0369: 		else
1:eac0369: 			return false;
3:8af8676: 	}
1:eac0369: 
2:eac0369: 	/**
1:b7730e4: 	  Used for operations that do not involve tables or routines.
1:eac0369:      
1:eac0369: 	  @see Authorizer#authorize
1:eac0369: 	  @exception StandardException Thrown if the operation is not allowed
1:eac0369: 	*/
1:b7730e4: 	public void authorize( int operation) throws StandardException
1:eac0369: 	{
1:b7730e4: 		authorize( (Activation) null, operation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:b7730e4: 	  @see Authorizer#authorize
1:b7730e4: 	  @exception StandardException Thrown if the operation is not allowed
1:eac0369: 	 */
1:b7730e4: 	public void authorize( Activation activation, int operation) throws StandardException
1:8af8676: 	{
1:eac0369: 		int sqlAllowed = lcc.getStatementContext().getSQLAllowed();
1:eac0369: 
1:eac0369: 		switch (operation)
1:eac0369: 		{
1:eac0369: 		case Authorizer.SQL_ARBITARY_OP:
1:eac0369: 		case Authorizer.SQL_CALL_OP:
1:eac0369: 			if (sqlAllowed == RoutineAliasInfo.NO_SQL)
1:eac0369: 				throw externalRoutineException(operation, sqlAllowed);
1:eac0369: 			break;
1:eac0369: 		case Authorizer.SQL_SELECT_OP:
1:eac0369: 			if (sqlAllowed > RoutineAliasInfo.READS_SQL_DATA)
1:eac0369: 				throw externalRoutineException(operation, sqlAllowed);
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		// SQL write operations
1:eac0369: 		case Authorizer.SQL_WRITE_OP:
1:eac0369: 		case Authorizer.PROPERTY_WRITE_OP:
1:eac0369: 			if (isReadOnlyConnection())
1:eac0369: 				throw StandardException.newException(SQLState.AUTH_WRITE_WITH_READ_ONLY_CONNECTION);
1:eac0369: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
1:eac0369: 				throw externalRoutineException(operation, sqlAllowed);
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		// SQL DDL operations
1:eac0369: 		case Authorizer.JAR_WRITE_OP:
1:eac0369: 		case Authorizer.SQL_DDL_OP:
1:eac0369:  			if (isReadOnlyConnection())
1:eac0369: 				throw StandardException.newException(SQLState.AUTH_DDL_WITH_READ_ONLY_CONNECTION);
1:eac0369: 
1:eac0369: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
1:eac0369: 				throw externalRoutineException(operation, sqlAllowed);
1:eac0369: 			break;
1:eac0369: 
1:eac0369: 		default:
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.THROWASSERT("Bad operation code "+operation);
1:eac0369: 		}
1:b7730e4:         if( activation != null)
1:eac0369:         {
1:801cf0d:             List<StatementPermission> requiredPermissionsList =
1:801cf0d:                 activation.getPreparedStatement().getRequiredPermissionsList();
1:eac0369: 
1:bf32514:             authorize( requiredPermissionsList, activation );
1:bf32514:         }
1:bf32514:     }
1:bf32514: 
1:bf32514: 	public void authorize
1:bf32514:         (
1:bf32514:          List<StatementPermission> requiredPermissionsList,
1:bf32514:          Activation activation
1:bf32514:          )
1:bf32514:         throws StandardException
1:bf32514:     {
1:bf32514:         DataDictionary dd = lcc.getDataDictionary();
1:bf32514: 
1:bf32514:         // Database Owner can access any object. Ignore 
1:bf32514:         // requiredPermissionsList for Database Owner
1:bf32514:         if( requiredPermissionsList != null    && 
1:bf32514:             !requiredPermissionsList.isEmpty() && 
1:bf32514:             !lcc.getCurrentUserId(activation).equals(
1:bf32514:                                                      dd.getAuthorizationDatabaseOwner()))
1:bf32514:         {
1:bf32514:             int ddMode = dd.startReading(lcc);
1:eac0369:                 
1:bf32514:             /*
1:bf32514:              * The system may need to read the permission descriptor(s) 
1:bf32514:              * from the system table(s) if they are not available in the 
1:bf32514:              * permission cache.  So start an internal read-only nested 
1:bf32514:              * transaction for this.
1:bf32514:              * 
1:bf32514:              * The reason to use a nested transaction here is to not hold
1:bf32514:              * locks on system tables on a user transaction.  e.g.:  when
1:bf32514:              * attempting to revoke an user, the statement may time out
1:bf32514:              * since the user-to-be-revoked transaction may have acquired 
1:bf32514:              * shared locks on the permission system tables; hence, this
1:bf32514:              * may not be desirable.  
1:bf32514:              * 
1:bf32514:              * All locks acquired by StatementPermission object's check()
1:bf32514:              * method will be released when the system ends the nested 
1:bf32514:              * transaction.
1:bf32514:              * 
1:bf32514:              * In Derby, the locks from read nested transactions come from
1:bf32514:              * the same space as the parent transaction; hence, they do not
1:bf32514:              * conflict with parent locks.
1:bf32514:              */  
1:bf32514:             lcc.beginNestedTransaction(true);
1:8af8676:             	
1:bf32514:             try 
1:bf32514:             {
2:8af8676:                 try 
1:8af8676:                 {
1:bf32514:                     // perform the permission checking
1:bf32514:                     for (StatementPermission rp : requiredPermissionsList)
1:8af8676:                     {
1:bf32514:                         rp.check(lcc, false, activation);
1:eac0369:                     }
1:eac0369:                 } 
2:8af8676:                 finally 
1:8af8676:                 {
1:bf32514:                     dd.doneReading(ddMode, lcc);
1:bf32514:                 }
1:8af8676:             } 
1:bf32514:             finally 
1:bf32514:             {
1:bf32514:                 // make sure we commit; otherwise, we will end up with 
1:bf32514:                 // mismatch nested level in the language connection context.
1:bf32514:                 lcc.commitNestedTransaction();
1:8af8676:             }
1:8af8676:         }
1:8af8676:     }
1:bf32514:     
1:bf32514:     /**
1:bf32514:      * Throw an exception if the user does not have all of the required permissions.
1:bf32514:      */
1:8af8676: 
1:eac0369: 	private static StandardException externalRoutineException(int operation, int sqlAllowed) {
1:eac0369: 
1:eac0369: 		String sqlState;
1:eac0369: 		if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
1:eac0369: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
1:eac0369: 		else if (sqlAllowed == RoutineAliasInfo.CONTAINS_SQL)
1:eac0369: 		{
1:eac0369: 			switch (operation)
1:eac0369: 			{
1:eac0369: 			case Authorizer.SQL_WRITE_OP:
1:eac0369: 			case Authorizer.PROPERTY_WRITE_OP:
1:eac0369: 			case Authorizer.JAR_WRITE_OP:
1:eac0369: 			case Authorizer.SQL_DDL_OP:
1:eac0369: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
1:eac0369: 				break;
1:eac0369: 			default:
1:eac0369: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_READS_SQL;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_SQL;
1:eac0369: 
1:eac0369: 		return StandardException.newException(sqlState);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 
1:eac0369: 	private void getUserAccessLevel() throws StandardException
1:eac0369: 	{
1:eac0369: 		userAccessLevel = NO_ACCESS;
1:eac0369: 		if (userOnAccessList(Property.FULL_ACCESS_USERS_PROPERTY))
1:eac0369: 			userAccessLevel = FULL_ACCESS;
1:eac0369: 
1:eac0369: 		if (userAccessLevel == NO_ACCESS &&
1:eac0369: 			userOnAccessList(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
1:eac0369: 			userAccessLevel = READ_ACCESS;
1:eac0369: 
1:eac0369: 		if (userAccessLevel == NO_ACCESS)
1:eac0369: 			userAccessLevel = getDefaultAccessLevel();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int getDefaultAccessLevel() throws StandardException
1:eac0369: 	{
1:eac0369: 		PersistentSet tc = lcc.getTransactionExecute();
1:50ba36b: 
1:801cf0d:         String modeS = PropertyUtil.getServiceProperty(
1:eac0369: 									tc,
1:eac0369: 									Property.DEFAULT_CONNECTION_MODE_PROPERTY);
1:eac0369: 		if (modeS == null)
1:eac0369: 			return FULL_ACCESS;
1:eac0369: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.NO_ACCESS))
1:eac0369: 			return NO_ACCESS;
1:eac0369: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.READ_ONLY_ACCESS))
1:eac0369: 			return READ_ACCESS;
1:eac0369: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.FULL_ACCESS))
1:eac0369: 			return FULL_ACCESS;
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.THROWASSERT("Invalid value for property "+
1:eac0369: 										  Property.DEFAULT_CONNECTION_MODE_PROPERTY+
1:eac0369: 										  " "+
1:eac0369: 										  modeS);
1:eac0369:  			return FULL_ACCESS;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private boolean userOnAccessList(String listName) throws StandardException
1:eac0369: 	{
1:eac0369: 		PersistentSet tc = lcc.getTransactionExecute();
1:801cf0d:         String listS = PropertyUtil.getServiceProperty(tc, listName);
1:9f60172:         return IdUtil.idOnList(lcc.getSessionUserId(),listS);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see Authorizer#isReadOnlyConnection
1:eac0369: 	 */
1:eac0369: 	public boolean isReadOnlyConnection()
1:eac0369: 	{
1:eac0369: 		return readOnlyConnection;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see Authorizer#isReadOnlyConnection
1:eac0369: 	  @exception StandardException Thrown if the operation is not allowed
1:eac0369: 	 */
1:eac0369: 	public void setReadOnlyConnection(boolean on, boolean authorize)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (authorize && !on) {
1:eac0369: 			if (connectionMustRemainReadOnly())
1:eac0369: 				throw StandardException.newException(SQLState.AUTH_CANNOT_SET_READ_WRITE);
1:eac0369: 		}
1:eac0369: 		readOnlyConnection = on;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see Authorizer#refresh
1:eac0369: 	  @exception StandardException Thrown if the operation is not allowed
1:eac0369: 	  */
1:801cf0d:     public final void refresh() throws StandardException
1:eac0369: 	{
1:eac0369: 		getUserAccessLevel();
1:eac0369: 		if (!readOnlyConnection)
1:eac0369: 			readOnlyConnection = connectionMustRemainReadOnly();
1:eac0369: 
1:eac0369: 		// Is a connection allowed.
1:eac0369: 		if (userAccessLevel == NO_ACCESS)
1:eac0369: 			throw StandardException.newException(SQLState.AUTH_DATABASE_CONNECTION_REFUSED);
1:eac0369: 	}
1:8af8676: 	
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:bf32514
/////////////////////////////////////////////////////////////////////////
1:             authorize( requiredPermissionsList, activation );
1:         }
1:     }
1: 
1: 	public void authorize
1:         (
1:          List<StatementPermission> requiredPermissionsList,
1:          Activation activation
1:          )
1:         throws StandardException
1:     {
1:         DataDictionary dd = lcc.getDataDictionary();
1: 
1:         // Database Owner can access any object. Ignore 
1:         // requiredPermissionsList for Database Owner
1:         if( requiredPermissionsList != null    && 
1:             !requiredPermissionsList.isEmpty() && 
1:             !lcc.getCurrentUserId(activation).equals(
1:                                                      dd.getAuthorizationDatabaseOwner()))
1:         {
1:             int ddMode = dd.startReading(lcc);
1:             /*
1:              * The system may need to read the permission descriptor(s) 
1:              * from the system table(s) if they are not available in the 
1:              * permission cache.  So start an internal read-only nested 
1:              * transaction for this.
1:              * 
1:              * The reason to use a nested transaction here is to not hold
1:              * locks on system tables on a user transaction.  e.g.:  when
1:              * attempting to revoke an user, the statement may time out
1:              * since the user-to-be-revoked transaction may have acquired 
1:              * shared locks on the permission system tables; hence, this
1:              * may not be desirable.  
1:              * 
1:              * All locks acquired by StatementPermission object's check()
1:              * method will be released when the system ends the nested 
1:              * transaction.
1:              * 
1:              * In Derby, the locks from read nested transactions come from
1:              * the same space as the parent transaction; hence, they do not
1:              * conflict with parent locks.
1:              */  
1:             lcc.beginNestedTransaction(true);
1:             try 
1:             {
1:                     // perform the permission checking
1:                     for (StatementPermission rp : requiredPermissionsList)
1:                         rp.check(lcc, false, activation);
1:                     dd.doneReading(ddMode, lcc);
1:             } 
1:             finally 
1:             {
1:                 // make sure we commit; otherwise, we will end up with 
1:                 // mismatch nested level in the language connection context.
1:                 lcc.commitNestedTransaction();
1:     
1:     /**
1:      * Throw an exception if the user does not have all of the required permissions.
1:      */
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.property.PersistentSet;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.util.StringUtil;
1: class GenericAuthorizer implements Authorizer
/////////////////////////////////////////////////////////////////////////
1:             List<StatementPermission> requiredPermissionsList =
1:                 activation.getPreparedStatement().getRequiredPermissionsList();
/////////////////////////////////////////////////////////////////////////
0:                         for (StatementPermission rp : requiredPermissionsList)
0:                             rp.check(lcc, false, activation);
/////////////////////////////////////////////////////////////////////////
1:         String modeS = PropertyUtil.getServiceProperty(
/////////////////////////////////////////////////////////////////////////
1:         String listS = PropertyUtil.getServiceProperty(tc, listName);
/////////////////////////////////////////////////////////////////////////
1:     public final void refresh() throws StandardException
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:     GenericAuthorizer(LanguageConnectionContext lcc)
/////////////////////////////////////////////////////////////////////////
0:                 !lcc.getCurrentUserId(activation).equals(
0:                     dd.getAuthorizationDatabaseOwner()))
/////////////////////////////////////////////////////////////////////////
0:                                 (lcc, false, activation);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return IdUtil.idOnList(lcc.getSessionUserId(),listS);
commit:12988c7
/////////////////////////////////////////////////////////////////////////
0:                             ((StatementPermission) iter.next()).check
0: 								(lcc, authorizationId, false, activation);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ac3a76
/////////////////////////////////////////////////////////////////////////
0: 						     LanguageConnectionContext lcc)
1: 		refresh();
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.conn.GenericAuthorizer
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.conn;
1: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.iapi.util.StringUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.property.PersistentSet;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import java.util.Properties;
1: 
0: class GenericAuthorizer
0: implements Authorizer
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	//
1: 	//Enumerations for user access levels.
1: 	private static final int NO_ACCESS = 0;
1: 	private static final int READ_ACCESS = 1;
1: 	private static final int FULL_ACCESS = 2;
1: 	
1: 	//
1: 	//Configurable userAccessLevel - derived from Database level
1: 	//access control lists + database boot time controls.
1: 	private int userAccessLevel;
1: 
1: 	//
1: 	//Connection's readOnly status
1:     boolean readOnlyConnection;
1: 
1: 	private final LanguageConnectionContext lcc;
1: 	
0: 	private final String authorizationId; //the userName after parsing by IdUtil 
1: 	
0: 	GenericAuthorizer(String authorizationId, 
0: 						     LanguageConnectionContext lcc,
0: 					         boolean sqlConnection)
1: 		 throws StandardException
1: 	{
1: 		this.lcc = lcc;
0: 		this.authorizationId = authorizationId;
1: 
0: 		//we check the access level only if this is coming from a sql
0: 		//connection, not internal logSniffer or StageTrunc db connection
0: 		if(sqlConnection)
0: 			refresh();
1: 	}
1: 
1: 	/*
1: 	  Return true if the connection must remain readOnly
1: 	  */
1: 	private boolean connectionMustRemainReadOnly()
1: 	{
1: 		if (lcc.getDatabase().isReadOnly() ||
1: 			(userAccessLevel==READ_ACCESS))
1: 			return true;
1: 		else
1: 			return false;
1: 	}
1: 
1: 	/**
1: 	  @see Authorizer#authorize
1: 	  @exception StandardException Thrown if the operation is not allowed
1: 	 */
0: 	public void authorize(int operation) throws StandardException
1: 	{
1: 		int sqlAllowed = lcc.getStatementContext().getSQLAllowed();
1: 
1: 		switch (operation)
1: 		{
1: 		case Authorizer.SQL_ARBITARY_OP:
1: 		case Authorizer.SQL_CALL_OP:
1: 			if (sqlAllowed == RoutineAliasInfo.NO_SQL)
1: 				throw externalRoutineException(operation, sqlAllowed);
1: 			break;
1: 		case Authorizer.SQL_SELECT_OP:
1: 			if (sqlAllowed > RoutineAliasInfo.READS_SQL_DATA)
1: 				throw externalRoutineException(operation, sqlAllowed);
1: 			break;
1: 
1: 		// SQL write operations
1: 		case Authorizer.SQL_WRITE_OP:
1: 		case Authorizer.PROPERTY_WRITE_OP:
1: 			if (isReadOnlyConnection())
1: 				throw StandardException.newException(SQLState.AUTH_WRITE_WITH_READ_ONLY_CONNECTION);
1: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
1: 				throw externalRoutineException(operation, sqlAllowed);
1: 			break;
1: 
1: 		// SQL DDL operations
1: 		case Authorizer.JAR_WRITE_OP:
1: 		case Authorizer.SQL_DDL_OP:
1:  			if (isReadOnlyConnection())
1: 				throw StandardException.newException(SQLState.AUTH_DDL_WITH_READ_ONLY_CONNECTION);
1: 
1: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
1: 				throw externalRoutineException(operation, sqlAllowed);
1: 			break;
1: 
1: 		default:
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT("Bad operation code "+operation);
1: 		}
1: 	}
1: 
1: 	private static StandardException externalRoutineException(int operation, int sqlAllowed) {
1: 
1: 		String sqlState;
1: 		if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
1: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
1: 		else if (sqlAllowed == RoutineAliasInfo.CONTAINS_SQL)
1: 		{
1: 			switch (operation)
1: 			{
1: 			case Authorizer.SQL_WRITE_OP:
1: 			case Authorizer.PROPERTY_WRITE_OP:
1: 			case Authorizer.JAR_WRITE_OP:
1: 			case Authorizer.SQL_DDL_OP:
1: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
1: 				break;
1: 			default:
1: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_READS_SQL;
1: 				break;
1: 			}
1: 		}
1: 		else
1: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_SQL;
1: 
1: 		return StandardException.newException(sqlState);
1: 	}
1: 	
1: 
1: 	/**
0: 	  @see Authorizer#getAuthorizationId
1: 	  */
0: 	public String getAuthorizationId()
1: 	{
0: 		return authorizationId;
1: 	}
1: 
1: 	private void getUserAccessLevel() throws StandardException
1: 	{
1: 		userAccessLevel = NO_ACCESS;
1: 		if (userOnAccessList(Property.FULL_ACCESS_USERS_PROPERTY))
1: 			userAccessLevel = FULL_ACCESS;
1: 
1: 		if (userAccessLevel == NO_ACCESS &&
1: 			userOnAccessList(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
1: 			userAccessLevel = READ_ACCESS;
1: 
1: 		if (userAccessLevel == NO_ACCESS)
1: 			userAccessLevel = getDefaultAccessLevel();
1: 	}
1: 
1: 	private int getDefaultAccessLevel() throws StandardException
1: 	{
1: 		PersistentSet tc = lcc.getTransactionExecute();
0: 		String modeS = (String)
0: 			PropertyUtil.getServiceProperty(
1: 									tc,
1: 									Property.DEFAULT_CONNECTION_MODE_PROPERTY);
1: 		if (modeS == null)
1: 			return FULL_ACCESS;
1: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.NO_ACCESS))
1: 			return NO_ACCESS;
1: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.READ_ONLY_ACCESS))
1: 			return READ_ACCESS;
1: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.FULL_ACCESS))
1: 			return FULL_ACCESS;
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT("Invalid value for property "+
1: 										  Property.DEFAULT_CONNECTION_MODE_PROPERTY+
1: 										  " "+
1: 										  modeS);
1:  			return FULL_ACCESS;
1: 		}
1: 	}
1: 
1: 	private boolean userOnAccessList(String listName) throws StandardException
1: 	{
1: 		PersistentSet tc = lcc.getTransactionExecute();
0: 		String listS = (String)
0: 			PropertyUtil.getServiceProperty(tc, listName);
0: 		return IdUtil.idOnList(authorizationId,listS);
1: 	}
1: 
1: 	/**
1: 	  @see Authorizer#isReadOnlyConnection
1: 	 */
1: 	public boolean isReadOnlyConnection()
1: 	{
1: 		return readOnlyConnection;
1: 	}
1: 
1: 	/**
1: 	  @see Authorizer#isReadOnlyConnection
1: 	  @exception StandardException Thrown if the operation is not allowed
1: 	 */
1: 	public void setReadOnlyConnection(boolean on, boolean authorize)
1: 		 throws StandardException
1: 	{
1: 		if (authorize && !on) {
1: 			if (connectionMustRemainReadOnly())
1: 				throw StandardException.newException(SQLState.AUTH_CANNOT_SET_READ_WRITE);
1: 		}
1: 		readOnlyConnection = on;
1: 	}
1: 
1: 	/**
1: 	  @see Authorizer#refresh
1: 	  @exception StandardException Thrown if the operation is not allowed
1: 	  */
0: 	public void refresh() throws StandardException
1: 	{
1: 		getUserAccessLevel();
1: 		if (!readOnlyConnection)
1: 			readOnlyConnection = connectionMustRemainReadOnly();
1: 
1: 		// Is a connection allowed.
1: 		if (userAccessLevel == NO_ACCESS)
1: 			throw StandardException.newException(SQLState.AUTH_DATABASE_CONNECTION_REFUSED);
1: 	}
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:8af8676
/////////////////////////////////////////////////////////////////////////
0:             if( requiredPermissionsList != null    && 
0:                 !requiredPermissionsList.isEmpty() && 
0:                 int ddMode = dd.startReading(lcc);
1:                 
0:                  /*
0:                   * The system may need to read the permission descriptor(s) 
0:                   * from the system table(s) if they are not available in the 
0:                   * permission cache.  So start an internal read-only nested 
0:                   * transaction for this.
0:                   * 
0:                   * The reason to use a nested transaction here is to not hold
0:                   * locks on system tables on a user transaction.  e.g.:  when
0:                   * attempting to revoke an user, the statement may time out
0:                   * since the user-to-be-revoked transaction may have acquired 
0:                   * shared locks on the permission system tables; hence, this
0:                   * may not be desirable.  
0:                   * 
0:                   * All locks acquired by StatementPermission object's check()
0:                   * method will be released when the system ends the nested 
0:                   * transaction.
0:                   * 
0:                   * In Derby, the locks from read nested transactions come from
0:                   * the same space as the parent transaction; hence, they do not
0:                   * conflict with parent locks.
0:                   */  
0:                 lcc.beginNestedTransaction(true);
1:             	
1:                 try 
1:                     try 
1:                     {
0:                     	// perform the permission checking
0:                         for (Iterator iter = requiredPermissionsList.iterator(); 
0:                             iter.hasNext();) 
1:                         {
0:                             ((StatementPermission) iter.next()).check(lcc, 
0:                                 authorizationId, false);
1:                         }
1:                     } 
1:                     finally 
1:                     {
0:                         dd.doneReading(ddMode, lcc);
1:                     }
1:                 } 
1:                 finally 
1:                 {
0:                 	// make sure we commit; otherwise, we will end up with 
0:                 	// mismatch nested level in the language connection context.
0:                     lcc.commitNestedTransaction();
1:                 }
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 	
commit:439d1e8
/////////////////////////////////////////////////////////////////////////
0:             // Database Owner can access any object. Ignore 
0:             // requiredPermissionsList for Database Owner
0: 				!authorizationId.equals(dd.getAuthorizationDatabaseOwner()))
author:David Van Couvering
-------------------------------------------------------------------------------
commit:575d6a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:eb8b3a2
/////////////////////////////////////////////////////////////////////////
0:                     ((StatementPermission) iter.next()).check( lcc, authorizationId, false);
commit:5ec8510
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
0:             List requiredPermissionsList = activation.getPreparedStatement().getRequiredPermissionsList();
0:             DataDictionary dd = lcc.getDataDictionary();
1: 
0:             // DBA can access any object. Ignore requiredPermissionsList for DBA
0:             if( requiredPermissionsList != null && ! requiredPermissionsList.isEmpty() && 
0: 				!authorizationId.equals(dd.getAuthorizationDBA()))
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: 			List requiredPermissionsList = activation.getPreparedStatement().getRequiredPermissionsList();
commit:2c6ca76
/////////////////////////////////////////////////////////////////////////
commit:4f4ddf4
/////////////////////////////////////////////////////////////////////////
0: 		// GrantRevoke TODO: Disabling this mode because of two failing tests.
0: 		if (true)
0: 		return false;
0: 
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.Activation;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.StatementPermission;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import java.util.List;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: 	private static final int SQL_STANDARD_ACCESS = 3;
/////////////////////////////////////////////////////////////////////////
1: 	  Used for operations that do not involve tables or routines.
0:      
1: 	  @see Authorizer#authorize
1: 	  @exception StandardException Thrown if the operation is not allowed
0: 	*/
1: 	public void authorize( int operation) throws StandardException
0: 	{
1: 		authorize( (Activation) null, operation);
0: 	}
0: 
0: 	/**
1: 	public void authorize( Activation activation, int operation) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 
1:         if( activation != null)
0:         {
0:             List requiredPermissionsList = null;
0: 			// GrantRevoke TODO: Need this logic for enforcing permissions later.
0: 			// List requiredPermissionsList = activation.getPreparedStatement().getRequiredPermissionsList();
0:             if( requiredPermissionsList != null && ! requiredPermissionsList.isEmpty())
0:             {
0:                 DataDictionary dd = lcc.getDataDictionary();
0:                 TransactionController tc = activation.getTransactionController();
0:                 for( Iterator iter = requiredPermissionsList.iterator();
0:                      iter.hasNext();)
0:                 {
0:                     ((StatementPermission) iter.next()).check( tc, dd, authorizationId, false);
0:                 }                    
0:             }
0: 		}
/////////////////////////////////////////////////////////////////////////
0: 
/////////////////////////////////////////////////////////////////////////
0: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.SQL_STANDARD_ACCESS))
0:             return FULL_ACCESS; 
/////////////////////////////////////////////////////////////////////////
0: 
0:     public boolean usesSqlStandardPermissions() throws StandardException
0:     {
0: 		// RESOLVE use getDefaultAccessLevel() when SQL standard permissions are fully implemented
0: 		// GrantRevoke TODO: May need to make database property value override system value
0: 		PersistentSet tc = lcc.getTransactionExecute();
0: 		String modeS = (String)
0: 		PropertyUtil.getServiceProperty(tc,
0: 									Property.DEFAULT_CONNECTION_MODE_PROPERTY);
0: 		if( modeS == null)
0:             return false;
0: 		return StringUtil.SQLEqualsIgnoreCase(modeS, Property.SQL_STANDARD_ACCESS);
0:     } // end of usesSqlStandardPermissions
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.conn
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.conn;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.iapi.util.StringUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.property.PersistentSet;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: import java.util.Properties;
0: 
0: class GenericAuthorizer
0: implements Authorizer
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	//
0: 	//Enumerations for user access levels.
0: 	private static final int NO_ACCESS = 0;
0: 	private static final int READ_ACCESS = 1;
0: 	private static final int FULL_ACCESS = 2;
0: 	
0: 	//
0: 	//Configurable userAccessLevel - derived from Database level
0: 	//access control lists + database boot time controls.
0: 	private int userAccessLevel;
0: 
0: 	//
0: 	//Connection's readOnly status
0:     boolean readOnlyConnection;
0: 
0: 	private final LanguageConnectionContext lcc;
0: 	
0: 	private final String authorizationId; //the userName after parsing by IdUtil 
0: 	
0: 	GenericAuthorizer(String authorizationId, 
0: 						     LanguageConnectionContext lcc,
0: 					         boolean sqlConnection)
0: 		 throws StandardException
0: 	{
0: 		this.lcc = lcc;
0: 		this.authorizationId = authorizationId;
0: 
0: 		//we check the access level only if this is coming from a sql
0: 		//connection, not internal logSniffer or StageTrunc db connection
0: 		if(sqlConnection)
0: 			refresh();
0: 	}
0: 
0: 	/*
0: 	  Return true if the connection must remain readOnly
0: 	  */
0: 	private boolean connectionMustRemainReadOnly()
0: 	{
0: 		if (lcc.getDatabase().isReadOnly() ||
0: 			(userAccessLevel==READ_ACCESS))
0: 			return true;
0: 		else
0: 			return false;
0: 	}
0: 
0: 	/**
0: 	  @see Authorizer#authorize
0: 	  @exception StandardException Thrown if the operation is not allowed
0: 	 */
0: 	public void authorize(int operation) throws StandardException
0: 	{
0: 		int sqlAllowed = lcc.getStatementContext().getSQLAllowed();
0: 
0: 		switch (operation)
0: 		{
0: 		case Authorizer.SQL_ARBITARY_OP:
0: 		case Authorizer.SQL_CALL_OP:
0: 			if (sqlAllowed == RoutineAliasInfo.NO_SQL)
0: 				throw externalRoutineException(operation, sqlAllowed);
0: 			break;
0: 		case Authorizer.SQL_SELECT_OP:
0: 			if (sqlAllowed > RoutineAliasInfo.READS_SQL_DATA)
0: 				throw externalRoutineException(operation, sqlAllowed);
0: 			break;
0: 
0: 		// SQL write operations
0: 		case Authorizer.SQL_WRITE_OP:
0: 		case Authorizer.PROPERTY_WRITE_OP:
0: 			if (isReadOnlyConnection())
0: 				throw StandardException.newException(SQLState.AUTH_WRITE_WITH_READ_ONLY_CONNECTION);
0: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
0: 				throw externalRoutineException(operation, sqlAllowed);
0: 			break;
0: 
0: 		// SQL DDL operations
0: 		case Authorizer.JAR_WRITE_OP:
0: 		case Authorizer.SQL_DDL_OP:
0:  			if (isReadOnlyConnection())
0: 				throw StandardException.newException(SQLState.AUTH_DDL_WITH_READ_ONLY_CONNECTION);
0: 
0: 			if (sqlAllowed > RoutineAliasInfo.MODIFIES_SQL_DATA)
0: 				throw externalRoutineException(operation, sqlAllowed);
0: 			break;
0: 
0: 		default:
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Bad operation code "+operation);
0: 		}
0: 	}
0: 
0: 	private static StandardException externalRoutineException(int operation, int sqlAllowed) {
0: 
0: 		String sqlState;
0: 		if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)
0: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
0: 		else if (sqlAllowed == RoutineAliasInfo.CONTAINS_SQL)
0: 		{
0: 			switch (operation)
0: 			{
0: 			case Authorizer.SQL_WRITE_OP:
0: 			case Authorizer.PROPERTY_WRITE_OP:
0: 			case Authorizer.JAR_WRITE_OP:
0: 			case Authorizer.SQL_DDL_OP:
0: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_MODIFIES_SQL;
0: 				break;
0: 			default:
0: 				sqlState = SQLState.EXTERNAL_ROUTINE_NO_READS_SQL;
0: 				break;
0: 			}
0: 		}
0: 		else
0: 			sqlState = SQLState.EXTERNAL_ROUTINE_NO_SQL;
0: 
0: 		return StandardException.newException(sqlState);
0: 	}
0: 	
0: 
0: 	/**
0: 	  @see Authorizer#getAuthorizationId
0: 	  */
0: 	public String getAuthorizationId()
0: 	{
0: 		return authorizationId;
0: 	}
0: 
0: 	private void getUserAccessLevel() throws StandardException
0: 	{
0: 		userAccessLevel = NO_ACCESS;
0: 		if (userOnAccessList(Property.FULL_ACCESS_USERS_PROPERTY))
0: 			userAccessLevel = FULL_ACCESS;
0: 
0: 		if (userAccessLevel == NO_ACCESS &&
0: 			userOnAccessList(Property.READ_ONLY_ACCESS_USERS_PROPERTY))
0: 			userAccessLevel = READ_ACCESS;
0: 
0: 		if (userAccessLevel == NO_ACCESS)
0: 			userAccessLevel = getDefaultAccessLevel();
0: 	}
0: 
0: 	private int getDefaultAccessLevel() throws StandardException
0: 	{
0: 		PersistentSet tc = lcc.getTransactionExecute();
0: 		String modeS = (String)
0: 			PropertyUtil.getServiceProperty(
0: 									tc,
0: 									Property.DEFAULT_CONNECTION_MODE_PROPERTY);
0: 		if (modeS == null)
0: 			return FULL_ACCESS;
0: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.NO_ACCESS))
0: 			return NO_ACCESS;
0: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.READ_ONLY_ACCESS))
0: 			return READ_ACCESS;
0: 		else if(StringUtil.SQLEqualsIgnoreCase(modeS, Property.FULL_ACCESS))
0: 			return FULL_ACCESS;
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.THROWASSERT("Invalid value for property "+
0: 										  Property.DEFAULT_CONNECTION_MODE_PROPERTY+
0: 										  " "+
0: 										  modeS);
0:  			return FULL_ACCESS;
0: 		}
0: 	}
0: 
0: 	private boolean userOnAccessList(String listName) throws StandardException
0: 	{
0: 		PersistentSet tc = lcc.getTransactionExecute();
0: 		String listS = (String)
0: 			PropertyUtil.getServiceProperty(tc, listName);
0: 		return IdUtil.idOnList(authorizationId,listS);
0: 	}
0: 
0: 	/**
0: 	  @see Authorizer#isReadOnlyConnection
0: 	 */
0: 	public boolean isReadOnlyConnection()
0: 	{
0: 		return readOnlyConnection;
0: 	}
0: 
0: 	/**
0: 	  @see Authorizer#isReadOnlyConnection
0: 	  @exception StandardException Thrown if the operation is not allowed
0: 	 */
0: 	public void setReadOnlyConnection(boolean on, boolean authorize)
0: 		 throws StandardException
0: 	{
0: 		if (authorize && !on) {
0: 			if (connectionMustRemainReadOnly())
0: 				throw StandardException.newException(SQLState.AUTH_CANNOT_SET_READ_WRITE);
0: 		}
0: 		readOnlyConnection = on;
0: 	}
0: 
0: 	/**
0: 	  @see Authorizer#refresh
0: 	  @exception StandardException Thrown if the operation is not allowed
0: 	  */
0: 	public void refresh() throws StandardException
0: 	{
0: 		getUserAccessLevel();
0: 		if (!readOnlyConnection)
0: 			readOnlyConnection = connectionMustRemainReadOnly();
0: 
0: 		// Is a connection allowed.
0: 		if (userAccessLevel == NO_ACCESS)
0: 			throw StandardException.newException(SQLState.AUTH_DATABASE_CONNECTION_REFUSED);
0: 	}
0: }
============================================================================