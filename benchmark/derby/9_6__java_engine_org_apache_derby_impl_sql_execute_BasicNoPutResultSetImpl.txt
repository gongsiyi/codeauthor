2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
23:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:bbb545e: import java.lang.reflect.Array;
1:b197ffa: import java.lang.reflect.Field;
1:a56ecfa: import java.security.AccessController;
1:a56ecfa: import java.security.PrivilegedAction;
1:7008b63: import java.sql.SQLWarning;
1:7008b63: import java.sql.Timestamp;
1:b197ffa: import java.util.Arrays;
1:b197ffa: import java.util.ArrayList;
1:b197ffa: import java.util.Comparator;
1:b197ffa: import org.w3c.dom.Element;
1:7008b63: 
1:7008b63: import org.apache.derby.iapi.error.StandardException;
1:7008b63: import org.apache.derby.iapi.reference.SQLState;
1:7008b63: import org.apache.derby.iapi.services.i18n.MessageService;
1:7008b63: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:c69c8b0: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.sql.ResultSet;
1:eac0369: import org.apache.derby.iapi.sql.Row;
1:7008b63: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:7008b63: import org.apache.derby.iapi.sql.conn.StatementContext;
1:7008b63: import org.apache.derby.iapi.sql.execute.ExecRow;
1:7008b63: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:7008b63: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:7008b63: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:6211712: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
4:eac0369: /**
1:eac0369:  * Abstract ResultSet for for operations that return rows but
1:eac0369:  * do not allow the caller to put data on output pipes. This
1:eac0369:  * basic implementation does not include support for an Activiation.
1:eac0369:  * See NoPutResultSetImpl.java for an implementaion with support for
1:eac0369:  * an activiation.
1:eac0369:  * <p>
1:eac0369:  * This abstract class does not define the entire ResultSet
1:eac0369:  * interface, but leaves the 'get' half of the interface
1:eac0369:  * for subtypes to implement. It is package-visible only,
1:eac0369:  * with its methods being public for exposure by its subtypes.
1:eac0369:  * <p>
1:eac0369:  */
1:eac0369: abstract class BasicNoPutResultSetImpl
1:eac0369: implements NoPutResultSet
8:eac0369: {
1:eac0369: 	/* Modified during the life of this object */
1:eac0369:     protected boolean isOpen;
1:eac0369:     protected boolean finished;
1:eac0369: 	protected ExecRow	  currentRow;
1:eac0369: 	protected boolean isTopResultSet;
1:eac0369: 	private SQLWarning	warnings;
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public int numOpens;
1:eac0369: 	public int rowsSeen;
1:eac0369: 	public int rowsFiltered;
1:eac0369: 	protected long startExecutionTime;
1:eac0369: 	protected long endExecutionTime;
1:eac0369: 	public long beginTime;
1:eac0369: 	public long constructorTime;
1:eac0369: 	public long openTime;
1:eac0369: 	public long nextTime;
1:eac0369: 	public long closeTime;
1:eac0369: 
1:eac0369: 	public double optimizerEstimatedRowCount;
1:eac0369: 	public double optimizerEstimatedCost;
1:eac0369: 
1:eac0369: 	// set on demand during execution
1:eac0369: 	private StatementContext			statementContext;
1:eac0369: 	public NoPutResultSet[]			subqueryTrackingArray;
1:eac0369: 	ExecRow compactRow;
1:eac0369: 
1:eac0369: 	// Set in the constructor and not modified
1:3237ef5: 	protected final Activation	    activation;
1:7008b63: 	private final boolean				statisticsTimingOn;
1:eac0369: 
1:c69c8b0: 	ResultDescription resultDescription;
1:c69c8b0: 
1:eac0369: 	private transient TransactionController	tc;
1:eac0369: 
1:eac0369: 	private int[] baseColumnMap;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Constructor.
1:eac0369: 	    <BR>
1:eac0369: 		Sets beginTime for all children to use to measue constructor time.
2:eac0369: 	 *
1:c69c8b0: 	 *  @param  resultDescription the result description. May be null.
1:eac0369: 	 *	@param	activation			The activation
1:eac0369: 	 *	@param	optimizerEstimatedRowCount	The optimizer's estimate of the
1:eac0369: 	 *										total number of rows for this
1:eac0369: 	 *										result set
1:eac0369: 	 *	@param	optimizerEstimatedCost		The optimizer's estimated cost for
1:eac0369: 	 *										this result set
1:eac0369: 	 */
1:c69c8b0: 	BasicNoPutResultSetImpl(ResultDescription resultDescription,
1:c69c8b0: 							Activation activation,
1:eac0369: 							double optimizerEstimatedRowCount,
1:eac0369: 							double optimizerEstimatedCost)
1:eac0369: 	{
1:eac0369: 		this.activation = activation;
1:7008b63: 		if (statisticsTimingOn = getLanguageConnectionContext().getStatisticsTiming())
1:7008b63: 		    beginTime = startExecutionTime = getCurrentTimeMillis();
1:c69c8b0: 		this.resultDescription = resultDescription;
1:eac0369: 		this.optimizerEstimatedRowCount = optimizerEstimatedRowCount;
1:eac0369: 		this.optimizerEstimatedCost = optimizerEstimatedCost;
14:eac0369: 	}
1:6b26ee1: 	
1:7008b63: 	/**
1:7008b63: 	 * Allow sub-classes to record the total
1:7008b63: 	 * time spent in their constructor time.
1:7008b63: 	 *
1:7008b63: 	 */
1:7008b63: 	protected final void recordConstructorTime()
1:7008b63: 	{
1:7008b63: 		if (statisticsTimingOn)
1:7008b63: 		    constructorTime = getElapsedMillis(beginTime);
1:7008b63: 	}
1:7008b63: 	
1:6b26ee1: 	public final Activation getActivation()
1:6b26ee1: 	{
1:6b26ee1: 		return activation;
1:6b26ee1: 	}
1:eac0369: 
1:2a4654b: 	protected final boolean isXplainOnlyMode()
1:2a4654b: 	{
1:2a4654b: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1:2a4654b: 		return
1:2a4654b: 		  (lcc.getRunTimeStatisticsMode() && lcc.getXplainOnlyMode());
1:2a4654b: 	}
1:2a4654b: 
1:eac0369: 	// NoPutResultSet interface
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This is the default implementation of reopenCore().
1:eac0369: 	 * It simply does a close() followed by an open().  If
1:eac0369: 	 * there are optimizations to be made (caching, etc), this
1:eac0369: 	 * is a good place to do it -- this will be overridden
1:eac0369: 	 * by a number of resultSet imlementations.  and SHOULD
1:eac0369: 	 * be overridden by any node that can get between a base
1:eac0369: 	 * table and a join.
1:eac0369: 	 *
2:eac0369: 	 * @see NoPutResultSet#openCore
2:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public void reopenCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		close();
1:48a9884: 		openCore();	
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#getNextRowCore
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369: 	 */
1:eac0369: 	public abstract ExecRow	getNextRowCore() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#getPointOfAttachment
1:eac0369: 	 */
1:eac0369: 	public int getPointOfAttachment()
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getPointOfAttachment() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 		return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
1:eac0369: 	 * Useful for closing down the ResultSet on an error.
1:eac0369: 	 */
1:eac0369: 	public void markAsTopResultSet()
1:eac0369: 	{
1:eac0369: 		isTopResultSet = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#getScanIsolationLevel
1:eac0369: 	 */
1:eac0369: 	public int getScanIsolationLevel()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getScanIsolationLevel() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see NoPutResultSet#getEstimatedRowCount */
1:eac0369: 	public double getEstimatedRowCount()
1:eac0369: 	{
1:eac0369: 		return optimizerEstimatedRowCount;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NoPutResultSet#requiresRelocking
1:eac0369: 	 */
1:eac0369: 	public boolean requiresRelocking()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"requiresRelocking() not expected to be called for " +
1:eac0369: 				getClass().getName());
1:eac0369: 		}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// ResultSet interface
1:eac0369: 
1:3fcea8a: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * NOTE: This method should only be called on the top ResultSet
1:eac0369: 	 * of a ResultSet tree to ensure that the entire ResultSet
1:eac0369: 	 * tree gets closed down on an error.  the openCore() method
1:eac0369: 	 * will be called for all other ResultSets in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public final void	open() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 				this + "expected to be the top ResultSet");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		finished = false;
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		try {
1:2a4654b: 			openCore();
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 			activation.checkStatementValidity();
1:eac0369: 			throw se;
1:48a9884: 		}
1:eac0369: 
1:eac0369: 		activation.checkStatementValidity();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the absolute position from the query, 
1:eac0369: 	 * and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means from the end of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: An exception will be thrown on 0.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the absolute position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, ABSOLUTE);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getAbsoluteRow() not expected to be called for " + getClass().getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the relative position from the current
1:eac0369: 	 * cursor position, and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means toward the beginning of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: 0 is valid.
1:eac0369: 	 * NOTE: An exception is thrown if the cursor is not currently
1:eac0369: 	 * positioned on a row.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the relative position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getRelativeRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, RELATIVE);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getRelativeRow() not expected to be called for " + getClass().getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to before the first row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setBeforeFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"setBeforeFirstRow() not expected to be called for " + getClass().getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine if the cursor is before the first row in the result 
1:eac0369:      * set.   
1:eac0369:      *
1:eac0369:      * @return true if before the first row, false otherwise. Returns
1:eac0369:      * false when the result set contains no rows.
1:eac0369:      */
1:eac0369:     public boolean checkRowPosition(int isType) throws StandardException
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row number of the current row.  Row
1:eac0369: 	 * numbers start from 1 and go to 'n'.  Corresponds
1:eac0369: 	 * to row numbering used to position current row
1:eac0369: 	 * in the result set (as per JDBC).
1:eac0369: 	 *
1:eac0369: 	 * @return	the row number, or 0 if not on a row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public int getRowNumber()
1:eac0369: 	{
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the first row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The first row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getFirstRow() not expected to be called for " + getClass().getName());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Return the requested values computed
1:eac0369:      * from the next row (if any) for which
1:eac0369:      * the restriction evaluates to true.
1:eac0369:      * <p>
1:eac0369:      * restriction and projection parameters
1:eac0369:      * are evaluated for each row.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: This method should only be called on the top ResultSet
1:eac0369: 	 * of a ResultSet tree to ensure that the entire ResultSet
1:eac0369: 	 * tree gets closed down on an error.  the getNextRowCore() method
1:eac0369: 	 * will be called for all other ResultSets in the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public final ExecRow	getNextRow() throws StandardException 
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 		{
1:48a9884: 			// return null to indicate no results available and 
1:48a9884: 			// to bypass the execution
1:48a9884: 			return null;
1:48a9884: 		}
1:48a9884: 		
1:48a9884: 		if ( ! isOpen ) {
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, NEXT);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 				this + "expected to be the top ResultSet");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		return getNextRowCore();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the previous row from the query, and returns NULL when there
1:eac0369: 	 * are no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The previous row, or NULL if no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getPreviousRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, PREVIOUS);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getPreviousRow() not expected to be called.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the last row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The last row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getLastRow()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		attachStatementContext();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"getLastRow() not expected to be called.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to after the last row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:eac0369: 	public ExecRow	setAfterLastRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 	    if ( ! isOpen ) 
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (!isTopResultSet)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					this + "expected to be the top ResultSet");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"setAfterLastRow() not expected to be called.");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Returns true.
1:eac0369: 	 */
1:eac0369: 	 public boolean	returnsRows() { return true; }
1:eac0369: 
1:7fb9956: 	public final long	modifiedRowCount() { return 0; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Clean up on error
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void	cleanUp() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isOpen) {
1:eac0369: 			close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Report if closed.
1:eac0369: 	 */
1:eac0369: 	public boolean	isClosed() {
1:eac0369: 	    return ( ! isOpen );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */	
1:eac0369: 	protected final void finishAndRTS() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if (!finished) {
1:eac0369: 			if (!isClosed())
1:eac0369: 				close();
1:eac0369: 
1:eac0369: 			finished = true;
1:eac0369: 
1:eac0369: 			if (isTopResultSet && activation.isSingleExecution())
1:eac0369: 				activation.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* The following methods are common to almost all sub-classes.
1:eac0369: 	 * They are overriden in selected cases.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:c69c8b0:      * Returns the description of the table's rows
1:c69c8b0: 	 */
1:c69c8b0: 	public ResultDescription getResultDescription() {
1:c69c8b0: 	    return resultDescription;
1:c69c8b0: 	}
1:c69c8b0: 
1:c69c8b0: 	/**
1:eac0369: 	 * Get the execution time in milliseconds.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The execution time in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getExecuteTime()
1:eac0369: 	{
1:eac0369: 		return getTimeSpent(ResultSet.ENTIRE_RESULTSET_TREE);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the beginning of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getBeginExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		if (startExecutionTime == 0)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return new Timestamp(startExecutionTime);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the end of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the end of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getEndExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		if (endExecutionTime == 0)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return new Timestamp(endExecutionTime);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#getSubqueryTrackingArray
1:eac0369: 	 */
1:eac0369: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1:eac0369: 	{
1:eac0369: 		if (subqueryTrackingArray == null)
1:eac0369: 		{
1:eac0369: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return subqueryTrackingArray;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
1:eac0369: 	 * on, else return 0.  (Only pay price of system call if need to.)
1:eac0369: 	 *
1:eac0369: 	 * @return long		Current time in milliseconds.
1:eac0369: 	 */
1:eac0369: 	protected final long getCurrentTimeMillis()
1:eac0369: 	{
1:eac0369: 		if (statisticsTimingOn)
1:eac0369: 		{
1:eac0369: 			return System.currentTimeMillis();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1:eac0369: 	 */
1:eac0369: 	public ResultSet getAutoGeneratedKeysResultset()
1:eac0369: 	{
1:eac0369: 		//A non-null resultset would be returned only for an insert statement 
1:eac0369: 		return (ResultSet)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the elapsed time in milliseconds, between now and the beginTime, if
1:eac0369: 	 * DEBUG and RunTimeStats is on, else return 0.  
1:eac0369: 	 * (Only pay price of system call if need to.)
1:eac0369: 	 *
1:eac0369: 	 * @return long		Elapsed time in milliseconds.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	protected final long getElapsedMillis(long beginTime)
1:eac0369: 	{
1:eac0369: 		if (statisticsTimingOn)
1:eac0369: 		{
1:eac0369: 			return (System.currentTimeMillis() - beginTime);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Dump out the time information for run time stats.
1:eac0369: 	 *
2:eac0369: 	 * @return Nothing.
1:eac0369: 	 */
1:eac0369: 	protected final String dumpTimeStats(String indent, String subIndent)
1:eac0369: 	{
1:eac0369: 		return 
1:eac0369: 			indent +
1:eac0369: 			  MessageService.getTextMessage(SQLState.LANG_TIME_SPENT_THIS) +
1:eac0369: 			  " " + getTimeSpent(ResultSet.CURRENT_RESULTSET_ONLY) + "\n" +
1:eac0369: 			indent +
1:eac0369: 			  MessageService.getTextMessage(
1:eac0369: 				SQLState.LANG_TIME_SPENT_THIS_AND_BELOW) +
1:eac0369: 			  " " + getTimeSpent(NoPutResultSet.ENTIRE_RESULTSET_TREE) + "\n" +
1:eac0369: 			indent +
1:eac0369: 			  MessageService.getTextMessage(
1:eac0369: 				SQLState.LANG_TOTAL_TIME_BREAKDOWN) + "\n" +
1:eac0369: 			subIndent +
1:eac0369: 			  MessageService.getTextMessage(SQLState.LANG_CONSTRUCTOR_TIME) +
1:eac0369: 			  " " + constructorTime + "\n" +
1:eac0369: 			subIndent +
1:eac0369: 			  MessageService.getTextMessage(SQLState.LANG_OPEN_TIME) +
1:eac0369: 			  " " + openTime + "\n" +
1:eac0369: 			subIndent +
1:eac0369: 			  MessageService.getTextMessage(SQLState.LANG_NEXT_TIME) +
1:eac0369: 			  " " + nextTime + "\n" +
1:eac0369: 			subIndent +
1:eac0369: 			  MessageService.getTextMessage(SQLState.LANG_CLOSE_TIME) +
1:eac0369: 			  " " + closeTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Attach this result set to the top statement context on the stack.
1:eac0369: 	  *	Result sets can be directly read from the JDBC layer. The JDBC layer
1:eac0369: 	  * will push and pop a statement context around each ResultSet.getNext().
1:eac0369: 	  * There's no guarantee that the statement context used for the last
1:eac0369: 	  * getNext() will be the context used for the current getNext(). The
1:eac0369: 	  * last statement context may have been popped off the stack and so
1:eac0369: 	  *	will not be available for cleanup if an error occurs. To make sure
1:eac0369: 	  *	that we will be cleaned up, we always attach ourselves to the top	
1:eac0369: 	  *	context.
1:eac0369: 	  *
1:eac0369: 	  *	The fun and games occur in nested contexts: using JDBC result sets inside
1:eac0369: 	  * user code that is itself invoked from queries or CALL statements.
1:eac0369: 	  *
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException thrown if cursor finished.
1:eac0369: 	  */
1:eac0369: 	protected	void	attachStatementContext() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isTopResultSet)
1:eac0369: 		{
1:eac0369: 			if (statementContext == null || !statementContext.onStack() )
1:eac0369: 			{
1:eac0369: 				statementContext = getLanguageConnectionContext().getStatementContext();
1:eac0369: 			}
1:eac0369: 			statementContext.setTopResultSet(this, subqueryTrackingArray);
1:eac0369: 			// Pick up any materialized subqueries
1:eac0369: 			if (subqueryTrackingArray == null)
1:eac0369: 			{
1:eac0369: 				subqueryTrackingArray = statementContext.getSubqueryTrackingArray();
1:eac0369: 			}
1:6950a39:             statementContext.setActivation(activation);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Cache the language connection context. Return it.
1:eac0369: 	  *
1:eac0369: 	  *	@return	the language connection context
1:eac0369: 	  */
1:eac0369: 	protected	final LanguageConnectionContext	getLanguageConnectionContext()
1:eac0369: 	{
1:3237ef5:         return getActivation().getLanguageConnectionContext();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see NoPutResultSet#resultSetNumber() */
1:eac0369: 	public int resultSetNumber() {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.THROWASSERT(
1:eac0369: 				"resultSetNumber() should not be called on a " +
1:eac0369: 				this.getClass().getName()
1:eac0369: 				);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// UTILS	
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a execution factory
1:eac0369: 	 *
1:eac0369: 	 * @return the execution factory
1:eac0369: 	 */
1:eac0369: 	final ExecutionFactory getExecutionFactory() 
1:eac0369: 	{
1:3237ef5: 		return activation.getExecutionFactory();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current transaction controller.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369:   	final TransactionController getTransactionController()
1:eac0369:  	{
1:eac0369:   		if (tc == null)
1:eac0369:   		{
1:eac0369: 			tc = getLanguageConnectionContext().getTransactionExecute();
1:eac0369:   		}
1:eac0369:   		return tc;
1:eac0369:   	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a compacted version of the candidate row according to the
1:eac0369: 	 * columns specified in the bit map. Share the holders between rows.
1:eac0369: 	 * If there is no bit map, use the candidate row as the compact row.
1:eac0369: 	 *
1:eac0369: 	 * Also, create an array of ints mapping base column positions to
1:eac0369: 	 * compact column positions, to make it cheaper to copy columns to
1:eac0369: 	 * the compact row, if we ever have to do it again.
1:eac0369: 	 *
1:eac0369: 	 * @param candidate		The row to get the columns from
1:eac0369: 	 * @param accessedCols	A bit map of the columns that are accessed in
1:eac0369: 	 *						the candidate row
1:eac0369: 	 * @param isKeyed		Tells whether to return a ValueRow or an IndexRow
1:eac0369: 	 *
1:eac0369: 	 * @return		A compact row.
1:eac0369: 	 */
1:eac0369: 	protected ExecRow getCompactRow(ExecRow candidate,
1:eac0369: 									FormatableBitSet accessedCols,
1:eac0369: 									boolean isKeyed)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		int		numCandidateCols = candidate.nColumns();
1:eac0369: 
1:eac0369: 		if (accessedCols == null)
1:eac0369: 		{
1:eac0369: 			compactRow =  candidate;
1:eac0369: 			baseColumnMap = new int[numCandidateCols];
1:eac0369: 			for (int i = 0; i < baseColumnMap.length; i++)
1:eac0369: 				baseColumnMap[i] = i;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:49f3f24: 			int numCols = accessedCols.getNumBitsSet();
1:eac0369: 			baseColumnMap = new int[numCols];
1:eac0369: 
1:eac0369: 			if (compactRow == null)
1:eac0369: 			{
1:3237ef5: 				ExecutionFactory ex = getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory();
1:eac0369: 
1:eac0369: 				if (isKeyed)
1:eac0369: 				{
1:eac0369: 					compactRow = ex.getIndexableRow(numCols);
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					compactRow = ex.getValueRow(numCols);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			int position = 0;
1:49f3f24: 			for (int i = accessedCols.anySetBit();
1:eac0369: 					i != -1;
1:49f3f24: 					i = accessedCols.anySetBit(i))
1:eac0369: 			{
1:eac0369: 				// Stop looking if there are columns beyond the columns
1:eac0369: 				// in the candidate row. This can happen due to the
1:eac0369: 				// otherCols bit map.
1:eac0369: 				if (i >= numCandidateCols)
1:eac0369: 					break;
1:eac0369: 
1:eac0369: 				DataValueDescriptor sc = candidate.getColumn(i+1);
1:eac0369: 				if (sc != null)
1:eac0369: 				{
1:eac0369: 					compactRow.setColumn(
1:eac0369: 									position + 1,
1:eac0369: 									sc
1:eac0369: 									);
1:eac0369: 				}
1:eac0369: 				baseColumnMap[position] = i;
1:eac0369: 				position++;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return compactRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Copy columns from the candidate row from the store to the given
1:eac0369: 	 * compact row. If there is no column map, just use the candidate row.
1:eac0369: 	 *
1:eac0369: 	 * This method assumes the above method (getCompactRow()) was called
1:eac0369: 	 * first. getCompactRow() sets up the baseColumnMap.
1:eac0369: 	 *
1:eac0369: 	 * @param candidateRow	The candidate row from the store
1:eac0369: 	 * @param compactRow	The compact row to fill in
1:eac0369: 	 *
1:eac0369: 	 * @return	The compact row to use
1:eac0369: 	 */
1:eac0369: 	protected ExecRow setCompactRow(ExecRow candidateRow, ExecRow compactRow)
1:eac0369: 	{
1:eac0369: 		ExecRow	retval;
1:eac0369: 
1:eac0369: 		//System.out.println("base col map " + baseColumnMap);
1:eac0369: 		if (baseColumnMap == null)
1:eac0369: 		{
1:eac0369: 			retval = candidateRow;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			retval = compactRow;
1:eac0369: 
1:eac0369: 			setCompatRow(compactRow, candidateRow.getRowArray());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:49f3f24: 	protected final void setCompatRow(ExecRow compactRow, DataValueDescriptor[] sourceRow) {
1:eac0369: 
1:49f3f24: 		DataValueDescriptor[] destRow = compactRow.getRowArray();
1:eac0369: 		int[] lbcm = baseColumnMap;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < lbcm.length; i++)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			destRow[i] = sourceRow[lbcm[i]];
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * This method will be overriden in the inherited Classes
1:eac0369: 	 * if it is true
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:3fcea8a:      * Checks whether the currently executing statement has been cancelled.
1:3fcea8a:      * This is done by checking the statement's allocated StatementContext
1:3fcea8a:      * object.
1:3fcea8a:      *
1:3fcea8a:      * @see StatementContext
1:3fcea8a:      */
1:3fcea8a: 	public void checkCancellationFlag()
1:3fcea8a:         throws
1:3fcea8a:             StandardException
1:3fcea8a: 	{
1:48a9884:         LanguageConnectionContext lcc = getLanguageConnectionContext();
1:8fe03ce:         StatementContext localStatementContext = lcc.getStatementContext();
1:3fcea8a:         if (localStatementContext == null) {
1:3fcea8a:             return;
1:3fcea8a:         }
1:3fcea8a: 
1:6211712: 		InterruptStatus.throwIf(lcc);
1:6211712: 
1:3fcea8a:         if (localStatementContext.isCancelled()) {
1:3fcea8a:             throw StandardException.newException(SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT);
1:3fcea8a:         }
1:3fcea8a:     }
1:3fcea8a: 
1:75ec275: 	public final void addWarning(SQLWarning w) {
1:eac0369: 
2:eac0369: 		if (isTopResultSet) {
1:eac0369: 			if (warnings == null)
1:eac0369: 				warnings = w;
1:eac0369: 			else 
1:eac0369: 				warnings.setNextWarning(w);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (activation != null) {
1:eac0369: 
1:eac0369: 			ResultSet rs = activation.getResultSet();
1:eac0369: 
1:75ec275:             if (rs != null) {
1:75ec275:                 rs.addWarning(w);
1:75ec275:             }
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final SQLWarning getWarnings() {
1:eac0369: 		SQLWarning w = warnings;
1:eac0369: 		warnings = null;
1:eac0369: 		return w;
1:eac0369: 	}
1:b197ffa: 
1:b197ffa:     public Element toXML( Element parentNode, String tag ) throws Exception
1:b197ffa:     {
1:b197ffa:         return childrenToXML( toXML( parentNode, tag, this ), this );
1:b197ffa:     }
1:b197ffa: 
1:b197ffa:     /**
1:b197ffa:      * <p>
1:b197ffa:      * Pretty-print a ResultSet as an xml child of a parent node.
1:b197ffa:      * Return the node representing the ResultSet child.
1:b197ffa:      * </p>
1:b197ffa:      */
1:b197ffa:     public  static  Element    toXML( Element parentNode, String childTag, ResultSet rs ) throws Exception
1:b197ffa:     {
1:b197ffa:         Element result = parentNode.getOwnerDocument().createElement( childTag );
1:bbb545e:         result.setAttribute( "type", stripPackage( rs.getClass().getName() ) );
1:b197ffa: 
1:b197ffa:         parentNode.appendChild( result );
1:b197ffa:         return result;
1:b197ffa:     }
1:b197ffa: 
1:bbb545e:     /** Strip the package location from a class name */
1:bbb545e:     private static  String  stripPackage( String className )
1:bbb545e:     {
1:bbb545e:         return className.substring( className.lastIndexOf( "." ) + 1 );
1:bbb545e:     }
1:bbb545e: 
1:b197ffa:     /**
1:b197ffa:      * <p>
1:b197ffa:      * Pretty-print the inner ResultSet fields inside an outer ResultSet.
1:b197ffa:      * Returns the outerNode.
1:b197ffa:      * </p>
1:b197ffa:      */
1:b197ffa:     public  static  Element    childrenToXML
1:b197ffa:         ( Element outerNode, ResultSet outerRS ) throws Exception
1:b197ffa:     {
1:b197ffa:         ArrayList<Field>    fieldList = new ArrayList<Field>();
1:b197ffa:         findResultSetFields( fieldList, outerRS.getClass() );
1:b197ffa: 
1:b197ffa:         //
1:b197ffa:         // Get a array of all the ResultSet fields inside the outerRS,
1:b197ffa:         // ordered by field name.
1:b197ffa:         //
1:b197ffa:         Field[] fields = new Field[ fieldList.size() ];
1:b197ffa:         fieldList.toArray( fields );
1:b197ffa:         Arrays.sort( fields, new FieldComparator() );
1:b197ffa: 
1:b197ffa:         // Add those fields as children of the outer element.
1:b197ffa:         for ( Field field : fields )
1:b197ffa:         {
1:bbb545e:             Object  fieldContents = field.get( outerRS );
1:b197ffa: 
1:bbb545e:             if ( fieldContents != null )
1:bbb545e:             {
1:bbb545e:                 if ( field.getType().isArray() )
1:bbb545e:                 {
1:bbb545e:                     Element arrayNode = outerNode.getOwnerDocument().createElement( "array" );
1:bbb545e:                     arrayNode.setAttribute( "arrayName", field.getName() );
1:bbb545e:                     String  typeName = stripPackage( field.getType().getComponentType().getName() ) + "[]";
1:bbb545e:                     arrayNode.setAttribute( "type", typeName );
1:bbb545e:                     outerNode.appendChild( arrayNode );
1:bbb545e: 
1:bbb545e:                     int arrayLength = Array.getLength( fieldContents );
1:bbb545e:                     for ( int i = 0; i < arrayLength; i++ )
1:bbb545e:                     {
1:bbb545e:                         ResultSet   cellRS = (ResultSet) Array.get( fieldContents, i );
1:bbb545e: 
1:bbb545e:                         if ( cellRS != null )
1:bbb545e:                         {
1:bbb545e:                             Element cellNode = cellRS.toXML( arrayNode, "cell" );
1:bbb545e:                             cellNode.setAttribute( "cellNumber", Integer.toString( i ) );
1:bbb545e:                         }
1:bbb545e:                     }
1:bbb545e:                 }
1:bbb545e:                 else
1:bbb545e:                 {
1:bbb545e:                     ResultSet   innerRS = (ResultSet) fieldContents;
1:bbb545e: 
1:bbb545e:                     innerRS.toXML( outerNode, field.getName() );
1:bbb545e:                 }
1:bbb545e:             }   // end if fieldContents is not null
1:bbb545e:         }   // end loop through fields
1:b197ffa: 
1:b197ffa:         return outerNode;
1:b197ffa:     }
1:b197ffa: 
1:b197ffa:     /**
1:b197ffa:      * <p>
1:b197ffa:      * Find all fields of type ResultSet.
1:b197ffa:      * </p>
1:b197ffa:      */
1:a56ecfa:     private static  void    findResultSetFields( ArrayList<Field> fieldList, final Class<?> klass )
1:b197ffa:         throws Exception
1:b197ffa:     {
1:b197ffa:         if ( klass == null ) { return; }
1:b197ffa:         
1:a56ecfa:         Field[] fields = AccessController.doPrivileged
1:a56ecfa:             (
1:a56ecfa:              new PrivilegedAction<Field[]>()
1:a56ecfa:              {
1:a56ecfa:                  public Field[] run()
1:a56ecfa:                  {
1:a56ecfa:                      return klass.getDeclaredFields();
1:a56ecfa:                  }
1:a56ecfa:              }
1:a56ecfa:              );
1:b197ffa: 
1:b197ffa:         for ( Field field : fields )
1:b197ffa:         {
1:b197ffa:             if ( ResultSet.class.isAssignableFrom( field.getType() ) ) { fieldList.add( field ); }
1:bbb545e:             else if ( field.getType().isArray() )
1:bbb545e:             {
1:bbb545e:                 if ( ResultSet.class.isAssignableFrom( field.getType().getComponentType() ) )
1:bbb545e:                 {
1:bbb545e:                     fieldList.add( field );
1:bbb545e:                 }
1:bbb545e:             }
1:b197ffa:         }
1:b197ffa: 
1:b197ffa:         findResultSetFields( fieldList, klass.getSuperclass() );
1:b197ffa:     }
1:b197ffa: 
1:b197ffa:     public  static  final   class   FieldComparator implements Comparator<Field>
1:b197ffa:     {
1:b197ffa:         public  int compare( Field left, Field right ) { return left.getName().compareTo( right.getName() ); }
1:b197ffa:     }
1:b197ffa: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 	protected final boolean isXplainOnlyMode()
1: 	{
1: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 		return
1: 		  (lcc.getRunTimeStatisticsMode() && lcc.getXplainOnlyMode());
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 			openCore();
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 		{
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 			if(lcc.getRunTimeStatisticsMode() && lcc.getXplainOnlyMode()) {
0: 				// do nothing
0: 			} else {
1: 				openCore();
1: 			}
/////////////////////////////////////////////////////////////////////////
0: 		LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 		if(lcc.getRunTimeStatisticsMode() && lcc.getXplainOnlyMode()){
1: 			// return null to indicate no results available and 
1: 			// to bypass the execution
1: 			return null;
1: 		}
1: 		
1: 		if ( ! isOpen ) {
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:bbb545e
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Array;
/////////////////////////////////////////////////////////////////////////
1:         result.setAttribute( "type", stripPackage( rs.getClass().getName() ) );
1:     /** Strip the package location from a class name */
1:     private static  String  stripPackage( String className )
1:     {
1:         return className.substring( className.lastIndexOf( "." ) + 1 );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             Object  fieldContents = field.get( outerRS );
1:             if ( fieldContents != null )
1:             {
1:                 if ( field.getType().isArray() )
1:                 {
1:                     Element arrayNode = outerNode.getOwnerDocument().createElement( "array" );
1:                     arrayNode.setAttribute( "arrayName", field.getName() );
1:                     String  typeName = stripPackage( field.getType().getComponentType().getName() ) + "[]";
1:                     arrayNode.setAttribute( "type", typeName );
1:                     outerNode.appendChild( arrayNode );
1: 
1:                     int arrayLength = Array.getLength( fieldContents );
1:                     for ( int i = 0; i < arrayLength; i++ )
1:                     {
1:                         ResultSet   cellRS = (ResultSet) Array.get( fieldContents, i );
1: 
1:                         if ( cellRS != null )
1:                         {
1:                             Element cellNode = cellRS.toXML( arrayNode, "cell" );
1:                             cellNode.setAttribute( "cellNumber", Integer.toString( i ) );
1:                         }
1:                     }
1:                 }
1:                 else
1:                 {
1:                     ResultSet   innerRS = (ResultSet) fieldContents;
1: 
1:                     innerRS.toXML( outerNode, field.getName() );
1:                 }
1:             }   // end if fieldContents is not null
1:         }   // end loop through fields
/////////////////////////////////////////////////////////////////////////
1:             else if ( field.getType().isArray() )
1:             {
1:                 if ( ResultSet.class.isAssignableFrom( field.getType().getComponentType() ) )
1:                 {
1:                     fieldList.add( field );
1:                 }
1:             }
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:     private static  void    findResultSetFields( ArrayList<Field> fieldList, final Class<?> klass )
1:         Field[] fields = AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Field[]>()
1:              {
1:                  public Field[] run()
1:                  {
1:                      return klass.getDeclaredFields();
1:                  }
1:              }
1:              );
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Field;
1: import java.util.Arrays;
1: import java.util.ArrayList;
1: import java.util.Comparator;
1: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public Element toXML( Element parentNode, String tag ) throws Exception
1:     {
1:         return childrenToXML( toXML( parentNode, tag, this ), this );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Pretty-print a ResultSet as an xml child of a parent node.
1:      * Return the node representing the ResultSet child.
1:      * </p>
1:      */
1:     public  static  Element    toXML( Element parentNode, String childTag, ResultSet rs ) throws Exception
1:     {
0:         String  childClassName = rs.getClass().getName();
0:         String  typeAttribute = childClassName.substring( childClassName.lastIndexOf( "." ) + 1 );
1:         Element result = parentNode.getOwnerDocument().createElement( childTag );
0:         result.setAttribute( "type", typeAttribute );
1: 
1:         parentNode.appendChild( result );
1:         return result;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Pretty-print the inner ResultSet fields inside an outer ResultSet.
1:      * Returns the outerNode.
1:      * </p>
1:      */
1:     public  static  Element    childrenToXML
1:         ( Element outerNode, ResultSet outerRS ) throws Exception
1:     {
1:         ArrayList<Field>    fieldList = new ArrayList<Field>();
1:         findResultSetFields( fieldList, outerRS.getClass() );
1: 
1:         //
1:         // Get a array of all the ResultSet fields inside the outerRS,
1:         // ordered by field name.
1:         //
1:         Field[] fields = new Field[ fieldList.size() ];
1:         fieldList.toArray( fields );
1:         Arrays.sort( fields, new FieldComparator() );
1: 
1:         // Add those fields as children of the outer element.
1:         for ( Field field : fields )
1:         {
0:             ResultSet   innerRS = (ResultSet) field.get( outerRS );
1: 
0:             if ( innerRS != null) { innerRS.toXML( outerNode, field.getName() ); }
1:         }
1: 
1:         return outerNode;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Find all fields of type ResultSet.
1:      * </p>
1:      */
0:     private static  void    findResultSetFields( ArrayList<Field> fieldList, Class<?> klass )
1:         throws Exception
1:     {
1:         if ( klass == null ) { return; }
1:         
0:         Field[] fields = klass.getDeclaredFields();
1: 
1:         for ( Field field : fields )
1:         {
1:             if ( ResultSet.class.isAssignableFrom( field.getType() ) ) { fieldList.add( field ); }
1:         }
1: 
1:         findResultSetFields( fieldList, klass.getSuperclass() );
1:     }
1: 
1:     public  static  final   class   FieldComparator implements Comparator<Field>
1:     {
1:         public  int compare( Field left, Field right ) { return left.getName().compareTo( right.getName() ); }
1:     }
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1: 	public final long	modifiedRowCount() { return 0; }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:75ec275
/////////////////////////////////////////////////////////////////////////
1: 	public final void addWarning(SQLWarning w) {
/////////////////////////////////////////////////////////////////////////
1:             if (rs != null) {
1:                 rs.addWarning(w);
1:             }
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	ResultDescription resultDescription;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	 *  @param  resultDescription the result description. May be null.
/////////////////////////////////////////////////////////////////////////
1: 	BasicNoPutResultSetImpl(ResultDescription resultDescription,
1: 							Activation activation,
1: 		this.resultDescription = resultDescription;
/////////////////////////////////////////////////////////////////////////
1:      * Returns the description of the table's rows
1: 	 */
1: 	public ResultDescription getResultDescription() {
1: 	    return resultDescription;
1: 	}
1: 
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:8fe03ce
/////////////////////////////////////////////////////////////////////////
1:         StatementContext localStatementContext = lcc.getStatementContext();
commit:6211712
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
0:         LanguageConnectionContext lcc = getLanguageConnectionContext();
0:         StatementContext localStatementContext = lcc.getStatementContext();            
1: 		InterruptStatus.throwIf(lcc);
1: 
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1:             statementContext.setActivation(activation);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a660147
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:49f3f24
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			int numCols = accessedCols.getNumBitsSet();
/////////////////////////////////////////////////////////////////////////
1: 			for (int i = accessedCols.anySetBit();
1: 					i = accessedCols.anySetBit(i))
/////////////////////////////////////////////////////////////////////////
1: 	protected final void setCompatRow(ExecRow compactRow, DataValueDescriptor[] sourceRow) {
1: 		DataValueDescriptor[] destRow = compactRow.getRowArray();
commit:4ef8621
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	BasicNoPutResultSetImpl(Activation activation,
/////////////////////////////////////////////////////////////////////////
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
1: import java.sql.Timestamp;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.store.access.TransactionController;
/////////////////////////////////////////////////////////////////////////
1: 	private final boolean				statisticsTimingOn;
/////////////////////////////////////////////////////////////////////////
1: 		if (statisticsTimingOn = getLanguageConnectionContext().getStatisticsTiming())
1: 		    beginTime = startExecutionTime = getCurrentTimeMillis();
1: 	/**
1: 	 * Allow sub-classes to record the total
1: 	 * time spent in their constructor time.
1: 	 *
1: 	 */
1: 	protected final void recordConstructorTime()
1: 	{
1: 		if (statisticsTimingOn)
1: 		    constructorTime = getElapsedMillis(beginTime);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
commit:3237ef5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	protected final Activation	    activation;
/////////////////////////////////////////////////////////////////////////
0: 		statisticsTimingOn = getLanguageConnectionContext().getStatisticsTiming();
/////////////////////////////////////////////////////////////////////////
1:         return getActivation().getLanguageConnectionContext();
/////////////////////////////////////////////////////////////////////////
1: 		return activation.getExecutionFactory();
/////////////////////////////////////////////////////////////////////////
1: 				ExecutionFactory ex = getLanguageConnectionContext().getLanguageConnectionFactory().getExecutionFactory();
commit:6c000e8
/////////////////////////////////////////////////////////////////////////
0: 				ExecutionFactory ex = lcc.getLanguageConnectionFactory().getExecutionFactory();
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	public final Activation getActivation()
1: 	{
1: 		return activation;
1: 	}
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks whether the currently executing statement has been cancelled.
1:      * This is done by checking the statement's allocated StatementContext
1:      * object.
1:      *
1:      * @see StatementContext
1:      */
1: 	public void checkCancellationFlag()
1:         throws
1:             StandardException
1: 	{
0:         StatementContext localStatementContext = getLanguageConnectionContext().getStatementContext();            
1:         if (localStatementContext == null) {
1:             return;
1:         }
1: 
1:         if (localStatementContext.isCancelled()) {
1:             throw StandardException.newException(SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT);
1:         }
1:     }
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.BasicNoPutResultSetImpl
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: 
0: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Row;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
1: 
1: /**
1:  * Abstract ResultSet for for operations that return rows but
1:  * do not allow the caller to put data on output pipes. This
1:  * basic implementation does not include support for an Activiation.
1:  * See NoPutResultSetImpl.java for an implementaion with support for
1:  * an activiation.
1:  * <p>
1:  * This abstract class does not define the entire ResultSet
1:  * interface, but leaves the 'get' half of the interface
1:  * for subtypes to implement. It is package-visible only,
1:  * with its methods being public for exposure by its subtypes.
1:  * <p>
1:  */
1: abstract class BasicNoPutResultSetImpl
1: implements NoPutResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/* Modified during the life of this object */
1:     protected boolean isOpen;
1:     protected boolean finished;
1: 	protected ExecRow	  currentRow;
1: 	protected boolean isTopResultSet;
0: 	protected LanguageConnectionContext	lcc;
1: 	private SQLWarning	warnings;
1: 
1: 	/* Run time statistics variables */
1: 	public int numOpens;
1: 	public int rowsSeen;
1: 	public int rowsFiltered;
1: 	protected long startExecutionTime;
1: 	protected long endExecutionTime;
1: 	public long beginTime;
1: 	public long constructorTime;
1: 	public long openTime;
1: 	public long nextTime;
1: 	public long closeTime;
1: 
1: 	public double optimizerEstimatedRowCount;
1: 	public double optimizerEstimatedCost;
1: 
1: 	// set on demand during execution
1: 	private StatementContext			statementContext;
1: 	public NoPutResultSet[]			subqueryTrackingArray;
1: 	ExecRow compactRow;
1: 
1: 	// Set in the constructor and not modified
0: 	protected Activation	    activation;
0: 	private boolean				statisticsTimingOn;
1: 
0: 	ResultDescription resultDescription;
1: 
0: 	private transient ExecutionFactory			exFactory;
1: 	private transient TransactionController	tc;
1: 
1: 	private int[] baseColumnMap;
1: 
1: 	/**
1: 	 *  Constructor.
1: 	    <BR>
1: 		Sets beginTime for all children to use to measue constructor time.
1: 	 *
0: 	 *  @param  resultDescription the result description. May be null.
1: 	 *	@param	activation			The activation
1: 	 *	@param	optimizerEstimatedRowCount	The optimizer's estimate of the
1: 	 *										total number of rows for this
1: 	 *										result set
1: 	 *	@param	optimizerEstimatedCost		The optimizer's estimated cost for
1: 	 *										this result set
1: 	 */
0: 	BasicNoPutResultSetImpl(ResultDescription resultDescription,
0: 							Activation activation,
1: 							double optimizerEstimatedRowCount,
1: 							double optimizerEstimatedCost)
1: 	{
1: 		this.activation = activation;
0: 		statisticsTimingOn = (activation != null && getLanguageConnectionContext().getStatisticsTiming());
0: 		beginTime = startExecutionTime = getCurrentTimeMillis();
0: 		this.resultDescription = resultDescription;
1: 		this.optimizerEstimatedRowCount = optimizerEstimatedRowCount;
1: 		this.optimizerEstimatedCost = optimizerEstimatedCost;
1: 	}
1: 
1: 	// NoPutResultSet interface
1: 
1: 	/**
1: 	 * @see NoPutResultSet#openCore
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
0: 	public abstract void openCore() throws StandardException;
1: 
1: 	/**
1: 	 * This is the default implementation of reopenCore().
1: 	 * It simply does a close() followed by an open().  If
1: 	 * there are optimizations to be made (caching, etc), this
1: 	 * is a good place to do it -- this will be overridden
1: 	 * by a number of resultSet imlementations.  and SHOULD
1: 	 * be overridden by any node that can get between a base
1: 	 * table and a join.
1: 	 *
1: 	 * @see NoPutResultSet#openCore
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public void reopenCore() throws StandardException
1: 	{
1: 		close();
0: 		openCore();	
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#getNextRowCore
1: 	 * @exception StandardException thrown if cursor finished.
1: 	 */
1: 	public abstract ExecRow	getNextRowCore() throws StandardException;
1: 
1: 	/**
1: 	 * @see NoPutResultSet#getPointOfAttachment
1: 	 */
1: 	public int getPointOfAttachment()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getPointOfAttachment() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 		return -1;
1: 	}
1: 
1: 	/**
1: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
1: 	 * Useful for closing down the ResultSet on an error.
1: 	 *
1: 	 * @return Nothing.
1: 	 */
1: 	public void markAsTopResultSet()
1: 	{
1: 		isTopResultSet = true;
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#getScanIsolationLevel
1: 	 */
1: 	public int getScanIsolationLevel()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"getScanIsolationLevel() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 		return 0;
1: 	}
1: 
1: 	/** @see NoPutResultSet#getEstimatedRowCount */
1: 	public double getEstimatedRowCount()
1: 	{
1: 		return optimizerEstimatedRowCount;
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#requiresRelocking
1: 	 */
1: 	public boolean requiresRelocking()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT(
1: 				"requiresRelocking() not expected to be called for " +
1: 				getClass().getName());
1: 		}
1: 		return false;
1: 	}
1: 
1: 	// ResultSet interface
1: 
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * NOTE: This method should only be called on the top ResultSet
1: 	 * of a ResultSet tree to ensure that the entire ResultSet
1: 	 * tree gets closed down on an error.  the openCore() method
1: 	 * will be called for all other ResultSets in the tree.
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public final void	open() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 				SanityManager.THROWASSERT(
1: 				this + "expected to be the top ResultSet");
1: 		}
1: 
1: 		finished = false;
1: 
1: 		attachStatementContext();
1: 
1: 		try {
1: 
0: 			openCore();
1: 
1: 		} catch (StandardException se) {
1: 			activation.checkStatementValidity();
1: 			throw se;
1: 		}
1: 
1: 		activation.checkStatementValidity();
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the absolute position from the query, 
1: 	 * and returns NULL when there is no such position.
1: 	 * (Negative position means from the end of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: An exception will be thrown on 0.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the absolute position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, ABSOLUTE);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"getAbsoluteRow() not expected to be called for " + getClass().getName());
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the relative position from the current
1: 	 * cursor position, and returns NULL when there is no such position.
1: 	 * (Negative position means toward the beginning of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: 0 is valid.
1: 	 * NOTE: An exception is thrown if the cursor is not currently
1: 	 * positioned on a row.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the relative position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getRelativeRow(int row) throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, RELATIVE);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"getRelativeRow() not expected to be called for " + getClass().getName());
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to before the first row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	setBeforeFirstRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"setBeforeFirstRow() not expected to be called for " + getClass().getName());
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1:     /**
1:      * Determine if the cursor is before the first row in the result 
1:      * set.   
1:      *
1:      * @return true if before the first row, false otherwise. Returns
1:      * false when the result set contains no rows.
1:      */
1:     public boolean checkRowPosition(int isType) throws StandardException
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row number of the current row.  Row
1: 	 * numbers start from 1 and go to 'n'.  Corresponds
1: 	 * to row numbering used to position current row
1: 	 * in the result set (as per JDBC).
1: 	 *
1: 	 * @return	the row number, or 0 if not on a row
1: 	 *
1: 	 */
1: 	public int getRowNumber()
1: 	{
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * Returns the first row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The first row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getFirstRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"getFirstRow() not expected to be called for " + getClass().getName());
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1:      * Return the requested values computed
1:      * from the next row (if any) for which
1:      * the restriction evaluates to true.
1:      * <p>
1:      * restriction and projection parameters
1:      * are evaluated for each row.
1: 	 *
1: 	 * NOTE: This method should only be called on the top ResultSet
1: 	 * of a ResultSet tree to ensure that the entire ResultSet
1: 	 * tree gets closed down on an error.  the getNextRowCore() method
1: 	 * will be called for all other ResultSets in the tree.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public final ExecRow	getNextRow() throws StandardException 
1: 	{
0: 	    if ( ! isOpen ) {
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, NEXT);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 				SanityManager.THROWASSERT(
1: 				this + "expected to be the top ResultSet");
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		return getNextRowCore();
1: 	}
1: 
1: 	/**
1: 	 * Returns the previous row from the query, and returns NULL when there
1: 	 * are no more previous rows.
1: 	 *
1: 	 * @return	The previous row, or NULL if no more previous rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getPreviousRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, PREVIOUS);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"getPreviousRow() not expected to be called.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the last row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The last row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	getLastRow()
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
1: 		}
1: 
1: 		attachStatementContext();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"getLastRow() not expected to be called.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to after the last row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
1: 	public ExecRow	setAfterLastRow() 
1: 		throws StandardException
1: 	{
1: 	    if ( ! isOpen ) 
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (!isTopResultSet)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					this + "expected to be the top ResultSet");
1: 			}
1: 
1: 			SanityManager.THROWASSERT(
1: 				"setAfterLastRow() not expected to be called.");
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 
1:     /**
1:      * Returns true.
1: 	 */
1: 	 public boolean	returnsRows() { return true; }
1: 
0: 	public final int	modifiedRowCount() { return 0; }
1: 
1: 	/**
1:      * Clean up on error
1: 	 * @exception StandardException		Thrown on failure
1: 	 *
1: 	 */
1: 	public void	cleanUp() throws StandardException
1: 	{
1: 		if (isOpen) {
1: 			close();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Report if closed.
1: 	 */
1: 	public boolean	isClosed() {
1: 	    return ( ! isOpen );
1: 	}
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		finishAndRTS();
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException on error
1: 	 */	
1: 	protected final void finishAndRTS() throws StandardException
1: 	{
1: 
1: 		if (!finished) {
1: 			/*
0: 			** If run time statistics tracing is turned on, then now is the
0: 			** time to dump out the information.
1: 			*/
1: 			if (isTopResultSet) {
1: 
0: 				LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 				if (lcc.getRunTimeStatisticsMode())
1: 				{
0: 					endExecutionTime = getCurrentTimeMillis();
1: 
0: 					lcc.setRunTimeStatisticsObject(
0: 						lcc.getExecutionContext().getResultSetStatisticsFactory().getRunTimeStatistics(activation, this, subqueryTrackingArray));
1: 
0: 					HeaderPrintWriter istream = lcc.getLogQueryPlan() ? Monitor.getStream() : null;
0: 					if (istream != null)
1: 					{
0: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 												  lcc.getTransactionExecute().getTransactionIdString() +
0: 												  "), " +
0: 												  LanguageConnectionContext.lccStr +
0: 												  lcc.getInstanceNumber() +
0: 												  "), " +
0: 												  lcc.getRunTimeStatisticsObject().getStatementText() + " ******* " +
0: 												  lcc.getRunTimeStatisticsObject().getStatementExecutionPlanText());
1: 					}
1: 				}
1: 
1: 			}
1: 
1: 			if (!isClosed())
1: 				close();
1: 
1: 			finished = true;
1: 
1: 			if (isTopResultSet && activation.isSingleExecution())
1: 				activation.close();
1: 		}
1: 	}
1: 
1: 	/* The following methods are common to almost all sub-classes.
1: 	 * They are overriden in selected cases.
1: 	 */
1: 
1: 	/**
0:      * Returns the description of the table's rows
1: 	 */
0: 	public ResultDescription getResultDescription() {
0: 	    return resultDescription;
1: 	}
1: 
1: 	/**
1: 	 * Get the execution time in milliseconds.
1: 	 *
1: 	 * @return long		The execution time in milliseconds.
1: 	 */
1: 	public long getExecuteTime()
1: 	{
1: 		return getTimeSpent(ResultSet.ENTIRE_RESULTSET_TREE);
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the beginning of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1: 	 */
1: 	public Timestamp getBeginExecutionTimestamp()
1: 	{
1: 		if (startExecutionTime == 0)
1: 		{
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 			return new Timestamp(startExecutionTime);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the end of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the end of execution.
1: 	 */
1: 	public Timestamp getEndExecutionTimestamp()
1: 	{
1: 		if (endExecutionTime == 0)
1: 		{
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 			return new Timestamp(endExecutionTime);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSet#getSubqueryTrackingArray
1: 	 */
1: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1: 	{
1: 		if (subqueryTrackingArray == null)
1: 		{
1: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1: 		}
1: 
1: 		return subqueryTrackingArray;
1: 	}
1: 
1: 	/**
1: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
1: 	 * on, else return 0.  (Only pay price of system call if need to.)
1: 	 *
1: 	 * @return long		Current time in milliseconds.
1: 	 */
1: 	protected final long getCurrentTimeMillis()
1: 	{
1: 		if (statisticsTimingOn)
1: 		{
1: 			return System.currentTimeMillis();
1: 		}
1: 		else
1: 		{
1: 			return 0;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1: 	 */
1: 	public ResultSet getAutoGeneratedKeysResultset()
1: 	{
1: 		//A non-null resultset would be returned only for an insert statement 
1: 		return (ResultSet)null;
1: 	}
1: 
1: 	/**
1: 	 * Return the elapsed time in milliseconds, between now and the beginTime, if
1: 	 * DEBUG and RunTimeStats is on, else return 0.  
1: 	 * (Only pay price of system call if need to.)
1: 	 *
1: 	 * @return long		Elapsed time in milliseconds.
1: 	 */
1: 
1: 	protected final long getElapsedMillis(long beginTime)
1: 	{
1: 		if (statisticsTimingOn)
1: 		{
1: 			return (System.currentTimeMillis() - beginTime);
1: 		}
1: 		else
1: 		{
1: 			return 0;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Dump out the time information for run time stats.
1: 	 *
1: 	 * @return Nothing.
1: 	 */
1: 	protected final String dumpTimeStats(String indent, String subIndent)
1: 	{
1: 		return 
1: 			indent +
1: 			  MessageService.getTextMessage(SQLState.LANG_TIME_SPENT_THIS) +
1: 			  " " + getTimeSpent(ResultSet.CURRENT_RESULTSET_ONLY) + "\n" +
1: 			indent +
1: 			  MessageService.getTextMessage(
1: 				SQLState.LANG_TIME_SPENT_THIS_AND_BELOW) +
1: 			  " " + getTimeSpent(NoPutResultSet.ENTIRE_RESULTSET_TREE) + "\n" +
1: 			indent +
1: 			  MessageService.getTextMessage(
1: 				SQLState.LANG_TOTAL_TIME_BREAKDOWN) + "\n" +
1: 			subIndent +
1: 			  MessageService.getTextMessage(SQLState.LANG_CONSTRUCTOR_TIME) +
1: 			  " " + constructorTime + "\n" +
1: 			subIndent +
1: 			  MessageService.getTextMessage(SQLState.LANG_OPEN_TIME) +
1: 			  " " + openTime + "\n" +
1: 			subIndent +
1: 			  MessageService.getTextMessage(SQLState.LANG_NEXT_TIME) +
1: 			  " " + nextTime + "\n" +
1: 			subIndent +
1: 			  MessageService.getTextMessage(SQLState.LANG_CLOSE_TIME) +
1: 			  " " + closeTime;
1: 	}
1: 
1: 
1: 	/**
1: 	  *	Attach this result set to the top statement context on the stack.
1: 	  *	Result sets can be directly read from the JDBC layer. The JDBC layer
1: 	  * will push and pop a statement context around each ResultSet.getNext().
1: 	  * There's no guarantee that the statement context used for the last
1: 	  * getNext() will be the context used for the current getNext(). The
1: 	  * last statement context may have been popped off the stack and so
1: 	  *	will not be available for cleanup if an error occurs. To make sure
1: 	  *	that we will be cleaned up, we always attach ourselves to the top	
1: 	  *	context.
1: 	  *
1: 	  *	The fun and games occur in nested contexts: using JDBC result sets inside
1: 	  * user code that is itself invoked from queries or CALL statements.
1: 	  *
1: 	  *
1: 	  * @exception StandardException thrown if cursor finished.
1: 	  */
1: 	protected	void	attachStatementContext() throws StandardException
1: 	{
1: 		if (isTopResultSet)
1: 		{
1: 			if (statementContext == null || !statementContext.onStack() )
1: 			{
1: 				statementContext = getLanguageConnectionContext().getStatementContext();
1: 			}
1: 			statementContext.setTopResultSet(this, subqueryTrackingArray);
1: 			// Pick up any materialized subqueries
1: 			if (subqueryTrackingArray == null)
1: 			{
1: 				subqueryTrackingArray = statementContext.getSubqueryTrackingArray();
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	  *	Cache the language connection context. Return it.
1: 	  *
1: 	  *	@return	the language connection context
1: 	  */
1: 	protected	final LanguageConnectionContext	getLanguageConnectionContext()
1: 	{
0: 		if ( lcc == null )
1: 		{
0: 			/* We don't always have an activation.  Get the LCC
0: 			 * from the activation when we have one.
1: 			 */
0: 			if (activation != null)
1: 			{
0: 				lcc = activation.getLanguageConnectionContext();
1: 			}
1: 			else
1: 			{
0: 				lcc = (LanguageConnectionContext) ContextService.getContext(LanguageConnectionContext.CONTEXT_ID); 
1: 			}
1: 		}
1: 
0: 		return	lcc;
1: 	}
1: 
1: 	/** @see NoPutResultSet#resultSetNumber() */
1: 	public int resultSetNumber() {
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.THROWASSERT(
1: 				"resultSetNumber() should not be called on a " +
1: 				this.getClass().getName()
1: 				);
1: 		}
1: 
1: 		return 0;
1: 	}
1: 
1: 	//////////////////////////////////////////////////////
1: 	//
1: 	// UTILS	
1: 	//
1: 	//////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Get a execution factory
1: 	 *
1: 	 * @return the execution factory
1: 	 */
1: 	final ExecutionFactory getExecutionFactory() 
1: 	{
0: 		if (exFactory == null) {
0: 			exFactory = activation.getExecutionFactory();
1: 		}
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(exFactory!=null,"unable to get execution factory");
0: 		return exFactory;
1: 	}
1: 
1: 	/**
1: 	 * Get the current transaction controller.
1: 	 *
1: 	 */
1:   	final TransactionController getTransactionController()
1:  	{
1:   		if (tc == null)
1:   		{
1: 			tc = getLanguageConnectionContext().getTransactionExecute();
1:   		}
1:   		return tc;
1:   	}
1: 
1: 	/**
1: 	 * Get a compacted version of the candidate row according to the
1: 	 * columns specified in the bit map. Share the holders between rows.
1: 	 * If there is no bit map, use the candidate row as the compact row.
1: 	 *
1: 	 * Also, create an array of ints mapping base column positions to
1: 	 * compact column positions, to make it cheaper to copy columns to
1: 	 * the compact row, if we ever have to do it again.
1: 	 *
1: 	 * @param candidate		The row to get the columns from
1: 	 * @param accessedCols	A bit map of the columns that are accessed in
1: 	 *						the candidate row
0: 	 * @param otherCols		An bit map of other column ids - this is used
0: 	 *						in case columns from an index row will be
0: 	 *						copied into a heap row - in this case, we
0: 	 *						need to be sure there are enough columns in
0: 	 *						the compact row. This parameter is null if
0: 	 *						columns will not be copied from an index row
0: 	 *						to a compact heap row. The column numbers in
0: 	 *						the bit map are zero-based.
1: 	 * @param isKeyed		Tells whether to return a ValueRow or an IndexRow
1: 	 *
1: 	 * @return		A compact row.
1: 	 */
1: 	protected ExecRow getCompactRow(ExecRow candidate,
1: 									FormatableBitSet accessedCols,
0: 									FormatableBitSet otherCols,
1: 									boolean isKeyed)
1: 									throws StandardException
1: 	{
1: 		int		numCandidateCols = candidate.nColumns();
1: 
1: 		if (accessedCols == null)
1: 		{
1: 			compactRow =  candidate;
1: 			baseColumnMap = new int[numCandidateCols];
1: 			for (int i = 0; i < baseColumnMap.length; i++)
1: 				baseColumnMap[i] = i;
1: 		}
1: 		else
1: 		{
0: 			FormatableBitSet allCols;
1: 
0: 			if (otherCols == null)
1: 			{
0: 				allCols = accessedCols;
1: 			}
1: 			else
1: 			{
0: 				allCols = new FormatableBitSet(accessedCols);
0: 				allCols.or(otherCols);
1: 			}
1: 
0: 			int numCols = allCols.getNumBitsSet();
1: 			baseColumnMap = new int[numCols];
1: 
1: 			if (compactRow == null)
1: 			{
0: 				ExecutionFactory ex = lcc.getExecutionContext().getExecutionFactory();
1: 
1: 				if (isKeyed)
1: 				{
1: 					compactRow = ex.getIndexableRow(numCols);
1: 				}
1: 				else
1: 				{
1: 					compactRow = ex.getValueRow(numCols);
1: 				}
1: 			}
1: 
1: 			int position = 0;
0: 			for (int i = allCols.anySetBit();
1: 					i != -1;
0: 					i = allCols.anySetBit(i))
1: 			{
1: 				// Stop looking if there are columns beyond the columns
1: 				// in the candidate row. This can happen due to the
1: 				// otherCols bit map.
1: 				if (i >= numCandidateCols)
1: 					break;
1: 
1: 				DataValueDescriptor sc = candidate.getColumn(i+1);
1: 				if (sc != null)
1: 				{
1: 					compactRow.setColumn(
1: 									position + 1,
1: 									sc
1: 									);
1: 				}
1: 				baseColumnMap[position] = i;
1: 				position++;
1: 			}
1: 		}
1: 
1: 		return compactRow;
1: 	}
1: 
1: 	/**
1: 	 * Copy columns from the candidate row from the store to the given
1: 	 * compact row. If there is no column map, just use the candidate row.
1: 	 *
1: 	 * This method assumes the above method (getCompactRow()) was called
1: 	 * first. getCompactRow() sets up the baseColumnMap.
1: 	 *
1: 	 * @param candidateRow	The candidate row from the store
1: 	 * @param compactRow	The compact row to fill in
1: 	 *
1: 	 * @return	The compact row to use
1: 	 */
1: 	protected ExecRow setCompactRow(ExecRow candidateRow, ExecRow compactRow)
1: 	{
1: 		ExecRow	retval;
1: 
1: 		//System.out.println("base col map " + baseColumnMap);
1: 		if (baseColumnMap == null)
1: 		{
1: 			retval = candidateRow;
1: 		}
1: 		else
1: 		{
1: 			retval = compactRow;
1: 
1: 			setCompatRow(compactRow, candidateRow.getRowArray());
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 
0: 	protected final void setCompatRow(ExecRow compactRow, Object[] sourceRow) {
1: 
0: 		Object[] destRow = compactRow.getRowArray();
1: 		int[] lbcm = baseColumnMap;
1: 
1: 		for (int i = 0; i < lbcm.length; i++)
1: 		{
1: 
1: 			destRow[i] = sourceRow[lbcm[i]];
1: 
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * This method will be overriden in the inherited Classes
1: 	 * if it is true
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return false;
1: 	}
1: 
0: 	protected final void addWarning(SQLWarning w) {
1: 
1: 		if (isTopResultSet) {
1: 			if (warnings == null)
1: 				warnings = w;
1: 			else 
1: 				warnings.setNextWarning(w);
1: 			return;
1: 		}
1: 
1: 		if (activation != null) {
1: 
1: 			ResultSet rs = activation.getResultSet();
0: 			if (rs instanceof BasicNoPutResultSetImpl) {
0: 				((BasicNoPutResultSetImpl) rs).addWarning(w);
1: 			}
1: 
1: 		}
1: 	}
1: 
1: 	public final SQLWarning getWarnings() {
1: 		SQLWarning w = warnings;
1: 		warnings = null;
1: 		return w;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: 
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
0: 
0: /**
0:  * Abstract ResultSet for for operations that return rows but
0:  * do not allow the caller to put data on output pipes. This
0:  * basic implementation does not include support for an Activiation.
0:  * See NoPutResultSetImpl.java for an implementaion with support for
0:  * an activiation.
0:  * <p>
0:  * This abstract class does not define the entire ResultSet
0:  * interface, but leaves the 'get' half of the interface
0:  * for subtypes to implement. It is package-visible only,
0:  * with its methods being public for exposure by its subtypes.
0:  * <p>
0:  */
0: abstract class BasicNoPutResultSetImpl
0: implements NoPutResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* Modified during the life of this object */
0:     protected boolean isOpen;
0:     protected boolean finished;
0: 	protected ExecRow	  currentRow;
0: 	protected boolean isTopResultSet;
0: 	protected LanguageConnectionContext	lcc;
0: 	private SQLWarning	warnings;
0: 
0: 	/* Run time statistics variables */
0: 	public int numOpens;
0: 	public int rowsSeen;
0: 	public int rowsFiltered;
0: 	protected long startExecutionTime;
0: 	protected long endExecutionTime;
0: 	public long beginTime;
0: 	public long constructorTime;
0: 	public long openTime;
0: 	public long nextTime;
0: 	public long closeTime;
0: 
0: 	public double optimizerEstimatedRowCount;
0: 	public double optimizerEstimatedCost;
0: 
0: 	// set on demand during execution
0: 	private StatementContext			statementContext;
0: 	public NoPutResultSet[]			subqueryTrackingArray;
0: 	ExecRow compactRow;
0: 
0: 	// Set in the constructor and not modified
0: 	protected Activation	    activation;
0: 	private boolean				statisticsTimingOn;
0: 
0: 	ResultDescription resultDescription;
0: 
0: 	private transient ExecutionFactory			exFactory;
0: 	private transient TransactionController	tc;
0: 
0: 	private int[] baseColumnMap;
0: 
0: 	/**
0: 	 *  Constructor.
0: 	    <BR>
0: 		Sets beginTime for all children to use to measue constructor time.
0: 	 *
0: 	 *  @param  resultDescription the result description. May be null.
0: 	 *	@param	activation			The activation
0: 	 *	@param	optimizerEstimatedRowCount	The optimizer's estimate of the
0: 	 *										total number of rows for this
0: 	 *										result set
0: 	 *	@param	optimizerEstimatedCost		The optimizer's estimated cost for
0: 	 *										this result set
0: 	 */
0: 	BasicNoPutResultSetImpl(ResultDescription resultDescription,
0: 							Activation activation,
0: 							double optimizerEstimatedRowCount,
0: 							double optimizerEstimatedCost)
0: 	{
0: 		this.activation = activation;
0: 		statisticsTimingOn = (activation != null && getLanguageConnectionContext().getStatisticsTiming());
0: 		beginTime = startExecutionTime = getCurrentTimeMillis();
0: 		this.resultDescription = resultDescription;
0: 		this.optimizerEstimatedRowCount = optimizerEstimatedRowCount;
0: 		this.optimizerEstimatedCost = optimizerEstimatedCost;
0: 	}
0: 
0: 	// NoPutResultSet interface
0: 
0: 	/**
0: 	 * @see NoPutResultSet#openCore
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public abstract void openCore() throws StandardException;
0: 
0: 	/**
0: 	 * This is the default implementation of reopenCore().
0: 	 * It simply does a close() followed by an open().  If
0: 	 * there are optimizations to be made (caching, etc), this
0: 	 * is a good place to do it -- this will be overridden
0: 	 * by a number of resultSet imlementations.  and SHOULD
0: 	 * be overridden by any node that can get between a base
0: 	 * table and a join.
0: 	 *
0: 	 * @see NoPutResultSet#openCore
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public void reopenCore() throws StandardException
0: 	{
0: 		close();
0: 		openCore();	
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#getNextRowCore
0: 	 * @exception StandardException thrown if cursor finished.
0: 	 */
0: 	public abstract ExecRow	getNextRowCore() throws StandardException;
0: 
0: 	/**
0: 	 * @see NoPutResultSet#getPointOfAttachment
0: 	 */
0: 	public int getPointOfAttachment()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getPointOfAttachment() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 		return -1;
0: 	}
0: 
0: 	/**
0: 	 * Mark the ResultSet as the topmost one in the ResultSet tree.
0: 	 * Useful for closing down the ResultSet on an error.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void markAsTopResultSet()
0: 	{
0: 		isTopResultSet = true;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#getScanIsolationLevel
0: 	 */
0: 	public int getScanIsolationLevel()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"getScanIsolationLevel() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 		return 0;
0: 	}
0: 
0: 	/** @see NoPutResultSet#getEstimatedRowCount */
0: 	public double getEstimatedRowCount()
0: 	{
0: 		return optimizerEstimatedRowCount;
0: 	}
0: 
0: 	/**
0: 	 * @see NoPutResultSet#requiresRelocking
0: 	 */
0: 	public boolean requiresRelocking()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT(
0: 				"requiresRelocking() not expected to be called for " +
0: 				getClass().getName());
0: 		}
0: 		return false;
0: 	}
0: 
0: 	// ResultSet interface
0: 
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * NOTE: This method should only be called on the top ResultSet
0: 	 * of a ResultSet tree to ensure that the entire ResultSet
0: 	 * tree gets closed down on an error.  the openCore() method
0: 	 * will be called for all other ResultSets in the tree.
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public final void	open() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 				SanityManager.THROWASSERT(
0: 				this + "expected to be the top ResultSet");
0: 		}
0: 
0: 		finished = false;
0: 
0: 		attachStatementContext();
0: 
0: 		try {
0: 
0: 			openCore();
0: 
0: 		} catch (StandardException se) {
0: 			activation.checkStatementValidity();
0: 			throw se;
0: 		}
0: 
0: 		activation.checkStatementValidity();
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the absolute position from the query, 
0: 	 * and returns NULL when there is no such position.
0: 	 * (Negative position means from the end of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: An exception will be thrown on 0.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the absolute position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, ABSOLUTE);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"getAbsoluteRow() not expected to be called for " + getClass().getName());
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the relative position from the current
0: 	 * cursor position, and returns NULL when there is no such position.
0: 	 * (Negative position means toward the beginning of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: 0 is valid.
0: 	 * NOTE: An exception is thrown if the cursor is not currently
0: 	 * positioned on a row.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the relative position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getRelativeRow(int row) throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, RELATIVE);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"getRelativeRow() not expected to be called for " + getClass().getName());
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to before the first row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setBeforeFirstRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"setBeforeFirstRow() not expected to be called for " + getClass().getName());
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0:     /**
0:      * Determine if the cursor is before the first row in the result 
0:      * set.   
0:      *
0:      * @return true if before the first row, false otherwise. Returns
0:      * false when the result set contains no rows.
0:      */
0:     public boolean checkRowPosition(int isType) throws StandardException
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row number of the current row.  Row
0: 	 * numbers start from 1 and go to 'n'.  Corresponds
0: 	 * to row numbering used to position current row
0: 	 * in the result set (as per JDBC).
0: 	 *
0: 	 * @return	the row number, or 0 if not on a row
0: 	 *
0: 	 */
0: 	public int getRowNumber()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * Returns the first row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The first row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getFirstRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, FIRST);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"getFirstRow() not expected to be called for " + getClass().getName());
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0:      * Return the requested values computed
0:      * from the next row (if any) for which
0:      * the restriction evaluates to true.
0:      * <p>
0:      * restriction and projection parameters
0:      * are evaluated for each row.
0: 	 *
0: 	 * NOTE: This method should only be called on the top ResultSet
0: 	 * of a ResultSet tree to ensure that the entire ResultSet
0: 	 * tree gets closed down on an error.  the getNextRowCore() method
0: 	 * will be called for all other ResultSets in the tree.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public final ExecRow	getNextRow() throws StandardException 
0: 	{
0: 	    if ( ! isOpen ) {
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, NEXT);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 				SanityManager.THROWASSERT(
0: 				this + "expected to be the top ResultSet");
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		return getNextRowCore();
0: 	}
0: 
0: 	/**
0: 	 * Returns the previous row from the query, and returns NULL when there
0: 	 * are no more previous rows.
0: 	 *
0: 	 * @return	The previous row, or NULL if no more previous rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getPreviousRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, PREVIOUS);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"getPreviousRow() not expected to be called.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the last row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The last row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getLastRow()
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
0: 		}
0: 
0: 		attachStatementContext();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"getLastRow() not expected to be called.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to after the last row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setAfterLastRow() 
0: 		throws StandardException
0: 	{
0: 	    if ( ! isOpen ) 
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, LAST);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (!isTopResultSet)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					this + "expected to be the top ResultSet");
0: 			}
0: 
0: 			SanityManager.THROWASSERT(
0: 				"setAfterLastRow() not expected to be called.");
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 
0:     /**
0:      * Returns true.
0: 	 */
0: 	 public boolean	returnsRows() { return true; }
0: 
0: 	public final int	modifiedRowCount() { return 0; }
0: 
0: 	/**
0:      * Clean up on error
0: 	 * @exception StandardException		Thrown on failure
0: 	 *
0: 	 */
0: 	public void	cleanUp() throws StandardException
0: 	{
0: 		if (isOpen) {
0: 			close();
0: 		}
0: 	}
0: 
0: 	/**
0: 		Report if closed.
0: 	 */
0: 	public boolean	isClosed() {
0: 	    return ( ! isOpen );
0: 	}
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		finishAndRTS();
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException on error
0: 	 */	
0: 	protected final void finishAndRTS() throws StandardException
0: 	{
0: 
0: 		if (!finished) {
0: 			/*
0: 			** If run time statistics tracing is turned on, then now is the
0: 			** time to dump out the information.
0: 			*/
0: 			if (isTopResultSet) {
0: 
0: 				LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 				if (lcc.getRunTimeStatisticsMode())
0: 				{
0: 					endExecutionTime = getCurrentTimeMillis();
0: 
0: 					lcc.setRunTimeStatisticsObject(
0: 						lcc.getExecutionContext().getResultSetStatisticsFactory().getRunTimeStatistics(activation, this, subqueryTrackingArray));
0: 
0: 					HeaderPrintWriter istream = lcc.getLogQueryPlan() ? Monitor.getStream() : null;
0: 					if (istream != null)
0: 					{
0: 						istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 												  lcc.getTransactionExecute().getTransactionIdString() +
0: 												  "), " +
0: 												  LanguageConnectionContext.lccStr +
0: 												  lcc.getInstanceNumber() +
0: 												  "), " +
0: 												  lcc.getRunTimeStatisticsObject().getStatementText() + " ******* " +
0: 												  lcc.getRunTimeStatisticsObject().getStatementExecutionPlanText());
0: 					}
0: 				}
0: 
0: 			}
0: 
0: 			if (!isClosed())
0: 				close();
0: 
0: 			finished = true;
0: 
0: 			if (isTopResultSet && activation.isSingleExecution())
0: 				activation.close();
0: 		}
0: 	}
0: 
0: 	/* The following methods are common to almost all sub-classes.
0: 	 * They are overriden in selected cases.
0: 	 */
0: 
0: 	/**
0:      * Returns the description of the table's rows
0: 	 */
0: 	public ResultDescription getResultDescription() {
0: 	    return resultDescription;
0: 	}
0: 
0: 	/**
0: 	 * Get the execution time in milliseconds.
0: 	 *
0: 	 * @return long		The execution time in milliseconds.
0: 	 */
0: 	public long getExecuteTime()
0: 	{
0: 		return getTimeSpent(ResultSet.ENTIRE_RESULTSET_TREE);
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the beginning of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the beginning of execution.
0: 	 */
0: 	public Timestamp getBeginExecutionTimestamp()
0: 	{
0: 		if (startExecutionTime == 0)
0: 		{
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 			return new Timestamp(startExecutionTime);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the end of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the end of execution.
0: 	 */
0: 	public Timestamp getEndExecutionTimestamp()
0: 	{
0: 		if (endExecutionTime == 0)
0: 		{
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 			return new Timestamp(endExecutionTime);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSet#getSubqueryTrackingArray
0: 	 */
0: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
0: 	{
0: 		if (subqueryTrackingArray == null)
0: 		{
0: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
0: 		}
0: 
0: 		return subqueryTrackingArray;
0: 	}
0: 
0: 	/**
0: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
0: 	 * on, else return 0.  (Only pay price of system call if need to.)
0: 	 *
0: 	 * @return long		Current time in milliseconds.
0: 	 */
0: 	protected final long getCurrentTimeMillis()
0: 	{
0: 		if (statisticsTimingOn)
0: 		{
0: 			return System.currentTimeMillis();
0: 		}
0: 		else
0: 		{
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSet#getAutoGeneratedKeysResultset
0: 	 */
0: 	public ResultSet getAutoGeneratedKeysResultset()
0: 	{
0: 		//A non-null resultset would be returned only for an insert statement 
0: 		return (ResultSet)null;
0: 	}
0: 
0: 	/**
0: 	 * Return the elapsed time in milliseconds, between now and the beginTime, if
0: 	 * DEBUG and RunTimeStats is on, else return 0.  
0: 	 * (Only pay price of system call if need to.)
0: 	 *
0: 	 * @return long		Elapsed time in milliseconds.
0: 	 */
0: 
0: 	protected final long getElapsedMillis(long beginTime)
0: 	{
0: 		if (statisticsTimingOn)
0: 		{
0: 			return (System.currentTimeMillis() - beginTime);
0: 		}
0: 		else
0: 		{
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Dump out the time information for run time stats.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	protected final String dumpTimeStats(String indent, String subIndent)
0: 	{
0: 		return 
0: 			indent +
0: 			  MessageService.getTextMessage(SQLState.LANG_TIME_SPENT_THIS) +
0: 			  " " + getTimeSpent(ResultSet.CURRENT_RESULTSET_ONLY) + "\n" +
0: 			indent +
0: 			  MessageService.getTextMessage(
0: 				SQLState.LANG_TIME_SPENT_THIS_AND_BELOW) +
0: 			  " " + getTimeSpent(NoPutResultSet.ENTIRE_RESULTSET_TREE) + "\n" +
0: 			indent +
0: 			  MessageService.getTextMessage(
0: 				SQLState.LANG_TOTAL_TIME_BREAKDOWN) + "\n" +
0: 			subIndent +
0: 			  MessageService.getTextMessage(SQLState.LANG_CONSTRUCTOR_TIME) +
0: 			  " " + constructorTime + "\n" +
0: 			subIndent +
0: 			  MessageService.getTextMessage(SQLState.LANG_OPEN_TIME) +
0: 			  " " + openTime + "\n" +
0: 			subIndent +
0: 			  MessageService.getTextMessage(SQLState.LANG_NEXT_TIME) +
0: 			  " " + nextTime + "\n" +
0: 			subIndent +
0: 			  MessageService.getTextMessage(SQLState.LANG_CLOSE_TIME) +
0: 			  " " + closeTime;
0: 	}
0: 
0: 
0: 	/**
0: 	  *	Attach this result set to the top statement context on the stack.
0: 	  *	Result sets can be directly read from the JDBC layer. The JDBC layer
0: 	  * will push and pop a statement context around each ResultSet.getNext().
0: 	  * There's no guarantee that the statement context used for the last
0: 	  * getNext() will be the context used for the current getNext(). The
0: 	  * last statement context may have been popped off the stack and so
0: 	  *	will not be available for cleanup if an error occurs. To make sure
0: 	  *	that we will be cleaned up, we always attach ourselves to the top	
0: 	  *	context.
0: 	  *
0: 	  *	The fun and games occur in nested contexts: using JDBC result sets inside
0: 	  * user code that is itself invoked from queries or CALL statements.
0: 	  *
0: 	  *
0: 	  * @exception StandardException thrown if cursor finished.
0: 	  */
0: 	protected	void	attachStatementContext() throws StandardException
0: 	{
0: 		if (isTopResultSet)
0: 		{
0: 			if (statementContext == null || !statementContext.onStack() )
0: 			{
0: 				statementContext = getLanguageConnectionContext().getStatementContext();
0: 			}
0: 			statementContext.setTopResultSet(this, subqueryTrackingArray);
0: 			// Pick up any materialized subqueries
0: 			if (subqueryTrackingArray == null)
0: 			{
0: 				subqueryTrackingArray = statementContext.getSubqueryTrackingArray();
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	  *	Cache the language connection context. Return it.
0: 	  *
0: 	  *	@return	the language connection context
0: 	  */
0: 	protected	final LanguageConnectionContext	getLanguageConnectionContext()
0: 	{
0: 		if ( lcc == null )
0: 		{
0: 			/* We don't always have an activation.  Get the LCC
0: 			 * from the activation when we have one.
0: 			 */
0: 			if (activation != null)
0: 			{
0: 				lcc = activation.getLanguageConnectionContext();
0: 			}
0: 			else
0: 			{
0: 				lcc = (LanguageConnectionContext) ContextService.getContext(LanguageConnectionContext.CONTEXT_ID); 
0: 			}
0: 		}
0: 
0: 		return	lcc;
0: 	}
0: 
0: 	/** @see NoPutResultSet#resultSetNumber() */
0: 	public int resultSetNumber() {
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.THROWASSERT(
0: 				"resultSetNumber() should not be called on a " +
0: 				this.getClass().getName()
0: 				);
0: 		}
0: 
0: 		return 0;
0: 	}
0: 
0: 	//////////////////////////////////////////////////////
0: 	//
0: 	// UTILS	
0: 	//
0: 	//////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Get a execution factory
0: 	 *
0: 	 * @return the execution factory
0: 	 */
0: 	final ExecutionFactory getExecutionFactory() 
0: 	{
0: 		if (exFactory == null) {
0: 			exFactory = activation.getExecutionFactory();
0: 		}
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(exFactory!=null,"unable to get execution factory");
0: 		return exFactory;
0: 	}
0: 
0: 	/**
0: 	 * Get the current transaction controller.
0: 	 *
0: 	 */
0:   	final TransactionController getTransactionController()
0:  	{
0:   		if (tc == null)
0:   		{
0: 			tc = getLanguageConnectionContext().getTransactionExecute();
0:   		}
0:   		return tc;
0:   	}
0: 
0: 	/**
0: 	 * Get a compacted version of the candidate row according to the
0: 	 * columns specified in the bit map. Share the holders between rows.
0: 	 * If there is no bit map, use the candidate row as the compact row.
0: 	 *
0: 	 * Also, create an array of ints mapping base column positions to
0: 	 * compact column positions, to make it cheaper to copy columns to
0: 	 * the compact row, if we ever have to do it again.
0: 	 *
0: 	 * @param candidate		The row to get the columns from
0: 	 * @param accessedCols	A bit map of the columns that are accessed in
0: 	 *						the candidate row
0: 	 * @param otherCols		An bit map of other column ids - this is used
0: 	 *						in case columns from an index row will be
0: 	 *						copied into a heap row - in this case, we
0: 	 *						need to be sure there are enough columns in
0: 	 *						the compact row. This parameter is null if
0: 	 *						columns will not be copied from an index row
0: 	 *						to a compact heap row. The column numbers in
0: 	 *						the bit map are zero-based.
0: 	 * @param isKeyed		Tells whether to return a ValueRow or an IndexRow
0: 	 *
0: 	 * @return		A compact row.
0: 	 */
0: 	protected ExecRow getCompactRow(ExecRow candidate,
0: 									FormatableBitSet accessedCols,
0: 									FormatableBitSet otherCols,
0: 									boolean isKeyed)
0: 									throws StandardException
0: 	{
0: 		int		numCandidateCols = candidate.nColumns();
0: 
0: 		if (accessedCols == null)
0: 		{
0: 			compactRow =  candidate;
0: 			baseColumnMap = new int[numCandidateCols];
0: 			for (int i = 0; i < baseColumnMap.length; i++)
0: 				baseColumnMap[i] = i;
0: 		}
0: 		else
0: 		{
0: 			FormatableBitSet allCols;
0: 
0: 			if (otherCols == null)
0: 			{
0: 				allCols = accessedCols;
0: 			}
0: 			else
0: 			{
0: 				allCols = new FormatableBitSet(accessedCols);
0: 				allCols.or(otherCols);
0: 			}
0: 
0: 			int numCols = allCols.getNumBitsSet();
0: 			baseColumnMap = new int[numCols];
0: 
0: 			if (compactRow == null)
0: 			{
0: 				ExecutionFactory ex = lcc.getExecutionContext().getExecutionFactory();
0: 
0: 				if (isKeyed)
0: 				{
0: 					compactRow = ex.getIndexableRow(numCols);
0: 				}
0: 				else
0: 				{
0: 					compactRow = ex.getValueRow(numCols);
0: 				}
0: 			}
0: 
0: 			int position = 0;
0: 			for (int i = allCols.anySetBit();
0: 					i != -1;
0: 					i = allCols.anySetBit(i))
0: 			{
0: 				// Stop looking if there are columns beyond the columns
0: 				// in the candidate row. This can happen due to the
0: 				// otherCols bit map.
0: 				if (i >= numCandidateCols)
0: 					break;
0: 
0: 				DataValueDescriptor sc = candidate.getColumn(i+1);
0: 				if (sc != null)
0: 				{
0: 					compactRow.setColumn(
0: 									position + 1,
0: 									sc
0: 									);
0: 				}
0: 				baseColumnMap[position] = i;
0: 				position++;
0: 			}
0: 		}
0: 
0: 		return compactRow;
0: 	}
0: 
0: 	/**
0: 	 * Copy columns from the candidate row from the store to the given
0: 	 * compact row. If there is no column map, just use the candidate row.
0: 	 *
0: 	 * This method assumes the above method (getCompactRow()) was called
0: 	 * first. getCompactRow() sets up the baseColumnMap.
0: 	 *
0: 	 * @param candidateRow	The candidate row from the store
0: 	 * @param compactRow	The compact row to fill in
0: 	 *
0: 	 * @return	The compact row to use
0: 	 */
0: 	protected ExecRow setCompactRow(ExecRow candidateRow, ExecRow compactRow)
0: 	{
0: 		ExecRow	retval;
0: 
0: 		//System.out.println("base col map " + baseColumnMap);
0: 		if (baseColumnMap == null)
0: 		{
0: 			retval = candidateRow;
0: 		}
0: 		else
0: 		{
0: 			retval = compactRow;
0: 
0: 			setCompatRow(compactRow, candidateRow.getRowArray());
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 
0: 	protected final void setCompatRow(ExecRow compactRow, Object[] sourceRow) {
0: 
0: 		Object[] destRow = compactRow.getRowArray();
0: 		int[] lbcm = baseColumnMap;
0: 
0: 		for (int i = 0; i < lbcm.length; i++)
0: 		{
0: 
0: 			destRow[i] = sourceRow[lbcm[i]];
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * This method will be overriden in the inherited Classes
0: 	 * if it is true
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	protected final void addWarning(SQLWarning w) {
0: 
0: 		if (isTopResultSet) {
0: 			if (warnings == null)
0: 				warnings = w;
0: 			else 
0: 				warnings.setNextWarning(w);
0: 			return;
0: 		}
0: 
0: 		if (activation != null) {
0: 
0: 			ResultSet rs = activation.getResultSet();
0: 			if (rs instanceof BasicNoPutResultSetImpl) {
0: 				((BasicNoPutResultSetImpl) rs).addWarning(w);
0: 			}
0: 
0: 		}
0: 	}
0: 
0: 	public final SQLWarning getWarnings() {
0: 		SQLWarning w = warnings;
0: 		warnings = null;
0: 		return w;
0: 	}
0: }
============================================================================