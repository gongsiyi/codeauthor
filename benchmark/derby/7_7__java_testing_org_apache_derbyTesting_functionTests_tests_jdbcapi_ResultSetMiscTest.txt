1:aa53134: /*
3:aa53134: 
1:aa53134:  Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ResultSetMiscTest
1:aa53134: 
1:aa53134:  Licensed to the Apache Software Foundation (ASF) under one or more
1:aa53134:  contributor license agreements.  See the NOTICE file distributed with
1:aa53134:  this work for additional information regarding copyright ownership.
1:aa53134:  The ASF licenses this file to You under the Apache License, Version 2.0
1:aa53134:  (the "License"); you may not use this file except in compliance with
1:aa53134:  the License.  You may obtain a copy of the License at
1:aa53134: 
1:aa53134:  http://www.apache.org/licenses/LICENSE-2.0
1:aa53134: 
1:aa53134:  Unless required by applicable law or agreed to in writing, software
1:aa53134:  distributed under the License is distributed on an "AS IS" BASIS,
1:aa53134:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:aa53134:  See the License for the specific language governing permissions and
1:aa53134:  limitations under the License.
1:aa53134: 
1:aa53134:  */
1:aa53134: 
1:aa53134: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:aa53134: 
1:aa53134: import java.sql.Connection;
1:aa53134: import java.sql.PreparedStatement;
1:aa53134: import java.sql.ResultSet;
1:aa53134: import java.sql.ResultSetMetaData;
1:aa53134: import java.sql.SQLException;
1:aa53134: import java.sql.Statement;
1:aa53134: import junit.framework.Test;
1:aa53134: import org.apache.derbyTesting.functionTests.util.SecurityCheck;
1:aa53134: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:aa53134: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:66edb71: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:aa53134: import org.apache.derbyTesting.junit.TestConfiguration;
1:aa53134: import org.apache.derbyTesting.junit.Utilities;
1:aa53134: 
1:aa53134: public class ResultSetMiscTest extends BaseJDBCTestCase {
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Hang onto the SecurityCheck class while running the tests so that it is
1:aa53134:      * not garbage collected during the test and lose the information it has
1:aa53134:      * collected.
1:aa53134:      */
1:aa53134:     private final Object nogc = SecurityCheck.class;
1:aa53134: 
1:aa53134:     public ResultSetMiscTest(String name) {
1:aa53134:         super(name);
3:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Test resultset metadata on columns of various types
2:aa53134:      * 
1:aa53134:      * @throws SQLException
1:aa53134:      */
1:aa53134:     public void testResultSetMetaData() throws SQLException {
1:aa53134:         Statement stmt = createStatement();
1:aa53134:         ResultSet rs = stmt
1:aa53134:                 .executeQuery("select i, s, r, d, dt, t, ts, c, v, dc, bi, cbd, vbd, lvbd, cl, bl from t");
1:aa53134:         ResultSetMetaData met = rs.getMetaData();
1:aa53134:         rs = stmt
1:aa53134:                 .executeQuery("select i, s, r, d, dt, t, ts, c, v, dc, bi, cbd, vbd, lvbd, cl, bl from t");
1:aa53134:         met = rs.getMetaData();
1:aa53134: 
1:aa53134:         int colCount = met.getColumnCount();
1:aa53134:         assertEquals(16, colCount);
1:aa53134: 
1:aa53134:         // Column 1 INTEGER
1:aa53134:         assertFalse(met.isAutoIncrement(1));
1:aa53134:         assertFalse(met.isCaseSensitive(1));
1:aa53134:         assertTrue(met.isSearchable(1));
1:aa53134:         assertFalse(met.isCurrency(1));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(1));
1:aa53134:         assertTrue(met.isSigned(1));
1:aa53134:         assertEquals(11, met.getColumnDisplaySize(1));
1:aa53134:         assertEquals("I", met.getColumnLabel(1));
1:aa53134:         assertEquals("I", met.getColumnName(1));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(1));
1:aa53134:         assertEquals("APP", met.getSchemaName(1));
1:aa53134:         assertEquals("", met.getCatalogName(1));
1:aa53134:         assertEquals(java.sql.Types.INTEGER, met.getColumnType(1));
1:aa53134:         assertEquals(10, met.getPrecision(1));
1:aa53134:         assertEquals(0, met.getScale(1));
1:aa53134:         assertEquals("INTEGER", met.getColumnTypeName(1));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
2:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(1));
1:aa53134:         assertFalse(met.isWritable(1));
1:aa53134:         assertFalse(met.isDefinitelyWritable(1));
1:aa53134: 
1:aa53134:         // Column 2 SMALLINT
1:aa53134:         assertFalse(met.isAutoIncrement(2));
1:aa53134:         assertFalse(met.isCaseSensitive(2));
1:aa53134:         assertTrue(met.isSearchable(2));
1:aa53134:         assertFalse(met.isCurrency(2));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(2));
1:aa53134:         assertTrue(met.isSigned(2));
1:aa53134:         assertEquals(6, met.getColumnDisplaySize(2));
1:aa53134:         assertEquals("S", met.getColumnLabel(2));
1:aa53134:         assertEquals("S", met.getColumnName(2));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(2));
1:aa53134:         assertEquals("APP", met.getSchemaName(2));
1:aa53134:         assertEquals("", met.getCatalogName(2));
1:aa53134:         assertEquals(java.sql.Types.SMALLINT, met.getColumnType(2));
1:aa53134:         assertEquals(5, met.getPrecision(2));
1:aa53134:         assertEquals(0, met.getScale(2));
1:aa53134:         assertEquals("SMALLINT", met.getColumnTypeName(2));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(2));
1:aa53134:         assertFalse(met.isWritable(2));
1:aa53134:         assertFalse(met.isDefinitelyWritable(2));
1:aa53134: 
1:aa53134:         // Column 3 REAL
1:aa53134:         assertFalse(met.isAutoIncrement(3));
1:aa53134:         assertFalse(met.isCaseSensitive(3));
1:aa53134:         assertTrue(met.isSearchable(3));
1:aa53134:         assertFalse(met.isCurrency(3));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(3));
1:aa53134:         assertTrue(met.isSigned(3));
1:c0a5ce1:         assertEquals(15, met.getColumnDisplaySize(3));
1:aa53134:         assertEquals("R", met.getColumnLabel(3));
1:aa53134:         assertEquals("R", met.getColumnName(3));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(3));
1:aa53134:         assertEquals("APP", met.getSchemaName(3));
1:aa53134:         assertEquals("", met.getCatalogName(3));
1:aa53134:         assertEquals(java.sql.Types.REAL, met.getColumnType(3));
1:aa53134:         assertEquals(7, met.getPrecision(3));
1:aa53134:         assertEquals(0, met.getScale(3));
1:aa53134:         assertEquals("REAL", met.getColumnTypeName(3));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(3));
1:aa53134:         assertFalse(met.isWritable(3));
1:aa53134:         assertFalse(met.isDefinitelyWritable(3));
1:aa53134: 
1:aa53134:         // Column 4 DOUBLE
1:aa53134:         assertFalse(met.isAutoIncrement(4));
1:aa53134:         assertFalse(met.isCaseSensitive(4));
1:aa53134:         assertTrue(met.isSearchable(4));
1:aa53134:         assertFalse(met.isCurrency(4));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(4));
1:aa53134:         assertTrue(met.isSigned(4));
1:c0a5ce1:         assertEquals(24, met.getColumnDisplaySize(4));
1:aa53134:         assertEquals("D", met.getColumnLabel(4));
1:aa53134:         assertEquals("D", met.getColumnName(4));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(4));
1:aa53134:         assertEquals("APP", met.getSchemaName(4));
1:aa53134:         assertEquals("", met.getCatalogName(4));
1:aa53134:         assertEquals(java.sql.Types.DOUBLE, met.getColumnType(4));
1:aa53134:         assertEquals(15, met.getPrecision(4));
1:aa53134:         assertEquals(0, met.getScale(4));
1:aa53134:         assertEquals("DOUBLE", met.getColumnTypeName(4));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(4));
1:aa53134:         assertFalse(met.isWritable(4));
1:aa53134:         assertFalse(met.isDefinitelyWritable(4));
1:aa53134: 
1:aa53134:         // Column 5 DATE
1:aa53134:         assertFalse(met.isAutoIncrement(5));
1:aa53134:         assertFalse(met.isCaseSensitive(5));
1:aa53134:         assertTrue(met.isSearchable(5));
1:aa53134:         assertFalse(met.isCurrency(5));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(5));
1:aa53134:         assertFalse(met.isSigned(5));
1:aa53134:         assertEquals(10, met.getColumnDisplaySize(5));
1:aa53134:         assertEquals("DT", met.getColumnLabel(5));
1:aa53134:         assertEquals("DT", met.getColumnName(5));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(5));
1:aa53134:         assertEquals("APP", met.getSchemaName(5));
1:aa53134:         assertEquals("", met.getCatalogName(5));
1:aa53134:         assertEquals(java.sql.Types.DATE, met.getColumnType(5));
1:aa53134:         assertEquals(10, met.getPrecision(5));
1:aa53134:         assertEquals(0, met.getScale(5));
1:aa53134:         assertEquals("DATE", met.getColumnTypeName(5));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(1));
1:aa53134:         assertFalse(met.isWritable(1));
1:aa53134:         assertFalse(met.isDefinitelyWritable(1));
1:aa53134: 
1:aa53134:         // COLUMN 7 TIMESTAMP
1:aa53134:         assertFalse(met.isAutoIncrement(7));
1:aa53134:         assertFalse(met.isCaseSensitive(7));
1:aa53134:         assertTrue(met.isSearchable(7));
1:aa53134:         assertFalse(met.isCurrency(7));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(7));
1:aa53134:         assertFalse(met.isSigned(7));
1:1e90bf4:         assertEquals(29, met.getColumnDisplaySize(7));
1:aa53134:         assertEquals("TS", met.getColumnLabel(7));
1:aa53134:         assertEquals("TS", met.getColumnName(7));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(7));
1:aa53134:         assertEquals("APP", met.getSchemaName(7));
1:aa53134:         assertEquals("", met.getCatalogName(7));
1:aa53134:         assertEquals(java.sql.Types.TIMESTAMP, met.getColumnType(7));
1:1e90bf4:         assertEquals(29, met.getPrecision(7));
1:1e90bf4:         assertEquals(9, met.getScale(7));
1:aa53134:         assertEquals("TIMESTAMP", met.getColumnTypeName(7));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(7));
1:aa53134:         assertFalse(met.isWritable(7));
1:aa53134:         assertFalse(met.isDefinitelyWritable(7));
1:aa53134: 
1:aa53134:         // COLUMN 8 CHAR
1:aa53134:         assertFalse(met.isAutoIncrement(8));
1:aa53134:         assertTrue(met.isCaseSensitive(8));
1:aa53134:         assertTrue(met.isSearchable(8));
1:aa53134:         assertFalse(met.isCurrency(8));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(8));
1:aa53134:         assertFalse(met.isSigned(8));
1:aa53134:         assertEquals(10, met.getColumnDisplaySize(8));
1:aa53134:         assertEquals("C", met.getColumnLabel(8));
1:aa53134:         assertEquals("C", met.getColumnName(8));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(8));
1:aa53134:         assertEquals("APP", met.getSchemaName(8));
1:aa53134:         assertEquals("", met.getCatalogName(8));
1:aa53134:         assertEquals(java.sql.Types.CHAR, met.getColumnType(8));
1:aa53134:         assertEquals(10, met.getPrecision(8));
1:aa53134:         assertEquals(0, met.getScale(8));
1:aa53134:         assertEquals("CHAR", met.getColumnTypeName(8));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(8));
1:aa53134:         assertFalse(met.isWritable(8));
1:aa53134:         assertFalse(met.isDefinitelyWritable(8));
1:aa53134: 
1:aa53134:         // COLUMN 9 VARCHAR
1:aa53134:         assertFalse(met.isAutoIncrement(9));
1:aa53134:         assertTrue(met.isCaseSensitive(9));
1:aa53134:         assertTrue(met.isSearchable(9));
1:aa53134:         assertFalse(met.isCurrency(9));
1:aa53134:         assertEquals(ResultSetMetaData.columnNoNulls, met.isNullable(9));
1:aa53134:         assertFalse(met.isSigned(9));
1:aa53134:         assertEquals(40, met.getColumnDisplaySize(9));
1:aa53134:         assertEquals("V", met.getColumnLabel(9));
1:aa53134:         assertEquals("V", met.getColumnName(9));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(9));
1:aa53134:         assertEquals("APP", met.getSchemaName(9));
1:aa53134:         assertEquals("", met.getCatalogName(9));
1:aa53134:         assertEquals(java.sql.Types.VARCHAR, met.getColumnType(9));
1:aa53134:         assertEquals(40, met.getPrecision(9));
1:aa53134:         assertEquals(0, met.getScale(9));
1:aa53134:         assertEquals("VARCHAR", met.getColumnTypeName(9));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(9));
1:aa53134:         assertFalse(met.isWritable(9));
1:aa53134:         assertFalse(met.isDefinitelyWritable(9));
1:aa53134: 
1:aa53134:         // COLUMN 10 DECIMAL
1:aa53134:         assertFalse(met.isAutoIncrement(10));
1:aa53134:         assertFalse(met.isCaseSensitive(10));
1:aa53134:         assertTrue(met.isSearchable(10));
1:c66c15d:         assertFalse(met.isCurrency(10));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(10));
1:aa53134:         assertTrue(met.isSigned(10));
1:aa53134:         assertEquals(12, met.getColumnDisplaySize(10));
1:aa53134:         assertEquals("DC", met.getColumnLabel(10));
1:aa53134:         assertEquals("DC", met.getColumnName(10));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(10));
1:aa53134:         assertEquals("APP", met.getSchemaName(10));
1:aa53134:         assertEquals("", met.getCatalogName(10));
1:aa53134:         assertEquals(java.sql.Types.DECIMAL, met.getColumnType(10));
1:aa53134:         assertEquals(10, met.getPrecision(10));
1:aa53134:         assertEquals(2, met.getScale(10));
1:aa53134:         assertEquals("DECIMAL", met.getColumnTypeName(10));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(10));
1:aa53134:         assertFalse(met.isWritable(10));
1:aa53134:         assertFalse(met.isDefinitelyWritable(10));
1:aa53134: 
1:aa53134:         // COLUMN 11 BIGINT
1:aa53134:         assertFalse(met.isAutoIncrement(11));
1:aa53134:         assertFalse(met.isCaseSensitive(11));
1:aa53134:         assertTrue(met.isSearchable(11));
1:aa53134:         assertFalse(met.isCurrency(11));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(11));
1:aa53134:         assertTrue(met.isSigned(11));
1:aa53134:         assertEquals(20, met.getColumnDisplaySize(11));
1:aa53134:         assertEquals("BI", met.getColumnLabel(11));
1:aa53134:         assertEquals("BI", met.getColumnName(11));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(11));
1:aa53134:         assertEquals("APP", met.getSchemaName(11));
1:aa53134:         assertEquals("", met.getCatalogName(11));
1:aa53134:         assertEquals(java.sql.Types.BIGINT, met.getColumnType(11));
1:aa53134:         assertEquals(19, met.getPrecision(11));
1:aa53134:         assertEquals(0, met.getScale(11));
1:aa53134:         assertEquals("BIGINT", met.getColumnTypeName(11));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(11));
1:aa53134:         assertFalse(met.isWritable(11));
1:aa53134:         assertFalse(met.isDefinitelyWritable(11));
1:aa53134: 
1:aa53134:         // COLUMN 12 CHAR FOR BIT DATA
1:aa53134:         assertFalse(met.isAutoIncrement(12));
1:aa53134:         assertFalse(met.isCaseSensitive(12));
1:aa53134:         assertTrue(met.isSearchable(12));
1:aa53134:         assertFalse(met.isCurrency(12));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(12));
1:aa53134:         assertFalse(met.isSigned(12));
1:aa53134:         assertEquals(20, met.getColumnDisplaySize(12));
1:aa53134:         assertEquals("CBD", met.getColumnLabel(12));
1:aa53134:         assertEquals("CBD", met.getColumnName(12));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(12));
1:aa53134:         assertEquals("APP", met.getSchemaName(12));
1:aa53134:         assertEquals("", met.getCatalogName(12));
1:aa53134:         assertEquals(java.sql.Types.BINARY, met.getColumnType(12));
1:aa53134:         assertEquals(10, met.getPrecision(12));
1:aa53134:         assertEquals(0, met.getScale(12));
1:aa53134:         // client and embedded differ in name, but stil a rose.
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertEquals("CHAR () FOR BIT DATA", met.getColumnTypeName(12));
1:aa53134:         else
1:aa53134:             assertEquals("CHAR FOR BIT DATA", met.getColumnTypeName(12));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(12));
1:aa53134:         assertFalse(met.isWritable(12));
1:aa53134:         assertFalse(met.isDefinitelyWritable(12));
1:aa53134: 
1:aa53134:         // COLUMN 13 VARCHAR FOR BIT DATA
1:aa53134:         assertFalse(met.isAutoIncrement(13));
1:aa53134:         assertFalse(met.isCaseSensitive(13));
1:aa53134:         assertTrue(met.isSearchable(13));
1:aa53134:         assertFalse(met.isCurrency(13));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(13));
1:aa53134:         assertFalse(met.isSigned(13));
1:aa53134:         assertEquals(20, met.getColumnDisplaySize(13));
1:aa53134:         assertEquals("VBD", met.getColumnLabel(13));
1:aa53134:         assertEquals("VBD", met.getColumnName(13));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(13));
1:aa53134:         assertEquals("APP", met.getSchemaName(13));
1:aa53134:         assertEquals("", met.getCatalogName(13));
1:aa53134:         assertEquals(java.sql.Types.VARBINARY, met.getColumnType(13));
1:aa53134:         assertEquals(10, met.getPrecision(13));
1:aa53134:         assertEquals(0, met.getScale(13));
1:aa53134:         // client and embedded differ in name, but stil a rose.
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertEquals("VARCHAR () FOR BIT DATA", met.getColumnTypeName(13));
1:aa53134:         else
1:aa53134:             assertEquals("VARCHAR FOR BIT DATA", met.getColumnTypeName(13));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(13));
1:aa53134:         assertFalse(met.isWritable(13));
1:aa53134:         assertFalse(met.isDefinitelyWritable(13));
1:aa53134: 
1:aa53134:         // COLUMN 14 LONGVARCHAR FOR BIT DATA
1:aa53134:         assertFalse(met.isAutoIncrement(14));
1:aa53134:         assertFalse(met.isCaseSensitive(14));
1:aa53134:         assertTrue(met.isSearchable(14));
1:aa53134:         assertFalse(met.isCurrency(14));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(14));
1:aa53134:         assertFalse(met.isSigned(14));
1:aa53134:         assertEquals(65400, met.getColumnDisplaySize(14));
1:aa53134:         assertEquals("LVBD", met.getColumnLabel(14));
1:aa53134:         assertEquals("LVBD", met.getColumnName(14));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(14));
1:aa53134:         assertEquals("APP", met.getSchemaName(14));
1:aa53134:         assertEquals("", met.getCatalogName(14));
1:aa53134:         assertEquals(java.sql.Types.LONGVARBINARY, met.getColumnType(14));
1:aa53134:         assertEquals(32700, met.getPrecision(14));
1:aa53134:         assertEquals(0, met.getScale(14));
1:aa53134:         assertEquals("LONG VARCHAR FOR BIT DATA", met.getColumnTypeName(14));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(14));
1:aa53134:         assertFalse(met.isWritable(14));
1:aa53134:         assertFalse(met.isDefinitelyWritable(14));
1:aa53134: 
1:aa53134:         // COLUMN 15 CLOB
1:aa53134:         assertFalse(met.isAutoIncrement(15));
1:aa53134:         assertTrue(met.isCaseSensitive(15));
1:aa53134:         assertTrue(met.isSearchable(15));
1:aa53134:         assertFalse(met.isCurrency(15));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(15));
1:aa53134:         assertFalse(met.isSigned(15));
1:aa53134:         assertEquals(2147483647, met.getColumnDisplaySize(15));
1:aa53134:         assertEquals("CL", met.getColumnLabel(15));
1:aa53134:         assertEquals("CL", met.getColumnName(15));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(15));
1:aa53134:         assertEquals("APP", met.getSchemaName(15));
1:aa53134:         assertEquals("", met.getCatalogName(15));
1:aa53134:         assertEquals(java.sql.Types.CLOB, met.getColumnType(15));
1:aa53134:         assertEquals(2147483647, met.getPrecision(15));
1:aa53134:         assertEquals(0, met.getScale(15));
1:aa53134:         assertEquals("CLOB", met.getColumnTypeName(15));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(15));
1:aa53134:         assertFalse(met.isWritable(15));
1:aa53134:         assertFalse(met.isDefinitelyWritable(15));
1:aa53134: 
1:aa53134:         // COLUMN 16 BLOB
1:aa53134:         assertFalse(met.isAutoIncrement(16));
1:aa53134:         assertFalse(met.isCaseSensitive(16));
1:aa53134:         assertTrue(met.isSearchable(16));
1:aa53134:         assertFalse(met.isCurrency(16));
1:aa53134:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(16));
1:96c0a0e:         assertFalse(met.isSigned(16));       
1:96c0a0e:         assertEquals(2147483647, met.getColumnDisplaySize(16));
1:aa53134:         assertEquals("BL", met.getColumnLabel(16));
1:aa53134:         assertEquals("BL", met.getColumnName(16));
1:aa53134:         // beetle 5323
1:aa53134:         assertEquals("T", met.getTableName(16));
1:aa53134:         assertEquals("APP", met.getSchemaName(16));
1:aa53134:         assertEquals("", met.getCatalogName(16));
1:aa53134:         assertEquals(java.sql.Types.BLOB, met.getColumnType(16));
1:aa53134:         assertEquals(1073741824, met.getPrecision(16));
1:aa53134:         assertEquals(0, met.getScale(16));
1:aa53134:         assertEquals("BLOB", met.getColumnTypeName(16));
1:aa53134:         // DERBY-142 client incorrectly returns true. Enable on client
1:aa53134:         // once DERBY-142 is fixed
1:aa53134:         if (usingEmbedded())
1:aa53134:             assertFalse(met.isReadOnly(16));
1:aa53134:         assertFalse(met.isWritable(16));
1:aa53134:         assertFalse(met.isDefinitelyWritable(16));
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:dbed020:      * Test fix for Bug4810 -Connection.commit() and rollback() do not
1:aa53134:      * commit/rollback in auto-commit mode.
1:aa53134:      */
1:aa53134:     public void testBug4810() throws SQLException {
1:aa53134:         Connection con = getConnection();
1:aa53134: 
1:aa53134:         Statement stmt = con.createStatement();
1:aa53134:         stmt.executeUpdate("create table bug4810(i int, b int)");
1:aa53134:         stmt
1:aa53134:                 .executeUpdate("insert into bug4810 values (1,1), (1,2), (1,3), (1,4)");
1:aa53134:         stmt
1:aa53134:                 .executeUpdate("insert into bug4810 values (1,1), (1,2), (1,3), (1,4)");
1:aa53134:         con.commit();
1:aa53134:         con.setAutoCommit(true);
1:aa53134:         con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:aa53134:         // Just autocommit
1:aa53134:         checkLocksForAutoCommitSelect(con, stmt, 0);
1:aa53134:         // commit with autocommit
1:aa53134:         checkLocksForAutoCommitSelect(con, stmt, 1);
1:aa53134:         // rollback with autocommit
1:aa53134:         checkLocksForAutoCommitSelect(con, stmt, 2);
1:aa53134: 
1:aa53134:         stmt.execute("drop table bug4810");
1:aa53134:         con.commit();
1:aa53134:         stmt.close();
1:aa53134:     }
1:aa53134: 
1:4afca48:      /**
1:4afca48:      * Test fix for DERBY-853 ResultSetMetaData.getScale 
1:4afca48:      *returns inconsistent values for DOUBLE type.
1:4afca48:      */
1:4afca48:     public void testDerby853() throws SQLException {
1:4afca48:         Connection con = getConnection();
1:4afca48: 	
1:4afca48:         Statement stmt = con.createStatement();
1:4afca48:         stmt.executeUpdate("create table derby853(d1 decimal(10,2), d2 double)");
1:4afca48:       
1:4afca48:         ResultSet rs = stmt.executeQuery("select d1 - d2 from derby853");
1:4afca48:         ResultSetMetaData rsmd = rs.getMetaData();
1:4afca48: 	assertEquals(0, rsmd.getScale(1));
1:4afca48: 	assertEquals(15, rsmd.getPrecision(1));
1:4afca48: 
1:4afca48: 	rs = stmt.executeQuery("select d2 - d1 from derby853");
1:4afca48: 	rsmd = rs.getMetaData();
1:4afca48: 	assertEquals(0, rsmd.getScale(1));
1:4afca48: 	assertEquals(15, rsmd.getPrecision(1));
1:4afca48: 
1:4afca48:         stmt.execute("drop table derby853");
1:4afca48:        
1:4afca48:         stmt.close();
1:4afca48:     }
1:4afca48: 
1:aa53134:     /**
1:aa53134:      * Setup up and run the auto-commit tests.
1:b1cb2cc:      * 
1:b1cb2cc:      * 
1:b1cb2cc:      *         
1:aa53134:      * @throws SQLException
1:aa53134:      */
1:aa53134:     public void testAutoCommit() throws SQLException {
1:aa53134:         Connection conn = getConnection();
1:aa53134:         Statement s = conn.createStatement();
1:aa53134:         s.executeUpdate("create table AutoCommitTable (num int)");
1:aa53134: 
1:aa53134:         s.executeUpdate("insert into AutoCommitTable values (1)");
1:aa53134:         s.executeUpdate("insert into AutoCommitTable values (2)");
1:aa53134:         int isolation = conn.getTransactionIsolation();
1:aa53134:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:aa53134:         checkSingleRSAutoCommit(conn);
1:aa53134:         checkSingleRSCloseCursorsAtCommit(conn);
1:aa53134:         conn.setTransactionIsolation(isolation);
1:aa53134:         s.executeUpdate("drop table AutoCommitTable");
1:aa53134:         s.close();
1:aa53134:     }
1:aa53134: 
1:aa53134:     // JIRA-1136: LossOfPrecisionConversionException fetching Float.MAX_VALUE.
1:aa53134:     // This test proves that we can successfully fetch that value from the DB
1:aa53134: 
1:aa53134:     public void testCorrelationNamesAndMetaDataCalls() throws SQLException {
1:aa53134:         Connection conn = getConnection();
1:aa53134:         Statement stmt = conn.createStatement();
1:aa53134:         stmt
1:aa53134:                 .executeUpdate("create table s (a int, b int, c int, d int, e int, f int)");
1:aa53134:         stmt.executeUpdate("insert into s values (0,1,2,3,4,5)");
1:aa53134:         stmt.executeUpdate("insert into s values (10,11,12,13,14,15)");
1:aa53134:         // System.out.println("Run select * from s ss (f, e, d, c, b, a) where f
1:aa53134:         // = 0 and then try getTableName and getSchemaName on columns");
1:aa53134:         ResultSet rs = stmt
1:aa53134:                 .executeQuery("select * from s ss (f, e, d, c, b, a) where f = 0");
1:aa53134:         rs.next();
1:aa53134:         ResultSetMetaData met = rs.getMetaData();
1:aa53134:         assertEquals("S", met.getTableName(1));
1:aa53134:         assertEquals("APP", met.getSchemaName(1));
1:aa53134:         // System.out.println("Run select * from (select * from s) a and then
1:aa53134:         // try getTableName and getSchemaName on columns");
1:aa53134:         rs = stmt.executeQuery("select * from (select * from s) a");
1:aa53134:         rs.next();
1:aa53134:         met = rs.getMetaData();
1:aa53134:         assertEquals("S", met.getTableName(1));
1:aa53134:         assertEquals("APP", met.getSchemaName(1));
1:aa53134:         stmt.executeUpdate("create schema s1");
1:aa53134:         stmt.executeUpdate("create table s1.t1 (c11 int, c12 int)");
1:aa53134:         stmt.executeUpdate("insert into s1.t1 values (11, 12), (21, 22)");
1:aa53134:         // System.out.println("Run select * from s1.t1 as abc and then try
1:aa53134:         // getTableName and getSchemaName on columns");
1:aa53134:         rs = stmt.executeQuery("select * from s1.t1 as abc");
1:aa53134:         met = rs.getMetaData();
1:aa53134:         assertEquals("T1", met.getTableName(1));
1:aa53134:         assertEquals("S1", met.getSchemaName(1));
1:aa53134:         assertEquals("T1", met.getTableName(2));
1:aa53134:         assertEquals("S1", met.getSchemaName(2));
1:aa53134: 
1:aa53134:         // System.out.println("Run select abc.c11 from s1.t1 as abc and then try
1:aa53134:         // getTableName and getSchemaName on columns");
1:aa53134:         rs = stmt.executeQuery("select abc.c11 from s1.t1 as abc");
1:aa53134:         met = rs.getMetaData();
1:aa53134:         assertEquals("T1", met.getTableName(1));
1:aa53134:         assertEquals("S1", met.getSchemaName(1));
1:aa53134:         // System.out.println("Run select bcd.a, abc.c11 from s1.t1 as abc, s as
1:aa53134:         // bcd and then try getTableName and getSchemaName on columns");
1:aa53134:         rs = stmt
1:aa53134:                 .executeQuery("select bcd.a, abc.c11 from s1.t1 as abc, s as bcd");
1:aa53134:         met = rs.getMetaData();
1:aa53134:         assertEquals("S", met.getTableName(1));
1:aa53134:         assertEquals("APP", met.getSchemaName(1));
1:aa53134:         assertEquals("T1", met.getTableName(2));
1:aa53134:         assertEquals("S1", met.getSchemaName(2));
1:aa53134: 
1:aa53134:         stmt.executeUpdate("create schema app1");
1:aa53134:         stmt.executeUpdate("create table app1.t1 (c11 int, c12 int)");
1:aa53134:         stmt.executeUpdate("insert into app1.t1 values (11, 12), (21, 22)");
1:aa53134:         stmt.executeUpdate("create schema app2");
1:aa53134:         stmt.executeUpdate("create table app2.t1 (c11 int, c12 int)");
1:aa53134:         stmt.executeUpdate("insert into app2.t1 values (11, 12), (21, 22)");
1:aa53134:         // System.out.println("Run select app1.t1.c11, app2.t1.c11 from app1.t1,
1:aa53134:         // app2.t1 and then try getTableName and getSchemaName on columns");
1:aa53134:         rs = stmt
1:aa53134:                 .executeQuery("select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1");
1:aa53134:         met = rs.getMetaData();
1:aa53134:         assertEquals("T1", met.getTableName(1));
1:aa53134:         assertEquals("APP1", met.getSchemaName(1));
1:aa53134:         assertEquals("T1", met.getTableName(2));
1:aa53134:         assertEquals("APP2", met.getSchemaName(2));
1:aa53134: 
1:aa53134:         stmt.execute("drop table s");
1:aa53134:         stmt.execute("drop table s1.t1");
1:aa53134:         stmt.execute("drop schema s1 restrict");
1:aa53134:         stmt.execute("drop table app1.t1");
1:aa53134:         stmt.execute("drop table app2.t1");
1:aa53134:         stmt.execute("drop schema app2 restrict");
1:aa53134:         stmt.execute("drop schema app1 restrict");
1:aa53134:     }
1:aa53134: 
1:aa53134:     public void testFloatMAX_VALUE(Connection conn) throws SQLException {
1:aa53134:         Statement stmt = createStatement();
1:aa53134:         try {
1:aa53134:             stmt.execute("drop table jira1136");
1:aa53134:         } catch (Throwable t) {
1:aa53134:         }
1:aa53134:         stmt.execute("create table jira1136 (f float)");
1:aa53134:         stmt.execute("insert into jira1136 values (3.4028235E38)");
1:aa53134:         PreparedStatement ps = conn.prepareStatement("select * from jira1136");
1:aa53134:         ResultSet rs = ps.executeQuery();
1:aa53134:         while (rs.next()) {
1:aa53134:             assertEquals(3.4028235E38, rs.getFloat(1), .00001);
1:aa53134: 
1:aa53134:         }
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Tests for two things:
1:aa53134:      * 
1:aa53134:      * 1) The ResultSet does not close implicitly when the ResultSet completes
1:aa53134:      * and holdability == HOLD_CURSORS_OVER_COMMIT
1:aa53134:      * 
1:aa53134:      * 2) The ResultSet auto-commits when it completes and auto-commit is on.
1:aa53134:      * 
2:aa53134:      * @param conn
2:aa53134:      *            The Connection
1:aa53134:      * @throws SQLException
1:aa53134:      */
1:aa53134:     private void checkSingleRSAutoCommit(Connection conn) throws SQLException {
1:aa53134:         conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:aa53134:         // Single RS auto-commit test:
1:aa53134:         Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:aa53134:                 ResultSet.CONCUR_READ_ONLY);
1:aa53134: 
1:aa53134:         ResultSet rs = s.executeQuery("select * from AutoCommitTable");
1:aa53134:         // drain results but don't close
1:aa53134:         while (rs.next())
1:aa53134:             ;
1:aa53134:         // test that resultset was not implicitly closed but autoCommit occured.
1:aa53134:         assertFalse("Fail Auto-commit unsuccessful", locksHeld());
1:aa53134: 
1:aa53134:         assertFalse("Final call of rs.next() should return false", rs.next());
1:aa53134:         rs.close();
1:aa53134:         // check that next() on closed ResultSet throws an exception
1:aa53134:         try {
1:aa53134:             rs.next();
1:aa53134:             fail("FAIL Error should have occured with rs.next() on a closed ResultSet");
1:aa53134:         } catch (SQLException se) {
1:aa53134:             assertEquals("XCL16", se.getSQLState());
1:c9687fc:             // DERBY-4767, sample verification test for operation in XCL16 message.
1:c9687fc:             assertTrue(se.getMessage().indexOf("next") > 0);
1:aa53134:         }
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Check to see that ResultSet closes implicitly when holdability is set to
1:aa53134:      * CLOSE_CURORS_AT_COMMIT.
1:aa53134:      * 
1:aa53134:      * @param conn
1:aa53134:      *            The Connection
1:aa53134:      * @throws SQLException
1:aa53134:      */
1:aa53134:     private void checkSingleRSCloseCursorsAtCommit(Connection conn)
1:aa53134:             throws SQLException {
1:aa53134:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:aa53134:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:aa53134:         Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:aa53134:                 ResultSet.CONCUR_READ_ONLY);
1:aa53134:         ResultSet rs = s.executeQuery("select * from AutoCommitTable");
1:aa53134:         // drain but do not close resultset.
1:aa53134:         while (rs.next())
1:aa53134:             ;
1:aa53134:         assertFalse("Fail Auto-commit unsuccessful", locksHeld());
1:aa53134:         try {
1:aa53134:             rs.next();
1:aa53134:             fail("FAIL. ResultSet not closed implicitly");
1:aa53134:         } catch (SQLException e) {
1:aa53134:             assertEquals("XCL16", e.getSQLState());
1:aa53134: 
1:aa53134:         }
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Check locks with various commit sequences.
1:aa53134:      * 
1:aa53134:      * @param conn
1:aa53134:      *            Initialized connection
1:aa53134:      * @param stmt
1:aa53134:      *            stmt to use for select from table
1:aa53134:      * @param action
1:aa53134:      *            0 = autocommit only 1 = commit with ResultSet open 2 =
1:aa53134:      *            rollback with ResultSet open
1:aa53134:      * @throws SQLException
1:aa53134:      */
1:aa53134:     private void checkLocksForAutoCommitSelect(Connection conn, Statement stmt,
1:aa53134:             int action) throws SQLException {
1:aa53134: 
1:aa53134:         ResultSet rs = stmt.executeQuery("select i,b from bug4810");
1:aa53134:         rs.next();
1:aa53134:         assertEquals(1, rs.getInt(1));
1:aa53134:         assertEquals(1, rs.getInt(2));
1:aa53134:         rs.next();
1:aa53134:         assertEquals(1, rs.getInt(1));
1:aa53134:         assertEquals(2, rs.getInt(2));
1:aa53134: 
1:aa53134:         if (action == 1) {
1:aa53134:             conn.commit();
1:aa53134:             assertFalse("Should not hold locks after commit", locksHeld());
1:aa53134:         } else if (action == 2) {
1:aa53134:             conn.rollback();
1:aa53134:             assertFalse("Should not hold locks after rollback", locksHeld());
1:aa53134:         } else if (action == 0) {
1:aa53134:             // autocommit only
1:aa53134:             assertTrue("Locks should be held with autocommit only", locksHeld());
1:aa53134: 
1:aa53134:             try {
1:aa53134: 
1:aa53134:                 rs.next();
1:aa53134:                 assertEquals(1, rs.getInt(1));
1:aa53134:                 assertEquals(3, rs.getInt(2));
1:aa53134: 
1:aa53134:             } catch (SQLException sqle) {
1:aa53134:                 fail("Unexpected exception" + sqle.getSQLState() + ":" + sqle.getMessage());
1:aa53134:             }
1:aa53134: 
1:aa53134:         }
1:aa53134:         rs.close();
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:3e52818:      * Check if locks are held.
1:aa53134:      * 
1:b1cb2cc:      * @return true if locks are held.
1:b1cb2cc:      * @throws SQLException
1:aa53134:      */
1:aa53134:     private boolean locksHeld() throws SQLException {
1:aa53134: 
1:aa53134:         Connection con2 = openDefaultConnection();
1:3e52818:         Statement s2 = con2.createStatement();
1:aa53134: 
1:3e52818:         // Wait for post-commit work to complete first. Otherwise, extra
1:3e52818:         // locks may intermittently show up in the lock table. DERBY-5568.
1:3e52818:         s2.execute("CALL WAIT_FOR_POST_COMMIT()");
1:3e52818: 
1:3e52818:         ResultSet rs2 = s2.executeQuery("SELECT 1 FROM SYSCS_DIAG.LOCK_TABLE");
1:3e52818:         boolean hasLocks = rs2.next();
1:aa53134: 
1:aa53134:         rs2.close();
1:3e52818:         s2.close();
1:aa53134:         con2.close();
1:aa53134:         return hasLocks;
1:aa53134:     }
1:aa53134: 
1:aa53134:     /**
1:aa53134:      * Runs the test fixtures in embedded and client.
1:aa53134:      * 
1:aa53134:      * @return test suite
1:aa53134:      */
1:aa53134:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ResultSetTest2");
1:aa53134: 
1:aa53134:         suite.addTest(baseSuite("ResultSetTest2:embedded"));
1:aa53134: 
1:aa53134:         suite.addTest(TestConfiguration
1:aa53134:                 .clientServerDecorator(baseSuite("ResultSetTest2:client")));
1:aa53134:         return suite;
1:aa53134:     }
1:aa53134: 
1:aa53134:     public static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:aa53134:         suite.addTestSuite(ResultSetMiscTest.class);
1:aa53134: 
1:66edb71:         // Some test cases expect lock timeouts, so reduce the timeout to
1:66edb71:         // make the test go faster.
1:66edb71:         Test test = DatabasePropertyTestSetup.setLockTimeouts(suite, 1, 3);
1:66edb71: 
1:66edb71:         return new CleanDatabaseTestSetup(test) {
1:aa53134:             /**
1:aa53134:              * Creates the table used in the test cases.
1:aa53134:              * 
1:aa53134:              */
1:aa53134:             protected void decorateSQL(Statement s) throws SQLException {
1:aa53134: 
1:aa53134:                 s
1:aa53134:                         .execute("create table t (i int, s smallint, r real, "
1:aa53134:                                 + "d double precision, dt date, t time, ts timestamp, "
1:aa53134:                                 + "c char(10), v varchar(40) not null, dc dec(10,2),"
1:aa53134:                                 + "bi bigint, cbd char(10) for bit data,"
1:aa53134:                                 + "vbd varchar(10) for bit data,lvbd long varchar for bit data,"
1:aa53134:                                 + "cl clob(2G), bl blob(1G) )");
1:aa53134:                 s
1:aa53134:                         .execute("insert into t values(1,2,3.3,4.4,date('1990-05-05'),"
1:aa53134:                                 + "time('12:06:06'),timestamp('1990-07-07 07:07:07.000007'),"
1:aa53134:                                 + "'eight','nine', 10.1, 11,"
1:aa53134:                                 + Utilities.stringToHexLiteral("twelv")
1:aa53134:                                 + ","
1:aa53134:                                 + Utilities.stringToHexLiteral("3teen")
1:aa53134:                                 + ","
1:aa53134:                                 + Utilities.stringToHexLiteral("4teen")
1:aa53134:                                 + ", null, null)");
1:aa53134: 
1:3e52818:                 s.execute("CREATE PROCEDURE WAIT_FOR_POST_COMMIT() "
1:3e52818:                         + "LANGUAGE JAVA EXTERNAL NAME "
1:3e52818:                         + "'org.apache.derbyTesting.functionTests.util."
1:3e52818:                         + "T_Access.waitForPostCommitToFinish' "
1:3e52818:                         + "PARAMETER STYLE JAVA");
1:3e52818: 
1:aa53134:             }
1:aa53134:         };
1:aa53134:     }
1:aa53134: 
1:aa53134: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:4afca48
/////////////////////////////////////////////////////////////////////////
1:      /**
1:      * Test fix for DERBY-853 ResultSetMetaData.getScale 
1:      *returns inconsistent values for DOUBLE type.
1:      */
1:     public void testDerby853() throws SQLException {
1:         Connection con = getConnection();
1: 	
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("create table derby853(d1 decimal(10,2), d2 double)");
1:       
1:         ResultSet rs = stmt.executeQuery("select d1 - d2 from derby853");
1:         ResultSetMetaData rsmd = rs.getMetaData();
1: 	assertEquals(0, rsmd.getScale(1));
1: 	assertEquals(15, rsmd.getPrecision(1));
1: 
1: 	rs = stmt.executeQuery("select d2 - d1 from derby853");
1: 	rsmd = rs.getMetaData();
1: 	assertEquals(0, rsmd.getScale(1));
1: 	assertEquals(15, rsmd.getPrecision(1));
1: 
1:         stmt.execute("drop table derby853");
1:        
1:         stmt.close();
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * Test fix for Bug4810 -Connection.commit() and rollback() do not
commit:1e90bf4
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(29, met.getColumnDisplaySize(7));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(29, met.getPrecision(7));
1:         assertEquals(9, met.getScale(7));
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ResultSetTest2");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
commit:c0a5ce1
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(15, met.getColumnDisplaySize(3));
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(24, met.getColumnDisplaySize(4));
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:c66c15d
/////////////////////////////////////////////////////////////////////////
1:         assertFalse(met.isCurrency(10));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3e52818
/////////////////////////////////////////////////////////////////////////
1:      * Check if locks are held.
1:         Statement s2 = con2.createStatement();
1:         // Wait for post-commit work to complete first. Otherwise, extra
1:         // locks may intermittently show up in the lock table. DERBY-5568.
1:         s2.execute("CALL WAIT_FOR_POST_COMMIT()");
1: 
1:         ResultSet rs2 = s2.executeQuery("SELECT 1 FROM SYSCS_DIAG.LOCK_TABLE");
1:         boolean hasLocks = rs2.next();
1:         s2.close();
/////////////////////////////////////////////////////////////////////////
1:                 s.execute("CREATE PROCEDURE WAIT_FOR_POST_COMMIT() "
1:                         + "LANGUAGE JAVA EXTERNAL NAME "
1:                         + "'org.apache.derbyTesting.functionTests.util."
1:                         + "T_Access.waitForPostCommitToFinish' "
1:                         + "PARAMETER STYLE JAVA");
1: 
commit:66edb71
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Some test cases expect lock timeouts, so reduce the timeout to
1:         // make the test go faster.
1:         Test test = DatabasePropertyTestSetup.setLockTimeouts(suite, 1, 3);
1: 
1:         return new CleanDatabaseTestSetup(test) {
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:c9687fc
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-4767, sample verification test for operation in XCL16 message.
1:             assertTrue(se.getMessage().indexOf("next") > 0);
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:96c0a0e
/////////////////////////////////////////////////////////////////////////
1:         assertFalse(met.isSigned(16));       
1:         assertEquals(2147483647, met.getColumnDisplaySize(16));
commit:b1cb2cc
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      *         
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @return true if locks are held.
1:      * @throws SQLException
commit:aa53134
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:  Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.ResultSetMiscTest
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.SecurityCheck;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.Utilities;
1: 
1: public class ResultSetMiscTest extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Hang onto the SecurityCheck class while running the tests so that it is
1:      * not garbage collected during the test and lose the information it has
1:      * collected.
1:      */
1:     private final Object nogc = SecurityCheck.class;
1: 
1:     public ResultSetMiscTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Test resultset metadata on columns of various types
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testResultSetMetaData() throws SQLException {
1:         Statement stmt = createStatement();
1:         ResultSet rs = stmt
1:                 .executeQuery("select i, s, r, d, dt, t, ts, c, v, dc, bi, cbd, vbd, lvbd, cl, bl from t");
1:         ResultSetMetaData met = rs.getMetaData();
1:         rs = stmt
1:                 .executeQuery("select i, s, r, d, dt, t, ts, c, v, dc, bi, cbd, vbd, lvbd, cl, bl from t");
1:         met = rs.getMetaData();
1: 
1:         int colCount = met.getColumnCount();
1:         assertEquals(16, colCount);
1: 
1:         // Column 1 INTEGER
1:         assertFalse(met.isAutoIncrement(1));
1:         assertFalse(met.isCaseSensitive(1));
1:         assertTrue(met.isSearchable(1));
1:         assertFalse(met.isCurrency(1));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(1));
1:         assertTrue(met.isSigned(1));
1:         assertEquals(11, met.getColumnDisplaySize(1));
1:         assertEquals("I", met.getColumnLabel(1));
1:         assertEquals("I", met.getColumnName(1));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(1));
1:         assertEquals("APP", met.getSchemaName(1));
1:         assertEquals("", met.getCatalogName(1));
1:         assertEquals(java.sql.Types.INTEGER, met.getColumnType(1));
1:         assertEquals(10, met.getPrecision(1));
1:         assertEquals(0, met.getScale(1));
1:         assertEquals("INTEGER", met.getColumnTypeName(1));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(1));
1:         assertFalse(met.isWritable(1));
1:         assertFalse(met.isDefinitelyWritable(1));
1: 
1:         // Column 2 SMALLINT
1:         assertFalse(met.isAutoIncrement(2));
1:         assertFalse(met.isCaseSensitive(2));
1:         assertTrue(met.isSearchable(2));
1:         assertFalse(met.isCurrency(2));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(2));
1:         assertTrue(met.isSigned(2));
1:         assertEquals(6, met.getColumnDisplaySize(2));
1:         assertEquals("S", met.getColumnLabel(2));
1:         assertEquals("S", met.getColumnName(2));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(2));
1:         assertEquals("APP", met.getSchemaName(2));
1:         assertEquals("", met.getCatalogName(2));
1:         assertEquals(java.sql.Types.SMALLINT, met.getColumnType(2));
1:         assertEquals(5, met.getPrecision(2));
1:         assertEquals(0, met.getScale(2));
1:         assertEquals("SMALLINT", met.getColumnTypeName(2));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(2));
1:         assertFalse(met.isWritable(2));
1:         assertFalse(met.isDefinitelyWritable(2));
1: 
1:         // Column 3 REAL
1:         assertFalse(met.isAutoIncrement(3));
1:         assertFalse(met.isCaseSensitive(3));
1:         assertTrue(met.isSearchable(3));
1:         assertFalse(met.isCurrency(3));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(3));
1:         assertTrue(met.isSigned(3));
0:         assertEquals(13, met.getColumnDisplaySize(3));
1:         assertEquals("R", met.getColumnLabel(3));
1:         assertEquals("R", met.getColumnName(3));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(3));
1:         assertEquals("APP", met.getSchemaName(3));
1:         assertEquals("", met.getCatalogName(3));
1:         assertEquals(java.sql.Types.REAL, met.getColumnType(3));
1:         assertEquals(7, met.getPrecision(3));
1:         assertEquals(0, met.getScale(3));
1:         assertEquals("REAL", met.getColumnTypeName(3));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(3));
1:         assertFalse(met.isWritable(3));
1:         assertFalse(met.isDefinitelyWritable(3));
1: 
1:         // Column 4 DOUBLE
1:         assertFalse(met.isAutoIncrement(4));
1:         assertFalse(met.isCaseSensitive(4));
1:         assertTrue(met.isSearchable(4));
1:         assertFalse(met.isCurrency(4));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(4));
1:         assertTrue(met.isSigned(4));
0:         assertEquals(22, met.getColumnDisplaySize(4));
1:         assertEquals("D", met.getColumnLabel(4));
1:         assertEquals("D", met.getColumnName(4));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(4));
1:         assertEquals("APP", met.getSchemaName(4));
1:         assertEquals("", met.getCatalogName(4));
1:         assertEquals(java.sql.Types.DOUBLE, met.getColumnType(4));
1:         assertEquals(15, met.getPrecision(4));
1:         assertEquals(0, met.getScale(4));
1:         assertEquals("DOUBLE", met.getColumnTypeName(4));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(4));
1:         assertFalse(met.isWritable(4));
1:         assertFalse(met.isDefinitelyWritable(4));
1: 
1:         // Column 5 DATE
1:         assertFalse(met.isAutoIncrement(5));
1:         assertFalse(met.isCaseSensitive(5));
1:         assertTrue(met.isSearchable(5));
1:         assertFalse(met.isCurrency(5));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(5));
1:         assertFalse(met.isSigned(5));
1:         assertEquals(10, met.getColumnDisplaySize(5));
1:         assertEquals("DT", met.getColumnLabel(5));
1:         assertEquals("DT", met.getColumnName(5));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(5));
1:         assertEquals("APP", met.getSchemaName(5));
1:         assertEquals("", met.getCatalogName(5));
1:         assertEquals(java.sql.Types.DATE, met.getColumnType(5));
1:         assertEquals(10, met.getPrecision(5));
1:         assertEquals(0, met.getScale(5));
1:         assertEquals("DATE", met.getColumnTypeName(5));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(1));
1:         assertFalse(met.isWritable(1));
1:         assertFalse(met.isDefinitelyWritable(1));
1: 
1:         // COLUMN 7 TIMESTAMP
1:         assertFalse(met.isAutoIncrement(7));
1:         assertFalse(met.isCaseSensitive(7));
1:         assertTrue(met.isSearchable(7));
1:         assertFalse(met.isCurrency(7));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(7));
1:         assertFalse(met.isSigned(7));
0:         assertEquals(26, met.getColumnDisplaySize(7));
1:         assertEquals("TS", met.getColumnLabel(7));
1:         assertEquals("TS", met.getColumnName(7));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(7));
1:         assertEquals("APP", met.getSchemaName(7));
1:         assertEquals("", met.getCatalogName(7));
1:         assertEquals(java.sql.Types.TIMESTAMP, met.getColumnType(7));
0:         assertEquals(26, met.getPrecision(7));
0:         assertEquals(6, met.getScale(7));
1:         assertEquals("TIMESTAMP", met.getColumnTypeName(7));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(7));
1:         assertFalse(met.isWritable(7));
1:         assertFalse(met.isDefinitelyWritable(7));
1: 
1:         // COLUMN 8 CHAR
1:         assertFalse(met.isAutoIncrement(8));
1:         assertTrue(met.isCaseSensitive(8));
1:         assertTrue(met.isSearchable(8));
1:         assertFalse(met.isCurrency(8));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(8));
1:         assertFalse(met.isSigned(8));
1:         assertEquals(10, met.getColumnDisplaySize(8));
1:         assertEquals("C", met.getColumnLabel(8));
1:         assertEquals("C", met.getColumnName(8));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(8));
1:         assertEquals("APP", met.getSchemaName(8));
1:         assertEquals("", met.getCatalogName(8));
1:         assertEquals(java.sql.Types.CHAR, met.getColumnType(8));
1:         assertEquals(10, met.getPrecision(8));
1:         assertEquals(0, met.getScale(8));
1:         assertEquals("CHAR", met.getColumnTypeName(8));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(8));
1:         assertFalse(met.isWritable(8));
1:         assertFalse(met.isDefinitelyWritable(8));
1: 
1:         // COLUMN 9 VARCHAR
1:         assertFalse(met.isAutoIncrement(9));
1:         assertTrue(met.isCaseSensitive(9));
1:         assertTrue(met.isSearchable(9));
1:         assertFalse(met.isCurrency(9));
1:         assertEquals(ResultSetMetaData.columnNoNulls, met.isNullable(9));
1:         assertFalse(met.isSigned(9));
1:         assertEquals(40, met.getColumnDisplaySize(9));
1:         assertEquals("V", met.getColumnLabel(9));
1:         assertEquals("V", met.getColumnName(9));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(9));
1:         assertEquals("APP", met.getSchemaName(9));
1:         assertEquals("", met.getCatalogName(9));
1:         assertEquals(java.sql.Types.VARCHAR, met.getColumnType(9));
1:         assertEquals(40, met.getPrecision(9));
1:         assertEquals(0, met.getScale(9));
1:         assertEquals("VARCHAR", met.getColumnTypeName(9));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(9));
1:         assertFalse(met.isWritable(9));
1:         assertFalse(met.isDefinitelyWritable(9));
1: 
1:         // COLUMN 10 DECIMAL
1:         assertFalse(met.isAutoIncrement(10));
1:         assertFalse(met.isCaseSensitive(10));
1:         assertTrue(met.isSearchable(10));
0:         // DERBY-2423 Embedded and client differ on isCurrency() for
0:         // DECIMAL and NUMERIC columns. Enable for embedded once the
0:         // issue is fixed
0:         if (usingDerbyNetClient())
0:             assertFalse(met.isCurrency(10));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(10));
1:         assertTrue(met.isSigned(10));
1:         assertEquals(12, met.getColumnDisplaySize(10));
1:         assertEquals("DC", met.getColumnLabel(10));
1:         assertEquals("DC", met.getColumnName(10));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(10));
1:         assertEquals("APP", met.getSchemaName(10));
1:         assertEquals("", met.getCatalogName(10));
1:         assertEquals(java.sql.Types.DECIMAL, met.getColumnType(10));
1:         assertEquals(10, met.getPrecision(10));
1:         assertEquals(2, met.getScale(10));
1:         assertEquals("DECIMAL", met.getColumnTypeName(10));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(10));
1:         assertFalse(met.isWritable(10));
1:         assertFalse(met.isDefinitelyWritable(10));
1: 
1:         // COLUMN 11 BIGINT
1:         assertFalse(met.isAutoIncrement(11));
1:         assertFalse(met.isCaseSensitive(11));
1:         assertTrue(met.isSearchable(11));
1:         assertFalse(met.isCurrency(11));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(11));
1:         assertTrue(met.isSigned(11));
1:         assertEquals(20, met.getColumnDisplaySize(11));
1:         assertEquals("BI", met.getColumnLabel(11));
1:         assertEquals("BI", met.getColumnName(11));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(11));
1:         assertEquals("APP", met.getSchemaName(11));
1:         assertEquals("", met.getCatalogName(11));
1:         assertEquals(java.sql.Types.BIGINT, met.getColumnType(11));
1:         assertEquals(19, met.getPrecision(11));
1:         assertEquals(0, met.getScale(11));
1:         assertEquals("BIGINT", met.getColumnTypeName(11));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(11));
1:         assertFalse(met.isWritable(11));
1:         assertFalse(met.isDefinitelyWritable(11));
1: 
1:         // COLUMN 12 CHAR FOR BIT DATA
1:         assertFalse(met.isAutoIncrement(12));
1:         assertFalse(met.isCaseSensitive(12));
1:         assertTrue(met.isSearchable(12));
1:         assertFalse(met.isCurrency(12));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(12));
1:         assertFalse(met.isSigned(12));
1:         assertEquals(20, met.getColumnDisplaySize(12));
1:         assertEquals("CBD", met.getColumnLabel(12));
1:         assertEquals("CBD", met.getColumnName(12));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(12));
1:         assertEquals("APP", met.getSchemaName(12));
1:         assertEquals("", met.getCatalogName(12));
1:         assertEquals(java.sql.Types.BINARY, met.getColumnType(12));
1:         assertEquals(10, met.getPrecision(12));
1:         assertEquals(0, met.getScale(12));
1:         // client and embedded differ in name, but stil a rose.
1:         if (usingEmbedded())
1:             assertEquals("CHAR () FOR BIT DATA", met.getColumnTypeName(12));
1:         else
1:             assertEquals("CHAR FOR BIT DATA", met.getColumnTypeName(12));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(12));
1:         assertFalse(met.isWritable(12));
1:         assertFalse(met.isDefinitelyWritable(12));
1: 
1:         // COLUMN 13 VARCHAR FOR BIT DATA
1:         assertFalse(met.isAutoIncrement(13));
1:         assertFalse(met.isCaseSensitive(13));
1:         assertTrue(met.isSearchable(13));
1:         assertFalse(met.isCurrency(13));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(13));
1:         assertFalse(met.isSigned(13));
1:         assertEquals(20, met.getColumnDisplaySize(13));
1:         assertEquals("VBD", met.getColumnLabel(13));
1:         assertEquals("VBD", met.getColumnName(13));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(13));
1:         assertEquals("APP", met.getSchemaName(13));
1:         assertEquals("", met.getCatalogName(13));
1:         assertEquals(java.sql.Types.VARBINARY, met.getColumnType(13));
1:         assertEquals(10, met.getPrecision(13));
1:         assertEquals(0, met.getScale(13));
1:         // client and embedded differ in name, but stil a rose.
1:         if (usingEmbedded())
1:             assertEquals("VARCHAR () FOR BIT DATA", met.getColumnTypeName(13));
1:         else
1:             assertEquals("VARCHAR FOR BIT DATA", met.getColumnTypeName(13));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(13));
1:         assertFalse(met.isWritable(13));
1:         assertFalse(met.isDefinitelyWritable(13));
1: 
1:         // COLUMN 14 LONGVARCHAR FOR BIT DATA
1:         assertFalse(met.isAutoIncrement(14));
1:         assertFalse(met.isCaseSensitive(14));
1:         assertTrue(met.isSearchable(14));
1:         assertFalse(met.isCurrency(14));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(14));
1:         assertFalse(met.isSigned(14));
1:         assertEquals(65400, met.getColumnDisplaySize(14));
1:         assertEquals("LVBD", met.getColumnLabel(14));
1:         assertEquals("LVBD", met.getColumnName(14));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(14));
1:         assertEquals("APP", met.getSchemaName(14));
1:         assertEquals("", met.getCatalogName(14));
1:         assertEquals(java.sql.Types.LONGVARBINARY, met.getColumnType(14));
1:         assertEquals(32700, met.getPrecision(14));
1:         assertEquals(0, met.getScale(14));
1:         assertEquals("LONG VARCHAR FOR BIT DATA", met.getColumnTypeName(14));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(14));
1:         assertFalse(met.isWritable(14));
1:         assertFalse(met.isDefinitelyWritable(14));
1: 
1:         // COLUMN 15 CLOB
1:         assertFalse(met.isAutoIncrement(15));
1:         assertTrue(met.isCaseSensitive(15));
1:         assertTrue(met.isSearchable(15));
1:         assertFalse(met.isCurrency(15));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(15));
1:         assertFalse(met.isSigned(15));
1:         assertEquals(2147483647, met.getColumnDisplaySize(15));
1:         assertEquals("CL", met.getColumnLabel(15));
1:         assertEquals("CL", met.getColumnName(15));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(15));
1:         assertEquals("APP", met.getSchemaName(15));
1:         assertEquals("", met.getCatalogName(15));
1:         assertEquals(java.sql.Types.CLOB, met.getColumnType(15));
1:         assertEquals(2147483647, met.getPrecision(15));
1:         assertEquals(0, met.getScale(15));
1:         assertEquals("CLOB", met.getColumnTypeName(15));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(15));
1:         assertFalse(met.isWritable(15));
1:         assertFalse(met.isDefinitelyWritable(15));
1: 
1:         // COLUMN 16 BLOB
1:         assertFalse(met.isAutoIncrement(16));
1:         assertFalse(met.isCaseSensitive(16));
1:         assertTrue(met.isSearchable(16));
1:         assertFalse(met.isCurrency(16));
1:         assertEquals(ResultSetMetaData.columnNullable, met.isNullable(16));
0:         assertFalse(met.isSigned(16));
0:         // DERBY-2425 Client returns negative value for getColumnDisplaySize()
0:         // enable for client once fixed.
1:         if (usingEmbedded())
0:             assertEquals(2147483647, met.getColumnDisplaySize(16));
1:         assertEquals("BL", met.getColumnLabel(16));
1:         assertEquals("BL", met.getColumnName(16));
1:         // beetle 5323
1:         assertEquals("T", met.getTableName(16));
1:         assertEquals("APP", met.getSchemaName(16));
1:         assertEquals("", met.getCatalogName(16));
1:         assertEquals(java.sql.Types.BLOB, met.getColumnType(16));
1:         assertEquals(1073741824, met.getPrecision(16));
1:         assertEquals(0, met.getScale(16));
1:         assertEquals("BLOB", met.getColumnTypeName(16));
1:         // DERBY-142 client incorrectly returns true. Enable on client
1:         // once DERBY-142 is fixed
1:         if (usingEmbedded())
1:             assertFalse(met.isReadOnly(16));
1:         assertFalse(met.isWritable(16));
1:         assertFalse(met.isDefinitelyWritable(16));
1:     }
1: 
1:     /**
0:      * Test fix for Bug4810 -Connection.commit() & rollback() do not
1:      * commit/rollback in auto-commit mode.
1:      */
1:     public void testBug4810() throws SQLException {
1:         Connection con = getConnection();
1: 
0:         CallableStatement cs = con
0:                 .prepareCall("CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
0:         cs.setString(1, "derby.locks.deadlockTimeout");
0:         cs.setString(2, "3");
0:         cs.execute();
0:         cs.setString(1, "derby.locks.waitTimeout");
0:         cs.setString(2, "3");
0:         cs.close();
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("create table bug4810(i int, b int)");
1:         stmt
1:                 .executeUpdate("insert into bug4810 values (1,1), (1,2), (1,3), (1,4)");
1:         stmt
1:                 .executeUpdate("insert into bug4810 values (1,1), (1,2), (1,3), (1,4)");
1:         con.commit();
1:         con.setAutoCommit(true);
1:         con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:         // Just autocommit
1:         checkLocksForAutoCommitSelect(con, stmt, 0);
1:         // commit with autocommit
1:         checkLocksForAutoCommitSelect(con, stmt, 1);
1:         // rollback with autocommit
1:         checkLocksForAutoCommitSelect(con, stmt, 2);
1: 
1:         stmt.execute("drop table bug4810");
1:         con.commit();
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Setup up and run the auto-commit tests.
1:      * 
1:      * @param conn
1:      *            The Connection
1:      * @throws SQLException
1:      */
1:     public void testAutoCommit() throws SQLException {
1:         Connection conn = getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("create table AutoCommitTable (num int)");
1: 
1:         s.executeUpdate("insert into AutoCommitTable values (1)");
1:         s.executeUpdate("insert into AutoCommitTable values (2)");
1:         int isolation = conn.getTransactionIsolation();
1:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:         checkSingleRSAutoCommit(conn);
1:         checkSingleRSCloseCursorsAtCommit(conn);
1:         conn.setTransactionIsolation(isolation);
1:         s.executeUpdate("drop table AutoCommitTable");
1:         s.close();
1:     }
1: 
1:     // JIRA-1136: LossOfPrecisionConversionException fetching Float.MAX_VALUE.
1:     // This test proves that we can successfully fetch that value from the DB
1: 
1:     public void testCorrelationNamesAndMetaDataCalls() throws SQLException {
1:         Connection conn = getConnection();
1:         Statement stmt = conn.createStatement();
1:         stmt
1:                 .executeUpdate("create table s (a int, b int, c int, d int, e int, f int)");
1:         stmt.executeUpdate("insert into s values (0,1,2,3,4,5)");
1:         stmt.executeUpdate("insert into s values (10,11,12,13,14,15)");
1:         // System.out.println("Run select * from s ss (f, e, d, c, b, a) where f
1:         // = 0 and then try getTableName and getSchemaName on columns");
1:         ResultSet rs = stmt
1:                 .executeQuery("select * from s ss (f, e, d, c, b, a) where f = 0");
1:         rs.next();
1:         ResultSetMetaData met = rs.getMetaData();
1:         assertEquals("S", met.getTableName(1));
1:         assertEquals("APP", met.getSchemaName(1));
1:         // System.out.println("Run select * from (select * from s) a and then
1:         // try getTableName and getSchemaName on columns");
1:         rs = stmt.executeQuery("select * from (select * from s) a");
1:         rs.next();
1:         met = rs.getMetaData();
1:         assertEquals("S", met.getTableName(1));
1:         assertEquals("APP", met.getSchemaName(1));
1:         stmt.executeUpdate("create schema s1");
1:         stmt.executeUpdate("create table s1.t1 (c11 int, c12 int)");
1:         stmt.executeUpdate("insert into s1.t1 values (11, 12), (21, 22)");
1:         // System.out.println("Run select * from s1.t1 as abc and then try
1:         // getTableName and getSchemaName on columns");
1:         rs = stmt.executeQuery("select * from s1.t1 as abc");
1:         met = rs.getMetaData();
1:         assertEquals("T1", met.getTableName(1));
1:         assertEquals("S1", met.getSchemaName(1));
1:         assertEquals("T1", met.getTableName(2));
1:         assertEquals("S1", met.getSchemaName(2));
1: 
1:         // System.out.println("Run select abc.c11 from s1.t1 as abc and then try
1:         // getTableName and getSchemaName on columns");
1:         rs = stmt.executeQuery("select abc.c11 from s1.t1 as abc");
1:         met = rs.getMetaData();
1:         assertEquals("T1", met.getTableName(1));
1:         assertEquals("S1", met.getSchemaName(1));
1:         // System.out.println("Run select bcd.a, abc.c11 from s1.t1 as abc, s as
1:         // bcd and then try getTableName and getSchemaName on columns");
1:         rs = stmt
1:                 .executeQuery("select bcd.a, abc.c11 from s1.t1 as abc, s as bcd");
1:         met = rs.getMetaData();
1:         assertEquals("S", met.getTableName(1));
1:         assertEquals("APP", met.getSchemaName(1));
1:         assertEquals("T1", met.getTableName(2));
1:         assertEquals("S1", met.getSchemaName(2));
1: 
1:         stmt.executeUpdate("create schema app1");
1:         stmt.executeUpdate("create table app1.t1 (c11 int, c12 int)");
1:         stmt.executeUpdate("insert into app1.t1 values (11, 12), (21, 22)");
1:         stmt.executeUpdate("create schema app2");
1:         stmt.executeUpdate("create table app2.t1 (c11 int, c12 int)");
1:         stmt.executeUpdate("insert into app2.t1 values (11, 12), (21, 22)");
1:         // System.out.println("Run select app1.t1.c11, app2.t1.c11 from app1.t1,
1:         // app2.t1 and then try getTableName and getSchemaName on columns");
1:         rs = stmt
1:                 .executeQuery("select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1");
1:         met = rs.getMetaData();
1:         assertEquals("T1", met.getTableName(1));
1:         assertEquals("APP1", met.getSchemaName(1));
1:         assertEquals("T1", met.getTableName(2));
1:         assertEquals("APP2", met.getSchemaName(2));
1: 
1:         stmt.execute("drop table s");
1:         stmt.execute("drop table s1.t1");
1:         stmt.execute("drop schema s1 restrict");
1:         stmt.execute("drop table app1.t1");
1:         stmt.execute("drop table app2.t1");
1:         stmt.execute("drop schema app2 restrict");
1:         stmt.execute("drop schema app1 restrict");
1:     }
1: 
1:     public void testFloatMAX_VALUE(Connection conn) throws SQLException {
1:         Statement stmt = createStatement();
1:         try {
1:             stmt.execute("drop table jira1136");
1:         } catch (Throwable t) {
1:         }
1:         stmt.execute("create table jira1136 (f float)");
1:         stmt.execute("insert into jira1136 values (3.4028235E38)");
1:         PreparedStatement ps = conn.prepareStatement("select * from jira1136");
1:         ResultSet rs = ps.executeQuery();
1:         while (rs.next()) {
1:             assertEquals(3.4028235E38, rs.getFloat(1), .00001);
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Tests for two things:
1:      * 
1:      * 1) The ResultSet does not close implicitly when the ResultSet completes
1:      * and holdability == HOLD_CURSORS_OVER_COMMIT
1:      * 
1:      * 2) The ResultSet auto-commits when it completes and auto-commit is on.
1:      * 
1:      * @param conn
1:      *            The Connection
1:      * @throws SQLException
1:      */
1:     private void checkSingleRSAutoCommit(Connection conn) throws SQLException {
1:         conn.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:         // Single RS auto-commit test:
1:         Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY);
1: 
1:         ResultSet rs = s.executeQuery("select * from AutoCommitTable");
1:         // drain results but don't close
1:         while (rs.next())
1:             ;
1:         // test that resultset was not implicitly closed but autoCommit occured.
1:         assertFalse("Fail Auto-commit unsuccessful", locksHeld());
1: 
1:         assertFalse("Final call of rs.next() should return false", rs.next());
1:         rs.close();
1:         // check that next() on closed ResultSet throws an exception
1:         try {
1:             rs.next();
1:             fail("FAIL Error should have occured with rs.next() on a closed ResultSet");
1:         } catch (SQLException se) {
1:             assertEquals("XCL16", se.getSQLState());
1:         }
1:     }
1: 
1:     /**
1:      * Check to see that ResultSet closes implicitly when holdability is set to
1:      * CLOSE_CURORS_AT_COMMIT.
1:      * 
1:      * @param conn
1:      *            The Connection
1:      * @throws SQLException
1:      */
1:     private void checkSingleRSCloseCursorsAtCommit(Connection conn)
1:             throws SQLException {
1:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:         Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = s.executeQuery("select * from AutoCommitTable");
1:         // drain but do not close resultset.
1:         while (rs.next())
1:             ;
1:         assertFalse("Fail Auto-commit unsuccessful", locksHeld());
1:         try {
1:             rs.next();
1:             fail("FAIL. ResultSet not closed implicitly");
1:         } catch (SQLException e) {
1:             assertEquals("XCL16", e.getSQLState());
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Check locks with various commit sequences.
1:      * 
1:      * @param conn
1:      *            Initialized connection
1:      * @param stmt
1:      *            stmt to use for select from table
1:      * @param action
1:      *            0 = autocommit only 1 = commit with ResultSet open 2 =
1:      *            rollback with ResultSet open
1:      * @throws SQLException
1:      */
1:     private void checkLocksForAutoCommitSelect(Connection conn, Statement stmt,
1:             int action) throws SQLException {
1: 
1:         ResultSet rs = stmt.executeQuery("select i,b from bug4810");
1:         rs.next();
1:         assertEquals(1, rs.getInt(1));
1:         assertEquals(1, rs.getInt(2));
1:         rs.next();
1:         assertEquals(1, rs.getInt(1));
1:         assertEquals(2, rs.getInt(2));
1: 
1:         if (action == 1) {
1:             conn.commit();
1:             assertFalse("Should not hold locks after commit", locksHeld());
1:         } else if (action == 2) {
1:             conn.rollback();
1:             assertFalse("Should not hold locks after rollback", locksHeld());
1:         } else if (action == 0) {
1:             // autocommit only
1:             assertTrue("Locks should be held with autocommit only", locksHeld());
1: 
1:             try {
1: 
1:                 rs.next();
1:                 assertEquals(1, rs.getInt(1));
1:                 assertEquals(3, rs.getInt(2));
1: 
1:             } catch (SQLException sqle) {
1:                 fail("Unexpected exception" + sqle.getSQLState() + ":" + sqle.getMessage());
1:             }
1: 
1:         }
1:         rs.close();
1:     }
1: 
1:     /**
1:      * 
0:      * @param numLocks
0:      *            Number of locks expeced. 0 for none
0:      * @throws Exception
1:      */
1:     private boolean locksHeld() throws SQLException {
1: 
0:         boolean hasLocks = false;
1:         Connection con2 = openDefaultConnection();
0:         PreparedStatement ps2 = con2
0:                 .prepareStatement("select XID, count(*) from SYSCS_DIAG.LOCK_TABLE as L group by XID");
0:         ResultSet rs2 = ps2.executeQuery();
1: 
0:         while (rs2.next()) {
0:             if (rs2.getInt(2) > 0) {
0:                 hasLocks = true;
0:             } else {
0:                 // 0 locks held
0:                 hasLocks = false;
1:             }
1:         }
1: 
1:         rs2.close();
0:         ps2.close();
1:         con2.close();
1:         return hasLocks;
1:     }
1: 
1:     /**
1:      * Runs the test fixtures in embedded and client.
1:      * 
1:      * @return test suite
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("ResultSetTest2");
1: 
1:         suite.addTest(baseSuite("ResultSetTest2:embedded"));
1: 
1:         suite.addTest(TestConfiguration
1:                 .clientServerDecorator(baseSuite("ResultSetTest2:client")));
1:         return suite;
1:     }
1: 
1:     public static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(ResultSetMiscTest.class);
1: 
0:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the table used in the test cases.
1:              * 
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1: 
1:                 s
1:                         .execute("create table t (i int, s smallint, r real, "
1:                                 + "d double precision, dt date, t time, ts timestamp, "
1:                                 + "c char(10), v varchar(40) not null, dc dec(10,2),"
1:                                 + "bi bigint, cbd char(10) for bit data,"
1:                                 + "vbd varchar(10) for bit data,lvbd long varchar for bit data,"
1:                                 + "cl clob(2G), bl blob(1G) )");
1:                 s
1:                         .execute("insert into t values(1,2,3.3,4.4,date('1990-05-05'),"
1:                                 + "time('12:06:06'),timestamp('1990-07-07 07:07:07.000007'),"
1:                                 + "'eight','nine', 10.1, 11,"
1:                                 + Utilities.stringToHexLiteral("twelv")
1:                                 + ","
1:                                 + Utilities.stringToHexLiteral("3teen")
1:                                 + ","
1:                                 + Utilities.stringToHexLiteral("4teen")
1:                                 + ", null, null)");
1: 
1:             }
1:         };
1:     }
1: 
1: }
============================================================================