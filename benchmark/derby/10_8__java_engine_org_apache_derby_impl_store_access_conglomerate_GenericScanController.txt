1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.conglomerate.GenericScanController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
8:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.conglomerate;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1:eac0369: 
2:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.ScanInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:00d19b5: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: /**
1:eac0369: Generic class implementing shared ScanController methods.
1:395bf04: 
1:eac0369: Logically a scancontroller is used to scan a set of rows that meet some 
1:eac0369: specified qualification.  Rows that meet the qualification may be operated
1:eac0369: upon by the scan to fetch, delete, or replace.  The ScanController also
1:eac0369: supports the notion or "repositioning" the scan, which simply resets the
1:eac0369: beginning of the scan to a new place, and allows the user to continue from
1:eac0369: there.
1:eac0369: 
1:eac0369: This class attempts to abstract out some of the parts of the scan such that
1:eac0369: maybe multiple access methods can share code, even if they perform parts of
1:eac0369: the scan wildly differently.  Here is how the scan has been broken apart:
1:eac0369: 
1:eac0369: scan_position - this variable holds the current scan position, it may be 
1:eac0369:                 extended
1:eac0369:                 to provide more information if necessary.
1:eac0369: 
1:1e762f5: scan_state    - a scan has 5 possible states:
1:1e762f5:                 SCAN_INIT, SCAN_INPROGRESS, SCAN_DONE, SCAN_HOLD_INIT, and
1:1e762f5:                 SCAN_HOLD_INPROGRESS
1:eac0369: 
1:eac0369: positionAtInitScan()
1:eac0369:               - This routine is called to move the scan to the SCAN_INIT state.
1:eac0369:                 It is used both for initialization of the ScanController and
1:eac0369:                 by reopenScan().
1:eac0369: 
1:eac0369: positionAtStartForForwardScan()
1:eac0369:               - This routine is called to move the scan from SCAN_INIT to 
1:eac0369:                 SCAN_INPROGRESS.  Upon return from this routine it is expected
1:eac0369:                 that scan_position is set such that calling the generic 
1:eac0369:                 scan loop will reach the first row of the scan.  Note that this
1:eac0369:                 usually means setting the scan_postion to one before the 1st 
1:eac0369:                 row to be returned.
1:eac0369: 
1:eac0369: fetchRows()   - This routine is the meat of the scan, it moves the scan to the
1:eac0369:                 next row, applies necessary qualifiers, and handles group or
1:eac0369:                 non-group operations.  It moves through rows on a page in
1:eac0369:                 order and then moves to the "next" page.
1:eac0369: 
1:eac0369: positionAtNextPage()
1:eac0369:               - This routine handles moving the scan from the current 
1:eac0369:                 scan_position to the next page.
1:eac0369: 
1:eac0369: positionAtDoneScan()
1:eac0369:               - Handle all cleanup associated with moving the scan state from
1:eac0369:                 SCAN_INPROGRESS to SCAN_DONE.  This may include releasing locks,
1:eac0369:                 and setting the state of the scan.  This does not close the 
1:eac0369:                 scan, it allows for a reopenScan() to be called.
1:395bf04: **/
1:eac0369: 
1:eac0369: public abstract class GenericScanController 
1:eac0369:     extends GenericController implements ScanManager
10:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constants of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /*
1:eac0369:      * There are 5 states a scan can be in.
1:eac0369:      *     SCAN_INIT - A scan has started but no positioning has been done.
1:eac0369:      *                 The scan will be positioned when the first next() call
1:eac0369:      *                 has been made.  None of the positioning state variables
1:eac0369:      *                 are valid in this state.
1:eac0369:      *     SCAN_INPROGRESS -
1:eac0369:      *                 A scan is in this state after the first next() call.
1:eac0369:      *                 On exit from any GenericScanController method, while in 
1:eac0369:      *                 this state,
1:eac0369:      *                 the scan "points" at a row which qualifies for the 
1:eac0369:      *                 scan.  While not maintaining latches on a page the 
1:eac0369:      *                 current position of the scan is either kept by record
1:eac0369:      *                 handle or key.  To tell which use the following:
1:eac0369:      *                 if (record key == null)
1:eac0369:      *                    record handle has current position
1:eac0369:      *                 else
1:eac0369:      *                    record key has current position
2:eac0369:      *
1:eac0369:      *     SCAN_DONE - Once the end of the table or the stop condition is met
1:eac0369:      *                 then the scan is placed in this state.  Only valid 
1:eac0369:      *                 ScanController method at this point is close().
1:eac0369:      *
1:eac0369:      *     SCAN_HOLD_INIT -
1:eac0369:      *                 The scan has been opened and held open across a commit,
1:eac0369:      *                 at the last commit the state was SCAN_INIT.
1:eac0369:      *                 The scan has never progressed from the SCAN_INIT state
1:eac0369:      *                 during a transaction.  When a next is done the state
1:eac0369:      *                 will either progress to SCAN_INPROGRESS or SCAN_DONE.
1:eac0369:      *
1:eac0369:      *     SCAN_HOLD_INPROGRESS -
1:eac0369:      *                 The scan has been opened and held open across a commit,
1:eac0369:      *                 at the last commit the state was in SCAN_INPROGRESS.
1:eac0369:      *                 The transaction which opened the scan has committed,
1:eac0369:      *                 but the scan was opened with the "hold" option true.
1:eac0369:      *                 At commit the locks were released and the "current"
1:eac0369:      *                 position is remembered.  In this state only two calls
1:eac0369:      *                 are valid, either next() or close().  When next() is
1:eac0369:      *                 called the scan is reopened, the underlying container
1:eac0369:      *                 is opened thus associating all new locks with the current
1:eac0369:      *                 transaction, and the scan continues at the "next" row.
1:eac0369:      */
1:eac0369:     public static final int    SCAN_INIT             = 1;
1:eac0369:     public static final int    SCAN_INPROGRESS       = 2;
1:eac0369:     public static final int    SCAN_DONE             = 3;
1:eac0369:     public static final int    SCAN_HOLD_INIT        = 4;
1:eac0369:     public static final int    SCAN_HOLD_INPROGRESS  = 5;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The following group of fields are all basic input parameters which are
1:eac0369:      * provided by the calling code when doing a scan.
1:eac0369:      * These are just saved values from what was initially input.
7:eac0369:      **/
1:395bf04:     private FormatableBitSet                 init_scanColumnList;
1:eac0369:     private DataValueDescriptor[]   init_startKeyValue;
1:eac0369:     private int                     init_startSearchOperator;
1:eac0369:     private Qualifier[][]           init_qualifier;
1:eac0369:     private DataValueDescriptor[]   init_stopKeyValue;
1:eac0369:     private int                     init_stopSearchOperator;
1:eac0369: 
1:eac0369:     private FetchDescriptor init_fetchDesc;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Delay positioning the table at the start position until the first
1:eac0369:      * next() call.
1:eac0369:      */
1:eac0369:     private int         scan_state;
1:eac0369: 
1:eac0369:          
1:eac0369:     /**
1:d376440:      * If this flag is set to true, a RowLocation returned from this controller
1:d376440:      * may have been reused for another row.
1:eac0369:      */
1:d376440:     protected boolean rowLocationsInvalidated = false;
1:eac0369:     
1:eac0369:     /**
1:d376440:      * This is the sequence number for when a record id can be
1:d376440:      * reused. If it has been changed in the container, a RowLocation
1:d376440:      * may be reused for another row.
1:d376440:      */
1:d376440:     private long reusableRecordIdSequenceNumber = 0;
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * The position for the current scan.  The can be maintained in any
1:eac0369:      * of the following ways:
1:eac0369:      *     record handle - scan_position.current_rh:
1:eac0369:      *         The scan maintains it's position using the record handle while
1:eac0369:      *         it does not have a latch on the page, which is the case anytime
1:eac0369:      *         control leaves access.  The access method must take appropriate
1:eac0369:      *         steps to make sure the record handle will still be valid when
1:eac0369:      *         the scan needs to reposition using the record handle.
1:eac0369:      *     slot number   - scan_position.current_slot:
1:eac0369:      *         While the scan has a latch on the page the scan is positioned
1:eac0369:      *         using the slot number as the order of the rows cannot change
1:eac0369:      *         while the latch is held (unless the holder of the latch causes
1:eac0369:      *         them to move).  
1:eac0369:      *     page number   - (RESOLVE - TODO)
1:eac0369:      *         Sometimes it would be interesting to position a scan "between"
1:eac0369:      *         pages, such that the next time the scan starts is starts at
1:eac0369:      *         the next page.  This would allow us to efficiently do group
1:eac0369:      *         scans returning page at atime results.  
1:eac0369:      *         NOT IMPLEMENTED CURRENTLY.
1:eac0369:      **/
1:eac0369:     protected RowPosition         scan_position;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Performance counters ...
1:eac0369:      */
1:eac0369:     protected int stat_numpages_visited         = 0;
1:eac0369:     protected int stat_numrows_visited          = 0;
1:eac0369:     protected int stat_numrows_qualified        = 0;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     private final void repositionScanForUpateOper()
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         if (scan_state != SCAN_INPROGRESS)
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_SCAN_NOT_POSITIONED);
1:bbc927c: 
1:bbc927c: 
1:eac0369:         if (!open_conglom.latchPage(scan_position))
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_RECORD_NOT_FOUND, 
1:eac0369:                     open_conglom.getContainer().getId(),
1:ce40a31:                     scan_position.current_rh.getPageNumber(),
1:ce40a31:                     scan_position.current_rh.getId());
8:eac0369:         }
1:395bf04: 
1:eac0369:         if (open_conglom.isUseUpdateLocks())
1:eac0369:         {
1:eac0369:             // we only have an U lock at this point which was acquired when the
1:eac0369:             // scan positioned on the row, need to request an
1:eac0369:             // X lock before we can actually perform the delete
1:eac0369: 
1:20cc6f6:             open_conglom.lockPositionForWrite(scan_position, true);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected methods implementing mechanics of scanning rows:
1:eac0369:      *
1:eac0369:      *     positionAtInitScan()             - move scan state to SCAN_INIT
1:eac0369:      *     positionAtStartForForwardScan()  - SCAN_INIT -> SCAN_INPROGRESS
1:eac0369:      *     positionAtResumeScan()           - reposition after losing scan latch
1:eac0369:      *     fetchRows()                      - move scan while in SCAN_INPROGRESS
1:eac0369:      *     positionAtNextPage()             - move page while in SCAN_INPROGRESS
1:eac0369:      *     positionAtDoneScan()             - SCAN_INPROGRESS -> SCAN_DONE
1:eac0369:      *
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:395bf04:     /**
1:eac0369:      * Move scan to the the SCAN_INIT state.
1:eac0369:      * <p>
1:eac0369:      * This routine is called to move the scan to the SCAN_INIT state.
1:eac0369:      * It is used both for initialization of the ScanController and
1:eac0369:      * by reopenScan().
1:eac0369:      **/
1:395bf04:     protected void positionAtInitScan(
1:eac0369:     DataValueDescriptor[]   startKeyValue,
1:eac0369:     int                     startSearchOperator,
1:eac0369:     Qualifier               qualifier[][],
1:eac0369:     DataValueDescriptor[]   stopKeyValue,
1:eac0369:     int                     stopSearchOperator,
1:eac0369:     RowPosition             pos)
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         // startKeyValue init.
1:395bf04:         this.init_startKeyValue         = startKeyValue;
1:395bf04:         if (RowUtil.isRowEmpty(this.init_startKeyValue))
1:395bf04:             this.init_startKeyValue = null;
1:eac0369: 
1:eac0369:         // startSearchOperator init.
1:395bf04:         this.init_startSearchOperator   = startSearchOperator;
1:eac0369: 
1:eac0369:         // qualifier init.
1:eac0369:         if ((qualifier != null) && (qualifier .length == 0))
1:eac0369:             qualifier = null;
1:eac0369:         this.init_qualifier             = qualifier;
1:eac0369: 
1:eac0369:         // TODO (mikem) - this could be more efficient, by writing
1:eac0369:         // code to figure out length of row, but scratch row is cached
1:eac0369:         // so allocating it here is probably not that bad.
1:eac0369:         init_fetchDesc = 
1:eac0369:             new FetchDescriptor(
1:722a889:               (open_conglom.getRuntimeMem().get_scratch_row(
1:722a889:                     open_conglom.getRawTran())).length,
1:eac0369:               init_scanColumnList,
1:eac0369:               init_qualifier);
1:eac0369: 
1:eac0369:         // stopKeyValue init.
1:395bf04:         this.init_stopKeyValue          = stopKeyValue;
1:00d8393:         if (RowUtil.isRowEmpty(this.init_stopKeyValue))
1:eac0369:             this.init_stopKeyValue = null;
1:eac0369: 
1:eac0369:         // stopSearchOperator init.
1:395bf04:         this.init_stopSearchOperator    = stopSearchOperator;
1:eac0369: 
1:eac0369:         // reset the "current" position to starting condition.
1:eac0369:         pos.init();
1:eac0369: 
1:eac0369: 
1:eac0369:         // Verify that all columns in start key value, stop key value, and
1:eac0369:         // qualifiers are present in the list of columns described by the
1:eac0369:         // scanColumnList.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (init_scanColumnList != null)
1:eac0369:             {
1:eac0369:                 // verify that all columns specified in qualifiers, start
1:eac0369:                 // and stop positions are specified in the scanColumnList.  
1:eac0369:                 
1:eac0369:                 FormatableBitSet required_cols;
1:eac0369: 
1:eac0369:                 if (qualifier != null)
1:eac0369:                     required_cols = RowUtil.getQualifierBitSet(qualifier);
1:eac0369:                 else
1:eac0369:                     required_cols = new FormatableBitSet(0);
1:eac0369: 
1:eac0369:                 // add in start columns
1:eac0369:                 if (this.init_startKeyValue != null)
1:eac0369:                 {
1:395bf04:                     required_cols.grow(this.init_startKeyValue.length);
1:eac0369:                     for (int i = 0; i < this.init_startKeyValue.length; i++)
1:eac0369:                         required_cols.set(i);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 if (this.init_stopKeyValue != null)
1:eac0369:                 {
1:395bf04:                     required_cols.grow(this.init_stopKeyValue.length);
1:eac0369:                     for (int i = 0; i < this.init_stopKeyValue.length; i++)
1:eac0369:                         required_cols.set(i);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 FormatableBitSet required_cols_and_scan_list = 
1:eac0369:                     (FormatableBitSet) required_cols.clone();
1:eac0369: 
1:eac0369:                 required_cols_and_scan_list.and(init_scanColumnList);
1:eac0369: 
1:395bf04:                 // FormatableBitSet equals requires the two FormatableBitSets to be of same
1:395bf04:                 // length.
1:395bf04:                 required_cols.grow(init_scanColumnList.size());
1:eac0369: 
1:eac0369:                 if (!required_cols_and_scan_list.equals(required_cols))
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "Some column specified in a Btree " +
1:eac0369:                         " qualifier/start/stop list is " +
1:eac0369:                         "not represented in the scanColumnList." +
1:eac0369:                         "\n:required_cols_and_scan_list = " + 
1:eac0369:                             required_cols_and_scan_list + 
1:eac0369:                         "\n;required_cols = " + required_cols +
1:eac0369:                         "\n;init_scanColumnList = " + init_scanColumnList);
1:395bf04:                 }
1:eac0369:             }
1:eac0369:         } 
1:eac0369: 
1:eac0369:         // Scan is fully initialized and ready to go.
1:eac0369:         scan_state = SCAN_INIT;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Reposition the scan upon entering the fetchRows loop.
1:eac0369:      * <p>
1:eac0369:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
1:eac0369:      * Do work necessary to look at rows in the current page of the scan.
1:eac0369:      * <p>
1:eac0369:      * The default implementation uses a record handle to maintain a scan
1:eac0369:      * position.  It will get the latch again on the current
1:eac0369:      * scan position and set the slot to the current record handle.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected void positionAtResumeScan(
1:eac0369:     RowPosition pos)
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 scan_position.current_rh != null, this.toString()); 
1:eac0369:         }
1:eac0369: 
1:eac0369:         // reposition the scan at the row just before the next one to return.
1:eac0369:         // This routine handles the mess of repositioning if the row or the
1:eac0369:         // page has disappeared. This can happen if a lock was not held on the
1:eac0369:         // row while not holding the latch.
1:eac0369:         open_conglom.latchPageAndRepositionScan(scan_position);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
1:eac0369:      * <p>
1:eac0369:      * This routine is called to move the scan from SCAN_INIT to 
1:eac0369:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
1:eac0369:      * that scan_position is set such that calling the generic 
1:eac0369:      * scan loop will reach the first row of the scan.  Note that this
1:eac0369:      * usually means setting the scan_postion to one before the 1st 
1:eac0369:      * row to be returned.
1:eac0369:      * <p>
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected void positionAtStartForForwardScan(
1:eac0369:     RowPosition pos)
11:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (pos.current_rh == null)
1:eac0369:         {
1:eac0369:             // 1st positioning of scan (delayed from openScan).
1:eac0369:             pos.current_page = 
1:eac0369:                 open_conglom.getContainer().getFirstPage();
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     pos.current_page.getPageNumber() == 
1:eac0369:                     ContainerHandle.FIRST_PAGE_NUMBER);
1:eac0369: 
1:eac0369:                 if (pos.current_page.recordCount() < 1)
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "record count = " + pos.current_page.recordCount());
1:eac0369:             }
1:eac0369: 
1:eac0369:             // set up for scan to continue at beginning of first page just
1:eac0369:             // after first first control row on first page.
1:eac0369:             pos.current_slot = Page.FIRST_SLOT_NUMBER;
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // 1st positioning of scan following a reopenScanByRowLocation
1:eac0369: 
1:eac0369:             // reposition the scan at the row just before the next one to 
1:eac0369:             // return.  This routine handles the mess of repositioning if the 
1:eac0369:             // row or the page has disappeared. This can happen if a lock was 
1:eac0369:             // not held on the row while not holding the latch.
1:eac0369:             open_conglom.latchPageAndRepositionScan(pos);
1:eac0369: 
1:eac0369:             // set up for scan to at the specified record handle (position one
1:eac0369:             // before it so that the loop increment and find it).
1:eac0369:             pos.current_slot -= 1;
1:eac0369:         }
1:eac0369: 
1:eac0369:         pos.current_rh    = null;
1:eac0369:         this.stat_numpages_visited  = 1;
1:eac0369:         this.scan_state             = SCAN_INPROGRESS;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Position scan to slot before first slot on next page.
1:eac0369:      * <p>
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected void positionAtNextPage(
1:eac0369:     RowPosition pos)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // The current_page can become null, in a rare multi-user case, where
1:eac0369:         // all pages in the heap are deallocated, in the middle of the scan
1:eac0369:         // loop, when no latches are held, and the scan is waiting on a lock.
1:eac0369:         // In this case the lockPositionForRead code, has nowhere good to 
1:eac0369:         // position the scan, so it just sets the page to null and returns.
1:eac0369:         if (pos.current_page != null)
1:eac0369:         {
1:eac0369:             // save current page number.
1:eac0369:             long pageid = pos.current_page.getPageNumber();
1:eac0369: 
1:eac0369:             // unlatch old page.
1:eac0369:             pos.unlatch();
1:eac0369: 
1:eac0369:             // latch page after current page number.
1:eac0369:             pos.current_page = 
1:eac0369:                 open_conglom.getContainer().getNextPage(pageid);
1:eac0369: 
1:eac0369:             // set up for scan to continue at beginning of this new page.
1:eac0369:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Do any necessary work to complete the scan.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected void positionAtDoneScan(
1:eac0369:     RowPosition pos)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // Unlatch current page if any.
1:eac0369:         pos.unlatch();
1:eac0369: 
1:eac0369:         // unlock the previous row.
1:eac0369:         if (scan_position.current_rh != null)
1:eac0369:         {
1:eac0369:             open_conglom.unlockPositionAfterRead(scan_position);
1:eac0369:             scan_position.current_rh = null;
1:eac0369:         }
1:eac0369: 
1:eac0369:         this.scan_state = SCAN_DONE;
1:eac0369:     }
1:eac0369: 
1:395bf04:     public void reopenScanByRowLocation(
1:eac0369:     RowLocation startRowLocation,
2:eac0369:     Qualifier qualifier[][])
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create object which represents the scan position.
1:eac0369:      * <p>
1:eac0369:      * Designed so that extending classes can override and allocate 
1:eac0369:      * implementation specific row position's.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected RowPosition allocateScanPosition()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return(new RowPosition());
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the next N rows from the table.
1:eac0369:      * <p>
1:eac0369:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected int fetchRows(
1:eac0369:     DataValueDescriptor[][] row_array,
1:eac0369:     RowLocation[]           rowloc_array,
1:eac0369:     BackingStoreHashtable   hash_table,
1:eac0369:     long                    max_rowcnt,
1:eac0369:     int[]                   key_column_numbers)
1:eac0369:         throws StandardException
1:395bf04:     {
1:eac0369:         int                     ret_row_count           = 0;
1:eac0369:         DataValueDescriptor[]   fetch_row               = null;
1:eac0369: 
1:eac0369:         if (max_rowcnt == -1)
1:eac0369:             max_rowcnt = Long.MAX_VALUE;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (row_array != null)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(row_array[0] != null,
1:eac0369:                     "first array slot in fetchNextGroup() must be non-null.");
1:eac0369:                 SanityManager.ASSERT(hash_table == null);
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(hash_table != null);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (this.scan_state == SCAN_INPROGRESS)
1:eac0369:         {
1:eac0369:             positionAtResumeScan(scan_position);
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_INIT)
1:eac0369:         {
1:eac0369:             positionAtStartForForwardScan(scan_position);
1:eac0369: 
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
1:eac0369:         {
1:d376440:             reopenAfterEndTransaction();
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     scan_position.current_rh != null, this.toString()); 
1:eac0369:             }
1:eac0369: 
1:eac0369:             // reposition the scan at the row just before the next one to 
1:eac0369:             // return.
1:eac0369:             // This routine handles the mess of repositioning if the row or 
1:eac0369:             // the page has disappeared. This can happen if a lock was not 
1:eac0369:             // held on the row while not holding the latch.
1:eac0369:             open_conglom.latchPageAndRepositionScan(scan_position);
1:eac0369: 
1:eac0369:             this.scan_state = SCAN_INPROGRESS;
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_HOLD_INIT)
1:eac0369:         {
1:d376440:             reopenAfterEndTransaction();
1:eac0369: 
1:eac0369:             positionAtStartForForwardScan(scan_position);
1:eac0369: 
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1:eac0369: 
1:eac0369:             return(0);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // At this point:
1:eac0369:         // scan_position.current_page is latched.  
1:eac0369:         // scan_position.current_slot is the slot on scan_position.current_page
1:eac0369:         // just before the "next" record this routine should process.
1:eac0369: 
1:eac0369:         // loop through successive pages and successive slots on those
1:eac0369:         // pages.  Stop when either the last page is reached 
1:eac0369:         // (scan_position.current_page will be null).  
1:eac0369:         // Along the way apply qualifiers to skip rows which don't qualify.
1:eac0369: 
1:395bf04:         while (scan_position.current_page != null)
1:395bf04:         {
1:395bf04:             while ((scan_position.current_slot + 1) < 
1:eac0369:                     scan_position.current_page.recordCount())
1:395bf04:             {
1:eac0369:                 // unlock the previous row.
1:eac0369:                 if (scan_position.current_rh != null)
1:eac0369:                 {
1:eac0369:                     open_conglom.unlockPositionAfterRead(scan_position);
1:eac0369: 
1:eac0369:                 }
1:eac0369:                 // Allocate a new row to read the row into.
1:eac0369:                 if (fetch_row == null)
1:eac0369:                 {
1:eac0369:                     if (hash_table == null)
1:eac0369:                     {
1:eac0369:                          // point at allocated row in array if one exists.
1:eac0369:                         if (row_array[ret_row_count] == null)
1:eac0369:                         {
1:eac0369:                             row_array[ret_row_count] = 
1:722a889:                               open_conglom.getRuntimeMem().get_row_for_export(
1:722a889:                                   open_conglom.getRawTran());
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         fetch_row = row_array[ret_row_count];
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         fetch_row = 
1:722a889:                             open_conglom.getRuntimeMem().get_row_for_export(
1:722a889:                                 open_conglom.getRawTran());
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // move scan current position forward.
1:eac0369:                 scan_position.positionAtNextSlot();
1:eac0369: 
1:eac0369:                 // Lock the row.
1:eac0369:                 boolean lock_granted_while_latch_held = 
1:eac0369:                     open_conglom.lockPositionForRead(
1:eac0369:                         scan_position, (RowPosition) null, true, true);
1:eac0369: 
1:eac0369:                 if (!lock_granted_while_latch_held)
1:eac0369:                 {
1:eac0369:                     // if lock could not be granted while holding
1:eac0369:                     // latch, then the row may either be on the same page 
1:eac0369:                     // or it may no longer exist, this implementation does not
1:eac0369:                     // handle rows which move to different pages.  
1:eac0369:                     // 
1:eac0369:                     // If the row moved on the same page then 
1:eac0369:                     // lockPositionForRead() will have automatically updated
1:eac0369:                     // the scan_postion argument to point to it, and we 
1:eac0369:                     // wil now have a latch and a lock on that row.
1:eac0369:                     //
1:eac0369:                     // If the row no longer exists then the 
1:eac0369:                     // "moveForwardIfRowDisappears" argument makes this routine
1:eac0369:                     // find the "next" row in the heap and position on it.  If
1:eac0369:                     // a valid row exists in the current page to position on,
1:eac0369:                     // then lockPositionForRead() will position on it, get
1:eac0369:                     // a lock on it, and return with a latch on the page.  
1:eac0369:                     // Otherwise the routine will return with current_slot == -1
1:eac0369:                     // and it is up to this routine to continue the scan as
1:eac0369:                     // normal at the top of the loop.
1:eac0369: 
1:eac0369:                     if (scan_position.current_page == null)
1:eac0369:                     {
1:eac0369:                         // page has been unlatched and the scan is done, there
1:eac0369:                         // are no more pages.  getNextPage() has been coded to
1:eac0369:                         // handle a null current_page.
1:eac0369: 
1:eac0369:                         break;
1:eac0369:                     }
1:eac0369:                     else if (scan_position.current_slot == -1)
1:eac0369:                     {
1:eac0369:                         // This means that lockPositionForRead() had to 
1:eac0369:                         // reposition the scan forward to a new page, because 
1:eac0369:                         // the row the scan was locking was purged, when the 
1:eac0369:                         // latch was released to wait on the lock.  In this 
1:eac0369:                         // case just jump back to the top of loop and continue 
1:eac0369:                         // scan.
1:eac0369: 
1:eac0369:                         if (SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.ASSERT(
1:eac0369:                                 scan_position.current_rh == null);
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         continue;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 this.stat_numrows_visited++;
1:eac0369: 
1:eac0369:                 // lockRowAtPosition set pos.current_rh as part of getting lock.
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(scan_position.current_rh != null);
1:eac0369: 
1:eac0369:                     // make sure current_rh and current_slot are in sync
1:eac0369:                     if (scan_position.current_slot !=
1:eac0369:                             scan_position.current_page.getSlotNumber(
1:eac0369:                                 scan_position.current_rh))
1:eac0369:                     {
1:eac0369:                         SanityManager.THROWASSERT(
1:eac0369:                             "current_slot = " + scan_position.current_slot +
1:eac0369:                             "current_rh = " + scan_position.current_rh +
1:eac0369:                             "current_rh.slot = " + 
1:eac0369:                             scan_position.current_page.getSlotNumber(
1:eac0369:                                 scan_position.current_rh));
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // fetchFromSlot returns null if row does not qualify.
1:eac0369: 
1:eac0369:                 scan_position.current_rh_qualified =
1:eac0369:                     (scan_position.current_page.fetchFromSlot(
1:eac0369:                         scan_position.current_rh, 
1:eac0369:                         scan_position.current_slot, 
1:eac0369:                         fetch_row, 
2:eac0369:                         init_fetchDesc,
1:eac0369:                         false) != null);
1:eac0369: 
1:eac0369:                 if (scan_position.current_rh_qualified)
1:eac0369:                 {
1:eac0369:                     // qualifying row.  
1:eac0369: 
1:eac0369: 
1:eac0369:                     // scan_position.current_rh is save position of scan while 
1:eac0369:                     // latch is not held.  It currently points at the 
1:eac0369:                     // scan_position.current_slot in search (while latch is 
1:eac0369:                     // held).
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         // make sure current_rh and current_slot are in sync
1:eac0369:                         SanityManager.ASSERT(
1:eac0369:                             scan_position.current_slot ==
1:eac0369:                                 scan_position.current_page.getSlotNumber(
1:eac0369:                                     scan_position.current_rh));
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     // Found qualifying row.  Done fetching rows for the group?
1:eac0369:                     ret_row_count++;
1:eac0369:                     stat_numrows_qualified++;
1:eac0369: 
1:eac0369: 
1:eac0369:                     if (hash_table == null)
1:eac0369:                     {
1:eac0369:                         if (rowloc_array != null)
1:eac0369:                         {
1:eac0369:                             // if requested return the associated row location.
1:eac0369:                             setRowLocationArray(
1:eac0369:                                 rowloc_array, ret_row_count - 1, scan_position);
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         fetch_row = null;
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:e81e52c:                         RowLocation     rowLocation =
1:e81e52c:                             hash_table.includeRowLocations() ?
1:e81e52c:                             makeRowLocation( scan_position ) : null;
1:e81e52c:                         if (
1:e81e52c:                             hash_table.putRow
1:e81e52c:                             ( false, fetch_row, rowLocation )
1:e81e52c:                             )
1:eac0369:                         {
1:eac0369:                             // The row was inserted into the hash table so we
1:eac0369:                             // need to create a new row next time through.
1:eac0369:                             fetch_row = null;
1:eac0369:                         }
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     if (max_rowcnt <= ret_row_count) 
1:eac0369:                     {
1:eac0369:                         // exit fetch row loop and return to the client.
1:eac0369:                         scan_position.unlatch();
1:eac0369: 
1:eac0369:                         if (SanityManager.DEBUG)
1:eac0369:                         {
1:eac0369:                             SanityManager.ASSERT(
1:eac0369:                                 scan_position.current_rh != null);
1:eac0369:                         }
1:eac0369: 
2:eac0369:                         return(ret_row_count);
1:395bf04:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             positionAtNextPage(scan_position);
1:eac0369: 
1:eac0369:             this.stat_numpages_visited++;
1:395bf04:         }
1:eac0369: 
1:eac0369:         // Reached last page of scan.
1:eac0369:         positionAtDoneScan(scan_position);
1:eac0369: 
1:eac0369:         // we need to decrement when we stop scan at the end of the table.
1:eac0369:         this.stat_numpages_visited--;
1:eac0369: 
1:395bf04:         return(ret_row_count);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Reposition the current scan.  This call is semantically the same as if
1:eac0369:     the current scan had been closed and a openScan() had been called instead.
1:eac0369:     The scan is reopened against the same conglomerate, and the scan
1:eac0369:     is reopened with the same "scan column list", "hold" and "forUpdate"
1:eac0369:     parameters passed in the original openScan.  
1:eac0369:     <p>
1:eac0369:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
1:eac0369:     rather they continue to accumulate.
1:eac0369:     <p>
1:eac0369:     Note that this operation is currently only supported on Heap conglomerates.
1:eac0369:     Also note that order of rows within are heap are not guaranteed, so for
1:eac0369:     instance positioning at a RowLocation in the "middle" of a heap, then
1:eac0369:     inserting more data, then continuing the scan is not guaranteed to see
1:eac0369:     the new rows - they may be put in the "beginning" of the heap.
1:eac0369: 
1:395bf04:     @param startRecordHandle  An existing RecordHandle within the conglomerate,
1:eac0369:     at which to position the start of the scan.  The scan will begin at this
1:eac0369:     location and continue forward until the end of the conglomerate.  
1:eac0369:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:eac0369:     had been deleted), will result in an exception being thrown when the 
1:eac0369:     first next operation is attempted.
1:eac0369: 
1:395bf04:     @param qualifier An array of qualifiers which, applied
1:395bf04:     to each key, restrict the rows returned by the scan.  Rows
1:395bf04:     for which any one of the qualifiers returns false are not
1:395bf04:     returned by the scan. If null, all rows are returned.
1:eac0369: 
1:395bf04:     @exception StandardException Standard exception policy.
1:395bf04:     **/
1:eac0369:     protected void reopenScanByRecordHandle(
1:8758a25:     RecordHandle    startRecordHandle,
1:8758a25:     Qualifier       qualifier[][])
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         // initialize scan position parameters at beginning of scan
1:eac0369:         this.scan_state = 
1:eac0369:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
1:eac0369: 
1:eac0369:         // position the scan at the row before the given record id, so that
1:eac0369:         // the first "next" starts on the given row.
1:eac0369:         scan_position.current_rh = startRecordHandle;
1:eac0369:     }
1:eac0369: 
1:b22462c:     protected abstract void setRowLocationArray(
1:eac0369:     RowLocation[]   rowloc_array,
1:eac0369:     int             index,
1:eac0369:     RowPosition     pos)
1:eac0369:         throws StandardException
1:b22462c:         ;
1:eac0369: 
1:e81e52c:     /** Make a RowLocation from a RowPosition */
1:e81e52c:     protected abstract RowLocation makeRowLocation( RowPosition pos )
1:e81e52c:         throws StandardException;
1:e81e52c: 
1:eac0369:     /**************************************************************************
1:eac0369:      * abstract protected Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:395bf04:     public void init(
1:eac0369:     OpenConglomerate                open_conglom,
1:395bf04:     FormatableBitSet                scanColumnList,
1:395bf04:     DataValueDescriptor[]           startKeyValue,
1:eac0369:     int                             startSearchOperator,
1:eac0369:     Qualifier                       qualifier[][],
1:395bf04:     DataValueDescriptor[]           stopKeyValue,
1:eac0369:     int                             stopSearchOperator)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         super.init(open_conglom);
1:eac0369: 
1:3f3b5e6:         scan_position = open_conglom.getRuntimeMem().get_scratch_row_position();
1:eac0369: 
1:eac0369:         // remember inputs
1:eac0369:         init_scanColumnList         = scanColumnList;
1:eac0369: 
1:eac0369:         positionAtInitScan(
1:eac0369:             startKeyValue,
1:eac0369:             startSearchOperator,
1:eac0369:             qualifier,
1:eac0369:             stopKeyValue,
1:eac0369:             stopSearchOperator,
1:eac0369:             scan_position);
1:eac0369:         
1:d376440:         reusableRecordIdSequenceNumber = 
1:3f3b5e6:             open_conglom.getContainer().getReusableRecordIdSequenceNumber();
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final int getNumPagesVisited()
1:eac0369:     {
1:eac0369:         return(stat_numpages_visited);
1:eac0369:     }
1:eac0369:     public final int getNumRowsVisited()
1:eac0369:     {
1:eac0369:         return(stat_numrows_visited);
1:eac0369:     }
1:eac0369:     public final int getNumRowsQualified()
1:eac0369:     {
1:eac0369:         return(stat_numrows_qualified);
1:eac0369:     }
1:eac0369:     public final FormatableBitSet getScanColumnList()
1:eac0369:     {
1:eac0369:         return(init_scanColumnList);
1:eac0369:     }
1:eac0369:     public final DataValueDescriptor[] getStartKeyValue()
1:eac0369:     {
1:eac0369:         return(init_startKeyValue);
1:eac0369:     }
1:eac0369:     public final int getStartSearchOperator()
1:eac0369:     {
1:eac0369:         return(init_startSearchOperator);
1:eac0369:     }
1:eac0369:     public final DataValueDescriptor[] getStopKeyValue()
1:eac0369:     {
1:eac0369:         return(init_stopKeyValue);
1:eac0369:     }
1:eac0369:     public final int getStopSearchOperator()
1:eac0369:     {
1:eac0369:         return(init_stopSearchOperator);
1:eac0369:     }
1:eac0369:     public final Qualifier[][] getQualifier()
1:eac0369:     {
1:eac0369:         return(init_qualifier);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final int getScanState()
1:eac0369:     {
1:eac0369:         return(scan_state);
1:eac0369:     }
1:eac0369:     public final void setScanState(int state)
1:eac0369:     {
1:eac0369:         scan_state = state;
1:eac0369:     }
1:eac0369:     public final RowPosition getScanPosition()
1:eac0369:     {
1:eac0369:         return(scan_position);
1:eac0369:     }
1:eac0369:     public final void setScanPosition(RowPosition   pos)
1:eac0369:     {
1:eac0369:         scan_position = pos;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing ScanController:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     private void closeScan()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         super.close();
1:eac0369: 
1:395bf04:         // If we are closed due to catching an error in the middle of init,
1:395bf04:         // xact_manager may not be set yet. 
1:395bf04:         if (open_conglom.getXactMgr() != null)
1:395bf04:             open_conglom.getXactMgr().closeMe(this);
1:eac0369: 
1:eac0369:         // help the garbage collector.
1:eac0369:         this.init_qualifier         = null;
1:eac0369:         init_scanColumnList         = null;
1:eac0369:         init_startKeyValue          = null;
1:eac0369:         init_stopKeyValue           = null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public void close()
1:eac0369:         throws StandardException
1:395bf04:     {
1:eac0369:         // Finish the scan - this may release locks if read committed and scan
1:eac0369:         // still holds some locks, and close comes before scan.next() returned
1:eac0369:         // that scan was done.
1:eac0369:         positionAtDoneScan(scan_position);
1:eac0369: 
1:eac0369:         closeScan();
1:395bf04:     }
1:eac0369: 
1:eac0369:     /**
1:d376440:      * Reopens the scan after it has been closed as part of a commit.
1:d376440:      * This method will check the reusableRecordIdSequenceNumber of the 
1:d376440:      * container, and will set the rowLocationsInvalidated flag if it has 
1:d376440:      * changed.
1:d376440:      * @return true if the conglomerate has been reopened
1:d376440:      * @exception StandardException Derby standard exception
1:d376440:      */
1:d376440:     protected final boolean reopenAfterEndTransaction() 
1:eac0369:         throws StandardException
1:eac0369:     {
1:d376440:         // Only reopen if holdable
1:d376440:         if (!open_conglom.getHold()) 
1:eac0369:         {
1:d376440:             return(false);
1:395bf04:         }
1:eac0369:         
1:d376440:         ContainerHandle container = open_conglom.reopen();
1:d376440:         switch (scan_state) {
1:d376440:         case SCAN_INPROGRESS:
1:d376440:         case SCAN_HOLD_INPROGRESS:
1:d376440:         case SCAN_DONE:
1:d376440:             if (container.getReusableRecordIdSequenceNumber() != 
1:d376440:                 reusableRecordIdSequenceNumber) 
1:eac0369:             {
1:d376440:                 rowLocationsInvalidated = true;
1:eac0369:             }
1:d376440:             break;
1:d376440:         case SCAN_INIT: 
1:d376440:         case SCAN_HOLD_INIT:
1:d376440:             reusableRecordIdSequenceNumber = 
1:d376440:                 container.getReusableRecordIdSequenceNumber();
1:d376440:             break;
1:d376440:         default:
1:d376440:             break; 
1:eac0369:         }
1:d376440:         return(true);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public boolean closeForEndTransaction(
1:eac0369:     boolean closeHeldScan)
1:eac0369:         throws StandardException
1:395bf04:     {
1:eac0369:         if ((!open_conglom.getHold()) || closeHeldScan) 
1:eac0369:         {
1:eac0369:             // close the scan as part of the commit/abort
1:eac0369: 
1:eac0369:             this.scan_state = SCAN_DONE;
1:eac0369: 
1:eac0369:             closeScan();
1:eac0369: 
1:eac0369:             return(true);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             super.close();
1:eac0369: 
1:eac0369:             // allow the scan to continue after the commit.
1:eac0369:             // locks and latches will be released as part of the commit, so
1:eac0369:             // no need to release them by hand.
1:eac0369: 
1:eac0369:             if (this.scan_state == SCAN_INPROGRESS)
1:eac0369:                 this.scan_state = SCAN_HOLD_INPROGRESS;
1:eac0369:             else if (this.scan_state == SCAN_INIT)
1:eac0369:                 this.scan_state = SCAN_HOLD_INIT;
1:eac0369: 
1:eac0369: 
1:eac0369:             return(false);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:395bf04:     @see org.apache.derby.iapi.store.access.ScanController#delete
1:395bf04:     **/
1:eac0369:     public boolean delete()
1:395bf04:         throws StandardException
1:395bf04:     {
1:eac0369:         repositionScanForUpateOper();
1:eac0369: 
1:eac0369:         boolean ret_val = true;
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - RECID - performance could be better if we did not
1:eac0369:         // have to call isDeletedAtSlot().
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - share code below with conglomerateController.
1:eac0369: 
1:eac0369:         if (scan_position.current_page.isDeletedAtSlot(
1:eac0369:                 scan_position.current_slot))
1:eac0369:         {
1:eac0369:             ret_val = false;
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // Delete the row 
1:eac0369:             scan_position.current_page.deleteAtSlot(
1:eac0369:                 scan_position.current_slot, true, (LogicalUndo) null);
1:eac0369: 
1:eac0369:             if (scan_position.current_page.nonDeletedRecordCount() == 0)
1:eac0369:             {
1:eac0369:                 queueDeletePostCommitWork(scan_position);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         scan_position.unlatch();
1:eac0369: 
1:eac0369:         return(ret_val);
1:395bf04:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * A call to allow client to indicate that current row does not qualify.
1:eac0369:      * <p>
1:eac0369:      * Indicates to the ScanController that the current row does not
1:eac0369:      * qualify for the scan.  If the isolation level of the scan allows, 
1:eac0369:      * this may result in the scan releasing the lock on this row.
1:eac0369:      * <p>
1:eac0369:      * Note that some scan implimentations may not support releasing locks on 
1:eac0369:      * non-qualifying rows, or may delay releasing the lock until sometime
1:eac0369:      * later in the scan (ie. it may be necessary to keep the lock until 
1:eac0369:      * either the scan is repositioned on the next row or page).
1:eac0369:      * <p>
1:eac0369:      * This call should only be made while the scan is positioned on a current
1:eac0369:      * valid row.
1:eac0369:      * RESOLVE (mikem-05/29/98) - Implement this when we support levels of
1:eac0369:      * concurrency less than serializable.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void didNotQualify()
1:eac0369:         throws StandardException
1:eac0369:     {
1:395bf04:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Insert all rows that qualify for the current scan into the input
1:eac0369:      * Hash table.  
1:eac0369:      * <p>
1:eac0369:      * This routine scans executes the entire scan as described in the 
1:eac0369:      * openScan call.  For every qualifying unique row value an entry is
1:eac0369:      * placed into the HashTable. For unique row values the entry in the
1:eac0369:      * Hashtable has a key value of the object stored in 
1:eac0369:      * row[key_column_number], and the value of the data is row.  For row 
1:eac0369:      * values with duplicates, the key value is also row[key_column_number], 
1:bd34a3a:      * but the value of the data is a <code>List</code> of
1:eac0369:      * rows.  The caller will have to call "instanceof" on the data value
1:eac0369:      * object if duplicates are expected, to determine if the data value
1:bd34a3a:      * of the Hashtable entry is a row or is a <code>List</code> of rows.
1:eac0369:      * <p>
1:eac0369:      * Note, that for this routine to work efficiently the caller must 
1:eac0369:      * ensure that the object in row[key_column_number] implements 
1:eac0369:      * the hashCode and equals method as appropriate for it's datatype.
1:eac0369:      * <p>
1:eac0369:      * It is expected that this call will be the first and only call made in
1:eac0369:      * an openscan.  Qualifiers and stop position of the openscan are applied
1:eac0369:      * just as in a normal scan.  This call is logically equivalent to the 
1:eac0369:      * caller performing the following:
1:eac0369:      *
1:395272b:      * <pre>
1:eac0369:      * import java.util.Hashtable;
1:eac0369:      *
1:eac0369:      * hash_table = new Hashtable();
1:eac0369:      *
1:eac0369:      * while (next())
1:eac0369:      * {
1:eac0369:      *     row = create_new_row();
1:eac0369:      *     fetch(row);
1:eac0369:      *     if ((duplicate_value = 
1:eac0369:      *         hash_table.put(row[key_column_number], row)) != null)
1:eac0369:      *     {
1:eac0369:      *         Vector row_vec;
1:eac0369:      *
1:eac0369:      *         // inserted a duplicate
1:eac0369:      *         if ((duplicate_value instanceof vector))
1:eac0369:      *         {
1:eac0369:      *             row_vec = (Vector) duplicate_value;
1:eac0369:      *         }
1:eac0369:      *         else
1:eac0369:      *         {
1:eac0369:      *             // allocate vector to hold duplicates
1:eac0369:      *             row_vec = new Vector(2);
1:eac0369:      *
1:eac0369:      *             // insert original row into vector
1:eac0369:      *             row_vec.addElement(duplicate_value);
1:eac0369:      *
1:eac0369:      *             // put the vector as the data rather than the row
1:eac0369:      *             hash_table.put(row[key_column_number], row_vec);
1:eac0369:      *         }
1:eac0369:      *         
1:eac0369:      *         // insert new row into vector
1:eac0369:      *         row_vec.addElement(row);
1:eac0369:      *     }
1:eac0369:      * }
1:395272b:      * </pre>
1:395272b:      *
1:eac0369:      * <p>
1:eac0369:      * The columns of the row will be the standard columns returned as
1:eac0369:      * part of a scan, as described by the validColumns - see openScan for
1:eac0369:      * description.
1:eac0369:      * RESOLVE - is this ok?  or should I hard code somehow the row to
1:eac0369:      *           be the first column and the row location?
1:eac0369:      * <p>
1:eac0369:      * Currently it is only possible to hash on the first column in the
1:eac0369:      * conglomerate, in the future we may change the interface to allow
1:eac0369:      * hashing either on a different column or maybe on a combination of
1:eac0369:      * columns.
1:eac0369:      * <p>
1:eac0369:      * No overflow to external storage is provided, so calling this routine
1:eac0369:      * on a 1 gigabyte conglomerate will incur at least 1 gigabyte of memory
1:eac0369:      * (probably failing with a java out of memory condition).  If this
1:eac0369:      * routine gets an out of memory condition, or if "max_rowcnt" is 
1:eac0369:      * exceeded then then the routine will give up, empty the Hashtable, 
1:eac0369:      * and return "false."
1:eac0369:      * <p>
1:eac0369:      * On exit from this routine, whether the fetchSet() succeeded or not
1:eac0369:      * the scan is complete, it is positioned just the same as if the scan
1:eac0369:      * had been drained by calling "next()" until it returns false (ie. 
1:eac0369:      * fetchNext() and next() calls will return false).  
1:eac0369:      * reopenScan() can be called to restart the scan.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * RESOLVE - until we get row counts what should we do for sizing the
1:eac0369:      *           the size, capasity, and load factor of the hash table.
1:eac0369:      *           For now it is up to the caller to create the Hashtable,
1:eac0369:      *           Access does not reset any parameters.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - I am not sure if access should be in charge of allocating
1:eac0369:      *           the new row objects.  I know that I can do this in the
1:eac0369:      *           case of btree's, but I don't think I can do this in heaps.
1:eac0369:      *           Maybe this is solved by work to be done on the sort 
1:eac0369:      *           interface.
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param max_rowcnt        The maximum number of rows to insert into the 
1:eac0369:      *                          Hash table.  Pass in -1 if there is no maximum.
1:eac0369:      * @param key_column_numbers The column numbers of the columns in the
1:eac0369:      *                          scan result row to be the key to the Hashtable.
1:eac0369:      *                          "0" is the first column in the scan result
1:eac0369:      *                          row (which may be different than the first
1:eac0369:      *                          column in the row in the table of the scan).
1:eac0369:      * @param hash_table        The java HashTable to load into.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void fetchSet(
1:eac0369:     long                    max_rowcnt,
1:eac0369:     int[]                   key_column_numbers,
1:eac0369:     BackingStoreHashtable   hash_table)
1:eac0369:         throws StandardException
1:395bf04:     {
1:eac0369:         fetchRows(
1:eac0369:             (DataValueDescriptor[][]) null,
1:eac0369:             (RowLocation[]) null,
1:eac0369:             hash_table,
1:eac0369:             max_rowcnt,
1:eac0369:             key_column_numbers);
1:eac0369: 
1:eac0369:         return;
1:395bf04:     }
1:eac0369: 
1:395bf04:     /**
1:eac0369:     Reposition the current scan.  This call is semantically the same as if
1:eac0369:     the current scan had been closed and a openScan() had been called instead.
1:eac0369:     The scan is reopened with against the same conglomerate, and the scan
1:eac0369:     is reopened with the same "hold" and "forUpdate" parameters passed in
1:eac0369:     the original openScan.  The previous template row continues to be used.
1:eac0369: 
1:395bf04:     @param startKeyValue  An indexable row which holds a 
1:395bf04:     (partial) key value which, in combination with the
1:395bf04:     startSearchOperator, defines the starting position of
1:395bf04:     the scan.  If null, the starting position of the scan
1:395bf04:     is the first row of the conglomerate.
1:395bf04:     
1:395bf04:     @param startSearchOperator an operator which defines
1:395bf04:     how the startKeyValue is to be searched for.  If 
1:8758a25:     startSearchOperator is ScanController.GE, the scan starts on
1:395bf04:     the first row which is greater than or equal to the 
1:395bf04:     startKeyValue.  If startSearchOperation is ScanController.GT,
1:395bf04:     the scan starts on the first row whose key is greater than
1:395bf04:     startKeyValue.  The startSearchOperation parameter is 
1:395bf04:     ignored if the startKeyValue parameter is null.
1:eac0369: 
1:395bf04:     @param qualifier An array of qualifiers which, applied
1:395bf04:     to each key, restrict the rows returned by the scan.  Rows
1:395bf04:     for which any one of the qualifiers returns false are not
1:395bf04:     returned by the scan. If null, all rows are returned.
1:eac0369: 
1:395bf04:     @param stopKeyValue  An indexable row which holds a 
1:395bf04:     (partial) key value which, in combination with the
1:395bf04:     stopSearchOperator, defines the ending position of
1:395bf04:     the scan.  If null, the ending position of the scan
1:395bf04:     is the last row of the conglomerate.
1:395bf04:     
1:395bf04:     @param stopSearchOperator an operator which defines
1:395bf04:     how the stopKeyValue is used to determine the scan stopping
1:395bf04:     position. If stopSearchOperation is ScanController.GE, the scan 
1:395bf04:     stops just before the first row which is greater than or
1:395bf04:     equal to the stopKeyValue.  If stopSearchOperation is
1:395bf04:     ScanController.GT, the scan stops just before the first row whose
1:395bf04:     key is greater than startKeyValue.  The stopSearchOperation
1:395bf04:     parameter is ignored if the stopKeyValue parameter is null.
1:eac0369: 
1:395bf04:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:395bf04:     public void reopenScan(
1:eac0369:     DataValueDescriptor[]   startKeyValue,
1:eac0369:     int                     startSearchOperator,
1:eac0369:     Qualifier               qualifier[][],
1:eac0369:     DataValueDescriptor[]   stopKeyValue,
1:eac0369:     int                     stopSearchOperator)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (!open_conglom.getHold())
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     !open_conglom.isClosed(), 
1:eac0369:                     "GenericScanController.reopenScan() called on a non-held closed scan.");
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // initialize scan position parameters at beginning of scan
1:eac0369:         this.scan_state = 
1:eac0369:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
1:eac0369: 
1:eac0369:         scan_position.current_rh   = null;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:395bf04:     @see org.apache.derby.iapi.store.access.ScanController#replace
1:395bf04:     **/
1:eac0369:     public boolean replace(
1:eac0369:     DataValueDescriptor[]   row, 
1:eac0369:     FormatableBitSet                 validColumns)
1:395bf04:         throws StandardException
1:395bf04:     {
1:eac0369:         repositionScanForUpateOper();
1:eac0369: 
1:00d19b5:         Page page = scan_position.current_page;
1:00d19b5:         int slot = scan_position.current_slot;
1:00d19b5: 
1:00d19b5:         if (SanityManager.DEBUG) {
1:00d19b5:             // DERBY-2197: Previously, we would try to get an exclusive row
1:00d19b5:             // lock here when the container was opened in row locking mode. In
1:00d19b5:             // most cases, the container is not opened in row locking mode. If
1:00d19b5:             // it is, and the open conglomerate uses update locks,
1:00d19b5:             // repositionScanForUpateOper() has already obtained an exclusive
1:00d19b5:             // row lock. We don't expect this method to be called unless these
1:00d19b5:             // conditions are satisfied, so now we just assert that no row
1:00d19b5:             // locking is required at this point.
1:00d19b5:             SanityManager.ASSERT(
1:00d19b5:                 ((open_conglom.getContainer().getLockingPolicy().getMode() !=
1:00d19b5:                       LockingPolicy.MODE_RECORD) ||
1:00d19b5:                           (open_conglom.isUseUpdateLocks())),
1:00d19b5:                 "Current mode of container requires row locking.");
1:00d19b5: 
1:00d19b5:             // make sure current_rh and current_slot are in sync
1:00d19b5:             SanityManager.ASSERT(
1:00d19b5:                 slot == page.getSlotNumber(scan_position.current_rh));
1:00d19b5:         }
1:00d19b5: 
1:00d19b5:         boolean ret_val;
1:00d19b5:         if (page.isDeletedAtSlot(slot)) {
1:00d19b5:             ret_val = false;
1:00d19b5:         } else {
1:00d19b5:             page.updateAtSlot(slot, row, validColumns);
1:00d19b5:             ret_val = true;
1:00d19b5:         }
1:eac0369: 
1:eac0369:         scan_position.unlatch();
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Returns true if the current position of the scan still qualifies
1:eac0369:     under the set of qualifiers passed to the openScan().  When called
1:eac0369:     this routine will reapply all qualifiers against the row currently
1:eac0369:     positioned and return true if the row still qualifies.  If the row
1:eac0369:     has been deleted or no longer passes the qualifiers then this routine
1:eac0369:     will return false.
1:eac0369:     
1:eac0369:     This case can come about if the current scan
1:eac0369:     or another scan on the same table in the same transaction 
1:eac0369:     deleted the row or changed columns referenced by the qualifier after 
1:eac0369:     the next() call which positioned the scan at this row.  
1:eac0369: 
1:eac0369:     Note that for comglomerates which don't support update, like btree's, 
1:eac0369:     there is no need to recheck the qualifiers.
1:eac0369: 
1:eac0369:     The results of a fetch() performed on a scan positioned on 
1:eac0369:     a deleted row are undefined.
1:eac0369: 
1:395bf04:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean doesCurrentPositionQualify()
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         if (scan_state != SCAN_INPROGRESS)
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_SCAN_NOT_POSITIONED);
1:eac0369: 
1:eac0369:         if (!open_conglom.latchPage(scan_position))
1:eac0369:         {
1:eac0369:             return(false);
1:eac0369:         }
1:eac0369: 
1:eac0369:         DataValueDescriptor row[] = 
1:722a889:             open_conglom.getRuntimeMem().get_scratch_row(
1:722a889:                 open_conglom.getRawTran());
1:eac0369: 
1:eac0369:         // If fetchFromSlot returns null it either means the row is deleted,
1:eac0369:         // or the qualifier evaluates to false.
1:eac0369:         
2:eac0369:         boolean ret_val = 
1:eac0369:             (scan_position.current_page.fetchFromSlot(
1:eac0369:                 scan_position.current_rh, 
1:eac0369:                 scan_position.current_slot, 
1:eac0369:                 row,
1:eac0369:                 init_fetchDesc,
1:eac0369:                 false) != null);
1:eac0369: 
1:eac0369:         scan_position.unlatch();
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:2700e3d:     Fetch the row at the current position of the Scan without applying the 
1:2700e3d:     qualifiers.
1:2700e3d:     
1:fa09146:     @see org.apache.derby.iapi.store.access.ScanController#fetchWithoutQualify
1:2700e3d:     **/
1:2700e3d:     public void fetchWithoutQualify(DataValueDescriptor[] row)
1:2700e3d:         throws StandardException
1:2700e3d:     {
1:2700e3d:         fetch(row, false);
1:2700e3d:     }
1:2700e3d: 
1:2700e3d:     /**
1:1e762f5:      * @see org.apache.derby.iapi.store.access.ScanController#isHeldAfterCommit
1:1e762f5:      */
1:1e762f5:     public boolean isHeldAfterCommit() throws StandardException
1:395bf04:     {
1:1e762f5:         return (scan_state == SCAN_HOLD_INIT ||
1:1e762f5:                 scan_state == SCAN_HOLD_INPROGRESS);
1:395bf04:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     
1:eac0369:     /**
1:2700e3d:     Fetch the row at the current position of the Scan.
1:2700e3d: 
1:fa09146:     @see org.apache.derby.iapi.store.access.ScanController#fetch
1:395bf04:     **/
1:395bf04:     public void fetch(DataValueDescriptor[] row)
1:395bf04:         throws StandardException
1:395bf04:     {
1:2700e3d:         fetch(row, true);
1:2700e3d:     }
1:2700e3d: 
1:2700e3d:     /**
1:2700e3d:     Fetch the row at the current position of the Scan.
1:2700e3d: 
1:2700e3d:     @param row The row into which the value of the current 
1:2700e3d:      position in the scan is to be stored.
1:2700e3d: 
1:2700e3d:     @param qualify Indicates whether the qualifiers should be applied.
1:2700e3d: 
1:2700e3d:     @exception StandardException Standard exception policy.
1:2700e3d:     **/
1:2700e3d:     private void fetch(DataValueDescriptor[] row, boolean qualify)
1:2700e3d:         throws StandardException
1:2700e3d:     {
1:eac0369:         if (scan_state != SCAN_INPROGRESS)
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_SCAN_NOT_POSITIONED);
1:eac0369: 
1:eac0369:         if (!open_conglom.latchPage(scan_position))
1:395bf04:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_RECORD_NOT_FOUND, 
1:eac0369:                     open_conglom.getContainer().getId(),
1:ce40a31:                     scan_position.current_rh.getPageNumber(),
1:ce40a31:                     scan_position.current_rh.getId());
1:395bf04:         }
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - should this call apply the qualifiers again?
1:eac0369:         RecordHandle rh = 
1:eac0369:             scan_position.current_page.fetchFromSlot(
1:eac0369:                 scan_position.current_rh, 
1:eac0369:                 scan_position.current_slot, 
1:eac0369:                 row, 
1:2700e3d:                 qualify ? init_fetchDesc : null, 
1:eac0369:                 false);
1:eac0369: 
1:eac0369:         scan_position.unlatch();
1:eac0369: 
1:eac0369:         if (rh == null)
1:eac0369:         {
1:eac0369:             /*
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 if (isCurrentPositionDeleted())
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "The record (" + 
1:eac0369:                         open_conglom.getContainer().getId() +
1:eac0369:                         ", " +
1:eac0369:                         scan_position.current_rh.getPageNumber() + ", " +
1:eac0369:                         scan_position.current_rh.getId() + ") " +
1:eac0369:                         "being fetched is marked deleted on page.:\n");
1:eac0369:             }
1:eac0369:             */
1:eac0369: 
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_RECORD_NOT_FOUND, 
1:eac0369:                     open_conglom.getContainer().getId(),
1:ce40a31:                     scan_position.current_rh.getPageNumber(),
1:ce40a31:                     scan_position.current_rh.getId());
1:eac0369:         }
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:395bf04:     /**
1:395bf04:     Fetch the location of the current position in the scan.
1:395bf04:     @see org.apache.derby.iapi.store.access.ScanController#fetchLocation
1:eac0369: 
1:395bf04:     @exception  StandardException  Standard exception policy.
1:395bf04:     **/
1:395bf04:     public void fetchLocation(RowLocation templateLocation)
1:395bf04:         throws StandardException
1:395bf04:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:395bf04:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return ScanInfo object which describes performance of scan.
1:eac0369:      * <p>
1:eac0369:      * Return ScanInfo object which contains information about the current
1:eac0369:      * scan.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @see ScanInfo
1:eac0369:      *
1:395bf04:      * @return The ScanInfo object which contains info about current scan.
1:eac0369:      *
1:395bf04:      * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ScanInfo getScanInfo()
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         throw StandardException.newException(
1:eac0369:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Returns true if the current position of the scan is at a 
1:eac0369:     deleted row.  This case can come about if the current scan
1:eac0369:     or another scan on the same table in the same transaction 
1:eac0369:     deleted the row after the next() call which positioned the
1:eac0369:     scan at this row.  
1:eac0369: 
1:eac0369:     The results of a fetch() performed on a scan positioned on 
1:eac0369:     a deleted row are undefined.
1:eac0369: 
1:395bf04:     @exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean isCurrentPositionDeleted()
1:395bf04:         throws StandardException
1:eac0369:     {
1:eac0369:         if (scan_state != SCAN_INPROGRESS)
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.AM_SCAN_NOT_POSITIONED);
1:eac0369: 
1:eac0369:         if (!open_conglom.latchPage(scan_position))
1:eac0369:         {
1:eac0369:             return(true);
1:eac0369:         }
1:eac0369: 
1:eac0369:         boolean ret_val = 
1:eac0369:             scan_position.current_page.isDeletedAtSlot(
1:eac0369:                 scan_position.current_slot);
1:eac0369: 
1:eac0369:         scan_position.unlatch();
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                     scan_position.current_rh.getPageNumber(),
1:                     scan_position.current_rh.getId());
/////////////////////////////////////////////////////////////////////////
1:                     scan_position.current_rh.getPageNumber(),
1:                     scan_position.current_rh.getId());
/////////////////////////////////////////////////////////////////////////
1:                     scan_position.current_rh.getPageNumber(),
1:                     scan_position.current_rh.getId());
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1:                         RowLocation     rowLocation =
1:                             hash_table.includeRowLocations() ?
1:                             makeRowLocation( scan_position ) : null;
1:                         if (
1:                             hash_table.putRow
1:                             ( false, fetch_row, rowLocation )
1:                             )
/////////////////////////////////////////////////////////////////////////
1:     /** Make a RowLocation from a RowPosition */
1:     protected abstract RowLocation makeRowLocation( RowPosition pos )
1:         throws StandardException;
1: 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:20cc6f6
/////////////////////////////////////////////////////////////////////////
1:             open_conglom.lockPositionForWrite(scan_position, true);
commit:bd34a3a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * but the value of the data is a <code>List</code> of
1:      * of the Hashtable entry is a row or is a <code>List</code> of rows.
commit:395272b
/////////////////////////////////////////////////////////////////////////
1:      * <pre>
/////////////////////////////////////////////////////////////////////////
1:      * </pre>
1:      *
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
/////////////////////////////////////////////////////////////////////////
1:         Page page = scan_position.current_page;
1:         int slot = scan_position.current_slot;
1: 
1:         if (SanityManager.DEBUG) {
1:             // DERBY-2197: Previously, we would try to get an exclusive row
1:             // lock here when the container was opened in row locking mode. In
1:             // most cases, the container is not opened in row locking mode. If
1:             // it is, and the open conglomerate uses update locks,
1:             // repositionScanForUpateOper() has already obtained an exclusive
1:             // row lock. We don't expect this method to be called unless these
1:             // conditions are satisfied, so now we just assert that no row
1:             // locking is required at this point.
1:             SanityManager.ASSERT(
1:                 ((open_conglom.getContainer().getLockingPolicy().getMode() !=
1:                       LockingPolicy.MODE_RECORD) ||
1:                           (open_conglom.isUseUpdateLocks())),
1:                 "Current mode of container requires row locking.");
1: 
1:             // make sure current_rh and current_slot are in sync
1:             SanityManager.ASSERT(
1:                 slot == page.getSlotNumber(scan_position.current_rh));
1:         }
1: 
1:         boolean ret_val;
1:         if (page.isDeletedAtSlot(slot)) {
1:             ret_val = false;
1:         } else {
1:             page.updateAtSlot(slot, row, validColumns);
1:             ret_val = true;
1:         }
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1:     Fetch the row at the current position of the Scan without applying the 
1:     qualifiers.
1: 	
0:     @see ScanController#fetchWithoutQualify
1: 	**/
1: 	public void fetchWithoutQualify(DataValueDescriptor[] row)
1: 		throws StandardException
1: 	{
1: 		fetch(row, false);
1: 	}
1: 	
1: 	/**
1:     Fetch the row at the current position of the Scan.
1: 
0:     @see ScanController#fetch
1: 		fetch(row, true);
1: 	}
1: 
1: 	/**
1:     Fetch the row at the current position of the Scan.
1: 
1:     @param row The row into which the value of the current 
1:      position in the scan is to be stored.
1: 
1:     @param qualify Indicates whether the qualifiers should be applied.
1: 
1:     @exception StandardException Standard exception policy.
1: 	**/
1: 	private void fetch(DataValueDescriptor[] row, boolean qualify)
1: 		throws StandardException
1: 	{
/////////////////////////////////////////////////////////////////////////
1:                 qualify ? init_fetchDesc : null, 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:395bf04
/////////////////////////////////////////////////////////////////////////
1:     private FormatableBitSet                 init_scanColumnList;
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
0:                     new Long(scan_position.current_rh.getPageNumber()),
/////////////////////////////////////////////////////////////////////////
1:     protected void positionAtInitScan(
/////////////////////////////////////////////////////////////////////////
1:         this.init_startKeyValue         = startKeyValue;
1:         if (RowUtil.isRowEmpty(this.init_startKeyValue))
1:             this.init_startKeyValue = null;
1:         this.init_startSearchOperator   = startSearchOperator;
/////////////////////////////////////////////////////////////////////////
1:         this.init_stopKeyValue          = stopKeyValue;
1:         this.init_stopSearchOperator    = stopSearchOperator;
/////////////////////////////////////////////////////////////////////////
1:                     required_cols.grow(this.init_startKeyValue.length);
1:                     required_cols.grow(this.init_stopKeyValue.length);
/////////////////////////////////////////////////////////////////////////
1:                 // FormatableBitSet equals requires the two FormatableBitSets to be of same
1:                 // length.
1:                 required_cols.grow(init_scanColumnList.size());
/////////////////////////////////////////////////////////////////////////
1:         } 
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:     public void reopenScanByRowLocation(
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:         while (scan_position.current_page != null)
1:         {
1:             while ((scan_position.current_slot + 1) < 
1:             {
/////////////////////////////////////////////////////////////////////////
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         return(ret_row_count);
/////////////////////////////////////////////////////////////////////////
1:     @param startRecordHandle  An existing RecordHandle within the conglomerate,
1:     @param qualifier An array of qualifiers which, applied
1:     to each key, restrict the rows returned by the scan.  Rows
1:     for which any one of the qualifiers returns false are not
1:     returned by the scan. If null, all rows are returned.
1:     @exception StandardException Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:     public void init(
1:     FormatableBitSet                scanColumnList,
1:     DataValueDescriptor[]           startKeyValue,
1:     DataValueDescriptor[]           stopKeyValue,
/////////////////////////////////////////////////////////////////////////
1:         // If we are closed due to catching an error in the middle of init,
1:         // xact_manager may not be set yet. 
1:         if (open_conglom.getXactMgr() != null)
1:             open_conglom.getXactMgr().closeMe(this);
/////////////////////////////////////////////////////////////////////////
1:     {
1:     }
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
1:     @see org.apache.derby.iapi.store.access.ScanController#delete
1:     **/
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
/////////////////////////////////////////////////////////////////////////
1:      * @exception  StandardException  Standard exception policy.
1:     {
/////////////////////////////////////////////////////////////////////////
1:     @param startKeyValue  An indexable row which holds a 
1:     (partial) key value which, in combination with the
1:     startSearchOperator, defines the starting position of
1:     the scan.  If null, the starting position of the scan
1:     is the first row of the conglomerate.
1:     
1:     @param startSearchOperator an operator which defines
1:     how the startKeyValue is to be searched for.  If 
1:     the first row which is greater than or equal to the 
1:     startKeyValue.  If startSearchOperation is ScanController.GT,
1:     the scan starts on the first row whose key is greater than
1:     startKeyValue.  The startSearchOperation parameter is 
1:     ignored if the startKeyValue parameter is null.
1:     @param qualifier An array of qualifiers which, applied
1:     to each key, restrict the rows returned by the scan.  Rows
1:     for which any one of the qualifiers returns false are not
1:     returned by the scan. If null, all rows are returned.
1:     @param stopKeyValue  An indexable row which holds a 
1:     (partial) key value which, in combination with the
1:     stopSearchOperator, defines the ending position of
1:     the scan.  If null, the ending position of the scan
1:     is the last row of the conglomerate.
1:     
1:     @param stopSearchOperator an operator which defines
1:     how the stopKeyValue is used to determine the scan stopping
1:     position. If stopSearchOperation is ScanController.GE, the scan 
1:     stops just before the first row which is greater than or
1:     equal to the stopKeyValue.  If stopSearchOperation is
1:     ScanController.GT, the scan stops just before the first row whose
1:     key is greater than startKeyValue.  The stopSearchOperation
1:     parameter is ignored if the stopKeyValue parameter is null.
1:     @exception StandardException Standard exception policy.
1:     public void reopenScan(
/////////////////////////////////////////////////////////////////////////
1:     @see org.apache.derby.iapi.store.access.ScanController#replace
1:     **/
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
1:     @exception StandardException Standard exception policy.
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     
1:     **/
0:     public void fetchWithoutQualify(DataValueDescriptor[] row)
1:         throws StandardException
1:     {
0:         fetch(row, false);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:     **/
1:     public void fetch(DataValueDescriptor[] row)
1:         throws StandardException
1:     {
0:         fetch(row, true);
1:     }
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     **/
0:     private void fetch(DataValueDescriptor[] row, boolean qualify)
1:         throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
0:                     new Long(scan_position.current_rh.getPageNumber()),
/////////////////////////////////////////////////////////////////////////
0:                     new Long(scan_position.current_rh.getPageNumber()),
1:     }
1:     /**
1:     Fetch the location of the current position in the scan.
1:     @see org.apache.derby.iapi.store.access.ScanController#fetchLocation
1:     @exception  StandardException  Standard exception policy.
1:     **/
1:     public void fetchLocation(RowLocation templateLocation)
1:         throws StandardException
1:     {
1:     }
/////////////////////////////////////////////////////////////////////////
1:      * @return The ScanInfo object which contains info about current scan.
1:      * @exception  StandardException  Standard exception policy.
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @exception StandardException Standard exception policy.
1:         throws StandardException
commit:3f3b5e6
/////////////////////////////////////////////////////////////////////////
0: 	FormatableBitSet				scanColumnList,
/////////////////////////////////////////////////////////////////////////
1:         scan_position = open_conglom.getRuntimeMem().get_scratch_row_position();
/////////////////////////////////////////////////////////////////////////
1:             open_conglom.getContainer().getReusableRecordIdSequenceNumber();
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:               (open_conglom.getRuntimeMem().get_scratch_row(
1:                     open_conglom.getRawTran())).length,
/////////////////////////////////////////////////////////////////////////
1:                               open_conglom.getRuntimeMem().get_row_for_export(
1:                                   open_conglom.getRawTran());
/////////////////////////////////////////////////////////////////////////
1:                             open_conglom.getRuntimeMem().get_row_for_export(
1:                                 open_conglom.getRawTran());
/////////////////////////////////////////////////////////////////////////
1:             open_conglom.getRuntimeMem().get_scratch_row(
1:                 open_conglom.getRawTran());
commit:8758a25
/////////////////////////////////////////////////////////////////////////
0: 	@param startRecordHandle  An existing RecordHandle within the conglomerate,
/////////////////////////////////////////////////////////////////////////
1:     RecordHandle    startRecordHandle,
1:     Qualifier       qualifier[][])
/////////////////////////////////////////////////////////////////////////
0: 	@param startSearchOperator an operator which defines
1:     startSearchOperator is ScanController.GE, the scan starts on
/////////////////////////////////////////////////////////////////////////
0: 	@param stopSearchOperator an operator which defines
commit:e7aa8e1
/////////////////////////////////////////////////////////////////////////
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         SanityManager.DEBUG_PRINT("GenericScanController.closeForEndTransaction", 
0:                 "closeHeldScan = " + closeHeldScan +
0:                 "open_conglom.getHold() = " + open_conglom.getHold());
1:                 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e8e04bf
/////////////////////////////////////////////////////////////////////////
0:                         if (hash_table.putRow(false, fetch_row))
commit:b22462c
/////////////////////////////////////////////////////////////////////////
1:     protected abstract void setRowLocationArray(
1:         ;
commit:00d8393
/////////////////////////////////////////////////////////////////////////
0: 		if (RowUtil.isRowEmpty(this.init_startKeyValue))
/////////////////////////////////////////////////////////////////////////
1:         if (RowUtil.isRowEmpty(this.init_stopKeyValue))
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.conglomerate.GenericScanController
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.conglomerate;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: 
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import java.util.Properties; 
1: 
1: 
1: /**
1: Generic class implementing shared ScanController methods.
1: 
1: Logically a scancontroller is used to scan a set of rows that meet some 
1: specified qualification.  Rows that meet the qualification may be operated
1: upon by the scan to fetch, delete, or replace.  The ScanController also
1: supports the notion or "repositioning" the scan, which simply resets the
1: beginning of the scan to a new place, and allows the user to continue from
1: there.
1: 
1: This class attempts to abstract out some of the parts of the scan such that
1: maybe multiple access methods can share code, even if they perform parts of
1: the scan wildly differently.  Here is how the scan has been broken apart:
1: 
1: scan_position - this variable holds the current scan position, it may be 
1:                 extended
1:                 to provide more information if necessary.
1: 
0: scan_state    - a scan has 3 possible states: 
0:                 SCAN_INIT, SCAN_INPROGRESS, SCAN_DONE
1: 
1: positionAtInitScan()
1:               - This routine is called to move the scan to the SCAN_INIT state.
1:                 It is used both for initialization of the ScanController and
1:                 by reopenScan().
1: 
1: positionAtStartForForwardScan()
1:               - This routine is called to move the scan from SCAN_INIT to 
1:                 SCAN_INPROGRESS.  Upon return from this routine it is expected
1:                 that scan_position is set such that calling the generic 
1:                 scan loop will reach the first row of the scan.  Note that this
1:                 usually means setting the scan_postion to one before the 1st 
1:                 row to be returned.
1: 
1: fetchRows()   - This routine is the meat of the scan, it moves the scan to the
1:                 next row, applies necessary qualifiers, and handles group or
1:                 non-group operations.  It moves through rows on a page in
1:                 order and then moves to the "next" page.
1: 
1: positionAtNextPage()
1:               - This routine handles moving the scan from the current 
1:                 scan_position to the next page.
1: 
1: positionAtDoneScan()
1:               - Handle all cleanup associated with moving the scan state from
1:                 SCAN_INPROGRESS to SCAN_DONE.  This may include releasing locks,
1:                 and setting the state of the scan.  This does not close the 
1:                 scan, it allows for a reopenScan() to be called.
1: **/
1: 
1: public abstract class GenericScanController 
1:     extends GenericController implements ScanManager
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1:     /**************************************************************************
1:      * Constants of the class
1:      **************************************************************************
1:      */
1: 
1:     /*
1:      * There are 5 states a scan can be in.
1:      *     SCAN_INIT - A scan has started but no positioning has been done.
1:      *                 The scan will be positioned when the first next() call
1:      *                 has been made.  None of the positioning state variables
1:      *                 are valid in this state.
1:      *     SCAN_INPROGRESS -
1:      *                 A scan is in this state after the first next() call.
1:      *                 On exit from any GenericScanController method, while in 
1:      *                 this state,
1:      *                 the scan "points" at a row which qualifies for the 
1:      *                 scan.  While not maintaining latches on a page the 
1:      *                 current position of the scan is either kept by record
1:      *                 handle or key.  To tell which use the following:
1:      *                 if (record key == null)
1:      *                    record handle has current position
1:      *                 else
1:      *                    record key has current position
1:      *
1:      *     SCAN_DONE - Once the end of the table or the stop condition is met
1:      *                 then the scan is placed in this state.  Only valid 
1:      *                 ScanController method at this point is close().
1:      *
1:      *     SCAN_HOLD_INIT -
1:      *                 The scan has been opened and held open across a commit,
1:      *                 at the last commit the state was SCAN_INIT.
1:      *                 The scan has never progressed from the SCAN_INIT state
1:      *                 during a transaction.  When a next is done the state
1:      *                 will either progress to SCAN_INPROGRESS or SCAN_DONE.
1:      *
1:      *     SCAN_HOLD_INPROGRESS -
1:      *                 The scan has been opened and held open across a commit,
1:      *                 at the last commit the state was in SCAN_INPROGRESS.
1:      *                 The transaction which opened the scan has committed,
1:      *                 but the scan was opened with the "hold" option true.
1:      *                 At commit the locks were released and the "current"
1:      *                 position is remembered.  In this state only two calls
1:      *                 are valid, either next() or close().  When next() is
1:      *                 called the scan is reopened, the underlying container
1:      *                 is opened thus associating all new locks with the current
1:      *                 transaction, and the scan continues at the "next" row.
1:      */
1:     public static final int    SCAN_INIT             = 1;
1:     public static final int    SCAN_INPROGRESS       = 2;
1:     public static final int    SCAN_DONE             = 3;
1:     public static final int    SCAN_HOLD_INIT        = 4;
1:     public static final int    SCAN_HOLD_INPROGRESS  = 5;
1: 
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * The following group of fields are all basic input parameters which are
1:      * provided by the calling code when doing a scan.
1:      * These are just saved values from what was initially input.
1:      **/
0: 	private FormatableBitSet                 init_scanColumnList;
1:     private DataValueDescriptor[]   init_startKeyValue;
1:     private int                     init_startSearchOperator;
1:     private Qualifier[][]           init_qualifier;
1:     private DataValueDescriptor[]   init_stopKeyValue;
1:     private int                     init_stopSearchOperator;
1: 
1:     private FetchDescriptor init_fetchDesc;
1: 
1:     /**
1:      * Delay positioning the table at the start position until the first
1:      * next() call.
1:      */
1:     private int         scan_state;
1: 
1:     
1:     /**
1:      * The position for the current scan.  The can be maintained in any
1:      * of the following ways:
1:      *     record handle - scan_position.current_rh:
1:      *         The scan maintains it's position using the record handle while
1:      *         it does not have a latch on the page, which is the case anytime
1:      *         control leaves access.  The access method must take appropriate
1:      *         steps to make sure the record handle will still be valid when
1:      *         the scan needs to reposition using the record handle.
1:      *     slot number   - scan_position.current_slot:
1:      *         While the scan has a latch on the page the scan is positioned
1:      *         using the slot number as the order of the rows cannot change
1:      *         while the latch is held (unless the holder of the latch causes
1:      *         them to move).  
1:      *     page number   - (RESOLVE - TODO)
1:      *         Sometimes it would be interesting to position a scan "between"
1:      *         pages, such that the next time the scan starts is starts at
1:      *         the next page.  This would allow us to efficiently do group
1:      *         scans returning page at atime results.  
1:      *         NOT IMPLEMENTED CURRENTLY.
1:      **/
1:     protected RowPosition         scan_position;
1: 
1:     /**
1:      * Performance counters ...
1:      */
1:     protected int stat_numpages_visited         = 0;
1:     protected int stat_numrows_visited          = 0;
1:     protected int stat_numrows_qualified        = 0;
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Private methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     private final void repositionScanForUpateOper()
1: 		throws StandardException
1:     {
1:         if (scan_state != SCAN_INPROGRESS)
1:             throw StandardException.newException(
1:                     SQLState.AM_SCAN_NOT_POSITIONED);
1: 
1: 
1:         if (!open_conglom.latchPage(scan_position))
1:         {
1:             throw StandardException.newException(
1:                     SQLState.AM_RECORD_NOT_FOUND, 
1:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
1:         }
1: 
1:         if (open_conglom.isUseUpdateLocks())
1:         {
1:             // we only have an U lock at this point which was acquired when the
1:             // scan positioned on the row, need to request an
1:             // X lock before we can actually perform the delete
1: 
0:             open_conglom.lockPositionForWrite(
0:                 scan_position, false /* not insert */, true);
1:         }
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Protected methods implementing mechanics of scanning rows:
1:      *
1:      *     positionAtInitScan()             - move scan state to SCAN_INIT
1:      *     positionAtStartForForwardScan()  - SCAN_INIT -> SCAN_INPROGRESS
1:      *     positionAtResumeScan()           - reposition after losing scan latch
1:      *     fetchRows()                      - move scan while in SCAN_INPROGRESS
1:      *     positionAtNextPage()             - move page while in SCAN_INPROGRESS
1:      *     positionAtDoneScan()             - SCAN_INPROGRESS -> SCAN_DONE
1:      *
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Move scan to the the SCAN_INIT state.
1:      * <p>
1:      * This routine is called to move the scan to the SCAN_INIT state.
1:      * It is used both for initialization of the ScanController and
1:      * by reopenScan().
1:      **/
0: 	protected void positionAtInitScan(
1:     DataValueDescriptor[]   startKeyValue,
1:     int                     startSearchOperator,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]   stopKeyValue,
1:     int                     stopSearchOperator,
1:     RowPosition             pos)
1:         throws StandardException
1:     {
1:         // startKeyValue init.
0: 	    this.init_startKeyValue         = startKeyValue;
0: 		if (RowUtil.isRowEmpty(this.init_startKeyValue, (FormatableBitSet) null))
0: 			this.init_startKeyValue = null;
1: 
1:         // startSearchOperator init.
0: 	    this.init_startSearchOperator   = startSearchOperator;
1: 
1:         // qualifier init.
1:         if ((qualifier != null) && (qualifier .length == 0))
1:             qualifier = null;
1:         this.init_qualifier             = qualifier;
1: 
1:         // TODO (mikem) - this could be more efficient, by writing
1:         // code to figure out length of row, but scratch row is cached
1:         // so allocating it here is probably not that bad.
1:         init_fetchDesc = 
1:             new FetchDescriptor(
0:               (open_conglom.getRuntimeMem().get_scratch_row()).length,
1:               init_scanColumnList,
1:               init_qualifier);
1: 
1:         // stopKeyValue init.
0: 	    this.init_stopKeyValue          = stopKeyValue;
0:         if (RowUtil.isRowEmpty(this.init_stopKeyValue, (FormatableBitSet) null))
1:             this.init_stopKeyValue = null;
1: 
1:         // stopSearchOperator init.
0: 	    this.init_stopSearchOperator    = stopSearchOperator;
1: 
1:         // reset the "current" position to starting condition.
1:         pos.init();
1: 
1: 
1:         // Verify that all columns in start key value, stop key value, and
1:         // qualifiers are present in the list of columns described by the
1:         // scanColumnList.
1:         if (SanityManager.DEBUG)
1:         {
1:             if (init_scanColumnList != null)
1:             {
1:                 // verify that all columns specified in qualifiers, start
1:                 // and stop positions are specified in the scanColumnList.  
1:                 
1:                 FormatableBitSet required_cols;
1: 
1:                 if (qualifier != null)
1:                     required_cols = RowUtil.getQualifierBitSet(qualifier);
1:                 else
1:                     required_cols = new FormatableBitSet(0);
1: 
1:                 // add in start columns
1:                 if (this.init_startKeyValue != null)
1:                 {
0: 					required_cols.grow(this.init_startKeyValue.length);
1:                     for (int i = 0; i < this.init_startKeyValue.length; i++)
1:                         required_cols.set(i);
1:                 }
1: 
1:                 if (this.init_stopKeyValue != null)
1:                 {
0: 					required_cols.grow(this.init_stopKeyValue.length);
1:                     for (int i = 0; i < this.init_stopKeyValue.length; i++)
1:                         required_cols.set(i);
1:                 }
1: 
1:                 FormatableBitSet required_cols_and_scan_list = 
1:                     (FormatableBitSet) required_cols.clone();
1: 
1:                 required_cols_and_scan_list.and(init_scanColumnList);
1: 
0: 				// FormatableBitSet equals requires the two FormatableBitSets to be of same
0: 				// length.
0: 				required_cols.grow(init_scanColumnList.size());
1: 
1:                 if (!required_cols_and_scan_list.equals(required_cols))
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "Some column specified in a Btree " +
1:                         " qualifier/start/stop list is " +
1:                         "not represented in the scanColumnList." +
1:                         "\n:required_cols_and_scan_list = " + 
1:                             required_cols_and_scan_list + 
1:                         "\n;required_cols = " + required_cols +
1:                         "\n;init_scanColumnList = " + init_scanColumnList);
1:                 }
1:             }
1: 		} 
1: 
1:         // Scan is fully initialized and ready to go.
1:         scan_state = SCAN_INIT;
1:     }
1: 
1: 
1:     /**
1:      * Reposition the scan upon entering the fetchRows loop.
1:      * <p>
1:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
1:      * Do work necessary to look at rows in the current page of the scan.
1:      * <p>
1:      * The default implementation uses a record handle to maintain a scan
1:      * position.  It will get the latch again on the current
1:      * scan position and set the slot to the current record handle.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtResumeScan(
1:     RowPosition pos)
1: 		throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 scan_position.current_rh != null, this.toString()); 
1:         }
1: 
1:         // reposition the scan at the row just before the next one to return.
1:         // This routine handles the mess of repositioning if the row or the
1:         // page has disappeared. This can happen if a lock was not held on the
1:         // row while not holding the latch.
1:         open_conglom.latchPageAndRepositionScan(scan_position);
1:     }
1: 
1:     /**
1:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
1:      * <p>
1:      * This routine is called to move the scan from SCAN_INIT to 
1:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
1:      * that scan_position is set such that calling the generic 
1:      * scan loop will reach the first row of the scan.  Note that this
1:      * usually means setting the scan_postion to one before the 1st 
1:      * row to be returned.
1:      * <p>
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtStartForForwardScan(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         if (pos.current_rh == null)
1:         {
1:             // 1st positioning of scan (delayed from openScan).
1:             pos.current_page = 
1:                 open_conglom.getContainer().getFirstPage();
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     pos.current_page.getPageNumber() == 
1:                     ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:                 if (pos.current_page.recordCount() < 1)
1:                     SanityManager.THROWASSERT(
1:                         "record count = " + pos.current_page.recordCount());
1:             }
1: 
1:             // set up for scan to continue at beginning of first page just
1:             // after first first control row on first page.
1:             pos.current_slot = Page.FIRST_SLOT_NUMBER;
1:         }
1:         else
1:         {
1:             // 1st positioning of scan following a reopenScanByRowLocation
1: 
1:             // reposition the scan at the row just before the next one to 
1:             // return.  This routine handles the mess of repositioning if the 
1:             // row or the page has disappeared. This can happen if a lock was 
1:             // not held on the row while not holding the latch.
1:             open_conglom.latchPageAndRepositionScan(pos);
1: 
1:             // set up for scan to at the specified record handle (position one
1:             // before it so that the loop increment and find it).
1:             pos.current_slot -= 1;
1:         }
1: 
1:         pos.current_rh    = null;
1:         this.stat_numpages_visited  = 1;
1:         this.scan_state             = SCAN_INPROGRESS;
1:     }
1: 
1:     /**
1:      * Position scan to slot before first slot on next page.
1:      * <p>
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtNextPage(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         // The current_page can become null, in a rare multi-user case, where
1:         // all pages in the heap are deallocated, in the middle of the scan
1:         // loop, when no latches are held, and the scan is waiting on a lock.
1:         // In this case the lockPositionForRead code, has nowhere good to 
1:         // position the scan, so it just sets the page to null and returns.
1:         if (pos.current_page != null)
1:         {
1:             // save current page number.
1:             long pageid = pos.current_page.getPageNumber();
1: 
1:             // unlatch old page.
1:             pos.unlatch();
1: 
1:             // latch page after current page number.
1:             pos.current_page = 
1:                 open_conglom.getContainer().getNextPage(pageid);
1: 
1:             // set up for scan to continue at beginning of this new page.
1:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
1:         }
1:     }
1: 
1:     /**
1:      * Do any necessary work to complete the scan.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtDoneScan(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         // Unlatch current page if any.
1:         pos.unlatch();
1: 
1:         // unlock the previous row.
1:         if (scan_position.current_rh != null)
1:         {
1:             open_conglom.unlockPositionAfterRead(scan_position);
1:             scan_position.current_rh = null;
1:         }
1: 
1:         this.scan_state = SCAN_DONE;
1:     }
1: 
0: 	public void reopenScanByRowLocation(
1:     RowLocation startRowLocation,
1:     Qualifier qualifier[][])
1:         throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     /**************************************************************************
1:      * Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Create object which represents the scan position.
1:      * <p>
1:      * Designed so that extending classes can override and allocate 
1:      * implementation specific row position's.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected RowPosition allocateScanPosition()
1:         throws StandardException
1:     {
1:         return(new RowPosition());
1:     }
1: 
1:     /**
1:      * Fetch the next N rows from the table.
1:      * <p>
1:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected int fetchRows(
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           rowloc_array,
1:     BackingStoreHashtable   hash_table,
1:     long                    max_rowcnt,
1:     int[]                   key_column_numbers)
1:         throws StandardException
1: 	{
1:         int                     ret_row_count           = 0;
1:         DataValueDescriptor[]   fetch_row               = null;
1: 
1:         if (max_rowcnt == -1)
1:             max_rowcnt = Long.MAX_VALUE;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (row_array != null)
1:             {
1:                 SanityManager.ASSERT(row_array[0] != null,
1:                     "first array slot in fetchNextGroup() must be non-null.");
1:                 SanityManager.ASSERT(hash_table == null);
1:             }
1:             else
1:             {
1:                 SanityManager.ASSERT(hash_table != null);
1:             }
1:         }
1: 
1:         if (this.scan_state == SCAN_INPROGRESS)
1:         {
1:             positionAtResumeScan(scan_position);
1:         }
1:         else if (this.scan_state == SCAN_INIT)
1:         {
1:             positionAtStartForForwardScan(scan_position);
1: 
1:         }
1:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
1:         {
0:             open_conglom.reopen();
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     scan_position.current_rh != null, this.toString()); 
1:             }
1: 
1:             // reposition the scan at the row just before the next one to 
1:             // return.
1:             // This routine handles the mess of repositioning if the row or 
1:             // the page has disappeared. This can happen if a lock was not 
1:             // held on the row while not holding the latch.
1:             open_conglom.latchPageAndRepositionScan(scan_position);
1: 
1:             this.scan_state = SCAN_INPROGRESS;
1:         }
1:         else if (this.scan_state == SCAN_HOLD_INIT)
1:         {
0:             open_conglom.reopen();
1: 
1:             positionAtStartForForwardScan(scan_position);
1: 
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1: 
1:             return(0);
1:         }
1: 
1:         // At this point:
1:         // scan_position.current_page is latched.  
1:         // scan_position.current_slot is the slot on scan_position.current_page
1:         // just before the "next" record this routine should process.
1: 
1:         // loop through successive pages and successive slots on those
1:         // pages.  Stop when either the last page is reached 
1:         // (scan_position.current_page will be null).  
1:         // Along the way apply qualifiers to skip rows which don't qualify.
1: 
0: 		while (scan_position.current_page != null)
1: 		{
0: 			while ((scan_position.current_slot + 1) < 
1:                     scan_position.current_page.recordCount())
1: 			{
1:                 // unlock the previous row.
1:                 if (scan_position.current_rh != null)
1:                 {
1:                     open_conglom.unlockPositionAfterRead(scan_position);
1: 
1:                 }
1:                 // Allocate a new row to read the row into.
1:                 if (fetch_row == null)
1:                 {
1:                     if (hash_table == null)
1:                     {
1:                          // point at allocated row in array if one exists.
1:                         if (row_array[ret_row_count] == null)
1:                         {
1:                             row_array[ret_row_count] = 
0:                               open_conglom.getRuntimeMem().get_row_for_export();
1:                         }
1: 
1:                         fetch_row = row_array[ret_row_count];
1:                     }
1:                     else
1:                     {
1:                         fetch_row = 
0:                             open_conglom.getRuntimeMem().get_row_for_export();
1:                     }
1:                 }
1: 
1:                 // move scan current position forward.
1:                 scan_position.positionAtNextSlot();
1: 
1:                 // Lock the row.
1:                 boolean lock_granted_while_latch_held = 
1:                     open_conglom.lockPositionForRead(
1:                         scan_position, (RowPosition) null, true, true);
1: 
1:                 if (!lock_granted_while_latch_held)
1:                 {
1:                     // if lock could not be granted while holding
1:                     // latch, then the row may either be on the same page 
1:                     // or it may no longer exist, this implementation does not
1:                     // handle rows which move to different pages.  
1:                     // 
1:                     // If the row moved on the same page then 
1:                     // lockPositionForRead() will have automatically updated
1:                     // the scan_postion argument to point to it, and we 
1:                     // wil now have a latch and a lock on that row.
1:                     //
1:                     // If the row no longer exists then the 
1:                     // "moveForwardIfRowDisappears" argument makes this routine
1:                     // find the "next" row in the heap and position on it.  If
1:                     // a valid row exists in the current page to position on,
1:                     // then lockPositionForRead() will position on it, get
1:                     // a lock on it, and return with a latch on the page.  
1:                     // Otherwise the routine will return with current_slot == -1
1:                     // and it is up to this routine to continue the scan as
1:                     // normal at the top of the loop.
1: 
1:                     if (scan_position.current_page == null)
1:                     {
1:                         // page has been unlatched and the scan is done, there
1:                         // are no more pages.  getNextPage() has been coded to
1:                         // handle a null current_page.
1: 
1:                         break;
1:                     }
1:                     else if (scan_position.current_slot == -1)
1:                     {
1:                         // This means that lockPositionForRead() had to 
1:                         // reposition the scan forward to a new page, because 
1:                         // the row the scan was locking was purged, when the 
1:                         // latch was released to wait on the lock.  In this 
1:                         // case just jump back to the top of loop and continue 
1:                         // scan.
1: 
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             SanityManager.ASSERT(
1:                                 scan_position.current_rh == null);
1:                         }
1: 
1:                         continue;
1:                     }
1:                 }
1: 
1:                 this.stat_numrows_visited++;
1: 
1:                 // lockRowAtPosition set pos.current_rh as part of getting lock.
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(scan_position.current_rh != null);
1: 
1:                     // make sure current_rh and current_slot are in sync
1:                     if (scan_position.current_slot !=
1:                             scan_position.current_page.getSlotNumber(
1:                                 scan_position.current_rh))
1:                     {
1:                         SanityManager.THROWASSERT(
1:                             "current_slot = " + scan_position.current_slot +
1:                             "current_rh = " + scan_position.current_rh +
1:                             "current_rh.slot = " + 
1:                             scan_position.current_page.getSlotNumber(
1:                                 scan_position.current_rh));
1:                     }
1:                 }
1: 
1:                 // fetchFromSlot returns null if row does not qualify.
1: 
1:                 scan_position.current_rh_qualified =
1:                     (scan_position.current_page.fetchFromSlot(
1:                         scan_position.current_rh, 
1:                         scan_position.current_slot, 
1:                         fetch_row, 
1:                         init_fetchDesc,
1:                         false) != null);
1: 
1:                 if (scan_position.current_rh_qualified)
1:                 {
1:                     // qualifying row.  
1: 
1: 
1:                     // scan_position.current_rh is save position of scan while 
1:                     // latch is not held.  It currently points at the 
1:                     // scan_position.current_slot in search (while latch is 
1:                     // held).
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         // make sure current_rh and current_slot are in sync
1:                         SanityManager.ASSERT(
1:                             scan_position.current_slot ==
1:                                 scan_position.current_page.getSlotNumber(
1:                                     scan_position.current_rh));
1:                     }
1: 
1:                     // Found qualifying row.  Done fetching rows for the group?
1:                     ret_row_count++;
1:                     stat_numrows_qualified++;
1: 
1: 
1:                     if (hash_table == null)
1:                     {
1:                         if (rowloc_array != null)
1:                         {
1:                             // if requested return the associated row location.
1:                             setRowLocationArray(
1:                                 rowloc_array, ret_row_count - 1, scan_position);
1:                         }
1: 
1:                         fetch_row = null;
1:                     }
1:                     else
1:                     {
0:                         if (hash_table.put(false, fetch_row))
1:                         {
1:                             // The row was inserted into the hash table so we
1:                             // need to create a new row next time through.
1:                             fetch_row = null;
1:                         }
1:                     }
1: 
1:                     if (max_rowcnt <= ret_row_count) 
1:                     {
1:                         // exit fetch row loop and return to the client.
1:                         scan_position.unlatch();
1: 
1:                         if (SanityManager.DEBUG)
1:                         {
1:                             SanityManager.ASSERT(
1:                                 scan_position.current_rh != null);
1:                         }
1: 
1:                         return(ret_row_count);
1:                     }
1:                 }
1: 			}
1: 
1:             positionAtNextPage(scan_position);
1: 
1:             this.stat_numpages_visited++;
1: 		}
1: 
1:         // Reached last page of scan.
1:         positionAtDoneScan(scan_position);
1: 
1:         // we need to decrement when we stop scan at the end of the table.
1:         this.stat_numpages_visited--;
1: 
1: 		return(ret_row_count);
1:     }
1: 
1: 
1:     /**
1:     Reposition the current scan.  This call is semantically the same as if
1:     the current scan had been closed and a openScan() had been called instead.
1:     The scan is reopened against the same conglomerate, and the scan
1:     is reopened with the same "scan column list", "hold" and "forUpdate"
1:     parameters passed in the original openScan.  
1:     <p>
1:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
1:     rather they continue to accumulate.
1:     <p>
1:     Note that this operation is currently only supported on Heap conglomerates.
1:     Also note that order of rows within are heap are not guaranteed, so for
1:     instance positioning at a RowLocation in the "middle" of a heap, then
1:     inserting more data, then continuing the scan is not guaranteed to see
1:     the new rows - they may be put in the "beginning" of the heap.
1: 
0: 	@param startRowLocation  An existing RowLocation within the conglomerate,
1:     at which to position the start of the scan.  The scan will begin at this
1:     location and continue forward until the end of the conglomerate.  
1:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:     had been deleted), will result in an exception being thrown when the 
1:     first next operation is attempted.
1: 
0: 	@param qualifier An array of qualifiers which, applied
0: 	to each key, restrict the rows returned by the scan.  Rows
0: 	for which any one of the qualifiers returns false are not
0: 	returned by the scan. If null, all rows are returned.
1: 
0: 	@exception StandardException Standard exception policy.
1:     **/
1:     protected void reopenScanByRecordHandle(
0:     RecordHandle startRecordHandle,
1:     Qualifier qualifier[][])
1:         throws StandardException
1:     {
1:         // initialize scan position parameters at beginning of scan
1:         this.scan_state = 
1:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
1: 
1:         // position the scan at the row before the given record id, so that
1:         // the first "next" starts on the given row.
1:         scan_position.current_rh = startRecordHandle;
1:     }
1: 
0:     protected void setRowLocationArray(
1:     RowLocation[]   rowloc_array,
1:     int             index,
1:     RowPosition     pos)
1:         throws StandardException
1:     {
0:         throw(StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * abstract protected Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
0: 	public void init(
1:     OpenConglomerate                open_conglom,
0: 	FormatableBitSet				            scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
1:     int                             startSearchOperator,
1:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]	        stopKeyValue,
1:     int                             stopSearchOperator)
1:         throws StandardException
1:     {
1:         super.init(open_conglom);
1: 
0:         // RESOLVE (mikem) - move this into runtime_mem
0:         scan_position = allocateScanPosition();
1: 
1:         // remember inputs
1:         init_scanColumnList         = scanColumnList;
1: 
1:         positionAtInitScan(
1:             startKeyValue,
1:             startSearchOperator,
1:             qualifier,
1:             stopKeyValue,
1:             stopSearchOperator,
1:             scan_position);
1:     }
1: 
1: 
1:     public final int getNumPagesVisited()
1:     {
1:         return(stat_numpages_visited);
1:     }
1:     public final int getNumRowsVisited()
1:     {
1:         return(stat_numrows_visited);
1:     }
1:     public final int getNumRowsQualified()
1:     {
1:         return(stat_numrows_qualified);
1:     }
1:     public final FormatableBitSet getScanColumnList()
1:     {
1:         return(init_scanColumnList);
1:     }
1:     public final DataValueDescriptor[] getStartKeyValue()
1:     {
1:         return(init_startKeyValue);
1:     }
1:     public final int getStartSearchOperator()
1:     {
1:         return(init_startSearchOperator);
1:     }
1:     public final DataValueDescriptor[] getStopKeyValue()
1:     {
1:         return(init_stopKeyValue);
1:     }
1:     public final int getStopSearchOperator()
1:     {
1:         return(init_stopSearchOperator);
1:     }
1:     public final Qualifier[][] getQualifier()
1:     {
1:         return(init_qualifier);
1:     }
1: 
1: 
1:     public final int getScanState()
1:     {
1:         return(scan_state);
1:     }
1:     public final void setScanState(int state)
1:     {
1:         scan_state = state;
1:     }
1:     public final RowPosition getScanPosition()
1:     {
1:         return(scan_position);
1:     }
1:     public final void setScanPosition(RowPosition   pos)
1:     {
1:         scan_position = pos;
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods implementing ScanController:
1:      **************************************************************************
1:      */
1:     private void closeScan()
1:         throws StandardException
1:     {
1:         super.close();
1: 
0: 		// If we are closed due to catching an error in the middle of init,
0: 		// xact_manager may not be set yet. 
0: 		if (open_conglom.getXactMgr() != null)
0: 			open_conglom.getXactMgr().closeMe(this);
1: 
1:         // help the garbage collector.
1:         this.init_qualifier         = null;
1:         init_scanColumnList         = null;
1:         init_startKeyValue          = null;
1:         init_stopKeyValue           = null;
1:     }
1: 
1:     public void close()
1:         throws StandardException
1: 	{
1:         // Finish the scan - this may release locks if read committed and scan
1:         // still holds some locks, and close comes before scan.next() returned
1:         // that scan was done.
1:         positionAtDoneScan(scan_position);
1: 
1:         closeScan();
1: 	}
1: 
1:     public boolean closeForEndTransaction(
1:     boolean closeHeldScan)
1:         throws StandardException
1: 	{
1:         if ((!open_conglom.getHold()) || closeHeldScan) 
1:         {
1:             // close the scan as part of the commit/abort
1: 
1:             this.scan_state = SCAN_DONE;
1: 
1:             closeScan();
1: 
1:             return(true);
1:         }
1:         else
1:         {
1:             super.close();
1: 
1:             // allow the scan to continue after the commit.
1:             // locks and latches will be released as part of the commit, so
1:             // no need to release them by hand.
1: 
1:             if (this.scan_state == SCAN_INPROGRESS)
1:                 this.scan_state = SCAN_HOLD_INPROGRESS;
1:             else if (this.scan_state == SCAN_INIT)
1:                 this.scan_state = SCAN_HOLD_INIT;
1: 
1: 
1:             return(false);
1:         }
1: 	}
1: 
1: 
1:     /**
0: 	@see ScanController#delete
1: 	**/
1:     public boolean delete()
1: 		throws StandardException
1: 	{
1:         repositionScanForUpateOper();
1: 
1:         boolean ret_val = true;
1: 
1:         // RESOLVE (mikem) - RECID - performance could be better if we did not
1:         // have to call isDeletedAtSlot().
1: 
1:         // RESOLVE (mikem) - share code below with conglomerateController.
1: 
1:         if (scan_position.current_page.isDeletedAtSlot(
1:                 scan_position.current_slot))
1:         {
1:             ret_val = false;
1:         }
1:         else
1:         {
1:             // Delete the row 
1:             scan_position.current_page.deleteAtSlot(
1:                 scan_position.current_slot, true, (LogicalUndo) null);
1: 
1:             if (scan_position.current_page.nonDeletedRecordCount() == 0)
1:             {
1:                 queueDeletePostCommitWork(scan_position);
1:             }
1:         }
1: 
1:         scan_position.unlatch();
1: 
1:         return(ret_val);
1: 	}
1: 
1: 
1:     /**
1:      * A call to allow client to indicate that current row does not qualify.
1:      * <p>
1:      * Indicates to the ScanController that the current row does not
1:      * qualify for the scan.  If the isolation level of the scan allows, 
1:      * this may result in the scan releasing the lock on this row.
1:      * <p>
1:      * Note that some scan implimentations may not support releasing locks on 
1:      * non-qualifying rows, or may delay releasing the lock until sometime
1:      * later in the scan (ie. it may be necessary to keep the lock until 
1:      * either the scan is repositioned on the next row or page).
1:      * <p>
1:      * This call should only be made while the scan is positioned on a current
1:      * valid row.
1:      * RESOLVE (mikem-05/29/98) - Implement this when we support levels of
1:      * concurrency less than serializable.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void didNotQualify()
1:         throws StandardException
1:     {
1:     }
1: 
1:     /**
1:      * Insert all rows that qualify for the current scan into the input
1:      * Hash table.  
1:      * <p>
1:      * This routine scans executes the entire scan as described in the 
1:      * openScan call.  For every qualifying unique row value an entry is
1:      * placed into the HashTable. For unique row values the entry in the
1:      * Hashtable has a key value of the object stored in 
1:      * row[key_column_number], and the value of the data is row.  For row 
1:      * values with duplicates, the key value is also row[key_column_number], 
0:      * but the value of the data is a Vector of
1:      * rows.  The caller will have to call "instanceof" on the data value
1:      * object if duplicates are expected, to determine if the data value
0:      * of the Hashtable entry is a row or is a Vector of rows.
1:      * <p>
1:      * Note, that for this routine to work efficiently the caller must 
1:      * ensure that the object in row[key_column_number] implements 
1:      * the hashCode and equals method as appropriate for it's datatype.
1:      * <p>
1:      * It is expected that this call will be the first and only call made in
1:      * an openscan.  Qualifiers and stop position of the openscan are applied
1:      * just as in a normal scan.  This call is logically equivalent to the 
1:      * caller performing the following:
1:      *
1:      * import java.util.Hashtable;
1:      *
1:      * hash_table = new Hashtable();
1:      *
1:      * while (next())
1:      * {
1:      *     row = create_new_row();
1:      *     fetch(row);
1:      *     if ((duplicate_value = 
1:      *         hash_table.put(row[key_column_number], row)) != null)
1:      *     {
1:      *         Vector row_vec;
1:      *
1:      *         // inserted a duplicate
1:      *         if ((duplicate_value instanceof vector))
1:      *         {
1:      *             row_vec = (Vector) duplicate_value;
1:      *         }
1:      *         else
1:      *         {
1:      *             // allocate vector to hold duplicates
1:      *             row_vec = new Vector(2);
1:      *
1:      *             // insert original row into vector
1:      *             row_vec.addElement(duplicate_value);
1:      *
1:      *             // put the vector as the data rather than the row
1:      *             hash_table.put(row[key_column_number], row_vec);
1:      *         }
1:      *         
1:      *         // insert new row into vector
1:      *         row_vec.addElement(row);
1:      *     }
1:      * }
1:      * <p>
1:      * The columns of the row will be the standard columns returned as
1:      * part of a scan, as described by the validColumns - see openScan for
1:      * description.
1:      * RESOLVE - is this ok?  or should I hard code somehow the row to
1:      *           be the first column and the row location?
1:      * <p>
1:      * Currently it is only possible to hash on the first column in the
1:      * conglomerate, in the future we may change the interface to allow
1:      * hashing either on a different column or maybe on a combination of
1:      * columns.
1:      * <p>
1:      * No overflow to external storage is provided, so calling this routine
1:      * on a 1 gigabyte conglomerate will incur at least 1 gigabyte of memory
1:      * (probably failing with a java out of memory condition).  If this
1:      * routine gets an out of memory condition, or if "max_rowcnt" is 
1:      * exceeded then then the routine will give up, empty the Hashtable, 
1:      * and return "false."
1:      * <p>
1:      * On exit from this routine, whether the fetchSet() succeeded or not
1:      * the scan is complete, it is positioned just the same as if the scan
1:      * had been drained by calling "next()" until it returns false (ie. 
1:      * fetchNext() and next() calls will return false).  
1:      * reopenScan() can be called to restart the scan.
1:      * <p>
1:      *
1:      * RESOLVE - until we get row counts what should we do for sizing the
1:      *           the size, capasity, and load factor of the hash table.
1:      *           For now it is up to the caller to create the Hashtable,
1:      *           Access does not reset any parameters.
1:      * <p>
1:      * RESOLVE - I am not sure if access should be in charge of allocating
1:      *           the new row objects.  I know that I can do this in the
1:      *           case of btree's, but I don't think I can do this in heaps.
1:      *           Maybe this is solved by work to be done on the sort 
1:      *           interface.
1:      *
1:      *
0: 	 * @return boolean indicating that the fetch set succeeded.  If it failed
0:      *                 Hashtable.clear() will be called leaving an empty 
0:      *                 table.
1:      *
1:      * @param max_rowcnt        The maximum number of rows to insert into the 
1:      *                          Hash table.  Pass in -1 if there is no maximum.
1:      * @param key_column_numbers The column numbers of the columns in the
1:      *                          scan result row to be the key to the Hashtable.
1:      *                          "0" is the first column in the scan result
1:      *                          row (which may be different than the first
1:      *                          column in the row in the table of the scan).
1:      * @param hash_table        The java HashTable to load into.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void fetchSet(
1:     long                    max_rowcnt,
1:     int[]                   key_column_numbers,
1:     BackingStoreHashtable   hash_table)
1:         throws StandardException
1: 	{
1:         fetchRows(
1:             (DataValueDescriptor[][]) null,
1:             (RowLocation[]) null,
1:             hash_table,
1:             max_rowcnt,
1:             key_column_numbers);
1: 
1:         return;
1:     }
1: 
1:     /**
1:     Reposition the current scan.  This call is semantically the same as if
1:     the current scan had been closed and a openScan() had been called instead.
1:     The scan is reopened with against the same conglomerate, and the scan
1:     is reopened with the same "hold" and "forUpdate" parameters passed in
1:     the original openScan.  The previous template row continues to be used.
1: 
0:     @param template A prototypical row which the scan may use ot
0: 	maintain its position in the conglomerate.  Not all access method
0: 	scan types will require this, if they don't it's ok to pass in null.
0:     In order to scan a conglomerate one must allocate 2 separate "row"
0:     templates.  The "row" template passed into openScan is for the private
0:     use of the scan itself, and no access to it should be made
0:     by the caller while the scan is still open.  Because of this the 
0:     scanner must allocate another "row" template to hold the values returned 
0:     from fetch().
1: 
0: 	@param startKeyValue  An indexable row which holds a 
0: 	(partial) key value which, in combination with the
0: 	startSearchOperator, defines the starting position of
0: 	the scan.  If null, the starting position of the scan
0: 	is the first row of the conglomerate.
1: 	
0: 	@param startSearchOperation an operator which defines
0: 	how the startKeyValue is to be searched for.  If 
0:     startSearchOperation is ScanController.GE, the scan starts on
0: 	the first row which is greater than or equal to the 
0: 	startKeyValue.  If startSearchOperation is ScanController.GT,
0: 	the scan starts on the first row whose key is greater than
0: 	startKeyValue.  The startSearchOperation parameter is 
0: 	ignored if the startKeyValue parameter is null.
1: 
0: 	@param qualifier An array of qualifiers which, applied
0: 	to each key, restrict the rows returned by the scan.  Rows
0: 	for which any one of the qualifiers returns false are not
0: 	returned by the scan. If null, all rows are returned.
1: 
0: 	@param stopKeyValue  An indexable row which holds a 
0: 	(partial) key value which, in combination with the
0: 	stopSearchOperator, defines the ending position of
0: 	the scan.  If null, the ending position of the scan
0: 	is the last row of the conglomerate.
1: 	
0: 	@param stopSearchOperation an operator which defines
0: 	how the stopKeyValue is used to determine the scan stopping
0: 	position. If stopSearchOperation is ScanController.GE, the scan 
0: 	stops just before the first row which is greater than or
0: 	equal to the stopKeyValue.  If stopSearchOperation is
0: 	ScanController.GT, the scan stops just before the first row whose
0: 	key is greater than	startKeyValue.  The stopSearchOperation
0: 	parameter is ignored if the stopKeyValue parameter is null.
1: 
0: 	@exception StandardException Standard exception policy.
1:     **/
0: 	public void reopenScan(
1:     DataValueDescriptor[]   startKeyValue,
1:     int                     startSearchOperator,
1:     Qualifier               qualifier[][],
1:     DataValueDescriptor[]   stopKeyValue,
1:     int                     stopSearchOperator)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             if (!open_conglom.getHold())
1:             {
1:                 SanityManager.ASSERT(
1:                     !open_conglom.isClosed(), 
1:                     "GenericScanController.reopenScan() called on a non-held closed scan.");
1:             }
1:         }
1: 
1:         // initialize scan position parameters at beginning of scan
1:         this.scan_state = 
1:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
1: 
1:         scan_position.current_rh   = null;
1:     }
1: 
1:     /**
0: 	@see ScanController#replace
1: 	**/
1:     public boolean replace(
1:     DataValueDescriptor[]   row, 
1:     FormatableBitSet                 validColumns)
1: 		throws StandardException
1: 	{
1:         repositionScanForUpateOper();
1: 
1:         boolean ret_val = 
0:             scan_position.current_page.update(
0:                 scan_position.current_rh, row, validColumns);
1: 
1:         scan_position.unlatch();
1: 
1:         return(ret_val);
1: 	}
1: 
1:     /**
1:     Returns true if the current position of the scan still qualifies
1:     under the set of qualifiers passed to the openScan().  When called
1:     this routine will reapply all qualifiers against the row currently
1:     positioned and return true if the row still qualifies.  If the row
1:     has been deleted or no longer passes the qualifiers then this routine
1:     will return false.
1:     
1:     This case can come about if the current scan
1:     or another scan on the same table in the same transaction 
1:     deleted the row or changed columns referenced by the qualifier after 
1:     the next() call which positioned the scan at this row.  
1: 
1:     Note that for comglomerates which don't support update, like btree's, 
1:     there is no need to recheck the qualifiers.
1: 
1:     The results of a fetch() performed on a scan positioned on 
1:     a deleted row are undefined.
1: 
0: 	@exception StandardException Standard exception policy.
1:     **/
1:     public boolean doesCurrentPositionQualify()
1: 		throws StandardException
1:     {
1:         if (scan_state != SCAN_INPROGRESS)
1:             throw StandardException.newException(
1:                     SQLState.AM_SCAN_NOT_POSITIONED);
1: 
1:         if (!open_conglom.latchPage(scan_position))
1:         {
1:             return(false);
1:         }
1: 
1:         DataValueDescriptor row[] = 
0:             open_conglom.getRuntimeMem().get_scratch_row();
1: 
1:         // If fetchFromSlot returns null it either means the row is deleted,
1:         // or the qualifier evaluates to false.
1:         
1:         boolean ret_val = 
1:             (scan_position.current_page.fetchFromSlot(
1:                 scan_position.current_rh, 
1:                 scan_position.current_slot, 
1:                 row,
1:                 init_fetchDesc,
1:                 false) != null);
1: 
1:         scan_position.unlatch();
1: 
1:         return(ret_val);
1:     }
1: 
1:     /**
0: 	@see ScanController#fetch
1: 	**/
0: 	public void fetch(DataValueDescriptor[] row)
1: 		throws StandardException
1: 	{
1:         if (scan_state != SCAN_INPROGRESS)
1:             throw StandardException.newException(
1:                     SQLState.AM_SCAN_NOT_POSITIONED);
1: 
1:         if (!open_conglom.latchPage(scan_position))
1:         {
1:             throw StandardException.newException(
1:                     SQLState.AM_RECORD_NOT_FOUND, 
1:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
1:         }
1: 
1:         // RESOLVE (mikem) - should this call apply the qualifiers again?
1:         RecordHandle rh = 
1:             scan_position.current_page.fetchFromSlot(
1:                 scan_position.current_rh, 
1:                 scan_position.current_slot, 
1:                 row, 
1:                 init_fetchDesc, 
1:                 false);
1: 
1:         scan_position.unlatch();
1: 
1:         if (rh == null)
1:         {
1:             /*
1:             if (SanityManager.DEBUG)
1:             {
1:                 if (isCurrentPositionDeleted())
1:                     SanityManager.THROWASSERT(
1:                         "The record (" + 
1:                         open_conglom.getContainer().getId() +
1:                         ", " +
1:                         scan_position.current_rh.getPageNumber() + ", " +
1:                         scan_position.current_rh.getId() + ") " +
1:                         "being fetched is marked deleted on page.:\n");
1:             }
1:             */
1: 
1:             throw StandardException.newException(
1:                     SQLState.AM_RECORD_NOT_FOUND, 
1:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
1:         }
1: 
1:         return;
1: 	}
1: 
1: 	/**
0: 	Fetch the location of the current position in the scan.
0: 	@see ScanController#fetchLocation
1: 
0: 	@exception  StandardException  Standard exception policy.
1: 	**/
0: 	public void fetchLocation(RowLocation templateLocation)
1: 		throws StandardException
1: 	{
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: 
1:     /**
1:      * Return ScanInfo object which describes performance of scan.
1:      * <p>
1:      * Return ScanInfo object which contains information about the current
1:      * scan.
1:      * <p>
1:      *
1:      * @see ScanInfo
1:      *
0: 	 * @return The ScanInfo object which contains info about current scan.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ScanInfo getScanInfo()
1: 		throws StandardException
1:     {
1:         throw StandardException.newException(
1:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1: 
1: 
1:     /**
1:     Returns true if the current position of the scan is at a 
1:     deleted row.  This case can come about if the current scan
1:     or another scan on the same table in the same transaction 
1:     deleted the row after the next() call which positioned the
1:     scan at this row.  
1: 
1:     The results of a fetch() performed on a scan positioned on 
1:     a deleted row are undefined.
1: 
0: 	@exception StandardException Standard exception policy.
1:     **/
1:     public boolean isCurrentPositionDeleted()
1: 		throws StandardException
1:     {
1:         if (scan_state != SCAN_INPROGRESS)
1:             throw StandardException.newException(
1:                     SQLState.AM_SCAN_NOT_POSITIONED);
1: 
1:         if (!open_conglom.latchPage(scan_position))
1:         {
1:             return(true);
1:         }
1: 
1:         boolean ret_val = 
1:             scan_position.current_page.isDeletedAtSlot(
1:                 scan_position.current_slot);
1: 
1:         scan_position.unlatch();
1: 
1:         return(ret_val);
1:     }
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1e762f5
/////////////////////////////////////////////////////////////////////////
1: scan_state    - a scan has 5 possible states:
1:                 SCAN_INIT, SCAN_INPROGRESS, SCAN_DONE, SCAN_HOLD_INIT, and
1:                 SCAN_HOLD_INPROGRESS
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * @see org.apache.derby.iapi.store.access.ScanController#isHeldAfterCommit
1:      */
1:     public boolean isHeldAfterCommit() throws StandardException
0:     {
1:         return (scan_state == SCAN_HOLD_INIT ||
1:                 scan_state == SCAN_HOLD_INPROGRESS);
0:     }
0: 
0: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	@see org.apache.derby.iapi.store.access.ScanController#delete
/////////////////////////////////////////////////////////////////////////
0: 	@see org.apache.derby.iapi.store.access.ScanController#replace
/////////////////////////////////////////////////////////////////////////
1:     @see org.apache.derby.iapi.store.access.ScanController#fetchWithoutQualify
/////////////////////////////////////////////////////////////////////////
1:     @see org.apache.derby.iapi.store.access.ScanController#fetch
/////////////////////////////////////////////////////////////////////////
0: 	@see org.apache.derby.iapi.store.access.ScanController#fetchLocation
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
0:          
0:     /**
1:      * If this flag is set to true, a RowLocation returned from this controller
1:      * may have been reused for another row.
1:      */
1:     protected boolean rowLocationsInvalidated = false;
0:     
0:     /**
1:      * This is the sequence number for when a record id can be
1:      * reused. If it has been changed in the container, a RowLocation
1:      * may be reused for another row.
1:      */
1:     private long reusableRecordIdSequenceNumber = 0;
/////////////////////////////////////////////////////////////////////////
1:             reopenAfterEndTransaction();
/////////////////////////////////////////////////////////////////////////
1:             reopenAfterEndTransaction();
/////////////////////////////////////////////////////////////////////////
0:         
1:         reusableRecordIdSequenceNumber = 
0:                     open_conglom.getContainer().getReusableRecordIdSequenceNumber();
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Reopens the scan after it has been closed as part of a commit.
1:      * This method will check the reusableRecordIdSequenceNumber of the 
1:      * container, and will set the rowLocationsInvalidated flag if it has 
1:      * changed.
1:      * @return true if the conglomerate has been reopened
1:      * @exception StandardException Derby standard exception
0:      */
1:     protected final boolean reopenAfterEndTransaction() 
0:         throws StandardException
0:     {
1:         // Only reopen if holdable
1:         if (!open_conglom.getHold()) 
0:         {
1:             return(false);
0:         }
0:         
1:         ContainerHandle container = open_conglom.reopen();
1:         switch (scan_state) {
1:         case SCAN_INPROGRESS:
1:         case SCAN_HOLD_INPROGRESS:
1:         case SCAN_DONE:
1:             if (container.getReusableRecordIdSequenceNumber() != 
1:                 reusableRecordIdSequenceNumber) 
0:             {
1:                 rowLocationsInvalidated = true;
0:             }
1:             break;
1:         case SCAN_INIT: 
1:         case SCAN_HOLD_INIT:
1:             reusableRecordIdSequenceNumber = 
1:                 container.getReusableRecordIdSequenceNumber();
1:             break;
1:         default:
1:             break; 
0:         }
1:         return(true);
0:     }
0: 
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.conglomerate;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.util.Properties; 
0: 
0: 
0: /**
0: Generic class implementing shared ScanController methods.
0: 
0: Logically a scancontroller is used to scan a set of rows that meet some 
0: specified qualification.  Rows that meet the qualification may be operated
0: upon by the scan to fetch, delete, or replace.  The ScanController also
0: supports the notion or "repositioning" the scan, which simply resets the
0: beginning of the scan to a new place, and allows the user to continue from
0: there.
0: 
0: This class attempts to abstract out some of the parts of the scan such that
0: maybe multiple access methods can share code, even if they perform parts of
0: the scan wildly differently.  Here is how the scan has been broken apart:
0: 
0: scan_position - this variable holds the current scan position, it may be 
0:                 extended
0:                 to provide more information if necessary.
0: 
0: scan_state    - a scan has 3 possible states: 
0:                 SCAN_INIT, SCAN_INPROGRESS, SCAN_DONE
0: 
0: positionAtInitScan()
0:               - This routine is called to move the scan to the SCAN_INIT state.
0:                 It is used both for initialization of the ScanController and
0:                 by reopenScan().
0: 
0: positionAtStartForForwardScan()
0:               - This routine is called to move the scan from SCAN_INIT to 
0:                 SCAN_INPROGRESS.  Upon return from this routine it is expected
0:                 that scan_position is set such that calling the generic 
0:                 scan loop will reach the first row of the scan.  Note that this
0:                 usually means setting the scan_postion to one before the 1st 
0:                 row to be returned.
0: 
0: fetchRows()   - This routine is the meat of the scan, it moves the scan to the
0:                 next row, applies necessary qualifiers, and handles group or
0:                 non-group operations.  It moves through rows on a page in
0:                 order and then moves to the "next" page.
0: 
0: positionAtNextPage()
0:               - This routine handles moving the scan from the current 
0:                 scan_position to the next page.
0: 
0: positionAtDoneScan()
0:               - Handle all cleanup associated with moving the scan state from
0:                 SCAN_INPROGRESS to SCAN_DONE.  This may include releasing locks,
0:                 and setting the state of the scan.  This does not close the 
0:                 scan, it allows for a reopenScan() to be called.
0: **/
0: 
0: public abstract class GenericScanController 
0:     extends GenericController implements ScanManager
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0:     /**************************************************************************
0:      * Constants of the class
0:      **************************************************************************
0:      */
0: 
0:     /*
0:      * There are 5 states a scan can be in.
0:      *     SCAN_INIT - A scan has started but no positioning has been done.
0:      *                 The scan will be positioned when the first next() call
0:      *                 has been made.  None of the positioning state variables
0:      *                 are valid in this state.
0:      *     SCAN_INPROGRESS -
0:      *                 A scan is in this state after the first next() call.
0:      *                 On exit from any GenericScanController method, while in 
0:      *                 this state,
0:      *                 the scan "points" at a row which qualifies for the 
0:      *                 scan.  While not maintaining latches on a page the 
0:      *                 current position of the scan is either kept by record
0:      *                 handle or key.  To tell which use the following:
0:      *                 if (record key == null)
0:      *                    record handle has current position
0:      *                 else
0:      *                    record key has current position
0:      *
0:      *     SCAN_DONE - Once the end of the table or the stop condition is met
0:      *                 then the scan is placed in this state.  Only valid 
0:      *                 ScanController method at this point is close().
0:      *
0:      *     SCAN_HOLD_INIT -
0:      *                 The scan has been opened and held open across a commit,
0:      *                 at the last commit the state was SCAN_INIT.
0:      *                 The scan has never progressed from the SCAN_INIT state
0:      *                 during a transaction.  When a next is done the state
0:      *                 will either progress to SCAN_INPROGRESS or SCAN_DONE.
0:      *
0:      *     SCAN_HOLD_INPROGRESS -
0:      *                 The scan has been opened and held open across a commit,
0:      *                 at the last commit the state was in SCAN_INPROGRESS.
0:      *                 The transaction which opened the scan has committed,
0:      *                 but the scan was opened with the "hold" option true.
0:      *                 At commit the locks were released and the "current"
0:      *                 position is remembered.  In this state only two calls
0:      *                 are valid, either next() or close().  When next() is
0:      *                 called the scan is reopened, the underlying container
0:      *                 is opened thus associating all new locks with the current
0:      *                 transaction, and the scan continues at the "next" row.
0:      */
0:     public static final int    SCAN_INIT             = 1;
0:     public static final int    SCAN_INPROGRESS       = 2;
0:     public static final int    SCAN_DONE             = 3;
0:     public static final int    SCAN_HOLD_INIT        = 4;
0:     public static final int    SCAN_HOLD_INPROGRESS  = 5;
0: 
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * The following group of fields are all basic input parameters which are
0:      * provided by the calling code when doing a scan.
0:      * These are just saved values from what was initially input.
0:      **/
0: 	private FormatableBitSet                 init_scanColumnList;
0:     private DataValueDescriptor[]   init_startKeyValue;
0:     private int                     init_startSearchOperator;
0:     private Qualifier[][]           init_qualifier;
0:     private DataValueDescriptor[]   init_stopKeyValue;
0:     private int                     init_stopSearchOperator;
0: 
0:     private FetchDescriptor init_fetchDesc;
0: 
0:     /**
0:      * Delay positioning the table at the start position until the first
0:      * next() call.
0:      */
0:     private int         scan_state;
0: 
0:     
0:     /**
0:      * The position for the current scan.  The can be maintained in any
0:      * of the following ways:
0:      *     record handle - scan_position.current_rh:
0:      *         The scan maintains it's position using the record handle while
0:      *         it does not have a latch on the page, which is the case anytime
0:      *         control leaves access.  The access method must take appropriate
0:      *         steps to make sure the record handle will still be valid when
0:      *         the scan needs to reposition using the record handle.
0:      *     slot number   - scan_position.current_slot:
0:      *         While the scan has a latch on the page the scan is positioned
0:      *         using the slot number as the order of the rows cannot change
0:      *         while the latch is held (unless the holder of the latch causes
0:      *         them to move).  
0:      *     page number   - (RESOLVE - TODO)
0:      *         Sometimes it would be interesting to position a scan "between"
0:      *         pages, such that the next time the scan starts is starts at
0:      *         the next page.  This would allow us to efficiently do group
0:      *         scans returning page at atime results.  
0:      *         NOT IMPLEMENTED CURRENTLY.
0:      **/
0:     protected RowPosition         scan_position;
0: 
0:     /**
0:      * Performance counters ...
0:      */
0:     protected int stat_numpages_visited         = 0;
0:     protected int stat_numrows_visited          = 0;
0:     protected int stat_numrows_qualified        = 0;
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Private methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     private final void repositionScanForUpateOper()
0: 		throws StandardException
0:     {
0:         if (scan_state != SCAN_INPROGRESS)
0:             throw StandardException.newException(
0:                     SQLState.AM_SCAN_NOT_POSITIONED);
0: 
0: 
0:         if (!open_conglom.latchPage(scan_position))
0:         {
0:             throw StandardException.newException(
0:                     SQLState.AM_RECORD_NOT_FOUND, 
0:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
0:         }
0: 
0:         if (open_conglom.isUseUpdateLocks())
0:         {
0:             // we only have an U lock at this point which was acquired when the
0:             // scan positioned on the row, need to request an
0:             // X lock before we can actually perform the delete
0: 
0:             open_conglom.lockPositionForWrite(
0:                 scan_position, false /* not insert */, true);
0:         }
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Protected methods implementing mechanics of scanning rows:
0:      *
0:      *     positionAtInitScan()             - move scan state to SCAN_INIT
0:      *     positionAtStartForForwardScan()  - SCAN_INIT -> SCAN_INPROGRESS
0:      *     positionAtResumeScan()           - reposition after losing scan latch
0:      *     fetchRows()                      - move scan while in SCAN_INPROGRESS
0:      *     positionAtNextPage()             - move page while in SCAN_INPROGRESS
0:      *     positionAtDoneScan()             - SCAN_INPROGRESS -> SCAN_DONE
0:      *
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Move scan to the the SCAN_INIT state.
0:      * <p>
0:      * This routine is called to move the scan to the SCAN_INIT state.
0:      * It is used both for initialization of the ScanController and
0:      * by reopenScan().
0:      **/
0: 	protected void positionAtInitScan(
0:     DataValueDescriptor[]   startKeyValue,
0:     int                     startSearchOperator,
0:     Qualifier               qualifier[][],
0:     DataValueDescriptor[]   stopKeyValue,
0:     int                     stopSearchOperator,
0:     RowPosition             pos)
0:         throws StandardException
0:     {
0:         // startKeyValue init.
0: 	    this.init_startKeyValue         = startKeyValue;
0: 		if (RowUtil.isRowEmpty(this.init_startKeyValue, (FormatableBitSet) null))
0: 			this.init_startKeyValue = null;
0: 
0:         // startSearchOperator init.
0: 	    this.init_startSearchOperator   = startSearchOperator;
0: 
0:         // qualifier init.
0:         if ((qualifier != null) && (qualifier .length == 0))
0:             qualifier = null;
0:         this.init_qualifier             = qualifier;
0: 
0:         // TODO (mikem) - this could be more efficient, by writing
0:         // code to figure out length of row, but scratch row is cached
0:         // so allocating it here is probably not that bad.
0:         init_fetchDesc = 
0:             new FetchDescriptor(
0:               (open_conglom.getRuntimeMem().get_scratch_row()).length,
0:               init_scanColumnList,
0:               init_qualifier);
0: 
0:         // stopKeyValue init.
0: 	    this.init_stopKeyValue          = stopKeyValue;
0:         if (RowUtil.isRowEmpty(this.init_stopKeyValue, (FormatableBitSet) null))
0:             this.init_stopKeyValue = null;
0: 
0:         // stopSearchOperator init.
0: 	    this.init_stopSearchOperator    = stopSearchOperator;
0: 
0:         // reset the "current" position to starting condition.
0:         pos.init();
0: 
0: 
0:         // Verify that all columns in start key value, stop key value, and
0:         // qualifiers are present in the list of columns described by the
0:         // scanColumnList.
0:         if (SanityManager.DEBUG)
0:         {
0:             if (init_scanColumnList != null)
0:             {
0:                 // verify that all columns specified in qualifiers, start
0:                 // and stop positions are specified in the scanColumnList.  
0:                 
0:                 FormatableBitSet required_cols;
0: 
0:                 if (qualifier != null)
0:                     required_cols = RowUtil.getQualifierBitSet(qualifier);
0:                 else
0:                     required_cols = new FormatableBitSet(0);
0: 
0:                 // add in start columns
0:                 if (this.init_startKeyValue != null)
0:                 {
0: 					required_cols.grow(this.init_startKeyValue.length);
0:                     for (int i = 0; i < this.init_startKeyValue.length; i++)
0:                         required_cols.set(i);
0:                 }
0: 
0:                 if (this.init_stopKeyValue != null)
0:                 {
0: 					required_cols.grow(this.init_stopKeyValue.length);
0:                     for (int i = 0; i < this.init_stopKeyValue.length; i++)
0:                         required_cols.set(i);
0:                 }
0: 
0:                 FormatableBitSet required_cols_and_scan_list = 
0:                     (FormatableBitSet) required_cols.clone();
0: 
0:                 required_cols_and_scan_list.and(init_scanColumnList);
0: 
0: 				// FormatableBitSet equals requires the two FormatableBitSets to be of same
0: 				// length.
0: 				required_cols.grow(init_scanColumnList.size());
0: 
0:                 if (!required_cols_and_scan_list.equals(required_cols))
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "Some column specified in a Btree " +
0:                         " qualifier/start/stop list is " +
0:                         "not represented in the scanColumnList." +
0:                         "\n:required_cols_and_scan_list = " + 
0:                             required_cols_and_scan_list + 
0:                         "\n;required_cols = " + required_cols +
0:                         "\n;init_scanColumnList = " + init_scanColumnList);
0:                 }
0:             }
0: 		} 
0: 
0:         // Scan is fully initialized and ready to go.
0:         scan_state = SCAN_INIT;
0:     }
0: 
0: 
0:     /**
0:      * Reposition the scan upon entering the fetchRows loop.
0:      * <p>
0:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
0:      * Do work necessary to look at rows in the current page of the scan.
0:      * <p>
0:      * The default implementation uses a record handle to maintain a scan
0:      * position.  It will get the latch again on the current
0:      * scan position and set the slot to the current record handle.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtResumeScan(
0:     RowPosition pos)
0: 		throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 scan_position.current_rh != null, this.toString()); 
0:         }
0: 
0:         // reposition the scan at the row just before the next one to return.
0:         // This routine handles the mess of repositioning if the row or the
0:         // page has disappeared. This can happen if a lock was not held on the
0:         // row while not holding the latch.
0:         open_conglom.latchPageAndRepositionScan(scan_position);
0:     }
0: 
0:     /**
0:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
0:      * <p>
0:      * This routine is called to move the scan from SCAN_INIT to 
0:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
0:      * that scan_position is set such that calling the generic 
0:      * scan loop will reach the first row of the scan.  Note that this
0:      * usually means setting the scan_postion to one before the 1st 
0:      * row to be returned.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtStartForForwardScan(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         if (pos.current_rh == null)
0:         {
0:             // 1st positioning of scan (delayed from openScan).
0:             pos.current_page = 
0:                 open_conglom.getContainer().getFirstPage();
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     pos.current_page.getPageNumber() == 
0:                     ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:                 if (pos.current_page.recordCount() < 1)
0:                     SanityManager.THROWASSERT(
0:                         "record count = " + pos.current_page.recordCount());
0:             }
0: 
0:             // set up for scan to continue at beginning of first page just
0:             // after first first control row on first page.
0:             pos.current_slot = Page.FIRST_SLOT_NUMBER;
0:         }
0:         else
0:         {
0:             // 1st positioning of scan following a reopenScanByRowLocation
0: 
0:             // reposition the scan at the row just before the next one to 
0:             // return.  This routine handles the mess of repositioning if the 
0:             // row or the page has disappeared. This can happen if a lock was 
0:             // not held on the row while not holding the latch.
0:             open_conglom.latchPageAndRepositionScan(pos);
0: 
0:             // set up for scan to at the specified record handle (position one
0:             // before it so that the loop increment and find it).
0:             pos.current_slot -= 1;
0:         }
0: 
0:         pos.current_rh    = null;
0:         this.stat_numpages_visited  = 1;
0:         this.scan_state             = SCAN_INPROGRESS;
0:     }
0: 
0:     /**
0:      * Position scan to slot before first slot on next page.
0:      * <p>
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtNextPage(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         // The current_page can become null, in a rare multi-user case, where
0:         // all pages in the heap are deallocated, in the middle of the scan
0:         // loop, when no latches are held, and the scan is waiting on a lock.
0:         // In this case the lockPositionForRead code, has nowhere good to 
0:         // position the scan, so it just sets the page to null and returns.
0:         if (pos.current_page != null)
0:         {
0:             // save current page number.
0:             long pageid = pos.current_page.getPageNumber();
0: 
0:             // unlatch old page.
0:             pos.unlatch();
0: 
0:             // latch page after current page number.
0:             pos.current_page = 
0:                 open_conglom.getContainer().getNextPage(pageid);
0: 
0:             // set up for scan to continue at beginning of this new page.
0:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
0:         }
0:     }
0: 
0:     /**
0:      * Do any necessary work to complete the scan.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtDoneScan(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         // Unlatch current page if any.
0:         pos.unlatch();
0: 
0:         // unlock the previous row.
0:         if (scan_position.current_rh != null)
0:         {
0:             open_conglom.unlockPositionAfterRead(scan_position);
0:             scan_position.current_rh = null;
0:         }
0: 
0:         this.scan_state = SCAN_DONE;
0:     }
0: 
0: 	public void reopenScanByRowLocation(
0:     RowLocation startRowLocation,
0:     Qualifier qualifier[][])
0:         throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     /**************************************************************************
0:      * Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Create object which represents the scan position.
0:      * <p>
0:      * Designed so that extending classes can override and allocate 
0:      * implementation specific row position's.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected RowPosition allocateScanPosition()
0:         throws StandardException
0:     {
0:         return(new RowPosition());
0:     }
0: 
0:     /**
0:      * Fetch the next N rows from the table.
0:      * <p>
0:      * Utility routine used by both fetchSet() and fetchNextGroup().
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected int fetchRows(
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           rowloc_array,
0:     BackingStoreHashtable   hash_table,
0:     long                    max_rowcnt,
0:     int[]                   key_column_numbers)
0:         throws StandardException
0: 	{
0:         int                     ret_row_count           = 0;
0:         DataValueDescriptor[]   fetch_row               = null;
0: 
0:         if (max_rowcnt == -1)
0:             max_rowcnt = Long.MAX_VALUE;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (row_array != null)
0:             {
0:                 SanityManager.ASSERT(row_array[0] != null,
0:                     "first array slot in fetchNextGroup() must be non-null.");
0:                 SanityManager.ASSERT(hash_table == null);
0:             }
0:             else
0:             {
0:                 SanityManager.ASSERT(hash_table != null);
0:             }
0:         }
0: 
0:         if (this.scan_state == SCAN_INPROGRESS)
0:         {
0:             positionAtResumeScan(scan_position);
0:         }
0:         else if (this.scan_state == SCAN_INIT)
0:         {
0:             positionAtStartForForwardScan(scan_position);
0: 
0:         }
0:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
0:         {
0:             open_conglom.reopen();
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     scan_position.current_rh != null, this.toString()); 
0:             }
0: 
0:             // reposition the scan at the row just before the next one to 
0:             // return.
0:             // This routine handles the mess of repositioning if the row or 
0:             // the page has disappeared. This can happen if a lock was not 
0:             // held on the row while not holding the latch.
0:             open_conglom.latchPageAndRepositionScan(scan_position);
0: 
0:             this.scan_state = SCAN_INPROGRESS;
0:         }
0:         else if (this.scan_state == SCAN_HOLD_INIT)
0:         {
0:             open_conglom.reopen();
0: 
0:             positionAtStartForForwardScan(scan_position);
0: 
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
0: 
0:             return(0);
0:         }
0: 
0:         // At this point:
0:         // scan_position.current_page is latched.  
0:         // scan_position.current_slot is the slot on scan_position.current_page
0:         // just before the "next" record this routine should process.
0: 
0:         // loop through successive pages and successive slots on those
0:         // pages.  Stop when either the last page is reached 
0:         // (scan_position.current_page will be null).  
0:         // Along the way apply qualifiers to skip rows which don't qualify.
0: 
0: 		while (scan_position.current_page != null)
0: 		{
0: 			while ((scan_position.current_slot + 1) < 
0:                     scan_position.current_page.recordCount())
0: 			{
0:                 // unlock the previous row.
0:                 if (scan_position.current_rh != null)
0:                 {
0:                     open_conglom.unlockPositionAfterRead(scan_position);
0: 
0:                 }
0:                 // Allocate a new row to read the row into.
0:                 if (fetch_row == null)
0:                 {
0:                     if (hash_table == null)
0:                     {
0:                          // point at allocated row in array if one exists.
0:                         if (row_array[ret_row_count] == null)
0:                         {
0:                             row_array[ret_row_count] = 
0:                               open_conglom.getRuntimeMem().get_row_for_export();
0:                         }
0: 
0:                         fetch_row = row_array[ret_row_count];
0:                     }
0:                     else
0:                     {
0:                         fetch_row = 
0:                             open_conglom.getRuntimeMem().get_row_for_export();
0:                     }
0:                 }
0: 
0:                 // move scan current position forward.
0:                 scan_position.positionAtNextSlot();
0: 
0:                 // Lock the row.
0:                 boolean lock_granted_while_latch_held = 
0:                     open_conglom.lockPositionForRead(
0:                         scan_position, (RowPosition) null, true, true);
0: 
0:                 if (!lock_granted_while_latch_held)
0:                 {
0:                     // if lock could not be granted while holding
0:                     // latch, then the row may either be on the same page 
0:                     // or it may no longer exist, this implementation does not
0:                     // handle rows which move to different pages.  
0:                     // 
0:                     // If the row moved on the same page then 
0:                     // lockPositionForRead() will have automatically updated
0:                     // the scan_postion argument to point to it, and we 
0:                     // wil now have a latch and a lock on that row.
0:                     //
0:                     // If the row no longer exists then the 
0:                     // "moveForwardIfRowDisappears" argument makes this routine
0:                     // find the "next" row in the heap and position on it.  If
0:                     // a valid row exists in the current page to position on,
0:                     // then lockPositionForRead() will position on it, get
0:                     // a lock on it, and return with a latch on the page.  
0:                     // Otherwise the routine will return with current_slot == -1
0:                     // and it is up to this routine to continue the scan as
0:                     // normal at the top of the loop.
0: 
0:                     if (scan_position.current_page == null)
0:                     {
0:                         // page has been unlatched and the scan is done, there
0:                         // are no more pages.  getNextPage() has been coded to
0:                         // handle a null current_page.
0: 
0:                         break;
0:                     }
0:                     else if (scan_position.current_slot == -1)
0:                     {
0:                         // This means that lockPositionForRead() had to 
0:                         // reposition the scan forward to a new page, because 
0:                         // the row the scan was locking was purged, when the 
0:                         // latch was released to wait on the lock.  In this 
0:                         // case just jump back to the top of loop and continue 
0:                         // scan.
0: 
0:                         if (SanityManager.DEBUG)
0:                         {
0:                             SanityManager.ASSERT(
0:                                 scan_position.current_rh == null);
0:                         }
0: 
0:                         continue;
0:                     }
0:                 }
0: 
0:                 this.stat_numrows_visited++;
0: 
0:                 // lockRowAtPosition set pos.current_rh as part of getting lock.
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT(scan_position.current_rh != null);
0: 
0:                     // make sure current_rh and current_slot are in sync
0:                     if (scan_position.current_slot !=
0:                             scan_position.current_page.getSlotNumber(
0:                                 scan_position.current_rh))
0:                     {
0:                         SanityManager.THROWASSERT(
0:                             "current_slot = " + scan_position.current_slot +
0:                             "current_rh = " + scan_position.current_rh +
0:                             "current_rh.slot = " + 
0:                             scan_position.current_page.getSlotNumber(
0:                                 scan_position.current_rh));
0:                     }
0:                 }
0: 
0:                 // fetchFromSlot returns null if row does not qualify.
0: 
0:                 scan_position.current_rh_qualified =
0:                     (scan_position.current_page.fetchFromSlot(
0:                         scan_position.current_rh, 
0:                         scan_position.current_slot, 
0:                         fetch_row, 
0:                         init_fetchDesc,
0:                         false) != null);
0: 
0:                 if (scan_position.current_rh_qualified)
0:                 {
0:                     // qualifying row.  
0: 
0: 
0:                     // scan_position.current_rh is save position of scan while 
0:                     // latch is not held.  It currently points at the 
0:                     // scan_position.current_slot in search (while latch is 
0:                     // held).
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         // make sure current_rh and current_slot are in sync
0:                         SanityManager.ASSERT(
0:                             scan_position.current_slot ==
0:                                 scan_position.current_page.getSlotNumber(
0:                                     scan_position.current_rh));
0:                     }
0: 
0:                     // Found qualifying row.  Done fetching rows for the group?
0:                     ret_row_count++;
0:                     stat_numrows_qualified++;
0: 
0: 
0:                     if (hash_table == null)
0:                     {
0:                         if (rowloc_array != null)
0:                         {
0:                             // if requested return the associated row location.
0:                             setRowLocationArray(
0:                                 rowloc_array, ret_row_count - 1, scan_position);
0:                         }
0: 
0:                         fetch_row = null;
0:                     }
0:                     else
0:                     {
0:                         if (hash_table.put(false, fetch_row))
0:                         {
0:                             // The row was inserted into the hash table so we
0:                             // need to create a new row next time through.
0:                             fetch_row = null;
0:                         }
0:                     }
0: 
0:                     if (max_rowcnt <= ret_row_count) 
0:                     {
0:                         // exit fetch row loop and return to the client.
0:                         scan_position.unlatch();
0: 
0:                         if (SanityManager.DEBUG)
0:                         {
0:                             SanityManager.ASSERT(
0:                                 scan_position.current_rh != null);
0:                         }
0: 
0:                         return(ret_row_count);
0:                     }
0:                 }
0: 			}
0: 
0:             positionAtNextPage(scan_position);
0: 
0:             this.stat_numpages_visited++;
0: 		}
0: 
0:         // Reached last page of scan.
0:         positionAtDoneScan(scan_position);
0: 
0:         // we need to decrement when we stop scan at the end of the table.
0:         this.stat_numpages_visited--;
0: 
0: 		return(ret_row_count);
0:     }
0: 
0: 
0:     /**
0:     Reposition the current scan.  This call is semantically the same as if
0:     the current scan had been closed and a openScan() had been called instead.
0:     The scan is reopened against the same conglomerate, and the scan
0:     is reopened with the same "scan column list", "hold" and "forUpdate"
0:     parameters passed in the original openScan.  
0:     <p>
0:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
0:     rather they continue to accumulate.
0:     <p>
0:     Note that this operation is currently only supported on Heap conglomerates.
0:     Also note that order of rows within are heap are not guaranteed, so for
0:     instance positioning at a RowLocation in the "middle" of a heap, then
0:     inserting more data, then continuing the scan is not guaranteed to see
0:     the new rows - they may be put in the "beginning" of the heap.
0: 
0: 	@param startRowLocation  An existing RowLocation within the conglomerate,
0:     at which to position the start of the scan.  The scan will begin at this
0:     location and continue forward until the end of the conglomerate.  
0:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
0:     had been deleted), will result in an exception being thrown when the 
0:     first next operation is attempted.
0: 
0: 	@param qualifier An array of qualifiers which, applied
0: 	to each key, restrict the rows returned by the scan.  Rows
0: 	for which any one of the qualifiers returns false are not
0: 	returned by the scan. If null, all rows are returned.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     protected void reopenScanByRecordHandle(
0:     RecordHandle startRecordHandle,
0:     Qualifier qualifier[][])
0:         throws StandardException
0:     {
0:         // initialize scan position parameters at beginning of scan
0:         this.scan_state = 
0:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
0: 
0:         // position the scan at the row before the given record id, so that
0:         // the first "next" starts on the given row.
0:         scan_position.current_rh = startRecordHandle;
0:     }
0: 
0:     protected void setRowLocationArray(
0:     RowLocation[]   rowloc_array,
0:     int             index,
0:     RowPosition     pos)
0:         throws StandardException
0:     {
0:         throw(StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * abstract protected Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods of This class:
0:      **************************************************************************
0:      */
0: 	public void init(
0:     OpenConglomerate                open_conglom,
0: 	FormatableBitSet				            scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]	        stopKeyValue,
0:     int                             stopSearchOperator)
0:         throws StandardException
0:     {
0:         super.init(open_conglom);
0: 
0:         // RESOLVE (mikem) - move this into runtime_mem
0:         scan_position = allocateScanPosition();
0: 
0:         // remember inputs
0:         init_scanColumnList         = scanColumnList;
0: 
0:         positionAtInitScan(
0:             startKeyValue,
0:             startSearchOperator,
0:             qualifier,
0:             stopKeyValue,
0:             stopSearchOperator,
0:             scan_position);
0:     }
0: 
0: 
0:     public final int getNumPagesVisited()
0:     {
0:         return(stat_numpages_visited);
0:     }
0:     public final int getNumRowsVisited()
0:     {
0:         return(stat_numrows_visited);
0:     }
0:     public final int getNumRowsQualified()
0:     {
0:         return(stat_numrows_qualified);
0:     }
0:     public final FormatableBitSet getScanColumnList()
0:     {
0:         return(init_scanColumnList);
0:     }
0:     public final DataValueDescriptor[] getStartKeyValue()
0:     {
0:         return(init_startKeyValue);
0:     }
0:     public final int getStartSearchOperator()
0:     {
0:         return(init_startSearchOperator);
0:     }
0:     public final DataValueDescriptor[] getStopKeyValue()
0:     {
0:         return(init_stopKeyValue);
0:     }
0:     public final int getStopSearchOperator()
0:     {
0:         return(init_stopSearchOperator);
0:     }
0:     public final Qualifier[][] getQualifier()
0:     {
0:         return(init_qualifier);
0:     }
0: 
0: 
0:     public final int getScanState()
0:     {
0:         return(scan_state);
0:     }
0:     public final void setScanState(int state)
0:     {
0:         scan_state = state;
0:     }
0:     public final RowPosition getScanPosition()
0:     {
0:         return(scan_position);
0:     }
0:     public final void setScanPosition(RowPosition   pos)
0:     {
0:         scan_position = pos;
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods implementing ScanController:
0:      **************************************************************************
0:      */
0:     private void closeScan()
0:         throws StandardException
0:     {
0:         super.close();
0: 
0: 		// If we are closed due to catching an error in the middle of init,
0: 		// xact_manager may not be set yet. 
0: 		if (open_conglom.getXactMgr() != null)
0: 			open_conglom.getXactMgr().closeMe(this);
0: 
0:         // help the garbage collector.
0:         this.init_qualifier         = null;
0:         init_scanColumnList         = null;
0:         init_startKeyValue          = null;
0:         init_stopKeyValue           = null;
0:     }
0: 
0:     public void close()
0:         throws StandardException
0: 	{
0:         // Finish the scan - this may release locks if read committed and scan
0:         // still holds some locks, and close comes before scan.next() returned
0:         // that scan was done.
0:         positionAtDoneScan(scan_position);
0: 
0:         closeScan();
0: 	}
0: 
0:     public boolean closeForEndTransaction(
0:     boolean closeHeldScan)
0:         throws StandardException
0: 	{
0:         if ((!open_conglom.getHold()) || closeHeldScan) 
0:         {
0:             // close the scan as part of the commit/abort
0: 
0:             this.scan_state = SCAN_DONE;
0: 
0:             closeScan();
0: 
0:             return(true);
0:         }
0:         else
0:         {
0:             super.close();
0: 
0:             // allow the scan to continue after the commit.
0:             // locks and latches will be released as part of the commit, so
0:             // no need to release them by hand.
0: 
0:             if (this.scan_state == SCAN_INPROGRESS)
0:                 this.scan_state = SCAN_HOLD_INPROGRESS;
0:             else if (this.scan_state == SCAN_INIT)
0:                 this.scan_state = SCAN_HOLD_INIT;
0: 
0: 
0:             return(false);
0:         }
0: 	}
0: 
0: 
0:     /**
0: 	@see ScanController#delete
0: 	**/
0:     public boolean delete()
0: 		throws StandardException
0: 	{
0:         repositionScanForUpateOper();
0: 
0:         boolean ret_val = true;
0: 
0:         // RESOLVE (mikem) - RECID - performance could be better if we did not
0:         // have to call isDeletedAtSlot().
0: 
0:         // RESOLVE (mikem) - share code below with conglomerateController.
0: 
0:         if (scan_position.current_page.isDeletedAtSlot(
0:                 scan_position.current_slot))
0:         {
0:             ret_val = false;
0:         }
0:         else
0:         {
0:             // Delete the row 
0:             scan_position.current_page.deleteAtSlot(
0:                 scan_position.current_slot, true, (LogicalUndo) null);
0: 
0:             if (scan_position.current_page.nonDeletedRecordCount() == 0)
0:             {
0:                 queueDeletePostCommitWork(scan_position);
0:             }
0:         }
0: 
0:         scan_position.unlatch();
0: 
0:         return(ret_val);
0: 	}
0: 
0: 
0:     /**
0:      * A call to allow client to indicate that current row does not qualify.
0:      * <p>
0:      * Indicates to the ScanController that the current row does not
0:      * qualify for the scan.  If the isolation level of the scan allows, 
0:      * this may result in the scan releasing the lock on this row.
0:      * <p>
0:      * Note that some scan implimentations may not support releasing locks on 
0:      * non-qualifying rows, or may delay releasing the lock until sometime
0:      * later in the scan (ie. it may be necessary to keep the lock until 
0:      * either the scan is repositioned on the next row or page).
0:      * <p>
0:      * This call should only be made while the scan is positioned on a current
0:      * valid row.
0:      * RESOLVE (mikem-05/29/98) - Implement this when we support levels of
0:      * concurrency less than serializable.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void didNotQualify()
0:         throws StandardException
0:     {
0:     }
0: 
0:     /**
0:      * Insert all rows that qualify for the current scan into the input
0:      * Hash table.  
0:      * <p>
0:      * This routine scans executes the entire scan as described in the 
0:      * openScan call.  For every qualifying unique row value an entry is
0:      * placed into the HashTable. For unique row values the entry in the
0:      * Hashtable has a key value of the object stored in 
0:      * row[key_column_number], and the value of the data is row.  For row 
0:      * values with duplicates, the key value is also row[key_column_number], 
0:      * but the value of the data is a Vector of
0:      * rows.  The caller will have to call "instanceof" on the data value
0:      * object if duplicates are expected, to determine if the data value
0:      * of the Hashtable entry is a row or is a Vector of rows.
0:      * <p>
0:      * Note, that for this routine to work efficiently the caller must 
0:      * ensure that the object in row[key_column_number] implements 
0:      * the hashCode and equals method as appropriate for it's datatype.
0:      * <p>
0:      * It is expected that this call will be the first and only call made in
0:      * an openscan.  Qualifiers and stop position of the openscan are applied
0:      * just as in a normal scan.  This call is logically equivalent to the 
0:      * caller performing the following:
0:      *
0:      * import java.util.Hashtable;
0:      *
0:      * hash_table = new Hashtable();
0:      *
0:      * while (next())
0:      * {
0:      *     row = create_new_row();
0:      *     fetch(row);
0:      *     if ((duplicate_value = 
0:      *         hash_table.put(row[key_column_number], row)) != null)
0:      *     {
0:      *         Vector row_vec;
0:      *
0:      *         // inserted a duplicate
0:      *         if ((duplicate_value instanceof vector))
0:      *         {
0:      *             row_vec = (Vector) duplicate_value;
0:      *         }
0:      *         else
0:      *         {
0:      *             // allocate vector to hold duplicates
0:      *             row_vec = new Vector(2);
0:      *
0:      *             // insert original row into vector
0:      *             row_vec.addElement(duplicate_value);
0:      *
0:      *             // put the vector as the data rather than the row
0:      *             hash_table.put(row[key_column_number], row_vec);
0:      *         }
0:      *         
0:      *         // insert new row into vector
0:      *         row_vec.addElement(row);
0:      *     }
0:      * }
0:      * <p>
0:      * The columns of the row will be the standard columns returned as
0:      * part of a scan, as described by the validColumns - see openScan for
0:      * description.
0:      * RESOLVE - is this ok?  or should I hard code somehow the row to
0:      *           be the first column and the row location?
0:      * <p>
0:      * Currently it is only possible to hash on the first column in the
0:      * conglomerate, in the future we may change the interface to allow
0:      * hashing either on a different column or maybe on a combination of
0:      * columns.
0:      * <p>
0:      * No overflow to external storage is provided, so calling this routine
0:      * on a 1 gigabyte conglomerate will incur at least 1 gigabyte of memory
0:      * (probably failing with a java out of memory condition).  If this
0:      * routine gets an out of memory condition, or if "max_rowcnt" is 
0:      * exceeded then then the routine will give up, empty the Hashtable, 
0:      * and return "false."
0:      * <p>
0:      * On exit from this routine, whether the fetchSet() succeeded or not
0:      * the scan is complete, it is positioned just the same as if the scan
0:      * had been drained by calling "next()" until it returns false (ie. 
0:      * fetchNext() and next() calls will return false).  
0:      * reopenScan() can be called to restart the scan.
0:      * <p>
0:      *
0:      * RESOLVE - until we get row counts what should we do for sizing the
0:      *           the size, capasity, and load factor of the hash table.
0:      *           For now it is up to the caller to create the Hashtable,
0:      *           Access does not reset any parameters.
0:      * <p>
0:      * RESOLVE - I am not sure if access should be in charge of allocating
0:      *           the new row objects.  I know that I can do this in the
0:      *           case of btree's, but I don't think I can do this in heaps.
0:      *           Maybe this is solved by work to be done on the sort 
0:      *           interface.
0:      *
0:      *
0: 	 * @return boolean indicating that the fetch set succeeded.  If it failed
0:      *                 Hashtable.clear() will be called leaving an empty 
0:      *                 table.
0:      *
0:      * @param max_rowcnt        The maximum number of rows to insert into the 
0:      *                          Hash table.  Pass in -1 if there is no maximum.
0:      * @param key_column_numbers The column numbers of the columns in the
0:      *                          scan result row to be the key to the Hashtable.
0:      *                          "0" is the first column in the scan result
0:      *                          row (which may be different than the first
0:      *                          column in the row in the table of the scan).
0:      * @param hash_table        The java HashTable to load into.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void fetchSet(
0:     long                    max_rowcnt,
0:     int[]                   key_column_numbers,
0:     BackingStoreHashtable   hash_table)
0:         throws StandardException
0: 	{
0:         fetchRows(
0:             (DataValueDescriptor[][]) null,
0:             (RowLocation[]) null,
0:             hash_table,
0:             max_rowcnt,
0:             key_column_numbers);
0: 
0:         return;
0:     }
0: 
0:     /**
0:     Reposition the current scan.  This call is semantically the same as if
0:     the current scan had been closed and a openScan() had been called instead.
0:     The scan is reopened with against the same conglomerate, and the scan
0:     is reopened with the same "hold" and "forUpdate" parameters passed in
0:     the original openScan.  The previous template row continues to be used.
0: 
0:     @param template A prototypical row which the scan may use ot
0: 	maintain its position in the conglomerate.  Not all access method
0: 	scan types will require this, if they don't it's ok to pass in null.
0:     In order to scan a conglomerate one must allocate 2 separate "row"
0:     templates.  The "row" template passed into openScan is for the private
0:     use of the scan itself, and no access to it should be made
0:     by the caller while the scan is still open.  Because of this the 
0:     scanner must allocate another "row" template to hold the values returned 
0:     from fetch().
0: 
0: 	@param startKeyValue  An indexable row which holds a 
0: 	(partial) key value which, in combination with the
0: 	startSearchOperator, defines the starting position of
0: 	the scan.  If null, the starting position of the scan
0: 	is the first row of the conglomerate.
0: 	
0: 	@param startSearchOperation an operator which defines
0: 	how the startKeyValue is to be searched for.  If 
0:     startSearchOperation is ScanController.GE, the scan starts on
0: 	the first row which is greater than or equal to the 
0: 	startKeyValue.  If startSearchOperation is ScanController.GT,
0: 	the scan starts on the first row whose key is greater than
0: 	startKeyValue.  The startSearchOperation parameter is 
0: 	ignored if the startKeyValue parameter is null.
0: 
0: 	@param qualifier An array of qualifiers which, applied
0: 	to each key, restrict the rows returned by the scan.  Rows
0: 	for which any one of the qualifiers returns false are not
0: 	returned by the scan. If null, all rows are returned.
0: 
0: 	@param stopKeyValue  An indexable row which holds a 
0: 	(partial) key value which, in combination with the
0: 	stopSearchOperator, defines the ending position of
0: 	the scan.  If null, the ending position of the scan
0: 	is the last row of the conglomerate.
0: 	
0: 	@param stopSearchOperation an operator which defines
0: 	how the stopKeyValue is used to determine the scan stopping
0: 	position. If stopSearchOperation is ScanController.GE, the scan 
0: 	stops just before the first row which is greater than or
0: 	equal to the stopKeyValue.  If stopSearchOperation is
0: 	ScanController.GT, the scan stops just before the first row whose
0: 	key is greater than	startKeyValue.  The stopSearchOperation
0: 	parameter is ignored if the stopKeyValue parameter is null.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0: 	public void reopenScan(
0:     DataValueDescriptor[]   startKeyValue,
0:     int                     startSearchOperator,
0:     Qualifier               qualifier[][],
0:     DataValueDescriptor[]   stopKeyValue,
0:     int                     stopSearchOperator)
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             if (!open_conglom.getHold())
0:             {
0:                 SanityManager.ASSERT(
0:                     !open_conglom.isClosed(), 
0:                     "GenericScanController.reopenScan() called on a non-held closed scan.");
0:             }
0:         }
0: 
0:         // initialize scan position parameters at beginning of scan
0:         this.scan_state = 
0:             (!open_conglom.getHold() ? SCAN_INIT : SCAN_HOLD_INIT);
0: 
0:         scan_position.current_rh   = null;
0:     }
0: 
0:     /**
0: 	@see ScanController#replace
0: 	**/
0:     public boolean replace(
0:     DataValueDescriptor[]   row, 
0:     FormatableBitSet                 validColumns)
0: 		throws StandardException
0: 	{
0:         repositionScanForUpateOper();
0: 
0:         boolean ret_val = 
0:             scan_position.current_page.update(
0:                 scan_position.current_rh, row, validColumns);
0: 
0:         scan_position.unlatch();
0: 
0:         return(ret_val);
0: 	}
0: 
0:     /**
0:     Returns true if the current position of the scan still qualifies
0:     under the set of qualifiers passed to the openScan().  When called
0:     this routine will reapply all qualifiers against the row currently
0:     positioned and return true if the row still qualifies.  If the row
0:     has been deleted or no longer passes the qualifiers then this routine
0:     will return false.
0:     
0:     This case can come about if the current scan
0:     or another scan on the same table in the same transaction 
0:     deleted the row or changed columns referenced by the qualifier after 
0:     the next() call which positioned the scan at this row.  
0: 
0:     Note that for comglomerates which don't support update, like btree's, 
0:     there is no need to recheck the qualifiers.
0: 
0:     The results of a fetch() performed on a scan positioned on 
0:     a deleted row are undefined.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     public boolean doesCurrentPositionQualify()
0: 		throws StandardException
0:     {
0:         if (scan_state != SCAN_INPROGRESS)
0:             throw StandardException.newException(
0:                     SQLState.AM_SCAN_NOT_POSITIONED);
0: 
0:         if (!open_conglom.latchPage(scan_position))
0:         {
0:             return(false);
0:         }
0: 
0:         DataValueDescriptor row[] = 
0:             open_conglom.getRuntimeMem().get_scratch_row();
0: 
0:         // If fetchFromSlot returns null it either means the row is deleted,
0:         // or the qualifier evaluates to false.
0:         
0:         boolean ret_val = 
0:             (scan_position.current_page.fetchFromSlot(
0:                 scan_position.current_rh, 
0:                 scan_position.current_slot, 
0:                 row,
0:                 init_fetchDesc,
0:                 false) != null);
0: 
0:         scan_position.unlatch();
0: 
0:         return(ret_val);
0:     }
0: 
0:     /**
0: 	@see ScanController#fetch
0: 	**/
0: 	public void fetch(DataValueDescriptor[] row)
0: 		throws StandardException
0: 	{
0:         if (scan_state != SCAN_INPROGRESS)
0:             throw StandardException.newException(
0:                     SQLState.AM_SCAN_NOT_POSITIONED);
0: 
0:         if (!open_conglom.latchPage(scan_position))
0:         {
0:             throw StandardException.newException(
0:                     SQLState.AM_RECORD_NOT_FOUND, 
0:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
0:         }
0: 
0:         // RESOLVE (mikem) - should this call apply the qualifiers again?
0:         RecordHandle rh = 
0:             scan_position.current_page.fetchFromSlot(
0:                 scan_position.current_rh, 
0:                 scan_position.current_slot, 
0:                 row, 
0:                 init_fetchDesc, 
0:                 false);
0: 
0:         scan_position.unlatch();
0: 
0:         if (rh == null)
0:         {
0:             /*
0:             if (SanityManager.DEBUG)
0:             {
0:                 if (isCurrentPositionDeleted())
0:                     SanityManager.THROWASSERT(
0:                         "The record (" + 
0:                         open_conglom.getContainer().getId() +
0:                         ", " +
0:                         scan_position.current_rh.getPageNumber() + ", " +
0:                         scan_position.current_rh.getId() + ") " +
0:                         "being fetched is marked deleted on page.:\n");
0:             }
0:             */
0: 
0:             throw StandardException.newException(
0:                     SQLState.AM_RECORD_NOT_FOUND, 
0:                     open_conglom.getContainer().getId(),
0:                     new Long(scan_position.current_rh.getId()));
0:         }
0: 
0:         return;
0: 	}
0: 
0: 	/**
0: 	Fetch the location of the current position in the scan.
0: 	@see ScanController#fetchLocation
0: 
0: 	@exception  StandardException  Standard exception policy.
0: 	**/
0: 	public void fetchLocation(RowLocation templateLocation)
0: 		throws StandardException
0: 	{
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0: 	}
0: 
0:     /**
0:      * Return ScanInfo object which describes performance of scan.
0:      * <p>
0:      * Return ScanInfo object which contains information about the current
0:      * scan.
0:      * <p>
0:      *
0:      * @see ScanInfo
0:      *
0: 	 * @return The ScanInfo object which contains info about current scan.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ScanInfo getScanInfo()
0: 		throws StandardException
0:     {
0:         throw StandardException.newException(
0:                 SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0: 
0: 
0:     /**
0:     Returns true if the current position of the scan is at a 
0:     deleted row.  This case can come about if the current scan
0:     or another scan on the same table in the same transaction 
0:     deleted the row after the next() call which positioned the
0:     scan at this row.  
0: 
0:     The results of a fetch() performed on a scan positioned on 
0:     a deleted row are undefined.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     public boolean isCurrentPositionDeleted()
0: 		throws StandardException
0:     {
0:         if (scan_state != SCAN_INPROGRESS)
0:             throw StandardException.newException(
0:                     SQLState.AM_SCAN_NOT_POSITIONED);
0: 
0:         if (!open_conglom.latchPage(scan_position))
0:         {
0:             return(true);
0:         }
0: 
0:         boolean ret_val = 
0:             scan_position.current_page.isDeletedAtSlot(
0:                 scan_position.current_slot);
0: 
0:         scan_position.unlatch();
0: 
0:         return(ret_val);
0:     }
0: }
============================================================================