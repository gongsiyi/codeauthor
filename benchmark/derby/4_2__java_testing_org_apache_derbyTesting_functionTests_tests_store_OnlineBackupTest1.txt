2:7ddacaa: /*
4:7ddacaa: 
1:7ddacaa:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest1
1:7ddacaa: 
1:dff95a1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:    contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:    this work for additional information regarding copyright ownership.
1:dff95a1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:    (the "License"); you may not use this file except in compliance with
1:dff95a1:    the License.  You may obtain a copy of the License at
1:7ddacaa: 
1:7ddacaa:       http://www.apache.org/licenses/LICENSE-2.0
1:7ddacaa: 
1:7ddacaa:    Unless required by applicable law or agreed to in writing, software
1:7ddacaa:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ddacaa:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ddacaa:    See the License for the specific language governing permissions and
1:7ddacaa:    limitations under the License.
1:7ddacaa: 
2:7ddacaa:  */
1:7ddacaa: 
1:7ddacaa: package org.apache.derbyTesting.functionTests.tests.store;
1:7ddacaa: import java.sql.Connection;
1:7ddacaa: import java.sql.Statement;
1:7ddacaa: import java.sql.PreparedStatement;
1:7ddacaa: import java.sql.ResultSet;
1:7ddacaa: import java.sql.SQLException;
1:7ddacaa: import org.apache.derby.tools.ij;
1:7ddacaa: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:7ddacaa: 
1:7ddacaa: /*
1:7ddacaa:  * This class tests online backup when dml/ddl actions
1:7ddacaa:  * are running in parallel to the backup thread. 
1:7ddacaa:  *
1:7ddacaa:  * @version 1.0
1:7ddacaa:  */
1:7ddacaa: 
1:7ddacaa: public class OnlineBackupTest1 {
1:7ddacaa: 
1:7ddacaa: 	private static final String TEST_DATABASE_NAME = "wombat" ;
1:7ddacaa: 	private static final String TEST_TABLE_NAME   =    "emp";
1:7ddacaa:     private static final String TEST_TABLE_NAME_1 =    "emp_1";
1:7ddacaa:     private static final String TEST_TABLE_NAME_2 =    "emp_2";
1:7ddacaa:     private static final String BACKUP_PATH = "extinout/onlinebackuptest1";
1:7ddacaa: 
1:7ddacaa: 	public static void main(String[] argv) throws Throwable {
1:7ddacaa: 		
1:7ddacaa:         OnlineBackupTest1 test = new OnlineBackupTest1();
1:7ddacaa:    		ij.getPropertyArg(argv); 
1:7ddacaa: 
1:7ddacaa:         try {
1:7ddacaa:             test.runTest();
3:7ddacaa:         }
1:7ddacaa:         catch (SQLException sqle) {
1:7ddacaa: 			dumpSQLException(sqle);
1:7ddacaa: 		} 
1:7ddacaa:     }
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 	/*
1:7ddacaa: 	 * Test online backup with unlogged operations. And DML/DDL's
1:7ddacaa: 	 * running in paralel to the backup. After the backup is complete restore
1:7ddacaa: 	 * the database from the backup and performs consistency checks on the
1:7ddacaa: 	 * database to make sure backup was good one.  
1:7ddacaa: 	 */
1:7ddacaa: 	private void runTest() throws Exception {
1:7ddacaa: 		logMessage("Begin Online Backup Test1");
1:7ddacaa: 		Connection conn = ij.startJBMS();
1:7ddacaa: 		conn.setAutoCommit(false);
1:7ddacaa: 		DatabaseActions dbActions = new DatabaseActions(conn);
1:7ddacaa: 		//create the test  tables. 
1:7ddacaa: 		dbActions.createTable(TEST_TABLE_NAME);
1:7ddacaa:         dbActions.createTable(TEST_TABLE_NAME_1);
1:7ddacaa:         dbActions.createTable(TEST_TABLE_NAME_2);
1:7ddacaa:         conn.commit();
1:7ddacaa: 
1:7ddacaa:         // start first unlogged operation
1:7ddacaa: 		dbActions.startUnloggedAction(TEST_TABLE_NAME_1);
1:7ddacaa: 		logMessage("First Transaction with Unlogged Operation Started");
1:7ddacaa: 
1:7ddacaa:         // start second unlogged opearation
1:7ddacaa:         Connection conn1 = ij.startJBMS();
1:7ddacaa: 		conn1.setAutoCommit(false);
1:7ddacaa: 		DatabaseActions dbActions1 = new DatabaseActions(conn1);
1:7ddacaa: 		dbActions1.startUnloggedAction(TEST_TABLE_NAME_2);
1:7ddacaa: 		logMessage("Second Transaction with Unlogged Operation Started");
1:7ddacaa: 
1:7ddacaa:         // setup threads.
1:7ddacaa:         // start a  thread to perform online backup
1:7ddacaa: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1:7ddacaa: 		Thread backupThread = new Thread(backup, "BACKUP");
1:7ddacaa:         
1:7ddacaa:         // run some dml actions in another thread
1:e72bcdd:         Connection dmlConn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         DatabaseActions dmlActions = 
1:7ddacaa:             new DatabaseActions(DatabaseActions.DMLACTIONS, dmlConn);
1:7ddacaa: 		Thread dmlThread = new Thread(dmlActions, "DML_THREAD");
1:7ddacaa:         
1:7ddacaa:         // run some DDL create/drop tables in another thread
1:e72bcdd:         Connection ddlConn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:7ddacaa:         
1:7ddacaa:         DatabaseActions ddlActions = 
1:7ddacaa:             new DatabaseActions(DatabaseActions.CREATEDROPS, ddlConn);
1:7ddacaa:         Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
1:7ddacaa: 
1:7ddacaa:         try {
1:7ddacaa:             // start a  thread to perform online backup
1:7ddacaa:             backupThread.start();	
1:7ddacaa:             // wait for the backup to start
1:7ddacaa:             backup.waitForBackupToBegin();
1:7ddacaa:             logMessage("BACKUP STARTED");
1:7ddacaa: 
1:7ddacaa:             // run some dml actions in another thread
1:7ddacaa:             dmlThread.start();
1:7ddacaa: 
1:7ddacaa:             // run some DDL create/drop tables in another thread
1:7ddacaa:             ddlThread.start();
1:7ddacaa: 
1:7ddacaa:             // sleep for few seconds just to make sure backup thread is actually
1:7ddacaa:             // gone to a wait state for unlogged actions to commit and there is
1:7ddacaa:             // some ddl and dml activity in progress. 
1:7ddacaa:             java.lang.Thread.sleep(50000);
1:7ddacaa: 			
1:7ddacaa:             // backup should not even start doing real work before the
1:7ddacaa:             // unlogged transaction is commited
1:7ddacaa:             if(!backup.isRunning())
1:7ddacaa:                 logMessage("Backup is not waiting for unlogged actions to commit");
1:7ddacaa: 
1:7ddacaa:             // end the unlogged work transaction.
1:7ddacaa:             dbActions.endUnloggedAction(TEST_TABLE_NAME_1);
1:7ddacaa:             // end the unlogged work transaction.
1:7ddacaa:             dbActions1.endUnloggedAction(TEST_TABLE_NAME_2);
1:7ddacaa:         
1:7ddacaa:             backup.waitForBackupToEnd();
1:7ddacaa: 
1:7ddacaa:         }finally {
1:7ddacaa:             //stop all threads activities.
1:7ddacaa:             backupThread.join();
1:7ddacaa:             dmlActions.stopActivity();
1:7ddacaa:             ddlActions.stopActivity(); 
1:7ddacaa:             dmlThread.join();
1:7ddacaa:             ddlThread.join(); 
1:7ddacaa:         }        
1:7ddacaa:         // close the connections.
1:7ddacaa:         conn.close();
1:7ddacaa:         conn1.close();
1:7ddacaa:         dmlConn.close();
1:7ddacaa:         ddlConn.close() ;
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		//shutdown the test db 
1:7ddacaa: 		shutdown(TEST_DATABASE_NAME);
1:7ddacaa: 
1:7ddacaa: 		// restore the database from the backup and run some checks 
1:7ddacaa: 		backup.restoreFromBackup();
1:7ddacaa: 		logMessage("Restored From the Backup");
1:7ddacaa: 		runConsistencyChecker(TEST_DATABASE_NAME);
1:7ddacaa: 		logMessage("Consistency Check is Done");
1:7ddacaa: 		//shutdown the test db 
1:7ddacaa: 		shutdown(TEST_DATABASE_NAME);
1:7ddacaa: 		logMessage("End Online Backup Test1");
1:7ddacaa: 	}
1:7ddacaa: 
1:7ddacaa: 	
1:7ddacaa: 	/**
1:7ddacaa: 	 * Run some consistency checks.
1:7ddacaa: 	 * @param  dbName  consistency checks are performed on this database.
1:7ddacaa: 	 */
1:7ddacaa: 	void runConsistencyChecker(String dbName) throws SQLException {
1:e72bcdd:         Connection conn = TestUtil.getConnection(dbName, null);
1:7ddacaa: 		Statement stmt = conn.createStatement();
1:7ddacaa: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
1:7ddacaa:         //check the data in the EMP table.
1:7ddacaa:         DatabaseActions dbActions = new DatabaseActions(conn);
1:7ddacaa:         dbActions.select(TEST_TABLE_NAME);
1:7ddacaa:         dbActions.select(TEST_TABLE_NAME_1);
1:7ddacaa:         dbActions.select(TEST_TABLE_NAME_2);
1:7ddacaa: 		conn.close();
1:7ddacaa: 
1:7ddacaa: 	}
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		
1:7ddacaa: 	/**
1:7ddacaa: 	 * Shutdown the datbase
1:7ddacaa: 	 * @param  dbName  Name of the database to shutdown.
1:7ddacaa: 	 */
1:7ddacaa: 	void shutdown(String dbName) {
1:7ddacaa: 
1:7ddacaa: 		try{
1:7ddacaa: 			//shutdown
1:e72bcdd: 			TestUtil.getConnection(dbName, "shutdown=true");
1:7ddacaa: 		}catch(SQLException se){
1:7ddacaa: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
1:7ddacaa: 				System.out.println("database shutdown properly");
2:7ddacaa: 			else
1:7ddacaa: 				dumpSQLException(se);
1:7ddacaa: 		}
1:7ddacaa: 	}
1:7ddacaa: 
1:7ddacaa: 	/**
1:7ddacaa: 	 * Write message to the standard output.
1:7ddacaa: 	 */
1:7ddacaa: 	void logMessage(String   str)	{
1:7ddacaa: 			System.out.println(str);
1:7ddacaa: 	}
1:7ddacaa: 
1:7ddacaa: 	
1:7ddacaa: 	/**
1:7ddacaa: 	 * dump the SQLException to the standard output.
1:7ddacaa: 	 */
1:7ddacaa: 	static private void dumpSQLException(SQLException sqle) {
1:7ddacaa: 		
1:7ddacaa: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
1:7ddacaa: 		sqle.printStackTrace(System.out);
1:7ddacaa: 	}
1:7ddacaa: 
1:7ddacaa: 	/*
1:7ddacaa: 	 * This class implements some DML and DDL operations to 
1:7ddacaa: 	 * run againest the datbase, when the backup is in progress. 
1:7ddacaa: 	 * Some of these operations can be  run in seperate threads in a
1:7ddacaa: 	 * loop until they are stopped  by some other thread. 
1:7ddacaa: 	 */
1:7ddacaa: 	
1:7ddacaa: 	class DatabaseActions implements Runnable {
1:7ddacaa:  
1:7ddacaa: 		public static final int DMLACTIONS =   1;
1:7ddacaa: 		public static final int CREATEDROPS =  2;
1:7ddacaa: 
1:7ddacaa: 		private static final int COMMIT =     1;
1:7ddacaa: 		private static final int ROLLBACK =   2;
1:7ddacaa: 		private static final int OPENTX =     3;
1:7ddacaa: 
1:7ddacaa: 		private int     action = 0;
1:7ddacaa: 		private volatile boolean stopActivity = false ;
1:7ddacaa: 		private Connection conn;
1:7ddacaa: 	
1:7ddacaa: 		DatabaseActions(Connection conn) {
1:7ddacaa: 			this.conn = conn;
1:7ddacaa: 		};
1:7ddacaa: 
1:7ddacaa: 		DatabaseActions(int action, Connection conn)	{
1:7ddacaa: 			this.action = action;
1:7ddacaa: 			this.conn = conn;
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 		/**
1:7ddacaa: 		 * stops any actions that are looping on a differt threads.
1:7ddacaa: 		 */
1:7ddacaa: 		public void stopActivity() {
1:7ddacaa: 			stopActivity = true;
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 		/**
1:7ddacaa: 		 * implementation of run() method in the Runnable interface, which
1:7ddacaa: 		 * is invoked when a thread is started using this class object. 
1:7ddacaa: 		 * <p>
1:7ddacaa: 		 * Performs DML ot DDL actions.
1:7ddacaa: 		 */
1:7ddacaa: 		 public void run() {
1:7ddacaa: 			try {
1:7ddacaa: 				conn.setAutoCommit(false);
1:7ddacaa: 				switch(action) {
1:7ddacaa: 					case DMLACTIONS :
1:7ddacaa: 						performDmlActions();
1:7ddacaa: 						break;
1:7ddacaa: 					case CREATEDROPS:
1:7ddacaa: 						performCreateDropTables() ;
1:7ddacaa: 						break;
1:7ddacaa: 				}
1:7ddacaa: 			} catch (SQLException sqle) {
1:7ddacaa: 				org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1:7ddacaa: 				sqle.printStackTrace(System.out);
1:7ddacaa: 			} 
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 		
1:7ddacaa: 		/*
1:7ddacaa: 		 * Run insert, update, select on the test table in a loop.
1:7ddacaa: 		 */
1:7ddacaa: 		void performDmlActions() throws SQLException {
1:7ddacaa: 			
1:7ddacaa: 			while(!stopActivity) {
1:7ddacaa: 				insert(TEST_TABLE_NAME, 100, COMMIT, 10);
1:7ddacaa: 				insert(TEST_TABLE_NAME, 100, ROLLBACK, 10);
1:7ddacaa: 				update(TEST_TABLE_NAME, 50, ROLLBACK, 10);
1:7ddacaa: 				select(TEST_TABLE_NAME);
1:7ddacaa: 			}
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		
1:7ddacaa: 		/**
1:7ddacaa: 		 * start an Unlogged operation, but don't commit the transaction.
1:7ddacaa: 		 * @param  tableName  name of the table to start the unlogged operation.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void startUnloggedAction(String tableName) throws SQLException {
1:7ddacaa: 			// load some data
1:7ddacaa: 			insert(tableName, 100, COMMIT, 10);
1:7ddacaa: 			// execute a unlogged database operation
1:7ddacaa: 			Statement s = conn.createStatement();
1:7ddacaa: 			
1:7ddacaa:             // index creation does not log the index entries 
1:7ddacaa:             s.executeUpdate("create index " + tableName + "_name_idx on " + 
1:7ddacaa:                             tableName + "(name) ");
1:7ddacaa: 			s.close();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 		
1:7ddacaa: 		/**
1:7ddacaa: 		 * end an Unlogged operation, commit the transaction.
1:7ddacaa: 		 * @param  tableName  name of the table to end unlogged operation.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void endUnloggedAction(String tableName) throws SQLException {
1:7ddacaa:             // insert some rows, insert should be successful even if
1:7ddacaa:             // backup is blocking for uncommitted unlogged operations. 
1:7ddacaa: 			insert(tableName, 1000, OPENTX, 10);
1:7ddacaa: 			conn.commit();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 				
1:7ddacaa: 		/**
1:7ddacaa: 		 * Create and Drop some tables.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void performCreateDropTables() throws SQLException { 
1:7ddacaa: 			
1:7ddacaa: 			Statement s = conn.createStatement();
1:7ddacaa: 			while(!stopActivity) {
1:7ddacaa: 				for( int i = 0 ; i < 10; i++) {
1:7ddacaa: 					String tableName = "emp" + i ;
1:7ddacaa: 					createTable(tableName);
1:7ddacaa: 					//load some data
1:7ddacaa: 					insert(tableName, 100, OPENTX, 10);
1:7ddacaa: 					if((i % 2) == 0) {
1:7ddacaa: 						conn.commit();
1:7ddacaa:                     }
1:7ddacaa: 					else
1:7ddacaa: 						conn.rollback();
1:7ddacaa: 				}
1:7ddacaa: 
1:7ddacaa:                 //drop all the table that are created above.
1:7ddacaa: 				for( int i = 0 ; i < 10 ; i=i+2) {
1:7ddacaa: 					String tableName = "emp" + i ;
1:7ddacaa: 					s.executeUpdate("drop TABLE " + "emp" +i ); 
1:7ddacaa:                     conn.commit();
1:7ddacaa: 				}
1:7ddacaa: 			}
1:7ddacaa:             s.close();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		
1:7ddacaa: 		/**
1:7ddacaa: 		 * Insert some rows into the specified table.
1:7ddacaa: 		 * @param  tableName  name of the table that rows are inserted.
1:7ddacaa: 		 * @param  rowCount   Number of rows to Insert.
1:df4020d: 		 * @param  txStatus    Transacton status commit/rollback/open.
1:7ddacaa: 		 * @param  commitCount After how many inserts commit/rollbacku should happen.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void insert(String tableName, int rowCount, 
1:7ddacaa: 					int txStatus, int commitCount) throws SQLException {
1:7ddacaa: 
1:7ddacaa: 			PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
1:7ddacaa: 														 tableName + 
1:7ddacaa: 														 " VALUES(?,?,?)");
1:7ddacaa: 			for (int i = 0; i < rowCount; i++) {
1:7ddacaa: 			
1:7ddacaa: 				ps.setInt(1, i); // ID
1:7ddacaa: 				ps.setString(2 , "skywalker" + i);
1:7ddacaa: 				ps.setFloat(3, (float)(i * 2000)); 
1:7ddacaa: 				ps.executeUpdate();
1:7ddacaa: 				if ((i % commitCount) == 0)
2:7ddacaa: 				{
1:7ddacaa: 					endTransaction(txStatus);
1:7ddacaa: 				}
1:7ddacaa: 			}
1:7ddacaa: 
1:7ddacaa: 			endTransaction(txStatus);
1:7ddacaa: 			ps.close();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		/**
1:7ddacaa: 		 * commit/rollback the transaction. 
1:df4020d: 		 * @param  txStatus    Transacton status commit/rollback/open.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void endTransaction(int txStatus) throws SQLException
1:7ddacaa: 		{
1:7ddacaa: 			switch(txStatus){
1:7ddacaa: 			case COMMIT: 
1:7ddacaa: 				conn.commit();
1:7ddacaa: 				break;
1:7ddacaa: 			case ROLLBACK:
1:7ddacaa: 				conn.rollback();
1:7ddacaa: 				break;
1:7ddacaa: 			case OPENTX:
1:7ddacaa: 				//do nothing
1:7ddacaa: 				break;
1:7ddacaa: 			}
1:7ddacaa: 		}
1:7ddacaa: 		
1:7ddacaa: 		/**
1:7ddacaa: 		 * update some rows in the table.
1:7ddacaa: 		 * @param  tableName  name of the table that rows are updates.
1:7ddacaa: 		 * @param  rowCount   Number of rows to update.
1:df4020d: 		 * @param  txStatus    Transacton status commit/rollback/open.
1:7ddacaa: 		 * @param  commitCount After how many updates commit/rollback should
1:7ddacaa: 		 *                      happen.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 
1:7ddacaa: 		void update(String tableName, int rowCount, 
1:7ddacaa: 					int txStatus, int commitCount) throws SQLException
1:7ddacaa: 		{
1:7ddacaa: 
1:7ddacaa: 			PreparedStatement ps = conn.prepareStatement("update " + tableName + 
1:7ddacaa: 								 " SET name = ?  where id=?");
1:7ddacaa: 		
1:7ddacaa: 			for (int i = 0; i < rowCount; i++) {
1:7ddacaa:                 ps.setString(1 ,  "moonwalker" + i);
1:7ddacaa: 				ps.setInt(2, i); // ID
1:7ddacaa: 				ps.executeUpdate();
1:7ddacaa: 				if ((i % commitCount) == 0)
1:7ddacaa: 				{
1:7ddacaa: 					endTransaction(txStatus);
1:7ddacaa: 				}
1:7ddacaa: 			}
1:7ddacaa: 			endTransaction(txStatus);
1:7ddacaa: 			ps.close();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 
1:7ddacaa: 		/*
1:7ddacaa: 		 * read  the rows in the table. 
1:7ddacaa: 		 * @param  tableName  select operation is perfomed on this table.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void select(String tableName) throws SQLException {
1:7ddacaa: 		
1:7ddacaa: 			Statement s = conn.createStatement();
1:7ddacaa: 			ResultSet rs = s.executeQuery("SELECT ID, name from " +  
1:7ddacaa: 										  tableName + " order by id" );
1:7ddacaa: 			int count = 0;
1:7ddacaa: 			int id = 0;
1:7ddacaa: 			while(rs.next())
1:7ddacaa: 			{
1:7ddacaa: 				int tid = rs.getInt(1);
1:7ddacaa: 				String name = rs.getString(2);
1:7ddacaa:  				if(name.equals("skywalker" + id) && tid!= id)
1:7ddacaa: 				{
1:7ddacaa: 					logMessage("DATA IN THE TABLE IS NOT AS EXPECTED");
1:7ddacaa: 					logMessage("Got :ID=" +  tid + " Name=:" + name);
1:7ddacaa: 					logMessage("Expected: ID=" + id + "Name=" + "skywalker" + id );
1:7ddacaa: 				}
1:7ddacaa: 
1:7ddacaa: 				id++;
1:7ddacaa: 				count++;
1:7ddacaa: 			}
1:7ddacaa:             
1:7ddacaa: 			rs.close();
1:7ddacaa: 			s.close();
1:7ddacaa:             conn.commit();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 		/* 
1:7ddacaa: 		 * create the tables that are used by this test.
1:7ddacaa: 		 * @param  tableName  Name of the table to create.
1:7ddacaa: 		 * @exception SQLException if any database exception occurs.
1:7ddacaa: 		 */
1:7ddacaa: 		void createTable(String tableName) throws SQLException {
1:7ddacaa: 
1:7ddacaa: 			Statement s = conn.createStatement();
1:7ddacaa: 			s.executeUpdate("CREATE TABLE " + tableName + 
1:7ddacaa: 							"(id INT," +
1:7ddacaa: 							"name CHAR(200),"+ 
1:7ddacaa: 							"salary float)");
1:7ddacaa: 			s.executeUpdate("create index " + tableName + "_id_idx on " + 
1:7ddacaa: 							tableName + "(id)");
1:7ddacaa: 			s.close();
1:7ddacaa: 		}
1:7ddacaa: 
1:7ddacaa: 	}
1:7ddacaa: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1: 		 * @param  txStatus    Transacton status commit/rollback/open.
/////////////////////////////////////////////////////////////////////////
1: 		 * @param  txStatus    Transacton status commit/rollback/open.
/////////////////////////////////////////////////////////////////////////
1: 		 * @param  txStatus    Transacton status commit/rollback/open.
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:e72bcdd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Connection dmlConn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
1:         Connection ddlConn = TestUtil.getConnection(TEST_DATABASE_NAME, null);
/////////////////////////////////////////////////////////////////////////
1:         Connection conn = TestUtil.getConnection(dbName, null);
/////////////////////////////////////////////////////////////////////////
1: 			TestUtil.getConnection(dbName, "shutdown=true");
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:7ddacaa
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest1
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.store;
1: import java.sql.Connection;
0: import java.sql.DriverManager;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import org.apache.derby.tools.ij;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
1: 
1: /*
1:  * This class tests online backup when dml/ddl actions
1:  * are running in parallel to the backup thread. 
1:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
1:  * @version 1.0
1:  */
1: 
1: public class OnlineBackupTest1 {
1: 
1: 	private static final String TEST_DATABASE_NAME = "wombat" ;
1: 	private static final String TEST_TABLE_NAME   =    "emp";
1:     private static final String TEST_TABLE_NAME_1 =    "emp_1";
1:     private static final String TEST_TABLE_NAME_2 =    "emp_2";
1:     private static final String BACKUP_PATH = "extinout/onlinebackuptest1";
1: 
1: 	public static void main(String[] argv) throws Throwable {
1: 		
1:         OnlineBackupTest1 test = new OnlineBackupTest1();
1:    		ij.getPropertyArg(argv); 
1: 
1:         try {
1:             test.runTest();
1:         }
1:         catch (SQLException sqle) {
1: 			dumpSQLException(sqle);
1: 		} 
1:     }
1: 
1: 
1: 	/*
1: 	 * Test online backup with unlogged operations. And DML/DDL's
1: 	 * running in paralel to the backup. After the backup is complete restore
1: 	 * the database from the backup and performs consistency checks on the
1: 	 * database to make sure backup was good one.  
1: 	 */
1: 	private void runTest() throws Exception {
1: 		logMessage("Begin Online Backup Test1");
1: 		Connection conn = ij.startJBMS();
1: 		conn.setAutoCommit(false);
1: 		DatabaseActions dbActions = new DatabaseActions(conn);
1: 		//create the test  tables. 
1: 		dbActions.createTable(TEST_TABLE_NAME);
1:         dbActions.createTable(TEST_TABLE_NAME_1);
1:         dbActions.createTable(TEST_TABLE_NAME_2);
1:         conn.commit();
1: 
1:         // start first unlogged operation
1: 		dbActions.startUnloggedAction(TEST_TABLE_NAME_1);
1: 		logMessage("First Transaction with Unlogged Operation Started");
1: 
1:         // start second unlogged opearation
1:         Connection conn1 = ij.startJBMS();
1: 		conn1.setAutoCommit(false);
1: 		DatabaseActions dbActions1 = new DatabaseActions(conn1);
1: 		dbActions1.startUnloggedAction(TEST_TABLE_NAME_2);
1: 		logMessage("Second Transaction with Unlogged Operation Started");
1: 
1:         // setup threads.
1:         // start a  thread to perform online backup
1: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
1: 		Thread backupThread = new Thread(backup, "BACKUP");
1:         
1:         // run some dml actions in another thread
0:         Connection dmlConn = getConnection();
1:         DatabaseActions dmlActions = 
1:             new DatabaseActions(DatabaseActions.DMLACTIONS, dmlConn);
1: 		Thread dmlThread = new Thread(dmlActions, "DML_THREAD");
1:         
1:         // run some DDL create/drop tables in another thread
0:         Connection ddlConn = getConnection();
1:         
1:         DatabaseActions ddlActions = 
1:             new DatabaseActions(DatabaseActions.CREATEDROPS, ddlConn);
1:         Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
1: 
1:         try {
1:             // start a  thread to perform online backup
1:             backupThread.start();	
1:             // wait for the backup to start
1:             backup.waitForBackupToBegin();
1:             logMessage("BACKUP STARTED");
1: 
1:             // run some dml actions in another thread
1:             dmlThread.start();
1: 
1:             // run some DDL create/drop tables in another thread
1:             ddlThread.start();
1: 
1:             // sleep for few seconds just to make sure backup thread is actually
1:             // gone to a wait state for unlogged actions to commit and there is
1:             // some ddl and dml activity in progress. 
1:             java.lang.Thread.sleep(50000);
1: 			
1:             // backup should not even start doing real work before the
1:             // unlogged transaction is commited
1:             if(!backup.isRunning())
1:                 logMessage("Backup is not waiting for unlogged actions to commit");
1: 
1:             // end the unlogged work transaction.
1:             dbActions.endUnloggedAction(TEST_TABLE_NAME_1);
1:             // end the unlogged work transaction.
1:             dbActions1.endUnloggedAction(TEST_TABLE_NAME_2);
1:         
1:             backup.waitForBackupToEnd();
1: 
1:         }finally {
1:             //stop all threads activities.
1:             backupThread.join();
1:             dmlActions.stopActivity();
1:             ddlActions.stopActivity(); 
1:             dmlThread.join();
1:             ddlThread.join(); 
1:         }        
1:         // close the connections.
1:         conn.close();
1:         conn1.close();
1:         dmlConn.close();
1:         ddlConn.close() ;
1: 
1: 
1: 		//shutdown the test db 
1: 		shutdown(TEST_DATABASE_NAME);
1: 
1: 		// restore the database from the backup and run some checks 
1: 		backup.restoreFromBackup();
1: 		logMessage("Restored From the Backup");
1: 		runConsistencyChecker(TEST_DATABASE_NAME);
1: 		logMessage("Consistency Check is Done");
1: 		//shutdown the test db 
1: 		shutdown(TEST_DATABASE_NAME);
1: 		logMessage("End Online Backup Test1");
1: 	}
1: 
1: 	
1: 	/**
1: 	 * Run some consistency checks.
1: 	 * @param  dbName  consistency checks are performed on this database.
1: 	 */
1: 	void runConsistencyChecker(String dbName) throws SQLException {
0:         Connection conn = getConnection();
1: 		Statement stmt = conn.createStatement();
1: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
1:         //check the data in the EMP table.
1:         DatabaseActions dbActions = new DatabaseActions(conn);
1:         dbActions.select(TEST_TABLE_NAME);
1:         dbActions.select(TEST_TABLE_NAME_1);
1:         dbActions.select(TEST_TABLE_NAME_2);
1: 		conn.close();
1: 
1: 	}
1: 
1: 
1: 		
1: 	/**
1: 	 * Shutdown the datbase
1: 	 * @param  dbName  Name of the database to shutdown.
1: 	 */
1: 	void shutdown(String dbName) {
1: 
1: 		try{
1: 			//shutdown
0: 			if(TestUtil.HAVE_DRIVER_CLASS)
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
1: 			else 
0: 				TestUtil.shutdownUsingDataSource(dbName);
1: 		}catch(SQLException se){
1: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
1: 				System.out.println("database shutdown properly");
1: 			else
1: 				dumpSQLException(se);
1: 		}
1: 	}
1: 
1:     /*
0:      * get connection to the test database
1:      */
0:     Connection getConnection() throws SQLException 
1:     {
0:     	Connection conn;
0:     	if(TestUtil.HAVE_DRIVER_CLASS)
0: 			conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:     	else {
0: 	    	Properties prop = new Properties();
0: 	        prop.setProperty("databaseName", TEST_DATABASE_NAME);
0: 	        conn = TestUtil.getDataSourceConnection(prop);
1:     	}
0:         return conn;
1:     }
1: 
1: 
1: 	/**
1: 	 * Write message to the standard output.
1: 	 */
1: 	void logMessage(String   str)	{
1: 			System.out.println(str);
1: 	}
1: 
1: 	
1: 	/**
1: 	 * dump the SQLException to the standard output.
1: 	 */
1: 	static private void dumpSQLException(SQLException sqle) {
1: 		
1: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
1: 		sqle.printStackTrace(System.out);
1: 	}
1: 
1: 	/*
1: 	 * This class implements some DML and DDL operations to 
1: 	 * run againest the datbase, when the backup is in progress. 
1: 	 * Some of these operations can be  run in seperate threads in a
1: 	 * loop until they are stopped  by some other thread. 
1: 	 */
1: 	
1: 	class DatabaseActions implements Runnable {
1:  
1: 		public static final int DMLACTIONS =   1;
1: 		public static final int CREATEDROPS =  2;
1: 
1: 		private static final int COMMIT =     1;
1: 		private static final int ROLLBACK =   2;
1: 		private static final int OPENTX =     3;
1: 
1: 		private int     action = 0;
1: 		private volatile boolean stopActivity = false ;
1: 		private Connection conn;
1: 	
1: 		DatabaseActions(Connection conn) {
1: 			this.conn = conn;
1: 		};
1: 
1: 		DatabaseActions(int action, Connection conn)	{
1: 			this.action = action;
1: 			this.conn = conn;
1: 		}
1: 
1: 		/**
1: 		 * stops any actions that are looping on a differt threads.
1: 		 */
1: 		public void stopActivity() {
1: 			stopActivity = true;
1: 		}
1: 
1: 		/**
1: 		 * implementation of run() method in the Runnable interface, which
1: 		 * is invoked when a thread is started using this class object. 
1: 		 * <p>
1: 		 * Performs DML ot DDL actions.
1: 		 */
1: 		 public void run() {
1: 			try {
1: 				conn.setAutoCommit(false);
1: 				switch(action) {
1: 					case DMLACTIONS :
1: 						performDmlActions();
1: 						break;
1: 					case CREATEDROPS:
1: 						performCreateDropTables() ;
1: 						break;
1: 				}
1: 			} catch (SQLException sqle) {
1: 				org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
1: 				sqle.printStackTrace(System.out);
1: 			} 
1: 		}
1: 
1: 		
1: 		/*
1: 		 * Run insert, update, select on the test table in a loop.
1: 		 */
1: 		void performDmlActions() throws SQLException {
1: 			
1: 			while(!stopActivity) {
1: 				insert(TEST_TABLE_NAME, 100, COMMIT, 10);
1: 				insert(TEST_TABLE_NAME, 100, ROLLBACK, 10);
1: 				update(TEST_TABLE_NAME, 50, ROLLBACK, 10);
1: 				select(TEST_TABLE_NAME);
1: 			}
1: 		}
1: 
1: 
1: 		
1: 		/**
1: 		 * start an Unlogged operation, but don't commit the transaction.
1: 		 * @param  tableName  name of the table to start the unlogged operation.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void startUnloggedAction(String tableName) throws SQLException {
1: 			// load some data
1: 			insert(tableName, 100, COMMIT, 10);
1: 			// execute a unlogged database operation
1: 			Statement s = conn.createStatement();
1: 			
1:             // index creation does not log the index entries 
1:             s.executeUpdate("create index " + tableName + "_name_idx on " + 
1:                             tableName + "(name) ");
1: 			s.close();
1: 		}
1: 
1: 		
1: 		/**
1: 		 * end an Unlogged operation, commit the transaction.
1: 		 * @param  tableName  name of the table to end unlogged operation.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void endUnloggedAction(String tableName) throws SQLException {
1:             // insert some rows, insert should be successful even if
1:             // backup is blocking for uncommitted unlogged operations. 
1: 			insert(tableName, 1000, OPENTX, 10);
1: 			conn.commit();
1: 		}
1: 
1: 				
1: 		/**
1: 		 * Create and Drop some tables.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void performCreateDropTables() throws SQLException { 
1: 			
1: 			Statement s = conn.createStatement();
1: 			while(!stopActivity) {
1: 				for( int i = 0 ; i < 10; i++) {
1: 					String tableName = "emp" + i ;
1: 					createTable(tableName);
1: 					//load some data
1: 					insert(tableName, 100, OPENTX, 10);
1: 					if((i % 2) == 0) {
1: 						conn.commit();
1:                     }
1: 					else
1: 						conn.rollback();
1: 				}
1: 
1:                 //drop all the table that are created above.
1: 				for( int i = 0 ; i < 10 ; i=i+2) {
1: 					String tableName = "emp" + i ;
1: 					s.executeUpdate("drop TABLE " + "emp" +i ); 
1:                     conn.commit();
1: 				}
1: 			}
1:             s.close();
1: 		}
1: 
1: 
1: 		
1: 		/**
1: 		 * Insert some rows into the specified table.
1: 		 * @param  tableName  name of the table that rows are inserted.
1: 		 * @param  rowCount   Number of rows to Insert.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
1: 		 * @param  commitCount After how many inserts commit/rollbacku should happen.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void insert(String tableName, int rowCount, 
1: 					int txStatus, int commitCount) throws SQLException {
1: 
1: 			PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
1: 														 tableName + 
1: 														 " VALUES(?,?,?)");
1: 			for (int i = 0; i < rowCount; i++) {
1: 			
1: 				ps.setInt(1, i); // ID
1: 				ps.setString(2 , "skywalker" + i);
1: 				ps.setFloat(3, (float)(i * 2000)); 
1: 				ps.executeUpdate();
1: 				if ((i % commitCount) == 0)
1: 				{
1: 					endTransaction(txStatus);
1: 				}
1: 			}
1: 
1: 			endTransaction(txStatus);
1: 			ps.close();
1: 		}
1: 
1: 
1: 
1: 		/**
1: 		 * commit/rollback the transaction. 
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void endTransaction(int txStatus) throws SQLException
1: 		{
1: 			switch(txStatus){
1: 			case COMMIT: 
1: 				conn.commit();
1: 				break;
1: 			case ROLLBACK:
1: 				conn.rollback();
1: 				break;
1: 			case OPENTX:
1: 				//do nothing
1: 				break;
1: 			}
1: 		}
1: 		
1: 		/**
1: 		 * update some rows in the table.
1: 		 * @param  tableName  name of the table that rows are updates.
1: 		 * @param  rowCount   Number of rows to update.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
1: 		 * @param  commitCount After how many updates commit/rollback should
1: 		 *                      happen.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 
1: 		void update(String tableName, int rowCount, 
1: 					int txStatus, int commitCount) throws SQLException
1: 		{
1: 
1: 			PreparedStatement ps = conn.prepareStatement("update " + tableName + 
1: 								 " SET name = ?  where id=?");
1: 		
1: 			for (int i = 0; i < rowCount; i++) {
1:                 ps.setString(1 ,  "moonwalker" + i);
1: 				ps.setInt(2, i); // ID
1: 				ps.executeUpdate();
1: 				if ((i % commitCount) == 0)
1: 				{
1: 					endTransaction(txStatus);
1: 				}
1: 			}
1: 			endTransaction(txStatus);
1: 			ps.close();
1: 		}
1: 
1: 
1: 		/*
1: 		 * read  the rows in the table. 
1: 		 * @param  tableName  select operation is perfomed on this table.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void select(String tableName) throws SQLException {
1: 		
1: 			Statement s = conn.createStatement();
1: 			ResultSet rs = s.executeQuery("SELECT ID, name from " +  
1: 										  tableName + " order by id" );
1: 			int count = 0;
1: 			int id = 0;
1: 			while(rs.next())
1: 			{
1: 				int tid = rs.getInt(1);
1: 				String name = rs.getString(2);
1:  				if(name.equals("skywalker" + id) && tid!= id)
1: 				{
1: 					logMessage("DATA IN THE TABLE IS NOT AS EXPECTED");
1: 					logMessage("Got :ID=" +  tid + " Name=:" + name);
1: 					logMessage("Expected: ID=" + id + "Name=" + "skywalker" + id );
1: 				}
1: 
1: 				id++;
1: 				count++;
1: 			}
1:             
1: 			rs.close();
1: 			s.close();
1:             conn.commit();
1: 		}
1: 
1: 		/* 
1: 		 * create the tables that are used by this test.
1: 		 * @param  tableName  Name of the table to create.
1: 		 * @exception SQLException if any database exception occurs.
1: 		 */
1: 		void createTable(String tableName) throws SQLException {
1: 
1: 			Statement s = conn.createStatement();
1: 			s.executeUpdate("CREATE TABLE " + tableName + 
1: 							"(id INT," +
1: 							"name CHAR(200),"+ 
1: 							"salary float)");
1: 			s.executeUpdate("create index " + tableName + "_id_idx on " + 
1: 							tableName + "(id)");
1: 			s.close();
1: 		}
1: 
1: 	}
1: }
commit:3108341
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest1
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import org.apache.derby.tools.ij;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
0: 
0: /*
0:  * This class tests online backup when dml/ddl actions
0:  * are running in parallel to the backup thread. 
0:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
0:  * @version 1.0
0:  */
0: 
0: public class OnlineBackupTest1 {
0: 
0: 	private static final String TEST_DATABASE_NAME = "wombat" ;
0: 	private static final String TEST_TABLE_NAME   =    "emp";
0:     private static final String TEST_TABLE_NAME_1 =    "emp_1";
0:     private static final String TEST_TABLE_NAME_2 =    "emp_2";
0:     private static final String BACKUP_PATH = "extinout/onlinebackuptest1";
0: 
0: 	public static void main(String[] argv) throws Throwable {
0: 		
0:         OnlineBackupTest1 test = new OnlineBackupTest1();
0:    		ij.getPropertyArg(argv); 
0: 
0:         try {
0:             test.runTest();
0:         }
0:         catch (SQLException sqle) {
0: 			dumpSQLException(sqle);
0: 		} 
0:     }
0: 
0: 
0: 	/*
0: 	 * Test online backup with unlogged operations. And DML/DDL's
0: 	 * running in paralel to the backup. After the backup is complete restore
0: 	 * the database from the backup and performs consistency checks on the
0: 	 * database to make sure backup was good one.  
0: 	 */
0: 	private void runTest() throws Exception {
0: 		logMessage("Begin Online Backup Test1");
0: 		Connection conn = ij.startJBMS();
0: 		conn.setAutoCommit(false);
0: 		DatabaseActions dbActions = new DatabaseActions(conn);
0: 		//create the test  tables. 
0: 		dbActions.createTable(TEST_TABLE_NAME);
0:         dbActions.createTable(TEST_TABLE_NAME_1);
0:         dbActions.createTable(TEST_TABLE_NAME_2);
0:         conn.commit();
0: 
0:         // start first unlogged operation
0: 		dbActions.startUnloggedAction(TEST_TABLE_NAME_1);
0: 		logMessage("First Transaction with Unlogged Operation Started");
0: 
0:         // start second unlogged opearation
0:         Connection conn1 = ij.startJBMS();
0: 		conn1.setAutoCommit(false);
0: 		DatabaseActions dbActions1 = new DatabaseActions(conn1);
0: 		dbActions1.startUnloggedAction(TEST_TABLE_NAME_2);
0: 		logMessage("Second Transaction with Unlogged Operation Started");
0: 
0:         // setup threads.
0:         // start a  thread to perform online backup
0: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME, BACKUP_PATH);
0: 		Thread backupThread = new Thread(backup, "BACKUP");
0:         
0:         // run some dml actions in another thread
0:         Connection dmlConn = getConnection();
0:         DatabaseActions dmlActions = 
0:             new DatabaseActions(DatabaseActions.DMLACTIONS, dmlConn);
0: 		Thread dmlThread = new Thread(dmlActions, "DML_THREAD");
0:         
0:         // run some DDL create/drop tables in another thread
0:         Connection ddlConn = getConnection();
0:         
0:         DatabaseActions ddlActions = 
0:             new DatabaseActions(DatabaseActions.CREATEDROPS, ddlConn);
0:         Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
0: 
0:         try {
0:             // start a  thread to perform online backup
0:             backupThread.start();	
0:             // wait for the backup to start
0:             backup.waitForBackupToBegin();
0:             logMessage("BACKUP STARTED");
0: 
0:             // run some dml actions in another thread
0:             dmlThread.start();
0: 
0:             // run some DDL create/drop tables in another thread
0:             ddlThread.start();
0: 
0:             // sleep for few seconds just to make sure backup thread is actually
0:             // gone to a wait state for unlogged actions to commit and there is
0:             // some ddl and dml activity in progress. 
0:             java.lang.Thread.sleep(50000);
0: 			
0:             // backup should not even start doing real work before the
0:             // unlogged transaction is commited
0:             if(!backup.isRunning())
0:                 logMessage("Backup is not waiting for unlogged actions to commit");
0: 
0:             // end the unlogged work transaction.
0:             dbActions.endUnloggedAction(TEST_TABLE_NAME_1);
0:             // end the unlogged work transaction.
0:             dbActions1.endUnloggedAction(TEST_TABLE_NAME_2);
0:         
0:             backup.waitForBackupToEnd();
0: 
0:         }finally {
0:             //stop all threads activities.
0:             backupThread.join();
0:             dmlActions.stopActivity();
0:             ddlActions.stopActivity(); 
0:             dmlThread.join();
0:             ddlThread.join(); 
0:         }        
0:         // close the connections.
0:         conn.close();
0:         conn1.close();
0:         dmlConn.close();
0:         ddlConn.close() ;
0: 
0: 
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 
0: 		// restore the database from the backup and run some checks 
0: 		backup.restoreFromBackup();
0: 		logMessage("Restored From the Backup");
0: 		runConsistencyChecker(TEST_DATABASE_NAME);
0: 		logMessage("Consistency Check is Done");
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		logMessage("End Online Backup Test1");
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Run some consistency checks.
0: 	 * @param  dbName  consistency checks are performed on this database.
0: 	 */
0: 	void runConsistencyChecker(String dbName) throws SQLException {
0:         Connection conn = getConnection();
0: 		Statement stmt = conn.createStatement();
0: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
0:         //check the data in the EMP table.
0:         DatabaseActions dbActions = new DatabaseActions(conn);
0:         dbActions.select(TEST_TABLE_NAME);
0:         dbActions.select(TEST_TABLE_NAME_1);
0:         dbActions.select(TEST_TABLE_NAME_2);
0: 		conn.close();
0: 
0: 	}
0: 
0: 
0: 		
0: 	/**
0: 	 * Shutdown the datbase
0: 	 * @param  dbName  Name of the database to shutdown.
0: 	 */
0: 	void shutdown(String dbName) {
0: 
0: 		try{
0: 			//shutdown
0: 			if(TestUtil.HAVE_DRIVER_CLASS)
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0: 			else 
0: 				TestUtil.shutdownUsingDataSource(dbName);
0: 		}catch(SQLException se){
0: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
0: 				System.out.println("database shutdown properly");
0: 			else
0: 				dumpSQLException(se);
0: 		}
0: 	}
0: 
0:     /*
0:      * get connection to the test database
0:      */
0:     Connection getConnection() throws SQLException 
0:     {
0:     	Connection conn;
0:     	if(TestUtil.HAVE_DRIVER_CLASS)
0: 			conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:     	else {
0: 	    	Properties prop = new Properties();
0: 	        prop.setProperty("databaseName", TEST_DATABASE_NAME);
0: 	        conn = TestUtil.getDataSourceConnection(prop);
0:     	}
0:         return conn;
0:     }
0: 
0: 
0: 	/**
0: 	 * Write message to the standard output.
0: 	 */
0: 	void logMessage(String   str)	{
0: 			System.out.println(str);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * dump the SQLException to the standard output.
0: 	 */
0: 	static private void dumpSQLException(SQLException sqle) {
0: 		
0: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0: 		sqle.printStackTrace(System.out);
0: 	}
0: 
0: 	/*
0: 	 * This class implements some DML and DDL operations to 
0: 	 * run againest the datbase, when the backup is in progress. 
0: 	 * Some of these operations can be  run in seperate threads in a
0: 	 * loop until they are stopped  by some other thread. 
0: 	 */
0: 	
0: 	class DatabaseActions implements Runnable {
0:  
0: 		public static final int DMLACTIONS =   1;
0: 		public static final int CREATEDROPS =  2;
0: 
0: 		private static final int COMMIT =     1;
0: 		private static final int ROLLBACK =   2;
0: 		private static final int OPENTX =     3;
0: 
0: 		private int     action = 0;
0: 		private volatile boolean stopActivity = false ;
0: 		private Connection conn;
0: 	
0: 		DatabaseActions(Connection conn) {
0: 			this.conn = conn;
0: 		};
0: 
0: 		DatabaseActions(int action, Connection conn)	{
0: 			this.action = action;
0: 			this.conn = conn;
0: 		}
0: 
0: 		/**
0: 		 * stops any actions that are looping on a differt threads.
0: 		 */
0: 		public void stopActivity() {
0: 			stopActivity = true;
0: 		}
0: 
0: 		/**
0: 		 * implementation of run() method in the Runnable interface, which
0: 		 * is invoked when a thread is started using this class object. 
0: 		 * <p>
0: 		 * Performs DML ot DDL actions.
0: 		 */
0: 		 public void run() {
0: 			try {
0: 				conn.setAutoCommit(false);
0: 				switch(action) {
0: 					case DMLACTIONS :
0: 						performDmlActions();
0: 						break;
0: 					case CREATEDROPS:
0: 						performCreateDropTables() ;
0: 						break;
0: 				}
0: 			} catch (SQLException sqle) {
0: 				org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 				sqle.printStackTrace(System.out);
0: 			} 
0: 		}
0: 
0: 		
0: 		/*
0: 		 * Run insert, update, select on the test table in a loop.
0: 		 */
0: 		void performDmlActions() throws SQLException {
0: 			
0: 			while(!stopActivity) {
0: 				insert(TEST_TABLE_NAME, 100, COMMIT, 10);
0: 				insert(TEST_TABLE_NAME, 100, ROLLBACK, 10);
0: 				update(TEST_TABLE_NAME, 50, ROLLBACK, 10);
0: 				select(TEST_TABLE_NAME);
0: 			}
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * start an Unlogged operation, but don't commit the transaction.
0: 		 * @param  tableName  name of the table to start the unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void startUnloggedAction(String tableName) throws SQLException {
0: 			// load some data
0: 			insert(tableName, 100, COMMIT, 10);
0: 			// execute a unlogged database operation
0: 			Statement s = conn.createStatement();
0: 			
0:             // index creation does not log the index entries 
0:             s.executeUpdate("create index " + tableName + "_name_idx on " + 
0:                             tableName + "(name) ");
0: 			s.close();
0: 		}
0: 
0: 		
0: 		/**
0: 		 * end an Unlogged operation, commit the transaction.
0: 		 * @param  tableName  name of the table to end unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endUnloggedAction(String tableName) throws SQLException {
0:             // insert some rows, insert should be successful even if
0:             // backup is blocking for uncommitted unlogged operations. 
0: 			insert(tableName, 1000, OPENTX, 10);
0: 			conn.commit();
0: 		}
0: 
0: 				
0: 		/**
0: 		 * Create and Drop some tables.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void performCreateDropTables() throws SQLException { 
0: 			
0: 			Statement s = conn.createStatement();
0: 			while(!stopActivity) {
0: 				for( int i = 0 ; i < 10; i++) {
0: 					String tableName = "emp" + i ;
0: 					createTable(tableName);
0: 					//load some data
0: 					insert(tableName, 100, OPENTX, 10);
0: 					if((i % 2) == 0) {
0: 						conn.commit();
0:                     }
0: 					else
0: 						conn.rollback();
0: 				}
0: 
0:                 //drop all the table that are created above.
0: 				for( int i = 0 ; i < 10 ; i=i+2) {
0: 					String tableName = "emp" + i ;
0: 					s.executeUpdate("drop TABLE " + "emp" +i ); 
0:                     conn.commit();
0: 				}
0: 			}
0:             s.close();
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * Insert some rows into the specified table.
0: 		 * @param  tableName  name of the table that rows are inserted.
0: 		 * @param  rowCount   Number of rows to Insert.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many inserts commit/rollbacku should happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void insert(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException {
0: 
0: 			PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
0: 														 tableName + 
0: 														 " VALUES(?,?,?)");
0: 			for (int i = 0; i < rowCount; i++) {
0: 			
0: 				ps.setInt(1, i); // ID
0: 				ps.setString(2 , "skywalker" + i);
0: 				ps.setFloat(3, (float)(i * 2000)); 
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 
0: 		/**
0: 		 * commit/rollback the transaction. 
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endTransaction(int txStatus) throws SQLException
0: 		{
0: 			switch(txStatus){
0: 			case COMMIT: 
0: 				conn.commit();
0: 				break;
0: 			case ROLLBACK:
0: 				conn.rollback();
0: 				break;
0: 			case OPENTX:
0: 				//do nothing
0: 				break;
0: 			}
0: 		}
0: 		
0: 		/**
0: 		 * update some rows in the table.
0: 		 * @param  tableName  name of the table that rows are updates.
0: 		 * @param  rowCount   Number of rows to update.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many updates commit/rollback should
0: 		 *                      happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 
0: 		void update(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException
0: 		{
0: 
0: 			PreparedStatement ps = conn.prepareStatement("update " + tableName + 
0: 								 " SET name = ?  where id=?");
0: 		
0: 			for (int i = 0; i < rowCount; i++) {
0:                 ps.setString(1 ,  "moonwalker" + i);
0: 				ps.setInt(2, i); // ID
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 		/*
0: 		 * read  the rows in the table. 
0: 		 * @param  tableName  select operation is perfomed on this table.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void select(String tableName) throws SQLException {
0: 		
0: 			Statement s = conn.createStatement();
0: 			ResultSet rs = s.executeQuery("SELECT ID, name from " +  
0: 										  tableName + " order by id" );
0: 			int count = 0;
0: 			int id = 0;
0: 			while(rs.next())
0: 			{
0: 				int tid = rs.getInt(1);
0: 				String name = rs.getString(2);
0:  				if(name.equals("skywalker" + id) && tid!= id)
0: 				{
0: 					logMessage("DATA IN THE TABLE IS NOT AS EXPECTED");
0: 					logMessage("Got :ID=" +  tid + " Name=:" + name);
0: 					logMessage("Expected: ID=" + id + "Name=" + "skywalker" + id );
0: 				}
0: 
0: 				id++;
0: 				count++;
0: 			}
0:             
0: 			rs.close();
0: 			s.close();
0:             conn.commit();
0: 		}
0: 
0: 		/* 
0: 		 * create the tables that are used by this test.
0: 		 * @param  tableName  Name of the table to create.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void createTable(String tableName) throws SQLException {
0: 
0: 			Statement s = conn.createStatement();
0: 			s.executeUpdate("CREATE TABLE " + tableName + 
0: 							"(id INT," +
0: 							"name CHAR(200),"+ 
0: 							"salary float)");
0: 			s.executeUpdate("create index " + tableName + "_id_idx on " + 
0: 							tableName + "(id)");
0: 			s.close();
0: 		}
0: 
0: 	}
0: }
commit:6700e19
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest1
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: import java.sql.Connection;
0: import java.sql.DriverManager;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import org.apache.derby.tools.ij;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
0: 
0: /*
0:  * This class tests online backup when dml/ddl actions
0:  * are running in parallel to the backup thread. 
0:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
0:  * @version 1.0
0:  */
0: 
0: public class OnlineBackupTest1 {
0: 
0: 	private static final String TEST_DATABASE_NAME = "wombat" ;
0: 	private static final String TEST_TABLE_NAME   =    "emp";
0:     private static final String TEST_TABLE_NAME_1 =    "emp_1";
0:     private static final String TEST_TABLE_NAME_2 =    "emp_2";
0: 
0: 	public static void main(String[] argv) throws Throwable {
0: 		
0:         OnlineBackupTest1 test = new OnlineBackupTest1();
0:    		ij.getPropertyArg(argv); 
0: 
0:         try {
0:             test.runTest();
0:         }
0:         catch (SQLException sqle) {
0: 			dumpSQLException(sqle);
0: 		} 
0:     }
0: 
0: 
0: 	/*
0: 	 * Test online backup with unlogged operations. And DML/DDL's
0: 	 * running in paralel to the backup. After the backup is complete restore
0: 	 * the database from the backup and performs consistency checks on the
0: 	 * database to make sure backup was good one.  
0: 	 */
0: 	private void runTest() throws SQLException, Exception {
0: 		logMessage("Begin Online Backup Test1");
0: 		Connection conn = ij.startJBMS();
0: 		conn.setAutoCommit(false);
0: 		DatabaseActions dbActions = new DatabaseActions(conn);
0: 		//create the test  tables. 
0: 		dbActions.createTable(TEST_TABLE_NAME);
0:         dbActions.createTable(TEST_TABLE_NAME_1);
0:         dbActions.createTable(TEST_TABLE_NAME_2);
0:         conn.commit();
0: 
0:         // start first unlogged operation
0: 		dbActions.startUnloggedAction(TEST_TABLE_NAME_1);
0: 		logMessage("First Transaction with Unlogged Operation Started");
0: 
0:         // start second unlogged opearation
0:         Connection conn1 = ij.startJBMS();
0: 		conn1.setAutoCommit(false);
0: 		DatabaseActions dbActions1 = new DatabaseActions(conn1);
0: 		dbActions1.startUnloggedAction(TEST_TABLE_NAME_2);
0: 		logMessage("Second Transaction with Unlogged Operation Started");
0:         
0: 
0: 		// start a  thread to perform online backup
0: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0: 		Thread backupThread = new Thread(backup, "BACKUP");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("BACKUP STARTED");
0: 
0:         // run some dml actions in another thread
0:         Connection dmlConn = getConnection();
0:         DatabaseActions dmlActions = 
0:             new DatabaseActions(DatabaseActions.DMLACTIONS, dmlConn);
0: 		Thread dmlThread = new Thread(dmlActions, "DML_THREAD");
0: 		dmlThread.start();
0: 
0:         // run some DDL create/drop tables in another thread
0:         Connection ddlConn = getConnection();
0:         
0:         DatabaseActions ddlActions = 
0:             new DatabaseActions(DatabaseActions.CREATEDROPS, ddlConn);
0:         Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
0:         ddlThread.start();
0: 
0:         // sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit and there is
0:         // some ddl and dml activity in progress. 
0: 		java.lang.Thread.sleep(50000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged actions to commit");
0: 
0: 		// end the unlogged work transaction.
0: 		dbActions.endUnloggedAction(TEST_TABLE_NAME_1);
0:         // end the unlogged work transaction.
0: 		dbActions1.endUnloggedAction(TEST_TABLE_NAME_2);
0:         
0: 		backup.waitForBackupToEnd();
0: 		backupThread.join();
0: 		dmlActions.stopActivity();
0:         ddlActions.stopActivity(); 
0: 		dmlThread.join();
0:         ddlThread.join(); 
0:         
0:         // close the connections.
0:         conn.close();
0:         conn1.close();
0:         dmlConn.close();
0:         ddlConn.close() ;
0: 
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 
0: 		// restore the database from the backup and run some checks 
0: 		backup.restoreFromBackup();
0: 		logMessage("Restored From the Backup");
0: 		runConsistencyChecker(TEST_DATABASE_NAME);
0: 		logMessage("Consistency Check is Done");
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		logMessage("End Online Backup Test1");
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Run some consistency checks.
0: 	 * @param  dbName  consistency checks are performed on this database.
0: 	 */
0: 	void runConsistencyChecker(String dbName) throws SQLException {
0:         Connection conn = getConnection();
0: 		Statement stmt = conn.createStatement();
0: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
0:         //check the data in the EMP table.
0:         DatabaseActions dbActions = new DatabaseActions(conn);
0:         dbActions.select(TEST_TABLE_NAME);
0:         dbActions.select(TEST_TABLE_NAME_1);
0:         dbActions.select(TEST_TABLE_NAME_2);
0: 		conn.close();
0: 
0: 	}
0: 
0: 
0: 		
0: 	/**
0: 	 * Shutdown the datbase
0: 	 * @param  dbName  Name of the database to shutdown.
0: 	 */
0: 	void shutdown(String dbName) {
0: 
0: 		try{
0: 			//shutdown
0: 			if(TestUtil.HAVE_DRIVER_CLASS)
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0: 			else 
0: 				TestUtil.shutdownUsingDataSource(dbName);
0: 		}catch(SQLException se){
0: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
0: 				System.out.println("database shutdown properly");
0: 			else
0: 				dumpSQLException(se);
0: 		}
0: 	}
0: 
0:     /*
0:      * get connection to the test database
0:      */
0:     Connection getConnection() throws SQLException 
0:     {
0:     	Connection conn;
0:     	if(TestUtil.HAVE_DRIVER_CLASS)
0: 			conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:     	else {
0: 	    	Properties prop = new Properties();
0: 	        prop.setProperty("databaseName", TEST_DATABASE_NAME);
0: 	        conn = TestUtil.getDataSourceConnection(prop);
0:     	}
0:         return conn;
0:     }
0: 
0: 
0: 	/**
0: 	 * Write message to the standard output.
0: 	 */
0: 	void logMessage(String   str)	{
0: 			System.out.println(str);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * dump the SQLException to the standard output.
0: 	 */
0: 	static private void dumpSQLException(SQLException sqle) {
0: 		
0: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0: 		sqle.printStackTrace(System.out);
0: 	}
0: 
0: 	/*
0: 	 * This class implements some DML and DDL operations to 
0: 	 * run againest the datbase, when the backup is in progress. 
0: 	 * Some of these operations can be  run in seperate threads in a
0: 	 * loop until they are stopped  by some other thread. 
0: 	 */
0: 	
0: 	class DatabaseActions implements Runnable {
0:  
0: 		public static final int DMLACTIONS =   1;
0: 		public static final int CREATEDROPS =  2;
0: 
0: 		private static final int COMMIT =     1;
0: 		private static final int ROLLBACK =   2;
0: 		private static final int OPENTX =     3;
0: 
0: 		private int     action = 0;
0: 		private volatile boolean stopActivity = false ;
0: 		private Connection conn;
0: 	
0: 		DatabaseActions(Connection conn) {
0: 			this.conn = conn;
0: 		};
0: 
0: 		DatabaseActions(int action, Connection conn)	{
0: 			this.action = action;
0: 			this.conn = conn;
0: 		}
0: 
0: 		/**
0: 		 * stops any actions that are looping on a differt threads.
0: 		 */
0: 		public void stopActivity() {
0: 			stopActivity = true;
0: 		}
0: 
0: 		/**
0: 		 * implementation of run() method in the Runnable interface, which
0: 		 * is invoked when a thread is started using this class object. 
0: 		 * <p>
0: 		 * Performs DML ot DDL actions.
0: 		 */
0: 		 public void run() {
0: 			try {
0: 				conn.setAutoCommit(false);
0: 				switch(action) {
0: 					case DMLACTIONS :
0: 						performDmlActions();
0: 						break;
0: 					case CREATEDROPS:
0: 						performCreateDropTables() ;
0: 						break;
0: 				}
0: 			} catch (SQLException sqle) {
0: 				org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 				sqle.printStackTrace(System.out);
0: 			} 
0: 		}
0: 
0: 		
0: 		/*
0: 		 * Run insert, update, select on the test table in a loop.
0: 		 */
0: 		void performDmlActions() throws SQLException {
0: 			
0: 			while(!stopActivity) {
0: 				insert(TEST_TABLE_NAME, 100, COMMIT, 10);
0: 				insert(TEST_TABLE_NAME, 100, ROLLBACK, 10);
0: 				update(TEST_TABLE_NAME, 50, ROLLBACK, 10);
0: 				select(TEST_TABLE_NAME);
0: 			}
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * start an Unlogged operation, but don't commit the transaction.
0: 		 * @param  tableName  name of the table to start the unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void startUnloggedAction(String tableName) throws SQLException {
0: 			// load some data
0: 			insert(tableName, 100, COMMIT, 10);
0: 			// execute a unlogged database operation
0: 			Statement s = conn.createStatement();
0: 			
0:             // index creation does not log the index entries 
0:             s.executeUpdate("create index " + tableName + "_name_idx on " + 
0:                             tableName + "(name) ");
0: 			s.close();
0: 		}
0: 
0: 		
0: 		/**
0: 		 * end an Unlogged operation, commit the transaction.
0: 		 * @param  tableName  name of the table to end unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endUnloggedAction(String tableName) throws SQLException {
0:             // insert some rows, insert should be successful even if
0:             // backup is blocking for uncommitted unlogged operations. 
0: 			insert(tableName, 1000, OPENTX, 10);
0: 			conn.commit();
0: 		}
0: 
0: 				
0: 		/**
0: 		 * Create and Drop some tables.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void performCreateDropTables() throws SQLException { 
0: 			
0: 			Statement s = conn.createStatement();
0: 			while(!stopActivity) {
0: 				for( int i = 0 ; i < 10; i++) {
0: 					String tableName = "emp" + i ;
0: 					createTable(tableName);
0: 					//load some data
0: 					insert(tableName, 100, OPENTX, 10);
0: 					if((i % 2) == 0) {
0: 						conn.commit();
0:                     }
0: 					else
0: 						conn.rollback();
0: 				}
0: 
0:                 //drop all the table that are created above.
0: 				for( int i = 0 ; i < 10 ; i=i+2) {
0: 					String tableName = "emp" + i ;
0: 					s.executeUpdate("drop TABLE " + "emp" +i ); 
0:                     conn.commit();
0: 				}
0: 			}
0:             s.close();
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * Insert some rows into the specified table.
0: 		 * @param  tableName  name of the table that rows are inserted.
0: 		 * @param  rowCount   Number of rows to Insert.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many inserts commit/rollbacku should happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void insert(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException {
0: 
0: 			PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
0: 														 tableName + 
0: 														 " VALUES(?,?,?)");
0: 			for (int i = 0; i < rowCount; i++) {
0: 			
0: 				ps.setInt(1, i); // ID
0: 				ps.setString(2 , "skywalker" + i);
0: 				ps.setFloat(3, (float)(i * 2000)); 
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 
0: 		/**
0: 		 * commit/rollback the transaction. 
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endTransaction(int txStatus) throws SQLException
0: 		{
0: 			switch(txStatus){
0: 			case COMMIT: 
0: 				conn.commit();
0: 				break;
0: 			case ROLLBACK:
0: 				conn.rollback();
0: 				break;
0: 			case OPENTX:
0: 				//do nothing
0: 				break;
0: 			}
0: 		}
0: 		
0: 		/**
0: 		 * update some rows in the table.
0: 		 * @param  tableName  name of the table that rows are updates.
0: 		 * @param  rowCount   Number of rows to update.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many updates commit/rollback should
0: 		 *                      happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 
0: 		void update(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException
0: 		{
0: 
0: 			PreparedStatement ps = conn.prepareStatement("update " + tableName + 
0: 								 " SET name = ?  where id=?");
0: 		
0: 			for (int i = 0; i < rowCount; i++) {
0:                 ps.setString(1 ,  "moonwalker" + i);
0: 				ps.setInt(2, i); // ID
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 		/*
0: 		 * read  the rows in the table. 
0: 		 * @param  tableName  select operation is perfomed on this table.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void select(String tableName) throws SQLException {
0: 		
0: 			Statement s = conn.createStatement();
0: 			ResultSet rs = s.executeQuery("SELECT ID, name from " +  
0: 										  tableName + " order by id" );
0: 			int count = 0;
0: 			int id = 0;
0: 			while(rs.next())
0: 			{
0: 				int tid = rs.getInt(1);
0: 				String name = rs.getString(2);
0:  				if(name.equals("skywalker" + id) && tid!= id)
0: 				{
0: 					logMessage("DATA IN THE TABLE IS NOT AS EXPECTED");
0: 					logMessage("Got :ID=" +  tid + " Name=:" + name);
0: 					logMessage("Expected: ID=" + id + "Name=" + "skywalker" + id );
0: 				}
0: 
0: 				id++;
0: 				count++;
0: 			}
0:             
0: 			rs.close();
0: 			s.close();
0:             conn.commit();
0: 		}
0: 
0: 		/* 
0: 		 * create the tables that are used by this test.
0: 		 * @param  tableName  Name of the table to create.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void createTable(String tableName) throws SQLException {
0: 
0: 			Statement s = conn.createStatement();
0: 			s.executeUpdate("CREATE TABLE " + tableName + 
0: 							"(id INT," +
0: 							"name CHAR(200),"+ 
0: 							"salary float)");
0: 			s.executeUpdate("create index " + tableName + "_id_idx on " + 
0: 							tableName + "(id)");
0: 			s.close();
0: 		}
0: 
0: 	}
0: }
commit:402725c
/////////////////////////////////////////////////////////////////////////
0: 	private static final String TEST_TABLE_NAME   =    "emp";
0:     private static final String TEST_TABLE_NAME_1 =    "emp_1";
0:     private static final String TEST_TABLE_NAME_2 =    "emp_2";
/////////////////////////////////////////////////////////////////////////
0: 		//create the test  tables. 
0:         dbActions.createTable(TEST_TABLE_NAME_1);
0:         dbActions.createTable(TEST_TABLE_NAME_2);
0: 
0:         // start first unlogged operation
0: 		dbActions.startUnloggedAction(TEST_TABLE_NAME_1);
0: 		logMessage("First Transaction with Unlogged Operation Started");
0: 
0:         // start second unlogged opearation
0:         Connection conn1 = ij.startJBMS();
0: 		conn1.setAutoCommit(false);
0: 		DatabaseActions dbActions1 = new DatabaseActions(conn1);
0: 		dbActions1.startUnloggedAction(TEST_TABLE_NAME_2);
0: 		logMessage("Second Transaction with Unlogged Operation Started");
0:         
0: 
/////////////////////////////////////////////////////////////////////////
0: 		dbActions.endUnloggedAction(TEST_TABLE_NAME_1);
0:         // end the unlogged work transaction.
0: 		dbActions1.endUnloggedAction(TEST_TABLE_NAME_2);
0:         
/////////////////////////////////////////////////////////////////////////
0:         conn1.close();
/////////////////////////////////////////////////////////////////////////
0:         //check the data in the EMP table.
0:         DatabaseActions dbActions = new DatabaseActions(conn);
0:         dbActions.select(TEST_TABLE_NAME);
0:         dbActions.select(TEST_TABLE_NAME_1);
0:         dbActions.select(TEST_TABLE_NAME_2);
/////////////////////////////////////////////////////////////////////////
0: 			while(!stopActivity) {
/////////////////////////////////////////////////////////////////////////
0: 			
0:             // index creation does not log the index entries 
0:             s.executeUpdate("create index " + tableName + "_name_idx on " + 
0:                             tableName + "(name) ");
/////////////////////////////////////////////////////////////////////////
0:             // insert some rows, insert should be successful even if
0:             // backup is blocking for uncommitted unlogged operations. 
/////////////////////////////////////////////////////////////////////////
0: 		 * @param  tableName  name of the table that rows are updates.
0: 		 * @param  rowCount   Number of rows to update.
0: 		 * @param  commitCount After how many updates commit/rollback should
/////////////////////////////////////////////////////////////////////////
0: 								 " SET name = ?  where id=?");
0:                 ps.setString(1 ,  "moonwalker" + i);
/////////////////////////////////////////////////////////////////////////
0:  				if(name.equals("skywalker" + id) && tid!= id)
/////////////////////////////////////////////////////////////////////////
0:             
0:             conn.commit();
commit:7e95bef
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0:          Connection ddlConn = getConnection();
0: 
0:          /* Disabling create table operation running parallel to 
0:           * backup because of DERBY-750 bug. This block of code
0:           * should be uncommented when DERBY-750 is fixed.
0: 
0:          DatabaseActions ddlActions = 
0:             Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
0:             ddlThread.start();
0:          */
/////////////////////////////////////////////////////////////////////////
0: 		// ddlActions.stopActivity(); -- uncomment this when derby-750 is fixed
0: 		// ddlThread.join(); -- uncomment this when derby-750 is fixed
commit:64ec5e2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
0: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
0:         // run some dml actions in another thread
0:         Connection dmlConn = getConnection();
0:         DatabaseActions dmlActions = 
0:             new DatabaseActions(DatabaseActions.DMLACTIONS, dmlConn);
0:         // run some DDL create/drop tables in another thread
0:         Connection ddlConn = getConnection();
0: 		DatabaseActions ddlActions = 
0:             new DatabaseActions(DatabaseActions.CREATEDROPS, ddlConn);
/////////////////////////////////////////////////////////////////////////
0:         
0:         // close the connections.
0:         conn.close();
0:         dmlConn.close();
0:         ddlConn.close() ;
/////////////////////////////////////////////////////////////////////////
0:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
0:             TestUtil.shutdownUsingDataSource(TEST_DATABASE_NAME);
/////////////////////////////////////////////////////////////////////////
0:     /*
0:      * get connection to the test database
0:      */
0:     Connection getConnection() throws SQLException 
0:     {
0:         Properties prop = new Properties();
0:         prop.setProperty("databaseName", TEST_DATABASE_NAME);
0:         Connection conn = TestUtil.getDataSourceConnection(prop);
0:         return conn;
0:     }
0: 
0: 
commit:b4b8d3b
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derbyTesting.functionTests.store.OnlineBackupTest1
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.tests.store;
0: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.DriverManager;
0: import org.apache.derby.tools.ij;
0: 
0: /*
0:  * This class tests online backup when dml/ddl actions
0:  * are running in parallel to the backup thread. 
0:  *
0:  * @author <a href="mailto:suresh.thalamati@gmail.com">Suresh Thalamati</a>
0:  * @version 1.0
0:  */
0: 
0: public class OnlineBackupTest1 {
0: 
0: 	private static final String TEST_DATABASE_NAME = "wombat" ;
0: 	private static final String TEST_TABLE_NAME =    "emp";
0: 
0: 	public static void main(String[] argv) throws Throwable {
0: 		
0:         OnlineBackupTest1 test = new OnlineBackupTest1();
0:    		ij.getPropertyArg(argv); 
0: 
0:         try {
0:             test.runTest();
0:         }
0:         catch (SQLException sqle) {
0: 			dumpSQLException(sqle);
0: 		} 
0:     }
0: 
0: 
0: 	/*
0: 	 * Test online backup with unlogged operations. And DML/DDL's
0: 	 * running in paralel to the backup. After the backup is complete restore
0: 	 * the database from the backup and performs consistency checks on the
0: 	 * database to make sure backup was good one.  
0: 	 */
0: 	private void runTest() throws SQLException, Exception {
0: 		logMessage("Begin Online Backup Test1");
0: 		Connection conn = ij.startJBMS();
0: 		conn.setAutoCommit(false);
0: 		DatabaseActions dbActions = new DatabaseActions(conn);
0: 		//create the test  table. 
0: 		dbActions.createTable(TEST_TABLE_NAME);
0: 		dbActions.startUnloggedAction(TEST_TABLE_NAME);
0: 		logMessage("A Transaction with Unlogged Operation Started");
0: 		// start a  thread to perform online backup
0: 		OnlineBackup backup = new OnlineBackup(TEST_DATABASE_NAME);
0: 		Thread backupThread = new Thread(backup, "BACKUP");
0: 		backupThread.start();	
0: 		// wait for the backup to start
0: 		backup.waitForBackupToBegin();
0: 		logMessage("BACKUP STARTED");
0: 
0: 		// run some dml actions in another thread
0: 		DatabaseActions dmlActions = new DatabaseActions(DatabaseActions.DMLACTIONS, conn);
0: 		Thread dmlThread = new Thread(dmlActions, "DML_THREAD");
0: 		dmlThread.start();
0: 
0: 		// run some DDL create/drop tables in another thread
0: 		DatabaseActions ddlActions = new DatabaseActions(DatabaseActions.CREATEDROPS, conn);
0: 		Thread ddlThread = new Thread(ddlActions, "DDL_THREAD");
0: 		ddlThread.start();
0: 
0: 		// sleep for few seconds just to make sure backup thread is actually
0: 		// gone to a wait state for unlogged actions to commit.
0: 		java.lang.Thread.sleep(5000);
0: 			
0: 		// backup should not even start doing real work before the
0: 		// unlogged transaction is commited
0: 		if(!backup.isRunning())
0: 			logMessage("Backup is not waiting for unlogged actions to commit");
0: 
0: 		// end the unlogged work transaction.
0: 		dbActions.endUnloggedAction(TEST_TABLE_NAME);
0: 		
0: 		backup.waitForBackupToEnd();
0: 		backupThread.join();
0: 		dmlActions.stopActivity();
0: 		ddlActions.stopActivity();
0: 		dmlThread.join();
0: 		ddlThread.join();
0: 
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 
0: 		// restore the database from the backup and run some checks 
0: 		backup.restoreFromBackup();
0: 		logMessage("Restored From the Backup");
0: 		runConsistencyChecker(TEST_DATABASE_NAME);
0: 		logMessage("Consistency Check is Done");
0: 		//shutdown the test db 
0: 		shutdown(TEST_DATABASE_NAME);
0: 		logMessage("End Online Backup Test1");
0: 	}
0: 
0: 	
0: 	/**
0: 	 * Run some consistency checks.
0: 	 * @param  dbName  consistency checks are performed on this database.
0: 	 */
0: 	void runConsistencyChecker(String dbName) throws SQLException {
0: 		Connection conn = DriverManager.getConnection("jdbc:derby:" + dbName);
0: 		Statement stmt = conn.createStatement();
0: 		stmt.execute("values SYSCS_UTIL.SYSCS_CHECK_TABLE('APP',  'EMP')");
0: 		//TO DO : Consistency check all the tables including the system tables. 
0: 		conn.close();
0: 
0: 	}
0: 
0: 
0: 		
0: 	/**
0: 	 * Shutdown the datbase
0: 	 * @param  dbName  Name of the database to shutdown.
0: 	 */
0: 	void shutdown(String dbName) {
0: 
0: 		try{
0: 			// shutdown 
0: 			Connection conn = 
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0: 		}catch(SQLException se){
0: 			if (se.getSQLState() != null && se.getSQLState().equals("08006"))
0: 				System.out.println("database shutdown properly");
0: 			else
0: 				dumpSQLException(se);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Write message to the standard output.
0: 	 */
0: 	void logMessage(String   str)	{
0: 			System.out.println(str);
0: 	}
0: 
0: 	
0: 	/**
0: 	 * dump the SQLException to the standard output.
0: 	 */
0: 	static private void dumpSQLException(SQLException sqle) {
0: 		
0: 		org.apache.derby.tools.JDBCDisplayUtil.	ShowSQLException(System.out, sqle);
0: 		sqle.printStackTrace(System.out);
0: 	}
0: 
0: 	/*
0: 	 * This class implements some DML and DDL operations to 
0: 	 * run againest the datbase, when the backup is in progress. 
0: 	 * Some of these operations can be  run in seperate threads in a
0: 	 * loop until they are stopped  by some other thread. 
0: 	 */
0: 	
0: 	class DatabaseActions implements Runnable {
0:  
0: 		public static final int DMLACTIONS =   1;
0: 		public static final int CREATEDROPS =  2;
0: 
0: 		private static final int COMMIT =     1;
0: 		private static final int ROLLBACK =   2;
0: 		private static final int OPENTX =     3;
0: 
0: 		private int     action = 0;
0: 		private volatile boolean stopActivity = false ;
0: 		private Connection conn;
0: 	
0: 		DatabaseActions(Connection conn) {
0: 			this.conn = conn;
0: 		};
0: 
0: 		DatabaseActions(int action, Connection conn)	{
0: 			this.action = action;
0: 			this.conn = conn;
0: 		}
0: 
0: 		/**
0: 		 * stops any actions that are looping on a differt threads.
0: 		 */
0: 		public void stopActivity() {
0: 			stopActivity = true;
0: 		}
0: 
0: 		/**
0: 		 * implementation of run() method in the Runnable interface, which
0: 		 * is invoked when a thread is started using this class object. 
0: 		 * <p>
0: 		 * Performs DML ot DDL actions.
0: 		 */
0: 		 public void run() {
0: 			try {
0: 				conn.setAutoCommit(false);
0: 				switch(action) {
0: 					case DMLACTIONS :
0: 						performDmlActions();
0: 						break;
0: 					case CREATEDROPS:
0: 						performCreateDropTables() ;
0: 						break;
0: 				}
0: 			} catch (SQLException sqle) {
0: 				org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(System.out, sqle);
0: 				sqle.printStackTrace(System.out);
0: 			} 
0: 		}
0: 
0: 		
0: 		/*
0: 		 * Run insert, update, select on the test table in a loop.
0: 		 */
0: 		void performDmlActions() throws SQLException {
0: 			
0: 			while(stopActivity) {
0: 				insert(TEST_TABLE_NAME, 100, COMMIT, 10);
0: 				insert(TEST_TABLE_NAME, 100, ROLLBACK, 10);
0: 				update(TEST_TABLE_NAME, 50, COMMIT, 10);
0: 				update(TEST_TABLE_NAME, 50, ROLLBACK, 10);
0: 				select(TEST_TABLE_NAME);
0: 			}
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * start an Unlogged operation, but don't commit the transaction.
0: 		 * @param  tableName  name of the table to start the unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void startUnloggedAction(String tableName) throws SQLException {
0: 			// load some data
0: 			insert(tableName, 100, COMMIT, 10);
0: 			// execute a unlogged database operation
0: 			Statement s = conn.createStatement();
0: 			// index creation does not log the index entries 
0: 			s.executeUpdate("create index " + tableName + "_name_idx on " + 
0: 							TEST_TABLE_NAME + "(name) ");
0: 			s.close();
0: 		}
0: 
0: 		
0: 		/**
0: 		 * end an Unlogged operation, commit the transaction.
0: 		 * @param  tableName  name of the table to end unlogged operation.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endUnloggedAction(String tableName) throws SQLException {
0: 			insert(tableName, 1000, OPENTX, 10);
0: 			conn.commit();
0: 		}
0: 
0: 
0: 				
0: 		/**
0: 		 * Create and Drop some tables.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void performCreateDropTables() throws SQLException { 
0: 			
0: 			Statement s = conn.createStatement();
0: 			while(!stopActivity) {
0: 				for( int i = 0 ; i < 100 ; i++) {
0: 					String tableName = "emp" + i ;
0: 					createTable(tableName);
0: 					//load some data
0: 					insert(tableName, 100, COMMIT, 10);
0: 					if((i % 2) == 0) 
0: 						conn.commit();
0: 					else
0: 						conn.rollback();
0: 				}
0: 				conn.commit();
0: 
0: 				for( int i = 0 ; i < 100 ; i=i+2) {
0: 					String tableName = "emp" + i ;
0: 					s.executeUpdate("drop TABLE " + "emp" +i ); 
0: 					if((i % 2) == 0) 
0: 						conn.commit();
0: 					else
0: 						conn.rollback();
0: 				}
0: 				conn.commit();
0: 			}
0: 		}
0: 
0: 
0: 		
0: 		/**
0: 		 * Insert some rows into the specified table.
0: 		 * @param  tableName  name of the table that rows are inserted.
0: 		 * @param  rowCount   Number of rows to Insert.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many inserts commit/rollbacku should happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void insert(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException {
0: 
0: 			PreparedStatement ps = conn.prepareStatement("INSERT INTO " + 
0: 														 tableName + 
0: 														 " VALUES(?,?,?)");
0: 			for (int i = 0; i < rowCount; i++) {
0: 			
0: 				ps.setInt(1, i); // ID
0: 				ps.setString(2 , "skywalker" + i);
0: 				ps.setFloat(3, (float)(i * 2000)); 
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 
0: 		/**
0: 		 * commit/rollback the transaction. 
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void endTransaction(int txStatus) throws SQLException
0: 		{
0: 			switch(txStatus){
0: 			case COMMIT: 
0: 				conn.commit();
0: 				break;
0: 			case ROLLBACK:
0: 				conn.rollback();
0: 				break;
0: 			case OPENTX:
0: 				//do nothing
0: 				break;
0: 			}
0: 		}
0: 		
0: 		/**
0: 		 * update some rows in the table.
0: 		 * @param  tableName  name of the table that rows are inserted.
0: 		 * @param  rowCount   Number of rows to Insert.
0: 		 * @param  txStaus    Transacton status commit/rollback/open.
0: 		 * @param  commitCount After how many inserts commit/rollbacku should
0: 		 *                      happen.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 
0: 		void update(String tableName, int rowCount, 
0: 					int txStatus, int commitCount) throws SQLException
0: 		{
0: 
0: 			PreparedStatement ps = conn.prepareStatement("update " + tableName + 
0: 														 " SET salary=? where id=?");
0: 		
0: 			for (int i = 0; i < rowCount; i++) {
0: 
0: 				ps.setFloat(1, (float)(i * 2000 * 0.08));
0: 				ps.setInt(2, i); // ID
0: 				ps.executeUpdate();
0: 				if ((i % commitCount) == 0)
0: 				{
0: 					endTransaction(txStatus);
0: 				}
0: 			}
0: 			endTransaction(txStatus);
0: 			ps.close();
0: 		}
0: 
0: 
0: 		/*
0: 		 * read  the rows in the table. 
0: 		 * @param  tableName  select operation is perfomed on this table.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void select(String tableName) throws SQLException {
0: 		
0: 			Statement s = conn.createStatement();
0: 			ResultSet rs = s.executeQuery("SELECT ID, name from " +  
0: 										  tableName + " order by id" );
0: 			int count = 0;
0: 			int id = 0;
0: 			while(rs.next())
0: 			{
0: 				int tid = rs.getInt(1);
0: 				String name = rs.getString(2);
0: 				if(name.equals("skywalker" + id) && tid!= id)
0: 				{
0: 					logMessage("DATA IN THE TABLE IS NOT AS EXPECTED");
0: 					logMessage("Got :ID=" +  tid + " Name=:" + name);
0: 					logMessage("Expected: ID=" + id + "Name=" + "skywalker" + id );
0: 				}
0: 
0: 				id++;
0: 				count++;
0: 			}
0: 
0: 			rs.close();
0: 			s.close();
0: 		}
0: 
0: 		/* 
0: 		 * create the tables that are used by this test.
0: 		 * @param  tableName  Name of the table to create.
0: 		 * @exception SQLException if any database exception occurs.
0: 		 */
0: 		void createTable(String tableName) throws SQLException {
0: 
0: 			Statement s = conn.createStatement();
0: 			s.executeUpdate("CREATE TABLE " + tableName + 
0: 							"(id INT," +
0: 							"name CHAR(200),"+ 
0: 							"salary float)");
0: 			s.executeUpdate("create index " + tableName + "_id_idx on " + 
0: 							tableName + "(id)");
0: 			conn.commit();
0: 			s.close();
0: 		}
0: 
0: 	}
0: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:e967126
/////////////////////////////////////////////////////////////////////////
0: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
0: 			//shutdown
0: 			if(TestUtil.HAVE_DRIVER_CLASS)
0: 				DriverManager.getConnection("jdbc:derby:" + dbName + ";shutdown=true");
0: 			else 
0: 				TestUtil.shutdownUsingDataSource(dbName);
/////////////////////////////////////////////////////////////////////////
0:     	Connection conn;
0:     	if(TestUtil.HAVE_DRIVER_CLASS)
0: 			conn = DriverManager.getConnection("jdbc:derby:" + TEST_DATABASE_NAME );
0:     	else {
0: 	    	Properties prop = new Properties();
0: 	        prop.setProperty("databaseName", TEST_DATABASE_NAME);
0: 	        conn = TestUtil.getDataSourceConnection(prop);
0:     	}
============================================================================