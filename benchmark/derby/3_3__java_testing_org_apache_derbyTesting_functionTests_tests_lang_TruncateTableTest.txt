1:7775fc7: /*
1:7775fc7:  * Class org.apache.derbyTesting.functionTests.tests.lang.TruncateTableTest
1:7775fc7:  *
1:7775fc7:  * Licensed to the Apache Software Foundation (ASF) under one
1:7775fc7:  * or more contributor license agreements.  See the NOTICE file
1:7775fc7:  * distributed with this work for additional information
1:7775fc7:  * regarding copyright ownership.  The ASF licenses this file
1:7775fc7:  * to you under the Apache License, Version 2.0 (the
1:7775fc7:  * "License"); you may not use this file except in compliance
1:7775fc7:  * with the License.  You may obtain a copy of the License at
1:7775fc7:  *
1:7775fc7:  *   http://www.apache.org/licenses/LICENSE-2.0
1:7775fc7:  *
1:7775fc7:  * Unless required by applicable law or agreed to in writing,
1:7775fc7:  * software distributed under the License is distributed on an
1:7775fc7:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:7775fc7:  * KIND, either express or implied.  See the License for the
1:7775fc7:  * specific language governing permissions and limitations
1:7775fc7:  * under the License.
2:7775fc7:  */
2:7775fc7: 
1:7775fc7: package org.apache.derbyTesting.functionTests.tests.lang;
1:7775fc7: 
1:b6fbed3: import java.sql.Connection;
1:8e47077: import java.sql.PreparedStatement;
1:3a4b2df: import java.sql.ResultSet;
1:7775fc7: import java.sql.SQLException;
1:7775fc7: import java.sql.Statement;
1:3f5c48a: import java.util.concurrent.atomic.AtomicBoolean;
1:7775fc7: import junit.framework.Test;
1:7775fc7: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:b6fbed3: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:3a4b2df: import org.apache.derbyTesting.junit.JDBC;
1:7775fc7: import org.apache.derbyTesting.junit.TestConfiguration;
1:7775fc7: 
2:7775fc7: /**
1:3a4b2df:  * Tests for TRUNCATE TABLE.
1:3a4b2df:  * 
1:7775fc7:  */
1:7775fc7: public class TruncateTableTest extends BaseJDBCTestCase {
1:7775fc7: 
1:b6fbed3:     private static  final   String      TEST_DBO = "TEST_DBO";
1:b6fbed3:     private static  final   String      RUTH = "RUTH";
1:b6fbed3:     private static  final   String      ALICE = "ALICE";
1:b6fbed3:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, RUTH, ALICE };
1:b6fbed3: 
1:b6fbed3:     private static  final   String      UNAUTHORIZED_OPERATION = "42507";
1:b6fbed3: 
1:7775fc7:     public TruncateTableTest(String name) {
1:7775fc7:         super(name);
3:7775fc7:     }
1:7775fc7: 
1:7775fc7:     public static Test suite() {
1:b6fbed3:         Test cleanTest = TestConfiguration.defaultSuite(TruncateTableTest.class);
1:b6fbed3:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:b6fbed3:             ( cleanTest, LEGAL_USERS, "" );
1:b6fbed3:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1:b6fbed3: 
1:b6fbed3:         return authorizedTest;
1:7775fc7:     }
1:7775fc7: 
1:7775fc7:     /**
1:7775fc7:      * Test that TRUNCATE TABLE works when there is an index on one of the
1:3a4b2df:      * columns. Verify that default "CONTINUE IDENTITY" semantics are enforced.
1:7775fc7:      */
1:7775fc7:     public void testTruncateWithIndex() throws SQLException {
1:b6fbed3:         Connection aliceConnection = openUserConnection( ALICE );
1:b6fbed3:         Statement st = aliceConnection.createStatement();
1:3a4b2df:         ResultSet rs;
1:3a4b2df:         String[][] expRS;
1:3a4b2df:         //creating a table with one column auto filled with a unique value
1:3a4b2df:         st.executeUpdate("create table t1(a int not null generated always as identity primary key, b varchar(100))");
1:3a4b2df:         //populate the table
1:3a4b2df:         st.executeUpdate("insert into t1(b) values('one'),('two'),('three'),('four'),('five')");
1:3a4b2df:         //varify the inserted values
1:3a4b2df:         rs = st.executeQuery("select * from t1 order by a");
1:3a4b2df:         expRS = new String[][]{
1:3a4b2df:                         {"1","one"},
1:3a4b2df:                         {"2","two"},
1:3a4b2df:                         {"3","three"},
1:3a4b2df:                         {"4","four"},
1:3a4b2df:                         {"5","five"}
1:3a4b2df:                 };
1:3a4b2df:         JDBC.assertFullResultSet(rs, expRS);
1:3a4b2df:         //executing the truncate table
1:3a4b2df:         st.executeUpdate("truncate table t1");
1:3a4b2df:         //confirm whether the truncation worked
1:b6fbed3:         JDBC.assertEmpty( st.executeQuery( "select * from t1" ) );
1:8e47077: 
1:3a4b2df:         //testing whether the truncation work as "CONTINUE IDENTITY"
1:3a4b2df:         //semantics are enforced
1:3a4b2df:         st.executeUpdate("insert into t1(b) values('six'),('seven')");
1:3a4b2df:         rs = st.executeQuery("select * from t1 order by a");
1:3a4b2df:         expRS = new String[][]{
1:3a4b2df:                         {"6","six"},
1:3a4b2df:                         {"7","seven"}
1:3a4b2df:                 };
1:3a4b2df:         JDBC.assertFullResultSet(rs, expRS);
1:3a4b2df: 
1:b6fbed3:         st.close();
1:b6fbed3:         aliceConnection.close();
1:7775fc7:     }
1:3a4b2df: 
1:8e47077:     /**
1:8e47077:      * Test that TRUNCATE TABLE cannot be performed on a table with a
1:8e47077:      * delete trigger.
1:8e47077:      */
1:8e47077:     public void testTruncateWithDeleteTrigger() throws Exception {
1:b6fbed3:         Connection aliceConnection = openUserConnection( ALICE );
1:b6fbed3:         Statement s = aliceConnection.createStatement();
1:8e47077: 
1:8e47077:         // Create two tables, t1 and t2, where deletes from t1 cause inserts
1:8e47077:         // into t2.
1:8e47077:         s.execute("create table deltriggertest_t1(x int)");
1:8e47077:         s.execute("create table deltriggertest_t2(y int)");
1:8e47077:         s.execute("create trigger deltriggertest_tr after delete on "
1:8e47077:                 + "deltriggertest_t1 referencing old as old for each row "
1:8e47077:                 + "insert into deltriggertest_t2 values old.x");
1:8e47077: 
1:8e47077:         // Prepare a statement that checks the number of rows in the
1:8e47077:         // destination table (t2).
1:b6fbed3:         PreparedStatement checkDest = aliceConnection.prepareStatement(
1:8e47077:                 "select count(*) from deltriggertest_t2");
1:8e47077: 
1:8e47077:         // Insert rows into t1, delete them, and verify that t2 has grown.
1:8e47077:         s.execute("insert into deltriggertest_t1 values 1,2,3");
1:8e47077:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "0");
1:8e47077:         assertUpdateCount(s, 3, "delete from deltriggertest_t1");
1:8e47077:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "3");
1:8e47077: 
1:8e47077:         // Now do the same with TRUNCATE instead of DELETE. Expect it to fail
1:8e47077:         // because there is a delete trigger on the table.
1:8e47077:         s.execute("insert into deltriggertest_t1 values 4,5");
1:8e47077:         assertStatementError("XCL49", s, "truncate table deltriggertest_t1");
1:8e47077:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "3");
1:8e47077:     }
1:8e47077: 
1:8e47077:     /**
1:8e47077:      * Test that TRUNCATE TABLE isn't allowed on a table referenced by a
1:8e47077:      * foreign key constraint on another table.
1:8e47077:      */
1:8e47077:     public void testTruncateWithForeignKey() throws SQLException {
1:b6fbed3:         Connection aliceConnection = openUserConnection( ALICE );
1:b6fbed3:         Statement s = aliceConnection.createStatement();
1:8e47077: 
1:8e47077:         // Create two tables with a foreign key relationship.
1:8e47077:         s.execute("create table foreignkey_t1(x int primary key)");
1:8e47077:         s.execute("create table foreignkey_t2(y int references foreignkey_t1)");
1:8e47077:         s.execute("insert into foreignkey_t1 values 1,2");
1:8e47077:         s.execute("insert into foreignkey_t2 values 2");
1:8e47077: 
1:8e47077:         // Truncating the referenced table isn't allowed as that would
1:8e47077:         // break referential integrity.
1:8e47077:         assertStatementError("XCL48", s, "truncate table foreignkey_t1");
1:8e47077: 
1:8e47077:         // Truncating the referencing table is OK.
1:8e47077:         s.execute("truncate table foreignkey_t2");
1:b6fbed3:         JDBC.assertEmpty( s.executeQuery( "select * from foreignkey_t2" ) );
1:8e47077:     }
1:8e47077: 
1:8e47077:     /**
1:8e47077:      * Test that TRUNCATE TABLE is allowed on a referenced table if it's only
1:8e47077:      * referenced by itself.
1:8e47077:      */
1:8e47077:     public void testSelfReferencing() throws SQLException {
1:b6fbed3:         Connection aliceConnection = openUserConnection( ALICE );
1:b6fbed3:         Statement s = aliceConnection.createStatement();
1:84349af: 
1:84349af:         // Workaround for DERBY-5139: If this test case happens to be running
1:84349af:         // first, before the schema ALICE has been created, the CREATE TABLE
1:84349af:         // statement below will fail. Normally, CREATE TABLE should create the
1:84349af:         // ALICE schema automatically, but for some reason that doesn't happen
1:84349af:         // when creating a self-referencing table. Create the schema manually
1:84349af:         // for now, if it doesn't already exist.
1:84349af:         try {
1:84349af:             s.execute("CREATE SCHEMA ALICE");
1:84349af:         } catch (SQLException sqle) {
1:84349af:             // It's OK to fail if schema already exists.
1:84349af:             assertSQLState("X0Y68", sqle);
1:84349af:         }
1:84349af: 
1:8e47077:         s.execute("create table self_referencing_t1(x int primary key, "
1:8e47077:                 + "y int references self_referencing_t1)");
1:8e47077:         s.execute("insert into self_referencing_t1 values (1, null), (2, 1)");
1:8e47077:         s.execute("truncate table self_referencing_t1");
1:b6fbed3:         JDBC.assertEmpty( s.executeQuery( "select * from self_referencing_t1" ) );
1:7775fc7:     }
1:b6fbed3: 
1:b6fbed3:     /**
1:b6fbed3:      * Test that dbo and owner can truncate table but no-one else can.
1:b6fbed3:      */
1:b6fbed3:     public void testPerms() throws Exception
1:b6fbed3:     {
1:b6fbed3:         Connection dboConnection = openUserConnection( TEST_DBO );
1:b6fbed3:         Connection aliceConnection = openUserConnection( ALICE );
1:b6fbed3:         Connection ruthConnection = openUserConnection( RUTH );
1:b6fbed3: 
1:b6fbed3:         Statement dboStatement = dboConnection.createStatement();
1:b6fbed3:         Statement aliceStatement = aliceConnection.createStatement();
1:b6fbed3:         Statement ruthStatement = ruthConnection.createStatement();
1:b6fbed3: 
1:b6fbed3:         // user can truncate her own table
1:b6fbed3:         aliceStatement.execute( "create table t_perm( a int )" );
1:b6fbed3:         aliceStatement.execute( "grant delete on t_perm to public" );
1:b6fbed3:         aliceStatement.execute( "grant select on t_perm to public" );
1:b6fbed3:         aliceStatement.execute( "insert into t_perm( a ) values ( 1 )" );
1:b6fbed3:         aliceStatement.execute( "truncate table t_perm" );
1:b6fbed3:         JDBC.assertEmpty( aliceStatement.executeQuery( "select * from t_perm" ) );
1:b6fbed3:         
1:b6fbed3:         // ordinary other user can't truncate table
1:b6fbed3:         aliceStatement.execute( "insert into t_perm( a ) values ( 2 )" );
1:b6fbed3:         assertStatementError( UNAUTHORIZED_OPERATION, ruthStatement, "truncate table alice.t_perm" );
1:b6fbed3:         JDBC.assertFullResultSet
1:b6fbed3:             (
1:b6fbed3:              ruthStatement.executeQuery( "select * from alice.t_perm" ),
1:b6fbed3:              new String[][] { { "2" } }
1:b6fbed3:              );
1:b6fbed3: 
1:b6fbed3:         // even though they are authorized to delete from the table
1:b6fbed3:         ruthStatement.execute( "delete from alice.t_perm" );
1:b6fbed3:         JDBC.assertEmpty( ruthStatement.executeQuery( "select * from alice.t_perm" ) );
1:b6fbed3:         
1:b6fbed3:         // the dbo, however, can truncate the table
1:b6fbed3:         aliceStatement.execute( "insert into t_perm( a ) values ( 3 )" );
1:b6fbed3:         JDBC.assertFullResultSet
1:b6fbed3:             (
1:b6fbed3:              aliceStatement.executeQuery( "select * from alice.t_perm" ),
1:b6fbed3:              new String[][] { { "3" } }
1:b6fbed3:              );
1:b6fbed3:         dboStatement.execute( "truncate table alice.t_perm" );
1:b6fbed3:         JDBC.assertEmpty( dboStatement.executeQuery( "select * from alice.t_perm" ) );
1:b6fbed3: 
1:b6fbed3:         // tidy up
1:b6fbed3:         dboStatement.close();
1:b6fbed3:         aliceStatement.close();
1:b6fbed3:         ruthStatement.close();
1:b6fbed3: 
1:b6fbed3:         dboConnection.close();
1:b6fbed3:         aliceConnection.close();
1:b6fbed3:         ruthConnection.close();
1:b6fbed3:     }
1:501b8b0: 
1:501b8b0:     /**
1:501b8b0:      * Test that TRUNCATE TABLE and DROP TABLE do not cause held cursors
1:501b8b0:      * to trip across an NPE. See DERBY-268.
1:501b8b0:      */
1:501b8b0:     public void testCursor() throws Exception
1:501b8b0:     {
1:501b8b0:         Connection cursorConnection = openUserConnection( ALICE );
1:501b8b0:         Connection truncatorConnection = openUserConnection( ALICE );
1:501b8b0: 
1:501b8b0:         cursorConnection.setAutoCommit( false );
1:501b8b0:         truncatorConnection.setAutoCommit( false );
1:501b8b0: 
1:501b8b0:         cursorMinion( cursorConnection, truncatorConnection, "truncateTab", "truncate table " );
1:501b8b0:         cursorMinion( cursorConnection, truncatorConnection, "dropTab", "drop table " );
1:501b8b0: 
1:501b8b0:         cursorConnection.close();
1:501b8b0:     }
1:501b8b0:     private void cursorMinion
1:501b8b0:         ( Connection cursorConnection, Connection truncatorConnection, String tableName, String truncationStub )
1:501b8b0:         throws Exception
1:501b8b0:     {
1:501b8b0:         Statement ddlStatement = cursorConnection.createStatement();
1:501b8b0:         Statement truncatorStatement = truncatorConnection.createStatement();
1:501b8b0: 
1:501b8b0:         ddlStatement.execute( "create table " + tableName + "( a int )" );
1:501b8b0:         ddlStatement.execute( "insert into " + tableName + "( a ) values ( 1 ), ( 2 )" );
1:501b8b0:         ddlStatement.close();
1:501b8b0:         cursorConnection.commit();
1:501b8b0: 
1:501b8b0:         Statement cursorStatement = cursorConnection.createStatement
1:501b8b0:             (
1:501b8b0:              ResultSet.TYPE_SCROLL_SENSITIVE,
1:501b8b0:              ResultSet.CONCUR_READ_ONLY,
1:501b8b0:              ResultSet.HOLD_CURSORS_OVER_COMMIT
1:501b8b0:              );
1:501b8b0:         ResultSet cursor = cursorStatement.executeQuery( "select * from " + tableName );
1:501b8b0: 
1:501b8b0:         // read first row, then commit the holdable cursor
1:501b8b0:         cursor.next();
1:501b8b0:         assertEquals( 1, cursor.getInt( 1 ) );
1:501b8b0:         cursorConnection.commit();
1:501b8b0: 
1:501b8b0:         // now truncate the table and commit
1:501b8b0:         truncatorStatement.execute( truncationStub + tableName );
1:501b8b0:         truncatorConnection.commit();
1:501b8b0: 
1:501b8b0:         // we expect to be able to finish draining the cursor
1:501b8b0:         cursor.next();
1:501b8b0:         assertEquals( 2, cursor.getInt( 1 ) );
1:501b8b0: 
1:501b8b0:         // and we expect to be told that the cursor is drained. this is
1:501b8b0:         // where the NPE was raised
1:501b8b0:         assertFalse( cursor.next() );
1:501b8b0:         
1:501b8b0:         cursor.close();
1:501b8b0:         cursorConnection.commit();
1:501b8b0:         
1:501b8b0:         cursorStatement.close();
1:501b8b0:         truncatorStatement.close();
1:501b8b0:     }
1:b6fbed3:     
1:5a56eb0:     /**
1:5a56eb0:      * Test that statement invalidation works when TRUNCATE TABLE statements
1:5a56eb0:      * and other statements accessing the same table execute concurrently.
1:5a56eb0:      * DERBY-4275.
1:5a56eb0:      */
1:5a56eb0:     public void testConcurrentInvalidation() throws Exception {
1:5a56eb0:         Statement s = createStatement();
1:5a56eb0:         s.execute("create table d4275(x int)");
1:5a56eb0: 
1:5a56eb0:         // Object used by the main thread to tell the helper thread to stop.
1:3f5c48a:         // The helper thread stops once the value is set to true.
1:3f5c48a:         final AtomicBoolean stop = new AtomicBoolean();
1:5a56eb0: 
1:5a56eb0:         // Holder for anything thrown by the run() method in the helper thread.
1:5a56eb0:         final Throwable[] error = new Throwable[1];
1:5a56eb0: 
1:5a56eb0:         // Set up a helper thread that executes a query against the table
1:5a56eb0:         // until the main thread tells it to stop.
1:5a56eb0:         Connection c2 = openDefaultConnection();
1:5a56eb0:         final PreparedStatement ps = c2.prepareStatement("select * from d4275");
1:5a56eb0: 
1:5a56eb0:         Thread t = new Thread() {
1:5a56eb0:             public void run() {
1:5a56eb0:                 try {
1:3f5c48a:                     while (!stop.get()) {
1:5a56eb0:                         JDBC.assertEmpty(ps.executeQuery());
1:5a56eb0:                     }
1:5a56eb0:                 } catch (Throwable t) {
1:5a56eb0:                     error[0] = t;
1:5a56eb0:                 }
1:5a56eb0:             }
1:5a56eb0:         };
1:5a56eb0: 
1:5a56eb0:         t.start();
1:5a56eb0: 
1:5a56eb0:         // Truncate the table while a query is being executed against the
1:5a56eb0:         // same table to force invalidation of the running statement. Since
1:5a56eb0:         // the problem we try to reproduce is timing-dependent, do it 100
1:5a56eb0:         // times to increase the chance of hitting the bug.
1:5a56eb0:         try {
1:5a56eb0:             for (int i = 0; i < 100; i++) {
1:5a56eb0:                 s.execute("truncate table d4275");
1:5a56eb0:             }
1:5a56eb0:         } finally {
1:5a56eb0:             // We're done, so tell the helper thread to stop.
1:3f5c48a:             stop.set(true);
1:5a56eb0:         }
1:5a56eb0: 
1:5a56eb0:         t.join();
1:5a56eb0: 
1:5a56eb0:         // Before DERBY-4275, the helper thread used to fail with an error
1:5a56eb0:         // saying the container was not found.
1:5a56eb0:         if (error[0] != null) {
1:5a56eb0:             fail("Helper thread failed", error[0]);
1:5a56eb0:         }
1:5a56eb0: 
1:5a56eb0:         // Cleanup.
1:5a56eb0:         ps.close();
1:5a56eb0:         c2.close();
1:5a56eb0:     }
1:8e47077: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicBoolean;
/////////////////////////////////////////////////////////////////////////
1:         // The helper thread stops once the value is set to true.
1:         final AtomicBoolean stop = new AtomicBoolean();
/////////////////////////////////////////////////////////////////////////
1:                     while (!stop.get()) {
/////////////////////////////////////////////////////////////////////////
1:             stop.set(true);
commit:5a56eb0
/////////////////////////////////////////////////////////////////////////
0: import java.util.ArrayList;
0: import java.util.Collections;
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that statement invalidation works when TRUNCATE TABLE statements
1:      * and other statements accessing the same table execute concurrently.
1:      * DERBY-4275.
1:      */
1:     public void testConcurrentInvalidation() throws Exception {
1:         Statement s = createStatement();
1:         s.execute("create table d4275(x int)");
1: 
1:         // Object used by the main thread to tell the helper thread to stop.
0:         // The helper thread stops once the list is non-empty.
0:         final List stop = Collections.synchronizedList(new ArrayList());
1: 
1:         // Holder for anything thrown by the run() method in the helper thread.
1:         final Throwable[] error = new Throwable[1];
1: 
1:         // Set up a helper thread that executes a query against the table
1:         // until the main thread tells it to stop.
1:         Connection c2 = openDefaultConnection();
1:         final PreparedStatement ps = c2.prepareStatement("select * from d4275");
1: 
1:         Thread t = new Thread() {
1:             public void run() {
1:                 try {
0:                     while (stop.isEmpty()) {
1:                         JDBC.assertEmpty(ps.executeQuery());
1:                     }
1:                 } catch (Throwable t) {
1:                     error[0] = t;
1:                 }
1:             }
1:         };
1: 
1:         t.start();
1: 
1:         // Truncate the table while a query is being executed against the
1:         // same table to force invalidation of the running statement. Since
1:         // the problem we try to reproduce is timing-dependent, do it 100
1:         // times to increase the chance of hitting the bug.
1:         try {
1:             for (int i = 0; i < 100; i++) {
1:                 s.execute("truncate table d4275");
1:             }
1:         } finally {
1:             // We're done, so tell the helper thread to stop.
0:             stop.add(Boolean.TRUE);
1:         }
1: 
1:         t.join();
1: 
1:         // Before DERBY-4275, the helper thread used to fail with an error
1:         // saying the container was not found.
1:         if (error[0] != null) {
1:             fail("Helper thread failed", error[0]);
1:         }
1: 
1:         // Cleanup.
1:         ps.close();
1:         c2.close();
1:     }
commit:84349af
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Workaround for DERBY-5139: If this test case happens to be running
1:         // first, before the schema ALICE has been created, the CREATE TABLE
1:         // statement below will fail. Normally, CREATE TABLE should create the
1:         // ALICE schema automatically, but for some reason that doesn't happen
1:         // when creating a self-referencing table. Create the schema manually
1:         // for now, if it doesn't already exist.
1:         try {
1:             s.execute("CREATE SCHEMA ALICE");
1:         } catch (SQLException sqle) {
1:             // It's OK to fail if schema already exists.
1:             assertSQLState("X0Y68", sqle);
1:         }
1: 
commit:21c9069
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         return TestConfiguration.defaultSuite(TruncateTableTest.class);
commit:8e47077
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that TRUNCATE TABLE cannot be performed on a table with a
1:      * delete trigger.
1:      */
1:     public void testTruncateWithDeleteTrigger() throws Exception {
0:         Statement s = createStatement();
1: 
1:         // Create two tables, t1 and t2, where deletes from t1 cause inserts
1:         // into t2.
1:         s.execute("create table deltriggertest_t1(x int)");
1:         s.execute("create table deltriggertest_t2(y int)");
1:         s.execute("create trigger deltriggertest_tr after delete on "
1:                 + "deltriggertest_t1 referencing old as old for each row "
1:                 + "insert into deltriggertest_t2 values old.x");
1: 
1:         // Prepare a statement that checks the number of rows in the
1:         // destination table (t2).
0:         PreparedStatement checkDest = prepareStatement(
1:                 "select count(*) from deltriggertest_t2");
1: 
1:         // Insert rows into t1, delete them, and verify that t2 has grown.
1:         s.execute("insert into deltriggertest_t1 values 1,2,3");
1:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "0");
1:         assertUpdateCount(s, 3, "delete from deltriggertest_t1");
1:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "3");
1: 
1:         // Now do the same with TRUNCATE instead of DELETE. Expect it to fail
1:         // because there is a delete trigger on the table.
1:         s.execute("insert into deltriggertest_t1 values 4,5");
1:         assertStatementError("XCL49", s, "truncate table deltriggertest_t1");
1:         JDBC.assertSingleValueResultSet(checkDest.executeQuery(), "3");
1:     }
1: 
1:     /**
1:      * Test that TRUNCATE TABLE isn't allowed on a table referenced by a
1:      * foreign key constraint on another table.
1:      */
1:     public void testTruncateWithForeignKey() throws SQLException {
0:         Statement s = createStatement();
1: 
1:         // Create two tables with a foreign key relationship.
1:         s.execute("create table foreignkey_t1(x int primary key)");
1:         s.execute("create table foreignkey_t2(y int references foreignkey_t1)");
1:         s.execute("insert into foreignkey_t1 values 1,2");
1:         s.execute("insert into foreignkey_t2 values 2");
1: 
1:         // Truncating the referenced table isn't allowed as that would
1:         // break referential integrity.
1:         assertStatementError("XCL48", s, "truncate table foreignkey_t1");
1: 
1:         // Truncating the referencing table is OK.
1:         s.execute("truncate table foreignkey_t2");
0:         assertTableRowCount("FOREIGNKEY_T2", 0);
1:     }
1: 
1:     /**
1:      * Test that TRUNCATE TABLE is allowed on a referenced table if it's only
1:      * referenced by itself.
1:      */
1:     public void testSelfReferencing() throws SQLException {
0:         Statement s = createStatement();
1:         s.execute("create table self_referencing_t1(x int primary key, "
1:                 + "y int references self_referencing_t1)");
1:         s.execute("insert into self_referencing_t1 values (1, null), (2, 1)");
1:         s.execute("truncate table self_referencing_t1");
0:         assertTableRowCount("SELF_REFERENCING_T1", 0);
1:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:501b8b0
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that TRUNCATE TABLE and DROP TABLE do not cause held cursors
1:      * to trip across an NPE. See DERBY-268.
1:      */
1:     public void testCursor() throws Exception
1:     {
1:         Connection cursorConnection = openUserConnection( ALICE );
1:         Connection truncatorConnection = openUserConnection( ALICE );
1: 
1:         cursorConnection.setAutoCommit( false );
1:         truncatorConnection.setAutoCommit( false );
1: 
1:         cursorMinion( cursorConnection, truncatorConnection, "truncateTab", "truncate table " );
1:         cursorMinion( cursorConnection, truncatorConnection, "dropTab", "drop table " );
1: 
1:         cursorConnection.close();
1:     }
1:     private void cursorMinion
1:         ( Connection cursorConnection, Connection truncatorConnection, String tableName, String truncationStub )
1:         throws Exception
1:     {
1:         Statement ddlStatement = cursorConnection.createStatement();
1:         Statement truncatorStatement = truncatorConnection.createStatement();
1: 
1:         ddlStatement.execute( "create table " + tableName + "( a int )" );
1:         ddlStatement.execute( "insert into " + tableName + "( a ) values ( 1 ), ( 2 )" );
1:         ddlStatement.close();
1:         cursorConnection.commit();
1: 
1:         Statement cursorStatement = cursorConnection.createStatement
1:             (
1:              ResultSet.TYPE_SCROLL_SENSITIVE,
1:              ResultSet.CONCUR_READ_ONLY,
1:              ResultSet.HOLD_CURSORS_OVER_COMMIT
1:              );
1:         ResultSet cursor = cursorStatement.executeQuery( "select * from " + tableName );
1: 
1:         // read first row, then commit the holdable cursor
1:         cursor.next();
1:         assertEquals( 1, cursor.getInt( 1 ) );
1:         cursorConnection.commit();
1: 
1:         // now truncate the table and commit
1:         truncatorStatement.execute( truncationStub + tableName );
1:         truncatorConnection.commit();
1: 
1:         // we expect to be able to finish draining the cursor
1:         cursor.next();
1:         assertEquals( 2, cursor.getInt( 1 ) );
1: 
1:         // and we expect to be told that the cursor is drained. this is
1:         // where the NPE was raised
1:         assertFalse( cursor.next() );
1:         
1:         cursor.close();
1:         cursorConnection.commit();
1:         
1:         cursorStatement.close();
1:         truncatorStatement.close();
1:     }
commit:b6fbed3
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      TEST_DBO = "TEST_DBO";
1:     private static  final   String      RUTH = "RUTH";
1:     private static  final   String      ALICE = "ALICE";
1:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, RUTH, ALICE };
1: 
1:     private static  final   String      UNAUTHORIZED_OPERATION = "42507";
1: 
1:         Test cleanTest = TestConfiguration.defaultSuite(TruncateTableTest.class);
1:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:             ( cleanTest, LEGAL_USERS, "" );
1:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1: 
1:         return authorizedTest;
/////////////////////////////////////////////////////////////////////////
1:         Connection aliceConnection = openUserConnection( ALICE );
1:         Statement st = aliceConnection.createStatement();
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertEmpty( st.executeQuery( "select * from t1" ) );
/////////////////////////////////////////////////////////////////////////
1:         st.close();
1:         aliceConnection.close();
/////////////////////////////////////////////////////////////////////////
1:         Connection aliceConnection = openUserConnection( ALICE );
1:         Statement s = aliceConnection.createStatement();
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement checkDest = aliceConnection.prepareStatement(
/////////////////////////////////////////////////////////////////////////
1:         Connection aliceConnection = openUserConnection( ALICE );
1:         Statement s = aliceConnection.createStatement();
/////////////////////////////////////////////////////////////////////////
1:         JDBC.assertEmpty( s.executeQuery( "select * from foreignkey_t2" ) );
/////////////////////////////////////////////////////////////////////////
1:         Connection aliceConnection = openUserConnection( ALICE );
1:         Statement s = aliceConnection.createStatement();
1:         JDBC.assertEmpty( s.executeQuery( "select * from self_referencing_t1" ) );
1: 
1:     /**
1:      * Test that dbo and owner can truncate table but no-one else can.
1:      */
1:     public void testPerms() throws Exception
1:     {
1:         Connection dboConnection = openUserConnection( TEST_DBO );
1:         Connection aliceConnection = openUserConnection( ALICE );
1:         Connection ruthConnection = openUserConnection( RUTH );
1: 
1:         Statement dboStatement = dboConnection.createStatement();
1:         Statement aliceStatement = aliceConnection.createStatement();
1:         Statement ruthStatement = ruthConnection.createStatement();
1: 
1:         // user can truncate her own table
1:         aliceStatement.execute( "create table t_perm( a int )" );
1:         aliceStatement.execute( "grant delete on t_perm to public" );
1:         aliceStatement.execute( "grant select on t_perm to public" );
1:         aliceStatement.execute( "insert into t_perm( a ) values ( 1 )" );
1:         aliceStatement.execute( "truncate table t_perm" );
1:         JDBC.assertEmpty( aliceStatement.executeQuery( "select * from t_perm" ) );
1:         
1:         // ordinary other user can't truncate table
1:         aliceStatement.execute( "insert into t_perm( a ) values ( 2 )" );
1:         assertStatementError( UNAUTHORIZED_OPERATION, ruthStatement, "truncate table alice.t_perm" );
1:         JDBC.assertFullResultSet
1:             (
1:              ruthStatement.executeQuery( "select * from alice.t_perm" ),
1:              new String[][] { { "2" } }
1:              );
1: 
1:         // even though they are authorized to delete from the table
1:         ruthStatement.execute( "delete from alice.t_perm" );
1:         JDBC.assertEmpty( ruthStatement.executeQuery( "select * from alice.t_perm" ) );
1:         
1:         // the dbo, however, can truncate the table
1:         aliceStatement.execute( "insert into t_perm( a ) values ( 3 )" );
1:         JDBC.assertFullResultSet
1:             (
1:              aliceStatement.executeQuery( "select * from alice.t_perm" ),
1:              new String[][] { { "3" } }
1:              );
1:         dboStatement.execute( "truncate table alice.t_perm" );
1:         JDBC.assertEmpty( dboStatement.executeQuery( "select * from alice.t_perm" ) );
1: 
1:         // tidy up
1:         dboStatement.close();
1:         aliceStatement.close();
1:         ruthStatement.close();
1: 
1:         dboConnection.close();
1:         aliceConnection.close();
1:         ruthConnection.close();
1:     }
1:     
commit:3a4b2df
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1:  * Tests for TRUNCATE TABLE.
1:  * 
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("TruncateTableTest Test");
0:         suite.addTest(TestConfiguration.defaultSuite(TruncateTableTest.class));
0:         return TestConfiguration.sqlAuthorizationDecorator(suite);
1:      * columns. Verify that default "CONTINUE IDENTITY" semantics are enforced.
0:         Statement st = createStatement();
1:         ResultSet rs;
1:         String[][] expRS;
1:         //creating a table with one column auto filled with a unique value
1:         st.executeUpdate("create table t1(a int not null generated always as identity primary key, b varchar(100))");
1:         //populate the table
1:         st.executeUpdate("insert into t1(b) values('one'),('two'),('three'),('four'),('five')");
1:         //varify the inserted values
1:         rs = st.executeQuery("select * from t1 order by a");
1:         expRS = new String[][]{
1:                         {"1","one"},
1:                         {"2","two"},
1:                         {"3","three"},
1:                         {"4","four"},
1:                         {"5","five"}
1:                 };
1:         JDBC.assertFullResultSet(rs, expRS);
1:         //executing the truncate table
1:         st.executeUpdate("truncate table t1");
1:         //confirm whether the truncation worked
0:         assertTableRowCount("T1", 0);
1: 
1:         //testing whether the truncation work as "CONTINUE IDENTITY"
1:         //semantics are enforced
1:         st.executeUpdate("insert into t1(b) values('six'),('seven')");
1:         rs = st.executeQuery("select * from t1 order by a");
1:         expRS = new String[][]{
1:                         {"6","six"},
1:                         {"7","seven"}
1:                 };
1:         JDBC.assertFullResultSet(rs, expRS);
1: 
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:7775fc7
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.TruncateTableTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
0:  * Tests for TRUNCATE TABLE. Currently, Derby only supports TRUNCATE TABLE in
0:  * debug builds.
1:  */
1: public class TruncateTableTest extends BaseJDBCTestCase {
1: 
1:     public TruncateTableTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         if (!SanityManager.DEBUG) {
0:             // Since Derby doesn't support TRUNCATE TABLE in non-debug builds,
0:             // only test that a "not implemented" exception is thrown.
0:             return new TruncateTableTest("unsupportedInInsaneBuilds");
1:         }
0:         return TestConfiguration.defaultSuite(TruncateTableTest.class);
1:     }
1: 
1:     /**
0:      * Test that a "not implemented" exception is thrown if TRUNCATE TABLE
0:      * is used in insane builds.
1:      */
0:     public void unsupportedInInsaneBuilds() throws SQLException {
0:         assertFalse("Not to be tested in sane builds", SanityManager.DEBUG);
0:         assertStatementError("0A000", createStatement(),
0:                              "truncate table table_that_does_not_exist");
1:     }
1: 
1:     /**
1:      * Test that TRUNCATE TABLE works when there is an index on one of the
0:      * columns. (This code would throw a {@code NullPointerException} before
0:      * DERBY-3352 was fixed).
1:      */
1:     public void testTruncateWithIndex() throws SQLException {
0:         Statement s = createStatement();
0:         s.execute("create table t_with_index (x varchar(128) unique, y int)");
0:         s.execute("insert into t_with_index values ('one', 1), ('two', 2)");
0:         s.execute("truncate table t_with_index");
0:         assertTableRowCount("T_WITH_INDEX", 0);
1:     }
1: }
============================================================================