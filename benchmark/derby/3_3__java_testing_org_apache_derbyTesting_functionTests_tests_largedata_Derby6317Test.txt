1:b25e3a7: package org.apache.derbyTesting.functionTests.tests.largedata;
4:b25e3a7: 
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:b25e3a7: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:b25e3a7: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:b25e3a7: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:b25e3a7: import org.apache.derbyTesting.junit.SQLUtilities;
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: /*
1:b25e3a7: Class org.apache.derbyTesting.functionTests.tests.largedata.Derby6317Test
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: Licensed to the Apache Software Foundation (ASF) under one or more
1:b25e3a7: contributor license agreements.  See the NOTICE file distributed with
1:b25e3a7: this work for additional information regarding copyright ownership.
1:b25e3a7: The ASF licenses this file to you under the Apache License, Version 2.0
1:b25e3a7: (the "License"); you may not use this file except in compliance with
1:b25e3a7: the License.  You may obtain a copy of the License at
1:b25e3a7: 
1:b25e3a7:    http://www.apache.org/licenses/LICENSE-2.0
1:b25e3a7: 
1:b25e3a7: Unless required by applicable law or agreed to in writing, software
1:b25e3a7: distributed under the License is distributed on an "AS IS" BASIS,
1:b25e3a7: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b25e3a7: See the License for the specific language governing permissions and
1:b25e3a7: limitations under the License.
1:b25e3a7: 
1:b25e3a7: */
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: /**
1:b25e3a7: Test to reproduce DERBY-6317(Optmizer can choose the wrong path when 
1:b25e3a7: BTreeCostController.java returns an estimate cost and row count of 0.0)
1:b25e3a7: 
1:b25e3a7: This test creates three tables and creates primary keys and foreign
1:b25e3a7: key constraints on them. Then we insert really large data in those
1:b25e3a7: three tables. Prior to DERBY-6317, there were times when we would do
1:b25e3a7: table scan rather than using index on a give join query. It turned out
1:b25e3a7: that the reason was that estimated count was less than 0.5 for such
1:b25e3a7: queries and hence it got rounded to 0 which caused the optimizer to
1:b25e3a7: do a table scan instead of index scan.
1:b25e3a7: 
1:b25e3a7: Query plan for a table scan - buggy scenario -
1:b25e3a7:     notice t0.Table3_ID is assigned 5189284
1:b25e3a7:     
1:b25e3a7: Statement Text: 
1:b25e3a7: 	SELECT * FROM Table1 T1,Table2 t0 WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = 5189284
1:b25e3a7: Number of opens = 1
1:b25e3a7: Rows seen = 0
1:b25e3a7: Rows filtered = 0
1:b25e3a7: restriction = false
1:b25e3a7: projection = true
1:b25e3a7: 	constructor time (milliseconds) = 0
1:b25e3a7: 	open time (milliseconds) = 0
1:b25e3a7: 	next time (milliseconds) = 0
1:b25e3a7: 	close time (milliseconds) = 0
1:b25e3a7: 	restriction time (milliseconds) = 0
1:b25e3a7: 	projection time (milliseconds) = 0
1:b25e3a7: 	optimizer estimated row count: 0.00
1:b25e3a7: 	optimizer estimated cost: 6.33
1:b25e3a7: Source result set:
1:b25e3a7: 	Nested Loop Join ResultSet:
1:b25e3a7: 	Number of opens = 1
1:b25e3a7: 	Rows seen from the left = 1
1:b25e3a7: 	Rows seen from the right = 0
1:b25e3a7: 	Rows filtered = 0
1:b25e3a7: 	Rows returned = 0
1:b25e3a7: 		constructor time (milliseconds) = 0
1:b25e3a7: 		open time (milliseconds) = 0
1:b25e3a7: 		next time (milliseconds) = 0
1:b25e3a7: 		close time (milliseconds) = 0
1:b25e3a7: 		optimizer estimated row count: 0.00
1:b25e3a7: 		optimizer estimated cost: 6.33
1:b25e3a7: 	Left result set:
1:b25e3a7: 		Index Row to Base Row ResultSet for TABLE2:
1:b25e3a7: 		Number of opens = 1
1:b25e3a7: 		Rows seen = 1
1:b25e3a7: 		Columns accessed from heap = {0, 1}
1:b25e3a7: 			constructor time (milliseconds) = 0
1:b25e3a7: 			open time (milliseconds) = 0
1:b25e3a7: 			next time (milliseconds) = 0
1:b25e3a7: 			close time (milliseconds) = 0
1:b25e3a7: 			optimizer estimated row count: 0.00
1:b25e3a7: 			optimizer estimated cost: 6.33
1:b25e3a7: 			Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1:b25e3a7: 			Number of opens = 1
1:b25e3a7: 			Rows seen = 1
1:b25e3a7: 			Rows filtered = 0
1:b25e3a7: 			Fetch Size = 16
1:b25e3a7: 				constructor time (milliseconds) = 0
1:b25e3a7: 				open time (milliseconds) = 0
1:b25e3a7: 				next time (milliseconds) = 0
1:b25e3a7: 				close time (milliseconds) = 0
1:b25e3a7: 				next time in milliseconds/row = 0
1:b25e3a7: 
1:b25e3a7: 			scan information:
1:b25e3a7: 				Bit set of columns fetched=All
1:b25e3a7: 				Number of columns fetched=2
1:b25e3a7: 				Number of deleted rows visited=0
1:b25e3a7: 				Number of pages visited=4
1:b25e3a7: 				Number of rows qualified=1
1:b25e3a7: 				Number of rows visited=2
1:b25e3a7: 				Scan type=btree
1:b25e3a7: 				Tree height=4
1:b25e3a7: 				start position:
1:dbed020: 					&gt;= on first 1 column(s).
1:b25e3a7: 					Ordered null semantics on the following columns: 
1:b25e3a7: 					0 
1:b25e3a7: 				stop position:
1:dbed020: 					&gt; on first 1 column(s).
1:b25e3a7: 					Ordered null semantics on the following columns: 
1:b25e3a7: 					0 
1:b25e3a7: 				qualifiers:
1:b25e3a7: 					None
1:b25e3a7: 				optimizer estimated row count: 0.00
1:b25e3a7: 				optimizer estimated cost: 6.33
1:b25e3a7: 
1:b25e3a7: 	Right result set:
1:b25e3a7: 		Table Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1:b25e3a7: 		Number of opens = 1
1:b25e3a7: 		Rows seen = 0
1:b25e3a7: 		Rows filtered = 0
1:b25e3a7: 		Fetch Size = 16
1:b25e3a7: 			constructor time (milliseconds) = 0
1:b25e3a7: 			open time (milliseconds) = 0
1:b25e3a7: 			next time (milliseconds) = 0
1:b25e3a7: 			close time (milliseconds) = 0
1:b25e3a7: 
1:b25e3a7: 		scan information:
1:b25e3a7: 			Bit set of columns fetched=All
1:b25e3a7: 			Number of columns fetched=1
1:b25e3a7: 			Number of pages visited=0
1:b25e3a7: 			Number of rows qualified=0
1:b25e3a7: 			Number of rows visited=0
1:b25e3a7: 			Scan type=heap
1:b25e3a7: 			start position:
1:b25e3a7: 				null
1:b25e3a7: 			stop position:
1:b25e3a7: 				null
1:b25e3a7: 			qualifiers:
1:b25e3a7: 				Column[0][0] Id: 0
1:b25e3a7: 				Operator: =
1:b25e3a7: 				Ordered nulls: false
1:b25e3a7: 				Unknown return value: false
1:b25e3a7: 				Negate comparison result: false
1:b25e3a7: 			optimizer estimated row count: 0.00
1:b25e3a7: 			optimizer estimated cost: 0.00
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: Query plan for index scan - the correct behavior - 
1:b25e3a7:     notice t0.Table3_ID is assigned 5189285
1:b25e3a7: 
1:b25e3a7: Statement Text: 
1:b25e3a7: 	SELECT * FROM Table1 T1,Table2 t0 WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = 5189285
1:b25e3a7: Number of opens = 1
1:b25e3a7: Rows seen = 1
1:b25e3a7: Rows filtered = 0
1:b25e3a7: restriction = false
1:b25e3a7: projection = true
1:b25e3a7: 	constructor time (milliseconds) = 0
1:b25e3a7: 	open time (milliseconds) = 0
1:b25e3a7: 	next time (milliseconds) = 0
1:b25e3a7: 	close time (milliseconds) = 0
1:b25e3a7: 	restriction time (milliseconds) = 0
1:b25e3a7: 	projection time (milliseconds) = 0
1:b25e3a7: 	optimizer estimated row count: 1.00
1:b25e3a7: 	optimizer estimated cost: 12.72
1:b25e3a7: Source result set:
1:b25e3a7: 	Scalar Aggregate ResultSet:
1:b25e3a7: 	Number of opens = 1
1:b25e3a7: 	Rows input = 1
1:b25e3a7: 		constructor time (milliseconds) = 0
1:b25e3a7: 		open time (milliseconds) = 0
1:b25e3a7: 		next time (milliseconds) = 0
1:b25e3a7: 		close time (milliseconds) = 0
1:b25e3a7: 		optimizer estimated row count: 1.00
1:b25e3a7: 		optimizer estimated cost: 12.72
1:b25e3a7: 	Index Key Optimization = false
1:b25e3a7: 	Source result set:
1:b25e3a7: 		Project-Restrict ResultSet (6):
1:b25e3a7: 		Number of opens = 1
1:b25e3a7: 		Rows seen = 1
1:b25e3a7: 		Rows filtered = 0
1:b25e3a7: 		restriction = false
1:b25e3a7: 		projection = true
1:b25e3a7: 			constructor time (milliseconds) = 0
1:b25e3a7: 			open time (milliseconds) = 0
1:b25e3a7: 			next time (milliseconds) = 0
1:b25e3a7: 			close time (milliseconds) = 0
1:b25e3a7: 			restriction time (milliseconds) = 0
1:b25e3a7: 			projection time (milliseconds) = 0
1:b25e3a7: 			optimizer estimated row count: 1.00
1:b25e3a7: 			optimizer estimated cost: 12.72
1:b25e3a7: 		Source result set:
1:b25e3a7: 			Nested Loop Exists Join ResultSet:
1:b25e3a7: 			Number of opens = 1
1:b25e3a7: 			Rows seen from the left = 1
1:b25e3a7: 			Rows seen from the right = 1
1:b25e3a7: 			Rows filtered = 0
1:b25e3a7: 			Rows returned = 1
1:b25e3a7: 				constructor time (milliseconds) = 0
1:b25e3a7: 				open time (milliseconds) = 0
1:b25e3a7: 				next time (milliseconds) = 0
1:b25e3a7: 				close time (milliseconds) = 0
1:b25e3a7: 				optimizer estimated row count: 1.00
1:b25e3a7: 				optimizer estimated cost: 12.72
1:b25e3a7: 			Left result set:
1:b25e3a7: 				Index Row to Base Row ResultSet for TABLE2:
1:b25e3a7: 				Number of opens = 1
1:b25e3a7: 				Rows seen = 1
1:b25e3a7: 				Columns accessed from heap = {0, 1}
1:b25e3a7: 					constructor time (milliseconds) = 0
1:b25e3a7: 					open time (milliseconds) = 0
1:b25e3a7: 					next time (milliseconds) = 0
1:b25e3a7: 					close time (milliseconds) = 0
1:b25e3a7: 					optimizer estimated row count: 1.00
1:b25e3a7: 					optimizer estimated cost: 8.01
1:b25e3a7: 					Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1:b25e3a7: 					Number of opens = 1
1:b25e3a7: 					Rows seen = 1
1:b25e3a7: 					Rows filtered = 0
1:b25e3a7: 					Fetch Size = 16
1:b25e3a7: 						constructor time (milliseconds) = 0
1:b25e3a7: 						open time (milliseconds) = 0
1:b25e3a7: 						next time (milliseconds) = 0
1:b25e3a7: 						close time (milliseconds) = 0
1:b25e3a7: 						next time in milliseconds/row = 0
1:b25e3a7: 
1:b25e3a7: 					scan information:
1:b25e3a7: 						Bit set of columns fetched=All
1:b25e3a7: 						Number of columns fetched=2
1:b25e3a7: 						Number of deleted rows visited=0
1:b25e3a7: 						Number of pages visited=4
1:b25e3a7: 						Number of rows qualified=1
1:b25e3a7: 						Number of rows visited=2
1:b25e3a7: 						Scan type=btree
1:b25e3a7: 						Tree height=-1
1:b25e3a7: 						start position:
1:dbed020: 							&gt;= on first 1 column(s).
1:b25e3a7: 							Ordered null semantics on the following columns: 
1:b25e3a7: 							0 
1:b25e3a7: 						stop position:
1:dbed020: 							&gt; on first 1 column(s).
1:b25e3a7: 							Ordered null semantics on the following columns: 
1:b25e3a7: 							0 
1:b25e3a7: 						qualifiers:
1:b25e3a7: 							None
1:b25e3a7: 						optimizer estimated row count: 1.00
1:b25e3a7: 						optimizer estimated cost: 8.01
1:b25e3a7: 
1:b25e3a7: 			Right result set:
1:b25e3a7: 				Index Scan ResultSet for TABLE1 using constraint SQL130904105604940 at read committed isolation level using share row locking chosen by the optimizer
1:b25e3a7: 				Number of opens = 1
1:b25e3a7: 				Rows seen = 1
1:b25e3a7: 				Rows filtered = 0
1:b25e3a7: 				Fetch Size = 1
1:b25e3a7: 					constructor time (milliseconds) = 0
1:b25e3a7: 					open time (milliseconds) = 0
1:b25e3a7: 					next time (milliseconds) = 0
1:b25e3a7: 					close time (milliseconds) = 0
1:b25e3a7: 					next time in milliseconds/row = 0
1:b25e3a7: 
1:b25e3a7: 				scan information:
1:b25e3a7: 					Bit set of columns fetched={0}
1:b25e3a7: 					Number of columns fetched=1
1:b25e3a7: 					Number of deleted rows visited=0
1:b25e3a7: 					Number of pages visited=3
1:b25e3a7: 					Number of rows qualified=1
1:b25e3a7: 					Number of rows visited=1
1:b25e3a7: 					Scan type=btree
1:b25e3a7: 					Tree height=3
1:b25e3a7: 					start position:
1:dbed020: 						&gt;= on first 1 column(s).
1:b25e3a7: 						Ordered null semantics on the following columns: 
1:b25e3a7: 						0 
1:b25e3a7: 					stop position:
1:dbed020: 						&gt; on first 1 column(s).
1:b25e3a7: 						Ordered null semantics on the following columns: 
1:b25e3a7: 						0 
1:b25e3a7: 					qualifiers:
1:b25e3a7: 						None
1:b25e3a7: 					optimizer estimated row count: 1.00
1:b25e3a7: 					optimizer estimated cost: 4.71
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: 
1:b25e3a7: **/
1:b25e3a7: 
1:b25e3a7: public class Derby6317Test extends BaseJDBCTestCase
1:b25e3a7: {
1:b25e3a7:     final static int DATABASE_SCALE = 1000000;
1:b25e3a7:     final static int TABLE_ONE_ROW_COUNT = DATABASE_SCALE;
1:b25e3a7:     final static int TABLE_THREE_ROW_COUNT = DATABASE_SCALE*8;
1:b25e3a7:     final static int SELECT_ROWS_COUNT = DATABASE_SCALE*8;
1:b25e3a7: 
1:b25e3a7:     final String testSelect=
1:b25e3a7:         "SELECT * FROM "+
1:b25e3a7:         "Table1 T1,"+
1:b25e3a7:         "Table2 t0 "+
1:b25e3a7:         "WHERE t1.ID = t0.Table1_ID and "+
1:b25e3a7:         "t0.Table3_ID = "; 
1:b25e3a7: 
1:b25e3a7:     public Derby6317Test(String name) 
1:b25e3a7:     {
1:b25e3a7:         super(name);
1:b25e3a7:     }
1:b25e3a7: 
1:b25e3a7:     public static Test suite() 
1:b25e3a7:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Derby6317Test");
1:b25e3a7:         suite.addTest(baseSuite("Derby6317Test:embedded"));
1:b25e3a7:         return suite;
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Confirm that both the tables involved in the SELECT statement are using
1:b25e3a7:     // index scan. Prior to fix for DERBY-6317, some SOME_CONSTANT values
1:b25e3a7:     // would do table scan on TABLE1 rather than an index scan.
1:b25e3a7:     // SELECT * FROM Table1 T1, Table2 t0 
1:b25e3a7:     //  WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = SOME_CONSTANT
1:b25e3a7:     private void confirmIndexScanUsage(Statement stmt, int some_constant)
1:b25e3a7:         throws SQLException {
1:b25e3a7:         RuntimeStatisticsParser rtsp;
1:b25e3a7:         boolean constraintUsed;
1:b25e3a7:         rtsp = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:b25e3a7:         constraintUsed = rtsp.usedConstraintForIndexScan("TABLE1");
1:b25e3a7:         if (!constraintUsed){
1:b25e3a7:             assertTrue("Should have done index scan but did table scan on " + 
1:b25e3a7:                 "TABLE1 for t0.Table3_ID = "+some_constant, constraintUsed);
1:b25e3a7:         }
1:b25e3a7:         constraintUsed = rtsp.usedConstraintForIndexScan("TABLE2");
1:b25e3a7:         if (!constraintUsed){
1:b25e3a7:             assertTrue("Should have done index scan but did table scan on " +
1:b25e3a7:                 "TABLE2 for t0.Table3_ID = "+some_constant, constraintUsed);
1:b25e3a7:         }    	
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //5189284 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value1()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 5189284);
1:b25e3a7:         confirmIndexScanUsage(stmt, 5189284);
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //6035610 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value2()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 6035610);
1:b25e3a7:         confirmIndexScanUsage(stmt, 6035610);
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //6031628 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value3()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 6031628);
1:b25e3a7:         confirmIndexScanUsage(stmt, 6031628);
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //5189284 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value4()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 5189285);
1:b25e3a7:         confirmIndexScanUsage(stmt, 5189285);
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //6035609 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value6()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 6035609);
1:b25e3a7:         confirmIndexScanUsage(stmt, 6035609);
1:b25e3a7:     }
1:b25e3a7:     
1:b25e3a7:     //Test just one specific value in the SELECT and see what kind of plan
1:b25e3a7:     // is picked up for it.
1:b25e3a7:     //1 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:b25e3a7:     public void testDERBY_6317_value5()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         stmt.execute(testSelect + 1);
1:b25e3a7:         confirmIndexScanUsage(stmt, 1);
1:b25e3a7:     }
1:b25e3a7: 
1:b25e3a7:     //This test is really really time consuming because it is going through
1:b25e3a7:     // 8million selects individually. Before DERBY-6317, it would take 
1:b25e3a7:     // about 4-5hrs to finish and stop right after the first failure which
1:b25e3a7:     // was on 5,189,284. The leftover selects out of 8million did not get
1:b25e3a7:     // run because of the failure. But once DERBY-6317 is fixed, the test
1:b25e3a7:     // takes even longer because it will go through 8 million rows rather
1:b25e3a7:     // than stop after about 5million rows. The time it takes for the 
1:b25e3a7:     // test to finish after DERBY-6317 is about 10hrs
1:b25e3a7:     //
1:b25e3a7:     // TODO - test name does not start with "test" so not run by default
1:b25e3a7:     // in the largedata suite, due to time it takes to run.  May make sense
1:b25e3a7:     // to run this test once a release.  The other fixtures currently
1:b25e3a7:     // test the problem area, but even a subtle change to the layout of
1:b25e3a7:     // records in the btree could make the particular values chosen not
1:b25e3a7:     // repro the previous bug.
1:b25e3a7:     public void dontrun_testDERBY_6317()
1:b25e3a7:         throws SQLException {
1:b25e3a7:         Statement stmt = createStatement();
1:b25e3a7:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:b25e3a7:         for (int i = 0; i < SELECT_ROWS_COUNT; i++) { 
1:b25e3a7:             stmt.execute(testSelect+i);
1:b25e3a7:             confirmIndexScanUsage(stmt,i);
1:b25e3a7:         }
1:b25e3a7:     }
1:b25e3a7: 
1:b25e3a7:     protected static Test baseSuite(String name) 
1:b25e3a7:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:b25e3a7:         suite.addTestSuite(Derby6317Test.class);
1:b25e3a7:         return new CleanDatabaseTestSetup(suite)
1:b25e3a7:         {
1:b25e3a7:             /**
1:b25e3a7:              * Creates the tables used in the test cases.
1:b25e3a7:              * @exception SQLException if a database error occurs
1:b25e3a7:              */
1:b25e3a7:             protected void decorateSQL(Statement stmt) throws SQLException
1:b25e3a7:             {
1:b25e3a7:                 Connection conn = stmt.getConnection();
1:b25e3a7: 
1:b25e3a7:                 stmt.executeUpdate("CREATE TABLE Table1 ("+
1:b25e3a7:                 		"ID int PRIMARY KEY NOT NULL)");
1:b25e3a7: 
1:b25e3a7:                 stmt.executeUpdate("CREATE TABLE Table2 ("+
1:b25e3a7:                 		"Table1_ID int NOT NULL,"+
1:b25e3a7:                 		"Table3_ID int NOT NULL,"+
1:b25e3a7:                 		"CONSTRAINT TABLE2_PK PRIMARY KEY "+
1:b25e3a7:                 		"(Table1_ID,Table3_ID))");
1:b25e3a7:                 
1:b25e3a7:                 stmt.executeUpdate("CREATE TABLE Table3 ("+
1:b25e3a7:                 		"ID int PRIMARY KEY NOT NULL)"); 
1:b25e3a7: 
1:b25e3a7:                 stmt.executeUpdate("ALTER TABLE table2 "+
1:b25e3a7:                         "ADD CONSTRAINT TABLE2_FK_1 "+
1:b25e3a7:                         "FOREIGN KEY (Table1_ID) "+
1:b25e3a7:                         "REFERENCES TABLE1(ID)");
1:b25e3a7:                 stmt.executeUpdate("ALTER TABLE table2 "+
1:b25e3a7:                         "ADD CONSTRAINT TABLE2_FK_2 "+
1:b25e3a7:                         "FOREIGN KEY (Table3_ID) "+
1:b25e3a7:                         "REFERENCES TABLE3(ID)");
1:b25e3a7: 
1:b25e3a7:                 conn.setAutoCommit(false);
1:b25e3a7:                 
1:b25e3a7:                 PreparedStatement insertPS = getConnection().prepareStatement(
1:b25e3a7:             		  "INSERT INTO table1 VALUES (?)");
1:b25e3a7:                 for (int i = 0; i < TABLE_ONE_ROW_COUNT; i++) { 
1:b25e3a7:                     insertPS.setInt(1,i);
1:b25e3a7:                     insertPS.execute();
1:b25e3a7:                     if (i%10000 == 0)
1:b25e3a7:       	    		    conn.commit();
1:b25e3a7:                 } 
1:b25e3a7:                 conn.commit();
1:b25e3a7:                 int count = TABLE_THREE_ROW_COUNT; 
1:b25e3a7:                 insertPS = conn.prepareStatement("INSERT INTO table3 VALUES (?)");
1:b25e3a7:                 for (int i = 0; i < count; i++) { 
1:b25e3a7:                     insertPS.setInt(1,i);
1:b25e3a7:                     insertPS.execute();
1:b25e3a7:           	        if (i%10000 == 0)
1:b25e3a7:           	            conn.commit();
1:b25e3a7:                 } 
1:b25e3a7:                 conn.commit();
1:b25e3a7:                 //In TABLE2, we will insert 8 million rows.
1:b25e3a7:                 insertPS = conn.prepareStatement("INSERT INTO table2 VALUES (?,?)");
1:b25e3a7:                 for (int i = 0, j=0; i < TABLE_ONE_ROW_COUNT; i++) { 
1:b25e3a7:                 	insertPS.setInt(1,i);
1:b25e3a7:        	            for (int k=0; k<8; k++,j++) {
1:b25e3a7:                         insertPS.setInt(2,j);
1:b25e3a7:           	            insertPS.execute();
1:b25e3a7:                     }
1:b25e3a7:               	    if (i%10000 == 0)
1:b25e3a7:               	        conn.commit();
1:b25e3a7:                 }
1:b25e3a7:                 conn.commit();
1:b25e3a7:             }
1:b25e3a7:         };
1:b25e3a7:     }
1:b25e3a7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 					&gt;= on first 1 column(s).
1: 					&gt; on first 1 column(s).
/////////////////////////////////////////////////////////////////////////
1: 							&gt;= on first 1 column(s).
1: 							&gt; on first 1 column(s).
/////////////////////////////////////////////////////////////////////////
1: 						&gt;= on first 1 column(s).
1: 						&gt; on first 1 column(s).
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Derby6317Test");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b25e3a7
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.largedata;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.SQLException;
1: 
1: 
1: /*
1: Class org.apache.derbyTesting.functionTests.tests.largedata.Derby6317Test
1: 
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to you under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: 
1: /**
1: Test to reproduce DERBY-6317(Optmizer can choose the wrong path when 
1: BTreeCostController.java returns an estimate cost and row count of 0.0)
1: 
1: This test creates three tables and creates primary keys and foreign
1: key constraints on them. Then we insert really large data in those
1: three tables. Prior to DERBY-6317, there were times when we would do
1: table scan rather than using index on a give join query. It turned out
1: that the reason was that estimated count was less than 0.5 for such
1: queries and hence it got rounded to 0 which caused the optimizer to
1: do a table scan instead of index scan.
1: 
1: Query plan for a table scan - buggy scenario -
1:     notice t0.Table3_ID is assigned 5189284
1:     
1: Statement Text: 
1: 	SELECT * FROM Table1 T1,Table2 t0 WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = 5189284
1: Number of opens = 1
1: Rows seen = 0
1: Rows filtered = 0
1: restriction = false
1: projection = true
1: 	constructor time (milliseconds) = 0
1: 	open time (milliseconds) = 0
1: 	next time (milliseconds) = 0
1: 	close time (milliseconds) = 0
1: 	restriction time (milliseconds) = 0
1: 	projection time (milliseconds) = 0
1: 	optimizer estimated row count: 0.00
1: 	optimizer estimated cost: 6.33
1: Source result set:
1: 	Nested Loop Join ResultSet:
1: 	Number of opens = 1
1: 	Rows seen from the left = 1
1: 	Rows seen from the right = 0
1: 	Rows filtered = 0
1: 	Rows returned = 0
1: 		constructor time (milliseconds) = 0
1: 		open time (milliseconds) = 0
1: 		next time (milliseconds) = 0
1: 		close time (milliseconds) = 0
1: 		optimizer estimated row count: 0.00
1: 		optimizer estimated cost: 6.33
1: 	Left result set:
1: 		Index Row to Base Row ResultSet for TABLE2:
1: 		Number of opens = 1
1: 		Rows seen = 1
1: 		Columns accessed from heap = {0, 1}
1: 			constructor time (milliseconds) = 0
1: 			open time (milliseconds) = 0
1: 			next time (milliseconds) = 0
1: 			close time (milliseconds) = 0
1: 			optimizer estimated row count: 0.00
1: 			optimizer estimated cost: 6.33
1: 			Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1: 			Number of opens = 1
1: 			Rows seen = 1
1: 			Rows filtered = 0
1: 			Fetch Size = 16
1: 				constructor time (milliseconds) = 0
1: 				open time (milliseconds) = 0
1: 				next time (milliseconds) = 0
1: 				close time (milliseconds) = 0
1: 				next time in milliseconds/row = 0
1: 
1: 			scan information:
1: 				Bit set of columns fetched=All
1: 				Number of columns fetched=2
1: 				Number of deleted rows visited=0
1: 				Number of pages visited=4
1: 				Number of rows qualified=1
1: 				Number of rows visited=2
1: 				Scan type=btree
1: 				Tree height=4
1: 				start position:
0: 					>= on first 1 column(s).
1: 					Ordered null semantics on the following columns: 
1: 					0 
1: 				stop position:
0: 					> on first 1 column(s).
1: 					Ordered null semantics on the following columns: 
1: 					0 
1: 				qualifiers:
1: 					None
1: 				optimizer estimated row count: 0.00
1: 				optimizer estimated cost: 6.33
1: 
1: 	Right result set:
1: 		Table Scan ResultSet for TABLE1 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1: 		Number of opens = 1
1: 		Rows seen = 0
1: 		Rows filtered = 0
1: 		Fetch Size = 16
1: 			constructor time (milliseconds) = 0
1: 			open time (milliseconds) = 0
1: 			next time (milliseconds) = 0
1: 			close time (milliseconds) = 0
1: 
1: 		scan information:
1: 			Bit set of columns fetched=All
1: 			Number of columns fetched=1
1: 			Number of pages visited=0
1: 			Number of rows qualified=0
1: 			Number of rows visited=0
1: 			Scan type=heap
1: 			start position:
1: 				null
1: 			stop position:
1: 				null
1: 			qualifiers:
1: 				Column[0][0] Id: 0
1: 				Operator: =
1: 				Ordered nulls: false
1: 				Unknown return value: false
1: 				Negate comparison result: false
1: 			optimizer estimated row count: 0.00
1: 			optimizer estimated cost: 0.00
1: 
1: 
1: 
1: Query plan for index scan - the correct behavior - 
1:     notice t0.Table3_ID is assigned 5189285
1: 
1: Statement Text: 
1: 	SELECT * FROM Table1 T1,Table2 t0 WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = 5189285
1: Number of opens = 1
1: Rows seen = 1
1: Rows filtered = 0
1: restriction = false
1: projection = true
1: 	constructor time (milliseconds) = 0
1: 	open time (milliseconds) = 0
1: 	next time (milliseconds) = 0
1: 	close time (milliseconds) = 0
1: 	restriction time (milliseconds) = 0
1: 	projection time (milliseconds) = 0
1: 	optimizer estimated row count: 1.00
1: 	optimizer estimated cost: 12.72
1: Source result set:
1: 	Scalar Aggregate ResultSet:
1: 	Number of opens = 1
1: 	Rows input = 1
1: 		constructor time (milliseconds) = 0
1: 		open time (milliseconds) = 0
1: 		next time (milliseconds) = 0
1: 		close time (milliseconds) = 0
1: 		optimizer estimated row count: 1.00
1: 		optimizer estimated cost: 12.72
1: 	Index Key Optimization = false
1: 	Source result set:
1: 		Project-Restrict ResultSet (6):
1: 		Number of opens = 1
1: 		Rows seen = 1
1: 		Rows filtered = 0
1: 		restriction = false
1: 		projection = true
1: 			constructor time (milliseconds) = 0
1: 			open time (milliseconds) = 0
1: 			next time (milliseconds) = 0
1: 			close time (milliseconds) = 0
1: 			restriction time (milliseconds) = 0
1: 			projection time (milliseconds) = 0
1: 			optimizer estimated row count: 1.00
1: 			optimizer estimated cost: 12.72
1: 		Source result set:
1: 			Nested Loop Exists Join ResultSet:
1: 			Number of opens = 1
1: 			Rows seen from the left = 1
1: 			Rows seen from the right = 1
1: 			Rows filtered = 0
1: 			Rows returned = 1
1: 				constructor time (milliseconds) = 0
1: 				open time (milliseconds) = 0
1: 				next time (milliseconds) = 0
1: 				close time (milliseconds) = 0
1: 				optimizer estimated row count: 1.00
1: 				optimizer estimated cost: 12.72
1: 			Left result set:
1: 				Index Row to Base Row ResultSet for TABLE2:
1: 				Number of opens = 1
1: 				Rows seen = 1
1: 				Columns accessed from heap = {0, 1}
1: 					constructor time (milliseconds) = 0
1: 					open time (milliseconds) = 0
1: 					next time (milliseconds) = 0
1: 					close time (milliseconds) = 0
1: 					optimizer estimated row count: 1.00
1: 					optimizer estimated cost: 8.01
1: 					Index Scan ResultSet for TABLE2 using constraint TABLE2_FK_2 at read committed isolation level using instantaneous share row locking chosen by the optimizer
1: 					Number of opens = 1
1: 					Rows seen = 1
1: 					Rows filtered = 0
1: 					Fetch Size = 16
1: 						constructor time (milliseconds) = 0
1: 						open time (milliseconds) = 0
1: 						next time (milliseconds) = 0
1: 						close time (milliseconds) = 0
1: 						next time in milliseconds/row = 0
1: 
1: 					scan information:
1: 						Bit set of columns fetched=All
1: 						Number of columns fetched=2
1: 						Number of deleted rows visited=0
1: 						Number of pages visited=4
1: 						Number of rows qualified=1
1: 						Number of rows visited=2
1: 						Scan type=btree
1: 						Tree height=-1
1: 						start position:
0: 							>= on first 1 column(s).
1: 							Ordered null semantics on the following columns: 
1: 							0 
1: 						stop position:
0: 							> on first 1 column(s).
1: 							Ordered null semantics on the following columns: 
1: 							0 
1: 						qualifiers:
1: 							None
1: 						optimizer estimated row count: 1.00
1: 						optimizer estimated cost: 8.01
1: 
1: 			Right result set:
1: 				Index Scan ResultSet for TABLE1 using constraint SQL130904105604940 at read committed isolation level using share row locking chosen by the optimizer
1: 				Number of opens = 1
1: 				Rows seen = 1
1: 				Rows filtered = 0
1: 				Fetch Size = 1
1: 					constructor time (milliseconds) = 0
1: 					open time (milliseconds) = 0
1: 					next time (milliseconds) = 0
1: 					close time (milliseconds) = 0
1: 					next time in milliseconds/row = 0
1: 
1: 				scan information:
1: 					Bit set of columns fetched={0}
1: 					Number of columns fetched=1
1: 					Number of deleted rows visited=0
1: 					Number of pages visited=3
1: 					Number of rows qualified=1
1: 					Number of rows visited=1
1: 					Scan type=btree
1: 					Tree height=3
1: 					start position:
0: 						>= on first 1 column(s).
1: 						Ordered null semantics on the following columns: 
1: 						0 
1: 					stop position:
0: 						> on first 1 column(s).
1: 						Ordered null semantics on the following columns: 
1: 						0 
1: 					qualifiers:
1: 						None
1: 					optimizer estimated row count: 1.00
1: 					optimizer estimated cost: 4.71
1: 
1: 
1: 
1: **/
1: 
1: public class Derby6317Test extends BaseJDBCTestCase
1: {
1:     final static int DATABASE_SCALE = 1000000;
1:     final static int TABLE_ONE_ROW_COUNT = DATABASE_SCALE;
1:     final static int TABLE_THREE_ROW_COUNT = DATABASE_SCALE*8;
1:     final static int SELECT_ROWS_COUNT = DATABASE_SCALE*8;
1: 
1:     final String testSelect=
1:         "SELECT * FROM "+
1:         "Table1 T1,"+
1:         "Table2 t0 "+
1:         "WHERE t1.ID = t0.Table1_ID and "+
1:         "t0.Table3_ID = "; 
1: 
1:     public Derby6317Test(String name) 
1:     {
1:         super(name);
1:     }
1: 
1:     public static Test suite() 
1:     {
0:         TestSuite suite = new TestSuite("Derby6317Test");
1:         suite.addTest(baseSuite("Derby6317Test:embedded"));
1:         return suite;
1:     }
1:     
1:     //Confirm that both the tables involved in the SELECT statement are using
1:     // index scan. Prior to fix for DERBY-6317, some SOME_CONSTANT values
1:     // would do table scan on TABLE1 rather than an index scan.
1:     // SELECT * FROM Table1 T1, Table2 t0 
1:     //  WHERE t1.ID = t0.Table1_ID and t0.Table3_ID = SOME_CONSTANT
1:     private void confirmIndexScanUsage(Statement stmt, int some_constant)
1:         throws SQLException {
1:         RuntimeStatisticsParser rtsp;
1:         boolean constraintUsed;
1:         rtsp = SQLUtilities.getRuntimeStatisticsParser(stmt);
1:         constraintUsed = rtsp.usedConstraintForIndexScan("TABLE1");
1:         if (!constraintUsed){
1:             assertTrue("Should have done index scan but did table scan on " + 
1:                 "TABLE1 for t0.Table3_ID = "+some_constant, constraintUsed);
1:         }
1:         constraintUsed = rtsp.usedConstraintForIndexScan("TABLE2");
1:         if (!constraintUsed){
1:             assertTrue("Should have done index scan but did table scan on " +
1:                 "TABLE2 for t0.Table3_ID = "+some_constant, constraintUsed);
1:         }    	
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //5189284 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:     public void testDERBY_6317_value1()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 5189284);
1:         confirmIndexScanUsage(stmt, 5189284);
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //6035610 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:     public void testDERBY_6317_value2()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 6035610);
1:         confirmIndexScanUsage(stmt, 6035610);
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //6031628 value incorrectly picked TABLE scan prior to DERBY-6317 fix
1:     public void testDERBY_6317_value3()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 6031628);
1:         confirmIndexScanUsage(stmt, 6031628);
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //5189284 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:     public void testDERBY_6317_value4()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 5189285);
1:         confirmIndexScanUsage(stmt, 5189285);
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //6035609 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:     public void testDERBY_6317_value6()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 6035609);
1:         confirmIndexScanUsage(stmt, 6035609);
1:     }
1:     
1:     //Test just one specific value in the SELECT and see what kind of plan
1:     // is picked up for it.
1:     //1 value always picked INDEX scan ie even prior to DERBY-6317 fix
1:     public void testDERBY_6317_value5()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         stmt.execute(testSelect + 1);
1:         confirmIndexScanUsage(stmt, 1);
1:     }
1: 
1:     //This test is really really time consuming because it is going through
1:     // 8million selects individually. Before DERBY-6317, it would take 
1:     // about 4-5hrs to finish and stop right after the first failure which
1:     // was on 5,189,284. The leftover selects out of 8million did not get
1:     // run because of the failure. But once DERBY-6317 is fixed, the test
1:     // takes even longer because it will go through 8 million rows rather
1:     // than stop after about 5million rows. The time it takes for the 
1:     // test to finish after DERBY-6317 is about 10hrs
1:     //
1:     // TODO - test name does not start with "test" so not run by default
1:     // in the largedata suite, due to time it takes to run.  May make sense
1:     // to run this test once a release.  The other fixtures currently
1:     // test the problem area, but even a subtle change to the layout of
1:     // records in the btree could make the particular values chosen not
1:     // repro the previous bug.
1:     public void dontrun_testDERBY_6317()
1:         throws SQLException {
1:         Statement stmt = createStatement();
1:         stmt.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         for (int i = 0; i < SELECT_ROWS_COUNT; i++) { 
1:             stmt.execute(testSelect+i);
1:             confirmIndexScanUsage(stmt,i);
1:         }
1:     }
1: 
1:     protected static Test baseSuite(String name) 
1:     {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(Derby6317Test.class);
1:         return new CleanDatabaseTestSetup(suite)
1:         {
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
1:                 Connection conn = stmt.getConnection();
1: 
1:                 stmt.executeUpdate("CREATE TABLE Table1 ("+
1:                 		"ID int PRIMARY KEY NOT NULL)");
1: 
1:                 stmt.executeUpdate("CREATE TABLE Table2 ("+
1:                 		"Table1_ID int NOT NULL,"+
1:                 		"Table3_ID int NOT NULL,"+
1:                 		"CONSTRAINT TABLE2_PK PRIMARY KEY "+
1:                 		"(Table1_ID,Table3_ID))");
1:                 
1:                 stmt.executeUpdate("CREATE TABLE Table3 ("+
1:                 		"ID int PRIMARY KEY NOT NULL)"); 
1: 
1:                 stmt.executeUpdate("ALTER TABLE table2 "+
1:                         "ADD CONSTRAINT TABLE2_FK_1 "+
1:                         "FOREIGN KEY (Table1_ID) "+
1:                         "REFERENCES TABLE1(ID)");
1:                 stmt.executeUpdate("ALTER TABLE table2 "+
1:                         "ADD CONSTRAINT TABLE2_FK_2 "+
1:                         "FOREIGN KEY (Table3_ID) "+
1:                         "REFERENCES TABLE3(ID)");
1: 
1:                 conn.setAutoCommit(false);
1:                 
1:                 PreparedStatement insertPS = getConnection().prepareStatement(
1:             		  "INSERT INTO table1 VALUES (?)");
1:                 for (int i = 0; i < TABLE_ONE_ROW_COUNT; i++) { 
1:                     insertPS.setInt(1,i);
1:                     insertPS.execute();
1:                     if (i%10000 == 0)
1:       	    		    conn.commit();
1:                 } 
1:                 conn.commit();
1:                 int count = TABLE_THREE_ROW_COUNT; 
1:                 insertPS = conn.prepareStatement("INSERT INTO table3 VALUES (?)");
1:                 for (int i = 0; i < count; i++) { 
1:                     insertPS.setInt(1,i);
1:                     insertPS.execute();
1:           	        if (i%10000 == 0)
1:           	            conn.commit();
1:                 } 
1:                 conn.commit();
1:                 //In TABLE2, we will insert 8 million rows.
1:                 insertPS = conn.prepareStatement("INSERT INTO table2 VALUES (?,?)");
1:                 for (int i = 0, j=0; i < TABLE_ONE_ROW_COUNT; i++) { 
1:                 	insertPS.setInt(1,i);
1:        	            for (int k=0; k<8; k++,j++) {
1:                         insertPS.setInt(2,j);
1:           	            insertPS.execute();
1:                     }
1:               	    if (i%10000 == 0)
1:               	        conn.commit();
1:                 }
1:                 conn.commit();
1:             }
1:         };
1:     }
1: }
============================================================================