1:c774a1c: /*
1:c774a1c: 
1:c774a1c:    Derby - Class 
1:c774a1c:       org.apache.derbyTesting.functionTests.tests.derbynet.NSSecurityMechanismTest
1:c774a1c: 
1:c774a1c:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c774a1c:    contributor license agreements.  See the NOTICE file distributed with
1:c774a1c:    this work for additional information regarding copyright ownership.
1:c774a1c:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c774a1c:    (the "License"); you may not use this file except in compliance with
1:c774a1c:    the License.  You may obtain a copy of the License at
1:c774a1c: 
1:c774a1c:       http://www.apache.org/licenses/LICENSE-2.0
1:c774a1c: 
1:c774a1c:    Unless required by applicable law or agreed to in writing, software
1:c774a1c:    distributed under the License is distributed on an "AS IS" BASIS,
1:c774a1c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c774a1c:    See the License for the specific language governing permissions and
1:c774a1c:    limitations under the License.
1:c774a1c: 
1:c774a1c:  */
1:c774a1c: 
1:c774a1c: package org.apache.derbyTesting.functionTests.tests.derbynet;
1:c774a1c: 
1:dac3aab: import java.io.PrintWriter;
1:dac3aab: import java.io.StringWriter;
1:c774a1c: import java.sql.CallableStatement;
1:c774a1c: import java.sql.Connection;
1:c774a1c: import java.sql.DriverManager;
1:c774a1c: import java.sql.ResultSet;
1:c774a1c: import java.sql.SQLException;
1:c774a1c: import java.sql.Statement;
1:c774a1c: import java.util.HashMap;
1:c774a1c: import javax.sql.ConnectionPoolDataSource;
1:c774a1c: import javax.sql.DataSource;
1:c774a1c: import javax.sql.PooledConnection;
1:c774a1c: import junit.framework.Test;
1:c774a1c: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:cb29d72: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:c774a1c: import org.apache.derbyTesting.junit.J2EEDataSource;
1:c774a1c: import org.apache.derbyTesting.junit.JDBCDataSource;
1:1146ea1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:c774a1c: import org.apache.derbyTesting.junit.TestConfiguration;
1:c774a1c: 
1:c774a1c: /**
1:c774a1c:  * This class tests the security mechanisms supported by Network Server
1:c774a1c:  * Network server supports SECMEC_EUSRIDPWD, SECMEC_USRIDPWD, SECMEC_USRIDONL
1:c774a1c:  * and SECMEC_USRSSBPWD.
4:c774a1c:  * 
1:c774a1c:  * -----------------------------------------------------------------
1:c774a1c:  * Security Mechanism | secmec           | User friendly name   
1:c774a1c:  *                    |  codepoint value |
1:c774a1c:  * -----------------------------------------------------------------
1:c774a1c:  * USRIDONL           | 0x04             | USER_ONLY_SECURITY
1:c774a1c:  * USRIDPWD           | 0x03             | CLEAR_TEXT_PASSWORD_SECURITY
1:c774a1c:  * EUSRIDPWD          | 0x09             | ENCRYPTED_USER_AND_PASSWORD_SECURITY
1:c774a1c:  * USRSSBPWD          | 0x08             | STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:c774a1c:  * -----------------------------------------------------------------
1:c774a1c:  * 
1:c774a1c:  * Key points: 
1:c774a1c:  * #1) Server and client support encrypted userid/password (EUSRIDPWD) via the
1:c774a1c:  * use of Diffie Helman key-agreement protocol - but current Open Group DRDA
1:c774a1c:  * specifications imposes small prime and base generator values (256 bits) that
1:c774a1c:  * prevents other JCE's to be used as java cryptography providers - typical
1:c774a1c:  * minimum security requirements is usually of 1024 bits (512-bit absolute
1:c774a1c:  * minimum) when using DH key-agreement protocol to generate a session key.
1:c774a1c:  * 
1:c774a1c:  * (Reference: DDM manual, page 281 and 282. Section: Generating the shared
1:c774a1c:  * private key. DRDA's diffie helman agreed public values for prime are 256
1:c774a1c:  * bits. The spec gives the public values for the prime, generator and the size
1:c774a1c:  * of exponent required for DH . These values must be used as is to generate a
1:c774a1c:  * shared private key.)
1:c774a1c:  * 
1:c774a1c:  * Encryption is done using JCE. Hence JCE support of the necessary algorithm
1:c774a1c:  * is required for a particular security mechanism to work. Thus even though 
1:c774a1c:  * the server and client have code to support EUSRIDPWD, this security 
1:c774a1c:  * mechanism will not work in all JVMs.
1:c774a1c:  * 
1:c774a1c:  * JVMs where support for DH(32byte prime) is not available and thus EUSRIDPWD
1:c774a1c:  * won't work are Sun JVM (versions 1.3.1,1.4.1,1.4.2,1.5) and IBM JVM (
1:c774a1c:  * versions 1.3.1 and some old versions of 1.4.2 (in 2004))
1:c774a1c:  * 
1:c774a1c:  * JVMs where support for DH(32bytes prime) is available and thus EUSRIDPWD 
1:c774a1c:  * will work are IBM JVM [versions 1.4.1, later versions of 1.4.2 (from 2005),
1:c774a1c:  * 1.5]
1:c774a1c:  * 
1:7dc89cf:  * #2) Note, if  server restricts the client connections based on security 
1:c774a1c:  * mechanism by setting derby.drda.securityMechanism, in that case the clients 
1:c774a1c:  * will see an error similar to this:
1:c774a1c:  * "Connection authorization failure occurred. Reason: security mechanism not
1:c774a1c:  *  supported"
1:c774a1c:  *
1:7dc89cf:  * #3) USRSSBPWD - Strong password substitute is only supported starting from
1:c774a1c:  *     Apache Derby 10.2.
1:c774a1c:  *	 NOTE: USRSSBPWD only works with the derby network client driver for now.
1:c774a1c:  *   ---- 
1:c774a1c:  */
1:c774a1c: public class NSSecurityMechanismTest extends BaseJDBCTestCase
14:c774a1c: {
1:c774a1c:     // values for derby.drda.securityMechanism property
1:c774a1c:     private static String[] derby_drda_securityMechanisms = {
1:c774a1c:         null, // not set 
1:c774a1c:         "USER_ONLY_SECURITY", "CLEAR_TEXT_PASSWORD_SECURITY",
1:c774a1c:         // this will give a DRDA_InvalidValue with jvms that do not support it
1:c774a1c:         "ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:c774a1c:         "STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:c774a1c:         //these two are always invalid values, again, will give DRDA_InvalidValue
1:c774a1c:         "INVALID_VALUE", ""};
1:c774a1c:     
1:c774a1c:     private static String derby_drda_securityMechanism;
1:c774a1c: 
1:c774a1c:     // possible interesting combinations with respect to security mechanism
1:c774a1c:     // upgrade logic for user attribute
1:c774a1c:     private static String[] USER_ATTRIBUTE = {"calvin",null};
1:c774a1c: 
1:c774a1c:     // possible interesting combinations with respect to security mechanism
1:c774a1c:     // upgrade logic for password attribute
1:c774a1c:     private static String[] PWD_ATTRIBUTE = {"hobbes",null};
1:c774a1c: 
1:c774a1c:     public NSSecurityMechanismTest(String name)
1:c774a1c:     {
1:c774a1c:         super(name);
1:1b46090:     }
1:c774a1c:     
1:c774a1c:     public static Test suite() 
1:c774a1c:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("NSSecurityMechanismTest");
1:c774a1c: 
1:1ae02c9:         BaseTestSuite clientSuite =
1:1ae02c9:             new BaseTestSuite("NSSecurityMechanismTest - client");
1:cb29d72:         clientSuite.addTest(new NSSecurityMechanismTest(
1:c774a1c:             "testNetworkServerSecurityMechanism"));
1:cb29d72:         suite.addTest(TestConfiguration.clientServerDecorator(clientSuite));
1:1b46090: 
1:cb29d72:         // Test case for embedded mode. Enable builtin authentication.
1:cb29d72:         suite.addTest(
1:cb29d72:             DatabasePropertyTestSetup.builtinAuthentication(
1:cb29d72:                 new NSSecurityMechanismTest("testSecurityMechanismOnEmbedded"),
1:cb29d72:                 new String[] { "calvin" }, "pw"));
1:cb29d72:         return suite;
1:1b46090:     }
1:c774a1c:     
1:fa6fca2:     protected void tearDown() throws Exception {
1:fa6fca2:         removeSystemProperty("derby.drda.securityMechanism");
1:c774a1c: 
1:1b46090:         super.tearDown();
1:1b46090:     }
1:c774a1c: 
1:c774a1c:     // Indicates userid/encrypted password security mechanism.
1:c774a1c:     static final short SECMEC_EUSRIDPWD = 0x09;
1:c774a1c: 
1:c774a1c:     // Indicates userid only security mechanism.
1:c774a1c:     static final short SECMEC_USRIDONL = 0x04;
1:c774a1c: 
1:c774a1c:     // Indicates userid/encrypted password security mechanism.
1:c774a1c:     static final short SECMEC_USRENCPWD = 0x07;
1:c774a1c: 
1:c774a1c:     // Indicates userid/new password security mechanism.
1:c774a1c:     static final short SECMEC_USRIDNWPWD = 0x05;
1:c774a1c: 
1:c774a1c:     // Indicates userid/password security mechanism.
1:c774a1c:     static final short SECMEC_USRIDPWD = 0x03;
1:c774a1c: 
1:c774a1c:     // Indicates strong password substitute security mechanism.
1:c774a1c:     static final short SECMEC_USRSSBPWD = 0x08;
1:c774a1c: 
1:c774a1c:     // client and server recognize these secmec values
1:c774a1c:     private static short[] SECMEC_ATTRIBUTE = {
1:c774a1c:         SECMEC_USRIDONL,
1:c774a1c:         SECMEC_USRIDPWD,
1:c774a1c:         SECMEC_EUSRIDPWD,
1:c774a1c:         SECMEC_USRSSBPWD
1:c774a1c:     };
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      *  Test cases for security mechanism
1:c774a1c:      *  ---------------------------------------------------------------
1:c774a1c:      *  DriverManager:
1:c774a1c:      *  T1 - default , no user      PASS (for derbyclient)
1:c774a1c:      *  T2 - user only              PASS (for derbyclient)
1:c774a1c:      *  T3 - user,password          PASS (only for derbynet)
1:c774a1c:      *  T4 - user,password, security mechanism not set  FAIL
1:c774a1c:      *  T5 - user,password, security mechanism set
1:c774a1c:      *       to SECMEC_EUSRIDPWD  PASS/FAIL
1:c774a1c:      *       (Fails with Sun JVM as EUSRIDPWD secmec cannot be used)
1:c774a1c:      *  T6 - user, security mechanism set to SECMEC_USRIDONL   PASS
1:c774a1c:      *  T7 - user,password, security mechanism set to SECMEC_USRENCPWD  FAIL
1:c774a1c:      *  Test with datasource as well as DriverManager
1:c774a1c:      *  T8 - user,password security mechanism set to SECMEC_USRIDONL   PASS
1:c774a1c:      *  T9 - user,password security mechanism set to SECMEC_USRSSBPWD  PASS
1:c774a1c:      *  Test with datasource as well as DriverManager
1:c774a1c:      * Note, that with DERBY-928, the pass/fail for the connections will depend 
1:c774a1c:      * on the security mechanism specified at the server by property 
1:c774a1c:      * derby.drda.securityMechanism.  Please check out the following
1:c774a1c:      * html file http://issues.apache.org/jira/secure/attachment/12322971/Derby928_Table_SecurityMechanisms..htm
1:c774a1c:      * for a combination of url/security mechanisms and the expected results 
1:c774a1c:      */
1:c774a1c:     public void testNetworkServerSecurityMechanism() throws SQLException, Exception
1:c774a1c:     {
1:c774a1c:         String[][] allDriverManagerExpectedValues = {
1:c774a1c:             {"null",
1:c774a1c:                 "OK","OK","OK","OK","OK","OK","?","OK","OK"},
1:c774a1c:             {"USER_ONLY_SECURITY",
1:c774a1c:                 "OK","OK","08004","08004","08004","OK","?","OK","08004"},
1:c774a1c:             {"CLEAR_TEXT_PASSWORD_SECURITY",
1:c774a1c:                 "08004","08004","OK","OK","08004","08004",
1:c774a1c:                 "?","08004","08004"},
1:c774a1c:             // this should give a DRDA_InvalidValue with jvms that do not
1:c774a1c:             // support it. For instance, it will fail with jdk14 jvms.
1:c774a1c:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:c774a1c:                 "08004","08004","08004","08004","OK","08004",
1:c774a1c:                 "?","08004","08004"},
1:c774a1c:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:c774a1c:                     "08004","08004","08004","08004","08004","08004",
1:c774a1c:                     "?","08004","OK"},
1:c774a1c:             };
1:c774a1c:         
1:c774a1c:         String[][] allDataSourceExpectedValues = {
1:c774a1c:             {null,"OK","OK","OK","OK"},
1:c774a1c:             {"USER_ONLY_SECURITY","OK","08004","08004","08004"},
1:c774a1c:             {"CLEAR_TEXT_PASSWORD_SECURITY","08004","OK","08004","08004"},
1:c774a1c:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:c774a1c:                 "08004","08004","OK","08004"},
1:c774a1c:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:c774a1c:                 "08004","08004","08004","OK"}};
1:c774a1c:         
1:c774a1c:         String[] DERBY1080ExpectedValues = {"OK","08004","08004","OK","08004"};
1:c774a1c:         
1:c774a1c:         String[][] allUserPwdSecMecExpectedValues = {
1:c774a1c:             // if secmec is null, all expected to pass.
1:c774a1c:             {null},
1:c774a1c:             {"USER_ONLY_SECURITY",
1:c774a1c:                 "08004","OK","08004","08004","08004", 
1:c774a1c:                 "OK","OK","08001.C.8","08001.C.8","08001.C.8",
1:c774a1c:                 "08004","OK","08004","08004","08004",
1:c774a1c:                 "OK","OK","08001.C.8","08001.C.8","08001.C.8"
1:c774a1c:             },
1:c774a1c:             {"CLEAR_TEXT_PASSWORD_SECURITY",
1:c774a1c:                 "OK","08004","OK","08004","08004", 
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:c774a1c:                 "OK","08004","OK","08004","08004",
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
1:c774a1c:             },
1:c774a1c:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:c774a1c:                 "08004","08004","08004","OK","08004", 
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:c774a1c:                 "08004","08004","08004","OK","08004",
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
1:c774a1c:             },
1:c774a1c:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:c774a1c:                 "08004","08004","08004","08004","OK", 
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:c774a1c:                 "08004","08004","08004","08004","OK",
1:c774a1c:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
8:c774a1c:             }
1:c774a1c:         };
1:c774a1c:         
1:c774a1c:         String[] testDERBY528ExpectedValues = {
1:c774a1c:             null,"08006","OK","08004","08006"
1:c774a1c:         };
1:c774a1c:         
1:c774a1c:         // just to see if this will work
1:c774a1c:         getConnection().getAutoCommit();
1:c774a1c:         
1:c774a1c:         for ( int i = 0; i < derby_drda_securityMechanisms.length; i++)
1:c774a1c:         {   
1:c774a1c:             derby_drda_securityMechanism = derby_drda_securityMechanisms[i];
1:c774a1c: 
1:c774a1c:             // Using 'null' will give a nullpointer exception...
1:c774a1c:             // as it's the first in the array, it should use default setting
1:c774a1c:             if (derby_drda_securityMechanism != null)
1:c774a1c:             {
1:7379752:                 if (derby_drda_securityMechanism.equals(
1:7379752:                         "STRONG_PASSWORD_SUBSTITUTE_SECURITY") &&
1:7379752:                         !hasSufficientEntropy()) {
1:7379752:                     println("skipping USRSSBPWD secmec due to " +
1:7379752:                             "assumed lack of entropy");
1:7379752:                     continue;
1:c774a1c:                 }
1:c774a1c:                 // with "" or "INVALID_VALUE", or with other mechanisms with
1:c774a1c:                 // certain jvms, some settings are not supported. Flag the loop
1:c774a1c:                 // to not try connections
1:c774a1c:                 if (setSecurityMechanism(derby_drda_securityMechanism))
1:c774a1c:                     continue;
1:c774a1c:             }
1:c774a1c:             // Test cases with get connection via drivermanager and via
1:c774a1c:             // datasource, using different security mechanisms.
1:c774a1c:             // Network server supports SECMEC_USRIDPWD, SECMEC_USRIDONL,
1:c774a1c:             // SECMEC_EUSRIDPWD and USRSSBPWD (derby network client only)
1:c774a1c: 
1:c774a1c:             assertConnectionsUsingDriverManager(
1:c774a1c:                 allDriverManagerExpectedValues[i]);
1:c774a1c:             
1:c774a1c:             assertConnectionUsingDataSource(allDataSourceExpectedValues[i]);
1:c774a1c: 
1:c774a1c:             // regression test for DERBY-1080
1:c774a1c:             assertDerby1080Fixed(DERBY1080ExpectedValues[i]);
1:c774a1c: 
1:c774a1c:             // test for DERBY-962
1:c774a1c:             // test all combinations of user/password with security mechanism
1:c774a1c:             assertAllCombinationsOfUserPasswordSecMecInputOK(
1:c774a1c:                 allUserPwdSecMecExpectedValues[i]);
1:c774a1c: 
1:c774a1c:             // test USRSSBPWD (DERBY-528) with Derby BUILTIN authentication 
1:c774a1c:             // scheme both with none and USRSSBPWD specified DRDA SecMec upon
1:c774a1c:             // starting the network server.
1:c774a1c:             if ((derby_drda_securityMechanism == null) ||
1:c774a1c:                 (derby_drda_securityMechanism.equals(
1:c774a1c:                 "STRONG_PASSWORD_SUBSTITUTE_SECURITY")))
1:c774a1c:             {
1:c774a1c:                 assertUSRSSBPWD_with_BUILTIN(testDERBY528ExpectedValues);
1:c774a1c:             }
1:1146ea1:             else
1:1146ea1:             {
1:1146ea1:                 // shutdown the database - this will prevent slow startup 
1:1146ea1:                 // when bouncing the server with next security mechanism.
1:1146ea1:                 // for ENCRYPTED_USER_AND_PASSWORD_SECURITY:
1:1146ea1:                 short secmeccode=SECMEC_EUSRIDPWD;
1:1146ea1:                 if (derby_drda_securityMechanism.equals("USER_ONLY_SECURITY"))
1:1146ea1:                     secmeccode=SECMEC_USRIDONL;
1:1146ea1:                 else if (derby_drda_securityMechanism.equals(
1:1146ea1:                     "CLEAR_TEXT_PASSWORD_SECURITY"))
1:1146ea1:                     secmeccode=SECMEC_USRIDPWD;
1:1146ea1:                 assertConnectionUsingDriverManager(getJDBCUrl(
1:1146ea1:                     "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:1146ea1:                     secmeccode)," BUILTIN (T5):",
1:1146ea1:                     "08006");
1:1146ea1:             }
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:cb29d72:     /**
1:cb29d72:      * Test that securityMechanism=8 is ignored by the embedded driver
1:cb29d72:      * (DERBY-3025).
1:cb29d72:      */
1:cb29d72:     public void testSecurityMechanismOnEmbedded() throws SQLException {
1:cb29d72:         DataSource ds = JDBCDataSource.getDataSource();
1:cb29d72:         JDBCDataSource.setBeanProperty(
1:cb29d72:             ds, "connectionAttributes", "securityMechanism=8");
1:c774a1c: 
1:cb29d72:         // DERBY-3025: NullPointerException or AssertFailure was thrown here
1:cb29d72:         Connection c = ds.getConnection("calvin", "calvinpw");
1:c774a1c: 
1:cb29d72:         c.close();
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     // returns a boolean true if the security mechanism is not supported
1:c774a1c:     // so the loop in which this is called can be continued without
1:c774a1c:     // causing unnecessary/impossible tests to be run
1:1146ea1:     private boolean setSecurityMechanism(String derby_security_mechanism) 
1:c774a1c:     throws Exception {
1:1b46090:         try {
1:c1192c0:             // shut down the currently running
1:c774a1c:             // server, before setting the next security mechanism
1:c1192c0:             NetworkServerTestSetup.getNetworkServerControl().shutdown();
1:1b46090:         } catch (Exception e) {
1:c774a1c:             if (!(e.getMessage().substring(0,17).equals("DRDA_InvalidValue")))
1:c774a1c:             {
1:c774a1c:                 fail("unexpected error");
1:c774a1c:             }
1:c774a1c:         }
1:c774a1c: 
1:6524638:         // Before attempting to start a new server, wait for the previous
1:6524638:         // server to complete and release the server port.
1:6524638:         NetworkServerTestSetup.waitForAvailablePort();
1:c774a1c: 
1:fa6fca2:         setSystemProperty("derby.drda.securityMechanism",
1:c774a1c:                 derby_drda_securityMechanism);
4:c774a1c:         try {
1:c774a1c:             
1:c774a1c:             // if the security mechanism isn't supported or invalid, getting a
1:c774a1c:             // networkservercontrol will fail.
1:c774a1c: 
1:c1192c0:             // For debugging, to make output come to console call start() with
1:c1192c0:             // new PrintWriter(System.out, true) instead of null.
1:c1192c0:             NetworkServerTestSetup.getNetworkServerControl().start(null);
1:c1192c0:             NetworkServerTestSetup.waitForServerStart(
1:c1192c0:                     NetworkServerTestSetup.getNetworkServerControl());
1:c774a1c:             
1:c774a1c:             if (derby_drda_securityMechanism.equals("") ||
1:c774a1c:                 derby_drda_securityMechanism.equals("INVALID_VALUE"))
1:c774a1c:             {
1:c774a1c:                 fail(
1:c774a1c:                     "expected server not to start with invalid or empty " +
1:c774a1c:                      "security mechanism, but passed");
1:c774a1c:             }
2:c774a1c:         } catch (Exception e) {
1:c774a1c:             // "" or "INVALID_VALUE" should always give DRDA_Invalid_Value, 
1:c774a1c:             // hence the 'fail' above.
1:c774a1c:             // However, other mechanisms may not be supported with certain
1:c774a1c:             // jvms, and then also will get the same exception. This is true
1:c774a1c:             // for ENCRYPTED_USER_AND_PASSWORD_SECURITY.
1:c774a1c:             // If we're not getting DRDA_Invalid_Value here, something's gone
1:c774a1c:             // wrong.
1:c774a1c:             if (derby_drda_securityMechanism.equals("") ||
1:c774a1c:                 derby_drda_securityMechanism.equals("INVALID_VALUE") ||
1:c774a1c:                 derby_drda_securityMechanism.equals(
1:c774a1c:                     "ENCRYPTED_USER_AND_PASSWORD_SECURITY"))
1:c774a1c:             {
1:c774a1c:                 // should give invalid value 
1:c774a1c:                 assertEquals("DRDA_InvalidValue",e.getMessage().substring(0,17));
1:c774a1c:                 return true;
1:c774a1c:             }
1:c774a1c:             fail ("got unexpected exception setting the mechanism " + 
1:c774a1c:                 derby_security_mechanism + "; message: " + e.getMessage());
1:c774a1c:         }
1:c774a1c:         return false;
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private void assertConnectionsUsingDriverManager(String[] expectedValues)
1:c774a1c:     {
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl(null),"T1:", expectedValues[1]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=max"),"T2:", expectedValues[2]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;password=lee"),"T3:", expectedValues[3]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:c774a1c:             SECMEC_USRIDPWD),"T4:", expectedValues[4]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:c774a1c:             SECMEC_EUSRIDPWD),"T5:", expectedValues[5]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;securityMechanism=" +
1:c774a1c:             SECMEC_USRIDONL),"T6:", expectedValues[6]);
1:c774a1c: 
1:c774a1c:         // disable as ibm142 and sun jce doesnt support DH prime of 32 bytes
1:c774a1c:         //assertConnectionUsingDriverManager(
1:c774a1c:         //    getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:c774a1c:         //    SECMEC_USRENCPWD),"T7:", expectedValues[7]);
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:c774a1c:             SECMEC_USRIDONL),"T8:", expectedValues[8]);
1:c774a1c:         // Test strong password substitute DRDA security mechanism 
1:c774a1c:         // (only works with DerbyClient driver right now)
1:c774a1c:         assertConnectionUsingDriverManager(
1:c774a1c:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:c774a1c:             SECMEC_USRSSBPWD),"T9:", expectedValues[9]);
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     
1:c774a1c:     /**
1:c774a1c:      * Get connection from datasource and also set security mechanism
1:c774a1c:      */
1:1146ea1:     private void assertConnectionUsingDataSource(String[] expectedValues)
1:c774a1c:     {
1:c774a1c:         if (usingDerbyNetClient())
1:c774a1c:         {
1:39b3237:             assertSecurityMechanismOK("sarah",null, SECMEC_USRIDONL,"SECMEC_USRIDONL:", expectedValues[1]);
1:c774a1c:         }
1:39b3237:         assertSecurityMechanismOK("john","sarah", SECMEC_USRIDPWD,"SECMEC_USRIDPWD:", expectedValues[2]);
1:c774a1c: 
1:c774a1c:         if (usingDerbyNetClient())
1:c774a1c:         {
1:c774a1c:             // Please note: EUSRIDPWD security mechanism in DRDA uses 
1:c774a1c:             // Diffie-Helman for generation of shared keys. The spec specifies
1:c774a1c:             // the prime to use for DH which is 32 bytes and this needs to be
1:c774a1c:             // used as is.
1:c774a1c:             // Sun JCE does not support a prime of 32 bytes for Diffie Helman
1:c774a1c:             // nor do some older versions of IBM JCE (1.4.2).
1:c774a1c:             // Hence the following call to get connection might not be 
1:c774a1c:             // successful when client is running in a JVM where the JCE does
1:c774a1c:             // not support the DH (32 byte prime).
1:c774a1c:             // The test methods are implemented to work either way.
1:39b3237:             assertSecurityMechanismOK("john","sarah",SECMEC_EUSRIDPWD,"SECMEC_EUSRIDPWD:", expectedValues[3]);
1:39b3237:             assertSecurityMechanismOK("john","sarah",SECMEC_USRSSBPWD,"SECMEC_USRSSBPWD:", expectedValues[4]);
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private void assertSecurityMechanismOK(String user, String password,
1:c774a1c:         Short secmec, String msg, String expectedValue)
1:c774a1c:     {
1:7379752:         // Skip this USRSSBPWD on platforms that are short on entropy.
1:7379752:         if (secmec.shortValue() == SECMEC_USRSSBPWD && !hasSufficientEntropy()){
1:7379752:             return;
1:c774a1c:         }
2:c774a1c:         Connection conn;
1:c774a1c: 
1:c774a1c:         DataSource ds = getDS(user,password);
1:c774a1c:         try {
1:72f8fa8:             JDBCDataSource.setBeanProperty(ds,
1:72f8fa8:                     "SecurityMechanism", secmec);
1:c774a1c:             conn = ds.getConnection(user, password);
1:c774a1c:             conn.close();
1:c774a1c:             // EUSRIDPWD is supported with some jvm( version)s, not with others
1:39b3237:             if (!(secmec.equals(SECMEC_EUSRIDPWD)))
1:c774a1c:             {
1:c774a1c:                 if (!expectedValue.equals("OK"))
1:c774a1c:                 {
1:c774a1c:                     fail("should have encountered an Exception");
1:c774a1c:                 }
1:c774a1c:             }
1:c774a1c:         }
2:c774a1c:         catch (SQLException sqle)
1:c774a1c:         {
1:c774a1c:             if (sqle.getSQLState().equals("08001"))
1:c774a1c:             {
1:c774a1c:                 // with null user id there's a difference between errors coming
1:c774a1c:                 // from driver manager vs. datasource, because the datasource
1:c774a1c:                 // getconnection call had to be specify user/password or the 
1:c774a1c:                 // junit framework pads it with 'APP'.
1:c774a1c:                 if (user == null)
1:c774a1c:                     assertSQLState08001("08001.C.7", sqle);
1:c774a1c:                 else
1:c774a1c:                     assertSQLState08001(expectedValue, sqle);
1:c774a1c:             }
2:c774a1c:             // Exceptions expected in certain cases depending on JCE used for 
1:c774a1c:             // running the test. So, instead of '08004' (connection refused),
1:c774a1c:             // or "OK", we may see 'not supported' (XJ112).
1:39b3237:             else if (secmec.equals(SECMEC_EUSRIDPWD)) 
1:c774a1c:             {
1:c774a1c:                 if (!(sqle.getSQLState().equals("XJ112")))
2:c774a1c:                     assertSQLState(expectedValue, sqle);
1:c774a1c:             }
1:c774a1c:             else
1:c774a1c:                 assertSQLState(expectedValue, sqle);
1:c774a1c:             // for debugging, uncomment:
1:c774a1c:             //dumpSQLException(sqle.getNextException());
1:c774a1c:         }
4:c774a1c:         catch (Exception e)
1:c774a1c:         {   
1:c774a1c:             fail(" should not have seen an exception");
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private void assertConnectionUsingDriverManager(
1:c774a1c:         String dbUrl, String msg, String expectedValue)
1:c774a1c:     {
1:7379752:         if (!hasSufficientEntropy() &&
1:7379752:                 dbUrl.indexOf("securityMechanism=8") != -1) {
1:7379752:             return;
1:c774a1c:         }
2:c774a1c:         try
1:c774a1c:         {
1:c774a1c:             TestConfiguration.getCurrent();
1:e76a6fb:             DriverManager.getConnection(dbUrl).close();
1:c774a1c:             // Please note: EUSRIDPWD security mechanism in DRDA uses 
1:c774a1c:             // Diffie-Helman for generation of shared keys. 
1:c774a1c:             // The spec specifies the prime to use for DH which is 32 bytes and
1:c774a1c:             // this needs to be used as is. Sun JCE does not support a prime of
1:c774a1c:             // 32 bytes for Diffie Helman and some older versions of IBM JCE 
1:c774a1c:             // ( 1.4.2) also do not support it. Hence the following call to get 
1:c774a1c:             // connection might not be successful when client is running in JVM
1:c774a1c:             // where the JCE does not support the DH (32 byte prime)
1:c774a1c:             
1:c774a1c:             if (derby_drda_securityMechanism != null && 
1:c774a1c:                 !(derby_drda_securityMechanism.equals(
1:c774a1c:                 "ENCRYPTED_USER_AND_PASSWORD_SECURITY") &&
1:c774a1c:                 ((msg.indexOf("T5")>0) || (dbUrl.indexOf("9")>0))))
1:c774a1c:             {
1:c774a1c:                 if (!expectedValue.equals("OK"))
1:c774a1c:                     fail("should have encountered an Exception");
1:c774a1c:             }
1:c774a1c:         }
1:c774a1c:         catch(SQLException sqle)
1:c774a1c:         {
1:c774a1c:             // if we're trying T5, and we've got EUSRIDPWD, 08004 is also
1:c774a1c:             // possible, or XJ112 instead of OK.
1:c774a1c:             if (derby_drda_securityMechanism != null  &&
1:c774a1c:                 derby_drda_securityMechanism.equals(
1:c774a1c:                 "ENCRYPTED_USER_AND_PASSWORD_SECURITY") &&
1:c774a1c:                 ((msg.indexOf("T5")>0) ))
1:c774a1c:             {
1:c774a1c:                 if (!(sqle.getSQLState().equals("XJ112")))
1:c774a1c:                     assertSQLState(expectedValue, sqle);
1:c774a1c:             }
1:c774a1c:             else if (sqle.getSQLState().equals("08001"))
1:c774a1c:                 assertSQLState08001(expectedValue, sqle);
1:c774a1c:             else if (dbUrl.indexOf("9")>0)
1:c774a1c:             {
1:c774a1c:                 if (!(sqle.getSQLState().equals("XJ112")))
1:c774a1c:                     assertSQLState(expectedValue, sqle);
1:c774a1c:             }
1:dac3aab:             else if (sqle.getSQLState().equals("XJ001"))
1:dac3aab:             {
1:dac3aab:                 // we might have hit DERBY-6702. We know the stack trace
1:dac3aab:                 // of that situation, so skip if we see it, except to repeat
1:dac3aab:                 // the passed in values.
1:dac3aab:                 StringWriter sw = new StringWriter();
1:dac3aab:                 sqle.printStackTrace(new PrintWriter(sw));
1:dac3aab:                 if (!sw.toString().contains(
1:ed3bfc8:                     "java.lang.InternalError: Unexpected CryptoAPI failure"))
1:dac3aab:                     assertSQLState(expectedValue, sqle);
1:dac3aab:                 else
1:dac3aab:                     alarm("hit DERBY-6702; for values:" +
1:dac3aab:                     "\n\t dbURL: " + dbUrl +
1:dac3aab:                     "\n\t msg: " + msg + 
1:dac3aab:                     "\n\t expectedValue: " + expectedValue + "\n");
1:dac3aab:             }
1:c774a1c:             else 
1:c774a1c:             {
1:dac3aab:                 if (expectedValue.length() < 5) {
1:dac3aab:                     StringWriter sw = new StringWriter();
1:dac3aab:                     sqle.printStackTrace(new PrintWriter(sw));
1:dac3aab:                     String emsgtxt = "unexpected failure..." +
1:dac3aab:                         "\n\t dbURL: " + dbUrl +
1:dac3aab:                         "\n\t msg: " + msg + 
1:dac3aab:                         "\n\t expectedValue: " + expectedValue ; 
1:dac3aab:                     fail (emsgtxt, sqle);
1:dac3aab:                 }
1:dac3aab:                 else
1:dac3aab:                     assertSQLState(expectedValue, sqle);
1:c774a1c:             }
1:c774a1c:             //for debugging sqles, uncomment: 
1:c774a1c:             // dumpSQLException(sqle.getNextException());
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Test different interesting combinations of user,password, security 
1:c774a1c:      * mechanism for testing security mechanism upgrade logic. This test
1:c774a1c:      * has been added as part of DERBY-962. Two things have been fixed in
1:c774a1c:      * DERBY-962, affects only client behavior.
1:c774a1c:      *
1:c774a1c:      * 1)Upgrade logic should not override security mechanism if it has been 
1:c774a1c:      * explicitly set in connection request (either via DriverManager or 
1:c774a1c:      * using DataSource)
1:c774a1c:      *
1:c774a1c:      * 2)Upgrade security mechanism to a more secure one , ie preferably 
1:c774a1c:      * to encrypted userid and password if the JVM in which the client is 
1:c774a1c:      * running has support for it.
1:c774a1c:      * 
1:c774a1c:      * Details are:  
1:c774a1c:      * If security mechanism is not specified as part of the connection 
1:c774a1c:      * request, then client will do an automatic switching (upgrade) of 
1:c774a1c:      * security mechanism to use. The logic is as follows :
1:c774a1c:      * if password is available, and if the JVM in which the client is running 
1:c774a1c:      * supports EUSRIDPWD mechanism, in that case also, USRIDPWD security 
1:c774a1c:      * mechanism is used. 
1:c774a1c:      * if password is available, and if the JVM in which the client is running 
1:c774a1c:      * does not support EUSRIDPWD mechanism, in that case the client will then
1:c774a1c:      * default to USRIDPWD.
1:c774a1c:      * Also see DERBY-962 http://issues.apache.org/jira/browse/DERBY-962
1:c774a1c:      * <BR>
1:c774a1c:      * To understand which JVMs support EUSRIDPWD or not, please see class
1:c774a1c:      * level comments (#1)
1:c774a1c:      * <BR>
1:c774a1c:      * The expected output from this test will depend on the following
1:7dc89cf:      * -- the client behavior. For the derby client, the table below 
1:7dc89cf:      * represents what security mechanism the client will send to server. 
1:c774a1c:      * -- Note: in case of derby client, if no user  is specified, user 
1:c774a1c:      * defaults to APP.
1:c774a1c:      * -- Will depend on if the server has been started with property 
1:c774a1c:      * derby.drda.securityMechanism and to the value it is set to.  See method
1:c774a1c:      * (fixture) testNetworkServerSecurityMechanism() to check if server is 
1:c774a1c:      * using the derby.drda.securityMechanism to restrict client connections
1:c774a1c:      * based on security mechanism. 
1:c774a1c:      * 
1:c774a1c:      TABLE with all different combinations of userid, password, security
1:c774a1c:      mechanism of derby client that is covered by this testcase if test
1:c774a1c:      is run against IBM15 and JDK15. 
1:c774a1c: 
1:c774a1c:      IBM15 supports eusridpwd, whereas SunJDK15 doesnt support EUSRIDPWD
1:c774a1c: 
1:c774a1c:      Security Mechanisms supported by derby server and client
1:c774a1c:      ====================================================================
1:c774a1c:      |SecMec     |codepoint value|   User friendly name                  |
1:c774a1c:      ====================================================================
1:c774a1c:      |USRIDONL   |   0x04        |   USER_ONLY_SECURITY                  |
1:c774a1c:      |USRIDPWD   |   0x03        |   CLEAR_TEXT_PASSWORD_SECURITY        |
1:c774a1c:      |EUSRIDPWD  |   0x09        |   ENCRYPTED_USER_AND_PASSWORD_SECURITY|
1:c774a1c:      |USRSSBPWD  |   0x08        |   STRONG_PASSWORD_SUBSTITUTE_SECURITY |
1:c774a1c:      =====================================================================
1:c774a1c: 	 Explanation of columns in table. 
1:c774a1c: 
1:c774a1c: 	 a) Connection request specifies a user or not.
1:c774a1c: 	 Note: if no user is specified, client defaults to APP
1:c774a1c: 	 b) Connection request specifies a password or not
1:c774a1c: 	 c) Connection request specifies securityMechanism or not. the valid
1:c774a1c: 	 values are 4(USRIDONL), 3(USRIDPWD), 9(EUSRIDPWD) and 8(USRSSBPWD).
1:c774a1c: 	 d) support eusridpwd means whether this client jvm supports encrypted 
1:c774a1c:      userid/password security mechanism or not.  A value of Y means it 
1:c774a1c:      supports and N means no.
1:c774a1c: 	 The next three columns specify what the client sends to the server
1:c774a1c: 	 e) Does client send user information 
1:c774a1c: 	 f) Does client send password information
1:c774a1c: 	 g) What security mechanism value (secmec value) is sent to server.
1:c774a1c: 
1:c774a1c: 	 SecMec refers to securityMechanism.
1:c774a1c: 	 Y means yes, N means No,  - or blank means not specified.
1:c774a1c: 	 Err stands for error.
1:c774a1c: 	 Err(1) stands for null password not supported
1:c774a1c: 	 Err(2) stands for case when the JCE does not support encrypted userid and
1:c774a1c: 	 password security mechanism. 
1:c774a1c: 	 ----------------------------------------------------------------
1:c774a1c: 	 | url connection      | support   | Client sends to Server      |
1:c774a1c: 	 |User |Pwd    |secmec |eusridpwd  |User   Pwd    SecMec         |
1:c774a1c: 	 |#a   |#b     |#c     |#d         |#e     #f      #g            |
1:c774a1c: 	 |---------------------------------------------------------------|
1:c774a1c: 	 =================================================================
1:c774a1c:      |SecMec not specified on connection request                    
1:c774a1c: 	 =================================================================
1:c774a1c: 	 |Y    |Y     |-       |Y         |Y        Y       3            |
1:c774a1c: 	 |----------------------------------------------------------------
1:c774a1c: 	 |     |Y     |-       |Y         |Y        Y       3            |
1:c774a1c: 	 -----------------------------------------------------------------
1:c774a1c: 	 |Y    |      |-       |Y         |Y        N       4            |
1:c774a1c: 	 -----------------------------------------------------------------
1:c774a1c: 	 |     |      |-       |Y         |Y        N       4            |
1:c774a1c: 	 =================================================================
1:c774a1c:      |Y    |Y     |-       |N         |Y        Y       3            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |-       |N         |Y        Y       3            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |-       |N         |Y        N       4            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |-       |N         |Y        N       4            |
1:c774a1c:      =================================================================
1:c774a1c: 	 SecMec specified to 3 (clear text userid and password)
1:c774a1c: 	 =================================================================
1:c774a1c:      |Y    |Y     |3       |Y         |Y        Y       3            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |3       |Y         |Y        Y       3            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |3       |Y         |-        -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |3       |Y         |-        -       Err1         |
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |3       |N         |Y        Y       3            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |3       |N         |Y        Y       3            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |3       |N         |-        -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |3       |N         |-        -       Err1         |
1:c774a1c:      =================================================================
1:c774a1c: 	 SecMec specified to 9 (encrypted userid/password)
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |9       |Y         |Y        Y       9            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |9       |Y         |Y        Y       9            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |9       |Y         | -       -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |9       |Y         | -       -       Err1         |
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |9       |N         | -       -       Err2         |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |9       |N         | -       -       Err2         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |9       |N         | -       -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |9       |N         | -       -       Err1         |
1:c774a1c:      =================================================================
1:c774a1c: 	 SecMec specified to 4 (userid only security)
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |4       |Y         |Y        N       4            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |4       |Y         |Y        N       4            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |4       |Y         |Y        N       4            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |4       |Y         |Y        N       4            |
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |4       |N         |Y        N       4            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |4       |N         |Y        N       4            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |4       |N         |Y        N       4            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |4       |N         |Y        N       4            |
1:c774a1c:      =================================================================
1:c774a1c: 	 SecMec specified to 8 (strong password substitute)
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |8       |Y         |Y        Y       8            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |8       |Y         |Y        Y       8            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |8       |Y         | -       -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |8       |Y         | -       -       Err1         |
1:c774a1c:      =================================================================
1:c774a1c:      |Y    |Y     |8       |N         | -       Y       8            |
1:c774a1c:      |----------------------------------------------------------------
1:c774a1c:      |     |Y     |8       |N         | -       Y       8            |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |Y    |      |8       |N         | -       -       Err1         |
1:c774a1c:      -----------------------------------------------------------------
1:c774a1c:      |     |      |8       |N         | -       -       Err1         |
1:c774a1c:      ================================================================= 
1:c774a1c:      */
1:1146ea1:     private void assertAllCombinationsOfUserPasswordSecMecInputOK(
1:c774a1c:         String[] expectedValues) {
1:c774a1c:         // Try following combinations:
1:c774a1c:         // user { null, user attribute given}
1:c774a1c:         // password {null, pwd specified}
1:c774a1c:         // securityMechanism attribute specified and not specified.
1:c774a1c:         // try with different security mechanism values - 
1:c774a1c:         // {encrypted useridpassword, userid only, clear text userid &password}
1:c774a1c:         // try with drivermanager, try with datasource
1:c774a1c:         
1:c774a1c:         String urlAttributes = null;
1:c774a1c: 
1:c774a1c:         for (int k = 0; k < USER_ATTRIBUTE.length; k++) {
1:c774a1c:             for (int j = 0; j < PWD_ATTRIBUTE.length; j++) {
1:c774a1c:                 urlAttributes = "";
1:c774a1c:                 if (USER_ATTRIBUTE[k] != null)
1:c774a1c:                     urlAttributes += "user=" + USER_ATTRIBUTE[k] +";";
1:c774a1c:                 if (PWD_ATTRIBUTE[j] != null)
1:c774a1c:                     urlAttributes += "password=" + PWD_ATTRIBUTE[j] +";";
1:c774a1c:                 
1:7dc89cf:                 // removing the last semicolon that we added here
1:c774a1c:                 if (urlAttributes.length() >= 1)
1:c774a1c:                     urlAttributes = urlAttributes.substring(
1:c774a1c:                         0,urlAttributes.length()-1);
1:c774a1c: 
1:c774a1c:                 // case - do not specify securityMechanism explicitly in the 
1:c774a1c:                 // url get connection via driver manager and datasource.
1:c774a1c:                 assertConnectionUsingDriverManager(
1:c774a1c:                     getJDBCUrl(urlAttributes), "Test:", 
1:c774a1c:                     getExpectedValueFromAll(expectedValues, k, j, 4));
1:c774a1c:                 getDataSourceConnection(USER_ATTRIBUTE[k],PWD_ATTRIBUTE[j],
1:c774a1c:                     getExpectedValueFromAll(expectedValues, k, j, 4));
1:c774a1c: 
1:c774a1c:                 for (int i = 0; i < SECMEC_ATTRIBUTE.length; i++) {
1:c774a1c:                     // case - specify securityMechanism attribute in url
1:c774a1c:                     // get connection using DriverManager
1:c774a1c:                     assertConnectionUsingDriverManager(
1:c774a1c:                         getJDBCUrl(urlAttributes + ";securityMechanism=" + 
1:c774a1c:                             SECMEC_ATTRIBUTE[i]), "#", 
1:c774a1c:                             getExpectedValueFromAll(expectedValues, k, j, i));
1:c774a1c:                     // case - specify security mechanism on datasource
1:c774a1c:                     assertSecurityMechanismOK(
1:39b3237:                         USER_ATTRIBUTE[k],PWD_ATTRIBUTE[j], SECMEC_ATTRIBUTE[i], "TEST_DS (" + urlAttributes
1:c774a1c:                             + ",securityMechanism="+SECMEC_ATTRIBUTE[i]+")", 
1:c774a1c:                             getExpectedValueFromAll(expectedValues, k, j, i));
1:c774a1c:                 }
1:c774a1c:             }
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     private String getExpectedValueFromAll(String[] expectedValues,
1:c774a1c:         int USER_ATTR, int PWD_ATTR, int SECMEC_ATTR)
1:c774a1c:     {
1:c774a1c:         String expectedValue;
1:c774a1c:         // There are 2 values each for USER_ATTR and PWD_ATTR.
1:c774a1c:         if (derby_drda_securityMechanism == null)
1:c774a1c:             return "OK";
1:c774a1c:         // elses
1:c774a1c:         // value 0 is just the name of the sec mechanism
1:c774a1c:         // sec mec '4' means no security mechanism specified
1:c774a1c:         // datasource and drivermanager calls should have same result
1:c774a1c:         // values 1-6 are for user 1, pwd 1
1:c774a1c:         if (USER_ATTR == 0 && PWD_ATTR == 0)
1:c774a1c:         {
1:c774a1c:             if (SECMEC_ATTR == 4)
1:c774a1c:                 expectedValue = expectedValues[1];
1:c774a1c:             else
1:c774a1c:                 expectedValue = expectedValues[2+SECMEC_ATTR];
1:c774a1c:         }
1:c774a1c:         else if (USER_ATTR == 0 && PWD_ATTR == 1)
1:c774a1c:         {
1:c774a1c:             if (SECMEC_ATTR == 4)
1:c774a1c:                 expectedValue = expectedValues[6];
1:c774a1c:             else
1:c774a1c:                 expectedValue = expectedValues[7+SECMEC_ATTR];
1:c774a1c:         }
1:c774a1c:         else if (USER_ATTR == 1 && PWD_ATTR == 0)
1:c774a1c:         {
1:c774a1c:             if (SECMEC_ATTR == 4)
1:c774a1c:                 expectedValue = expectedValues[11];
1:c774a1c:             else
1:c774a1c:                 expectedValue = expectedValues[12+SECMEC_ATTR];
1:c774a1c:         }
1:c774a1c:         else
1:c774a1c:         {
1:c774a1c:             if (SECMEC_ATTR == 4)
1:c774a1c:                 expectedValue = expectedValues[16];
1:c774a1c:             else
1:c774a1c:                 expectedValue = expectedValues[17+SECMEC_ATTR];
1:c774a1c:         }
1:c774a1c:         return expectedValue;
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Helper method to get connection from datasource and to print
1:c774a1c:      * the exceptions if any when getting a connection. This method 
1:c774a1c:      * is used in assertAllCombinationsOfUserPasswordSecMecInputOK.
1:c774a1c:      * For explanation of exceptions that might arise in this method,
1:c774a1c:      * please check assertAllCombinationsOfUserPasswordSecMecInputOK
1:c774a1c:      * javadoc comment.
1:c774a1c:      * get connection from datasource
1:c774a1c:      * @param user username
1:c774a1c:      * @param password password
1:1b46090:      * @param expectedValue expected sql state
1:c774a1c:      */
1:1146ea1:     private void getDataSourceConnection(
1:afff7e0:         String user, String password, String expectedValue)
1:c774a1c:     {
1:c774a1c:         Connection conn;
1:c774a1c:         DataSource ds = getDS(user, password);
1:c774a1c:         try {
1:c774a1c:             // get connection via datasource without setting securityMechanism
1:c774a1c:             // cannot use ds.getConnection, because junit framework will
1:c774a1c:             // substitute 'null' with 'APP'.
1:c774a1c:             conn = ds.getConnection(user, password);
1:c774a1c:             conn.close();
1:c774a1c:         }
1:c774a1c:         catch (SQLException sqle)
1:c774a1c:         {
1:c774a1c:             // Exceptions expected in certain case hence printing message
1:c774a1c:             // instead of stack traces here. 
1:c774a1c:             // - For case if server doesnt accept connection with this 
1:c774a1c:             //   security mechanism
1:c774a1c:             // - For case when client driver does support USRSSBPWD security
1:c774a1c:             //   mechanism
1:c774a1c:             if ((user == null) && (sqle.getSQLState().equals("08001")))
1:c774a1c:                 assertSQLState08001("08001.C.7", sqle);
1:c774a1c:             else
1:c774a1c:                 assertSQLState(expectedValue, sqle);
1:c774a1c:             // for debugging, uncomment:
1:c774a1c:             //dumpSQLException(sqle.getNextException());
1:c774a1c:         }
1:c774a1c:         catch (Exception e)
1:c774a1c:         {
1:c774a1c:             fail ("should not have gotten an exception");
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Dump SQLState and message for the complete nested chain of SQLException 
1:c774a1c:      * @param sqle SQLException whose complete chain of exceptions is
1:c774a1c:      * traversed and sqlstate and message is printed out
1:c774a1c:      */
1:1146ea1:     private static void dumpSQLException(SQLException sqle)
1:c774a1c:     {
1:c774a1c:         while ( sqle != null)
1:c774a1c:         {
1:c774a1c:             println("SQLSTATE("+sqle.getSQLState()+"): " + 
1:c774a1c:                 sqle.getMessage());
1:c774a1c:             sqle = sqle.getNextException();
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Test a deferred connection reset. When connection pooling is done
1:c774a1c:      * and connection is reset, the client sends EXCSAT,ACCSEC and followed
1:c774a1c:      * by SECCHK and ACCRDB. Test if the security mechanism related information
1:c774a1c:      * is correctly reset or not. This method was added to help simulate 
1:c774a1c:      * regression test for DERBY-1080. It is called from testDerby1080.   
1:c774a1c:      * @param user username 
1:c774a1c:      * @param password password for connection
1:c774a1c:      * @param secmec security mechanism for datasource
1:c774a1c:      * @throws Exception
1:c774a1c:      */
1:1146ea1:     private void assertSecMecWithConnPoolingOK(
1:c774a1c:         String user, String password, Short secmec) throws Exception
1:c774a1c:     {     
1:c774a1c:         ConnectionPoolDataSource cpds = getCPDS(user,password);
1:c774a1c:         
1:c774a1c:         // call setSecurityMechanism with secmec.
1:72f8fa8:         JDBCDataSource.setBeanProperty(cpds,
1:72f8fa8:                 "SecurityMechanism", secmec);
1:c774a1c:                
1:c774a1c:         // simulate case when connection will be re-used by getting 
1:c774a1c:         // a connection, closing it and then the next call to
1:c774a1c:         // getConnection will re-use the previous connection.  
1:c774a1c:         PooledConnection pc = cpds.getPooledConnection();
1:72f8fa8:         Connection conn = pc.getConnection();
1:c774a1c:         conn.close();
2:c774a1c:         conn = pc.getConnection();
1:c774a1c:         assertConnectionOK(conn);
1:1146ea1:         pc.close();
1:c774a1c:         conn.close();
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Test a connection by executing a sample query
1:c774a1c:      * @param   conn    database connection
1:c774a1c:      * @throws Exception if there is any error
1:c774a1c:      */
1:1146ea1:     private void assertConnectionOK(Connection conn)
1:9dc398a:     throws SQLException
1:c774a1c:     {
1:c774a1c:         Statement stmt = conn.createStatement();
1:c774a1c:         ResultSet rs = null;
1:c774a1c:         // To test our connection, we will try to do a select from the 
1:c774a1c:         // system catalog tables
1:c774a1c:         rs = stmt.executeQuery("select count(*) from sys.systables");
1:c774a1c:         int updatecount=0;
1:c774a1c:         while(rs.next())
1:c774a1c:         {
1:c774a1c:             rs.getInt(1); // assume ok if no exception, ignore result
1:c774a1c:             updatecount++;
1:c774a1c:         }
1:c774a1c:         assertEquals(1,updatecount);
1:c774a1c:         
1:c774a1c:         if(rs != null)
1:c774a1c:             rs.close();
1:c774a1c:         if(stmt != null)
1:c774a1c:             stmt.close();
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     /**
1:c774a1c:      * This is a regression test for DERBY-1080 - where some variables required
1:c774a1c:      * only for the EUSRIDPWD security mechanism case were not getting reset on
1:c774a1c:      * connection re-use and resulting in protocol error. This also applies to
1:c774a1c:      * USRSSBPWD security mechanism. 
1:c774a1c:      * 
1:c774a1c:      * Read class level comments (#1) to understand what is specified by drda
1:c774a1c:      * spec for EUSRIDPWD.  
1:c774a1c:      * <br>
1:c774a1c:      * Encryption is done using JCE. Hence JCE support of the necessary
1:c774a1c:      * algorithm is required for EUSRIDPWD security mechanism to work. Thus
1:c774a1c:      * even though the server and client have code to support EUSRIDPWD, this
1:c774a1c:      * security mechanism will not work in all JVMs. 
1:c774a1c:      * 
1:c774a1c:      * JVMs where support for DH(32byte prime) is not available and thus EUSRIDPWD 
1:c774a1c:      * wont work are Sun JVM (versions 1.3.1, 1.4.1, 1.4.2, 1.5) and 
1:c774a1c:      * IBM JVM (versions 1.3.1 and some old versions of 1.4.2 (in 2004) )
1:c774a1c:      * 
1:c774a1c:      * Expected behavior for this test:
1:c774a1c:      * If no regression has occurred, this test should work OK, given the 
1:c774a1c:      * expected exception in following cases:
1:c774a1c:      * 1) When EUSRIDPWD is not supported in JVM the test is running, a CNFE
1:c774a1c:      * with initializing EncryptionManager will happen. This will happen for 
1:c774a1c:      * Sun JVM (versions 1.3.1, 1.4.1, 1.4.2, 1.5) and 
1:c774a1c:      * IBM JVM (versions 1.3.1 and some old versions of 1.4.2 (in 2004) )
1:c774a1c:      * For derby client, the error message is 
1:c774a1c:      * "Security exception encountered, see next exception for details."
1:c774a1c:      * 2)If server does not accept EUSRIDPWD security mechanism from clients,then
1:c774a1c:      * error message will be "Connection authorization failure
1:c774a1c:      * occurred. Reason: security mechanism not supported"
1:c774a1c:      * Note: #2 can happen if server is started with derby.drda.securityMechanism
1:c774a1c:      * and thus restricts what security mechanisms the client can connect with.
1:c774a1c:      * This will happen for the test run when derby.drda.securityMechanism is
1:c774a1c:      * set, to a valid value other than ENCRYPTED_USER_AND_PASSWORD_SECURITY.
1:c774a1c:      * <br>
1:c774a1c:      * See testNetworkServerSecurityMechanism where this method is called to 
1:c774a1c:      * test for regression for DERBY-1080, and to check if server is using the
1:c774a1c:      * derby.drda.securityMechanism to restrict client connections based on
1:c774a1c:      * the security mechanism.
1:c774a1c:      */
1:1146ea1:     private void assertDerby1080Fixed(String expectedValue)
1:9dc398a:             throws Exception {
1:c774a1c:         try
1:c774a1c:         {
1:c774a1c:             // simulate connection re-set using connection pooling on a pooled
1:c774a1c:             // datasource set security mechanism to use encrypted userid and
1:c774a1c:             // password.
1:c774a1c:             assertSecMecWithConnPoolingOK(
1:39b3237:                 "peter","neelima",SECMEC_EUSRIDPWD);
1:c774a1c:             if (!expectedValue.equals("OK"))
1:c774a1c:                 fail("expected SQLException if DERBY-1080 did not regress");
1:c774a1c:         }
1:c774a1c:         catch (SQLException sqle)
1:c774a1c:         {
1:c774a1c:             // Exceptions expected in certain case hence accepting different
1:c774a1c:             // SQLStates.
1:c774a1c:             // - For cases where the jvm does not support EUSRIDPWD.
1:c774a1c:             // - For case if server doesnt accept connection with this security
1:c774a1c:             // mechanism
1:c774a1c:             // Please see javadoc comments for this test method for more 
1:c774a1c:             // details of expected exceptions.
1:c774a1c:             if(!(sqle.getSQLState().equals("XJ112")))
1:c774a1c:                 assertSQLState(expectedValue, sqle);
1:c774a1c:             // for debugging, uncomment:
1:c774a1c:             // dumpSQLException(sqle.getNextException());
1:c774a1c:         }
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:c774a1c:      * Test SECMEC_USRSSBPWD with derby BUILTIN authentication turned ON.
1:c774a1c:      *
1:c774a1c:      * We want to test a combination of USRSSBPWD with BUILTIN as password
1:c774a1c:      * substitute is only supported with NONE or BUILTIN Derby authentication
1:8c305e2:      * scheme right now (DERBY-528). Also, it doesn't work if passwords are
1:8c305e2:      * hashed with the configurable hash authentication scheme (DERBY-4483)
1:8c305e2:      * before they are stored in the database, so we'll need to disable that.
1:c774a1c:      * 
1:c774a1c:      * @throws Exception if there an unexpected error
1:c774a1c:      */
1:1146ea1:     private void assertUSRSSBPWD_with_BUILTIN(String[] expectedValues)
1:9dc398a:             throws Exception {
1:7379752:         // Skip this security mechanism on platforms that are short on entropy,
1:7379752:         // otherwise this test will take a very long time to complete.
1:7379752:         if (!hasSufficientEntropy()) {
1:7379752:             return;
1:c774a1c:         }
1:c774a1c:         // Turn on Derby BUILTIN authentication and attempt connecting with
1:c774a1c:         // USRSSBPWD security mechanism.
1:c774a1c:         println("Turning ON Derby BUILTIN authentication");
1:afff7e0:         Connection conn = getDataSourceConnectionWithSecMec(
1:39b3237:             "neelima", "lee", SECMEC_USRSSBPWD);
1:c774a1c: 
1:c774a1c:         // Turn on BUILTIN authentication
1:c774a1c:         CallableStatement cs = conn.prepareCall(
1:c774a1c:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:c774a1c: 
1:8c305e2:         // First, disable the configurable hash authentication scheme so that
1:8c305e2:         // passwords are stored using the old hash algorithm.
1:8c305e2:         cs.setString(1, "derby.authentication.builtin.algorithm");
1:8c305e2:         cs.setString(2, null);
1:8c305e2:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.setString(1, "derby.user.neelima");
1:c774a1c:         cs.setString(2, "lee");
1:c774a1c:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.setString(1, "derby.user.APP");
1:c774a1c:         cs.setString(2, "APP");
1:c774a1c:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.setString(1, "derby.database.fullAccessUsers");
1:c774a1c:         cs.setString(2, "neelima,APP");
1:c774a1c:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.setString(1, "derby.connection.requireAuthentication");
1:c774a1c:         cs.setString(2, "true");
1:c774a1c:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.close();
1:c774a1c:         cs = null;
1:c774a1c: 
1:c774a1c:         conn.close();
1:c774a1c: 
1:c774a1c:         // Shutdown database for BUILTIN
1:c774a1c:         // authentication to take effect the next time it is
1:c774a1c:         // booted - derby.connection.requireAuthentication is a
1:c774a1c:         // static property.
1:c774a1c:         assertConnectionUsingDriverManager(getJDBCUrl(
1:c774a1c:             "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:c774a1c:             SECMEC_USRSSBPWD),"USRSSBPWD (T0):", expectedValues[1]);
1:c774a1c: 
1:c774a1c:         // Now test some connection(s) with SECMEC_USRSSBPWD
1:c774a1c:         // via DriverManager and Datasource
1:c774a1c:         assertConnectionUsingDriverManager(getJDBCUrl(
1:c774a1c:             "user=neelima;password=lee;securityMechanism=" +
1:c774a1c:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T1):", expectedValues[2]);
1:c774a1c:         assertSecurityMechanismOK(
1:39b3237:             "neelima","lee",SECMEC_USRSSBPWD,
1:c774a1c:             "TEST_DS - USRSSBPWD + BUILTIN (T2):", expectedValues[2]);
1:c774a1c:         // Attempting to connect with some invalid user
1:c774a1c:         assertConnectionUsingDriverManager(getJDBCUrl(
1:c774a1c:             "user=invalid;password=user;securityMechanism=" +
1:c774a1c:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T3):",expectedValues[3]);
1:c774a1c:         assertSecurityMechanismOK(
1:39b3237:             "invalid","user",SECMEC_USRSSBPWD,
1:c774a1c:             "TEST_DS - USRSSBPWD + BUILTIN (T4):", expectedValues[3]);
1:c774a1c: 
1:c774a1c:         // Prepare to turn OFF Derby BUILTIN authentication
1:afff7e0:         conn = getDataSourceConnectionWithSecMec("neelima", "lee",
1:39b3237:             SECMEC_USRSSBPWD);
1:c774a1c: 
1:c774a1c:         // Turn off BUILTIN authentication
1:c774a1c:         cs = conn.prepareCall(
1:c774a1c:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1:c774a1c: 
1:c774a1c:         cs.setString(1, "derby.connection.requireAuthentication");
1:c774a1c:         cs.setString(2, "false");
1:c774a1c:         cs.execute();
1:c774a1c: 
1:c774a1c:         cs.close();
1:c774a1c:         cs = null;
1:c774a1c:         conn.close();
1:c774a1c: 
1:c774a1c:         // Shutdown 'wombat' database for BUILTIN authentication
1:c774a1c:         // to take effect the next time it is booted
1:c774a1c:         assertConnectionUsingDriverManager(getJDBCUrl(
1:c774a1c:             "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:c774a1c:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T5):", expectedValues[4]);
1:c774a1c:     }
1:c774a1c:     
1:1146ea1:     private Connection getDataSourceConnectionWithSecMec(
1:afff7e0:         String user, String password, Short secMec)
1:9dc398a:             throws Exception {
1:c774a1c: 
1:c774a1c:         DataSource ds = getDS(user, password);
1:72f8fa8:         JDBCDataSource.setBeanProperty(ds,
1:72f8fa8:                 "SecurityMechanism", secMec);
1:9dc398a:         return ds.getConnection();
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private String getJDBCUrl(String attrs) {
1:c774a1c:         String dbName = 
1:c774a1c:             TestConfiguration.getCurrent().getDefaultDatabaseName();
1:c774a1c:         // s is protocol, subprotocol, + dbName
1:c774a1c:         String s = TestConfiguration.getCurrent().getJDBCUrl(dbName);
1:c774a1c: 
1:c774a1c:         if (attrs != null)
1:c774a1c:             if (usingDerbyNetClient())
1:c774a1c:                 s = s + ";" + attrs;
1:c774a1c:             else
1:c774a1c:                 s = s + ":" + attrs + ";";
1:c774a1c:         return s;
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private javax.sql.DataSource getDS(String user, String password)
1:c774a1c:     {
1:9d44c9e:         HashMap<String, Object> attrs = new HashMap<String, Object>();
1:c774a1c:         if (user != null)
1:c774a1c:             attrs.put("user", user);
1:c774a1c:         if (password != null)
1:c774a1c:             attrs.put("password", password);
1:c774a1c:         attrs = addRequiredAttributes(attrs);
1:c774a1c: 
1:c774a1c:         DataSource ds = JDBCDataSource.getDataSource();
1:9d44c9e:         for (String property : attrs.keySet()) {
1:c774a1c:             Object value = attrs.get(property);
1:c774a1c:             JDBCDataSource.setBeanProperty(ds, property, value);
1:c774a1c:         }
1:c774a1c:         return ds;
1:c774a1c:     }
1:c774a1c: 
1:9d44c9e:     private HashMap<String, Object> addRequiredAttributes(
1:9d44c9e:             HashMap<String, Object> attrs)
1:c774a1c:     {
1:530c877:         String hostName = TestConfiguration.getCurrent().getHostName();
1:ad60cd5:         int port = TestConfiguration.getCurrent().getPort();
1:c774a1c:         /** 
1:7dc89cf:          * serverName defaults to localhost (see DERBY-410), 
1:7dc89cf:          * but for a remote host it's needed 
1:c774a1c:          */
1:c774a1c:         if (!hostName.equals("localhost"))
1:c774a1c:         {
1:c774a1c:             attrs.put("serverName", hostName);
1:39b3237:             attrs.put("portNumber", port);
1:c774a1c:         }
1:c774a1c:         else
1:c774a1c:         {
1:39b3237:             attrs.put("portNumber", port);
1:c774a1c:         }
1:c774a1c:         return attrs;
1:c774a1c:     }
1:c774a1c: 
1:1146ea1:     private javax.sql.ConnectionPoolDataSource getCPDS(
1:c774a1c:         String user, String password)
1:c774a1c:     {
1:9d44c9e:         HashMap<String, Object> attrs = new HashMap<String, Object>();
1:c774a1c:         if (user != null)
1:c774a1c:             attrs.put("user", user);
1:c774a1c:         if (password != null)
1:c774a1c:             attrs.put("password", password);
1:c774a1c: 
1:c774a1c:         attrs = addRequiredAttributes(attrs);
1:c774a1c:         ConnectionPoolDataSource cpds = 
1:c774a1c:             J2EEDataSource.getConnectionPoolDataSource();
1:9d44c9e:         for (String property : attrs.keySet()) {
1:c774a1c:             Object value = attrs.get(property);
1:c774a1c:             JDBCDataSource.setBeanProperty(cpds, property, value);
1:c774a1c:         }
1:c774a1c:         return cpds;
1:c774a1c:     }
1:c774a1c:     
1:c774a1c:     private void assertSQLState08001(String expectedValue, SQLException sqle)
1:c774a1c:     {
1:c774a1c:         if (expectedValue.equals("08001.C.7"))
1:c774a1c:             assertEquals("User id can not be null.", sqle.getMessage());
1:c774a1c:         if (expectedValue.equals("08001.C.8"))
1:c774a1c:             assertEquals("Password can not be null.", sqle.getMessage());
1:c774a1c:     }
1:c774a1c: 
1:c774a1c:     /**
1:7379752:      * Tells if the current platform is assumed to have sufficient entropy for
1:7379752:      * the strong password substitution security mechanism to run reasonably
1:7379752:      * fast.
1:c774a1c:      */
1:7379752:     private boolean hasSufficientEntropy() {
1:7379752:         // The ARM platform is known to suffer from too little entropy
1:7379752:         // (unless there is significant disk activity).
1:7379752:         return !getSystemProperty("os.arch").equalsIgnoreCase("arm");
1:c774a1c:     }
1:c774a1c: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             assertSecurityMechanismOK("sarah",null, SECMEC_USRIDONL,"SECMEC_USRIDONL:", expectedValues[1]);
1:         assertSecurityMechanismOK("john","sarah", SECMEC_USRIDPWD,"SECMEC_USRIDPWD:", expectedValues[2]);
/////////////////////////////////////////////////////////////////////////
1:             assertSecurityMechanismOK("john","sarah",SECMEC_EUSRIDPWD,"SECMEC_EUSRIDPWD:", expectedValues[3]);
1:             assertSecurityMechanismOK("john","sarah",SECMEC_USRSSBPWD,"SECMEC_USRSSBPWD:", expectedValues[4]);
/////////////////////////////////////////////////////////////////////////
1:             if (!(secmec.equals(SECMEC_EUSRIDPWD)))
/////////////////////////////////////////////////////////////////////////
1:             else if (secmec.equals(SECMEC_EUSRIDPWD)) 
/////////////////////////////////////////////////////////////////////////
1:                         USER_ATTRIBUTE[k],PWD_ATTRIBUTE[j], SECMEC_ATTRIBUTE[i], "TEST_DS (" + urlAttributes
/////////////////////////////////////////////////////////////////////////
1:                 "peter","neelima",SECMEC_EUSRIDPWD);
/////////////////////////////////////////////////////////////////////////
1:             "neelima", "lee", SECMEC_USRSSBPWD);
/////////////////////////////////////////////////////////////////////////
1:             "neelima","lee",SECMEC_USRSSBPWD,
1:             "invalid","user",SECMEC_USRSSBPWD,
1:             SECMEC_USRSSBPWD);
/////////////////////////////////////////////////////////////////////////
1:             attrs.put("portNumber", port);
1:             attrs.put("portNumber", port);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:ed3bfc8
/////////////////////////////////////////////////////////////////////////
1:                     "java.lang.InternalError: Unexpected CryptoAPI failure"))
commit:dac3aab
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.io.StringWriter;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             else if (sqle.getSQLState().equals("XJ001"))
1:             {
1:                 // we might have hit DERBY-6702. We know the stack trace
1:                 // of that situation, so skip if we see it, except to repeat
1:                 // the passed in values.
1:                 StringWriter sw = new StringWriter();
1:                 sqle.printStackTrace(new PrintWriter(sw));
1:                 if (!sw.toString().contains(
0:                     "java.lang.InternalError: unexpected CryptoAPI failure"))
1:                     assertSQLState(expectedValue, sqle);
1:                 else
1:                     alarm("hit DERBY-6702; for values:" +
1:                     "\n\t dbURL: " + dbUrl +
1:                     "\n\t msg: " + msg + 
1:                     "\n\t expectedValue: " + expectedValue + "\n");
1:             }
1:                 if (expectedValue.length() < 5) {
1:                     StringWriter sw = new StringWriter();
1:                     sqle.printStackTrace(new PrintWriter(sw));
1:                     String emsgtxt = "unexpected failure..." +
1:                         "\n\t dbURL: " + dbUrl +
1:                         "\n\t msg: " + msg + 
1:                         "\n\t expectedValue: " + expectedValue ; 
1:                     fail (emsgtxt, sqle);
1:                 }
1:                 else
1:                     assertSQLState(expectedValue, sqle);
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
1:  * #2) Note, if  server restricts the client connections based on security 
1:  * #3) USRSSBPWD - Strong password substitute is only supported starting from
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * -- the client behavior. For the derby client, the table below 
1:      * represents what security mechanism the client will send to server. 
/////////////////////////////////////////////////////////////////////////
1:                 // removing the last semicolon that we added here
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          * serverName defaults to localhost (see DERBY-410), 
1:          * but for a remote host it's needed 
commit:1146ea1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
/////////////////////////////////////////////////////////////////////////
1:             else
1:             {
1:                 // shutdown the database - this will prevent slow startup 
1:                 // when bouncing the server with next security mechanism.
1:                 // for ENCRYPTED_USER_AND_PASSWORD_SECURITY:
1:                 short secmeccode=SECMEC_EUSRIDPWD;
1:                 if (derby_drda_securityMechanism.equals("USER_ONLY_SECURITY"))
1:                     secmeccode=SECMEC_USRIDONL;
1:                 else if (derby_drda_securityMechanism.equals(
1:                     "CLEAR_TEXT_PASSWORD_SECURITY"))
1:                     secmeccode=SECMEC_USRIDPWD;
1:                 assertConnectionUsingDriverManager(getJDBCUrl(
1:                     "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:                     secmeccode)," BUILTIN (T5):",
1:                     "08006");
1:             }
1:     private boolean setSecurityMechanism(String derby_security_mechanism) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             NetworkServerTestSetup.waitForServerStart(server2);
/////////////////////////////////////////////////////////////////////////
1:     private void assertConnectionsUsingDriverManager(String[] expectedValues)
/////////////////////////////////////////////////////////////////////////
1:     private void assertConnectionUsingDataSource(String[] expectedValues)
/////////////////////////////////////////////////////////////////////////
1:     private void assertSecurityMechanismOK(String user, String password,
/////////////////////////////////////////////////////////////////////////
1:     private void assertConnectionUsingDriverManager(
/////////////////////////////////////////////////////////////////////////
1:     private void assertAllCombinationsOfUserPasswordSecMecInputOK(
/////////////////////////////////////////////////////////////////////////
1:     private void getDataSourceConnection(
/////////////////////////////////////////////////////////////////////////
1:     private static void dumpSQLException(SQLException sqle)
/////////////////////////////////////////////////////////////////////////
1:     private void assertSecMecWithConnPoolingOK(
/////////////////////////////////////////////////////////////////////////
1:         pc.close();
/////////////////////////////////////////////////////////////////////////
1:     private void assertConnectionOK(Connection conn)
/////////////////////////////////////////////////////////////////////////
1:     private void assertDerby1080Fixed(String expectedValue)
/////////////////////////////////////////////////////////////////////////
1:     private void assertUSRSSBPWD_with_BUILTIN(String[] expectedValues)
/////////////////////////////////////////////////////////////////////////
1:     private Connection getDataSourceConnectionWithSecMec(
/////////////////////////////////////////////////////////////////////////
1:     private String getJDBCUrl(String attrs) {
/////////////////////////////////////////////////////////////////////////
1:     private javax.sql.DataSource getDS(String user, String password)
0:     private javax.sql.DataSource getDS(
/////////////////////////////////////////////////////////////////////////
1:     private javax.sql.ConnectionPoolDataSource getCPDS(
/////////////////////////////////////////////////////////////////////////
0:     private static String getSetterName(String attribute)
/////////////////////////////////////////////////////////////////////////
commit:1b46090
/////////////////////////////////////////////////////////////////////////
1:     
0:     public void tearDown() throws Exception {
1:         try {
0:             AccessController.doPrivileged
0:             (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return System.getProperties().remove(
0:                             "derby.drda.securityMechanism");
1:                 }
0:             });
1:         } catch (Exception e) {
0:             fail("warning: could not remove secmec settings");
1:         }
1:         super.tearDown();
1:     }
/////////////////////////////////////////////////////////////////////////
0:             Thread.sleep(120000);
/////////////////////////////////////////////////////////////////////////
1:      * @param expectedValue expected sql state
commit:afff7e0
/////////////////////////////////////////////////////////////////////////
0:         Thread.sleep(500);
/////////////////////////////////////////////////////////////////////////
0:             Thread.sleep(80000);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         String user, String password, String expectedValue)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Connection conn = getDataSourceConnectionWithSecMec(
/////////////////////////////////////////////////////////////////////////
1:             conn = getDataSourceConnectionWithSecMec("neelima", "lee",
/////////////////////////////////////////////////////////////////////////
0:     public Connection getDataSourceConnectionWithSecMec(
1:         String user, String password, Short secMec)
/////////////////////////////////////////////////////////////////////////
0:             // running the test, but in this case, we don't expect any
0:             // sqlexceptions
0:             fail("did not expect an sqlexception.");
0:             fail("did not expect exception.");
commit:c774a1c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class 
1:       org.apache.derbyTesting.functionTests.tests.derbynet.NSSecurityMechanismTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.derbynet;
1: 
0: import java.lang.reflect.*;
0: import java.net.InetAddress;
1: import java.util.HashMap;
0: import java.util.Iterator;
1: 
0: import java.security.AccessController;
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.CallableStatement;
1: import java.sql.Statement;
1: import java.sql.SQLException;
1: import java.sql.DriverManager;
1: import javax.sql.DataSource;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: 
0: import org.apache.derby.drda.NetworkServerControl;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: /**
1:  * This class tests the security mechanisms supported by Network Server
1:  * Network server supports SECMEC_EUSRIDPWD, SECMEC_USRIDPWD, SECMEC_USRIDONL
1:  * and SECMEC_USRSSBPWD.
1:  * 
1:  * -----------------------------------------------------------------
1:  * Security Mechanism | secmec           | User friendly name   
1:  *                    |  codepoint value |
1:  * -----------------------------------------------------------------
1:  * USRIDONL           | 0x04             | USER_ONLY_SECURITY
1:  * USRIDPWD           | 0x03             | CLEAR_TEXT_PASSWORD_SECURITY
1:  * EUSRIDPWD          | 0x09             | ENCRYPTED_USER_AND_PASSWORD_SECURITY
1:  * USRSSBPWD          | 0x08             | STRONG_PASSWORD_SUBSTITUTE_SECURITY
1:  * -----------------------------------------------------------------
1:  * 
1:  * Key points: 
1:  * #1) Server and client support encrypted userid/password (EUSRIDPWD) via the
1:  * use of Diffie Helman key-agreement protocol - but current Open Group DRDA
1:  * specifications imposes small prime and base generator values (256 bits) that
1:  * prevents other JCE's to be used as java cryptography providers - typical
1:  * minimum security requirements is usually of 1024 bits (512-bit absolute
1:  * minimum) when using DH key-agreement protocol to generate a session key.
1:  * 
1:  * (Reference: DDM manual, page 281 and 282. Section: Generating the shared
1:  * private key. DRDA's diffie helman agreed public values for prime are 256
1:  * bits. The spec gives the public values for the prime, generator and the size
1:  * of exponent required for DH . These values must be used as is to generate a
1:  * shared private key.)
1:  * 
1:  * Encryption is done using JCE. Hence JCE support of the necessary algorithm
1:  * is required for a particular security mechanism to work. Thus even though 
1:  * the server and client have code to support EUSRIDPWD, this security 
1:  * mechanism will not work in all JVMs.
1:  * 
1:  * JVMs where support for DH(32byte prime) is not available and thus EUSRIDPWD
1:  * won't work are Sun JVM (versions 1.3.1,1.4.1,1.4.2,1.5) and IBM JVM (
1:  * versions 1.3.1 and some old versions of 1.4.2 (in 2004))
1:  * 
1:  * JVMs where support for DH(32bytes prime) is available and thus EUSRIDPWD 
1:  * will work are IBM JVM [versions 1.4.1, later versions of 1.4.2 (from 2005),
1:  * 1.5]
1:  * 
0:  * #2) JCC 2.6 client does some automatic upgrade of security mechanism in one
0:  * case. Logic is  as follows:
0:  * If client sends USRIDPWD to server and server rejects this
0:  * and says it accepts only EUSRIDPWD, in that case JCC 2.6 will upgrade the 
0:  * security mechanism to EUSRIDPWD and retry the request with EUSRIDPWD.
0:  * This switching will also override the security mechanism specified by user.
0:  * Thus if JCC client is running with Sun JVM 1.4.2 and even though Sun JCE
0:  * does not have support for algorithms needed for  EUSRIDPWD, the JCC client
0:  * will still try to switch to  EUSRIDPWD and throw an exception with 
0:  * ClassNotFoundException for the IBM JCE.
1:  *
0:  * - Default security mechanism is USRIDPWD(0x03)
0:  * - If securityMechanism is not explicitly specified on connection request 
0:  *   and if no user specified, an exception is thrown - Null userid not 
0:  *   supported
0:  * - If securityMechanism is not explicitly specified on connection request, 
0:  *   and if no password is specified, an exception is thrown - null password
0:  *   not supported
0:  *   If securityMechanism is explicitly specified to be USRIDONL,  then a
0:  *   password is not required. But in other cases (EUSRIDPWD, USRIDPWD, 
0:  *   USRSSBPWD) if password is null, an exception with the message 'a null
0:  *   password not valid' will be thrown.
0:  * - On datasource, setting a security mechanism works. It also allows a 
0:  *   security mechanism of USRIDONL to be set on datasource unlike jcc 2.4.
1:  * 
0:  * #3)JCC 2.4 client behavior 
0:  * Default security mechanism used is USRIDPWD (0x03)
0:  * If securityMechanism is not explicitly specified on connection request, and
0:  * if no user is specified, an exception is thrown - Null userid not supported.
0:  * If securityMechanism is not explicitly specified on connection request, and
0:  * if no password is specified, an exception is thrown - null password not
0:  * supported.
0:  * If security mechanism is specified, jcc client will not override the 
0:  * security mechanism.
0:  * If securityMechanism is explicitly specified to be USRIDONL, then a password
0:  * is not required. But in other cases (EUSRIDPWD,USRIDPWD) if password is null
0:  * an exception with the message 'a null password not valid' will be thrown.
0:  * On datasource, setting a security mechanism does not work (bug). It defaults
0:  * to USRIDPWD.  Setting a value of USRIDONL or EUSRIDPWD does not seem to have
0:  * an effect.
1:  * 
0:  * #4) Note, if  server restricts the client connections based on security 
1:  * mechanism by setting derby.drda.securityMechanism, in that case the clients 
1:  * will see an error similar to this:
1:  * "Connection authorization failure occurred. Reason: security mechanism not
1:  *  supported"
1:  *
0:  * #5) USRSSBPWD - Strong password substitute is only supported starting from
1:  *     Apache Derby 10.2.
1:  *	 NOTE: USRSSBPWD only works with the derby network client driver for now.
1:  *   ---- 
1:  */
1: public class NSSecurityMechanismTest extends BaseJDBCTestCase
1: {
1:     // values for derby.drda.securityMechanism property
1:     private static String[] derby_drda_securityMechanisms = {
1:         null, // not set 
1:         "USER_ONLY_SECURITY", "CLEAR_TEXT_PASSWORD_SECURITY",
1:         // this will give a DRDA_InvalidValue with jvms that do not support it
1:         "ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:         "STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:         //these two are always invalid values, again, will give DRDA_InvalidValue
1:         "INVALID_VALUE", ""};
1:     
1:     private static String derby_drda_securityMechanism;
1: 
1:     // possible interesting combinations with respect to security mechanism
1:     // upgrade logic for user attribute
1:     private static String[] USER_ATTRIBUTE = {"calvin",null};
1: 
1:     // possible interesting combinations with respect to security mechanism
1:     // upgrade logic for password attribute
1:     private static String[] PWD_ATTRIBUTE = {"hobbes",null};
1: 
1:     public NSSecurityMechanismTest(String name)
1:     {
1:         super(name);
1:     }
1:     
1:     public static Test suite() 
1:     {
0:         TestSuite suite = new TestSuite("NSSecurityMechanismTest");
0:         suite.addTest(new NSSecurityMechanismTest(
1:             "testNetworkServerSecurityMechanism"));
0:         return TestConfiguration.clientServerDecorator((suite));
1:     }
1: 
1:     // Indicates userid/encrypted password security mechanism.
1:     static final short SECMEC_EUSRIDPWD = 0x09;
1: 
1:     // Indicates userid only security mechanism.
1:     static final short SECMEC_USRIDONL = 0x04;
1: 
1:     // Indicates userid/encrypted password security mechanism.
1:     static final short SECMEC_USRENCPWD = 0x07;
1: 
1:     // Indicates userid/new password security mechanism.
1:     static final short SECMEC_USRIDNWPWD = 0x05;
1: 
1:     // Indicates userid/password security mechanism.
1:     static final short SECMEC_USRIDPWD = 0x03;
1: 
1:     // Indicates strong password substitute security mechanism.
1:     static final short SECMEC_USRSSBPWD = 0x08;
1: 
1:     // client and server recognize these secmec values
1:     private static short[] SECMEC_ATTRIBUTE = {
1:         SECMEC_USRIDONL,
1:         SECMEC_USRIDPWD,
1:         SECMEC_EUSRIDPWD,
1:         SECMEC_USRSSBPWD
1:     };
1: 
1:     /**
1:      *  Test cases for security mechanism
1:      *  ---------------------------------------------------------------
1:      *  DriverManager:
1:      *  T1 - default , no user      PASS (for derbyclient)
1:      *  T2 - user only              PASS (for derbyclient)
1:      *  T3 - user,password          PASS (only for derbynet)
1:      *  T4 - user,password, security mechanism not set  FAIL
1:      *  T5 - user,password, security mechanism set
1:      *       to SECMEC_EUSRIDPWD  PASS/FAIL
1:      *       (Fails with Sun JVM as EUSRIDPWD secmec cannot be used)
1:      *  T6 - user, security mechanism set to SECMEC_USRIDONL   PASS
1:      *  T7 - user,password, security mechanism set to SECMEC_USRENCPWD  FAIL
1:      *  Test with datasource as well as DriverManager
1:      *  T8 - user,password security mechanism set to SECMEC_USRIDONL   PASS
1:      *  T9 - user,password security mechanism set to SECMEC_USRSSBPWD  PASS
1:      *  Test with datasource as well as DriverManager
1:      * Note, that with DERBY-928, the pass/fail for the connections will depend 
1:      * on the security mechanism specified at the server by property 
1:      * derby.drda.securityMechanism.  Please check out the following
1:      * html file http://issues.apache.org/jira/secure/attachment/12322971/Derby928_Table_SecurityMechanisms..htm
1:      * for a combination of url/security mechanisms and the expected results 
1:      */
1:     public void testNetworkServerSecurityMechanism() throws SQLException, Exception
1:     {
1:         String[][] allDriverManagerExpectedValues = {
1:             {"null",
1:                 "OK","OK","OK","OK","OK","OK","?","OK","OK"},
1:             {"USER_ONLY_SECURITY",
1:                 "OK","OK","08004","08004","08004","OK","?","OK","08004"},
1:             {"CLEAR_TEXT_PASSWORD_SECURITY",
1:                 "08004","08004","OK","OK","08004","08004",
1:                 "?","08004","08004"},
1:             // this should give a DRDA_InvalidValue with jvms that do not
1:             // support it. For instance, it will fail with jdk14 jvms.
1:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:                 "08004","08004","08004","08004","OK","08004",
1:                 "?","08004","08004"},
1:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:                     "08004","08004","08004","08004","08004","08004",
1:                     "?","08004","OK"},
1:             };
1:         
1:         String[][] allDataSourceExpectedValues = {
1:             {null,"OK","OK","OK","OK"},
1:             {"USER_ONLY_SECURITY","OK","08004","08004","08004"},
1:             {"CLEAR_TEXT_PASSWORD_SECURITY","08004","OK","08004","08004"},
1:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:                 "08004","08004","OK","08004"},
1:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:                 "08004","08004","08004","OK"}};
1:         
1:         String[] DERBY1080ExpectedValues = {"OK","08004","08004","OK","08004"};
1:         
1:         String[][] allUserPwdSecMecExpectedValues = {
1:             // if secmec is null, all expected to pass.
1:             {null},
1:             {"USER_ONLY_SECURITY",
1:                 "08004","OK","08004","08004","08004", 
1:                 "OK","OK","08001.C.8","08001.C.8","08001.C.8",
1:                 "08004","OK","08004","08004","08004",
1:                 "OK","OK","08001.C.8","08001.C.8","08001.C.8"
1:             },
1:             {"CLEAR_TEXT_PASSWORD_SECURITY",
1:                 "OK","08004","OK","08004","08004", 
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:                 "OK","08004","OK","08004","08004",
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
1:             },
1:             {"ENCRYPTED_USER_AND_PASSWORD_SECURITY",
1:                 "08004","08004","08004","OK","08004", 
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:                 "08004","08004","08004","OK","08004",
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
1:             },
1:             {"STRONG_PASSWORD_SUBSTITUTE_SECURITY",
1:                 "08004","08004","08004","08004","OK", 
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8",
1:                 "08004","08004","08004","08004","OK",
1:                 "08004","08004","08001.C.8","08001.C.8","08001.C.8"
1:             }
1:         };
1:         
1:         String[] testDERBY528ExpectedValues = {
1:             null,"08006","OK","08004","08006"
1:         };
1:         
1:         // just to see if this will work
1:         getConnection().getAutoCommit();
1:         
1:         for ( int i = 0; i < derby_drda_securityMechanisms.length; i++)
1:         {   
1:             derby_drda_securityMechanism = derby_drda_securityMechanisms[i];
1: 
1:             // Using 'null' will give a nullpointer exception...
1:             // as it's the first in the array, it should use default setting
1:             if (derby_drda_securityMechanism != null)
1:             {
1:                 // with "" or "INVALID_VALUE", or with other mechanisms with
1:                 // certain jvms, some settings are not supported. Flag the loop
1:                 // to not try connections
1:                 if (setSecurityMechanism(derby_drda_securityMechanism))
1:                     continue;
1:             }
1:             // Test cases with get connection via drivermanager and via
1:             // datasource, using different security mechanisms.
1:             // Network server supports SECMEC_USRIDPWD, SECMEC_USRIDONL,
1:             // SECMEC_EUSRIDPWD and USRSSBPWD (derby network client only)
1: 
1:             assertConnectionsUsingDriverManager(
1:                 allDriverManagerExpectedValues[i]);
1:             
1:             assertConnectionUsingDataSource(allDataSourceExpectedValues[i]);
1: 
1:             // regression test for DERBY-1080
1:             assertDerby1080Fixed(DERBY1080ExpectedValues[i]);
1: 
1:             // test for DERBY-962
1:             // test all combinations of user/password with security mechanism
1:             assertAllCombinationsOfUserPasswordSecMecInputOK(
1:                 allUserPwdSecMecExpectedValues[i]);
1: 
1:             // test USRSSBPWD (DERBY-528) with Derby BUILTIN authentication 
1:             // scheme both with none and USRSSBPWD specified DRDA SecMec upon
1:             // starting the network server.
1:             if ((derby_drda_securityMechanism == null) ||
1:                 (derby_drda_securityMechanism.equals(
1:                 "STRONG_PASSWORD_SUBSTITUTE_SECURITY")))
1:             {
1:                 assertUSRSSBPWD_with_BUILTIN(testDERBY528ExpectedValues);
1:             }
1:         }
1:     }
1:     
1:     // returns a boolean true if the security mechanism is not supported
1:     // so the loop in which this is called can be continued without
1:     // causing unnecessary/impossible tests to be run
0:     public boolean setSecurityMechanism(String derby_security_mechanism) 
1:     throws Exception {
1:         try {
0:         // getting a networkservercontrol to shutdown the currently running 
1:         // server, before setting the next security mechanism
0:         NetworkServerControl server = new NetworkServerControl(
0:             InetAddress.getByName(
0:                 TestConfiguration.getCurrent().getHostName()),
0:                 TestConfiguration.getCurrent().getPort());
1: 
0:         // shut down the server
0:         server.shutdown();
0:         Thread.sleep(1000);
1:         } catch (Exception e) {
1:             if (!(e.getMessage().substring(0,17).equals("DRDA_InvalidValue")))
1:             {
1:                 fail("unexpected error");
1:             }
1:         }
1: 
1:         try {
0:             AccessController.doPrivileged
0:             (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     return System.setProperty(
0:                         "derby.drda.securityMechanism",
1:                         derby_drda_securityMechanism);
1:                 }
0:             });
1:             
1:             // if the security mechanism isn't supported or invalid, getting a
1:             // networkservercontrol will fail.
0:             NetworkServerControl server2 = new NetworkServerControl(
0:                 InetAddress.getByName(
0:                     TestConfiguration.getCurrent().getHostName()),
0:                     TestConfiguration.getCurrent().getPort());
1: 
0:             // For debugging, to make output come to console uncomment:
0:             //server2.start(new PrintWriter(System.out, true));
0:             // and comment out:
0:             server2.start(null);
0:             // TODO: sleep ridiculously long, otherwise getting 08001 errors
0:             //       even when the server is up.
0:             Thread.sleep(120000);
1:             
1:             if (derby_drda_securityMechanism.equals("") ||
1:                 derby_drda_securityMechanism.equals("INVALID_VALUE"))
1:             {
1:                 fail(
1:                     "expected server not to start with invalid or empty " +
1:                      "security mechanism, but passed");
1:             }
1:         } catch (Exception e) {
1:             // "" or "INVALID_VALUE" should always give DRDA_Invalid_Value, 
1:             // hence the 'fail' above.
1:             // However, other mechanisms may not be supported with certain
1:             // jvms, and then also will get the same exception. This is true
1:             // for ENCRYPTED_USER_AND_PASSWORD_SECURITY.
1:             // If we're not getting DRDA_Invalid_Value here, something's gone
1:             // wrong.
1:             if (derby_drda_securityMechanism.equals("") ||
1:                 derby_drda_securityMechanism.equals("INVALID_VALUE") ||
1:                 derby_drda_securityMechanism.equals(
1:                     "ENCRYPTED_USER_AND_PASSWORD_SECURITY"))
1:             {
1:                 // should give invalid value 
1:                 assertEquals("DRDA_InvalidValue",e.getMessage().substring(0,17));
1:                 return true;
1:             }
1:             fail ("got unexpected exception setting the mechanism " + 
1:                 derby_security_mechanism + "; message: " + e.getMessage());
1:         }
1:         return false;
1:     }
1: 
0:     public void assertConnectionsUsingDriverManager(String[] expectedValues)
1:     {
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl(null),"T1:", expectedValues[1]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=max"),"T2:", expectedValues[2]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;password=lee"),"T3:", expectedValues[3]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:             SECMEC_USRIDPWD),"T4:", expectedValues[4]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:             SECMEC_EUSRIDPWD),"T5:", expectedValues[5]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;securityMechanism=" +
1:             SECMEC_USRIDONL),"T6:", expectedValues[6]);
1: 
1:         // disable as ibm142 and sun jce doesnt support DH prime of 32 bytes
1:         //assertConnectionUsingDriverManager(
1:         //    getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:         //    SECMEC_USRENCPWD),"T7:", expectedValues[7]);
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:             SECMEC_USRIDONL),"T8:", expectedValues[8]);
1:         // Test strong password substitute DRDA security mechanism 
1:         // (only works with DerbyClient driver right now)
1:         assertConnectionUsingDriverManager(
1:             getJDBCUrl("user=neelima;password=lee;securityMechanism=" +
1:             SECMEC_USRSSBPWD),"T9:", expectedValues[9]);
1:     }
1:     
1:     
1:     /**
1:      * Get connection from datasource and also set security mechanism
1:      */
0:     public void assertConnectionUsingDataSource(String[] expectedValues)
1:     {
0:         // Note: bug in jcc, throws error with null password
1:         if (usingDerbyNetClient())
1:         {
0:             assertSecurityMechanismOK("sarah",null, new Short(
0:                 SECMEC_USRIDONL),"SECMEC_USRIDONL:", expectedValues[1]);
1:         }
0:         assertSecurityMechanismOK("john","sarah", new Short(
0:             SECMEC_USRIDPWD),"SECMEC_USRIDPWD:", expectedValues[2]);
1: 
0:         // Possible bug in JCC, hence disable this test for JCC framework only
0:         // the security mechanism when set on JCC datasource does not seem to 
0:         // have an effect. JCC driver is sending a secmec of 3( USRIDPWD) to 
0:         // the server even though the security mechanism on datasource is set to 
0:         // EUSRIDPWD (9)
1:         if (usingDerbyNetClient())
1:         {
1:             // Please note: EUSRIDPWD security mechanism in DRDA uses 
1:             // Diffie-Helman for generation of shared keys. The spec specifies
1:             // the prime to use for DH which is 32 bytes and this needs to be
1:             // used as is.
1:             // Sun JCE does not support a prime of 32 bytes for Diffie Helman
1:             // nor do some older versions of IBM JCE (1.4.2).
1:             // Hence the following call to get connection might not be 
1:             // successful when client is running in a JVM where the JCE does
1:             // not support the DH (32 byte prime).
1:             // The test methods are implemented to work either way.
0:             assertSecurityMechanismOK("john","sarah",new Short(
0:                 SECMEC_EUSRIDPWD),"SECMEC_EUSRIDPWD:", expectedValues[3]);
0:             // JCC does not support USRSSBPWD security mechanism
0:             assertSecurityMechanismOK("john","sarah",new Short(
0:                 SECMEC_USRSSBPWD),"SECMEC_USRSSBPWD:", expectedValues[4]);
1:         }
1:     }
1: 
0:     public void assertSecurityMechanismOK(String user, String password,
1:         Short secmec, String msg, String expectedValue)
1:     {
1:         Connection conn;
0:         String securityMechanismProperty = "SecurityMechanism";
0:         Class[] argType = { Short.TYPE };
0:         String methodName = getSetterName(securityMechanismProperty);
0:         Object[] args = new Short[1];
0:         args[0] = secmec;
1: 
1:         DataSource ds = getDS(user,password);
1:         try {
0:             Method sh = ds.getClass().getMethod(methodName, argType);
0:             sh.invoke(ds, args);
1:             conn = ds.getConnection(user, password);
1:             conn.close();
1:             // EUSRIDPWD is supported with some jvm( version)s, not with others
0:             if (!(secmec.equals(new Short(SECMEC_EUSRIDPWD))))
1:             {
1:                 if (!expectedValue.equals("OK"))
1:                 {
1:                     fail("should have encountered an Exception");
1:                 }
1:             }
1:         }
1:         catch (SQLException sqle)
1:         {
1:             if (sqle.getSQLState().equals("08001"))
1:             {
1:                 // with null user id there's a difference between errors coming
1:                 // from driver manager vs. datasource, because the datasource
1:                 // getconnection call had to be specify user/password or the 
1:                 // junit framework pads it with 'APP'.
1:                 if (user == null)
1:                     assertSQLState08001("08001.C.7", sqle);
1:                 else
1:                     assertSQLState08001(expectedValue, sqle);
1:             }
1:             // Exceptions expected in certain cases depending on JCE used for 
1:             // running the test. So, instead of '08004' (connection refused),
1:             // or "OK", we may see 'not supported' (XJ112).
0:             else if (secmec.equals(new Short(SECMEC_EUSRIDPWD))) 
1:             {
1:                 if (!(sqle.getSQLState().equals("XJ112")))
1:                     assertSQLState(expectedValue, sqle);
1:             }
1:             else
1:                 assertSQLState(expectedValue, sqle);
1:             // for debugging, uncomment:
1:             //dumpSQLException(sqle.getNextException());
1:         }
1:         catch (Exception e)
1:         {   
1:             fail(" should not have seen an exception");
1:         }
1:     }
1: 
0:     public void assertConnectionUsingDriverManager(
1:         String dbUrl, String msg, String expectedValue)
1:     {
1:         try
1:         {
1:             TestConfiguration.getCurrent();
0:             DriverManager.getConnection(dbUrl);
1:             // Please note: EUSRIDPWD security mechanism in DRDA uses 
1:             // Diffie-Helman for generation of shared keys. 
1:             // The spec specifies the prime to use for DH which is 32 bytes and
1:             // this needs to be used as is. Sun JCE does not support a prime of
1:             // 32 bytes for Diffie Helman and some older versions of IBM JCE 
1:             // ( 1.4.2) also do not support it. Hence the following call to get 
1:             // connection might not be successful when client is running in JVM
1:             // where the JCE does not support the DH (32 byte prime)
1:             
1:             if (derby_drda_securityMechanism != null && 
1:                 !(derby_drda_securityMechanism.equals(
1:                 "ENCRYPTED_USER_AND_PASSWORD_SECURITY") &&
1:                 ((msg.indexOf("T5")>0) || (dbUrl.indexOf("9")>0))))
1:             {
1:                 if (!expectedValue.equals("OK"))
1:                     fail("should have encountered an Exception");
1:             }
1:         }
1:         catch(SQLException sqle)
1:         {
1:             // if we're trying T5, and we've got EUSRIDPWD, 08004 is also
1:             // possible, or XJ112 instead of OK.
1:             if (derby_drda_securityMechanism != null  &&
1:                 derby_drda_securityMechanism.equals(
1:                 "ENCRYPTED_USER_AND_PASSWORD_SECURITY") &&
1:                 ((msg.indexOf("T5")>0) ))
1:             {
1:                 if (!(sqle.getSQLState().equals("XJ112")))
1:                     assertSQLState(expectedValue, sqle);
1:             }
1:             else if (sqle.getSQLState().equals("08001"))
1:                 assertSQLState08001(expectedValue, sqle);
1:             else if (dbUrl.indexOf("9")>0)
1:             {
1:                 if (!(sqle.getSQLState().equals("XJ112")))
1:                     assertSQLState(expectedValue, sqle);
1:             }
1:             else 
1:             {
1:                 assertSQLState(expectedValue, sqle);
1:             }
1:             //for debugging sqles, uncomment: 
1:             // dumpSQLException(sqle.getNextException());
1:         }
1:     }
1: 
1:     /**
1:      * Test different interesting combinations of user,password, security 
1:      * mechanism for testing security mechanism upgrade logic. This test
1:      * has been added as part of DERBY-962. Two things have been fixed in
1:      * DERBY-962, affects only client behavior.
1:      *
1:      * 1)Upgrade logic should not override security mechanism if it has been 
1:      * explicitly set in connection request (either via DriverManager or 
1:      * using DataSource)
1:      *
1:      * 2)Upgrade security mechanism to a more secure one , ie preferably 
1:      * to encrypted userid and password if the JVM in which the client is 
1:      * running has support for it.
1:      * 
1:      * Details are:  
1:      * If security mechanism is not specified as part of the connection 
1:      * request, then client will do an automatic switching (upgrade) of 
1:      * security mechanism to use. The logic is as follows :
1:      * if password is available, and if the JVM in which the client is running 
1:      * supports EUSRIDPWD mechanism, in that case also, USRIDPWD security 
1:      * mechanism is used. 
1:      * if password is available, and if the JVM in which the client is running 
1:      * does not support EUSRIDPWD mechanism, in that case the client will then
1:      * default to USRIDPWD.
1:      * Also see DERBY-962 http://issues.apache.org/jira/browse/DERBY-962
1:      * <BR>
1:      * To understand which JVMs support EUSRIDPWD or not, please see class
1:      * level comments (#1)
1:      * <BR>
1:      * The expected output from this test will depend on the following
0:      * -- the client behavior (JCC 2.4, JCC2.6 or derby client).For the derby
0:      * client, the table below represents what security mechanism the client
0:      * will send to server. 
0:      * -- See class level comments (#2,#3) to understand the JCC2.6 and JCC2.4 
0:      * behavior
1:      * -- Note: in case of derby client, if no user  is specified, user 
1:      * defaults to APP.
1:      * -- Will depend on if the server has been started with property 
1:      * derby.drda.securityMechanism and to the value it is set to.  See method
1:      * (fixture) testNetworkServerSecurityMechanism() to check if server is 
1:      * using the derby.drda.securityMechanism to restrict client connections
1:      * based on security mechanism. 
1:      * 
1:      TABLE with all different combinations of userid, password, security
1:      mechanism of derby client that is covered by this testcase if test
1:      is run against IBM15 and JDK15. 
1: 
1:      IBM15 supports eusridpwd, whereas SunJDK15 doesnt support EUSRIDPWD
1: 
1:      Security Mechanisms supported by derby server and client
1:      ====================================================================
1:      |SecMec     |codepoint value|   User friendly name                  |
1:      ====================================================================
1:      |USRIDONL   |   0x04        |   USER_ONLY_SECURITY                  |
1:      |USRIDPWD   |   0x03        |   CLEAR_TEXT_PASSWORD_SECURITY        |
1:      |EUSRIDPWD  |   0x09        |   ENCRYPTED_USER_AND_PASSWORD_SECURITY|
1:      |USRSSBPWD  |   0x08        |   STRONG_PASSWORD_SUBSTITUTE_SECURITY |
1:      =====================================================================
1: 	 Explanation of columns in table. 
1: 
1: 	 a) Connection request specifies a user or not.
1: 	 Note: if no user is specified, client defaults to APP
1: 	 b) Connection request specifies a password or not
1: 	 c) Connection request specifies securityMechanism or not. the valid
1: 	 values are 4(USRIDONL), 3(USRIDPWD), 9(EUSRIDPWD) and 8(USRSSBPWD).
1: 	 d) support eusridpwd means whether this client jvm supports encrypted 
1:      userid/password security mechanism or not.  A value of Y means it 
1:      supports and N means no.
1: 	 The next three columns specify what the client sends to the server
1: 	 e) Does client send user information 
1: 	 f) Does client send password information
1: 	 g) What security mechanism value (secmec value) is sent to server.
1: 
1: 	 SecMec refers to securityMechanism.
1: 	 Y means yes, N means No,  - or blank means not specified.
1: 	 Err stands for error.
1: 	 Err(1) stands for null password not supported
1: 	 Err(2) stands for case when the JCE does not support encrypted userid and
1: 	 password security mechanism. 
1: 	 ----------------------------------------------------------------
1: 	 | url connection      | support   | Client sends to Server      |
1: 	 |User |Pwd    |secmec |eusridpwd  |User   Pwd    SecMec         |
1: 	 |#a   |#b     |#c     |#d         |#e     #f      #g            |
1: 	 |---------------------------------------------------------------|
1: 	 =================================================================
1:      |SecMec not specified on connection request                    
1: 	 =================================================================
1: 	 |Y    |Y     |-       |Y         |Y        Y       3            |
1: 	 |----------------------------------------------------------------
1: 	 |     |Y     |-       |Y         |Y        Y       3            |
1: 	 -----------------------------------------------------------------
1: 	 |Y    |      |-       |Y         |Y        N       4            |
1: 	 -----------------------------------------------------------------
1: 	 |     |      |-       |Y         |Y        N       4            |
1: 	 =================================================================
1:      |Y    |Y     |-       |N         |Y        Y       3            |
1:      |----------------------------------------------------------------
1:      |     |Y     |-       |N         |Y        Y       3            |
1:      -----------------------------------------------------------------
1:      |Y    |      |-       |N         |Y        N       4            |
1:      -----------------------------------------------------------------
1:      |     |      |-       |N         |Y        N       4            |
1:      =================================================================
1: 	 SecMec specified to 3 (clear text userid and password)
1: 	 =================================================================
1:      |Y    |Y     |3       |Y         |Y        Y       3            |
1:      |----------------------------------------------------------------
1:      |     |Y     |3       |Y         |Y        Y       3            |
1:      -----------------------------------------------------------------
1:      |Y    |      |3       |Y         |-        -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |3       |Y         |-        -       Err1         |
1:      =================================================================
1:      |Y    |Y     |3       |N         |Y        Y       3            |
1:      |----------------------------------------------------------------
1:      |     |Y     |3       |N         |Y        Y       3            |
1:      -----------------------------------------------------------------
1:      |Y    |      |3       |N         |-        -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |3       |N         |-        -       Err1         |
1:      =================================================================
1: 	 SecMec specified to 9 (encrypted userid/password)
1:      =================================================================
1:      |Y    |Y     |9       |Y         |Y        Y       9            |
1:      |----------------------------------------------------------------
1:      |     |Y     |9       |Y         |Y        Y       9            |
1:      -----------------------------------------------------------------
1:      |Y    |      |9       |Y         | -       -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |9       |Y         | -       -       Err1         |
1:      =================================================================
1:      |Y    |Y     |9       |N         | -       -       Err2         |
1:      |----------------------------------------------------------------
1:      |     |Y     |9       |N         | -       -       Err2         |
1:      -----------------------------------------------------------------
1:      |Y    |      |9       |N         | -       -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |9       |N         | -       -       Err1         |
1:      =================================================================
1: 	 SecMec specified to 4 (userid only security)
1:      =================================================================
1:      |Y    |Y     |4       |Y         |Y        N       4            |
1:      |----------------------------------------------------------------
1:      |     |Y     |4       |Y         |Y        N       4            |
1:      -----------------------------------------------------------------
1:      |Y    |      |4       |Y         |Y        N       4            |
1:      -----------------------------------------------------------------
1:      |     |      |4       |Y         |Y        N       4            |
1:      =================================================================
1:      |Y    |Y     |4       |N         |Y        N       4            |
1:      |----------------------------------------------------------------
1:      |     |Y     |4       |N         |Y        N       4            |
1:      -----------------------------------------------------------------
1:      |Y    |      |4       |N         |Y        N       4            |
1:      -----------------------------------------------------------------
1:      |     |      |4       |N         |Y        N       4            |
1:      =================================================================
1: 	 SecMec specified to 8 (strong password substitute)
1:      =================================================================
1:      |Y    |Y     |8       |Y         |Y        Y       8            |
1:      |----------------------------------------------------------------
1:      |     |Y     |8       |Y         |Y        Y       8            |
1:      -----------------------------------------------------------------
1:      |Y    |      |8       |Y         | -       -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |8       |Y         | -       -       Err1         |
1:      =================================================================
1:      |Y    |Y     |8       |N         | -       Y       8            |
1:      |----------------------------------------------------------------
1:      |     |Y     |8       |N         | -       Y       8            |
1:      -----------------------------------------------------------------
1:      |Y    |      |8       |N         | -       -       Err1         |
1:      -----------------------------------------------------------------
1:      |     |      |8       |N         | -       -       Err1         |
1:      ================================================================= 
1:      */
0:     public void assertAllCombinationsOfUserPasswordSecMecInputOK(
1:         String[] expectedValues) {
1:         // Try following combinations:
1:         // user { null, user attribute given}
1:         // password {null, pwd specified}
1:         // securityMechanism attribute specified and not specified.
1:         // try with different security mechanism values - 
1:         // {encrypted useridpassword, userid only, clear text userid &password}
1:         // try with drivermanager, try with datasource
1:         
1:         String urlAttributes = null;
1: 
1:         for (int k = 0; k < USER_ATTRIBUTE.length; k++) {
1:             for (int j = 0; j < PWD_ATTRIBUTE.length; j++) {
1:                 urlAttributes = "";
1:                 if (USER_ATTRIBUTE[k] != null)
1:                     urlAttributes += "user=" + USER_ATTRIBUTE[k] +";";
1:                 if (PWD_ATTRIBUTE[j] != null)
1:                     urlAttributes += "password=" + PWD_ATTRIBUTE[j] +";";
1:                 
0:                 // removing the last semicolon that we added here, getJDBCUrl
0:                 // will add another semicolon for jcc, which would be too many.
1:                 if (urlAttributes.length() >= 1)
1:                     urlAttributes = urlAttributes.substring(
1:                         0,urlAttributes.length()-1);
1: 
1:                 // case - do not specify securityMechanism explicitly in the 
1:                 // url get connection via driver manager and datasource.
1:                 assertConnectionUsingDriverManager(
1:                     getJDBCUrl(urlAttributes), "Test:", 
1:                     getExpectedValueFromAll(expectedValues, k, j, 4));
1:                 getDataSourceConnection(USER_ATTRIBUTE[k],PWD_ATTRIBUTE[j],
0:                     "TEST_DS("+urlAttributes+")", 
1:                     getExpectedValueFromAll(expectedValues, k, j, 4));
1: 
1:                 for (int i = 0; i < SECMEC_ATTRIBUTE.length; i++) {
1:                     // case - specify securityMechanism attribute in url
1:                     // get connection using DriverManager
1:                     assertConnectionUsingDriverManager(
1:                         getJDBCUrl(urlAttributes + ";securityMechanism=" + 
1:                             SECMEC_ATTRIBUTE[i]), "#", 
1:                             getExpectedValueFromAll(expectedValues, k, j, i));
1:                     // case - specify security mechanism on datasource
1:                     assertSecurityMechanismOK(
0:                         USER_ATTRIBUTE[k],PWD_ATTRIBUTE[j], new Short 
0:                             (SECMEC_ATTRIBUTE[i]), "TEST_DS (" + urlAttributes
1:                             + ",securityMechanism="+SECMEC_ATTRIBUTE[i]+")", 
1:                             getExpectedValueFromAll(expectedValues, k, j, i));
1:                 }
1:             }
1:         }
1:     }
1:     
1:     private String getExpectedValueFromAll(String[] expectedValues,
1:         int USER_ATTR, int PWD_ATTR, int SECMEC_ATTR)
1:     {
1:         String expectedValue;
1:         // There are 2 values each for USER_ATTR and PWD_ATTR.
1:         if (derby_drda_securityMechanism == null)
1:             return "OK";
1:         // elses
1:         // value 0 is just the name of the sec mechanism
1:         // sec mec '4' means no security mechanism specified
1:         // datasource and drivermanager calls should have same result
1:         // values 1-6 are for user 1, pwd 1
1:         if (USER_ATTR == 0 && PWD_ATTR == 0)
1:         {
1:             if (SECMEC_ATTR == 4)
1:                 expectedValue = expectedValues[1];
1:             else
1:                 expectedValue = expectedValues[2+SECMEC_ATTR];
1:         }
1:         else if (USER_ATTR == 0 && PWD_ATTR == 1)
1:         {
1:             if (SECMEC_ATTR == 4)
1:                 expectedValue = expectedValues[6];
1:             else
1:                 expectedValue = expectedValues[7+SECMEC_ATTR];
1:         }
1:         else if (USER_ATTR == 1 && PWD_ATTR == 0)
1:         {
1:             if (SECMEC_ATTR == 4)
1:                 expectedValue = expectedValues[11];
1:             else
1:                 expectedValue = expectedValues[12+SECMEC_ATTR];
1:         }
1:         else
1:         {
1:             if (SECMEC_ATTR == 4)
1:                 expectedValue = expectedValues[16];
1:             else
1:                 expectedValue = expectedValues[17+SECMEC_ATTR];
1:         }
1:         return expectedValue;
1:     }
1: 
1:     /**
1:      * Helper method to get connection from datasource and to print
1:      * the exceptions if any when getting a connection. This method 
1:      * is used in assertAllCombinationsOfUserPasswordSecMecInputOK.
1:      * For explanation of exceptions that might arise in this method,
1:      * please check assertAllCombinationsOfUserPasswordSecMecInputOK
1:      * javadoc comment.
1:      * get connection from datasource
1:      * @param user username
1:      * @param password password
0:      * @param msg message to print for testcase
1:      */
0:     public void getDataSourceConnection(
0:         String user, String password,String msg, String expectedValue)
1:     {
1:         Connection conn;
1:         DataSource ds = getDS(user, password);
1:         try {
1:             // get connection via datasource without setting securityMechanism
1:             // cannot use ds.getConnection, because junit framework will
1:             // substitute 'null' with 'APP'.
1:             conn = ds.getConnection(user, password);
1:             conn.close();
1:         }
1:         catch (SQLException sqle)
1:         {
1:             // Exceptions expected in certain case hence printing message
1:             // instead of stack traces here. 
0:             // - For cases when userid is null or password is null and by
0:             //   default JCC does not allow a null password or null userid.
0:             // - For case when JVM does not support EUSRIDPWD and JCC 2.6 
0:             //   tries to do autoswitching of security mechanism.
1:             // - For case if server doesnt accept connection with this 
1:             //   security mechanism
1:             // - For case when client driver does support USRSSBPWD security
1:             //   mechanism
1:             if ((user == null) && (sqle.getSQLState().equals("08001")))
1:                 assertSQLState08001("08001.C.7", sqle);
1:             else
1:                 assertSQLState(expectedValue, sqle);
1:             // for debugging, uncomment:
1:             //dumpSQLException(sqle.getNextException());
1:         }
1:         catch (Exception e)
1:         {
1:             fail ("should not have gotten an exception");
1:         }
1:     }
1: 
1:     /**
1:      * Dump SQLState and message for the complete nested chain of SQLException 
1:      * @param sqle SQLException whose complete chain of exceptions is
1:      * traversed and sqlstate and message is printed out
1:      */
0:     public static void dumpSQLException(SQLException sqle)
1:     {
1:         while ( sqle != null)
1:         {
1:             println("SQLSTATE("+sqle.getSQLState()+"): " + 
1:                 sqle.getMessage());
1:             sqle = sqle.getNextException();
1:         }
1:     }
1: 
1:     /**
1:      * Test a deferred connection reset. When connection pooling is done
1:      * and connection is reset, the client sends EXCSAT,ACCSEC and followed
1:      * by SECCHK and ACCRDB. Test if the security mechanism related information
1:      * is correctly reset or not. This method was added to help simulate 
1:      * regression test for DERBY-1080. It is called from testDerby1080.   
1:      * @param user username 
1:      * @param password password for connection
1:      * @param secmec security mechanism for datasource
1:      * @throws Exception
1:      */
0:     public void assertSecMecWithConnPoolingOK(
1:         String user, String password, Short secmec) throws Exception
1:     {
1:         Connection conn;
0:         String securityMechanismProperty = "SecurityMechanism";
0:         Class[] argType = { Short.TYPE };
0:         String methodName = getSetterName(securityMechanismProperty);
0:         Object[] args = new Short[1];
0:         args[0] = secmec;
1:         
1:         ConnectionPoolDataSource cpds = getCPDS(user,password);
1:         
1:         // call setSecurityMechanism with secmec.
0:         Method sh = cpds.getClass().getMethod(methodName, argType);
0:         sh.invoke(cpds, args);
1:         
1:         // simulate case when connection will be re-used by getting 
1:         // a connection, closing it and then the next call to
1:         // getConnection will re-use the previous connection.  
1:         PooledConnection pc = cpds.getPooledConnection();
1:         conn = pc.getConnection();
1:         conn.close();
1:         conn = pc.getConnection();
1:         assertConnectionOK(conn);
1:         conn.close();
1:     }
1: 
1:     /**
1:      * Test a connection by executing a sample query
1:      * @param   conn    database connection
1:      * @throws Exception if there is any error
1:      */
0:     public void assertConnectionOK(Connection conn)
0:     throws Exception
1:     {
1:         Statement stmt = conn.createStatement();
1:         ResultSet rs = null;
1:         // To test our connection, we will try to do a select from the 
1:         // system catalog tables
1:         try {
1:             rs = stmt.executeQuery("select count(*) from sys.systables");
1:             int updatecount=0;
1:             while(rs.next())
1:             {
1:                 rs.getInt(1); // assume ok if no exception, ignore result
1:                 updatecount++;
1:             }
1:             assertEquals(1,updatecount);
0:         } catch (SQLException sqle) {
0:             fail("should not have failed");
1:         }
1:         
0:         // TODO: using this with ibm15 results in 42X05 - table does not exist
0:         //assertTableRowCount("sys.systables", 1);
1:         
1:         if(rs != null)
1:             rs.close();
1:         if(stmt != null)
1:             stmt.close();
1:     }
1:     
1:     /**
1:      * This is a regression test for DERBY-1080 - where some variables required
1:      * only for the EUSRIDPWD security mechanism case were not getting reset on
1:      * connection re-use and resulting in protocol error. This also applies to
1:      * USRSSBPWD security mechanism. 
1:      * 
1:      * Read class level comments (#1) to understand what is specified by drda
1:      * spec for EUSRIDPWD.  
1:      * <br>
1:      * Encryption is done using JCE. Hence JCE support of the necessary
1:      * algorithm is required for EUSRIDPWD security mechanism to work. Thus
1:      * even though the server and client have code to support EUSRIDPWD, this
1:      * security mechanism will not work in all JVMs. 
1:      * 
1:      * JVMs where support for DH(32byte prime) is not available and thus EUSRIDPWD 
1:      * wont work are Sun JVM (versions 1.3.1, 1.4.1, 1.4.2, 1.5) and 
1:      * IBM JVM (versions 1.3.1 and some old versions of 1.4.2 (in 2004) )
1:      * 
1:      * Expected behavior for this test:
1:      * If no regression has occurred, this test should work OK, given the 
1:      * expected exception in following cases:
1:      * 1) When EUSRIDPWD is not supported in JVM the test is running, a CNFE
1:      * with initializing EncryptionManager will happen. This will happen for 
1:      * Sun JVM (versions 1.3.1, 1.4.1, 1.4.2, 1.5) and 
1:      * IBM JVM (versions 1.3.1 and some old versions of 1.4.2 (in 2004) )
0:      * For JCC clients, error message is   
0:      * "java.lang.ClassNotFoundException is caught when initializing
0:      * EncryptionManager 'IBMJCE'"
1:      * For derby client, the error message is 
1:      * "Security exception encountered, see next exception for details."
1:      * 2)If server does not accept EUSRIDPWD security mechanism from clients,then
1:      * error message will be "Connection authorization failure
1:      * occurred. Reason: security mechanism not supported"
1:      * Note: #2 can happen if server is started with derby.drda.securityMechanism
1:      * and thus restricts what security mechanisms the client can connect with.
1:      * This will happen for the test run when derby.drda.securityMechanism is
1:      * set, to a valid value other than ENCRYPTED_USER_AND_PASSWORD_SECURITY.
1:      * <br>
1:      * See testNetworkServerSecurityMechanism where this method is called to 
1:      * test for regression for DERBY-1080, and to check if server is using the
1:      * derby.drda.securityMechanism to restrict client connections based on
1:      * the security mechanism.
1:      */
0:     public void assertDerby1080Fixed(String expectedValue)
1:     {
1:         try
1:         {
1:             // simulate connection re-set using connection pooling on a pooled
1:             // datasource set security mechanism to use encrypted userid and
1:             // password.
1:             assertSecMecWithConnPoolingOK(
0:                 "peter","neelima",new Short(SECMEC_EUSRIDPWD));
1:             if (!expectedValue.equals("OK"))
1:                 fail("expected SQLException if DERBY-1080 did not regress");
1:         }
1:         catch (SQLException sqle)
1:         {
1:             // Exceptions expected in certain case hence accepting different
1:             // SQLStates.
1:             // - For cases where the jvm does not support EUSRIDPWD.
1:             // - For case if server doesnt accept connection with this security
1:             // mechanism
1:             // Please see javadoc comments for this test method for more 
1:             // details of expected exceptions.
1:             if(!(sqle.getSQLState().equals("XJ112")))
1:                 assertSQLState(expectedValue, sqle);
1:             // for debugging, uncomment:
1:             // dumpSQLException(sqle.getNextException());
1:         }
1:         catch (Exception e)
1:         {
0:             fail("did not expect an exception");
1:         }
1:     }
1: 
1:     /**
1:      * Test SECMEC_USRSSBPWD with derby BUILTIN authentication turned ON.
1:      *
1:      * We want to test a combination of USRSSBPWD with BUILTIN as password
1:      * substitute is only supported with NONE or BUILTIN Derby authentication
0:      * scheme right now (DERBY-528).
1:      * 
1:      * @throws Exception if there an unexpected error
1:      */
0:     public void assertUSRSSBPWD_with_BUILTIN(String[] expectedValues)
1:     {
1:         // Turn on Derby BUILTIN authentication and attempt connecting with
1:         // USRSSBPWD security mechanism.
1:         try
1:         {
1:             println("Turning ON Derby BUILTIN authentication");
0:             Connection conn = getConnectionWithSecMec(
0:                 "neelima", "lee", new Short(SECMEC_USRSSBPWD));
0:             if (conn == null)
0:                 return; // Exception would have been raised
1: 
1:             // Turn on BUILTIN authentication
1:             CallableStatement cs = conn.prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1: 
1:             cs.setString(1, "derby.user.neelima");
1:             cs.setString(2, "lee");
1:             cs.execute();
1: 
1:             cs.setString(1, "derby.user.APP");
1:             cs.setString(2, "APP");
1:             cs.execute();
1: 
1:             cs.setString(1, "derby.database.fullAccessUsers");
1:             cs.setString(2, "neelima,APP");
1:             cs.execute();
1: 
1:             cs.setString(1, "derby.connection.requireAuthentication");
1:             cs.setString(2, "true");
1:             cs.execute();
1: 
1:             cs.close();
1:             cs = null;
1: 
1:             conn.close();
1: 
1:             // Shutdown database for BUILTIN
1:             // authentication to take effect the next time it is
1:             // booted - derby.connection.requireAuthentication is a
1:             // static property.
1:             assertConnectionUsingDriverManager(getJDBCUrl(
1:                 "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:                 SECMEC_USRSSBPWD),"USRSSBPWD (T0):", expectedValues[1]);
1: 
1:             // Now test some connection(s) with SECMEC_USRSSBPWD
1:             // via DriverManager and Datasource
1:             assertConnectionUsingDriverManager(getJDBCUrl(
1:                 "user=neelima;password=lee;securityMechanism=" +
1:                 SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T1):", expectedValues[2]);
1:             assertSecurityMechanismOK(
0:                 "neelima","lee",new Short(SECMEC_USRSSBPWD),
1:                 "TEST_DS - USRSSBPWD + BUILTIN (T2):", expectedValues[2]);
1:             // Attempting to connect with some invalid user
1:             assertConnectionUsingDriverManager(getJDBCUrl(
1:                 "user=invalid;password=user;securityMechanism=" +
1:                 SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T3):",expectedValues[3]);
1:             assertSecurityMechanismOK(
0:                 "invalid","user",new Short(SECMEC_USRSSBPWD),
1:                 "TEST_DS - USRSSBPWD + BUILTIN (T4):", expectedValues[3]);
1: 
1:             // Prepare to turn OFF Derby BUILTIN authentication
0:             conn = getConnectionWithSecMec("neelima", "lee",
0:                 new Short(SECMEC_USRSSBPWD));
0:             if (conn == null)
0:                 return; // Exception would have been raised
1: 
1:             // Turn off BUILTIN authentication
1:             cs = conn.prepareCall(
1:             "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
1: 
1:             cs.setString(1, "derby.connection.requireAuthentication");
1:             cs.setString(2, "false");
1:             cs.execute();
1: 
1:             cs.close();
1:             cs = null;
1:             conn.close();
1: 
1:             // Shutdown 'wombat' database for BUILTIN authentication
1:             // to take effect the next time it is booted
1:             assertConnectionUsingDriverManager(getJDBCUrl(
1:                 "user=APP;password=APP;shutdown=true;securityMechanism=" +
1:                 SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T5):", expectedValues[4]);
1:         } 
1:         catch (Exception e)
1:         {
0:             fail("unexpected exception testing USRSSBPWD_with_BUILTIN()");
1:         }
1:     }
1:     
0:     public Connection getConnectionWithSecMec(String user,
0:         String password,
0:         Short secMec)
1:     {
0:         Connection conn = null;
0:         String securityMechanismProperty = "SecurityMechanism";
0:         Class[] argType = { Short.TYPE };
0:         String methodName = getSetterName(securityMechanismProperty);
0:         Object[] args = new Short[1];
0:         args[0] = secMec;
1: 
1:         DataSource ds = getDS(user, password);
1:         try {
0:             Method sh = ds.getClass().getMethod(methodName, argType);
0:             sh.invoke(ds, args);
0:             conn = ds.getConnection();
1:         }
1:         catch (SQLException sqle)
1:         {
1:             // Exceptions expected in certain cases depending on JCE used for 
0:             // running the test.
0:             dumpSQLException(sqle.getNextException());
0:             assertSQLState("11111", sqle);
1:         }
1:         catch (Exception e)
1:         {
0:             fail("did not expect exception");
1:         }
0:         return conn;
1:     }
1: 
0:     public String getJDBCUrl(String attrs) {
1:         String dbName = 
1:             TestConfiguration.getCurrent().getDefaultDatabaseName();
1:         // s is protocol, subprotocol, + dbName
1:         String s = TestConfiguration.getCurrent().getJDBCUrl(dbName);
1: 
1:         if (attrs != null)
1:             if (usingDerbyNetClient())
1:                 s = s + ";" + attrs;
1:             else
1:                 s = s + ":" + attrs + ";";
1:         return s;
1:     }
1: 
0:     public javax.sql.DataSource getDS(String user, String password)
1:     {
0:         return getDS(user,password,null);
1:     }
1: 
0:     public javax.sql.DataSource getDS(
0:         String user, String password, HashMap attrs)
1:     {
0:         if (attrs == null)
0:             attrs = new HashMap();
1:         if (user != null)
1:             attrs.put("user", user);
1:         if (password != null)
1:             attrs.put("password", password);
1:         attrs = addRequiredAttributes(attrs);
1: 
1:         DataSource ds = JDBCDataSource.getDataSource();
0:         for (Iterator i = attrs.keySet().iterator(); i.hasNext(); )
1:         {
0:             String property = (String) i.next();
1:             Object value = attrs.get(property);
1:             JDBCDataSource.setBeanProperty(ds, property, value);
1:         }
1:         return ds;
1:     }
1: 
0:     private HashMap addRequiredAttributes(HashMap attrs)
1:     {
0:         String hostName = TestConfiguration.DEFAULT_HOSTNAME;
0:         int port = TestConfiguration.DEFAULT_PORT;
0:         if (usingDerbyNet())
1:         {
0:             //attrs.put("retrieveMessagesFromServerOnGetMessage","true");
0:             attrs.put("driverType","4");
1:             /**
0:              * As per the fix of derby-410 servername should
0:              * default to localhost, but for jcc it's still needed  
1:              */
0:             attrs.put("serverName",hostName);
1:         }
1:         /** 
0:          * For a remote host of course it's also needed 
1:          */
1:         if (!hostName.equals("localhost"))
1:         {
1:             attrs.put("serverName", hostName);
0:             attrs.put("portNumber", new Integer(port));
1:         }
1:         else
1:         {
0:             attrs.put("portNumber", new Integer(port));
1:         }
1:         return attrs;
1:     }
1: 
0:     public javax.sql.ConnectionPoolDataSource getCPDS(
1:         String user, String password)
1:     {
0:         HashMap attrs = new HashMap();
1:         if (user != null)
1:             attrs.put("user", user);
1:         if (password != null)
1:             attrs.put("password", password);
1:         attrs = addRequiredAttributes(attrs);
1:         ConnectionPoolDataSource cpds = 
1:             J2EEDataSource.getConnectionPoolDataSource();
0:         for (Iterator i = attrs.keySet().iterator(); i.hasNext(); )
1:         {
0:             String property = (String) i.next();
1:             Object value = attrs.get(property);
1:             JDBCDataSource.setBeanProperty(cpds, property, value);
1:         }
1:         return cpds;
1:     }
1: 
0:     public static String getSetterName(String attribute)
1:     {
0:         return "set" + Character.toUpperCase(attribute.charAt(0)) +
0:             attribute.substring(1);
1:     }
1:     
1:     private void assertSQLState08001(String expectedValue, SQLException sqle)
1:     {
1:         if (expectedValue.equals("08001.C.7"))
1:             assertEquals("User id can not be null.", sqle.getMessage());
1:         if (expectedValue.equals("08001.C.8"))
1:             assertEquals("Password can not be null.", sqle.getMessage());
1:     }
1:     
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
0: import java.sql.Connection;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
0: import java.util.HashMap;
0: import javax.sql.DataSource;
0: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("NSSecurityMechanismTest");
1:         BaseTestSuite clientSuite =
1:             new BaseTestSuite("NSSecurityMechanismTest - client");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, Object> attrs = new HashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
1:         for (String property : attrs.keySet()) {
1:     private HashMap<String, Object> addRequiredAttributes(
1:             HashMap<String, Object> attrs)
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, Object> attrs = new HashMap<String, Object>();
/////////////////////////////////////////////////////////////////////////
1:         for (String property : attrs.keySet()) {
commit:c1192c0
/////////////////////////////////////////////////////////////////////////
1:             // shut down the currently running
1:             NetworkServerTestSetup.getNetworkServerControl().shutdown();
/////////////////////////////////////////////////////////////////////////
1:             // For debugging, to make output come to console call start() with
1:             // new PrintWriter(System.out, true) instead of null.
1:             NetworkServerTestSetup.getNetworkServerControl().start(null);
1:             NetworkServerTestSetup.waitForServerStart(
1:                     NetworkServerTestSetup.getNetworkServerControl());
commit:6524638
/////////////////////////////////////////////////////////////////////////
1:         // Before attempting to start a new server, wait for the previous
1:         // server to complete and release the server port.
1:         NetworkServerTestSetup.waitForAvailablePort();
0: 
commit:8c305e2
/////////////////////////////////////////////////////////////////////////
1:      * scheme right now (DERBY-528). Also, it doesn't work if passwords are
1:      * hashed with the configurable hash authentication scheme (DERBY-4483)
1:      * before they are stored in the database, so we'll need to disable that.
/////////////////////////////////////////////////////////////////////////
1:         // First, disable the configurable hash authentication scheme so that
1:         // passwords are stored using the old hash algorithm.
1:         cs.setString(1, "derby.authentication.builtin.algorithm");
1:         cs.setString(2, null);
1:         cs.execute();
0: 
commit:cb29d72
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
0: 
0:         TestSuite clientSuite =
0:             new TestSuite("NSSecurityMechanismTest - client");
1:         clientSuite.addTest(new NSSecurityMechanismTest(
1:         suite.addTest(TestConfiguration.clientServerDecorator(clientSuite));
0: 
1:         // Test case for embedded mode. Enable builtin authentication.
1:         suite.addTest(
1:             DatabasePropertyTestSetup.builtinAuthentication(
1:                 new NSSecurityMechanismTest("testSecurityMechanismOnEmbedded"),
1:                 new String[] { "calvin" }, "pw"));
0: 
1:         return suite;
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Test that securityMechanism=8 is ignored by the embedded driver
1:      * (DERBY-3025).
1:      */
1:     public void testSecurityMechanismOnEmbedded() throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(
1:             ds, "connectionAttributes", "securityMechanism=8");
0: 
1:         // DERBY-3025: NullPointerException or AssertFailure was thrown here
1:         Connection c = ds.getConnection("calvin", "calvinpw");
0: 
1:         c.close();
0:     }
0: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7379752
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 if (derby_drda_securityMechanism.equals(
1:                         "STRONG_PASSWORD_SUBSTITUTE_SECURITY") &&
1:                         !hasSufficientEntropy()) {
1:                     println("skipping USRSSBPWD secmec due to " +
1:                             "assumed lack of entropy");
1:                     continue;
0:                 }
/////////////////////////////////////////////////////////////////////////
1:         // Skip this USRSSBPWD on platforms that are short on entropy.
1:         if (secmec.shortValue() == SECMEC_USRSSBPWD && !hasSufficientEntropy()){
1:             return;
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (!hasSufficientEntropy() &&
1:                 dbUrl.indexOf("securityMechanism=8") != -1) {
1:             return;
0:         }
/////////////////////////////////////////////////////////////////////////
1:         // Skip this security mechanism on platforms that are short on entropy,
1:         // otherwise this test will take a very long time to complete.
1:         if (!hasSufficientEntropy()) {
1:             return;
0:         }
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Tells if the current platform is assumed to have sufficient entropy for
1:      * the strong password substitution security mechanism to run reasonably
1:      * fast.
0:      */
1:     private boolean hasSufficientEntropy() {
1:         // The ARM platform is known to suffer from too little entropy
1:         // (unless there is significant disk activity).
1:         return !getSystemProperty("os.arch").equalsIgnoreCase("arm");
0:     }
commit:530c877
/////////////////////////////////////////////////////////////////////////
1:         String hostName = TestConfiguration.getCurrent().getHostName();
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client())
commit:9dc398a
/////////////////////////////////////////////////////////////////////////
0:         AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:             public Object run(){
0:                 return System.getProperties().remove(
0:                         "derby.drda.securityMechanism");
0:             }
0:         });
/////////////////////////////////////////////////////////////////////////
1:     throws SQLException
0:         rs = stmt.executeQuery("select count(*) from sys.systables");
0:         int updatecount=0;
0:         while(rs.next())
0:         {
0:             rs.getInt(1); // assume ok if no exception, ignore result
0:             updatecount++;
0:         assertEquals(1,updatecount);
/////////////////////////////////////////////////////////////////////////
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throws Exception {
0:         println("Turning ON Derby BUILTIN authentication");
0:         Connection conn = getDataSourceConnectionWithSecMec(
0:             "neelima", "lee", new Short(SECMEC_USRSSBPWD));
0:         if (conn == null)
0:             return; // Exception would have been raised
0:         // Turn on BUILTIN authentication
0:         CallableStatement cs = conn.prepareCall(
0:         cs.setString(1, "derby.user.neelima");
0:         cs.setString(2, "lee");
0:         cs.execute();
0:         cs.setString(1, "derby.user.APP");
0:         cs.setString(2, "APP");
0:         cs.execute();
0:         cs.setString(1, "derby.database.fullAccessUsers");
0:         cs.setString(2, "neelima,APP");
0:         cs.execute();
0: 
0:         cs.setString(1, "derby.connection.requireAuthentication");
0:         cs.setString(2, "true");
0:         cs.execute();
0: 
0:         cs.close();
0:         cs = null;
0: 
0:         conn.close();
0: 
0:         // Shutdown database for BUILTIN
0:         // authentication to take effect the next time it is
0:         // booted - derby.connection.requireAuthentication is a
0:         // static property.
0:         assertConnectionUsingDriverManager(getJDBCUrl(
0:             "user=APP;password=APP;shutdown=true;securityMechanism=" +
0:             SECMEC_USRSSBPWD),"USRSSBPWD (T0):", expectedValues[1]);
0: 
0:         // Now test some connection(s) with SECMEC_USRSSBPWD
0:         // via DriverManager and Datasource
0:         assertConnectionUsingDriverManager(getJDBCUrl(
0:             "user=neelima;password=lee;securityMechanism=" +
0:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T1):", expectedValues[2]);
0:         assertSecurityMechanismOK(
0:             "neelima","lee",new Short(SECMEC_USRSSBPWD),
0:             "TEST_DS - USRSSBPWD + BUILTIN (T2):", expectedValues[2]);
0:         // Attempting to connect with some invalid user
0:         assertConnectionUsingDriverManager(getJDBCUrl(
0:             "user=invalid;password=user;securityMechanism=" +
0:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T3):",expectedValues[3]);
0:         assertSecurityMechanismOK(
0:             "invalid","user",new Short(SECMEC_USRSSBPWD),
0:             "TEST_DS - USRSSBPWD + BUILTIN (T4):", expectedValues[3]);
0: 
0:         // Prepare to turn OFF Derby BUILTIN authentication
0:         conn = getDataSourceConnectionWithSecMec("neelima", "lee",
0:             new Short(SECMEC_USRSSBPWD));
0:         if (conn == null)
0:             return; // Exception would have been raised
0: 
0:         // Turn off BUILTIN authentication
0:         cs = conn.prepareCall(
0:         "CALL SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY(?, ?)");
0: 
0:         cs.setString(1, "derby.connection.requireAuthentication");
0:         cs.setString(2, "false");
0:         cs.execute();
0: 
0:         cs.close();
0:         cs = null;
0:         conn.close();
0: 
0:         // Shutdown 'wombat' database for BUILTIN authentication
0:         // to take effect the next time it is booted
0:         assertConnectionUsingDriverManager(getJDBCUrl(
0:             "user=APP;password=APP;shutdown=true;securityMechanism=" +
0:             SECMEC_USRSSBPWD),"USRSSBPWD + BUILTIN (T5):", expectedValues[4]);
1:             throws Exception {
/////////////////////////////////////////////////////////////////////////
0:         Method sh = ds.getClass().getMethod(methodName, argType);
0:         sh.invoke(ds, args);
1:         return ds.getConnection();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ad60cd5
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.ClientConnectionPoolDataSource40;
/////////////////////////////////////////////////////////////////////////
0:                
/////////////////////////////////////////////////////////////////////////
1:         int port = TestConfiguration.getCurrent().getPort();
/////////////////////////////////////////////////////////////////////////
0: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:72f8fa8
/////////////////////////////////////////////////////////////////////////
1:             JDBCDataSource.setBeanProperty(ds,
1:                     "SecurityMechanism", secmec);
/////////////////////////////////////////////////////////////////////////
0:     {     
1:         JDBCDataSource.setBeanProperty(cpds,
1:                 "SecurityMechanism", secmec);
1:         Connection conn = pc.getConnection();
/////////////////////////////////////////////////////////////////////////
1:         JDBCDataSource.setBeanProperty(ds,
1:                 "SecurityMechanism", secMec);
/////////////////////////////////////////////////////////////////////////
commit:fa6fca2
/////////////////////////////////////////////////////////////////////////
1:     protected void tearDown() throws Exception {
1:         removeSystemProperty("derby.drda.securityMechanism");
0: 
/////////////////////////////////////////////////////////////////////////
1:         setSystemProperty("derby.drda.securityMechanism",
0:                 derby_drda_securityMechanism);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:204c040
/////////////////////////////////////////////////////////////////////////
0:             // getting a networkservercontrol to shutdown the currently running
0:             // server, before setting the next security mechanism
0:             final TestConfiguration config = TestConfiguration.getCurrent();
0:             NetworkServerControl server = new NetworkServerControl(
0:                 InetAddress.getByName(config.getHostName()),
0:                 config.getPort(),
0:                 config.getUserName(),
0:                 config.getUserPassword());
0:             // shut down the server
0:             server.shutdown();
commit:e76a6fb
/////////////////////////////////////////////////////////////////////////
1:             DriverManager.getConnection(dbUrl).close();
============================================================================