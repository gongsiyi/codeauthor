1:74d40b2: /*
1:74d40b2:  * Class org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest
1:74d40b2:  *
1:74d40b2:  * Licensed to the Apache Software Foundation (ASF) under one
1:74d40b2:  * or more contributor license agreements.  See the NOTICE file
1:74d40b2:  * distributed with this work for additional information
1:74d40b2:  * regarding copyright ownership.  The ASF licenses this file
1:74d40b2:  * to you under the Apache License, Version 2.0 (the
1:74d40b2:  * "License"); you may not use this file except in compliance
1:74d40b2:  * with the License.  You may obtain a copy of the License at
1:74d40b2:  *
1:74d40b2:  *   http://www.apache.org/licenses/LICENSE-2.0
1:74d40b2:  *
1:74d40b2:  * Unless required by applicable law or agreed to in writing,
1:74d40b2:  * software distributed under the License is distributed on an
1:74d40b2:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:74d40b2:  * KIND, either express or implied.  See the License for the
1:74d40b2:  * specific language governing permissions and limitations
1:74d40b2:  * under the License.
1:74d40b2:  */
1:74d40b2: package org.apache.derbyTesting.functionTests.tests.lang;
1:74d40b2: 
1:74d40b2: import java.sql.PreparedStatement;
1:74d40b2: import java.sql.ResultSet;
1:74d40b2: import java.sql.SQLException;
1:74d40b2: import java.sql.Statement;
1:74d40b2: import java.sql.Types;
1:74d40b2: import java.util.HashMap;
1:74d40b2: import java.util.Map;
1:74d40b2: import junit.framework.Test;
1:74d40b2: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:74d40b2: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:74d40b2: import org.apache.derbyTesting.junit.JDBC;
1:cd1bd87: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:cd1bd87: import org.apache.derbyTesting.junit.SQLUtilities;
1:74d40b2: import org.apache.derbyTesting.junit.TestConfiguration;
1:74d40b2: 
1:74d40b2: /**
1:74d40b2:  * Test the dynamic like optimization.
1:74d40b2:  *
1:74d40b2:  * <p><b>NOTE:</b> the metadata test does a bunch of likes with parameters.
1:74d40b2:  */
1:74d40b2: public class DynamicLikeOptimizationTest extends BaseJDBCTestCase {
1:74d40b2:     /** All rows in the cei table. */
1:74d40b2:     private static final Object[][] CEI_ROWS = {
1:39b3237:         { 0, "Alarms", "AlarmDisk999" },
1:39b3237:         { 1, "Alarms", "AlarmFS-usr" },
1:39b3237:         { 2, "Alarms", "AlarmPower" },
1:39b3237:         { 3, "Alert", "AlertBattery" },
1:39b3237:         { 4, "Alert", "AlertUPS" },
1:39b3237:         { 5, "Warning", "WarnIntrusion" },
1:39b3237:         { 6, "Warning", "WarnUnlockDoor" },
1:39b3237:         { 7, "Warning", "Warn%Unlock%Door" },
1:39b3237:         { 8, "Warning", "W_Unlock_Door" },
1:74d40b2:     };
1:74d40b2: 
1:74d40b2:     public DynamicLikeOptimizationTest(String name) {
1:74d40b2:         super(name);
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public static Test suite() {
1:1ae02c9:         BaseTestSuite tests =
1:1ae02c9:             new BaseTestSuite("DynamicLikeOptimizationTest");
1:1ae02c9: 
1:74d40b2:         tests.addTestSuite(DynamicLikeOptimizationTest.class);
1:74d40b2:         tests.addTest(TestConfiguration.clientServerDecorator(
1:1ae02c9:             new BaseTestSuite(DynamicLikeOptimizationTest.class)));
1:1ae02c9: 
1:74d40b2:         return new CleanDatabaseTestSetup(tests) {
1:74d40b2:             protected void decorateSQL(Statement stmt) throws SQLException {
1:74d40b2:                 stmt.executeUpdate("create table t1(c11 int)");
1:74d40b2:                 stmt.executeUpdate("insert into t1 values 1");
1:74d40b2: 
1:74d40b2:                 stmt.executeUpdate("create table test(id char(10), " +
1:74d40b2:                                    "c10 char(10), vc10 varchar(10))");
1:74d40b2:                 PreparedStatement insert = getConnection().prepareStatement(
1:74d40b2:                     "insert into test values (?,?,?)");
1:74d40b2:                 String[] values = {
1:74d40b2:                     "asdf", "asdg", "aasdf", "%foobar", "foo%bar", "foo_bar"
1:74d40b2:                 };
1:74d40b2:                 for (int i = 0; i < values.length; i++) {
1:74d40b2:                     for (int j = 1; j <= 3; j++) {
1:74d40b2:                         insert.setString(j, values[i]);
1:74d40b2:                     }
1:74d40b2:                     insert.executeUpdate();
1:74d40b2:                 }
1:74d40b2:                 insert.setString(1, "V-NULL");
1:74d40b2:                 insert.setString(2, null);
1:74d40b2:                 insert.setString(3, null);
1:74d40b2:                 insert.executeUpdate();
1:74d40b2:                 insert.setString(1, "MAX_CHAR");
1:74d40b2:                 insert.setString(2, "\uFA2D");
1:74d40b2:                 insert.setString(3, "\uFA2D");
1:74d40b2:                 insert.executeUpdate();
1:74d40b2:                 insert.close();
1:74d40b2: 
1:74d40b2:                 stmt.executeUpdate(
1:74d40b2:                     "create table likeable(match_me varchar(10), " +
1:74d40b2:                     "pattern varchar(10), esc varchar(1))");
1:74d40b2:                 stmt.executeUpdate(
1:74d40b2:                     "insert into likeable values " +
1:74d40b2:                     "('foo%bar', 'fooZ%bar', 'Z'), " +
1:74d40b2:                     "('foo%bar', '%Z%ba_', 'Z')," +
1:74d40b2:                     "('foo%bar', 'fooZ%baZ', 'Z')");
1:74d40b2: 
1:74d40b2:                 stmt.executeUpdate(
1:74d40b2:                     "create table cei(id int, name varchar(192) not null, " +
1:74d40b2:                     "source varchar(252) not null)");
1:74d40b2: 
1:74d40b2:                 PreparedStatement cei = getConnection().prepareStatement(
1:74d40b2:                     "insert into cei values (?,?,?)");
1:74d40b2:                 for (int i = 0; i < CEI_ROWS.length; i++) {
1:74d40b2:                     for (int j = 0; j < CEI_ROWS[i].length; j++) {
1:74d40b2:                         cei.setObject(j+1, CEI_ROWS[i][j]);
1:74d40b2:                     }
1:74d40b2:                     cei.executeUpdate();
1:74d40b2:                 }
1:74d40b2:                 cei.close();
1:74d40b2:             }
1:74d40b2:         };
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     protected void setUp() throws SQLException {
1:74d40b2:         getConnection().setAutoCommit(false);
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testSimpleLikePredicates() throws SQLException {
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select 1 from t1 where 'asdf' like ?");
1:74d40b2: 
1:74d40b2:         // queries that expect one row
1:74d40b2:         String[] one = { "%", "%f", "asd%", "_%", "%_", "%asdf" };
1:74d40b2:         for (int i = 0; i < one.length; i++) {
1:74d40b2:             ps.setString(1, one[i]);
1:74d40b2:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         // queries that expect empty result set
1:74d40b2:         String[] empty = { "", "%g", "_asdf", null };
1:74d40b2:         for (int i = 0; i < empty.length; i++) {
1:74d40b2:             ps.setObject(1, empty[i], Types.VARCHAR);
1:74d40b2:             JDBC.assertEmpty(ps.executeQuery());
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testEscapeSyntax() throws SQLException {
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select 1 from t1 where '%foobar' " +
1:74d40b2:                              "like 'Z%foobar' escape ?");
1:74d40b2: 
1:74d40b2:         // match: optimize to LIKE and ==
1:74d40b2:         ps.setString(1, "Z");
1:74d40b2:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2: 
1:74d40b2:         // invalid escape strings
1:74d40b2:         String[][] invalid = {
1:74d40b2:             { "raZ", "22019" },
1:74d40b2:             { "", "22019" },
1:74d40b2:             { null, "22501" },
1:74d40b2:         };
1:74d40b2:         for (int i = 0; i < invalid.length; i++) {
1:74d40b2:             ps.setObject(1, invalid[i][0], Types.VARCHAR);
1:74d40b2:             try {
1:74d40b2:                 ps.executeQuery();
1:74d40b2:                 fail();
1:74d40b2:             } catch (SQLException e) {
1:74d40b2:                 assertSQLState(invalid[i][1], e);
1:74d40b2:             }
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         // no match, wrong char
1:74d40b2:         ps.setString(1, "%");
1:74d40b2:         JDBC.assertEmpty(ps.executeQuery());
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testWildcardAsEscape() throws SQLException {
1:74d40b2:         Statement s = createStatement();
1:74d40b2:         JDBC.assertSingleValueResultSet(
1:74d40b2:             s.executeQuery(
1:74d40b2:                 "select 1 from t1 where '%foobar' like '%%foobar' escape '%'"),
1:74d40b2:             "1");
1:74d40b2:         JDBC.assertSingleValueResultSet(
1:74d40b2:             s.executeQuery(
1:74d40b2:                 "select 1 from t1 where '_foobar' like '__foobar' escape '_'"),
1:74d40b2:             "1");
1:74d40b2:         s.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testEscapeSyntax2() throws SQLException {
1:74d40b2:         PreparedStatement ps = prepareStatement(
1:74d40b2:             "select 1 from t1 where '%foobar' like ? escape ?");
1:74d40b2: 
1:74d40b2:         ps.setString(1, "Z%foobar");
1:74d40b2:         ps.setString(2, "Z");
1:74d40b2:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2: 
1:74d40b2:         ps.setString(2, "");
1:74d40b2:         try {
1:74d40b2:             ps.executeQuery();
1:74d40b2:             fail();
1:74d40b2:         } catch (SQLException e) {
1:74d40b2:             assertSQLState("22019", e);
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testEscapeSyntax3() throws SQLException {
1:74d40b2:         PreparedStatement ps = prepareStatement(
1:74d40b2:             "select 1 from t1 where '%foobar' like ? escape 'Z'");
1:74d40b2: 
1:74d40b2:         ps.setString(1, "x%foobar");
1:74d40b2:         JDBC.assertEmpty(ps.executeQuery());
1:74d40b2: 
1:74d40b2:         ps.setString(1, "Z%foobar");
1:74d40b2:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testEscapeSyntax4() throws SQLException {
1:74d40b2:         PreparedStatement ps = prepareStatement(
1:74d40b2:             "select 1 from t1 where '%foobar' like ? escape '$'");
1:74d40b2: 
1:74d40b2:         ps.setString(1, "$%f%bar");
1:74d40b2:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testEscapeSyntax5() throws SQLException {
1:74d40b2:         PreparedStatement ps = prepareStatement(
1:74d40b2:             "select 1 from t1 where 'Z%foobar' like ? escape 'Z'");
1:74d40b2: 
1:74d40b2:         ps.setString(1, "ZZZ%foo%a_");
1:74d40b2:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testLikeWithHighestValidCharacter() throws SQLException {
1:74d40b2:         // \uFA2D - the highest valid character according to
1:74d40b2:         // Character.isDefined() of JDK 1.4;
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select 1 from t1 where '\uFA2D' like ?");
1:74d40b2: 
1:74d40b2:         String[] match = { "%", "_", "\uFA2D" };
1:74d40b2:         for (int i = 0; i < match.length; i++) {
1:74d40b2:             ps.setString(1, match[i]);
1:74d40b2:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         ps.setString(1, "");
1:74d40b2:         JDBC.assertEmpty(ps.executeQuery());
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testGeneratedPredicatesCHAR() throws SQLException {
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select id from test where c10 like ?");
1:74d40b2:         String[][][] expected = {
1:74d40b2:             /* null */ { },
1:74d40b2:             /* 1 */ { },
1:74d40b2:             /* "" */ { },
1:74d40b2:             /* % */  { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* %f */ { },
1:74d40b2:             /* %g */ { },
1:74d40b2:             /* asd% */ { {"asdf"},{"asdg"} },
1:74d40b2:             /* _% */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* %_ */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* _asdf */ { },
1:74d40b2:             /* _asdf % */ { {"aasdf"} },
1:74d40b2:             /* %asdf */ { },
1:74d40b2:         };
1:74d40b2:         testGeneratedPredicates(ps, expected);
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testGeneratedPredicatesVARCHAR() throws SQLException {
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select id from test where vc10 like ?");
1:74d40b2:         String[][][] expected = {
1:74d40b2:             /* null */ { },
1:74d40b2:             /* 1 */ { },
1:74d40b2:             /* "" */ { },
1:74d40b2:             /* % */  { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* %f */ { {"asdf"}, {"aasdf"} },
1:74d40b2:             /* %g */ { {"asdg"} },
1:74d40b2:             /* asd% */ { {"asdf"},{"asdg"} },
1:74d40b2:             /* _% */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* %_ */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:74d40b2:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:74d40b2:             /* _asdf */ { {"aasdf"} },
1:74d40b2:             /* _asdf % */ { },
1:74d40b2:             /* %asdf */ { {"asdf"}, {"aasdf"} },
1:74d40b2:         };
1:74d40b2:         testGeneratedPredicates(ps, expected);
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     /**
1:74d40b2:      * Helper method for <code>testGeneratedPredicates*</code>. Executes a
1:74d40b2:      * prepared statement with different parameter values and compares result
1:74d40b2:      * to an array of expected rows.
1:74d40b2:      *
1:74d40b2:      * @param ps the prepared statement to execute
1:74d40b2:      * @param rows array of expected rows to be returned for the different
1:74d40b2:      * executions
1:74d40b2:      */
1:74d40b2:     private void testGeneratedPredicates(PreparedStatement ps,
1:74d40b2:                                          String[][][] rows)
1:74d40b2:             throws SQLException {
1:74d40b2:         Object[] args = {
1:39b3237:             null, 1, "", "%", "%f", "%g", "asd%", "_%", "%_",
1:74d40b2:             "_asdf", "_asdf %", "%asdf"
1:74d40b2:         };
1:74d40b2:         assertEquals(args.length, rows.length);
1:74d40b2: 
1:74d40b2:         for (int i = 0; i < args.length; i++) {
1:74d40b2:             if (args[i] == null) {
1:74d40b2:                 ps.setString(1, null);
1:74d40b2:             } else {
1:74d40b2:                 ps.setObject(1, args[i]);
1:74d40b2:             }
1:74d40b2:             JDBC.assertUnorderedResultSet(ps.executeQuery(), rows[i]);
1:74d40b2:         }
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     public void testStringAndPatternAndEscapeFromTable() throws SQLException {
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select match_me from likeable " +
1:74d40b2:                              "where match_me like pattern escape esc");
1:74d40b2: 
1:74d40b2:         // In embedded, the first two should go fine, third one should fail
1:74d40b2:         // because the escape character is not followed by _ or %. In
1:74d40b2:         // client/server mode, executeQuery() should fail because of
1:74d40b2:         // pre-fetching. (This test only works correctly if the rows are
1:74d40b2:         // returned in the insert order, which happens to be the case but is
1:74d40b2:         // not guaranteed.)
1:74d40b2:         ResultSet rs = null;
1:74d40b2:         boolean twoSuccessful = false;
1:74d40b2:         try {
1:74d40b2:             rs = ps.executeQuery();
1:74d40b2:             assertTrue(rs.next());
1:74d40b2:             assertTrue(rs.next());
1:74d40b2:             twoSuccessful = true;
1:74d40b2:             rs.next();
1:74d40b2:             fail();
1:74d40b2:         } catch (SQLException e) {
1:74d40b2:             assertSQLState("22025", e);
1:74d40b2:             assertTrue((usingEmbedded() && twoSuccessful) ||
1:74d40b2:                        (usingDerbyNetClient() && (rs == null)));
1:74d40b2:         }
1:74d40b2:         if (rs != null) {
1:74d40b2:             rs.close();
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         PreparedStatement del = prepareStatement("delete from likeable");
1:74d40b2:         assertEquals(3, del.executeUpdate());
1:74d40b2: 
1:74d40b2:         PreparedStatement ins = prepareStatement("insert into likeable " +
1:74d40b2:                                                  "values (?, ?, ?)");
1:74d40b2:         ins.setString(1, "foo%bar");
1:74d40b2:         ins.setString(2, "foo%bar");
1:74d40b2:         ins.setString(3, null);
1:74d40b2:         ins.executeUpdate();
1:74d40b2: 
1:74d40b2:         try {
1:74d40b2:             JDBC.assertDrainResults(ps.executeQuery());
1:74d40b2:             fail();
1:74d40b2:         } catch (SQLException e) {
1:74d40b2:             assertSQLState("22501", e);
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         assertEquals(1, del.executeUpdate());
1:74d40b2: 
1:74d40b2:         ins.setString(3, "");
1:74d40b2:         ins.executeUpdate();
1:74d40b2: 
1:74d40b2:         try {
1:74d40b2:             JDBC.assertDrainResults(ps.executeQuery());
1:74d40b2:             fail();
1:74d40b2:         } catch (SQLException e) {
1:74d40b2:             assertSQLState("22019", e);
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:         del.close();
1:74d40b2:         ins.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     /**
1:74d40b2:      * Test defect 6002/6039.
1:74d40b2:      */
1:74d40b2:     public void testEscapeWithBackslash() throws SQLException {
1:74d40b2:         PreparedStatement ps = prepareStatement(
1:74d40b2:             "select id, name, source from cei where " +
1:74d40b2:             "(name LIKE ? escape '\\') and (source like ? escape '\\') " +
1:74d40b2:             "order by source asc, name asc");
1:74d40b2: 
1:3f5c48a:         HashMap<String[], Object[][]> inputOutput =
1:3f5c48a:                 new HashMap<String[], Object[][]>();
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"%", "%"},
1:74d40b2:             new Object[][] {
1:74d40b2:                 CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2], CEI_ROWS[3], CEI_ROWS[4],
1:74d40b2:                 CEI_ROWS[8], CEI_ROWS[7], CEI_ROWS[5], CEI_ROWS[6]
1:74d40b2:             });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Alarms", "AlarmDisk%"},
1:74d40b2:             new Object[][] { CEI_ROWS[0] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"A%", "%"},
1:74d40b2:             new Object[][] {
1:74d40b2:                 CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2], CEI_ROWS[3], CEI_ROWS[4],
1:74d40b2:             });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"%", "___rm%"},
1:74d40b2:             new Object[][] { CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Warning", "%oor"},
1:74d40b2:             new Object[][] { CEI_ROWS[8], CEI_ROWS[7], CEI_ROWS[6] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Warning", "Warn\\%Unlock\\%Door"},
1:74d40b2:             new Object[][] { CEI_ROWS[7] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Warning", "%\\%Unlo%"},
1:74d40b2:             new Object[][] { CEI_ROWS[7] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Warning", "W\\_Unloc%"},
1:74d40b2:             new Object[][] { CEI_ROWS[8] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"Warning", "_\\_Unlock\\_Door"},
1:74d40b2:             new Object[][] { CEI_ROWS[8] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"W%", "Warn\\%Unlock\\%Door"},
1:74d40b2:             new Object[][] { CEI_ROWS[7] });
1:74d40b2:         inputOutput.put(
1:74d40b2:             new String[] {"%ing", "W\\_Unlock\\_%Door"},
1:74d40b2:             new Object[][] { CEI_ROWS[8] });
1:74d40b2:         inputOutput.put(new String[] {"Bogus", "Name"}, new Object[][] {});
1:74d40b2: 
1:3f5c48a:         for (Map.Entry<String[], Object[][]> entry : inputOutput.entrySet()) {
1:3f5c48a:             String[] args = entry.getKey();
1:3f5c48a:             Object[][] rows = entry.getValue();
1:74d40b2:             ps.setObject(1, args[0]);
1:74d40b2:             ps.setObject(2, args[1]);
1:74d40b2:             JDBC.assertFullResultSet(ps.executeQuery(), rows, false);
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     /**
1:74d40b2:      * Test that % matches tab characters (DERBY-1262).
1:74d40b2:      */
1:74d40b2:     public void testTabs() throws SQLException {
1:74d40b2:         Statement s = createStatement();
1:74d40b2:         s.executeUpdate("insert into test values " +
1:74d40b2:                         "('asd\tp', 'asd\tp', 'asd\tp'), " +
1:74d40b2:                         "('ase\tp', 'ase\tg', 'ase\tg')");
1:74d40b2: 
1:74d40b2:         String[][] expected = { {"asdf"}, {"asdg"}, {"asd\tp"} };
1:74d40b2:         JDBC.assertUnorderedResultSet(
1:74d40b2:             s.executeQuery("select c10 from test where c10 like 'asd%'"),
1:74d40b2:             expected);
1:74d40b2: 
1:74d40b2:         PreparedStatement ps =
1:74d40b2:             prepareStatement("select c10 from test where c10 like ?");
1:74d40b2:         ps.setString(1, "asd%");
1:74d40b2:         JDBC.assertUnorderedResultSet(ps.executeQuery(), expected);
1:74d40b2: 
1:74d40b2:         s.close();
1:74d40b2:         ps.close();
1:74d40b2:     }
1:74d40b2: 
1:74d40b2:     /**
1:74d40b2:      * Test that it is possible to escape an escape character that is before
1:74d40b2:      * the first wildcard (% or _) in the pattern (DERBY-1386).
1:74d40b2:      */
1:74d40b2:     public void testEscapedEscapeCharacterPrecedingFirstWildcard()
1:74d40b2:             throws SQLException {
1:74d40b2:         Statement s = createStatement();
1:74d40b2:         s.executeUpdate("insert into test values " +
1:74d40b2:                         "('abc#def', 'abc#def', 'abc#def'), " +
1:74d40b2:                         "('abc\\def', 'abc\\def', 'abc\\def')");
1:74d40b2: 
1:74d40b2:         PreparedStatement[] ps = {
1:74d40b2:             prepareStatement("select id from test where c10 like ? escape ?"),
1:74d40b2:             prepareStatement("select id from test where vc10 like ? escape ?")
1:74d40b2:         };
1:74d40b2: 
1:74d40b2:         String[][] inputOutput = {
1:74d40b2:             { "abc##%", "#", "abc#def", "abc#def" },
1:74d40b2:             { "abc\\\\%", "\\", "abc\\def", "abc\\def" },
1:74d40b2:             { "abc##_ef", "#", null, "abc#def" },
1:74d40b2:             { "abc\\\\_ef", "\\", null, "abc\\def" },
1:74d40b2:         };
1:74d40b2: 
1:74d40b2:         for (int i = 0; i < inputOutput.length; i++) {
1:74d40b2:             for (int j = 0; j < ps.length; j++) {
1:74d40b2:                 ps[j].setString(1, inputOutput[i][0]);
1:74d40b2:                 ps[j].setString(2, inputOutput[i][1]);
1:74d40b2:                 ResultSet rs = ps[j].executeQuery();
1:74d40b2:                 String expected = inputOutput[i][2+j];
1:74d40b2:                 if (expected == null) {
1:74d40b2:                     JDBC.assertEmpty(rs);
1:74d40b2:                 } else {
1:74d40b2:                     JDBC.assertSingleValueResultSet(rs, expected);
1:74d40b2:                 }
1:74d40b2:             }
1:74d40b2:         }
1:74d40b2: 
1:74d40b2:         s.close();
1:74d40b2:         ps[0].close();
1:74d40b2:         ps[1].close();
1:74d40b2:     }
1:cd1bd87: 
1:cd1bd87:     /**
1:cd1bd87:      * Test that dynamic like optimization is performed. That is, the LIKE
1:cd1bd87:      * predicate is rewritten to &gt;=, &lt; and LIKE.
1:cd1bd87:      */
1:cd1bd87:     public void testDynamicLikeOptimization() throws SQLException {
1:cd1bd87:         Statement s = createStatement();
1:f148f1f:         ResultSet rs = s.executeQuery( 
1:f148f1f:           		"VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.database.collation')");
1:f148f1f:         if (rs.next()){
1:f148f1f:         	if (rs.getString(1).equals("TERRITORY_BASED")) {
1:f148f1f:         		rs.close();
1:f148f1f:         		s.close();
1:f148f1f:         		return;
1:74d40b2:         	}
1:f148f1f:         }
1:cd1bd87:         s.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:cd1bd87:         PreparedStatement ps =
1:cd1bd87:             prepareStatement("select id from test where vc10 like ?");
1:cd1bd87:         ps.setString(1, "%");
1:cd1bd87:         JDBC.assertDrainResults(ps.executeQuery());
1:cd1bd87:         RuntimeStatisticsParser p = SQLUtilities.getRuntimeStatisticsParser(s);
1:cd1bd87:         assertTrue(p.hasGreaterThanOrEqualQualifier());
1:cd1bd87:         assertTrue(p.hasLessThanQualifier());
1:cd1bd87:         s.close();
1:cd1bd87:         ps.close();
1:cd1bd87:     }
1:cd1bd87: 
1:cd1bd87:     public void testCast() throws SQLException {
1:cd1bd87:         Statement s = createStatement();
1:cd1bd87:         JDBC.assertSingleValueResultSet(
1:cd1bd87:             s.executeQuery("select 1 from t1 where 'asdf' like " +
1:cd1bd87:                            "cast('%f' as varchar(2))"),
1:cd1bd87:             "1");
1:cd1bd87:         JDBC.assertEmpty(s.executeQuery("select 1 from t1 where 'asdf' like " +
1:cd1bd87:                                         "cast(null as char)"));
1:cd1bd87:         JDBC.assertSingleValueResultSet(
1:cd1bd87:             s.executeQuery("select 1 from t1 where '%foobar' like 'Z%foobar' " +
1:cd1bd87:                            "escape cast('Z' as varchar(1))"),
1:cd1bd87:             "1");
1:cd1bd87:         // quoted values clause should not match anything
1:cd1bd87:         JDBC.assertEmpty(s.executeQuery(
1:cd1bd87:                 "select vc10 from test where vc10 like " +
1:cd1bd87:                 "'values cast(null as varchar(1))'"));
1:cd1bd87:         JDBC.assertEmpty(s.executeQuery(
1:cd1bd87:                 "select id from test where c10 like " +
1:cd1bd87:                 "cast ('%f' as varchar(2))"));
1:cd1bd87:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:cd1bd87:                 "select id from test where vc10 like " +
1:cd1bd87:                 "cast ('%f' as varchar(2))"),
1:cd1bd87:                 new String[][] { {"asdf"}, {"aasdf"} });
1:cd1bd87:         s.close();
1:cd1bd87:     }
1:f148f1f: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:         { 0, "Alarms", "AlarmDisk999" },
1:         { 1, "Alarms", "AlarmFS-usr" },
1:         { 2, "Alarms", "AlarmPower" },
1:         { 3, "Alert", "AlertBattery" },
1:         { 4, "Alert", "AlertUPS" },
1:         { 5, "Warning", "WarnIntrusion" },
1:         { 6, "Warning", "WarnUnlockDoor" },
1:         { 7, "Warning", "Warn%Unlock%Door" },
1:         { 8, "Warning", "W_Unlock_Door" },
/////////////////////////////////////////////////////////////////////////
1:             null, 1, "", "%", "%f", "%g", "asd%", "_%", "%_",
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite tests =
1:             new BaseTestSuite("DynamicLikeOptimizationTest");
1: 
1:             new BaseTestSuite(DynamicLikeOptimizationTest.class)));
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String[], Object[][]> inputOutput =
1:                 new HashMap<String[], Object[][]>();
/////////////////////////////////////////////////////////////////////////
1:         for (Map.Entry<String[], Object[][]> entry : inputOutput.entrySet()) {
1:             String[] args = entry.getKey();
1:             Object[][] rows = entry.getValue();
commit:cd1bd87
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that dynamic like optimization is performed. That is, the LIKE
1:      * predicate is rewritten to &gt;=, &lt; and LIKE.
1:      */
1:     public void testDynamicLikeOptimization() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:         PreparedStatement ps =
1:             prepareStatement("select id from test where vc10 like ?");
1:         ps.setString(1, "%");
1:         JDBC.assertDrainResults(ps.executeQuery());
1:         RuntimeStatisticsParser p = SQLUtilities.getRuntimeStatisticsParser(s);
1:         assertTrue(p.hasGreaterThanOrEqualQualifier());
1:         assertTrue(p.hasLessThanQualifier());
1:         s.close();
1:         ps.close();
1:     }
1: 
1:     public void testCast() throws SQLException {
1:         Statement s = createStatement();
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery("select 1 from t1 where 'asdf' like " +
1:                            "cast('%f' as varchar(2))"),
1:             "1");
1:         JDBC.assertEmpty(s.executeQuery("select 1 from t1 where 'asdf' like " +
1:                                         "cast(null as char)"));
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery("select 1 from t1 where '%foobar' like 'Z%foobar' " +
1:                            "escape cast('Z' as varchar(1))"),
1:             "1");
1:         // quoted values clause should not match anything
1:         JDBC.assertEmpty(s.executeQuery(
1:                 "select vc10 from test where vc10 like " +
1:                 "'values cast(null as varchar(1))'"));
1:         JDBC.assertEmpty(s.executeQuery(
1:                 "select id from test where c10 like " +
1:                 "cast ('%f' as varchar(2))"));
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select id from test where vc10 like " +
1:                 "cast ('%f' as varchar(2))"),
1:                 new String[][] { {"asdf"}, {"aasdf"} });
1:         s.close();
1:     }
commit:74d40b2
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.DynamicLikeOptimizationTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import java.util.HashMap;
0: import java.util.Iterator;
1: import java.util.Map;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test the dynamic like optimization.
1:  *
1:  * <p><b>NOTE:</b> the metadata test does a bunch of likes with parameters.
1:  */
1: public class DynamicLikeOptimizationTest extends BaseJDBCTestCase {
1:     /** All rows in the cei table. */
1:     private static final Object[][] CEI_ROWS = {
0:         { new Integer(0), "Alarms", "AlarmDisk999" },
0:         { new Integer(1), "Alarms", "AlarmFS-usr" },
0:         { new Integer(2), "Alarms", "AlarmPower" },
0:         { new Integer(3), "Alert", "AlertBattery" },
0:         { new Integer(4), "Alert", "AlertUPS" },
0:         { new Integer(5), "Warning", "WarnIntrusion" },
0:         { new Integer(6), "Warning", "WarnUnlockDoor" },
0:         { new Integer(7), "Warning", "Warn%Unlock%Door" },
0:         { new Integer(8), "Warning", "W_Unlock_Door" },
1:     };
1: 
1:     public DynamicLikeOptimizationTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite tests = new TestSuite("DynamicLikeOptimizationTest");
1:         tests.addTestSuite(DynamicLikeOptimizationTest.class);
1:         tests.addTest(TestConfiguration.clientServerDecorator(
0:                           new TestSuite(DynamicLikeOptimizationTest.class)));
1:         return new CleanDatabaseTestSetup(tests) {
1:             protected void decorateSQL(Statement stmt) throws SQLException {
1:                 stmt.executeUpdate("create table t1(c11 int)");
1:                 stmt.executeUpdate("insert into t1 values 1");
1: 
1:                 stmt.executeUpdate("create table test(id char(10), " +
1:                                    "c10 char(10), vc10 varchar(10))");
1:                 PreparedStatement insert = getConnection().prepareStatement(
1:                     "insert into test values (?,?,?)");
1:                 String[] values = {
1:                     "asdf", "asdg", "aasdf", "%foobar", "foo%bar", "foo_bar"
1:                 };
1:                 for (int i = 0; i < values.length; i++) {
1:                     for (int j = 1; j <= 3; j++) {
1:                         insert.setString(j, values[i]);
1:                     }
1:                     insert.executeUpdate();
1:                 }
1:                 insert.setString(1, "V-NULL");
1:                 insert.setString(2, null);
1:                 insert.setString(3, null);
1:                 insert.executeUpdate();
1:                 insert.setString(1, "MAX_CHAR");
1:                 insert.setString(2, "\uFA2D");
1:                 insert.setString(3, "\uFA2D");
1:                 insert.executeUpdate();
1:                 insert.close();
1: 
1:                 stmt.executeUpdate(
1:                     "create table likeable(match_me varchar(10), " +
1:                     "pattern varchar(10), esc varchar(1))");
1:                 stmt.executeUpdate(
1:                     "insert into likeable values " +
1:                     "('foo%bar', 'fooZ%bar', 'Z'), " +
1:                     "('foo%bar', '%Z%ba_', 'Z')," +
1:                     "('foo%bar', 'fooZ%baZ', 'Z')");
1: 
1:                 stmt.executeUpdate(
1:                     "create table cei(id int, name varchar(192) not null, " +
1:                     "source varchar(252) not null)");
1: 
1:                 PreparedStatement cei = getConnection().prepareStatement(
1:                     "insert into cei values (?,?,?)");
1:                 for (int i = 0; i < CEI_ROWS.length; i++) {
1:                     for (int j = 0; j < CEI_ROWS[i].length; j++) {
1:                         cei.setObject(j+1, CEI_ROWS[i][j]);
1:                     }
1:                     cei.executeUpdate();
1:                 }
1:                 cei.close();
1:             }
1:         };
1:     }
1: 
1:     protected void setUp() throws SQLException {
1:         getConnection().setAutoCommit(false);
1:     }
1: 
1:     public void testSimpleLikePredicates() throws SQLException {
1:         PreparedStatement ps =
1:             prepareStatement("select 1 from t1 where 'asdf' like ?");
1: 
1:         // queries that expect one row
1:         String[] one = { "%", "%f", "asd%", "_%", "%_", "%asdf" };
1:         for (int i = 0; i < one.length; i++) {
1:             ps.setString(1, one[i]);
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         }
1: 
1:         // queries that expect empty result set
1:         String[] empty = { "", "%g", "_asdf", null };
1:         for (int i = 0; i < empty.length; i++) {
1:             ps.setObject(1, empty[i], Types.VARCHAR);
1:             JDBC.assertEmpty(ps.executeQuery());
1:         }
1: 
1:         ps.close();
1:     }
1: 
1:     public void testEscapeSyntax() throws SQLException {
1:         PreparedStatement ps =
1:             prepareStatement("select 1 from t1 where '%foobar' " +
1:                              "like 'Z%foobar' escape ?");
1: 
1:         // match: optimize to LIKE and ==
1:         ps.setString(1, "Z");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         // invalid escape strings
1:         String[][] invalid = {
1:             { "raZ", "22019" },
1:             { "", "22019" },
1:             { null, "22501" },
1:         };
1:         for (int i = 0; i < invalid.length; i++) {
1:             ps.setObject(1, invalid[i][0], Types.VARCHAR);
1:             try {
1:                 ps.executeQuery();
1:                 fail();
1:             } catch (SQLException e) {
1:                 assertSQLState(invalid[i][1], e);
1:             }
1:         }
1: 
1:         // no match, wrong char
1:         ps.setString(1, "%");
1:         JDBC.assertEmpty(ps.executeQuery());
1: 
1:         ps.close();
1:     }
1: 
1:     public void testWildcardAsEscape() throws SQLException {
1:         Statement s = createStatement();
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery(
1:                 "select 1 from t1 where '%foobar' like '%%foobar' escape '%'"),
1:             "1");
1:         JDBC.assertSingleValueResultSet(
1:             s.executeQuery(
1:                 "select 1 from t1 where '_foobar' like '__foobar' escape '_'"),
1:             "1");
1:         s.close();
1:     }
1: 
1:     public void testEscapeSyntax2() throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:             "select 1 from t1 where '%foobar' like ? escape ?");
1: 
1:         ps.setString(1, "Z%foobar");
1:         ps.setString(2, "Z");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         ps.setString(2, "");
1:         try {
1:             ps.executeQuery();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22019", e);
1:         }
1: 
1:         ps.close();
1:     }
1: 
1:     public void testEscapeSyntax3() throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:             "select 1 from t1 where '%foobar' like ? escape 'Z'");
1: 
1:         ps.setString(1, "x%foobar");
1:         JDBC.assertEmpty(ps.executeQuery());
1: 
1:         ps.setString(1, "Z%foobar");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         ps.close();
1:     }
1: 
1:     public void testEscapeSyntax4() throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:             "select 1 from t1 where '%foobar' like ? escape '$'");
1: 
1:         ps.setString(1, "$%f%bar");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         ps.close();
1:     }
1: 
1:     public void testEscapeSyntax5() throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:             "select 1 from t1 where 'Z%foobar' like ? escape 'Z'");
1: 
1:         ps.setString(1, "ZZZ%foo%a_");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         ps.close();
1:     }
1: 
1:     public void testLikeWithHighestValidCharacter() throws SQLException {
1:         // \uFA2D - the highest valid character according to
1:         // Character.isDefined() of JDK 1.4;
1:         PreparedStatement ps =
1:             prepareStatement("select 1 from t1 where '\uFA2D' like ?");
1: 
1:         String[] match = { "%", "_", "\uFA2D" };
1:         for (int i = 0; i < match.length; i++) {
1:             ps.setString(1, match[i]);
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         }
1: 
1:         ps.setString(1, "");
1:         JDBC.assertEmpty(ps.executeQuery());
1: 
1:         ps.close();
1:     }
1: 
1:     public void testGeneratedPredicatesCHAR() throws SQLException {
1:         PreparedStatement ps =
1:             prepareStatement("select id from test where c10 like ?");
1:         String[][][] expected = {
1:             /* null */ { },
1:             /* 1 */ { },
1:             /* "" */ { },
1:             /* % */  { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* %f */ { },
1:             /* %g */ { },
1:             /* asd% */ { {"asdf"},{"asdg"} },
1:             /* _% */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* %_ */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* _asdf */ { },
1:             /* _asdf % */ { {"aasdf"} },
1:             /* %asdf */ { },
1:         };
1:         testGeneratedPredicates(ps, expected);
1:     }
1: 
1:     public void testGeneratedPredicatesVARCHAR() throws SQLException {
1:         PreparedStatement ps =
1:             prepareStatement("select id from test where vc10 like ?");
1:         String[][][] expected = {
1:             /* null */ { },
1:             /* 1 */ { },
1:             /* "" */ { },
1:             /* % */  { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* %f */ { {"asdf"}, {"aasdf"} },
1:             /* %g */ { {"asdg"} },
1:             /* asd% */ { {"asdf"},{"asdg"} },
1:             /* _% */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* %_ */ { {"MAX_CHAR"}, {"asdf"}, {"asdg"}, {"aasdf"},
1:                        {"%foobar"}, {"foo%bar"}, {"foo_bar"} },
1:             /* _asdf */ { {"aasdf"} },
1:             /* _asdf % */ { },
1:             /* %asdf */ { {"asdf"}, {"aasdf"} },
1:         };
1:         testGeneratedPredicates(ps, expected);
1:     }
1: 
1:     /**
1:      * Helper method for <code>testGeneratedPredicates*</code>. Executes a
1:      * prepared statement with different parameter values and compares result
1:      * to an array of expected rows.
1:      *
1:      * @param ps the prepared statement to execute
1:      * @param rows array of expected rows to be returned for the different
1:      * executions
1:      */
1:     private void testGeneratedPredicates(PreparedStatement ps,
1:                                          String[][][] rows)
1:             throws SQLException {
1:         Object[] args = {
0:             null, new Integer(1), "", "%", "%f", "%g", "asd%", "_%", "%_",
1:             "_asdf", "_asdf %", "%asdf"
1:         };
1:         assertEquals(args.length, rows.length);
1: 
1:         for (int i = 0; i < args.length; i++) {
1:             if (args[i] == null) {
1:                 ps.setString(1, null);
1:             } else {
1:                 ps.setObject(1, args[i]);
1:             }
1:             JDBC.assertUnorderedResultSet(ps.executeQuery(), rows[i]);
1:         }
1:         ps.close();
1:     }
1: 
1:     public void testStringAndPatternAndEscapeFromTable() throws SQLException {
1:         PreparedStatement ps =
1:             prepareStatement("select match_me from likeable " +
1:                              "where match_me like pattern escape esc");
1: 
1:         // In embedded, the first two should go fine, third one should fail
1:         // because the escape character is not followed by _ or %. In
1:         // client/server mode, executeQuery() should fail because of
1:         // pre-fetching. (This test only works correctly if the rows are
1:         // returned in the insert order, which happens to be the case but is
1:         // not guaranteed.)
1:         ResultSet rs = null;
1:         boolean twoSuccessful = false;
1:         try {
1:             rs = ps.executeQuery();
1:             assertTrue(rs.next());
1:             assertTrue(rs.next());
1:             twoSuccessful = true;
1:             rs.next();
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22025", e);
1:             assertTrue((usingEmbedded() && twoSuccessful) ||
1:                        (usingDerbyNetClient() && (rs == null)));
1:         }
1:         if (rs != null) {
1:             rs.close();
1:         }
1: 
1:         PreparedStatement del = prepareStatement("delete from likeable");
1:         assertEquals(3, del.executeUpdate());
1: 
1:         PreparedStatement ins = prepareStatement("insert into likeable " +
1:                                                  "values (?, ?, ?)");
1:         ins.setString(1, "foo%bar");
1:         ins.setString(2, "foo%bar");
1:         ins.setString(3, null);
1:         ins.executeUpdate();
1: 
1:         try {
1:             JDBC.assertDrainResults(ps.executeQuery());
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22501", e);
1:         }
1: 
1:         assertEquals(1, del.executeUpdate());
1: 
1:         ins.setString(3, "");
1:         ins.executeUpdate();
1: 
1:         try {
1:             JDBC.assertDrainResults(ps.executeQuery());
1:             fail();
1:         } catch (SQLException e) {
1:             assertSQLState("22019", e);
1:         }
1: 
1:         ps.close();
1:         del.close();
1:         ins.close();
1:     }
1: 
1:     /**
1:      * Test defect 6002/6039.
1:      */
1:     public void testEscapeWithBackslash() throws SQLException {
1:         PreparedStatement ps = prepareStatement(
1:             "select id, name, source from cei where " +
1:             "(name LIKE ? escape '\\') and (source like ? escape '\\') " +
1:             "order by source asc, name asc");
1: 
0:         HashMap inputOutput = new HashMap();
1:         inputOutput.put(
1:             new String[] {"%", "%"},
1:             new Object[][] {
1:                 CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2], CEI_ROWS[3], CEI_ROWS[4],
1:                 CEI_ROWS[8], CEI_ROWS[7], CEI_ROWS[5], CEI_ROWS[6]
1:             });
1:         inputOutput.put(
1:             new String[] {"Alarms", "AlarmDisk%"},
1:             new Object[][] { CEI_ROWS[0] });
1:         inputOutput.put(
1:             new String[] {"A%", "%"},
1:             new Object[][] {
1:                 CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2], CEI_ROWS[3], CEI_ROWS[4],
1:             });
1:         inputOutput.put(
1:             new String[] {"%", "___rm%"},
1:             new Object[][] { CEI_ROWS[0], CEI_ROWS[1], CEI_ROWS[2] });
1:         inputOutput.put(
1:             new String[] {"Warning", "%oor"},
1:             new Object[][] { CEI_ROWS[8], CEI_ROWS[7], CEI_ROWS[6] });
1:         inputOutput.put(
1:             new String[] {"Warning", "Warn\\%Unlock\\%Door"},
1:             new Object[][] { CEI_ROWS[7] });
1:         inputOutput.put(
1:             new String[] {"Warning", "%\\%Unlo%"},
1:             new Object[][] { CEI_ROWS[7] });
1:         inputOutput.put(
1:             new String[] {"Warning", "W\\_Unloc%"},
1:             new Object[][] { CEI_ROWS[8] });
1:         inputOutput.put(
1:             new String[] {"Warning", "_\\_Unlock\\_Door"},
1:             new Object[][] { CEI_ROWS[8] });
1:         inputOutput.put(
1:             new String[] {"W%", "Warn\\%Unlock\\%Door"},
1:             new Object[][] { CEI_ROWS[7] });
1:         inputOutput.put(
1:             new String[] {"%ing", "W\\_Unlock\\_%Door"},
1:             new Object[][] { CEI_ROWS[8] });
1:         inputOutput.put(new String[] {"Bogus", "Name"}, new Object[][] {});
1: 
0:         for (Iterator it = inputOutput.entrySet().iterator(); it.hasNext(); ) {
0:             Map.Entry entry = (Map.Entry) it.next();
0:             String[] args = (String[]) entry.getKey();
0:             Object[][] rows = (Object[][]) entry.getValue();
1:             ps.setObject(1, args[0]);
1:             ps.setObject(2, args[1]);
1:             JDBC.assertFullResultSet(ps.executeQuery(), rows, false);
1:         }
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Test that % matches tab characters (DERBY-1262).
1:      */
1:     public void testTabs() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("insert into test values " +
1:                         "('asd\tp', 'asd\tp', 'asd\tp'), " +
1:                         "('ase\tp', 'ase\tg', 'ase\tg')");
1: 
1:         String[][] expected = { {"asdf"}, {"asdg"}, {"asd\tp"} };
1:         JDBC.assertUnorderedResultSet(
1:             s.executeQuery("select c10 from test where c10 like 'asd%'"),
1:             expected);
1: 
1:         PreparedStatement ps =
1:             prepareStatement("select c10 from test where c10 like ?");
1:         ps.setString(1, "asd%");
1:         JDBC.assertUnorderedResultSet(ps.executeQuery(), expected);
1: 
1:         s.close();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Test that it is possible to escape an escape character that is before
1:      * the first wildcard (% or _) in the pattern (DERBY-1386).
1:      */
1:     public void testEscapedEscapeCharacterPrecedingFirstWildcard()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("insert into test values " +
1:                         "('abc#def', 'abc#def', 'abc#def'), " +
1:                         "('abc\\def', 'abc\\def', 'abc\\def')");
1: 
1:         PreparedStatement[] ps = {
1:             prepareStatement("select id from test where c10 like ? escape ?"),
1:             prepareStatement("select id from test where vc10 like ? escape ?")
1:         };
1: 
1:         String[][] inputOutput = {
1:             { "abc##%", "#", "abc#def", "abc#def" },
1:             { "abc\\\\%", "\\", "abc\\def", "abc\\def" },
1:             { "abc##_ef", "#", null, "abc#def" },
1:             { "abc\\\\_ef", "\\", null, "abc\\def" },
1:         };
1: 
1:         for (int i = 0; i < inputOutput.length; i++) {
1:             for (int j = 0; j < ps.length; j++) {
1:                 ps[j].setString(1, inputOutput[i][0]);
1:                 ps[j].setString(2, inputOutput[i][1]);
1:                 ResultSet rs = ps[j].executeQuery();
1:                 String expected = inputOutput[i][2+j];
1:                 if (expected == null) {
1:                     JDBC.assertEmpty(rs);
1:                 } else {
1:                     JDBC.assertSingleValueResultSet(rs, expected);
1:                 }
1:             }
1:         }
1: 
1:         s.close();
1:         ps[0].close();
1:         ps[1].close();
1:     }
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:f148f1f
/////////////////////////////////////////////////////////////////////////
1:         ResultSet rs = s.executeQuery( 
1:           		"VALUES SYSCS_UTIL.SYSCS_GET_DATABASE_PROPERTY('derby.database.collation')");
1:         if (rs.next()){
1:         	if (rs.getString(1).equals("TERRITORY_BASED")) {
1:         		rs.close();
1:         		s.close();
1:         		return;
1:         	}
1:         }
============================================================================