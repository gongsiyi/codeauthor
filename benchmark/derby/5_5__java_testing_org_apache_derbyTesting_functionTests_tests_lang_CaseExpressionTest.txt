1:a1d6109: /**
1:a1d6109:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CaseExpressionTest
1:a1d6109:  *
1:a1d6109:  * Licensed to the Apache Software Foundation (ASF) under one
1:a1d6109:  * or more contributor license agreements.  See the NOTICE file
1:a1d6109:  * distributed with this work for additional information
1:a1d6109:  * regarding copyright ownership.  The ASF licenses this file
1:a1d6109:  * to you under the Apache License, Version 2.0 (the
1:a1d6109:  * "License"); you may not use this file except in compliance
1:a1d6109:  * with the License.  You may obtain a copy of the License at
1:a1d6109:  *
1:a1d6109:  *   http://www.apache.org/licenses/LICENSE-2.0
1:a1d6109:  *
1:a1d6109:  * Unless required by applicable law or agreed to in writing,
1:a1d6109:  * software distributed under the License is distributed on an
1:a1d6109:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:a1d6109:  * KIND, either express or implied.  See the License for the
1:a1d6109:  * specific language governing permissions and limitations
1:a1d6109:  * under the License.
1:a1d6109:  */
5:a1d6109: 
1:a1d6109: package org.apache.derbyTesting.functionTests.tests.lang;
1:a1d6109: 
1:2bd5cbd: import java.sql.ParameterMetaData;
1:f273581: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:78cb2da: import java.sql.ResultSetMetaData;
1:a1d6109: import java.sql.SQLException;
1:a1d6109: import java.sql.Statement;
1:d6b5ab3: import java.sql.Types;
1:f273581: import java.util.ArrayList;
1:f273581: import java.util.Arrays;
1:f2dfe06: import java.util.concurrent.atomic.AtomicInteger;
1:a1d6109: import junit.framework.Test;
1:f2dfe06: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:f2dfe06: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:a1d6109: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a1d6109: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:4c2072e: import org.apache.derbyTesting.junit.JDBC;
1:a1d6109: import org.apache.derbyTesting.junit.SQLUtilities;
1:a1d6109: import org.apache.derbyTesting.junit.TestConfiguration;
1:a1d6109: 
1:a1d6109: 
1:a1d6109: public class CaseExpressionTest extends BaseJDBCTestCase {
1:a1d6109: 
1:a1d6109:         // Results if the Case Expression evaluates to a column reference :
1:a1d6109:         //
1:a1d6109:         // 1. SELECT CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END
1:a1d6109:         // 2. SELECT CASE WHEN 1 = 1 THEN
1:a1d6109:         //       (CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END)
1:a1d6109:         //       ELSE NULL END
1:a1d6109:         //
1:a1d6109:         private static String[][] columnReferenceResults = {
1:a1d6109:             /*SMALLINT*/ {null,"0","1","2"},
1:a1d6109:             /*INTEGER*/ {null,"0","1","21"},
1:a1d6109:             /*BIGINT*/ {null,"0","1","22"},
1:a1d6109:             /*DECIMAL(10,5)*/ {null,"0.00000","1.00000","23.00000"},
1:a1d6109:             /*REAL*/ {null,"0.0","1.0","24.0"},
1:a1d6109:             /*DOUBLE*/ {null,"0.0","1.0","25.0"},
1:a1d6109:             /*CHAR(60)*/ {
1:a1d6109:                 null,
1:a1d6109:                 "0                                                           ",
1:a1d6109:                 "aa                                                          ",
1:a1d6109:                 "2.0                                                         "},
1:a1d6109:             /*VARCHAR(60)*/ {null,"0","aa","15:30:20"},
1:a1d6109:             /*LONG VARCHAR*/ {null,"0","aa","2000-01-01 15:30:20"},
1:a1d6109:             /*CHAR(60) FOR BIT DATA*/ {
1:a1d6109:                 null,
1:a1d6109:                 "10aa20202020202020202020202020202020202020202020202020202020" +
1:a1d6109:                 "202020202020202020202020202020202020202020202020202020202020",
1:a1d6109:                 null,
1:a1d6109:                 "10aaaa202020202020202020202020202020202020202020202020202020" +
1:a1d6109:                 "202020202020202020202020202020202020202020202020202020202020"},
1:a1d6109:             /*VARCHAR(60) FOR BIT DATA*/ {null,"10aa",null,"10aaba"},
1:a1d6109:             /*LONG VARCHAR FOR BIT DATA*/ {null,"10aa",null,"10aaca"},
1:a1d6109:             /*CLOB(1k)*/ {null,"13","14",null},
1:a1d6109:             /*DATE*/ {null,"2000-01-01","2000-01-01",null},
1:a1d6109:             /*TIME*/ {null,"15:30:20","15:30:20","15:30:20"},
1:a1d6109:             /*TIMESTAMP*/ {
1:a1d6109:                 null,
1:a1d6109:                 "2000-01-01 15:30:20.0",
1:a1d6109:                 "2000-01-01 15:30:20.0",
1:a1d6109:                 "2000-01-01 15:30:20.0"},
1:a1d6109:             /*BLOB(1k)*/ {null,null,null,null},
1:a1d6109:         };
1:1cf00e6:         
1:1cf00e6:        
1:a1d6109: 
1:a1d6109:         // Results if the Case Expression evaluates to a NULL value :
1:a1d6109:         //
1:a1d6109:         // 3. SELECT CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END
1:a1d6109:         // 4. SELECT CASE WHEN 1 = 1 THEN
1:a1d6109:         //       (CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END)
1:a1d6109:         //         ELSE NULL END
1:a1d6109:         // 5. SELECT CASE WHEN 1 = 1 THEN NULL ELSE
1:a1d6109:         //         (CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END) END
1:a1d6109:         // 6. SELECT CASE WHEN 1 = 1 THEN NULL ELSE
1:a1d6109:         //         (CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END) END
1:a1d6109:         //
1:a1d6109:         private static String[][] nullValueResults  = {
1:a1d6109:             /*SMALLINT*/ {null,null,null,null},
1:a1d6109:             /*INTEGER*/ {null,null,null,null},
1:a1d6109:             /*BIGINT*/ {null,null,null,null},
1:a1d6109:             /*DECIMAL(10,5)*/ {null,null,null,null},
1:a1d6109:             /*REAL*/ {null,null,null,null},
1:a1d6109:             /*DOUBLE*/ {null,null,null,null},
1:a1d6109:             /*CHAR(60)*/ {null,null,null,null},
1:a1d6109:             /*VARCHAR(60)*/ {null,null,null,null},
1:a1d6109:             /*LONG VARCHAR*/ {null,null,null,null},
1:a1d6109:             /*CHAR(60) FOR BIT DATA*/ {null,null,null,null},
1:a1d6109:             /*VARCHAR(60) FOR BIT DATA*/ {null,null,null,null},
1:a1d6109:             /*LONG VARCHAR FOR BIT DATA*/ {null,null,null,null},
1:a1d6109:             /*CLOB(1k)*/ {null,null,null,null},
1:a1d6109:             /*DATE*/ {null,null,null,null},
1:a1d6109:             /*TIME*/ {null,null,null,null},
1:a1d6109:             /*TIMESTAMP*/ {null,null,null,null},
1:a1d6109:             /*BLOB(1k)*/ {null,null,null,null},
1:a1d6109:         };
1:a1d6109: 
1:a1d6109:     public CaseExpressionTest(String name) {
1:a1d6109:         super(name);
1:a1d6109:     }
1:b959945:     
1:b959945:     /**
1:b959945:      * Test various statements that 
1:b959945:      *
1:b959945:      */
1:b959945:     public void testWhenNonBoolean() {
1:b959945:         
1:b959945:         // DERBY-2809: BOOLEAN datatype was forced upon
1:b959945:         // unary expressions that were not BOOLEAN, such
1:b959945:         // as SQRT(?)
1:b959945:         String[] unaryOperators = {
1:b959945:                 "SQRT(?)", "SQRT(9)",
1:b959945:                 "UPPER(?)", "UPPER('haight')",
1:b959945:                 "LOWER(?)", "LOWER('HAIGHT')",
1:b959945:         };
1:b959945:         for (int i = 0; i < unaryOperators.length; i++)
1:b959945:         {
1:b959945:             assertCompileError("42X88",
1:b959945:                "VALUES CASE WHEN " + unaryOperators[i] +
1:b959945:                " THEN 3 ELSE 4 END");
1:b959945:         }
1:b959945:     }
1:78cb2da: 
1:a1d6109:     public void testAllDatatypesCombinationsForCaseExpressions()
1:a1d6109:     throws SQLException
1:a1d6109:     {
1:a1d6109:         Statement s = createStatement();
1:1cf00e6: 
1:a1d6109:         /* 1. Column Reference in the THEN node, and NULL in
1:a1d6109:          * the ELSE node.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, columnReferenceResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN ",
1:a1d6109:             " ELSE NULL END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         /* 2. Test Column Reference nested in the THEN's node THEN node,
1:a1d6109:          * NULL's elsewhere.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, columnReferenceResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN (CASE WHEN 1 = 1 THEN ",
1:a1d6109:             " ELSE NULL END) ELSE NULL END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         /* 3. NULL in the THEN node, and a Column Reference in
1:a1d6109:          * the ELSE node.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, nullValueResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN NULL ELSE ",
1:a1d6109:             " END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         /* 4. Test Column Reference nested in the THEN's node ELSE node,
1:a1d6109:          * NULL's elsewhere.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, nullValueResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN (CASE WHEN 1 = 1 THEN NULL ELSE ",
1:a1d6109:             " END) ELSE NULL END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         /* 5. Test Column Reference nested in the ELSE's node THEN node,
1:a1d6109:          * NULL's elsewhere.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, nullValueResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN NULL ELSE (CASE WHEN 1 = 1 THEN ",
1:a1d6109:             " ELSE NULL END) END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         /* 6. Test Column Reference nested in the ELSE's node ELSE node,
1:a1d6109:          * NULL's elsewhere.
1:a1d6109:          */
1:a1d6109:         testCaseExpressionQuery(s, nullValueResults,
1:a1d6109:             "SELECT CASE WHEN 1 = 1 THEN NULL " +
1:a1d6109:             "ELSE (CASE WHEN 1 = 1 THEN NULL ELSE ",
1:a1d6109:             " END) END from AllDataTypesTable");
1:a1d6109: 
1:a1d6109:         s.close();
1:a1d6109:     }
1:a1d6109: 
1:78cb2da:     /**
1:4c2072e:      * Test a query that has many WHEN conditions in it.  This is mostly
1:4c2072e:      * checking for the performance regression filed as DERBY-2986.  That
1:4c2072e:      * regression may not be noticeable in the scope of the full regression
1:4c2072e:      * suite, but if this test is run standalone then this fixture could
1:4c2072e:      * still be useful.
1:4c2072e:      */
1:4c2072e:     public void testMultipleWhens() throws SQLException
1:4c2072e:     {
1:4c2072e:         Statement s = createStatement();
1:4c2072e:         JDBC.assertFullResultSet(
1:4c2072e:             s.executeQuery(
1:4c2072e:                 "values CASE WHEN 10 = 1 THEN 'a' " +
1:4c2072e:                 "WHEN 10 = 2 THEN 'b' " +
1:4c2072e:                 "WHEN 10 = 3 THEN 'c' " +
1:4c2072e:                 "WHEN 10 = 4 THEN 'd' " +
1:4c2072e:                 "WHEN 10 = 5 THEN 'e' " +
1:4c2072e:                 "WHEN 10 = 6 THEN 'f' " +
1:4c2072e:                 "WHEN 10 = 7 THEN 'g' " +
1:4c2072e:                 "WHEN 10 = 8 THEN 'h' " +
1:4c2072e:                 "WHEN 10 = 11 THEN 'i' " +
1:4c2072e:                 "WHEN 10 = 12 THEN 'j' " +
1:4c2072e:                 "WHEN 10 = 15 THEN 'k' " +
1:4c2072e:                 "WHEN 10 = 16 THEN 'l' " +
1:4c2072e:                 "WHEN 10 = 23 THEN 'm' " +
1:4c2072e:                 "WHEN 10 = 24 THEN 'n' " +
1:4c2072e:                 "WHEN 10 = 27 THEN 'o' " +
1:4c2072e:                 "WHEN 10 = 31 THEN 'p' " +
1:4c2072e:                 "WHEN 10 = 41 THEN 'q' " +
1:4c2072e:                 "WHEN 10 = 42 THEN 'r' " +
1:4c2072e:                 "WHEN 10 = 50 THEN 's' " +
1:4c2072e:                 "ELSE '*' END"),
1:4c2072e:             new String[][] {{"*"}});
1:4c2072e: 
1:4c2072e:         s.close();
1:4c2072e:     }
1:4c2072e: 
1:4c2072e:     /**
1:aaac214:      * Before DERBY-6423, boolean expressions (such as A OR B, or A AND B)
1:aaac214:      * were not accepted in THEN and ELSE clauses.
1:aaac214:      */
1:aaac214:     public void testBooleanExpressions() throws SQLException {
1:aaac214:         Statement s = createStatement();
1:aaac214: 
1:aaac214:         // Test both with and without parentheses around the expressions.
1:aaac214:         // Those with parentheses used to work, and those without used to
1:aaac214:         // cause syntax errors. Now both should work.
1:aaac214:         JDBC.assertFullResultSet(
1:aaac214:             s.executeQuery(
1:aaac214:                 "select case when a or b then b or c else a or c end,\n" +
1:aaac214:                 "   case when a and b then b and c else a and c end,\n" +
1:aaac214:                 "   case when (a or b) then (b or c) else (a or c) end,\n" +
1:aaac214:                 "   case when (a and b) then (b and c) else (a and c) end\n" +
1:aaac214:                 "from (values (true, true, true), (true, true, false),\n" +
1:aaac214:                 "             (true, false, true), (true, false, false),\n" +
1:aaac214:                 "             (false, true, true), (false, true, false),\n" +
1:aaac214:                 "             (false, false, true), (false, false, false)\n" +
1:aaac214:                 "      ) v(a, b, c)\n" +
1:aaac214:                 "order by a desc, b desc, c desc"),
1:aaac214:             new String[][] {
1:aaac214:                 { "true", "true", "true", "true" },
1:aaac214:                 { "true", "false", "true", "false" },
1:aaac214:                 { "true", "true", "true", "true" },
1:aaac214:                 { "false", "false", "false", "false" },
1:aaac214:                 { "true", "false", "true", "false" },
1:aaac214:                 { "true", "false", "true", "false" },
1:aaac214:                 { "true", "false", "true", "false" },
1:aaac214:                 { "false", "false", "false", "false" },
1:aaac214:             });
1:aaac214:     }
1:aaac214: 
1:aaac214:     /**
1:a1d6109:      * Runs the test fixtures in embedded.
1:a1d6109:      *
1:a1d6109:      * @return test suite
1:a1d6109:      */
1:a1d6109:     public static Test suite()
1:a1d6109:     {
1:1ae02c9:         BaseTestSuite suite = (BaseTestSuite)
1:a1d6109:             TestConfiguration.embeddedSuite(CaseExpressionTest.class);
1:a1d6109: 
1:a1d6109:         return new CleanDatabaseTestSetup(suite) {
1:a1d6109:             /**
1:a1d6109:              * Creates the table used in the test cases.
1:a1d6109:              */
1:a1d6109:             protected void decorateSQL(Statement s) throws SQLException {
1:a1d6109:                 SQLUtilities.createAndPopulateAllDataTypesTable(s);
1:1cf00e6:                 
1:a1d6109:             }
1:a1d6109:         };
1:a1d6109:     }
1:a1d6109: 
1:a1d6109:     /**
1:a1d6109:      * Execute the received caseExpression on the received Statement
1:a1d6109:      * and check the results against the receieved expected array.
1:a1d6109:      */
1:a1d6109:     private void testCaseExpressionQuery(Statement st,
1:a1d6109:         String [][] expRS, String caseExprBegin, String caseExprEnd)
1:a1d6109:         throws SQLException
1:a1d6109:     {
1:a1d6109:         ResultSet rs;
1:a1d6109:         int colType;
1:a1d6109:         int row;
1:a1d6109: 
1:a1d6109:         for (colType = 0;
1:1cf00e6:             colType < SQLUtilities.SQLTypes.length;
1:a1d6109:             colType++)
1:a1d6109:         {
1:a1d6109:             rs = st.executeQuery(
1:a1d6109:                 caseExprBegin +
1:a1d6109:                 SQLUtilities.allDataTypesColumnNames[colType] +
1:a1d6109:                 caseExprEnd);
1:a1d6109: 
1:a1d6109:             row = 0;
1:1cf00e6:             
1:a1d6109:             while (rs.next()) {
1:a1d6109:                 String val = rs.getString(1);
1:a1d6109:                 assertEquals(expRS[colType][row], val);
1:a1d6109:                 row++;
1:a1d6109:             }
1:a1d6109:             rs.close();
1:a1d6109:         }
1:1cf00e6:      
1:a1d6109:     }
1:1cf00e6: 
1:1cf00e6:     
1:a1d6109:     /**
1:78cb2da:      * Test fix for DERBY-3032. Fix ClassCastException if SQL NULL is returned from conditional.
1:78cb2da:      * 
1:78cb2da:      * @throws SQLException
1:78cb2da:      */
1:78cb2da:     public void testDerby3032() throws SQLException 
1:78cb2da:     {
1:78cb2da:         Statement s = createStatement();
1:78cb2da:         
1:78cb2da: 
1:78cb2da:         s.executeUpdate("create table t (d date, vc varchar(30))");
1:78cb2da:         s.executeUpdate("insert into t values(CURRENT_DATE, 'hello')");
1:78cb2da:         ResultSet rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 1 THEN CURRENT_DATE ELSE NULL END from t)");
1:78cb2da:         JDBC.assertDrainResults(rs,1);
1:78cb2da:         
1:78cb2da:         // Make sure null gets cast properly to date type to avoid cast exception. DERBY-3032
1:78cb2da:         rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 1 THEN NULL  ELSE CURRENT_DATE  END from t)");
1:78cb2da:         JDBC.assertEmpty(rs);
1:78cb2da:         
1:78cb2da:         rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE  ELSE NULL END from t)");
1:78cb2da:         JDBC.assertEmpty(rs);
1:78cb2da:         
1:f5efedc:         // Make sure metadata has correct type for various null handling
1:78cb2da:         rs = s.executeQuery("SELECT CASE WHEN 1 = 1 THEN NULL  ELSE CURRENT_DATE  END from t");
1:78cb2da:         ResultSetMetaData rsmd = rs.getMetaData();
1:78cb2da:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:78cb2da:         // should be nullable since it returns NULL #:)
1:f5efedc:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:f5efedc:         JDBC.assertSingleValueResultSet(rs, null);    
1:f5efedc:         
1:f5efedc:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE ELSE NULL END from t");
1:f5efedc:         rsmd = rs.getMetaData();
1:f5efedc:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:f5efedc:         // should be nullable since it returns NULL #:)
1:f5efedc:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:f5efedc:         JDBC.assertSingleValueResultSet(rs, null);  
1:f5efedc:         
1:f5efedc:         // and with an implicit NULL return.
1:f5efedc:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE END from t");
1:f5efedc:         rsmd = rs.getMetaData();
1:f5efedc:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:f5efedc:         // should be nullable since it returns NULL #:)
1:f5efedc:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:f5efedc:         JDBC.assertSingleValueResultSet(rs, null);  
1:f5efedc:         
1:f5efedc:         // and no possible NULL return.
1:f5efedc:         
1:f5efedc:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN 6 ELSE 4 END from t");
1:f5efedc:         rsmd = rs.getMetaData();
1:f5efedc:         assertEquals(java.sql.Types.INTEGER, rsmd.getColumnType(1));
1:f5efedc:         // should be nullable since it returns NULL #:)
1:f5efedc:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:f5efedc:         JDBC.assertSingleValueResultSet(rs, "4"); 
1:f5efedc:         
1:f5efedc:         rs = s.executeQuery("SELECT CASE WHEN 1 = 1 THEN 6 ELSE 4 END from t");
1:f5efedc:         rsmd = rs.getMetaData();
1:f5efedc:         assertEquals(java.sql.Types.INTEGER, rsmd.getColumnType(1));
1:f5efedc:         // should be nullable since it returns NULL #:)
1:f5efedc:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:f5efedc:         JDBC.assertSingleValueResultSet(rs, "6");
1:f273581:         
1:78cb2da:     }
1:f5efedc: 
1:f273581:     /**
1:f273581:      * Verify that NOT elimination produces the correct results.
1:f273581:      * DERBY-6563.
1:f273581:      */
1:f273581:     public void testNotElimination() throws SQLException {
1:f273581:         setAutoCommit(false);
1:f273581: 
1:f273581:         Statement s = createStatement();
1:f273581:         s.execute("create table d6563(b1 boolean, b2 boolean, b3 boolean)");
1:f273581: 
1:f273581:         // Fill the table with all possible combinations of true/false/null.
1:f273581:         Boolean[] universe = { true, false, null };
1:f273581:         PreparedStatement insert = prepareStatement(
1:f273581:                 "insert into d6563 values (?, ?, ?)");
1:f273581:         for (Boolean v1 : universe) {
1:f273581:             insert.setObject(1, v1);
1:f273581:             for (Boolean v2 : universe) {
1:f273581:                 insert.setObject(2, v2);
1:f273581:                 for (Boolean v3 : universe) {
1:f273581:                     insert.setObject(3, v3);
1:f273581:                     insert.executeUpdate();
1:f273581:                 }
1:f273581:             }
1:f273581:         }
1:f273581: 
1:f273581:         // Truth table for
1:f273581:         // B1, B2, B3, WHEN B1 THEN B2 ELSE B3, NOT (WHEN B1 THEN B2 ELSE B3).
1:f273581:         Object[][] expectedRows = {
1:f273581:             { false, false, false, false, true  },
1:f273581:             { false, false, true,  true,  false },
1:f273581:             { false, false, null,  null,  null  },
1:f273581:             { false, true,  false, false, true  },
1:f273581:             { false, true,  true,  true,  false },
1:f273581:             { false, true,  null,  null,  null  },
1:f273581:             { false, null,  false, false, true  },
1:f273581:             { false, null,  true,  true,  false },
1:f273581:             { false, null,  null,  null,  null  },
1:f273581:             { true,  false, false, false, true  },
1:f273581:             { true,  false, true,  false, true  },
1:f273581:             { true,  false, null,  false, true  },
1:f273581:             { true,  true,  false, true,  false },
1:f273581:             { true,  true,  true,  true,  false },
1:f273581:             { true,  true,  null,  true,  false },
1:f273581:             { true,  null,  false, null,  null  },
1:f273581:             { true,  null,  true,  null,  null  },
1:f273581:             { true,  null,  null,  null,  null  },
1:f273581:             { null,  false, false, false, true  },
1:f273581:             { null,  false, true,  true,  false },
1:f273581:             { null,  false, null,  null,  null  },
1:f273581:             { null,  true,  false, false, true  },
1:f273581:             { null,  true,  true,  true,  false },
1:f273581:             { null,  true,  null,  null,  null  },
1:f273581:             { null,  null,  false, false, true  },
1:f273581:             { null,  null,  true,  true,  false },
1:f273581:             { null,  null,  null,  null,  null  },
1:f273581:         };
1:f273581: 
1:f273581:         // Verify the truth table. Since NOT elimination is not performed on
1:f273581:         // expressions in the SELECT list, this passed even before the fix.
1:f273581:         JDBC.assertFullResultSet(
1:f273581:             s.executeQuery(
1:f273581:                 "select b1, b2, b3, case when b1 then b2 else b3 end, "
1:f273581:                         + "not case when b1 then b2 else b3 end "
1:f273581:                         + "from d6563 order by b1, b2, b3"),
1:f273581:             expectedRows, false);
1:f273581: 
1:f273581:         // Now take only those rows where the NOT CASE expression evaluated
1:f273581:         // to TRUE, and strip off the expression columns at the end.
1:f273581:         ArrayList<Object[]> rows = new ArrayList<Object[]>();
1:f273581:         for (Object[] row : expectedRows) {
1:f273581:             if (row[4] == Boolean.TRUE) {
1:f273581:                 rows.add(Arrays.copyOf(row, 3));
1:f273581:             }
1:f273581:         }
1:f273581: 
1:f273581:         // Assert that those are the only rows returned if the NOT CASE
1:f273581:         // expression is used as a predicate. This query used to return a
1:f273581:         // different set of rows before the fix.
1:f273581:         expectedRows = rows.toArray(new Object[rows.size()][]);
1:f273581:         JDBC.assertFullResultSet(
1:f273581:                 s.executeQuery("select * from d6563 where "
1:f273581:                         + "not case when b1 then b2 else b3 end "
1:f273581:                         + "order by b1, b2, b3"),
1:f273581:                 expectedRows, false);
1:f273581:     }
1:f273581: 
1:d6b5ab3:     /**
1:d6b5ab3:      * Test that parameters can be used in CASE expressions.
1:d6b5ab3:      */
1:d6b5ab3:     public void testParameters() throws SQLException {
1:d6b5ab3:         // If all of the result expressions are untyped parameters, the
1:d6b5ab3:         // type cannot be determined, and an error should be raised.
1:d6b5ab3:         assertCompileError("42X87", "values case when true then ? else ? end");
1:d6b5ab3: 
1:d6b5ab3:         // If at least one result expression is typed, the parameter should
1:d6b5ab3:         // get its type from it.
1:d6b5ab3:         PreparedStatement ps = prepareStatement(
1:d6b5ab3:                 "values case when true then ? else 1 end");
1:d6b5ab3: 
1:d6b5ab3:         // DERBY-6567: The result should be nullable, since the parameter
1:d6b5ab3:         // could be set to null. It used to be reported as not nullable.
1:d6b5ab3:         assertEquals(ResultSetMetaData.columnNullable,
1:d6b5ab3:                      ps.getMetaData().isNullable(1));
1:d6b5ab3: 
1:d6b5ab3:         ps.setNull(1, Types.INTEGER);
1:d6b5ab3:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d6b5ab3: 
1:d6b5ab3:         ps.setInt(1, 1);
1:d6b5ab3:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:d6b5ab3: 
1:6f52e78:         ps = prepareStatement(
1:6f52e78:                 "values case when true then ? else cast(? as integer) end");
1:6f52e78:         ParameterMetaData params = ps.getParameterMetaData();
1:6f52e78:         assertEquals(Types.INTEGER, params.getParameterType(1));
1:6f52e78:         assertEquals(Types.INTEGER, params.getParameterType(2));
1:6f52e78:         ps.setInt(1, 1);
1:6f52e78:         ps.setInt(2, 2);
1:6f52e78:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:6f52e78: 
1:d6b5ab3:         // Parameters in the WHEN clause can be untyped. They will
1:d6b5ab3:         // implicitly get the BOOLEAN type.
1:d6b5ab3:         ps = prepareStatement("values case when ? then 1 else 0 end");
1:d6b5ab3:         assertEquals(Types.BOOLEAN,
1:d6b5ab3:                      ps.getParameterMetaData().getParameterType(1));
1:d6b5ab3: 
1:d6b5ab3:         ps.setBoolean(1, true);
1:d6b5ab3:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:d6b5ab3: 
1:d6b5ab3:         ps.setBoolean(1, false);
1:d6b5ab3:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1:d6b5ab3: 
1:d6b5ab3:         ps.setNull(1, Types.BOOLEAN);
1:d6b5ab3:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1:d6b5ab3:     }
1:d6b5ab3: 
1:5d7388d:     /**
1:5d7388d:      * Test how untyped NULLs are handled.
1:5d7388d:      */
1:5d7388d:     public void testUntypedNulls() throws SQLException {
1:5d7388d:         Statement s = createStatement();
1:5d7388d: 
1:6f52e78:         // Before DERBY-2002, Derby accepted a CASE expression to have an
1:6f52e78:         // untyped NULL in all the result branches. Verify that an error
1:6f52e78:         // is raised.
1:6f52e78:         String[] allUntyped = {
1:6f52e78:             // The SQL standard says at least one result should not be an
1:6f52e78:             // untyped NULL, so expect these to fail.
1:5d7388d:             "values case when true then null end",
1:5d7388d:             "values case when true then null else null end",
1:6f52e78:             "values case when true then null "
1:6f52e78:                 + "when false then null else null end",
1:6f52e78: 
1:6f52e78:             // We're not able to tell the type if we have a mix of untyped
1:6f52e78:             // NULLs and untyped parameters.
1:6f52e78:             "values case when true then ? end", // implicit ELSE NULL
1:6f52e78:             "values case when true then null else ? end",
1:6f52e78:             "values case when true then ? when false then ? else null end",
1:6f52e78: 
1:6f52e78:             // These ones failed even before DERBY-2002.
1:6f52e78:             "values case when true then ? else ? end",
1:6f52e78:             "values case when true then ? when false then ? else ? end",
1:5d7388d:         };
1:6f52e78:         for (String sql : allUntyped) {
1:6f52e78:             assertCompileError("42X87", sql);
1:5d7388d:         }
1:5d7388d: 
1:5d7388d:         // Check that expressions with untyped NULLs compile as long as
1:5d7388d:         // there is at least one typed expression.
1:5d7388d:         JDBC.assertFullResultSet(s.executeQuery(
1:5d7388d:                 "select case when a then 1 when b then null end, "
1:5d7388d:                     + "case when a then null when b then 1 end, "
1:5d7388d:                     + "case when a then null when b then null else 1 end "
1:5d7388d:                     + "from (values (false, false), (false, true), "
1:5d7388d:                     + " (true, false), (true, true)) v(a, b) order by a, b"),
1:5d7388d:             new Object[][] {
1:5d7388d:                 { null, null, 1    },
1:5d7388d:                 { null, 1,    null },
1:5d7388d:                 { 1,    null, null },
1:5d7388d:                 { 1,    null, null },
1:5d7388d:             },
1:5d7388d:             false);
1:5d7388d: 
1:5d7388d:         // When there is a typed NULL, its type has to be compatible with
1:5d7388d:         // the types of the other expressions.
1:5d7388d:         assertCompileError("42X89",
1:5d7388d:             "values case when 1<>1 then 'abc' else cast(null as smallint) end");
1:5d7388d:     }
1:39e20ff: 
1:39e20ff:     /** Regression test case for DERBY-6577. */
1:39e20ff:     public void testQuantifiedComparison() throws SQLException {
1:39e20ff:         // This query used to return wrong results.
1:39e20ff:         JDBC.assertUnorderedResultSet(createStatement().executeQuery(
1:39e20ff:                 "select c, case when c = all (values 'Y') then true end "
1:39e20ff:                 + "from (values 'Y', 'N') v(c)"),
1:39e20ff:             new String[][] { { "N", null }, { "Y", "true" }});
1:39e20ff:     }
1:2455f1a: 
1:2455f1a:     /**
1:2455f1a:      * Tests for the simple case syntax added in DERBY-1576.
1:2455f1a:      */
1:2455f1a:     public void testSimpleCaseSyntax() throws SQLException {
1:2455f1a:         Statement s = createStatement();
1:2455f1a: 
1:2455f1a:         // Simplest of the simple cases. SQL:1999 syntax, which allows a
1:2455f1a:         // single operand per WHEN clause, and the operand is a value
1:2455f1a:         // expression.
1:2455f1a:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:2455f1a:                 "select i, case i when 0 then 'zero' "
1:2455f1a:                 + "when 1 then 'one' when 1+1 then 'two' "
1:2455f1a:                 + "else 'many' end from "
1:2455f1a:                 + "(values 0, 1, 2, 3, cast(null as int)) v(i)"),
1:2455f1a:             new String[][] {
1:2455f1a:                 {"0", "zero"},
1:2455f1a:                 {"1", "one"},
1:2455f1a:                 {"2", "two"},
1:2455f1a:                 {"3", "many"},
1:2455f1a:                 {null, "many"}
1:2455f1a:             });
1:2455f1a: 
1:2455f1a:         // SQL:2003 added feature F262 Extended CASE Expression, which
1:2455f1a:         // allows more complex WHEN operands. Essentially, it allows any
1:2455f1a:         // last part of a predicate (everything after the left operand).
1:2455f1a:         JDBC.assertFullResultSet(s.executeQuery(
1:2455f1a:                 "select i, case i when < 0 then 'negative' "
1:2455f1a:                         + "when < 10 then 'small' "
1:2455f1a:                         + "when between 10 and 20 then 'medium' "
1:2455f1a:                         + "when in (19, 23, 29, 37, 41) then 'prime' "
1:2455f1a:                         + "when = some (values 7, 42) then 'lucky number' "
1:2455f1a:                         + "when >= 40 then 'big' end "
1:2455f1a:                         + "from (values -1, 0, 1, 2, 3, 8, 9, 10, 17, 19, "
1:2455f1a:                         + "29, 37, 38, 39, 40, 41, 42, 50) v(i) order by i"),
1:2455f1a:             new String[][] {
1:2455f1a:                 { "-1", "negative" },
1:2455f1a:                 { "0", "small" },
1:2455f1a:                 { "1", "small" },
1:2455f1a:                 { "2", "small" },
1:2455f1a:                 { "3", "small" },
1:2455f1a:                 { "8", "small" },
1:2455f1a:                 { "9", "small" },
1:2455f1a:                 { "10", "medium" },
1:2455f1a:                 { "17", "medium" },
1:2455f1a:                 { "19", "medium" },
1:2455f1a:                 { "29", "prime" },
1:2455f1a:                 { "37", "prime" },
1:2455f1a:                 { "38", null },
1:2455f1a:                 { "39", null },
1:2455f1a:                 { "40", "big" },
1:2455f1a:                 { "41", "prime" },
1:2455f1a:                 { "42", "lucky number" },
1:2455f1a:                 { "50", "big" },
1:2455f1a:             });
1:2455f1a: 
1:2455f1a:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:2455f1a:                 "select c, case c "
1:2455f1a:                 + "when like 'abc%' then 0 "
1:2455f1a:                 + "when like 'x%%' escape 'x' then 1 "
1:2455f1a:                 + "when = all (select ibmreqd from sysibm.sysdummy1) then 2 "
1:2455f1a:                 + "when 'xyz' || 'zyx' then 3 "
1:2455f1a:                 + "when is null then 4 "
1:2455f1a:                 + "when is not null then 5 end "
1:2455f1a:                 + "from (values 'abcdef', 'xyzzyx', '%s', 'hello', "
1:2455f1a:                 + "cast(null as char(1)), 'Y', 'N') v(c)"),
1:2455f1a:             new String[][] {
1:2455f1a:                 { "abcdef", "0" },
1:2455f1a:                 { "xyzzyx", "3" },
1:2455f1a:                 { "%s", "1" },
1:2455f1a:                 { "hello", "5" },
1:2455f1a:                 { null, "4" },
1:2455f1a:                 { "Y", "2" },
1:2455f1a:                 { "N", "5" },
1:2455f1a:             });
1:2455f1a: 
1:2455f1a:         // SQL:2011 added feature F263 Comma-separated predicates in simple
1:2455f1a:         // CASE expression, which allows multiple operands per WHEN clause.
1:2455f1a:         JDBC.assertFullResultSet(s.executeQuery(
1:2455f1a:                 "select i, case i "
1:2455f1a:                 + "when between 2 and 3, 5, =7 then 'prime' "
1:2455f1a:                 + "when <1, >7 then 'out of range' "
1:2455f1a:                 + "when is not null then 'small' end "
1:2455f1a:                 + "from (values 0, 1, 2, 3, 4, 5, 6, 7, 8, cast(null as int)) "
1:2455f1a:                 + "as v(i) order by i"),
1:2455f1a:             new String[][] {
1:2455f1a:                 { "0", "out of range" },
1:2455f1a:                 { "1", "small" },
1:2455f1a:                 { "2", "prime" },
1:2455f1a:                 { "3", "prime" },
1:2455f1a:                 { "4", "small" },
1:2455f1a:                 { "5", "prime" },
1:2455f1a:                 { "6", "small" },
1:2455f1a:                 { "7", "prime" },
1:2455f1a:                 { "8", "out of range" },
1:2455f1a:                 { null, null },
1:2455f1a:             });
1:2455f1a: 
1:2455f1a:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:2455f1a:                 "select c, case c "
1:2455f1a:                 + "when in ('ab', 'cd'), like '_' then 'matched' "
1:2455f1a:                 + "else 'not matched' end "
1:2455f1a:                 + "from (values cast('a' as varchar(1)), 'b', 'c', 'ab', "
1:2455f1a:                 + "'cd', 'ac', 'abc') v(c)"),
1:2455f1a:             new String[][] {
1:2455f1a:                 { "a",   "matched" },
1:2455f1a:                 { "b",   "matched" },
1:2455f1a:                 { "c",   "matched" },
1:2455f1a:                 { "ab",  "matched" },
1:2455f1a:                 { "cd",  "matched" },
1:2455f1a:                 { "ac",  "not matched" },
1:2455f1a:                 { "abc", "not matched" },
1:2455f1a:             });
1:2455f1a: 
1:2455f1a:         // Untyped null is not allowed as CASE operand. Use typed null instead.
1:2455f1a:         assertCompileError("42X01", "values case null when 1 then 'one' end");
1:2455f1a:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:2455f1a:                 "values case cast(null as int) when 1 then 'one' end"),
1:2455f1a:             null);
1:2455f1a: 
1:2455f1a:         // Untyped null is not allowed as WHEN operand. Use IS NULL instead.
1:2455f1a:         assertCompileError("42X01", "values case 1 when null then 'null' end");
1:2455f1a:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:2455f1a:                 "select i, case i when is null then 1 when is not null "
1:2455f1a:                 + "then 2 else 3 end from (values 1, cast(null as int)) v(i)"),
1:2455f1a:             new String[][] { { "1", "2" }, { null, "1" } });
1:2455f1a: 
1:2455f1a:         // Non-deterministic functions are not allowed in the case operand.
1:2455f1a:         assertCompileError("42Y98",
1:2455f1a:                 "values case sysfun.random() when 1 then true else false end");
1:2455f1a:         assertCompileError("42Y98",
1:2455f1a:                 "values case (values sysfun.random()) "
1:2455f1a:                 + "when 1 then true else false end");
1:2455f1a: 
1:2455f1a:         // Deterministic functions, on the other hand, are allowed.
1:2455f1a:         JDBC.assertFullResultSet(s.executeQuery(
1:2455f1a:                 "select case sysfun.sin(angle) when < 0 then 'negative' "
1:2455f1a:                         + "when > 0 then 'positive' end "
1:2455f1a:                         + "from (values -pi()/2, 0, pi()/2) v(angle) "
1:2455f1a:                         + "order by angle"),
1:2455f1a:             new String[][] { {"negative"}, {null}, {"positive"} });
1:2455f1a: 
1:2455f1a:         // Non-deterministic functions can be used outside of the case operand.
1:2455f1a:         JDBC.assertDrainResults(
1:2455f1a:             s.executeQuery(
1:2455f1a:                 "values case 1 when sysfun.random() then sysfun.random() end"),
1:2455f1a:             1);
1:2455f1a: 
1:2455f1a:         // Scalar subqueries are allowed in the case operand.
1:2455f1a:         JDBC.assertSingleValueResultSet(
1:2455f1a:                 s.executeQuery("values case (values 1) when 1 then true end"),
1:2455f1a:                 "true");
1:2455f1a: 
1:2455f1a:         // Non-scalar subqueries are not allowed.
1:2455f1a:         assertCompileError(
1:2455f1a:                 "42X39", "values case (values (1, 2)) when 1 then true end");
1:2455f1a:         assertStatementError(
1:2455f1a:                 "21000", s, "values case (values 1, 2) when 1 then true end");
1:2455f1a: 
1:2455f1a:         // The type of the CASE operand must be compatible with the types
1:2455f1a:         // of all the WHEN operands.
1:2455f1a:         assertCompileError("42818", "values case 1 when true then 'yes' end");
1:2455f1a:         assertCompileError("42818",
1:2455f1a:                 "values case 1 when 1 then 'yes' when 2 then 'no' "
1:2455f1a:                 + "when 'three' then 'maybe' end");
1:2455f1a:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:2455f1a:                 "values case cast(1 as bigint)"
1:2455f1a:                 + " when cast(1 as smallint) then 'yes' end"),
1:2455f1a:             "yes");
1:13d34b0: 
1:13d34b0:         // A sequence cannot be accessed anywhere in a CASE expression.
1:13d34b0:         s.execute("create sequence d1576_s start with 1");
1:13d34b0:         assertCompileError(
1:13d34b0:                 "42XAH",
1:13d34b0:                 "values case next value for d1576_s when 1 then 1 else 0 end");
1:13d34b0:         assertCompileError(
1:13d34b0:                 "42XAH",
1:13d34b0:                 "values case 1 when next value for d1576_s then 1 else 0 end");
1:13d34b0:         assertCompileError(
1:13d34b0:                 "42XAH",
1:13d34b0:                 "values case 1 when 1 then next value for d1576_s else 0 end");
1:13d34b0: 
1:13d34b0:         // Instead, access the sequence value in a nested query.
1:13d34b0:         JDBC.assertSingleValueResultSet(
1:13d34b0:                 s.executeQuery(
1:13d34b0:                     "select case x when 1 then 1 else 0 end from "
1:13d34b0:                     + "(values next value for d1576_s) v(x)"),
1:13d34b0:                 "1");
1:13d34b0: 
1:13d34b0:         s.execute("drop sequence d1576_s restrict");
1:13d34b0: 
1:13d34b0:         // Window functions are allowed.
1:13d34b0:         JDBC.assertFullResultSet(
1:13d34b0:                 s.executeQuery(
1:13d34b0:                     "select case row_number() over () when 1 then 'one' "
1:13d34b0:                     + "when 2 then 'two' end from (values 1, 1, 1) v(x)"),
1:13d34b0:                 new String[][] { {"one"}, {"two"}, {null} });
1:13d34b0: 
1:2bd5cbd:         // Test that you can have a typed parameter in the case operand.
1:13d34b0:         PreparedStatement ps = prepareStatement(
1:13d34b0:                 "values case cast(? as integer) "
1:13d34b0:                 + "when 1 then 'one' when 2 then 'two' end");
1:13d34b0:         ps.setInt(1, 1);
1:13d34b0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:13d34b0:         ps.setInt(1, 2);
1:13d34b0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1:13d34b0:         ps.setInt(1, 3);
1:13d34b0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:13d34b0: 
1:13d34b0:         // This one fails to compile because an integer cannot be checked
1:13d34b0:         // with LIKE.
1:13d34b0:         assertCompileError("42884",
1:13d34b0:                 "values case cast(? as integer) "
1:13d34b0:                 + "when 1 then 1 when like 'abc' then 2 end");
1:13d34b0: 
1:2bd5cbd:         // Untyped parameter in the case operand. Should be able to infer
1:2bd5cbd:         // the type from the WHEN clauses.
1:2bd5cbd:         ps = prepareStatement("values case ? when 1 then 2 when 3 then 4 end");
1:2bd5cbd:         ParameterMetaData pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.INTEGER, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:13d34b0: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 3);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "4");
1:2bd5cbd: 
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case ? when cast(1.1 as double) then true "
1:2bd5cbd:                 + "when cast(1.2 as double) then false end");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.DOUBLE, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setDouble(1, 1.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:2bd5cbd:         ps.setDouble(1, 1.2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "false");
1:2bd5cbd:         ps.setDouble(1, 1.3);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         // Mixed types are accepted, as long as they are compatible.
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case ? when 1 then 'one' when 2.1 then 'two' end");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         ps.setDouble(1, 1.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd:         ps.setDouble(1, 2.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1:2bd5cbd: 
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case ? when 1 then 'one' when 2.1 then 'two'"
1:2bd5cbd:                 + " when cast(3 as bigint) then 'three' end");
1:2bd5cbd:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd:         ps.setInt(1, 3);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "three");
1:2bd5cbd: 
1:2bd5cbd:         ps.setDouble(1, 1.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd:         ps.setDouble(1, 2.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1:2bd5cbd:         ps.setDouble(1, 3.1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case ? when 'abcdef' then 1 "
1:2bd5cbd:                 + "when cast('abcd' as varchar(4)) then 2 end");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.VARCHAR, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(6, pmd.getPrecision(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setString(1, "abcdef");
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:2bd5cbd:         ps.setString(1, "abcd");
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:2bd5cbd:         ps.setString(1, "ab");
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd:         ps.setString(1, "abcdefghi");
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         // The types in the WHEN clauses are incompatible, so the type of
1:2bd5cbd:         // the case operand cannot be inferred.
1:2bd5cbd:         assertCompileError("42818",
1:13d34b0:             "values case ? when 1 then true when like 'abc' then false end");
1:13d34b0: 
1:2bd5cbd:         assertCompileError("42818",
1:13d34b0:             "values case ? when like 'abc' then true when 1 then false end");
1:2bd5cbd: 
1:2bd5cbd:         // BLOB and CLOB are not comparable with anything.
1:2bd5cbd:         assertCompileError("42818",
1:2bd5cbd:                 "values case ? when cast(x'abcd' as blob) then true end");
1:2bd5cbd:         assertCompileError("42818",
1:2bd5cbd:                 "values case ? when cast('abcd' as clob) then true end");
1:2bd5cbd: 
1:2bd5cbd:         // Cannot infer type if both sides of the comparison are untyped.
1:2bd5cbd:         assertCompileError("42X35", "values case ? when ? then true end");
1:2bd5cbd:         assertCompileError("42X35", "values case ? when ? then true "
1:2bd5cbd:                                     + "when 1 then false end");
1:2bd5cbd: 
1:2bd5cbd:         // Should be able to infer type when the untyped parameter is prefixed
1:2bd5cbd:         // with plus or minus.
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values (case +? when 1 then 1 when 2.1 then 2 end, "
1:2bd5cbd:                         + "case -? when 1 then 1 when 2.1 then 2 end)");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd:         assertEquals(Types.DECIMAL, pmd.getParameterType(2));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(2));
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         ps.setInt(2, -1);
1:2bd5cbd:         JDBC.assertFullResultSet(ps.executeQuery(),
1:2bd5cbd:                                  new String[][] {{ "1", "1" }});
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         ps.setInt(2, -2);
1:2bd5cbd:         JDBC.assertFullResultSet(ps.executeQuery(),
1:2bd5cbd:                                  new String[][] {{ null, null }});
1:2bd5cbd: 
1:2bd5cbd:         ps.setDouble(1, 1.1);
1:2bd5cbd:         ps.setDouble(2, -1.1);
1:2bd5cbd:         JDBC.assertFullResultSet(ps.executeQuery(),
1:2bd5cbd:                                  new String[][] {{ null, null }});
1:2bd5cbd: 
1:2bd5cbd:         ps.setDouble(1, 2.1);
1:2bd5cbd:         ps.setDouble(2, -2.1);
1:2bd5cbd:         JDBC.assertFullResultSet(ps.executeQuery(),
1:2bd5cbd:                                  new String[][] {{ "2", "2" }});
1:2bd5cbd: 
1:2bd5cbd:         // If the untyped parameter is part of an arithmetic expression, its
1:2bd5cbd:         // type is inferred from that expression and not from the WHEN clause.
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case 2*? when 2 then true when 3.0 then false end");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.INTEGER, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:2bd5cbd:         ps.setDouble(1, 1.5);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:2bd5cbd: 
1:2bd5cbd:         ps = prepareStatement(
1:2bd5cbd:                 "values case 2.0*? when 2 then true when 3.0 then false end");
1:2bd5cbd:         pmd = ps.getParameterMetaData();
1:2bd5cbd:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:2bd5cbd:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:2bd5cbd: 
1:2bd5cbd:         ps.setInt(1, 1);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:2bd5cbd:         ps.setDouble(1, 1.5);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "false");
1:2bd5cbd:         ps.setInt(1, 2);
1:2bd5cbd:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:d75118e: 
1:d75118e:         // The EXISTS predicate can only be used in the WHEN operand if
1:d75118e:         // the CASE operand is a BOOLEAN.
1:d75118e:         JDBC.assertSingleValueResultSet(
1:d75118e:                 s.executeQuery("values case true when exists" +
1:d75118e:                                "(select * from sysibm.sysdummy1) then 1 end"),
1:d75118e:                 "1");
1:d75118e:         assertCompileError("42818",
1:d75118e:                 "values case 1 when exists" +
1:d75118e:                 "(select * from sysibm.sysdummy1) then 1 end");
1:d75118e: 
1:d75118e:         // Scalar subqueries are allowed in the operands.
1:d75118e:         JDBC.assertSingleValueResultSet(
1:d75118e:                 s.executeQuery(
1:d75118e:                         "values case (select ibmreqd from sysibm.sysdummy1) "
1:d75118e:                         + "when 'N' then 'no' when 'Y' then 'yes' end"),
1:d75118e:                 "yes");
1:d75118e:         JDBC.assertSingleValueResultSet(
1:d75118e:                 s.executeQuery("values case 'Y' when "
1:d75118e:                                 + "(select ibmreqd from sysibm.sysdummy1) "
1:d75118e:                                 + "then 'yes' end"),
1:d75118e:                 "yes");
1:d75118e: 
1:d75118e:         // Subquery returns two columns - fail.
1:d75118e:         assertCompileError(
1:d75118e:                 "42X39",
1:d75118e:                 "values case (select ibmreqd, 1 from sysibm.sysdummy1)"
1:d75118e:                 + " when 'Y' then true end");
1:d75118e:         assertCompileError(
1:d75118e:                 "42X39",
1:d75118e:                 "values case 'Y' when "
1:d75118e:                 + "(select ibmreqd, 1 from sysibm.sysdummy1) then true end");
1:d75118e: 
1:d75118e:         // Subquery returns multiple rows - fail.
1:d75118e:         assertStatementError("21000", s,
1:d75118e:             "values case (select 1 from sys.systables) when 1 then true end");
1:d75118e:         assertStatementError("21000", s,
1:d75118e:             "values case 1 when (select 1 from sys.systables) then true end");
1:d75118e: 
1:d75118e:         // Subquery returns zero rows, which is converted to NULL for scalar
1:d75118e:         // subqueries.
1:d75118e:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:d75118e:                 "values case (select ibmreqd from sysibm.sysdummy1 where false)"
1:d75118e:                 + " when is null then 'yes' end"),
1:d75118e:             "yes");
1:d75118e:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:d75118e:                 "values case true when true then "
1:d75118e:                 + "(select ibmreqd from sysibm.sysdummy1 where false) end"),
1:d75118e:             null);
1:f2dfe06: 
1:f2dfe06:         // Simple case expressions should work in join conditions.
1:f2dfe06:         JDBC.assertSingleValueResultSet(
1:f2dfe06:                 s.executeQuery("select x from (values 1, 2, 3) v1(x) "
1:f2dfe06:                                 + "join (values 13, 14) v2(y) "
1:f2dfe06:                                 + "on case y-x when 10 then true end"),
1:f2dfe06:                 "3");
1:f2dfe06:     }
1:f2dfe06: 
1:f2dfe06:     /**
1:f2dfe06:      * Verify that the case operand expression is evaluated only once per
1:f2dfe06:      * evaluation of the CASE expression.
1:f2dfe06:      */
1:f2dfe06:     public void testSingleEvaluationOfCaseOperand() throws SQLException {
1:f2dfe06:         setAutoCommit(false);
1:f2dfe06:         Statement s = createStatement();
1:f2dfe06: 
1:f2dfe06:         s.execute("create function count_me(x int) returns int "
1:f2dfe06:                 + "language java parameter style java external name '"
1:f2dfe06:                 + getClass().getName() + ".countMe' no sql deterministic");
1:f2dfe06: 
1:f2dfe06:         callCount.set(0);
1:f2dfe06: 
1:f2dfe06:         JDBC.assertUnorderedResultSet(
1:f2dfe06:             s.executeQuery(
1:f2dfe06:                 "select case count_me(x) when 1 then 'one' when 2 then 'two' "
1:f2dfe06:                 + "when 3 then 'three' end from (values 1, 2, 3) v(x)"),
1:f2dfe06:             new String[][] { {"one"}, {"two"}, {"three"} });
1:f2dfe06: 
1:f2dfe06:         // The CASE expression is evaluated once per row. There are three
1:f2dfe06:         // rows. Expect that the COUNT_ME function was only invoked once
1:f2dfe06:         // per row.
1:f2dfe06:         assertEquals(3, callCount.get());
1:f2dfe06:     }
1:f2dfe06: 
1:f2dfe06:     /** Count how many times countMe() has been called. */
1:f2dfe06:     private static final AtomicInteger callCount = new AtomicInteger();
1:f2dfe06: 
1:f2dfe06:     /**
1:f2dfe06:      * Stored function that keeps track of how many times it has been called.
1:f2dfe06:      * @param i an integer
1:f2dfe06:      * @return the integer {@code i}
1:f2dfe06:      */
1:f2dfe06:     public static int countMe(int i) {
1:f2dfe06:         callCount.incrementAndGet();
1:f2dfe06:         return i;
1:f2dfe06:     }
1:f2dfe06: 
1:f2dfe06:     /**
1:f2dfe06:      * Test that large objects can be used as case operands.
1:f2dfe06:      */
1:f2dfe06:     public void testLobAsCaseOperand() throws SQLException {
1:f2dfe06:         Statement s = createStatement();
1:f2dfe06: 
1:f2dfe06:         // BLOB and CLOB are allowed in the case operand.
1:f2dfe06:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f2dfe06:                 "values case cast(null as blob) when is null then 'yes' end"),
1:f2dfe06:             "yes");
1:f2dfe06:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:f2dfe06:                 "values case cast(null as clob) when is null then 'yes' end"),
1:f2dfe06:             "yes");
1:f2dfe06: 
1:f2dfe06:         // Comparisons between BLOB and BLOB, or between CLOB and CLOB, are
1:f2dfe06:         // not allowed, so expect a compile-time error for these queries.
1:f2dfe06:         assertCompileError("42818",
1:f2dfe06:                 "values case cast(null as blob) "
1:f2dfe06:                 + "when cast(null as blob) then true end");
1:f2dfe06:         assertCompileError("42818",
1:f2dfe06:                 "values case cast(null as clob) "
1:f2dfe06:                 + "when cast(null as clob) then true end");
1:f2dfe06: 
1:f2dfe06:         // Now create a table with some actual LOBs in them.
1:f2dfe06:         s.execute("create table lobs_for_simple_case("
1:f2dfe06:                 + "id int generated always as identity, b blob, c clob)");
1:f2dfe06: 
1:f2dfe06:         PreparedStatement insert = prepareStatement(
1:f2dfe06:                 "insert into lobs_for_simple_case(b, c) values (?, ?)");
1:f2dfe06: 
1:f2dfe06:         // A small one.
1:f2dfe06:         insert.setBytes(1, new byte[] {1, 2, 3});
1:f2dfe06:         insert.setString(2, "small");
1:f2dfe06:         insert.executeUpdate();
1:f2dfe06: 
1:f2dfe06:         // And a big one (larger than 32K means it will be streamed
1:f2dfe06:         // from store, instead of being returned as a materialized value).
1:f2dfe06:         insert.setBinaryStream(1, new LoopingAlphabetStream(40000));
1:f2dfe06:         insert.setCharacterStream(2, new LoopingAlphabetReader(40000));
1:f2dfe06:         insert.executeUpdate();
1:f2dfe06: 
1:f2dfe06:         // And a NULL.
1:f2dfe06:         insert.setNull(1, Types.BLOB);
1:f2dfe06:         insert.setNull(2, Types.CLOB);
1:f2dfe06:         insert.executeUpdate();
1:f2dfe06: 
1:f2dfe06:         // IS [NOT] NULL can be used on both BLOB and CLOB. LIKE can be
1:f2dfe06:         // used on CLOB. Those are the only predicates supported on BLOB
1:f2dfe06:         // and CLOB in simple case expressions currently. Test that they
1:f2dfe06:         // all work.
1:f2dfe06:         JDBC.assertUnorderedResultSet(
1:f2dfe06:             s.executeQuery(
1:f2dfe06:                 "select id, case b when is null then 'yes'"
1:f2dfe06:                 + " when is not null then 'no' end, "
1:f2dfe06:                 + "case c when is null then 'yes' when like 'abc' then 'abc'"
1:f2dfe06:                 + " when like 'abc%' then 'abc...' when is not null then 'no'"
1:f2dfe06:                 + " end "
1:f2dfe06:                 + "from lobs_for_simple_case"),
1:f2dfe06:             new String[][] {
1:f2dfe06:                 { "1", "no", "no" },
1:f2dfe06:                 { "2", "no", "abc..." },
1:f2dfe06:                 { "3", "yes", "yes" },
1:f2dfe06:             });
1:f2dfe06: 
1:f2dfe06:         s.execute("drop table lobs_for_simple_case");
1:2455f1a:     }
1:a1d6109: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = (BaseTestSuite)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6f52e78
/////////////////////////////////////////////////////////////////////////
1:         ps = prepareStatement(
1:                 "values case when true then ? else cast(? as integer) end");
1:         ParameterMetaData params = ps.getParameterMetaData();
1:         assertEquals(Types.INTEGER, params.getParameterType(1));
1:         assertEquals(Types.INTEGER, params.getParameterType(2));
1:         ps.setInt(1, 1);
1:         ps.setInt(2, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Before DERBY-2002, Derby accepted a CASE expression to have an
1:         // untyped NULL in all the result branches. Verify that an error
1:         // is raised.
1:         String[] allUntyped = {
1:             // The SQL standard says at least one result should not be an
1:             // untyped NULL, so expect these to fail.
1:             "values case when true then null "
1:                 + "when false then null else null end",
1: 
1:             // We're not able to tell the type if we have a mix of untyped
1:             // NULLs and untyped parameters.
1:             "values case when true then ? end", // implicit ELSE NULL
1:             "values case when true then null else ? end",
1:             "values case when true then ? when false then ? else null end",
1: 
1:             // These ones failed even before DERBY-2002.
1:             "values case when true then ? else ? end",
1:             "values case when true then ? when false then ? else ? end",
1:         for (String sql : allUntyped) {
1:             assertCompileError("42X87", sql);
commit:2bd5cbd
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:         // Test that you can have a typed parameter in the case operand.
/////////////////////////////////////////////////////////////////////////
1:         // Untyped parameter in the case operand. Should be able to infer
1:         // the type from the WHEN clauses.
1:         ps = prepareStatement("values case ? when 1 then 2 when 3 then 4 end");
1:         ParameterMetaData pmd = ps.getParameterMetaData();
1:         assertEquals(Types.INTEGER, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1: 
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps.setInt(1, 3);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "4");
1: 
1:         ps = prepareStatement(
1:                 "values case ? when cast(1.1 as double) then true "
1:                 + "when cast(1.2 as double) then false end");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.DOUBLE, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setDouble(1, 1.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:         ps.setDouble(1, 1.2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "false");
1:         ps.setDouble(1, 1.3);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         // Mixed types are accepted, as long as they are compatible.
1:         ps = prepareStatement(
1:                 "values case ? when 1 then 'one' when 2.1 then 'two' end");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps.setDouble(1, 1.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setDouble(1, 2.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1: 
1:         ps = prepareStatement(
1:                 "values case ? when 1 then 'one' when 2.1 then 'two'"
1:                 + " when cast(3 as bigint) then 'three' end");
1:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setInt(1, 3);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "three");
1: 
1:         ps.setDouble(1, 1.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setDouble(1, 2.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1:         ps.setDouble(1, 3.1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps = prepareStatement(
1:                 "values case ? when 'abcdef' then 1 "
1:                 + "when cast('abcd' as varchar(4)) then 2 end");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.VARCHAR, pmd.getParameterType(1));
1:         assertEquals(6, pmd.getPrecision(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setString(1, "abcdef");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         ps.setString(1, "abcd");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:         ps.setString(1, "ab");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1:         ps.setString(1, "abcdefghi");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         // The types in the WHEN clauses are incompatible, so the type of
1:         // the case operand cannot be inferred.
1:         assertCompileError("42818",
1:         assertCompileError("42818",
1:         // BLOB and CLOB are not comparable with anything.
1:         assertCompileError("42818",
1:                 "values case ? when cast(x'abcd' as blob) then true end");
1:         assertCompileError("42818",
1:                 "values case ? when cast('abcd' as clob) then true end");
1: 
1:         // Cannot infer type if both sides of the comparison are untyped.
1:         assertCompileError("42X35", "values case ? when ? then true end");
1:         assertCompileError("42X35", "values case ? when ? then true "
1:                                     + "when 1 then false end");
1: 
1:         // Should be able to infer type when the untyped parameter is prefixed
1:         // with plus or minus.
1:         ps = prepareStatement(
1:                 "values (case +? when 1 then 1 when 2.1 then 2 end, "
1:                         + "case -? when 1 then 1 when 2.1 then 2 end)");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1:         assertEquals(Types.DECIMAL, pmd.getParameterType(2));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(2));
1: 
1:         ps.setInt(1, 1);
1:         ps.setInt(2, -1);
1:         JDBC.assertFullResultSet(ps.executeQuery(),
1:                                  new String[][] {{ "1", "1" }});
1: 
1:         ps.setInt(1, 2);
1:         ps.setInt(2, -2);
1:         JDBC.assertFullResultSet(ps.executeQuery(),
1:                                  new String[][] {{ null, null }});
1: 
1:         ps.setDouble(1, 1.1);
1:         ps.setDouble(2, -1.1);
1:         JDBC.assertFullResultSet(ps.executeQuery(),
1:                                  new String[][] {{ null, null }});
1: 
1:         ps.setDouble(1, 2.1);
1:         ps.setDouble(2, -2.1);
1:         JDBC.assertFullResultSet(ps.executeQuery(),
1:                                  new String[][] {{ "2", "2" }});
1: 
1:         // If the untyped parameter is part of an arithmetic expression, its
1:         // type is inferred from that expression and not from the WHEN clause.
1:         ps = prepareStatement(
1:                 "values case 2*? when 2 then true when 3.0 then false end");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.INTEGER, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:         ps.setDouble(1, 1.5);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps = prepareStatement(
1:                 "values case 2.0*? when 2 then true when 3.0 then false end");
1:         pmd = ps.getParameterMetaData();
1:         assertEquals(Types.DECIMAL, pmd.getParameterType(1));
1:         assertEquals(ParameterMetaData.parameterNullable, pmd.isNullable(1));
1: 
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "true");
1:         ps.setDouble(1, 1.5);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "false");
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
commit:f2dfe06
/////////////////////////////////////////////////////////////////////////
1: import java.util.concurrent.atomic.AtomicInteger;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Simple case expressions should work in join conditions.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select x from (values 1, 2, 3) v1(x) "
1:                                 + "join (values 13, 14) v2(y) "
1:                                 + "on case y-x when 10 then true end"),
1:                 "3");
1:     }
1: 
1:     /**
1:      * Verify that the case operand expression is evaluated only once per
1:      * evaluation of the CASE expression.
1:      */
1:     public void testSingleEvaluationOfCaseOperand() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         s.execute("create function count_me(x int) returns int "
1:                 + "language java parameter style java external name '"
1:                 + getClass().getName() + ".countMe' no sql deterministic");
1: 
1:         callCount.set(0);
1: 
1:         JDBC.assertUnorderedResultSet(
1:             s.executeQuery(
1:                 "select case count_me(x) when 1 then 'one' when 2 then 'two' "
1:                 + "when 3 then 'three' end from (values 1, 2, 3) v(x)"),
1:             new String[][] { {"one"}, {"two"}, {"three"} });
1: 
1:         // The CASE expression is evaluated once per row. There are three
1:         // rows. Expect that the COUNT_ME function was only invoked once
1:         // per row.
1:         assertEquals(3, callCount.get());
1:     }
1: 
1:     /** Count how many times countMe() has been called. */
1:     private static final AtomicInteger callCount = new AtomicInteger();
1: 
1:     /**
1:      * Stored function that keeps track of how many times it has been called.
1:      * @param i an integer
1:      * @return the integer {@code i}
1:      */
1:     public static int countMe(int i) {
1:         callCount.incrementAndGet();
1:         return i;
1:     }
1: 
1:     /**
1:      * Test that large objects can be used as case operands.
1:      */
1:     public void testLobAsCaseOperand() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // BLOB and CLOB are allowed in the case operand.
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case cast(null as blob) when is null then 'yes' end"),
1:             "yes");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case cast(null as clob) when is null then 'yes' end"),
1:             "yes");
1: 
1:         // Comparisons between BLOB and BLOB, or between CLOB and CLOB, are
1:         // not allowed, so expect a compile-time error for these queries.
1:         assertCompileError("42818",
1:                 "values case cast(null as blob) "
1:                 + "when cast(null as blob) then true end");
1:         assertCompileError("42818",
1:                 "values case cast(null as clob) "
1:                 + "when cast(null as clob) then true end");
1: 
1:         // Now create a table with some actual LOBs in them.
1:         s.execute("create table lobs_for_simple_case("
1:                 + "id int generated always as identity, b blob, c clob)");
1: 
1:         PreparedStatement insert = prepareStatement(
1:                 "insert into lobs_for_simple_case(b, c) values (?, ?)");
1: 
1:         // A small one.
1:         insert.setBytes(1, new byte[] {1, 2, 3});
1:         insert.setString(2, "small");
1:         insert.executeUpdate();
1: 
1:         // And a big one (larger than 32K means it will be streamed
1:         // from store, instead of being returned as a materialized value).
1:         insert.setBinaryStream(1, new LoopingAlphabetStream(40000));
1:         insert.setCharacterStream(2, new LoopingAlphabetReader(40000));
1:         insert.executeUpdate();
1: 
1:         // And a NULL.
1:         insert.setNull(1, Types.BLOB);
1:         insert.setNull(2, Types.CLOB);
1:         insert.executeUpdate();
1: 
1:         // IS [NOT] NULL can be used on both BLOB and CLOB. LIKE can be
1:         // used on CLOB. Those are the only predicates supported on BLOB
1:         // and CLOB in simple case expressions currently. Test that they
1:         // all work.
1:         JDBC.assertUnorderedResultSet(
1:             s.executeQuery(
1:                 "select id, case b when is null then 'yes'"
1:                 + " when is not null then 'no' end, "
1:                 + "case c when is null then 'yes' when like 'abc' then 'abc'"
1:                 + " when like 'abc%' then 'abc...' when is not null then 'no'"
1:                 + " end "
1:                 + "from lobs_for_simple_case"),
1:             new String[][] {
1:                 { "1", "no", "no" },
1:                 { "2", "no", "abc..." },
1:                 { "3", "yes", "yes" },
1:             });
1: 
1:         s.execute("drop table lobs_for_simple_case");
commit:d75118e
/////////////////////////////////////////////////////////////////////////
1: 
1:         // The EXISTS predicate can only be used in the WHEN operand if
1:         // the CASE operand is a BOOLEAN.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values case true when exists" +
1:                                "(select * from sysibm.sysdummy1) then 1 end"),
1:                 "1");
1:         assertCompileError("42818",
1:                 "values case 1 when exists" +
1:                 "(select * from sysibm.sysdummy1) then 1 end");
1: 
1:         // Scalar subqueries are allowed in the operands.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery(
1:                         "values case (select ibmreqd from sysibm.sysdummy1) "
1:                         + "when 'N' then 'no' when 'Y' then 'yes' end"),
1:                 "yes");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values case 'Y' when "
1:                                 + "(select ibmreqd from sysibm.sysdummy1) "
1:                                 + "then 'yes' end"),
1:                 "yes");
1: 
1:         // Subquery returns two columns - fail.
1:         assertCompileError(
1:                 "42X39",
1:                 "values case (select ibmreqd, 1 from sysibm.sysdummy1)"
1:                 + " when 'Y' then true end");
1:         assertCompileError(
1:                 "42X39",
1:                 "values case 'Y' when "
1:                 + "(select ibmreqd, 1 from sysibm.sysdummy1) then true end");
1: 
1:         // Subquery returns multiple rows - fail.
1:         assertStatementError("21000", s,
1:             "values case (select 1 from sys.systables) when 1 then true end");
1:         assertStatementError("21000", s,
1:             "values case 1 when (select 1 from sys.systables) then true end");
1: 
1:         // Subquery returns zero rows, which is converted to NULL for scalar
1:         // subqueries.
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case (select ibmreqd from sysibm.sysdummy1 where false)"
1:                 + " when is null then 'yes' end"),
1:             "yes");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case true when true then "
1:                 + "(select ibmreqd from sysibm.sysdummy1 where false) end"),
1:             null);
commit:13d34b0
/////////////////////////////////////////////////////////////////////////
1: 
1:         // A sequence cannot be accessed anywhere in a CASE expression.
1:         s.execute("create sequence d1576_s start with 1");
1:         assertCompileError(
1:                 "42XAH",
1:                 "values case next value for d1576_s when 1 then 1 else 0 end");
1:         assertCompileError(
1:                 "42XAH",
1:                 "values case 1 when next value for d1576_s then 1 else 0 end");
1:         assertCompileError(
1:                 "42XAH",
1:                 "values case 1 when 1 then next value for d1576_s else 0 end");
1: 
1:         // Instead, access the sequence value in a nested query.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery(
1:                     "select case x when 1 then 1 else 0 end from "
1:                     + "(values next value for d1576_s) v(x)"),
1:                 "1");
1: 
1:         s.execute("drop sequence d1576_s restrict");
1: 
1:         // Window functions are allowed.
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery(
1:                     "select case row_number() over () when 1 then 'one' "
1:                     + "when 2 then 'two' end from (values 1, 1, 1) v(x)"),
1:                 new String[][] { {"one"}, {"two"}, {null} });
1: 
0:         // Parameters in the case operand have to be typed for now, since the
0:         // current type inference doesn't handle multiple types very well.
1:         PreparedStatement ps = prepareStatement(
1:                 "values case cast(? as integer) "
1:                 + "when 1 then 'one' when 2 then 'two' end");
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "one");
1:         ps.setInt(1, 2);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "two");
1:         ps.setInt(1, 3);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         // This one fails to compile because an integer cannot be checked
1:         // with LIKE.
1:         assertCompileError("42884",
1:                 "values case cast(? as integer) "
1:                 + "when 1 then 1 when like 'abc' then 2 end");
1: 
0:         // Should have been able to infer the type in this case, but
0:         // expect failure for now.
0:         assertCompileError("42Z09",
0:                            "values case ? when 1 then 2 when 3 then 4 end");
1: 
0:         // Should have detected that the types in the WHEN clauses are
0:         // incompatible (the first requires the operand to be a number, the
0:         // second requires it to be a string). Instead, for now, it fails
0:         // because untyped parameters have been forbidden in the case operand.
0:         // Used to fail with "Invalid character string format for type int"
0:         // during execution before it was forbidden.
0:         assertCompileError("42Z09",
1:             "values case ? when 1 then true when like 'abc' then false end");
1: 
0:         // Should have detected that the types in the WHEN clauses are
0:         // incompatible (the first requires the operand to be a string, the
0:         // second requires it to be a number). Instead, for now, it fails
0:         // because untyped parameters have been forbidden in the case operand.
0:         // Used to fail with an assert failure at compile time before it was
0:         // forbidden.
0:         assertCompileError("42Z09",
1:             "values case ? when like 'abc' then true when 1 then false end");
commit:2455f1a
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tests for the simple case syntax added in DERBY-1576.
1:      */
1:     public void testSimpleCaseSyntax() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Simplest of the simple cases. SQL:1999 syntax, which allows a
1:         // single operand per WHEN clause, and the operand is a value
1:         // expression.
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select i, case i when 0 then 'zero' "
1:                 + "when 1 then 'one' when 1+1 then 'two' "
1:                 + "else 'many' end from "
1:                 + "(values 0, 1, 2, 3, cast(null as int)) v(i)"),
1:             new String[][] {
1:                 {"0", "zero"},
1:                 {"1", "one"},
1:                 {"2", "two"},
1:                 {"3", "many"},
1:                 {null, "many"}
1:             });
1: 
1:         // SQL:2003 added feature F262 Extended CASE Expression, which
1:         // allows more complex WHEN operands. Essentially, it allows any
1:         // last part of a predicate (everything after the left operand).
1:         JDBC.assertFullResultSet(s.executeQuery(
1:                 "select i, case i when < 0 then 'negative' "
1:                         + "when < 10 then 'small' "
1:                         + "when between 10 and 20 then 'medium' "
1:                         + "when in (19, 23, 29, 37, 41) then 'prime' "
1:                         + "when = some (values 7, 42) then 'lucky number' "
1:                         + "when >= 40 then 'big' end "
1:                         + "from (values -1, 0, 1, 2, 3, 8, 9, 10, 17, 19, "
1:                         + "29, 37, 38, 39, 40, 41, 42, 50) v(i) order by i"),
1:             new String[][] {
1:                 { "-1", "negative" },
1:                 { "0", "small" },
1:                 { "1", "small" },
1:                 { "2", "small" },
1:                 { "3", "small" },
1:                 { "8", "small" },
1:                 { "9", "small" },
1:                 { "10", "medium" },
1:                 { "17", "medium" },
1:                 { "19", "medium" },
1:                 { "29", "prime" },
1:                 { "37", "prime" },
1:                 { "38", null },
1:                 { "39", null },
1:                 { "40", "big" },
1:                 { "41", "prime" },
1:                 { "42", "lucky number" },
1:                 { "50", "big" },
1:             });
1: 
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select c, case c "
1:                 + "when like 'abc%' then 0 "
1:                 + "when like 'x%%' escape 'x' then 1 "
1:                 + "when = all (select ibmreqd from sysibm.sysdummy1) then 2 "
1:                 + "when 'xyz' || 'zyx' then 3 "
1:                 + "when is null then 4 "
1:                 + "when is not null then 5 end "
1:                 + "from (values 'abcdef', 'xyzzyx', '%s', 'hello', "
1:                 + "cast(null as char(1)), 'Y', 'N') v(c)"),
1:             new String[][] {
1:                 { "abcdef", "0" },
1:                 { "xyzzyx", "3" },
1:                 { "%s", "1" },
1:                 { "hello", "5" },
1:                 { null, "4" },
1:                 { "Y", "2" },
1:                 { "N", "5" },
1:             });
1: 
1:         // SQL:2011 added feature F263 Comma-separated predicates in simple
1:         // CASE expression, which allows multiple operands per WHEN clause.
1:         JDBC.assertFullResultSet(s.executeQuery(
1:                 "select i, case i "
1:                 + "when between 2 and 3, 5, =7 then 'prime' "
1:                 + "when <1, >7 then 'out of range' "
1:                 + "when is not null then 'small' end "
1:                 + "from (values 0, 1, 2, 3, 4, 5, 6, 7, 8, cast(null as int)) "
1:                 + "as v(i) order by i"),
1:             new String[][] {
1:                 { "0", "out of range" },
1:                 { "1", "small" },
1:                 { "2", "prime" },
1:                 { "3", "prime" },
1:                 { "4", "small" },
1:                 { "5", "prime" },
1:                 { "6", "small" },
1:                 { "7", "prime" },
1:                 { "8", "out of range" },
1:                 { null, null },
1:             });
1: 
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select c, case c "
1:                 + "when in ('ab', 'cd'), like '_' then 'matched' "
1:                 + "else 'not matched' end "
1:                 + "from (values cast('a' as varchar(1)), 'b', 'c', 'ab', "
1:                 + "'cd', 'ac', 'abc') v(c)"),
1:             new String[][] {
1:                 { "a",   "matched" },
1:                 { "b",   "matched" },
1:                 { "c",   "matched" },
1:                 { "ab",  "matched" },
1:                 { "cd",  "matched" },
1:                 { "ac",  "not matched" },
1:                 { "abc", "not matched" },
1:             });
1: 
1:         // Untyped null is not allowed as CASE operand. Use typed null instead.
1:         assertCompileError("42X01", "values case null when 1 then 'one' end");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case cast(null as int) when 1 then 'one' end"),
1:             null);
1: 
1:         // Untyped null is not allowed as WHEN operand. Use IS NULL instead.
1:         assertCompileError("42X01", "values case 1 when null then 'null' end");
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select i, case i when is null then 1 when is not null "
1:                 + "then 2 else 3 end from (values 1, cast(null as int)) v(i)"),
1:             new String[][] { { "1", "2" }, { null, "1" } });
1: 
1:         // Non-deterministic functions are not allowed in the case operand.
1:         assertCompileError("42Y98",
1:                 "values case sysfun.random() when 1 then true else false end");
1:         assertCompileError("42Y98",
1:                 "values case (values sysfun.random()) "
1:                 + "when 1 then true else false end");
1: 
1:         // Deterministic functions, on the other hand, are allowed.
1:         JDBC.assertFullResultSet(s.executeQuery(
1:                 "select case sysfun.sin(angle) when < 0 then 'negative' "
1:                         + "when > 0 then 'positive' end "
1:                         + "from (values -pi()/2, 0, pi()/2) v(angle) "
1:                         + "order by angle"),
1:             new String[][] { {"negative"}, {null}, {"positive"} });
1: 
1:         // Non-deterministic functions can be used outside of the case operand.
1:         JDBC.assertDrainResults(
1:             s.executeQuery(
1:                 "values case 1 when sysfun.random() then sysfun.random() end"),
1:             1);
1: 
1:         // Scalar subqueries are allowed in the case operand.
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("values case (values 1) when 1 then true end"),
1:                 "true");
1: 
1:         // Non-scalar subqueries are not allowed.
1:         assertCompileError(
1:                 "42X39", "values case (values (1, 2)) when 1 then true end");
1:         assertStatementError(
1:                 "21000", s, "values case (values 1, 2) when 1 then true end");
1: 
1:         // The type of the CASE operand must be compatible with the types
1:         // of all the WHEN operands.
1:         assertCompileError("42818", "values case 1 when true then 'yes' end");
1:         assertCompileError("42818",
1:                 "values case 1 when 1 then 'yes' when 2 then 'no' "
1:                 + "when 'three' then 'maybe' end");
1:         JDBC.assertSingleValueResultSet(s.executeQuery(
1:                 "values case cast(1 as bigint)"
1:                 + " when cast(1 as smallint) then 'yes' end"),
1:             "yes");
1:     }
commit:39e20ff
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Regression test case for DERBY-6577. */
1:     public void testQuantifiedComparison() throws SQLException {
1:         // This query used to return wrong results.
1:         JDBC.assertUnorderedResultSet(createStatement().executeQuery(
1:                 "select c, case when c = all (values 'Y') then true end "
1:                 + "from (values 'Y', 'N') v(c)"),
1:             new String[][] { { "N", null }, { "Y", "true" }});
1:     }
commit:5d7388d
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test how untyped NULLs are handled.
1:      */
1:     public void testUntypedNulls() throws SQLException {
1:         Statement s = createStatement();
1: 
0:         // When all branches specify NULL, then Derby currently returns NULL
0:         // with type CHAR(1). It should have raised an error according to the
0:         // SQL standard. See DERBY-2002.
0:         String[] allNull = {
1:             "values case when true then null end",
1:             "values case when true then null else null end",
0:             "values case when true then null when false then null else null end"
1:         };
0:         for (String sql : allNull) {
0:             JDBC.assertSingleValueResultSet(s.executeQuery(sql), null);
1:         }
1: 
1:         // Check that expressions with untyped NULLs compile as long as
1:         // there is at least one typed expression.
1:         JDBC.assertFullResultSet(s.executeQuery(
1:                 "select case when a then 1 when b then null end, "
1:                     + "case when a then null when b then 1 end, "
1:                     + "case when a then null when b then null else 1 end "
1:                     + "from (values (false, false), (false, true), "
1:                     + " (true, false), (true, true)) v(a, b) order by a, b"),
1:             new Object[][] {
1:                 { null, null, 1    },
1:                 { null, 1,    null },
1:                 { 1,    null, null },
1:                 { 1,    null, null },
1:             },
1:             false);
1: 
1:         // When there is a typed NULL, its type has to be compatible with
1:         // the types of the other expressions.
1:         assertCompileError("42X89",
1:             "values case when 1<>1 then 'abc' else cast(null as smallint) end");
1:     }
commit:d6b5ab3
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test that parameters can be used in CASE expressions.
1:      */
1:     public void testParameters() throws SQLException {
1:         // If all of the result expressions are untyped parameters, the
1:         // type cannot be determined, and an error should be raised.
1:         assertCompileError("42X87", "values case when true then ? else ? end");
1: 
1:         // If at least one result expression is typed, the parameter should
1:         // get its type from it.
1:         PreparedStatement ps = prepareStatement(
1:                 "values case when true then ? else 1 end");
1: 
1:         // DERBY-6567: The result should be nullable, since the parameter
1:         // could be set to null. It used to be reported as not nullable.
1:         assertEquals(ResultSetMetaData.columnNullable,
1:                      ps.getMetaData().isNullable(1));
1: 
1:         ps.setNull(1, Types.INTEGER);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), null);
1: 
1:         ps.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         // Parameters in the WHEN clause can be untyped. They will
1:         // implicitly get the BOOLEAN type.
1:         ps = prepareStatement("values case when ? then 1 else 0 end");
1:         assertEquals(Types.BOOLEAN,
1:                      ps.getParameterMetaData().getParameterType(1));
1: 
1:         ps.setBoolean(1, true);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1: 
1:         ps.setBoolean(1, false);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1: 
1:         ps.setNull(1, Types.BOOLEAN);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "0");
1:     }
1: 
commit:f273581
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.util.ArrayList;
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Verify that NOT elimination produces the correct results.
1:      * DERBY-6563.
1:      */
1:     public void testNotElimination() throws SQLException {
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table d6563(b1 boolean, b2 boolean, b3 boolean)");
1: 
1:         // Fill the table with all possible combinations of true/false/null.
1:         Boolean[] universe = { true, false, null };
1:         PreparedStatement insert = prepareStatement(
1:                 "insert into d6563 values (?, ?, ?)");
1:         for (Boolean v1 : universe) {
1:             insert.setObject(1, v1);
1:             for (Boolean v2 : universe) {
1:                 insert.setObject(2, v2);
1:                 for (Boolean v3 : universe) {
1:                     insert.setObject(3, v3);
1:                     insert.executeUpdate();
1:                 }
1:             }
1:         }
1: 
1:         // Truth table for
1:         // B1, B2, B3, WHEN B1 THEN B2 ELSE B3, NOT (WHEN B1 THEN B2 ELSE B3).
1:         Object[][] expectedRows = {
1:             { false, false, false, false, true  },
1:             { false, false, true,  true,  false },
1:             { false, false, null,  null,  null  },
1:             { false, true,  false, false, true  },
1:             { false, true,  true,  true,  false },
1:             { false, true,  null,  null,  null  },
1:             { false, null,  false, false, true  },
1:             { false, null,  true,  true,  false },
1:             { false, null,  null,  null,  null  },
1:             { true,  false, false, false, true  },
1:             { true,  false, true,  false, true  },
1:             { true,  false, null,  false, true  },
1:             { true,  true,  false, true,  false },
1:             { true,  true,  true,  true,  false },
1:             { true,  true,  null,  true,  false },
1:             { true,  null,  false, null,  null  },
1:             { true,  null,  true,  null,  null  },
1:             { true,  null,  null,  null,  null  },
1:             { null,  false, false, false, true  },
1:             { null,  false, true,  true,  false },
1:             { null,  false, null,  null,  null  },
1:             { null,  true,  false, false, true  },
1:             { null,  true,  true,  true,  false },
1:             { null,  true,  null,  null,  null  },
1:             { null,  null,  false, false, true  },
1:             { null,  null,  true,  true,  false },
1:             { null,  null,  null,  null,  null  },
1:         };
1: 
1:         // Verify the truth table. Since NOT elimination is not performed on
1:         // expressions in the SELECT list, this passed even before the fix.
1:         JDBC.assertFullResultSet(
1:             s.executeQuery(
1:                 "select b1, b2, b3, case when b1 then b2 else b3 end, "
1:                         + "not case when b1 then b2 else b3 end "
1:                         + "from d6563 order by b1, b2, b3"),
1:             expectedRows, false);
1: 
1:         // Now take only those rows where the NOT CASE expression evaluated
1:         // to TRUE, and strip off the expression columns at the end.
1:         ArrayList<Object[]> rows = new ArrayList<Object[]>();
1:         for (Object[] row : expectedRows) {
1:             if (row[4] == Boolean.TRUE) {
1:                 rows.add(Arrays.copyOf(row, 3));
1:             }
1:         }
1: 
1:         // Assert that those are the only rows returned if the NOT CASE
1:         // expression is used as a predicate. This query used to return a
1:         // different set of rows before the fix.
1:         expectedRows = rows.toArray(new Object[rows.size()][]);
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from d6563 where "
1:                         + "not case when b1 then b2 else b3 end "
1:                         + "order by b1, b2, b3"),
1:                 expectedRows, false);
1:     }
1: 
commit:aaac214
/////////////////////////////////////////////////////////////////////////
1:      * Before DERBY-6423, boolean expressions (such as A OR B, or A AND B)
1:      * were not accepted in THEN and ELSE clauses.
1:      */
1:     public void testBooleanExpressions() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Test both with and without parentheses around the expressions.
1:         // Those with parentheses used to work, and those without used to
1:         // cause syntax errors. Now both should work.
1:         JDBC.assertFullResultSet(
1:             s.executeQuery(
1:                 "select case when a or b then b or c else a or c end,\n" +
1:                 "   case when a and b then b and c else a and c end,\n" +
1:                 "   case when (a or b) then (b or c) else (a or c) end,\n" +
1:                 "   case when (a and b) then (b and c) else (a and c) end\n" +
1:                 "from (values (true, true, true), (true, true, false),\n" +
1:                 "             (true, false, true), (true, false, false),\n" +
1:                 "             (false, true, true), (false, true, false),\n" +
1:                 "             (false, false, true), (false, false, false)\n" +
1:                 "      ) v(a, b, c)\n" +
1:                 "order by a desc, b desc, c desc"),
1:             new String[][] {
1:                 { "true", "true", "true", "true" },
1:                 { "true", "false", "true", "false" },
1:                 { "true", "true", "true", "true" },
1:                 { "false", "false", "false", "false" },
1:                 { "true", "false", "true", "false" },
1:                 { "true", "false", "true", "false" },
1:                 { "true", "false", "true", "false" },
1:                 { "false", "false", "false", "false" },
1:             });
1:     }
1: 
1:     /**
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f5efedc
/////////////////////////////////////////////////////////////////////////
1:         // Make sure metadata has correct type for various null handling
1:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:         JDBC.assertSingleValueResultSet(rs, null);    
1:         
1:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE ELSE NULL END from t");
1:         rsmd = rs.getMetaData();
1:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:         // should be nullable since it returns NULL #:)
1:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:         JDBC.assertSingleValueResultSet(rs, null);  
1:         
1:         // and with an implicit NULL return.
1:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE END from t");
1:         rsmd = rs.getMetaData();
1:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:         // should be nullable since it returns NULL #:)
1:         assertEquals(ResultSetMetaData.columnNullable, rsmd.isNullable(1));
1:         JDBC.assertSingleValueResultSet(rs, null);  
1:         
1:         // and no possible NULL return.
1:         
1:         rs = s.executeQuery("SELECT CASE WHEN 1 = 0 THEN 6 ELSE 4 END from t");
1:         rsmd = rs.getMetaData();
1:         assertEquals(java.sql.Types.INTEGER, rsmd.getColumnType(1));
1:         // should be nullable since it returns NULL #:)
1:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:         JDBC.assertSingleValueResultSet(rs, "4"); 
1:         
1:         rs = s.executeQuery("SELECT CASE WHEN 1 = 1 THEN 6 ELSE 4 END from t");
1:         rsmd = rs.getMetaData();
1:         assertEquals(java.sql.Types.INTEGER, rsmd.getColumnType(1));
1:         // should be nullable since it returns NULL #:)
1:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:         JDBC.assertSingleValueResultSet(rs, "6");
1:         
commit:b959945
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Test various statements that 
1:      *
1:      */
1:     public void testWhenNonBoolean() {
1:         
1:         // DERBY-2809: BOOLEAN datatype was forced upon
1:         // unary expressions that were not BOOLEAN, such
1:         // as SQRT(?)
1:         String[] unaryOperators = {
1:                 "SQRT(?)", "SQRT(9)",
1:                 "UPPER(?)", "UPPER('haight')",
1:                 "LOWER(?)", "LOWER('HAIGHT')",
1:         };
1:         for (int i = 0; i < unaryOperators.length; i++)
1:         {
1:             assertCompileError("42X88",
1:                "VALUES CASE WHEN " + unaryOperators[i] +
1:                " THEN 3 ELSE 4 END");
1:         }
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:78cb2da
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test fix for DERBY-3032. Fix ClassCastException if SQL NULL is returned from conditional.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDerby3032() throws SQLException 
1:     {
1:         Statement s = createStatement();
1:         
1: 
1:         s.executeUpdate("create table t (d date, vc varchar(30))");
1:         s.executeUpdate("insert into t values(CURRENT_DATE, 'hello')");
1:         ResultSet rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 1 THEN CURRENT_DATE ELSE NULL END from t)");
1:         JDBC.assertDrainResults(rs,1);
1:         
1:         // Make sure null gets cast properly to date type to avoid cast exception. DERBY-3032
1:         rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 1 THEN NULL  ELSE CURRENT_DATE  END from t)");
1:         JDBC.assertEmpty(rs);
1:         
1:         rs = s.executeQuery("SELECT d from t where d = (SELECT CASE WHEN 1 = 0 THEN CURRENT_DATE  ELSE NULL END from t)");
1:         JDBC.assertEmpty(rs);
1:         
0:         // Make sure metadata has correct type
1:         rs = s.executeQuery("SELECT CASE WHEN 1 = 1 THEN NULL  ELSE CURRENT_DATE  END from t");
1:         ResultSetMetaData rsmd = rs.getMetaData();
1:         assertEquals(java.sql.Types.DATE, rsmd.getColumnType(1));
1:         // should be nullable since it returns NULL #:)
0:         assertTrue(rsmd.isNullable(1) == ResultSetMetaData.columnNullable);
0:         JDBC.assertSingleValueResultSet(rs, null);        
1:     }
commit:1cf00e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
1:        
/////////////////////////////////////////////////////////////////////////
1:                 
/////////////////////////////////////////////////////////////////////////
1:             colType < SQLUtilities.SQLTypes.length;
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:      
1:     
1:   
1:     
author:Army
-------------------------------------------------------------------------------
commit:4c2072e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:      * Test a query that has many WHEN conditions in it.  This is mostly
1:      * checking for the performance regression filed as DERBY-2986.  That
1:      * regression may not be noticeable in the scope of the full regression
1:      * suite, but if this test is run standalone then this fixture could
1:      * still be useful.
1:      */
1:     public void testMultipleWhens() throws SQLException
1:     {
1:         Statement s = createStatement();
1:         JDBC.assertFullResultSet(
1:             s.executeQuery(
1:                 "values CASE WHEN 10 = 1 THEN 'a' " +
1:                 "WHEN 10 = 2 THEN 'b' " +
1:                 "WHEN 10 = 3 THEN 'c' " +
1:                 "WHEN 10 = 4 THEN 'd' " +
1:                 "WHEN 10 = 5 THEN 'e' " +
1:                 "WHEN 10 = 6 THEN 'f' " +
1:                 "WHEN 10 = 7 THEN 'g' " +
1:                 "WHEN 10 = 8 THEN 'h' " +
1:                 "WHEN 10 = 11 THEN 'i' " +
1:                 "WHEN 10 = 12 THEN 'j' " +
1:                 "WHEN 10 = 15 THEN 'k' " +
1:                 "WHEN 10 = 16 THEN 'l' " +
1:                 "WHEN 10 = 23 THEN 'm' " +
1:                 "WHEN 10 = 24 THEN 'n' " +
1:                 "WHEN 10 = 27 THEN 'o' " +
1:                 "WHEN 10 = 31 THEN 'p' " +
1:                 "WHEN 10 = 41 THEN 'q' " +
1:                 "WHEN 10 = 42 THEN 'r' " +
1:                 "WHEN 10 = 50 THEN 's' " +
1:                 "ELSE '*' END"),
1:             new String[][] {{"*"}});
1: 
1:         s.close();
1:     }
1: 
1:     /**
commit:a1d6109
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.CaseExpressionTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.sql.ResultSet;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import org.apache.derbyTesting.functionTests.tests.lang.CastingTest;
1: 
1: public class CaseExpressionTest extends BaseJDBCTestCase {
1: 
1:         // Results if the Case Expression evaluates to a column reference :
1:         //
1:         // 1. SELECT CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END
1:         // 2. SELECT CASE WHEN 1 = 1 THEN
1:         //       (CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END)
1:         //       ELSE NULL END
1:         //
1:         private static String[][] columnReferenceResults = {
1:             /*SMALLINT*/ {null,"0","1","2"},
1:             /*INTEGER*/ {null,"0","1","21"},
1:             /*BIGINT*/ {null,"0","1","22"},
1:             /*DECIMAL(10,5)*/ {null,"0.00000","1.00000","23.00000"},
1:             /*REAL*/ {null,"0.0","1.0","24.0"},
1:             /*DOUBLE*/ {null,"0.0","1.0","25.0"},
1:             /*CHAR(60)*/ {
1:                 null,
1:                 "0                                                           ",
1:                 "aa                                                          ",
1:                 "2.0                                                         "},
1:             /*VARCHAR(60)*/ {null,"0","aa","15:30:20"},
1:             /*LONG VARCHAR*/ {null,"0","aa","2000-01-01 15:30:20"},
1:             /*CHAR(60) FOR BIT DATA*/ {
1:                 null,
1:                 "10aa20202020202020202020202020202020202020202020202020202020" +
1:                 "202020202020202020202020202020202020202020202020202020202020",
1:                 null,
1:                 "10aaaa202020202020202020202020202020202020202020202020202020" +
1:                 "202020202020202020202020202020202020202020202020202020202020"},
1:             /*VARCHAR(60) FOR BIT DATA*/ {null,"10aa",null,"10aaba"},
1:             /*LONG VARCHAR FOR BIT DATA*/ {null,"10aa",null,"10aaca"},
1:             /*CLOB(1k)*/ {null,"13","14",null},
1:             /*DATE*/ {null,"2000-01-01","2000-01-01",null},
1:             /*TIME*/ {null,"15:30:20","15:30:20","15:30:20"},
1:             /*TIMESTAMP*/ {
1:                 null,
1:                 "2000-01-01 15:30:20.0",
1:                 "2000-01-01 15:30:20.0",
1:                 "2000-01-01 15:30:20.0"},
1:             /*BLOB(1k)*/ {null,null,null,null},
1:         };
1: 
1:         // Results if the Case Expression evaluates to a NULL value :
1:         //
1:         // 3. SELECT CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END
1:         // 4. SELECT CASE WHEN 1 = 1 THEN
1:         //       (CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END)
1:         //         ELSE NULL END
1:         // 5. SELECT CASE WHEN 1 = 1 THEN NULL ELSE
1:         //         (CASE WHEN 1 = 1 THEN <column reference> ELSE NULL END) END
1:         // 6. SELECT CASE WHEN 1 = 1 THEN NULL ELSE
1:         //         (CASE WHEN 1 = 1 THEN NULL ELSE <column reference> END) END
1:         //
1:         private static String[][] nullValueResults  = {
1:             /*SMALLINT*/ {null,null,null,null},
1:             /*INTEGER*/ {null,null,null,null},
1:             /*BIGINT*/ {null,null,null,null},
1:             /*DECIMAL(10,5)*/ {null,null,null,null},
1:             /*REAL*/ {null,null,null,null},
1:             /*DOUBLE*/ {null,null,null,null},
1:             /*CHAR(60)*/ {null,null,null,null},
1:             /*VARCHAR(60)*/ {null,null,null,null},
1:             /*LONG VARCHAR*/ {null,null,null,null},
1:             /*CHAR(60) FOR BIT DATA*/ {null,null,null,null},
1:             /*VARCHAR(60) FOR BIT DATA*/ {null,null,null,null},
1:             /*LONG VARCHAR FOR BIT DATA*/ {null,null,null,null},
1:             /*CLOB(1k)*/ {null,null,null,null},
1:             /*DATE*/ {null,null,null,null},
1:             /*TIME*/ {null,null,null,null},
1:             /*TIMESTAMP*/ {null,null,null,null},
1:             /*BLOB(1k)*/ {null,null,null,null},
1:         };
1: 
1:     public CaseExpressionTest(String name) {
1:         super(name);
1:     }
1: 
1:     public void testAllDatatypesCombinationsForCaseExpressions()
1:     throws SQLException
1:     {
1:         Statement s = createStatement();
1: 
1:         /* 1. Column Reference in the THEN node, and NULL in
1:          * the ELSE node.
1:          */
1:         testCaseExpressionQuery(s, columnReferenceResults,
1:             "SELECT CASE WHEN 1 = 1 THEN ",
1:             " ELSE NULL END from AllDataTypesTable");
1: 
1:         /* 2. Test Column Reference nested in the THEN's node THEN node,
1:          * NULL's elsewhere.
1:          */
1:         testCaseExpressionQuery(s, columnReferenceResults,
1:             "SELECT CASE WHEN 1 = 1 THEN (CASE WHEN 1 = 1 THEN ",
1:             " ELSE NULL END) ELSE NULL END from AllDataTypesTable");
1: 
1:         /* 3. NULL in the THEN node, and a Column Reference in
1:          * the ELSE node.
1:          */
1:         testCaseExpressionQuery(s, nullValueResults,
1:             "SELECT CASE WHEN 1 = 1 THEN NULL ELSE ",
1:             " END from AllDataTypesTable");
1: 
1:         /* 4. Test Column Reference nested in the THEN's node ELSE node,
1:          * NULL's elsewhere.
1:          */
1:         testCaseExpressionQuery(s, nullValueResults,
1:             "SELECT CASE WHEN 1 = 1 THEN (CASE WHEN 1 = 1 THEN NULL ELSE ",
1:             " END) ELSE NULL END from AllDataTypesTable");
1: 
1:         /* 5. Test Column Reference nested in the ELSE's node THEN node,
1:          * NULL's elsewhere.
1:          */
1:         testCaseExpressionQuery(s, nullValueResults,
1:             "SELECT CASE WHEN 1 = 1 THEN NULL ELSE (CASE WHEN 1 = 1 THEN ",
1:             " ELSE NULL END) END from AllDataTypesTable");
1: 
1:         /* 6. Test Column Reference nested in the ELSE's node ELSE node,
1:          * NULL's elsewhere.
1:          */
1:         testCaseExpressionQuery(s, nullValueResults,
1:             "SELECT CASE WHEN 1 = 1 THEN NULL " +
1:             "ELSE (CASE WHEN 1 = 1 THEN NULL ELSE ",
1:             " END) END from AllDataTypesTable");
1: 
1:         s.close();
1:     }
1: 
1:     /**
1:      * Runs the test fixtures in embedded.
1:      *
1:      * @return test suite
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite)
1:             TestConfiguration.embeddedSuite(CaseExpressionTest.class);
1: 
1:         return new CleanDatabaseTestSetup(suite) {
1:             /**
1:              * Creates the table used in the test cases.
1:              */
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 SQLUtilities.createAndPopulateAllDataTypesTable(s);
1:             }
1:         };
1:     }
1: 
1:     /**
1:      * Execute the received caseExpression on the received Statement
1:      * and check the results against the receieved expected array.
1:      */
1:     private void testCaseExpressionQuery(Statement st,
1:         String [][] expRS, String caseExprBegin, String caseExprEnd)
1:         throws SQLException
1:     {
1:         ResultSet rs;
1:         int colType;
1:         int row;
1: 
1:         for (colType = 0;
0:             colType < CastingTest.SQLTypes.length;
1:             colType++)
1:         {
1:             rs = st.executeQuery(
1:                 caseExprBegin +
1:                 SQLUtilities.allDataTypesColumnNames[colType] +
1:                 caseExprEnd);
1: 
1:             row = 0;
1:             while (rs.next()) {
1:                 String val = rs.getString(1);
1:                 assertEquals(expRS[colType][row], val);
1:                 row++;
1:             }
1:             rs.close();
1:         }
1:     }
1: }
============================================================================