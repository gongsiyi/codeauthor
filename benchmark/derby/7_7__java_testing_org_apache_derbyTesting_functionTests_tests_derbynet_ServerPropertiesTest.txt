1:177c065: /*
32:177c065: 
1:177c065:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.ServerPropertiesTest
1:177c065: 
1:177c065:    Licensed to the Apache Software Foundation (ASF) under one or more
1:177c065:    contributor license agreements.  See the NOTICE file distributed with
1:177c065:    this work for additional information regarding copyright ownership.
1:177c065:    The ASF licenses this file to You under the Apache License, Version 2.0
1:177c065:    (the "License"); you may not use this file except in compliance with
1:177c065:    the License.  You may obtain a copy of the License at
1:177c065: 
1:177c065:       http://www.apache.org/licenses/LICENSE-2.0
1:177c065: 
1:177c065:    Unless required by applicable law or agreed to in writing, software
1:177c065:    distributed under the License is distributed on an "AS IS" BASIS,
1:177c065:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:177c065:    See the License for the specific language governing permissions and
1:177c065:    limitations under the License.
1:177c065: 
5:177c065:  */
1:177c065: package org.apache.derbyTesting.functionTests.tests.derbynet;
1:177c065: 
1:177c065: import java.io.File;
1:177c065: import java.io.FileOutputStream;
1:177c065: import java.io.IOException;
1:177c065: import java.security.AccessController;
1:177c065: import java.sql.SQLException;
1:177c065: import java.util.Locale;
1:177c065: import java.util.Properties;
1:177c065: import junit.framework.Test;
1:177c065: import org.apache.derby.drda.NetworkServerControl;
1:9d44c9e: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:177c065: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:177c065: import org.apache.derbyTesting.junit.Derby;
1:177c065: import org.apache.derbyTesting.junit.JDBC;
1:177c065: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:177c065: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:177c065: import org.apache.derbyTesting.junit.TestConfiguration;
1:177c065: 
6:177c065: /** 
1:177c065:  * This test tests the derby.properties, system properties and command line
1:177c065:  * parameters to make sure the pick up settings in the correct order. 
1:177c065:  * Search order is:
1:177c065:  *     command line parameters
1:177c065:  *     System properties
1:177c065:  *     derby.properties
1:177c065:  *     default     
1:177c065:  * The command line should take precedence
1:177c065:  * 
1:177c065:  * The test also tests start server by specifying system properties without
1:177c065:  * values; in this case the server will use default values.
1:177c065:  */
1:177c065: 
1:177c065: public class ServerPropertiesTest  extends BaseJDBCTestCase {
1:177c065:     
1:177c065:     //create own policy file
1:b32256d:     private static final String POLICY_FILE_NAME =
1:b32256d:         "org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.policy";
1:0c8f7b8:     private int[] portsSoFar;
1:ad60cd5:     private int basePort;
1:177c065:     
1:177c065:     public ServerPropertiesTest(String name) {
1:177c065:         super(name);
1:ad60cd5:         this.basePort = TestConfiguration.getCurrent().getPort();
35:177c065:     }
1:177c065:     
1:177c065:     public static Test suite()
14:177c065:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ServerPropertiesTest");
1:177c065:           
1:177c065:         if (!Derby.hasServer()) return suite;
1:177c065:         // don't run with JSR169 for 1. this is network server and
1:177c065:         // 2. the java executable may be named differently
1:177c065:         if (JDBC.vmSupportsJSR169()) return suite;
1:177c065:         
1:044179c:         // this fixture doesn't use a client/server setup, instead does the 
1:177c065:         // relevant starting/stopping inside the test
1:177c065:         // Add security manager policy that allows executing java commands
1:0c8f7b8:         suite.addTest(decorateTest("ttestSetPortPriority", 
1:0c8f7b8:                 new String[] {}, new String[] {}, false));
1:177c065:         
1:044179c:         // test unfinished properties settings. 
1:044179c:         // decorateTest adds policy file and sets up properties
1:0c8f7b8:         // the properties settings are incorrect i.e. they have no value
1:0c8f7b8:         String[] badServerProperties = {
1:0c8f7b8:                 "derby.drda.logConnections=",
1:0c8f7b8:                 "derby.drda.traceAll=",
1:0c8f7b8:                 "derby.drda.traceDirectory=",
1:0c8f7b8:                 "derby.drda.keepAlive=",
1:0c8f7b8:                 "derby.drda.timeSlice=",
1:0c8f7b8:                 "derby.drda.host=",
1:0c8f7b8:                 "derby.drda.portNumber=",
1:0c8f7b8:                 "derby.drda.minThreads=",
1:0c8f7b8:                 "derby.drda.maxThreads=",
1:0c8f7b8:                 "derby.drda.startNetworkServer=",
1:0c8f7b8:                 "derby.drda.debug="
1:0c8f7b8:                 };
1:044179c:         // fixture hits error DRDA_MissingNetworkJar (Cannot find derbynet.jar) so,
1:044179c:         // only run with jars
1:f61cb10:         if (TestConfiguration.loadingFromJars()) 
1:044179c:             suite.addTest(decorateTest("ttestDefaultProperties", 
1:0c8f7b8:                 badServerProperties, new String[] {}, true));
1:177c065:         
1:044179c:         // The other fixtures, testToggleTrace (trace on/off), 
1:9f61c8b:         // and testToggleLogConnections (logconnections on/off)
1:9f61c8b:         // can all use the default setup with adjusted policy
1:177c065:         
1:177c065:         // need english locale so we can compare command output for those tests 
1:177c065:         if (!Locale.getDefault().getLanguage().equals("en"))
1:177c065:             return suite;
1:177c065:         
1:177c065:         Test test = TestConfiguration
1:177c065:             .clientServerSuite(ServerPropertiesTest.class);
1:177c065:         
1:177c065:         // Install a security manager using the special policy file.
1:177c065:         test = decorateWithPolicy(test);
1:177c065:         suite.addTest(test);
1:177c065:         return suite;
1:177c065:     }
1:177c065:     
1:177c065:     public void tearDown() throws Exception {
1:177c065:         super.tearDown();
1:0c8f7b8:         if (portsSoFar != null)
1:0c8f7b8:         {
1:0c8f7b8:             for (int i = 0 ; i < portsSoFar.length ; i++)
1:0c8f7b8:             {
1:0c8f7b8:                 try {
1:0c8f7b8:                     shutdownServer(portsSoFar[i], true);
1:0c8f7b8:                 } catch (SQLException e) {
1:0c8f7b8:                     fail("could not shutdown server at port " + portsSoFar[i]);
1:0c8f7b8:                 }
1:0c8f7b8:             }
1:0c8f7b8:             portsSoFar=null;
1:0c8f7b8:         }
1:177c065:     }
1:177c065:     
1:177c065:     /**
2:177c065:      * <p>
1:177c065:      * Compose the required decorators to bring up the server in the correct
1:177c065:      * configuration.
2:177c065:      * </p>
1:177c065:      */
1:177c065:     private static Test decorateTest(String testName, 
1:0c8f7b8:             String[] startupProperties, String[] startupArgs,
1:0c8f7b8:             boolean startServer)
1:177c065:     {
1:177c065:         ServerPropertiesTest spt = new ServerPropertiesTest(testName);
1:177c065:         String [] startupProps;
1:177c065:         if (startupProperties == null)
1:177c065:             startupProps = new String[] {};
3:177c065:         else
1:177c065:             startupProps = startupProperties;
1:177c065:         if (startupArgs == null)
1:177c065:             startupArgs = new String[]{};
1:0c8f7b8:         NetworkServerTestSetup networkServerTestSetup;
1:0c8f7b8:         if (startServer)
1:0c8f7b8:         {
1:0c8f7b8:             // start networkServer as a process
1:0c8f7b8:             networkServerTestSetup = new NetworkServerTestSetup(
1:a63ab5e:                 spt, startupProps, startupArgs, true);
1:0c8f7b8:         }
1:0c8f7b8:         else
1:0c8f7b8:         {
1:0c8f7b8:             // get networkserver setup but don't start anything
1:0c8f7b8:             networkServerTestSetup = new NetworkServerTestSetup(
1:0c8f7b8:                 spt, true, false);
1:0c8f7b8:         }
1:177c065:         Test test = decorateWithPolicy(networkServerTestSetup);
1:177c065:         test = TestConfiguration.defaultServerDecorator(test);
2:177c065:         return test;
1:177c065:     }   
1:05829c1:     
1:177c065:     // grant ALL FILES execute, and getPolicy permissions,
1:177c065:     // as well as write for the trace files.
1:177c065:     private static Test decorateWithPolicy(Test test) {
2:177c065:         //
1:177c065:         // Install a security manager using the initial policy file.
1:177c065:         //
1:b32256d:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
1:177c065:     }
1:177c065:     
1:05829c1:     private static Properties getTheProperties() {
1:177c065:         Properties p;
11:177c065:         try {
1:0c8f7b8:             p = NetworkServerTestSetup.getNetworkServerControl().getCurrentProperties();
6:177c065:         } catch (Exception e) {
1:177c065:             p = null; // should be ok to set to null (to satisfy compiler)
1:177c065:             // as fail will exit without further checks.
2:177c065:             e.printStackTrace();
1:177c065:             fail("unexpected exception getting properties from server");
1:177c065:         }
1:05829c1:         return p;
1:05829c1:     }
1:05829c1: 
1:05829c1:     // check for 1 Property/Value pair, passing in expected as a String
1:05829c1:     // "<propertyName>=<expectedPropertyValue>"
1:05829c1:     private static void verifyProperties(String expectedPropAndValue) {
1:05829c1:         Properties p = getTheProperties();
1:05829c1:         assertPropertyValueCorrect(p, expectedPropAndValue);
1:05829c1:         p=null;
1:05829c1:     }
1:05829c1:     
1:05829c1:     // check for an array of Property/Value pairs, passing each expected pair 
1:05829c1:     // in as a String "<propertyName>=<expectedPropertyValue>"
1:05829c1:     private static void verifyProperties(String[] expectedValues) { 
1:05829c1:         Properties p = getTheProperties();
1:177c065:         // for debugging:
1:177c065:         for (int i=0 ; i<expectedValues.length; i++){
1:177c065:             println("expV: " + expectedValues[i]);
1:177c065:         }
1:177c065:         assertEquals(expectedValues.length , p.size());
1:05829c1:         for ( int i = 0 ; i < expectedValues.length ; i++)
1:177c065:         {
1:05829c1:             assertPropertyValueCorrect(p, expectedValues[i]);
1:177c065:         }
1:177c065:         p = null;
1:177c065:     }
1:177c065:     
1:05829c1:     private static void assertPropertyValueCorrect(Properties p, String expectedPropAndValue) {
1:05829c1:         String[] expPropValueString = expectedPropAndValue.split("=");
1:05829c1:         try {
1:05829c1:             // for debugging
1:05829c1:             String actualPropertyValue = p.getProperty(expPropValueString[0]);
1:05829c1:             println("exppropName: " + expPropValueString[0]);
1:05829c1:             println("exppropValue: " + expPropValueString[1]);
1:05829c1:             println("actualpropValue: " + actualPropertyValue);
1:05829c1:             assertEquals(expPropValueString[1],actualPropertyValue);
1:05829c1:         } catch(Exception e) {
1:05829c1:             fail("could not find property " + expPropValueString[0]);
1:05829c1:         }
1:05829c1:     }
1:05829c1:     
1:177c065:     /**
1:0c8f7b8:      *  Ping for the server to be up - or down.
1:0c8f7b8:      *  @param port port number to be used in the ping
1:0c8f7b8:      *  @param expectServerUp indicator whether the server is expected to be up
1:177c065:      */
1:0c8f7b8:     private boolean canPingServer(int port, boolean expectServerUp) 
1:177c065:     throws SQLException {
1:177c065:         
1:0c8f7b8:         boolean serverUp = false;
1:0c8f7b8:         try {
1:0c8f7b8:             serverUp = NetworkServerTestSetup.pingForServerUp(
1:0c8f7b8:                 NetworkServerTestSetup.getNetworkServerControl(port), null,
1:0c8f7b8:                 expectServerUp);
1:0c8f7b8:         } catch (Exception e) {
1:0c8f7b8:             fail("unexpected Exception while pinging");
1:0c8f7b8:         }
1:0c8f7b8:         return serverUp;
1:177c065:     }
1:177c065:     
1:177c065:     // obtain & shutdown the network server;
1:177c065:     // port needs to be passed in to verify it's down;
1:177c065:     private String shutdownServer(int port, boolean specifyPort) 
1:177c065:     throws SQLException {
1:177c065:         try {
1:177c065:             if (specifyPort)
1:177c065:             {
1:0c8f7b8:                 NetworkServerControl nsctrl = 
1:0c8f7b8:                     NetworkServerTestSetup.getNetworkServerControl(port);
2:177c065:                 nsctrl.shutdown();
1:177c065:             }
1:177c065:             else
1:177c065:             {
1:0c8f7b8:                 NetworkServerControl nsctrl = 
1:0c8f7b8:                     NetworkServerTestSetup.getNetworkServerControlDefault();
1:177c065:                 nsctrl.shutdown();
1:177c065:             }
1:177c065:         } catch (Exception e) {
1:204c040:             return "failed to shutdown server with API parameter (" + e + ")";
1:177c065:         }
1:0c8f7b8:         if (canPingServer(port,false)) {
1:177c065:             return "Can still ping server";
1:177c065:         }
2:177c065:         return null;
1:177c065:     }
1:177c065: 
1:177c065: 
1:177c065:     // obtain & start the network server without specifying port;
1:177c065:     // port needs to be passed in to verify it's up.
1:177c065:     public String startServer(int port, boolean specifyPort) 
1:177c065:     throws SQLException {
1:177c065:         try {
1:177c065:             if (specifyPort)
1:177c065:             {
1:0c8f7b8:                 NetworkServerControl nsctrl = 
1:0c8f7b8:                     NetworkServerTestSetup.getNetworkServerControl(port);
1:177c065:                 // For debugging, to make output come to console uncomment:
1:177c065:                 //nsctrl.start(new PrintWriter(System.out, true));
1:177c065:                 // and comment out:
1:177c065:                 nsctrl.start(null);
1:177c065:                 NetworkServerTestSetup.waitForServerStart(nsctrl);
1:177c065:             }
1:177c065:             else
1:177c065:             {
1:0c8f7b8:                 NetworkServerControl nsctrl = 
1:0c8f7b8:                     NetworkServerTestSetup.getNetworkServerControlDefault();
1:177c065:                 // For debugging, to make output come to console uncomment:
1:177c065:                 //nsctrl.start(new PrintWriter(System.out, true));
1:177c065:                 // and comment out:
1:177c065:                 nsctrl.start(null);
1:177c065:                 NetworkServerTestSetup.waitForServerStart(nsctrl);
1:177c065:             }
1:177c065:         } catch (Exception e) {
1:177c065:             return "failed to start server with port " + port;
1:177c065:         }
1:177c065:         // check that we have this server up now
1:0c8f7b8:         if (!canPingServer(port, true)) {
1:177c065:             return "Cannot ping server started with port set to " + port;
1:177c065:         }
1:177c065:         return null;
1:177c065:     }
1:177c065:     
1:0c8f7b8:    public void checkWhetherNeedToShutdown(int[] ports, String failReason) {
1:177c065:        
1:0c8f7b8:        portsSoFar = ports;
1:177c065:        if (!(failReason == null))
1:177c065:        {
1:0c8f7b8:            fail(failReason);
1:177c065:        }
1:177c065:    }
1:177c065:    
1:177c065:    /**
1:177c065:     * Execute command and verify that it completes successfully
1:177c065:     * @param Cmd array of java arguments for command
2:177c065:     * @throws InterruptedException
2:177c065:     * @throws IOException
1:177c065:     */
1:177c065:    private void  assertSuccessfulCmd(String expectedString, String[] Cmd) throws InterruptedException, IOException {
1:044179c:        assertExecJavaCmdAsExpected(new String[] {expectedString}, Cmd, 0);
1:177c065:    }
1:177c065: 
1:177c065:     /**
1:177c065:      *  Test port setting priority
1:177c065:      */
1:0c8f7b8:     public void ttestSetPortPriority() 
1:0c8f7b8:     throws SQLException, InterruptedException, IOException {
1:177c065:         // default is 1527. The test harness configuration would
1:177c065:         // use the API and add the port number. We want to test all
1:177c065:         // 4 mechanisms for specifying the port.
1:177c065:         // To ensure getting a unique port number, this test leaves open
1:177c065:         // each server for a bit.
1:177c065:         // as we need to test the default as well as with setting various
1:177c065:         // properties, this test can't rely on the testsetup.
1:177c065: 
1:177c065:         // So, first, bring default server down if up
1:177c065:         // Note: if the harness gets modified to accomodate splitting
1:177c065:         //    over different networkservers, there maybe something more
1:177c065:         //    appropriate than shutting down the default server.
1:0c8f7b8:         // we really expect the server to be down, let's
1:0c8f7b8:         // not do any waiting around
1:0c8f7b8:         NetworkServerTestSetup.setWaitTime(0);
1:ad60cd5:         if (canPingServer(basePort, false)) {
1:177c065:             // for now, shutdown
1:ad60cd5:             shutdownServer(basePort, false);
1:177c065:         }
1:0c8f7b8:         NetworkServerTestSetup.setDefaultWaitTime();
1:0c8f7b8: 
1:6524638:         // Wait until the server has shut down completely and released the
1:6524638:         // port.
1:6524638:         NetworkServerTestSetup.waitForAvailablePort();
1:6524638: 
1:ad60cd5:         /* 
1:ad60cd5:          * The port should be default, but it might not be, so the second argument
1:ad60cd5:          * must be true to accommodate for every case.
1:177c065:          */
1:ad60cd5:         String actionResult = startServer(basePort, true);
1:ad60cd5:         checkWhetherNeedToShutdown(new int[] {basePort}, actionResult);
1:177c065:         
1:177c065:         // set derby.drda.portNumber to an alternate number in derby.properties
1:5e25f23:         int firstAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
1:177c065:         final Properties derbyProperties = new Properties();
1:177c065:         derbyProperties.put("derby.drda.portNumber", 
1:39b3237:                 Integer.toString(firstAlternatePort));
1:177c065: 
1:0c8f7b8:         final String derbyHome = getSystemProperty("derby.system.home");
1:9d44c9e:         boolean b = AccessController.doPrivileged
1:9d44c9e:         (new java.security.PrivilegedAction<Boolean>(){
1:9d44c9e:             public Boolean run(){
1:177c065:                 boolean fail = false;
1:177c065:                 try {
1:177c065:                     FileOutputStream propFile = 
1:177c065:                         new FileOutputStream(derbyHome + File.separator + "derby.properties");
1:177c065:                     derbyProperties.store(propFile,"testing derby.properties");
1:177c065:                     propFile.close();
1:177c065:                 } catch (IOException ioe) {
1:177c065:                     fail = true;
1:177c065:                 }
1:9d44c9e:                 return fail;
1:177c065:             }
3:177c065:         });
1:9d44c9e:         if (b)
1:0c8f7b8:         {
1:ad60cd5:             checkWhetherNeedToShutdown(new int[] {TestConfiguration.getCurrent().getPort()}, "failed to write derby.properties");
1:177c065:         }
1:177c065:         // have to shutdown engine to force read of derby.properties
1:177c065:         TestConfiguration.getCurrent().shutdownEngine();
1:177c065:         actionResult = startServer(firstAlternatePort, false);
1:ad60cd5:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort}, actionResult);
1:177c065: 
1:5e25f23:         final int secondAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
1:177c065:         // Now set system properties.
1:177c065:         setSystemProperty("derby.drda.portNumber", 
1:39b3237:             Integer.toString(secondAlternatePort));
1:177c065:         actionResult = startServer(secondAlternatePort, false);
1:ad60cd5:         checkWhetherNeedToShutdown( new int[] {basePort, firstAlternatePort, secondAlternatePort},
1:177c065:             actionResult);
1:177c065:         
1:177c065:         // now try with specifying port
1:177c065:         // Note that we didn't unset the system property yet, nor did
1:177c065:         // we get rid of derby.properties...
1:177c065:         // command line parameter should take hold
1:5e25f23:         int thirdAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
1:177c065:         actionResult = startServer(thirdAlternatePort, true);
1:ad60cd5:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:177c065:             thirdAlternatePort}, actionResult);
1:177c065: 
1:177c065:         // now with -p. 
1:5e25f23:         int fourthAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
1:0c8f7b8:         String[] commandArray = {"-Dderby.system.home=" + derbyHome,
1:177c065:             "org.apache.derby.drda.NetworkServerControl", "-p",
1:177c065:             String.valueOf(fourthAlternatePort).toString(), 
1:177c065:             "-noSecurityManager", "start"};
1:63c65ac:         execJavaCmd(commandArray);
1:177c065:         
1:0c8f7b8:         if (!canPingServer(fourthAlternatePort, true)) {
1:177c065:             actionResult = "Can not ping server specified with -p";
1:177c065:         }
1:ad60cd5:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:177c065:             thirdAlternatePort, fourthAlternatePort}, actionResult);
1:0c8f7b8:                         
1:177c065:         // shutdown with -p
1:0c8f7b8:         commandArray = new String[] {"-Dderby.system.home=" + derbyHome,
1:177c065:                 "org.apache.derby.drda.NetworkServerControl", "-p",
1:177c065:                 String.valueOf(fourthAlternatePort).toString(), 
1:177c065:                 "-noSecurityManager", "shutdown"};
1:63c65ac:         execJavaCmd(commandArray);
1:177c065: 
1:0c8f7b8:         if (canPingServer(fourthAlternatePort, false)) {
1:177c065:             actionResult = "Can still ping server specified with -p";
1:177c065:         }
1:ad60cd5:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:177c065:             thirdAlternatePort, fourthAlternatePort}, actionResult);
1:177c065:             
1:177c065:         // shutdown with port specified in constructor
1:177c065:         actionResult = shutdownServer(thirdAlternatePort, true);
1:ad60cd5:         checkWhetherNeedToShutdown( new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:177c065:             thirdAlternatePort}, actionResult);
1:177c065:         
1:177c065:         // shutdown using System property
1:177c065:         actionResult = shutdownServer(secondAlternatePort, false);
1:ad60cd5:         checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort, secondAlternatePort},
1:177c065:             actionResult);
1:177c065:         // remove system property
1:177c065:         removeSystemProperty("derby.drda.portNumber");
1:177c065: 
1:177c065:         // shutdown server with port set in derby.properties
1:177c065:         actionResult = shutdownServer(firstAlternatePort, false);
1:ad60cd5:         checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort},
1:177c065:             actionResult);
1:177c065:         // remove derby.properties
1:9d44c9e:         if (!PrivilegedFileOpsForTests.delete(
1:9d44c9e:                 new File(derbyHome, "derby.properties"))) {
1:ad60cd5:             checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort},
1:177c065:                 "unable to remove derby.properties");
1:177c065:         }
1:177c065:         // have to shutdown engine to force re-evaluation of derby.properties
1:177c065:         TestConfiguration.getCurrent().shutdownEngine();
1:177c065:         
1:177c065:         // shutdown the default server
1:ad60cd5:         actionResult = shutdownServer(basePort, true);
1:ad60cd5:         checkWhetherNeedToShutdown ( new int[] {basePort}, actionResult);
1:177c065:     }
1:177c065:     
1:177c065:     /**
1:177c065:      *   Test start server specifying system properties without values
1:177c065:      */
1:177c065:     public void ttestDefaultProperties() throws SQLException
1:177c065:     {
1:177c065:         //check that default properties are used
1:177c065:         verifyProperties(new String[] {
1:05829c1:                 "derby.drda.maxThreads=0", 
1:05829c1:                 "derby.drda.sslMode=off", 
1:05829c1:                 "derby.drda.keepAlive=true", 
1:05829c1:                 "derby.drda.minThreads=0", 
1:05829c1:                 "derby.drda.portNumber=" + 
1:05829c1:                     String.valueOf(TestConfiguration.getCurrent().getPort()),
1:05829c1:                 "derby.drda.logConnections=false", 
1:05829c1:                 "derby.drda.timeSlice=0", 
1:05829c1:                 "derby.drda.startNetworkServer=false",
1:05829c1:                 "derby.drda.host=" +
1:05829c1:                     String.valueOf(TestConfiguration.getCurrent().getHostName()), 
1:05829c1:                 "derby.drda.traceAll=false"});
1:177c065:     }
1:177c065:        
1:177c065:     /**
1:177c065:      *   Test trace command on - property traceAll should get set
1:177c065:      */
1:177c065:     public void testToggleTrace() 
2:177c065:     throws SQLException, IOException, InterruptedException
1:177c065:     {        
1:05829c1:         // we only care about the traceAll property, the rest will be unchanged
1:05829c1:         String expectedTraceOff = "derby.drda.traceAll=false";
1:05829c1:         String expectedTraceOn = "derby.drda.traceAll=true";     
1:177c065:         
1:177c065:         verifyProperties(expectedTraceOff);     
1:177c065: 
1:ad60cd5:         int port = TestConfiguration.getCurrent().getPort();
1:177c065: 
1:177c065:         String[] traceCmd = new String[] {
1:ad60cd5:             "org.apache.derby.drda.NetworkServerControl", "trace", "on", "-p",String.valueOf(port) };
1:177c065:         assertSuccessfulCmd("Trace turned on for all sessions.", traceCmd);
1:177c065:         verifyProperties(expectedTraceOn);     
1:177c065: 
1:177c065:         traceCmd = new String[] {
1:ad60cd5:                 "org.apache.derby.drda.NetworkServerControl", "trace", "off", "-p",String.valueOf(port) };
1:177c065:         assertSuccessfulCmd("Trace turned off for all sessions", traceCmd);
1:177c065:         // traceAll should be back to false
1:177c065:         verifyProperties(expectedTraceOff);     
1:177c065:     }
1:177c065: 
1:177c065:     /**
1:177c065:      *   Test logconnections on
1:177c065:      */
1:177c065:     public void testToggleLogConnections() 
1:177c065:     throws SQLException, IOException, InterruptedException
1:177c065:     {
1:05829c1:         // only care about the LogConnections property; the rest is unchanged
1:05829c1:         String expectedLogConnectionsOff = "derby.drda.logConnections=false";
1:05829c1:         String expectedLogConnectionsOn = "derby.drda.logConnections=true";
1:177c065:         
1:177c065:         verifyProperties(expectedLogConnectionsOff);     
1:177c065: 
1:ad60cd5:         int port = TestConfiguration.getCurrent().getPort();
1:177c065: 
1:177c065:         String[] cmd = new String[] {
1:ad60cd5:             "org.apache.derby.drda.NetworkServerControl", "logconnections", "on","-p",String.valueOf(port) };
1:e09c18a:         assertSuccessfulCmd("Log Connections turned on.", cmd);
1:177c065:         verifyProperties(expectedLogConnectionsOn);     
1:177c065: 
1:177c065:         cmd = new String[] {
1:ad60cd5:                 "org.apache.derby.drda.NetworkServerControl", "logconnections", "off", "-p",String.valueOf(port) };
1:e09c18a:         assertSuccessfulCmd("Log Connections turned off.", cmd);
1:177c065:         // traceAll should be back to false
1:177c065:         verifyProperties(expectedLogConnectionsOff);    
1:177c065:     }
1:177c065: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                 Integer.toString(firstAlternatePort));
/////////////////////////////////////////////////////////////////////////
1:             Integer.toString(secondAlternatePort));
commit:e09c18a
/////////////////////////////////////////////////////////////////////////
1:         assertSuccessfulCmd("Log Connections turned on.", cmd);
1:         assertSuccessfulCmd("Log Connections turned off.", cmd);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ServerPropertiesTest");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:         boolean b = AccessController.doPrivileged
1:         (new java.security.PrivilegedAction<Boolean>(){
1:             public Boolean run(){
/////////////////////////////////////////////////////////////////////////
1:                 return fail;
1:         if (b)
/////////////////////////////////////////////////////////////////////////
1:         if (!PrivilegedFileOpsForTests.delete(
1:                 new File(derbyHome, "derby.properties"))) {
commit:b32256d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final String POLICY_FILE_NAME =
1:         "org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.policy";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
commit:6524638
/////////////////////////////////////////////////////////////////////////
1:         // Wait until the server has shut down completely and released the
1:         // port.
1:         NetworkServerTestSetup.waitForAvailablePort();
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:f61cb10
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         if (TestConfiguration.loadingFromJars()) 
commit:05829c1
/////////////////////////////////////////////////////////////////////////
1:     
1:     private static Properties getTheProperties() {
/////////////////////////////////////////////////////////////////////////
1:         return p;
1:     }
1: 
1:     // check for 1 Property/Value pair, passing in expected as a String
1:     // "<propertyName>=<expectedPropertyValue>"
1:     private static void verifyProperties(String expectedPropAndValue) {
1:         Properties p = getTheProperties();
1:         assertPropertyValueCorrect(p, expectedPropAndValue);
1:         p=null;
1:     }
1:     
1:     // check for an array of Property/Value pairs, passing each expected pair 
1:     // in as a String "<propertyName>=<expectedPropertyValue>"
1:     private static void verifyProperties(String[] expectedValues) { 
1:         Properties p = getTheProperties();
1:         for ( int i = 0 ; i < expectedValues.length ; i++)
1:             assertPropertyValueCorrect(p, expectedValues[i]);
1:     private static void assertPropertyValueCorrect(Properties p, String expectedPropAndValue) {
1:         String[] expPropValueString = expectedPropAndValue.split("=");
1:         try {
1:             // for debugging
1:             String actualPropertyValue = p.getProperty(expPropValueString[0]);
1:             println("exppropName: " + expPropValueString[0]);
1:             println("exppropValue: " + expPropValueString[1]);
1:             println("actualpropValue: " + actualPropertyValue);
1:             assertEquals(expPropValueString[1],actualPropertyValue);
1:         } catch(Exception e) {
1:             fail("could not find property " + expPropValueString[0]);
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 "derby.drda.maxThreads=0", 
1:                 "derby.drda.sslMode=off", 
1:                 "derby.drda.keepAlive=true", 
1:                 "derby.drda.minThreads=0", 
1:                 "derby.drda.portNumber=" + 
1:                     String.valueOf(TestConfiguration.getCurrent().getPort()),
1:                 "derby.drda.logConnections=false", 
1:                 "derby.drda.timeSlice=0", 
1:                 "derby.drda.startNetworkServer=false",
1:                 "derby.drda.host=" +
1:                     String.valueOf(TestConfiguration.getCurrent().getHostName()), 
1:                 "derby.drda.traceAll=false"});
/////////////////////////////////////////////////////////////////////////
1:         // we only care about the traceAll property, the rest will be unchanged
1:         String expectedTraceOff = "derby.drda.traceAll=false";
1:         String expectedTraceOn = "derby.drda.traceAll=true";     
/////////////////////////////////////////////////////////////////////////
1:         // only care about the LogConnections property; the rest is unchanged
1:         String expectedLogConnectionsOff = "derby.drda.logConnections=false";
1:         String expectedLogConnectionsOn = "derby.drda.logConnections=true";
commit:63c65ac
/////////////////////////////////////////////////////////////////////////
1:         execJavaCmd(commandArray);
/////////////////////////////////////////////////////////////////////////
1:         execJavaCmd(commandArray);
commit:0c8f7b8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.Utilities;
/////////////////////////////////////////////////////////////////////////
1:     private int[] portsSoFar;
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(decorateTest("ttestSetPortPriority", 
1:                 new String[] {}, new String[] {}, false));
1:         // the properties settings are incorrect i.e. they have no value
1:         String[] badServerProperties = {
1:                 "derby.drda.logConnections=",
1:                 "derby.drda.traceAll=",
1:                 "derby.drda.traceDirectory=",
1:                 "derby.drda.keepAlive=",
1:                 "derby.drda.timeSlice=",
1:                 "derby.drda.host=",
1:                 "derby.drda.portNumber=",
1:                 "derby.drda.minThreads=",
1:                 "derby.drda.maxThreads=",
1:                 "derby.drda.startNetworkServer=",
1:                 "derby.drda.debug="
1:                 };
1:                 badServerProperties, new String[] {}, true));
/////////////////////////////////////////////////////////////////////////
1:         if (portsSoFar != null)
1:         {
1:             for (int i = 0 ; i < portsSoFar.length ; i++)
1:             {
1:                 try {
1:                     shutdownServer(portsSoFar[i], true);
1:                 } catch (SQLException e) {
1:                     fail("could not shutdown server at port " + portsSoFar[i]);
1:                 }
1:             }
1:             portsSoFar=null;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             String[] startupProperties, String[] startupArgs,
1:             boolean startServer)
/////////////////////////////////////////////////////////////////////////
1:         NetworkServerTestSetup networkServerTestSetup;
1:         if (startServer)
1:         {
1:             // start networkServer as a process
1:             networkServerTestSetup = new NetworkServerTestSetup(
0:                 spt, startupProps, startupArgs, true, spt._inputStreamHolder);
1:         }
1:         else
1:         {
1:             // get networkserver setup but don't start anything
1:             networkServerTestSetup = new NetworkServerTestSetup(
1:                 spt, true, false);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             p = NetworkServerTestSetup.getNetworkServerControl().getCurrentProperties();
/////////////////////////////////////////////////////////////////////////
1:      *  Ping for the server to be up - or down.
1:      *  @param port port number to be used in the ping
1:      *  @param expectServerUp indicator whether the server is expected to be up
1:     private boolean canPingServer(int port, boolean expectServerUp) 
1:         boolean serverUp = false;
1:         try {
1:             serverUp = NetworkServerTestSetup.pingForServerUp(
1:                 NetworkServerTestSetup.getNetworkServerControl(port), null,
1:                 expectServerUp);
1:         } catch (Exception e) {
1:             fail("unexpected Exception while pinging");
1:         }
1:         return serverUp;
/////////////////////////////////////////////////////////////////////////
1:                 NetworkServerControl nsctrl = 
1:                     NetworkServerTestSetup.getNetworkServerControl(port);
1:                 NetworkServerControl nsctrl = 
1:                     NetworkServerTestSetup.getNetworkServerControlDefault();
1:         if (canPingServer(port,false)) {
/////////////////////////////////////////////////////////////////////////
1:                 NetworkServerControl nsctrl = 
1:                     NetworkServerTestSetup.getNetworkServerControl(port);
/////////////////////////////////////////////////////////////////////////
1:                 NetworkServerControl nsctrl = 
1:                     NetworkServerTestSetup.getNetworkServerControlDefault();
/////////////////////////////////////////////////////////////////////////
1:         if (!canPingServer(port, true)) {
1:    public void checkWhetherNeedToShutdown(int[] ports, String failReason) {
1:        portsSoFar = ports;
1:            fail(failReason);
/////////////////////////////////////////////////////////////////////////
1:     public void ttestSetPortPriority() 
1:     throws SQLException, InterruptedException, IOException {
/////////////////////////////////////////////////////////////////////////
1:         // we really expect the server to be down, let's
1:         // not do any waiting around
1:         NetworkServerTestSetup.setWaitTime(0);
0:         if (canPingServer(1527, false)) {
1:         NetworkServerTestSetup.setDefaultWaitTime();
1: 
/////////////////////////////////////////////////////////////////////////
1:         final String derbyHome = getSystemProperty("derby.system.home");
/////////////////////////////////////////////////////////////////////////
1:         {
/////////////////////////////////////////////////////////////////////////
1:         String[] commandArray = {"-Dderby.system.home=" + derbyHome,
0:         Utilities.execJavaCmd(commandArray);
1:         if (!canPingServer(fourthAlternatePort, true)) {
1:                         
1:         commandArray = new String[] {"-Dderby.system.home=" + derbyHome,
0:         Utilities.execJavaCmd(commandArray);
1:         if (canPingServer(fourthAlternatePort, false)) {
commit:044179c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // this fixture doesn't use a client/server setup, instead does the 
1:         // test unfinished properties settings. 
1:         // decorateTest adds policy file and sets up properties
1:         // fixture hits error DRDA_MissingNetworkJar (Cannot find derbynet.jar) so,
1:         // only run with jars
0:         if (TestConfiguration.loadingFromJars())
1:             suite.addTest(decorateTest("ttestDefaultProperties", 
0:                 getStartupProperties(), new String[] {}));
1:         // The other fixtures, testToggleTrace (trace on/off), 
0:         // testWrongCommands can all use the default setup with adjusted policy
/////////////////////////////////////////////////////////////////////////
1:        assertExecJavaCmdAsExpected(new String[] {expectedString}, Cmd, 0);
/////////////////////////////////////////////////////////////////////////
0:         assertExecJavaCmdAsExpected(new String[] 
0:         assertExecJavaCmdAsExpected(new String[] 
0:         assertExecJavaCmdAsExpected(new String[] 
commit:177c065
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.ServerPropertiesTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.derbynet;
1: 
1: import java.io.File;
1: import java.io.FileOutputStream;
1: import java.io.IOException;
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.net.InetAddress;
1: import java.security.AccessController;
0: import java.security.PrivilegedAction;
0: import java.security.PrivilegedActionException;
0: import java.security.PrivilegedExceptionAction;
1: import java.sql.SQLException;
0: import java.util.ArrayList;
0: import java.util.Enumeration;
1: import java.util.Locale;
1: import java.util.Properties;
1: 
0: import junit.framework.Assert;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derby.drda.NetworkServerControl;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.BaseTestCase;
1: import org.apache.derbyTesting.junit.Derby;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.Utilities;
1: 
1: /** 
1:  * This test tests the derby.properties, system properties and command line
1:  * parameters to make sure the pick up settings in the correct order. 
1:  * Search order is:
1:  *     command line parameters
1:  *     System properties
1:  *     derby.properties
1:  *     default     
1:  * The command line should take precedence
1:  * 
1:  * The test also tests start server by specifying system properties without
1:  * values; in this case the server will use default values.
1:  */
1: 
1: public class ServerPropertiesTest  extends BaseJDBCTestCase {
1:     
0:     // helper state for intercepting server error messages;
0:     // needed by fixture testToggleTrace
0:     private InputStream[]  _inputStreamHolder;
1:     
1:     //create own policy file
0:     private static String POLICY_FILE_NAME = 
0:         "functionTests/tests/derbynet/ServerPropertiesTest.policy";
0:     private static String TARGET_POLICY_FILE_NAME = "server.policy";
1:     
0:     private static String[] serverProperties = {
0:                 "derby.drda.logConnections",
0:                 "derby.drda.traceAll",
0:                 "derby.drda.traceDirectory",
0:                 "derby.drda.keepAlive",
0:                 "derby.drda.timeSlice",
0:                 "derby.drda.host",
0:                 "derby.drda.portNumber",
0:                 "derby.drda.minThreads",
0:                 "derby.drda.maxThreads",
0:                 "derby.drda.startNetworkServer",
0:                 "derby.drda.debug"
0:                 };
1:     
1:     public ServerPropertiesTest(String name) {
1:         super(name);
0:         _inputStreamHolder = new InputStream[1];
1:     }
1:     
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("ServerPropertiesTest");
1: 
0:         // Server booting requires that we run from the jar files
0:         // Need derbynet.jar in the classpath!
0:         // TODO: check - can this be modified to use noSecurityManager
0:         //    for classes?
0:         // if (!TestConfiguration.loadingFromJars()) { return suite; }
1:           
1:         if (!Derby.hasServer()) return suite;
1:         // don't run with JSR169 for 1. this is network server and
1:         // 2. the java executable may be named differently
1:         if (JDBC.vmSupportsJSR169()) return suite;
1:         
0:         // this test doesn't use a client/server setup, instead does the 
1:         // relevant starting/stopping inside the test
1:         // Add security manager policy that allows executing java commands
0:         Test setPortPriority = new ServerPropertiesTest("ttestSetPortPriority");
0:         setPortPriority = decorateWithPolicy(setPortPriority);
0:         suite.addTest(setPortPriority);
1:         
0:         // unfinished properties settings. decorateTest add policy file and sets
0:         // up properties
0:         suite.addTest(decorateTest("ttestDefaultProperties", getStartupProperties(),
0:             new String[] {}));
1:         
0:         // The other tests, testToggleTrace (trace on/off), 
0:         // testToggleLogConnections (logconnections on/off) , and
0:         // testWrongCommands can all use the default setup - with policy
1:         
1:         // need english locale so we can compare command output for those tests 
1:         if (!Locale.getDefault().getLanguage().equals("en"))
1:             return suite;
1:         
1:         Test test = TestConfiguration
1:             .clientServerSuite(ServerPropertiesTest.class);
1:         
1:         // Install a security manager using the special policy file.
1:         test = decorateWithPolicy(test);
1:         suite.addTest(test);
1:         return suite;
1:     }
1:     
1:     public void tearDown() throws Exception {
1:         super.tearDown();
0:         serverProperties = null;
0:         POLICY_FILE_NAME = null;
0:         TARGET_POLICY_FILE_NAME = null;
0:         _inputStreamHolder = null;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Compose the required decorators to bring up the server in the correct
1:      * configuration.
1:      * </p>
1:      */
1:     private static Test decorateTest(String testName, 
0:             String[] startupProperties, String[] startupArgs)
1:     {
1:         ServerPropertiesTest spt = new ServerPropertiesTest(testName);
1:         String [] startupProps;
1:         if (startupProperties == null)
1:             startupProps = new String[] {};
1:         else
1:             startupProps = startupProperties;
1:         if (startupArgs == null)
1:             startupArgs = new String[]{};
0:         // start networkServer as a process
0:         NetworkServerTestSetup networkServerTestSetup =
0:             new NetworkServerTestSetup(spt,
0:                 startupProps, startupArgs, true, 
0:                 spt._inputStreamHolder);
1:         Test test = decorateWithPolicy(networkServerTestSetup);
1:         test = TestConfiguration.defaultServerDecorator(test);
1:         return test;
1:     }   
1:     
1:     /**
1:      * <p>
0:      * Return a set of startup properties for testing
1:      * </p>
1:      */
0:     private static  String[]  getStartupProperties()
1:     {
1: 
0:         ArrayList list = new ArrayList();
0:         for (int i = 0 ; i<serverProperties.length ; i++)
1:         {
0:             //System.out.println(serverProperties[i]);
0:             list.add(serverProperties[i] + "=");
1:         }
0:         String[] result = new String[ list.size()];
0:         list.toArray(result);
0:         return result;
1:     }
1:     
1:     /**
0:      * Construct the name of the server policy file.
1:      */
0:     private String makeServerPolicyName()
1:     {
1:         try {
0:             String  userDir = getSystemProperty( "user.dir" );
0:             String  fileName = userDir + File.separator + SupportFilesSetup.EXTINOUT + File.separator + TARGET_POLICY_FILE_NAME;
0:             File      file = new File( fileName );
0:             String  urlString = file.toURL().toExternalForm();
1: 
0:             return urlString;
1:         }
0:         catch (Exception e)
1:         {
0:             System.out.println( "Unexpected exception caught by makeServerPolicyName(): " + e );
1: 
1:             return null;
1:         }
1:     }
1:     
1:     // grant ALL FILES execute, and getPolicy permissions,
1:     // as well as write for the trace files.
1:     private static Test decorateWithPolicy(Test test) {
0:         String serverPolicyName = new ServerPropertiesTest("test").makeServerPolicyName();
1:         //
1:         // Install a security manager using the initial policy file.
1:         //
0:         test = new SecurityManagerSetup(test,serverPolicyName );
0:         // Copy over the policy file we want to use.
1:         //
0:         test = new SupportFilesSetup(
0:             test, null, new String[] {POLICY_FILE_NAME},
0:             null, new String[] {TARGET_POLICY_FILE_NAME}
0:         );
1:         return test;
1:     }
1: 
0:     private static void verifyProperties(String[] expectedValues) { 
1:         Properties p;
1:         try {
0:         NetworkServerControl derbyServer = NetworkServerTestSetup.getNetworkServerControl(); 
0:             p = derbyServer.getCurrentProperties();
1:         } catch (Exception e) {
1:             p = null; // should be ok to set to null (to satisfy compiler)
1:             // as fail will exit without further checks.
1:             e.printStackTrace();
1:             fail("unexpected exception getting properties from server");
1:         }
1:         
0:         Enumeration e = p.propertyNames();
1:         // for debugging:
1:         for (int i=0 ; i<expectedValues.length; i++){
1:             println("expV: " + expectedValues[i]);
1:         }
1:         assertEquals(expectedValues.length , p.size());
0:         for ( int i = 0 ; i < p.size() ; i++)
1:         {
0:             String propName = (String)e.nextElement();
0:             // next line for debugging
0:             println("propName: " + propName);
0:             String propval = (String)p.get(propName);
0:             assertEquals(expectedValues[i], propval);
1:         }
1:         p = null;
1:     }
1:     
0:     public int getAlternativePort() throws SQLException {
1: 
0:         Exception failException = null;
0:         // start with the default port + 1
0:         // there may be a smarter way to get the starting point...
0:         int possiblePort = TestConfiguration.getCurrent().getPort();
0:         if (!(possiblePort > 0))
0:             possiblePort = 1528;
1:         else
0:             possiblePort = possiblePort + 1;
1:         try {
0:             boolean portOK = false;
0:             while (!portOK) {
0:                 // check for first one in use
0:                 NetworkServerControl networkServer =
0:                     new NetworkServerControl(InetAddress.getByName("localhost"), possiblePort);
0:                 // Ping and wait for the network server to reply
0:                 boolean started = false;
1: 
1:                 try {
0:                     networkServer.ping();
0:                     // If ping throws no exception the server is running
0:                     started = true;
0:                 } catch(Exception e) {         
0:                     failException = e;
1:                 }
0:                 // Check if we got a reply on ping
0:                 if (!started) {
0:                     // we'll assume we can use this port. 
0:                     // If there was some other problem with the pinging, it'll
0:                     // become clear when someone attempts to use the port
0:                     portOK = true;
1:                 }
0:                 else { // this port's in use.
0:                     possiblePort = possiblePort + 1;
1:                 }
1:             }
1:         } catch (Exception e) {
0:             SQLException se = new SQLException("Error pinging network server");
0:             se.initCause(failException);
0:             throw se;
1:         }        
0:         return possiblePort;
1:     }
1:     
1:     /**
0:      *  Ping for the server started on the specified port
1:      */
0:     public boolean canPingServer(int port, int SLEEP_TIME, int retries) 
1:     throws SQLException {
1:     
0:         // Wait for the network server to respond
0:         boolean started = false;
0:         if (retries > 10)
0:             retries = 10;         // Max retries = max seconds to wait
1: 
0:         while (!started && retries > 0) {
1:             try {
0:                 NetworkServerControl nsctrl = new NetworkServerControl(
0:                         InetAddress.getByName(
0:                                 TestConfiguration.getCurrent().getHostName()),
0:                                 port);
0:                 // Sleep x second and then ping the network server
0:                 Thread.sleep(SLEEP_TIME);
0:                 nsctrl.ping();
1: 
0:                 // If ping does not throw an exception the server has started
0:                 started = true;
0:             } catch(Exception e) {         
0:                 retries--;
1:             }
1:         }
0:         return (started);
1:     }
1:         
0:     private Process runProcess(String[] command) {
0:         final String[] finalCommand = command;
0:         Process serverProcess = (Process) AccessController.doPrivileged
0:         (
0:          new PrivilegedAction()
1:          {
0:              public Object run()
1:              {
0:                  Process result = null;
1:                  try {
0:                     result = Runtime.getRuntime().exec(finalCommand);
0:                  } catch (Exception ex) {
0:                      ex.printStackTrace();
0:                      println("failure starting process");
1:                  }
0:                  return result;
1:              }
1:          }
0:         );
0:         return serverProcess;
1:     }
1:     
1:     // obtain & shutdown the network server;
1:     // port needs to be passed in to verify it's down;
1:     private String shutdownServer(int port, boolean specifyPort) 
1:     throws SQLException {
1:         try {
1:             if (specifyPort)
1:             {
0:                 NetworkServerControl nsctrl = new NetworkServerControl(
0:                     InetAddress.getByName(
0:                         TestConfiguration.getCurrent().getHostName()), port);
1:                 nsctrl.shutdown();
1:             }
1:             else
1:             {
0:                 NetworkServerControl nsctrl = new NetworkServerControl();
1:                 nsctrl.shutdown();
1:             }
1:         } catch (Exception e) {
0:             return "failed to shutdown server with API parameter";
1:         }
0:         if (canPingServer(port,0,1)) {
1:             return "Can still ping server";
1:         }
1:         return null;
1:     }
1: 
1: 
1:     // obtain & start the network server without specifying port;
1:     // port needs to be passed in to verify it's up.
1:     public String startServer(int port, boolean specifyPort) 
1:     throws SQLException {
1:         try {
1:             if (specifyPort)
1:             {
0:                 NetworkServerControl nsctrl = new NetworkServerControl(
0:                         InetAddress.getByName(
0:                             TestConfiguration.getCurrent().getHostName()),
0:                             port);
1:                 // For debugging, to make output come to console uncomment:
1:                 //nsctrl.start(new PrintWriter(System.out, true));
1:                 // and comment out:
1:                 nsctrl.start(null);
1:                 NetworkServerTestSetup.waitForServerStart(nsctrl);
1:             }
1:             else
1:             {
0:             NetworkServerControl nsctrl = new NetworkServerControl();
1:                 // For debugging, to make output come to console uncomment:
1:                 //nsctrl.start(new PrintWriter(System.out, true));
1:                 // and comment out:
1:                 nsctrl.start(null);
1:                 NetworkServerTestSetup.waitForServerStart(nsctrl);
1:             }
1:         } catch (Exception e) {
1:             return "failed to start server with port " + port;
1:         }
1:         // check that we have this server up now
0:         if (!canPingServer(port, 1, 10)) {
1:             return "Cannot ping server started with port set to " + port;
1:         }
1:         return null;
1:     }
1:     
1:     /**
0:      *  Shutdown the server on the specified port - for cleanup
1:      */
0:     public void shutdownServer(int port) throws SQLException {
1:         try {
0:         NetworkServerControl nsctrl = new NetworkServerControl(
0:             InetAddress.getByName(
0:                 TestConfiguration.getCurrent().getHostName()), port);
1:         nsctrl.shutdown();
1:         } catch (Exception e) {
0:             // ignore errors for this one.
1:         }
1:     }
1:     
0:    public void checkWhetherNeedToShutdown(int[] portsSoFar, String failReason) {
1:        
1:        if (!(failReason == null))
1:        {
0:            if (portsSoFar != null && portsSoFar[0] != 0);
0:            for (int i = 0 ; i < portsSoFar.length ; i++)
1:            {
1:                try {
0:                    shutdownServer(portsSoFar[i]);
0:                } catch (SQLException e) {
0:                    fail("could not shutdown server at port " + portsSoFar[i]);
1:                }
1:            }
0:        fail(failReason);
1:        }
1:    }
1:    
1:    /**
1:     * Execute command and verify that it completes successfully
1:     * @param Cmd array of java arguments for command
1:     * @throws InterruptedException
1:     * @throws IOException
1:     */
1:    private void  assertSuccessfulCmd(String expectedString, String[] Cmd) throws InterruptedException, IOException {
0:        InputStream is = Utilities.execJavaCmd(Cmd, 0);
0:        byte[] b = new byte[80];
0:        is.read(b, 0, 80);
0:        String output = new String(b);
0:        //System.out.println("output: " + output);
0:        assertTrue(output.startsWith(expectedString));
1:    }
1: 
1:    /**
0:     * Execute command and verify that it completes with
0:     * an error
0:     * This method does *not* use Utilities.execJavaCmd, because
0:     * that one will hang on waitFor() when the usage message needs
0:     * to get extracted. This is probably DERBY-3251.
0:     * Note: this method may possibly be extracted 
0:     *     be placed in either Utilities or one of the Configuration
0:     *     or Setup classes, but as there is an intermittent problem
0:     *     with it, holding off on that
0:     * @param expectedString String to compare the resulting output with
0:     * @param cmd array of java arguments for command
0:     * @param expectedExitValue expected return value from the command
1:     * @throws InterruptedException
1:     * @throws IOException
1:     */
0:    private void  assertUsageMessage(
0:            String[] expectedString, String[] cmd, int expectedExitValue)
0:    throws InterruptedException, IOException {
1:        
0:        int totalSize = 3 + cmd.length;
0:        String[] tcmd = new String[totalSize];
0:        tcmd[0] = "java";
0:        tcmd[1] = "-classpath";
0:        tcmd[2] = BaseTestCase.getSystemProperty("java.class.path");
1:                
0:        System.arraycopy(cmd, 0, tcmd, 3, cmd.length);
1:        
0:        final String[] command = tcmd;
0:        Process pr = null;
1:        try {
0:            pr = (Process) AccessController
0:                .doPrivileged(new PrivilegedExceptionAction() {
0:                    public Object run() throws IOException {
0:                        Process result = null;
0:                            result = Runtime.getRuntime().exec(command);
0:                        return result;
1:                    }
1:                });
0:        } catch (PrivilegedActionException pe) {
0:            Exception e = pe.getException();
0:            if (e instanceof IOException)
0:                throw (IOException) e;
1:            else
0:                throw (SecurityException) e;
1:        }
0:        InputStream is = pr.getInputStream();
0:        if ( is == null )
1:        {
0:            fail("Unexpectedly receiving no text from the java command");
1:        }
1:        
0:        String output = "";
0:        try
1:        {
0:            char[] ca = new char[1024];
0:            // Create an InputStreamReader with UTF-8 encoding
0:            // use default encoding; we're hoping this to be en.
0:            // if not, it's not going to match the expected string.
0:            InputStreamReader inStream;
0:                //inStream = new InputStreamReader(is, "UTF-8");
0:                inStream = new InputStreamReader(is);
0:            // keep reading from the stream until all done
0:            while ((inStream.read(ca, 0, ca.length)) != -1)
1:            {
0:                output = output + new String(ca).trim();
1:            }
1:        } catch (Exception e) {
0:            fail("Exception accessing inputstream from javacommand");
1:        }
1:        
0:        // wait until the process exits
0:        pr.waitFor();
1:        
0:        Assert.assertEquals(expectedExitValue, pr.exitValue());
0:        for (int i=0 ; i<expectedString.length ; i++)
1:        {
0:            assertFalse(output.indexOf(expectedString[i]) < 0);
1:        }
1:    }
1:    
1:    
1: 
1:     /**
1:      *  Test port setting priority
1:      */
0:     public void ttestSetPortPriority() throws SQLException {
1:         // default is 1527. The test harness configuration would
1:         // use the API and add the port number. We want to test all
1:         // 4 mechanisms for specifying the port.
1:         // To ensure getting a unique port number, this test leaves open
1:         // each server for a bit.
1:         // as we need to test the default as well as with setting various
1:         // properties, this test can't rely on the testsetup.
1: 
1:         // So, first, bring default server down if up
1:         // Note: if the harness gets modified to accomodate splitting
1:         //    over different networkservers, there maybe something more
1:         //    appropriate than shutting down the default server.
0:         if (canPingServer(1527, 0, 1)) {
1:             // for now, shutdown
0:             shutdownServer(1527, false);
1:         }
0:         // start the default, which at this point should be localhost and 1527
0:         String actionResult = startServer(1527, false);
0:         checkWhetherNeedToShutdown(new int[] {1527}, actionResult);
1:         
1:         // set derby.drda.portNumber to an alternate number in derby.properties
0:         int firstAlternatePort = getAlternativePort();
1:         final Properties derbyProperties = new Properties();
1:         derbyProperties.put("derby.drda.portNumber", 
0:                 new Integer(firstAlternatePort).toString());
1: 
0:         String tmpDerbyHome = "";
1:         try {
0:             final String derbyHome = (String)
0:             AccessController.doPrivileged
0:             (new java.security.PrivilegedAction(){
0:                 public Object run(){
0:                     String x = System.getProperty(
0:                         "derby.system.home");
0:                     println("derbyhome: " + x);
0:                         return x;
1:                 }
1:             });
0:             tmpDerbyHome = derbyHome;
1:         } catch (Exception e) {
0:             checkWhetherNeedToShutdown(new int[] {1527}, "failed to get derby.system.home for test");
1:         }
1:         
0:         final String derbyHome = tmpDerbyHome;
0:         Boolean b = (Boolean)AccessController.doPrivileged
0:         (new java.security.PrivilegedAction(){
0:             public Object run(){
1:                 boolean fail = false;
1:                 try {
1:                     FileOutputStream propFile = 
1:                         new FileOutputStream(derbyHome + File.separator + "derby.properties");
1:                     derbyProperties.store(propFile,"testing derby.properties");
1:                     propFile.close();
1:                 } catch (IOException ioe) {
1:                     fail = true;
1:                 }
0:                 return new Boolean(fail);
1:             }
1:         });
0:         if (b.booleanValue())
1:        {
0:             checkWhetherNeedToShutdown(new int[] {1527}, "failed to write derby.properties");
1:         }
1:         // have to shutdown engine to force read of derby.properties
1:         TestConfiguration.getCurrent().shutdownEngine();
1:         actionResult = startServer(firstAlternatePort, false);
0:         checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort}, actionResult);
1: 
0:         final int secondAlternatePort = getAlternativePort();
1:         // Now set system properties.
1:         setSystemProperty("derby.drda.portNumber", 
0:             new Integer(secondAlternatePort).toString());
1:         actionResult = startServer(secondAlternatePort, false);
0:         checkWhetherNeedToShutdown( new int[] {1527, firstAlternatePort, secondAlternatePort},
1:             actionResult);
1:         
1:         // now try with specifying port
1:         // Note that we didn't unset the system property yet, nor did
1:         // we get rid of derby.properties...
1:         // command line parameter should take hold
0:         int thirdAlternatePort = getAlternativePort();
1:         actionResult = startServer(thirdAlternatePort, true);
0:         checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
1:             thirdAlternatePort}, actionResult);
1: 
1:         // now with -p. 
0:         int fourthAlternatePort = getAlternativePort();
0:         String classpath = getSystemProperty("java.class.path");
0:         String[] commandArray = {"java", "-classpath", classpath, 
0:             "-Dderby.system.home=" + derbyHome,
1:             "org.apache.derby.drda.NetworkServerControl", "-p",
1:             String.valueOf(fourthAlternatePort).toString(), 
1:             "-noSecurityManager", "start"};
0:         Process p = runProcess(commandArray);
1:         
0:         if (!canPingServer(fourthAlternatePort,1,10)) {
1:             actionResult = "Can not ping server specified with -p";
1:         }
0:         checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
1:             thirdAlternatePort, fourthAlternatePort}, actionResult);
1:             
1:         // shutdown with -p
0:         commandArray = new String[] {"java", "-classpath", classpath, 
0:                 "-Dderby.system.home=" + derbyHome,
1:                 "org.apache.derby.drda.NetworkServerControl", "-p",
1:                 String.valueOf(fourthAlternatePort).toString(), 
1:                 "-noSecurityManager", "shutdown"};
0:         Process p2 = runProcess(commandArray);
1: 
0:         if (canPingServer(fourthAlternatePort,1000,10)) {
1:             actionResult = "Can still ping server specified with -p";
1:         }
0:         checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
1:             thirdAlternatePort, fourthAlternatePort}, actionResult);
1:             
0:         // clean up
0:         InputStream istr = p.getInputStream();
0:         InputStream istr2 = p2.getInputStream();
1:         try {
0:             istr.close();
0:             istr2.close();
1:         } catch (Exception e) {
1:             e.printStackTrace();
0:             fail("cannot close spawned process' inputstream");
1:         }
0:         istr=null;
0:         istr2=null;
0:         p.destroy();
0:         p=null;
0:         p2.destroy();
0:         p2=null;
1:         
1:         // shutdown with port specified in constructor
1:         actionResult = shutdownServer(thirdAlternatePort, true);
0:         checkWhetherNeedToShutdown( new int[] {1527, firstAlternatePort, secondAlternatePort,
1:             thirdAlternatePort}, actionResult);
1:         
1:         // shutdown using System property
1:         actionResult = shutdownServer(secondAlternatePort, false);
0:         checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort, secondAlternatePort},
1:             actionResult);
1:         // remove system property
1:         removeSystemProperty("derby.drda.portNumber");
1: 
1:         // shutdown server with port set in derby.properties
1:         actionResult = shutdownServer(firstAlternatePort, false);
0:         checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort},
1:             actionResult);
1:         // remove derby.properties
0:         Boolean ret = (Boolean) AccessController.doPrivileged
0:         (new java.security.PrivilegedAction() {
0:             public Object run() {
0:                 return Boolean.valueOf((new File(
0:                     derbyHome+File.separator + "derby.properties")).delete());
1:             }
1:         }
0:         );
0:         if (ret.booleanValue() == false) {
0:             checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort},
1:                 "unable to remove derby.properties");
1:         }
1:         // have to shutdown engine to force re-evaluation of derby.properties
1:         TestConfiguration.getCurrent().shutdownEngine();
1:         
1:         // shutdown the default server
0:         actionResult = shutdownServer(1527, false);
0:         checkWhetherNeedToShutdown ( new int[] {1527}, actionResult);
1:     }
1:     
1:     /**
1:      *   Test start server specifying system properties without values
1:      */
1:     public void ttestDefaultProperties() throws SQLException
1:     {
1:         //check that default properties are used
1:         verifyProperties(new String[] {
0:                 // getProperties returns properties in sequence:
0:                 // maxThreads; sslMode; keepAlive; minThreads; portNumber;
0:                 // logConnections; timeSlice; startNetworkServer; host; traceAll 
0:                 "0", "off", "true", "0", 
0:                 String.valueOf(TestConfiguration.getCurrent().getPort()),
0:                 "false", "0", "false", 
0:                 String.valueOf(TestConfiguration.getCurrent().getHostName()), 
0:                 "false"});     
1:     }
1:        
1:     /**
1:      *   Test trace command on - property traceAll should get set
1:      */
1:     public void testToggleTrace() 
1:     throws SQLException, IOException, InterruptedException
1:     {        
0:         String[] expectedTraceOff = new String[] {
0:                 // getProperties returns properties in sequence:
0:                 // traceDirectory; maxThreads; sslMode; keepAlive; minThreads; 
0:                 // portNumber; logConnections; timeSlice; startNetworkServer;
0:                 // host; traceAll
0:                 getSystemProperty("derby.system.home"),
0:                 "0", "off", "true", "0", 
0:                 String.valueOf(TestConfiguration.getCurrent().getPort()),
0:                 "false", "0", "false", 
0:                 //String.valueOf(TestConfiguration.getCurrent().getHostName()),
0:                 "127.0.0.1", 
0:                 "false"};     
0:         String[] expectedTraceOn = new String[] {
0:                 // getProperties returns properties in sequence:
0:                 // traceDirectory; maxThreads; sslMode; keepAlive; minThreads; 
0:                 // portNumber; logConnections; timeSlice; startNetworkServer;
0:                 // host; traceAll
0:                 getSystemProperty("derby.system.home"),
0:                 "0", "off", "true", "0", 
0:                 String.valueOf(TestConfiguration.getCurrent().getPort()),
0:                 "false", "0", "false", 
0:                 //String.valueOf(TestConfiguration.getCurrent().getHostName()),
0:                 "127.0.0.1", 
0:                 "true"};     
1:         
1:         verifyProperties(expectedTraceOff);     
1: 
1:         String[] traceCmd = new String[] {
0:             "org.apache.derby.drda.NetworkServerControl", "trace", "on" };
1:         assertSuccessfulCmd("Trace turned on for all sessions.", traceCmd);
1:         verifyProperties(expectedTraceOn);     
1: 
1:         traceCmd = new String[] {
0:                 "org.apache.derby.drda.NetworkServerControl", "trace", "off" };
1:         assertSuccessfulCmd("Trace turned off for all sessions", traceCmd);
1:         // traceAll should be back to false
1:         verifyProperties(expectedTraceOff);     
1:     }
1: 
1:     /**
1:      *   Test logconnections on
1:      */
1:     public void testToggleLogConnections() 
1:     throws SQLException, IOException, InterruptedException
1:     {
0:         String[] expectedLogConnectionsOff = new String[] {
0:                 // getProperties returns properties in sequence:
0:                 // traceDirectory; maxThreads; sslMode; keepAlive; minThreads; 
0:                 // portNumber; logConnections; timeSlice; startNetworkServer;
0:                 // host; traceAll
0:                 getSystemProperty("derby.system.home"),
0:                 "0", "off", "true", "0", 
0:                 String.valueOf(TestConfiguration.getCurrent().getPort()),
0:                 "false", "0", "false", 
0:                 //String.valueOf(TestConfiguration.getCurrent().getHostName()),
0:                 "127.0.0.1", 
0:                 "false"};     
0:         String[] expectedLogConnectionsOn = new String[] {
0:                 // getProperties returns properties in sequence:
0:                 // traceDirectory; maxThreads; sslMode; keepAlive; minThreads; 
0:                 // portNumber; logConnections; timeSlice; startNetworkServer;
0:                 // host; traceAll
0:                 getSystemProperty("derby.system.home"),
0:                 "0", "off", "true", "0", 
0:                 String.valueOf(TestConfiguration.getCurrent().getPort()),
0:                 "true", "0", "false", 
0:                 //String.valueOf(TestConfiguration.getCurrent().getHostName()),
0:                 "127.0.0.1", 
0:                 "false"};     
1:         
1:         verifyProperties(expectedLogConnectionsOff);     
1: 
1:         String[] cmd = new String[] {
0:             "org.apache.derby.drda.NetworkServerControl", "logconnections", "on" };
0:         assertSuccessfulCmd("Log Connections changed to on.", cmd);
1:         verifyProperties(expectedLogConnectionsOn);     
1: 
1:         cmd = new String[] {
0:                 "org.apache.derby.drda.NetworkServerControl", "logconnections", "off" };
0:         assertSuccessfulCmd("Log Connections changed to off.", cmd);
1:         // traceAll should be back to false
1:         verifyProperties(expectedLogConnectionsOff);    
1:     }
1: 
1:     
1:     /**
0:      *   Test other commands. These should all give a helpful error and the
0:      *   usage message
0:      *   Note: maybe these test cases should be moved to another Test,
0:      *   as they don't actually test any properties. 
1:      */
0:     public void testWrongCommands() 
1:     throws SQLException, IOException, InterruptedException
1:     {
0:         String nsc = "org.apache.derby.drda.NetworkServerControl";
0:         // no arguments
0:         String[] cmd = new String[] {nsc};
0:         // we'll assume that we get the full message if we get 'Usage'
0:         // because sometimes, the message gets returned with carriage return,
0:         // and sometimes it doesn't, checking for two different parts...
0:         assertUsageMessage(new String[] 
0:             {"No arguments given.", "Usage: "}, cmd, 1);
0:         //Unknown command
0:         cmd = new String[] {nsc, "unknowncmd"};
0:         assertUsageMessage(new String[] 
0:             {"Command unknowncmd is unknown.", "Usage: "}, cmd, 0);
0:         // wrong number of arguments
0:         cmd = new String[] {nsc, "ping", "arg1"};
0:         assertUsageMessage(new String[] 
0:             {"Invalid number of arguments for command ping.",
0:              "Usage: "}, cmd, 1);
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:23a4538
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.OsName;
/////////////////////////////////////////////////////////////////////////
0:         // omit on AIX JDK 1.5 for now as it is causing a hang DERBY-4319
0:         // see also ttestDefaultProperties below
0:         if (! (isPlatform(OsName.AIX) && isJava5())) {
0:         }
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-4319 
0:         if (TestConfiguration.loadingFromJars() &&
0:             (! (isPlatform(OsName.AIX) && isJava5())))
commit:5e25f23
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int firstAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
/////////////////////////////////////////////////////////////////////////
1:         final int secondAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
/////////////////////////////////////////////////////////////////////////
1:         int thirdAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
1:         int fourthAlternatePort = TestConfiguration.getCurrent().getNextAvailablePort();
commit:ad60cd5
/////////////////////////////////////////////////////////////////////////
1:     private int basePort;
1:         this.basePort = TestConfiguration.getCurrent().getPort();
/////////////////////////////////////////////////////////////////////////
0:         
0:         int possiblePort = basePort + 1;
/////////////////////////////////////////////////////////////////////////
1:         if (canPingServer(basePort, false)) {
1:             shutdownServer(basePort, false);
1:         /* 
1:          * The port should be default, but it might not be, so the second argument
1:          * must be true to accommodate for every case.
0:          */
1:         String actionResult = startServer(basePort, true);
1:         checkWhetherNeedToShutdown(new int[] {basePort}, actionResult);
/////////////////////////////////////////////////////////////////////////
1:             checkWhetherNeedToShutdown(new int[] {TestConfiguration.getCurrent().getPort()}, "failed to write derby.properties");
1:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort}, actionResult);
1:         checkWhetherNeedToShutdown( new int[] {basePort, firstAlternatePort, secondAlternatePort},
/////////////////////////////////////////////////////////////////////////
1:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
/////////////////////////////////////////////////////////////////////////
1:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
/////////////////////////////////////////////////////////////////////////
1:         checkWhetherNeedToShutdown(new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:         checkWhetherNeedToShutdown( new int[] {basePort, firstAlternatePort, secondAlternatePort,
1:         checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort, secondAlternatePort},
1:         checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort},
/////////////////////////////////////////////////////////////////////////
1:             checkWhetherNeedToShutdown ( new int[] {basePort, firstAlternatePort},
1:         actionResult = shutdownServer(basePort, true);
1:         checkWhetherNeedToShutdown ( new int[] {basePort}, actionResult);
/////////////////////////////////////////////////////////////////////////
1:         int port = TestConfiguration.getCurrent().getPort();
0: 
1:             "org.apache.derby.drda.NetworkServerControl", "trace", "on", "-p",String.valueOf(port) };
1:                 "org.apache.derby.drda.NetworkServerControl", "trace", "off", "-p",String.valueOf(port) };
/////////////////////////////////////////////////////////////////////////
1:         int port = TestConfiguration.getCurrent().getPort();
0: 
1:             "org.apache.derby.drda.NetworkServerControl", "logconnections", "on","-p",String.valueOf(port) };
1:                 "org.apache.derby.drda.NetworkServerControl", "logconnections", "off", "-p",String.valueOf(port) };
author:Thomas Nielsen
-------------------------------------------------------------------------------
commit:9f61c8b
/////////////////////////////////////////////////////////////////////////
1:         // and testToggleLogConnections (logconnections on/off)
1:         // can all use the default setup with adjusted policy
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a63ab5e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 spt, startupProps, startupArgs, true);
commit:204c040
/////////////////////////////////////////////////////////////////////////
1:             return "failed to shutdown server with API parameter (" + e + ")";
============================================================================