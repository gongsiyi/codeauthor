2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.RowOrderingImpl
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
12:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.compile;
1:c7000cb: 
1:c7000cb: import java.util.ArrayList;
1:b153b24: import java.util.Iterator;
1:e1f49ca: import java.util.ListIterator;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:eac0369: 
1:61070a6: class RowOrderingImpl implements RowOrdering {
1:eac0369: 
1:b153b24:     /** List of ColumnOrderings. */
1:71c8e86: 	private final ArrayList<ColumnOrdering> ordering = new ArrayList<ColumnOrdering>();
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** This ColumnOrdering represents the columns that can be considered
1:eac0369: 	** ordered no matter what.  For example, columns that are compared to
1:eac0369: 	** constants with = are always ordered.  Also, all columns in a one-row
1:200a5ea: 	** result set are ordered. Another instance of always ordered is when
1:200a5ea: 	** the column is involved in an equijoin with an optimizable which is 
1:200a5ea: 	** always ordered on the column on which the equijoin is happening.
1:eac0369: 	*/
1:eac0369: 	ColumnOrdering	columnsAlwaysOrdered;
1:eac0369: 
1:b153b24:     /**
1:b153b24:      * List of table numbers for tables that are always ordered.
1:b153b24:      * This happens for one-row tables.
1:b153b24:      */
1:71c8e86:     private final ArrayList<Optimizable> alwaysOrderedOptimizables = new ArrayList<Optimizable>();
1:eac0369: 
1:eac0369: 	ColumnOrdering	currentColumnOrdering;
1:eac0369: 
1:b153b24:     /** List of unordered Optimizables. */
1:71c8e86:     private final ArrayList<Optimizable> unorderedOptimizables = new ArrayList<Optimizable>();
1:eac0369: 
1:eac0369: 	RowOrderingImpl() {
1:eac0369: 		columnsAlwaysOrdered = new ColumnOrdering(RowOrdering.DONTCARE);
7:eac0369: 	}
1:200a5ea: 	
1:200a5ea: 	/** @see RowOrdering#isColumnAlwaysOrdered */
1:200a5ea: 	public boolean isColumnAlwaysOrdered(int tableNumber, int columnNumber){
1:200a5ea: 		return (columnsAlwaysOrdered.contains(tableNumber, columnNumber)); 
1:200a5ea: 	}
1:eac0369: 
3:eac0369: 	/**
1:eac0369: 	 * @see RowOrdering#orderedOnColumn
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean orderedOnColumn(int direction,
1:eac0369: 									int orderPosition,
1:eac0369: 									int tableNumber,
1:eac0369: 									int columnNumber)
1:eac0369: 				throws StandardException {
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Return true if the table is always ordered.
1:eac0369: 		*/
1:b153b24:         if (alwaysOrdered(tableNumber))
7:eac0369: 		{
2:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Return true if the column is always ordered.
1:eac0369: 		*/
1:eac0369: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Return false if we're looking for an ordering position that isn't
1:eac0369: 		** in this ordering.
1:eac0369: 		*/
1:eac0369: 		if (orderPosition >= ordering.size())
2:eac0369: 			return false;
1:eac0369: 
1:3bb140c:         ColumnOrdering co = ordering.get(orderPosition);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Is the column in question ordered with the given direction at
1:eac0369: 		** this position?
1:eac0369: 		*/
1:eac0369: 		return co.ordered(direction, tableNumber, columnNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RowOrdering#orderedOnColumn
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean orderedOnColumn(int direction,
1:eac0369: 									int tableNumber,
1:eac0369: 									int columnNumber)
1:eac0369: 				throws StandardException {
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Return true if the table is always ordered.
1:eac0369: 		*/
1:b153b24:         if (alwaysOrdered(tableNumber))
1:eac0369: 		{
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Return true if the column is always ordered.
1:eac0369: 		*/
1:eac0369: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean ordered = false;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < ordering.size(); i++) {
1:3bb140c:             ColumnOrdering co = ordering.get(i);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Is the column in question ordered with the given direction at
1:eac0369: 			** this position?
1:eac0369: 			*/
1:eac0369: 			boolean thisOrdered = co.ordered(direction,
2:eac0369: 											tableNumber,
1:eac0369: 											columnNumber);
1:eac0369: 
1:eac0369: 			if (thisOrdered) {
1:eac0369: 				ordered = true;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return ordered;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#addOrderedColumn */
1:eac0369: 	public void addOrderedColumn(int direction,
1:eac0369: 								int tableNumber,
1:eac0369: 								int columnNumber)
1:eac0369: 	{
1:c7000cb:         if (!unorderedOptimizables.isEmpty()) {
1:eac0369: 			return;
1:c7000cb:         }
1:eac0369: 
1:3bb140c:         ColumnOrdering currColOrder;
1:eac0369: 
1:c7000cb: 		if (ordering.isEmpty())
1:eac0369: 		{
1:3bb140c:             currColOrder = new ColumnOrdering(direction);
1:3bb140c:             ordering.add(currColOrder);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:3bb140c:             currColOrder =
1:71c8e86: 				ordering.get(ordering.size() - 1);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:3bb140c:             if (currColOrder.direction() != direction)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("direction == " + direction +
1:eac0369: 					", currentColumnOrdering.direction() == " +
1:3bb140c:                     currColOrder.direction());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         currColOrder.addColumn(tableNumber, columnNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#nextOrderPosition */
1:eac0369: 	public void nextOrderPosition(int direction)
1:eac0369: 	{
1:c7000cb:         if (!unorderedOptimizables.isEmpty()) {
1:eac0369: 			return;
1:c7000cb:         }
1:eac0369: 
2:eac0369: 		currentColumnOrdering = new ColumnOrdering(direction);
1:a32eb9f: 		ordering.add(currentColumnOrdering);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void optimizableAlwaysOrdered(Optimizable optimizable)
1:eac0369: 	{
1:eac0369: 		// A table can't be ordered if there is an outer unordered table
1:eac0369: 		if (unorderedOptimizablesOtherThan(optimizable))
1:eac0369: 		{
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** A table is not "always ordered" if any of the other ordered tables
1:eac0369: 		** in the join order are not also "always ordered".  In other words,
1:eac0369: 		** if any outer table is not a one-row table, this table is not
1:eac0369: 		** always ordered.
1:eac0369: 		**
1:eac0369: 		** The table that was passed in as a parameter may have already been
1:eac0369: 		** added as a table with ordered columns.  If it is the first table
1:eac0369: 		** in the list of ordered columns, then there should be no other
1:eac0369: 		** tables in this list, so we remove it from the list and add it
1:eac0369: 		** to the list of always-ordered tables.
1:eac0369: 		*/
1:eac0369: 		boolean hasTableNumber = optimizable.hasTableNumber();
1:eac0369: 		int tableNumber = (hasTableNumber ? optimizable.getTableNumber() : 0);
1:eac0369: 		if (
1:eac0369: 			(
1:c7000cb: 				(ordering.isEmpty()) ||
1:eac0369: 				(
1:3bb140c:                     hasTableNumber && ordering.get(0).hasTable(tableNumber)
1:eac0369: 				)
1:eac0369: 			)
1:eac0369: 			&&
1:eac0369: 			(
2:eac0369: 				hasTableNumber &&
1:eac0369: 				! columnsAlwaysOrdered.hasAnyOtherTable(tableNumber)
1:eac0369: 			)
1:eac0369: 		   )
1:eac0369: 		{
1:eac0369: 			if (optimizable.hasTableNumber())
1:eac0369: 				removeOptimizable(optimizable.getTableNumber());
1:eac0369: 
1:a32eb9f: 			alwaysOrderedOptimizables.add(optimizable);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#columnAlwaysOrdered */
1:eac0369: 	public void columnAlwaysOrdered(Optimizable optimizable, int columnNumber)
1:eac0369: 	{
1:eac0369: 		columnsAlwaysOrdered.addColumn(optimizable.getTableNumber(),
1:eac0369: 										columnNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#alwaysOrdered */
1:eac0369: 	public boolean alwaysOrdered(int tableNumber)
1:eac0369: 	{
1:71c8e86:         Iterator<Optimizable> it = alwaysOrderedOptimizables.iterator();
1:b153b24:         while (it.hasNext()) {
1:71c8e86:             Optimizable optTable = it.next();
1:b153b24: 
1:b153b24:             if (optTable.hasTableNumber()) {
1:b153b24:                 if (optTable.getTableNumber() == tableNumber) {
1:b153b24:                     return true;
1:b153b24:                 }
1:b153b24:             }
1:b153b24:         }
1:b153b24: 
1:b153b24:         return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#removeOptimizable */
1:eac0369: 	public void removeOptimizable(int tableNumber)
1:eac0369: 	{
3:eac0369: 		int i;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Walk the list backwards, so we can remove elements
1:eac0369: 		** by position.
1:eac0369: 		*/
1:eac0369: 		for (i = ordering.size() - 1; i >= 0; i--)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** First, remove the table from all the ColumnOrderings
1:eac0369: 			*/
1:3bb140c:             ColumnOrdering ord = ordering.get(i);
1:eac0369: 			ord.removeColumns(tableNumber);
1:eac0369: 			if (ord.empty())
1:a32eb9f: 				ordering.remove(i);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Remove from list of always-ordered columns */
1:eac0369: 		columnsAlwaysOrdered.removeColumns(tableNumber);
1:eac0369: 
1:eac0369: 		/* Also remove from list of unordered optimizables */
1:b153b24:         removeOptimizable(tableNumber, unorderedOptimizables);
1:eac0369: 
1:eac0369: 		/* Also remove from list of always ordered optimizables */
1:b153b24:         removeOptimizable(tableNumber, alwaysOrderedOptimizables);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove all optimizables with the given table number from the
1:b153b24:      * given list of optimizables.
1:eac0369: 	 */
1:e1f49ca:     private void removeOptimizable(int tableNumber, ArrayList<Optimizable> list)
1:eac0369: 	{
1:e1f49ca:         ListIterator<Optimizable> it = list.listIterator();
1:e1f49ca: 
1:b153b24:         while (it.hasNext())
1:eac0369: 		{
1:e1f49ca:             Optimizable optTable = it.next();
1:eac0369: 
1:b153b24:             if (optTable.hasTableNumber()
1:b153b24:                     && (optTable.getTableNumber() == tableNumber)) {
1:b153b24:                 it.remove();
1:b153b24:             }
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#addUnorderedOptimizable */
1:eac0369: 	public void addUnorderedOptimizable(Optimizable optimizable)
1:eac0369: 	{
1:a32eb9f: 		unorderedOptimizables.add(optimizable);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RowOrdering#copy */
1:eac0369: 	public void copy(RowOrdering copyTo) {
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if ( ! (copyTo instanceof RowOrderingImpl) ) {
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"copyTo should be a RowOrderingImpl, is a " +
1:eac0369: 					copyTo.getClass().getName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		RowOrderingImpl dest = (RowOrderingImpl) copyTo;
1:eac0369: 
1:eac0369: 		/* Clear the ordering of what we're copying to */
1:a32eb9f: 		dest.ordering.clear();
1:eac0369: 		dest.currentColumnOrdering = null;
1:eac0369: 
1:a32eb9f: 		dest.unorderedOptimizables.clear();
1:eac0369: 		for (int i = 0; i < unorderedOptimizables.size(); i++) {
1:a32eb9f: 			dest.unorderedOptimizables.add(
1:a32eb9f: 											unorderedOptimizables.get(i));
1:eac0369: 		}
1:eac0369: 
1:a32eb9f: 		dest.alwaysOrderedOptimizables.clear();
1:eac0369: 		for (int i = 0; i < alwaysOrderedOptimizables.size(); i++) {
1:a32eb9f: 			dest.alwaysOrderedOptimizables.add(
1:a32eb9f: 										alwaysOrderedOptimizables.get(i));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (int i = 0; i < ordering.size(); i++) {
1:71c8e86: 			ColumnOrdering co = ordering.get(i);
1:eac0369: 
1:a32eb9f: 			dest.ordering.add(co.cloneMe());
1:eac0369: 
1:eac0369: 			if (co == currentColumnOrdering)
1:eac0369: 				dest.rememberCurrentColumnOrdering(i);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		dest.columnsAlwaysOrdered = null;
1:eac0369: 		if (columnsAlwaysOrdered != null)
1:eac0369: 			dest.columnsAlwaysOrdered = columnsAlwaysOrdered.cloneMe();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void rememberCurrentColumnOrdering(int posn) {
1:3bb140c:         currentColumnOrdering = ordering.get(posn);
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:eac0369: 	public String toString() {
1:eac0369: 		String retval = null;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			int i;
1:eac0369: 
1:eac0369: 			retval = "Unordered optimizables: ";
1:eac0369: 
1:eac0369: 			for (i = 0; i < unorderedOptimizables.size(); i++) 
1:eac0369: 			{
1:3bb140c:                 Optimizable opt = unorderedOptimizables.get(i);
1:eac0369: 				if (opt.getBaseTableName() != null)
1:eac0369: 				{
1:eac0369: 					retval += opt.getBaseTableName();
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:a32eb9f: 					retval += unorderedOptimizables.get(i).toString();
1:eac0369: 				}
1:eac0369: 				retval += " ";
1:eac0369: 			}
1:eac0369: 			retval += "\n";
1:eac0369: 
1:eac0369: 			retval += "\nAlways ordered optimizables: ";
1:eac0369: 
1:eac0369: 			for (i = 0; i < alwaysOrderedOptimizables.size(); i++) 
1:eac0369: 			{
1:71c8e86: 				Optimizable opt = alwaysOrderedOptimizables.get(i);
1:eac0369: 				if (opt.getBaseTableName() != null)
1:eac0369: 				{
1:eac0369: 					retval += opt.getBaseTableName();
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:a32eb9f: 					retval += alwaysOrderedOptimizables.get(i).toString();
1:eac0369: 				}
1:eac0369: 				retval += " ";
1:eac0369: 			}
1:eac0369: 			retval += "\n";
1:eac0369: 
1:eac0369: 			for (i = 0; i < ordering.size(); i++) {
1:a32eb9f: 				retval += " ColumnOrdering " + i + ": " + ordering.get(i);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns true if there are unordered optimizables in the join order
1:eac0369: 	 * other than the given one.
1:eac0369: 	 */
1:eac0369: 	private boolean unorderedOptimizablesOtherThan(Optimizable optimizable)
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < unorderedOptimizables.size(); i++)
1:eac0369: 		{
1:eac0369: 			Optimizable thisOpt =
1:71c8e86: 				unorderedOptimizables.get(i);
1:eac0369: 
1:eac0369: 			if (thisOpt != optimizable)
1:eac0369: 				return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: import java.util.ListIterator;
/////////////////////////////////////////////////////////////////////////
1:     private void removeOptimizable(int tableNumber, ArrayList<Optimizable> list)
1:         ListIterator<Optimizable> it = list.listIterator();
1: 
1:             Optimizable optTable = it.next();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
/////////////////////////////////////////////////////////////////////////
1:         ColumnOrdering co = ordering.get(orderPosition);
/////////////////////////////////////////////////////////////////////////
1:             ColumnOrdering co = ordering.get(i);
/////////////////////////////////////////////////////////////////////////
1:         ColumnOrdering currColOrder;
1:             currColOrder = new ColumnOrdering(direction);
1:             ordering.add(currColOrder);
1:             currColOrder =
1:             if (currColOrder.direction() != direction)
1:                     currColOrder.direction());
1:         currColOrder.addColumn(tableNumber, columnNumber);
/////////////////////////////////////////////////////////////////////////
1:                     hasTableNumber && ordering.get(0).hasTable(tableNumber)
/////////////////////////////////////////////////////////////////////////
1:             ColumnOrdering ord = ordering.get(i);
/////////////////////////////////////////////////////////////////////////
1:         currentColumnOrdering = ordering.get(posn);
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 Optimizable opt = unorderedOptimizables.get(i);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private final ArrayList<ColumnOrdering> ordering = new ArrayList<ColumnOrdering>();
/////////////////////////////////////////////////////////////////////////
1:     private final ArrayList<Optimizable> alwaysOrderedOptimizables = new ArrayList<Optimizable>();
1:     private final ArrayList<Optimizable> unorderedOptimizables = new ArrayList<Optimizable>();
/////////////////////////////////////////////////////////////////////////
1: 				ordering.get(ordering.size() - 1);
/////////////////////////////////////////////////////////////////////////
1:         Iterator<Optimizable> it = alwaysOrderedOptimizables.iterator();
1:             Optimizable optTable = it.next();
/////////////////////////////////////////////////////////////////////////
1: 			ColumnOrdering co = ordering.get(i);
/////////////////////////////////////////////////////////////////////////
1: 				Optimizable opt = alwaysOrderedOptimizables.get(i);
/////////////////////////////////////////////////////////////////////////
1: 				unorderedOptimizables.get(i);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b153b24
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1:     /** List of ColumnOrderings. */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * List of table numbers for tables that are always ordered.
1:      * This happens for one-row tables.
1:      */
1:     /** List of unordered Optimizables. */
/////////////////////////////////////////////////////////////////////////
1:         if (alwaysOrdered(tableNumber))
/////////////////////////////////////////////////////////////////////////
1:         if (alwaysOrdered(tableNumber))
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         Iterator it = alwaysOrderedOptimizables.iterator();
1:         while (it.hasNext()) {
0:             Optimizable optTable = (Optimizable) it.next();
1: 
1:             if (optTable.hasTableNumber()) {
1:                 if (optTable.getTableNumber() == tableNumber) {
1:                     return true;
1:                 }
1:             }
1:         }
1: 
1:         return false;
/////////////////////////////////////////////////////////////////////////
1:         removeOptimizable(tableNumber, unorderedOptimizables);
1:         removeOptimizable(tableNumber, alwaysOrderedOptimizables);
1:      * given list of optimizables.
0:     private void removeOptimizable(int tableNumber, ArrayList list)
0:         Iterator it = list.iterator();
1:         while (it.hasNext())
0:             Optimizable optTable = (Optimizable) it.next();
1:             if (optTable.hasTableNumber()
1:                     && (optTable.getTableNumber() == tableNumber)) {
1:                 it.remove();
1:             }
commit:c7000cb
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
1: 
/////////////////////////////////////////////////////////////////////////
0: 	private final ArrayList ordering = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0:     private final ArrayList alwaysOrderedOptimizables = new ArrayList();
0:     private final ArrayList unorderedOptimizables = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0: 	private boolean vectorContainsOptimizable(int tableNumber, ArrayList vec)
/////////////////////////////////////////////////////////////////////////
1:         if (!unorderedOptimizables.isEmpty()) {
1:         }
1: 		if (ordering.isEmpty())
/////////////////////////////////////////////////////////////////////////
1:         if (!unorderedOptimizables.isEmpty()) {
1:         }
/////////////////////////////////////////////////////////////////////////
1: 				(ordering.isEmpty()) ||
/////////////////////////////////////////////////////////////////////////
0: 	private void removeOptimizableFromVector(int tableNumber, ArrayList vec)
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 		ColumnOrdering co = (ColumnOrdering) ordering.get(orderPosition);
/////////////////////////////////////////////////////////////////////////
0: 			ColumnOrdering co = (ColumnOrdering) ordering.get(i);
/////////////////////////////////////////////////////////////////////////
0: 							(Optimizable) vec.get(i);
/////////////////////////////////////////////////////////////////////////
1: 			ordering.add(currentColumnOrdering);
0: 				(ColumnOrdering) ordering.get(ordering.size() - 1);
/////////////////////////////////////////////////////////////////////////
0: 		ordering.add(currentColumnOrdering);
/////////////////////////////////////////////////////////////////////////
0: 					((ColumnOrdering) ordering.get(0)).hasTable(
/////////////////////////////////////////////////////////////////////////
1: 			alwaysOrderedOptimizables.add(optimizable);
/////////////////////////////////////////////////////////////////////////
0: 			ColumnOrdering ord = (ColumnOrdering) ordering.get(i);
1: 				ordering.remove(i);
/////////////////////////////////////////////////////////////////////////
0: 							(Optimizable) vec.get(i);
0: 					vec.remove(i);
/////////////////////////////////////////////////////////////////////////
1: 		unorderedOptimizables.add(optimizable);
/////////////////////////////////////////////////////////////////////////
1: 		dest.ordering.clear();
1: 		dest.unorderedOptimizables.clear();
1: 			dest.unorderedOptimizables.add(
1: 											unorderedOptimizables.get(i));
1: 		dest.alwaysOrderedOptimizables.clear();
1: 			dest.alwaysOrderedOptimizables.add(
1: 										alwaysOrderedOptimizables.get(i));
0: 			ColumnOrdering co = (ColumnOrdering) ordering.get(i);
1: 			dest.ordering.add(co.cloneMe());
/////////////////////////////////////////////////////////////////////////
0: 		currentColumnOrdering = (ColumnOrdering) ordering.get(posn);
/////////////////////////////////////////////////////////////////////////
0: 				Optimizable opt = (Optimizable) unorderedOptimizables.get(i);
1: 					retval += unorderedOptimizables.get(i).toString();
/////////////////////////////////////////////////////////////////////////
0: 				Optimizable opt = (Optimizable) alwaysOrderedOptimizables.get(i);
1: 					retval += alwaysOrderedOptimizables.get(i).toString();
1: 				retval += " ColumnOrdering " + i + ": " + ordering.get(i);
/////////////////////////////////////////////////////////////////////////
0: 				(Optimizable) unorderedOptimizables.get(i);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:200a5ea
/////////////////////////////////////////////////////////////////////////
1: 	** result set are ordered. Another instance of always ordered is when
1: 	** the column is involved in an equijoin with an optimizable which is 
1: 	** always ordered on the column on which the equijoin is happening.
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/** @see RowOrdering#isColumnAlwaysOrdered */
1: 	public boolean isColumnAlwaysOrdered(int tableNumber, int columnNumber){
1: 		return (columnsAlwaysOrdered.contains(tableNumber, columnNumber)); 
1: 	}
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.RowOrderingImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
1: class RowOrderingImpl implements RowOrdering {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import java.util.Vector;
1: 
0: class RowOrderingImpl implements RowOrdering { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
0: 	/* This vector contains ColumnOrderings */
0: 	Vector ordering;
1: 
1: 	/*
1: 	** This ColumnOrdering represents the columns that can be considered
1: 	** ordered no matter what.  For example, columns that are compared to
1: 	** constants with = are always ordered.  Also, all columns in a one-row
0: 	** result set are ordered.
1: 	*/
1: 	ColumnOrdering	columnsAlwaysOrdered;
1: 
1: 	/*
0: 	** This vector contains table numbers for tables that are always ordered.
0: 	** This happens for one-row tables.
1: 	*/
0: 	Vector alwaysOrderedOptimizables;
1: 
1: 	ColumnOrdering	currentColumnOrdering;
1: 
0: 	/* This vector contains unordered Optimizables */
0: 	Vector unorderedOptimizables;
1: 
1: 	RowOrderingImpl() {
0: 		ordering = new Vector();
0: 		unorderedOptimizables = new Vector();
1: 		columnsAlwaysOrdered = new ColumnOrdering(RowOrdering.DONTCARE);
0: 		alwaysOrderedOptimizables = new Vector();
1: 	}
1: 
1: 	/**
1: 	 * @see RowOrdering#orderedOnColumn
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean orderedOnColumn(int direction,
1: 									int orderPosition,
1: 									int tableNumber,
1: 									int columnNumber)
1: 				throws StandardException {
1: 
1: 		/*
1: 		** Return true if the table is always ordered.
1: 		*/
0: 		if (vectorContainsOptimizable(tableNumber, alwaysOrderedOptimizables))
1: 		{
1: 			return true;
1: 		}
1: 
1: 		/*
1: 		** Return true if the column is always ordered.
1: 		*/
1: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
1: 			return true;
1: 		}
1: 
1: 		/*
1: 		** Return false if we're looking for an ordering position that isn't
1: 		** in this ordering.
1: 		*/
1: 		if (orderPosition >= ordering.size())
1: 			return false;
1: 
0: 		ColumnOrdering co = (ColumnOrdering) ordering.elementAt(orderPosition);
1: 
1: 		/*
1: 		** Is the column in question ordered with the given direction at
1: 		** this position?
1: 		*/
1: 		return co.ordered(direction, tableNumber, columnNumber);
1: 	}
1: 
1: 	/**
1: 	 * @see RowOrdering#orderedOnColumn
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean orderedOnColumn(int direction,
1: 									int tableNumber,
1: 									int columnNumber)
1: 				throws StandardException {
1: 
1: 		/*
1: 		** Return true if the table is always ordered.
1: 		*/
0: 		if (vectorContainsOptimizable(tableNumber, alwaysOrderedOptimizables))
1: 		{
1: 			return true;
1: 		}
1: 
1: 		/*
1: 		** Return true if the column is always ordered.
1: 		*/
1: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
1: 			return true;
1: 		}
1: 
1: 		boolean ordered = false;
1: 
1: 		for (int i = 0; i < ordering.size(); i++) {
0: 			ColumnOrdering co = (ColumnOrdering) ordering.elementAt(i);
1: 
1: 			/*
1: 			** Is the column in question ordered with the given direction at
1: 			** this position?
1: 			*/
1: 			boolean thisOrdered = co.ordered(direction,
1: 											tableNumber,
1: 											columnNumber);
1: 
1: 			if (thisOrdered) {
1: 				ordered = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		return ordered;
1: 	}
1: 
1: 	/**
0: 	 * Return true if the given vector of Optimizables contains an Optimizable
0: 	 * with the given table number.
1: 	 */
0: 	private boolean vectorContainsOptimizable(int tableNumber, Vector vec)
1: 	{
1: 		int i;
1: 
0: 		for (i = vec.size() - 1; i >= 0; i--)
1: 		{
0: 			Optimizable optTable =
0: 							(Optimizable) vec.elementAt(i);
1: 
0: 			if (optTable.hasTableNumber())
1: 			{
0: 				if (optTable.getTableNumber() == tableNumber)
1: 				{
1: 					return true;
1: 				}
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/** @see RowOrdering#addOrderedColumn */
1: 	public void addOrderedColumn(int direction,
1: 								int tableNumber,
1: 								int columnNumber)
1: 	{
0: 		if (unorderedOptimizables.size() > 0)
1: 			return;
1: 
0: 		ColumnOrdering currentColumnOrdering;
1: 
0: 		if (ordering.size() == 0)
1: 		{
1: 			currentColumnOrdering = new ColumnOrdering(direction);
0: 			ordering.addElement(currentColumnOrdering);
1: 		}
1: 		else
1: 		{
0: 			currentColumnOrdering =
0: 				(ColumnOrdering) ordering.elementAt(ordering.size() - 1);
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (currentColumnOrdering.direction() != direction)
1: 			{
1: 				SanityManager.THROWASSERT("direction == " + direction +
1: 					", currentColumnOrdering.direction() == " +
0: 					currentColumnOrdering.direction());
1: 			}
1: 		}
1: 
0: 		currentColumnOrdering.addColumn(tableNumber, columnNumber);
1: 	}
1: 
1: 	/** @see RowOrdering#nextOrderPosition */
1: 	public void nextOrderPosition(int direction)
1: 	{
0: 		if (unorderedOptimizables.size() > 0)
1: 			return;
1: 
1: 		currentColumnOrdering = new ColumnOrdering(direction);
0: 		ordering.addElement(currentColumnOrdering);
1: 	}
1: 
1: 	public void optimizableAlwaysOrdered(Optimizable optimizable)
1: 	{
1: 		// A table can't be ordered if there is an outer unordered table
1: 		if (unorderedOptimizablesOtherThan(optimizable))
1: 		{
1: 			return;
1: 		}
1: 
1: 		/*
1: 		** A table is not "always ordered" if any of the other ordered tables
1: 		** in the join order are not also "always ordered".  In other words,
1: 		** if any outer table is not a one-row table, this table is not
1: 		** always ordered.
1: 		**
1: 		** The table that was passed in as a parameter may have already been
1: 		** added as a table with ordered columns.  If it is the first table
1: 		** in the list of ordered columns, then there should be no other
1: 		** tables in this list, so we remove it from the list and add it
1: 		** to the list of always-ordered tables.
1: 		*/
1: 		boolean hasTableNumber = optimizable.hasTableNumber();
1: 		int tableNumber = (hasTableNumber ? optimizable.getTableNumber() : 0);
1: 		if (
1: 			(
0: 				(ordering.size() == 0) ||
1: 				(
1: 					hasTableNumber &&
0: 					((ColumnOrdering) ordering.elementAt(0)).hasTable(
0: 																	tableNumber)
1: 				)
1: 			)
1: 			&&
1: 			(
1: 				hasTableNumber &&
1: 				! columnsAlwaysOrdered.hasAnyOtherTable(tableNumber)
1: 			)
1: 		   )
1: 		{
1: 			if (optimizable.hasTableNumber())
1: 				removeOptimizable(optimizable.getTableNumber());
1: 
0: 			alwaysOrderedOptimizables.addElement(optimizable);
1: 		}
1: 	}
1: 
1: 	/** @see RowOrdering#columnAlwaysOrdered */
1: 	public void columnAlwaysOrdered(Optimizable optimizable, int columnNumber)
1: 	{
1: 		columnsAlwaysOrdered.addColumn(optimizable.getTableNumber(),
1: 										columnNumber);
1: 	}
1: 
1: 	/** @see RowOrdering#alwaysOrdered */
1: 	public boolean alwaysOrdered(int tableNumber)
1: 	{
0: 		return vectorContainsOptimizable(
1: 										tableNumber,
0: 										alwaysOrderedOptimizables
0: 										);
1: 	}
1: 
1: 	/** @see RowOrdering#removeOptimizable */
1: 	public void removeOptimizable(int tableNumber)
1: 	{
1: 		int i;
1: 
1: 		/*
1: 		** Walk the list backwards, so we can remove elements
1: 		** by position.
1: 		*/
1: 		for (i = ordering.size() - 1; i >= 0; i--)
1: 		{
1: 			/*
1: 			** First, remove the table from all the ColumnOrderings
1: 			*/
0: 			ColumnOrdering ord = (ColumnOrdering) ordering.elementAt(i);
1: 			ord.removeColumns(tableNumber);
1: 			if (ord.empty())
0: 				ordering.removeElementAt(i);
1: 		}
1: 
1: 		/* Remove from list of always-ordered columns */
1: 		columnsAlwaysOrdered.removeColumns(tableNumber);
1: 
1: 		/* Also remove from list of unordered optimizables */
0: 		removeOptimizableFromVector(tableNumber, unorderedOptimizables);
1: 
1: 		/* Also remove from list of always ordered optimizables */
0: 		removeOptimizableFromVector(tableNumber, alwaysOrderedOptimizables);
1: 	}
1: 
1: 	/**
1: 	 * Remove all optimizables with the given table number from the
0: 	 * given vector of optimizables.
1: 	 */
0: 	private void removeOptimizableFromVector(int tableNumber, Vector vec)
1: 	{
1: 		int i;
1: 
0: 		for (i = vec.size() - 1; i >= 0; i--)
1: 		{
0: 			Optimizable optTable =
0: 							(Optimizable) vec.elementAt(i);
1: 
0: 			if (optTable.hasTableNumber())
1: 			{
0: 				if (optTable.getTableNumber() == tableNumber)
1: 				{
0: 					vec.removeElementAt(i);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/** @see RowOrdering#addUnorderedOptimizable */
1: 	public void addUnorderedOptimizable(Optimizable optimizable)
1: 	{
0: 		unorderedOptimizables.addElement(optimizable);
1: 	}
1: 
1: 	/** @see RowOrdering#copy */
1: 	public void copy(RowOrdering copyTo) {
1: 		if (SanityManager.DEBUG) {
1: 			if ( ! (copyTo instanceof RowOrderingImpl) ) {
1: 				SanityManager.THROWASSERT(
1: 					"copyTo should be a RowOrderingImpl, is a " +
1: 					copyTo.getClass().getName());
1: 			}
1: 		}
1: 
1: 		RowOrderingImpl dest = (RowOrderingImpl) copyTo;
1: 
1: 		/* Clear the ordering of what we're copying to */
0: 		dest.ordering.removeAllElements();
1: 		dest.currentColumnOrdering = null;
1: 
0: 		dest.unorderedOptimizables.removeAllElements();
1: 		for (int i = 0; i < unorderedOptimizables.size(); i++) {
0: 			dest.unorderedOptimizables.addElement(
0: 											unorderedOptimizables.elementAt(i));
1: 		}
1: 
0: 		dest.alwaysOrderedOptimizables.removeAllElements();
1: 		for (int i = 0; i < alwaysOrderedOptimizables.size(); i++) {
0: 			dest.alwaysOrderedOptimizables.addElement(
0: 										alwaysOrderedOptimizables.elementAt(i));
1: 		}
1: 
1: 		for (int i = 0; i < ordering.size(); i++) {
0: 			ColumnOrdering co = (ColumnOrdering) ordering.elementAt(i);
1: 
0: 			dest.ordering.addElement(co.cloneMe());
1: 
1: 			if (co == currentColumnOrdering)
1: 				dest.rememberCurrentColumnOrdering(i);
1: 		}
1: 
1: 		dest.columnsAlwaysOrdered = null;
1: 		if (columnsAlwaysOrdered != null)
1: 			dest.columnsAlwaysOrdered = columnsAlwaysOrdered.cloneMe();
1: 	}
1: 
1: 	private void rememberCurrentColumnOrdering(int posn) {
0: 		currentColumnOrdering = (ColumnOrdering) ordering.elementAt(posn);
1: 	}
1: 
1: 	public String toString() {
1: 		String retval = null;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			int i;
1: 
1: 			retval = "Unordered optimizables: ";
1: 
1: 			for (i = 0; i < unorderedOptimizables.size(); i++) 
1: 			{
0: 				Optimizable opt = (Optimizable) unorderedOptimizables.elementAt(i);
1: 				if (opt.getBaseTableName() != null)
1: 				{
1: 					retval += opt.getBaseTableName();
1: 				}
1: 				else
1: 				{
0: 					retval += unorderedOptimizables.elementAt(i).toString();
1: 				}
1: 				retval += " ";
1: 			}
1: 			retval += "\n";
1: 
1: 			retval += "\nAlways ordered optimizables: ";
1: 
1: 			for (i = 0; i < alwaysOrderedOptimizables.size(); i++) 
1: 			{
0: 				Optimizable opt = (Optimizable) alwaysOrderedOptimizables.elementAt(i);
1: 				if (opt.getBaseTableName() != null)
1: 				{
1: 					retval += opt.getBaseTableName();
1: 				}
1: 				else
1: 				{
0: 					retval += alwaysOrderedOptimizables.elementAt(i).toString();
1: 				}
1: 				retval += " ";
1: 			}
1: 			retval += "\n";
1: 
1: 			for (i = 0; i < ordering.size(); i++) {
0: 				retval += " ColumnOrdering " + i + ": " + ordering.elementAt(i);
1: 			}
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * Returns true if there are unordered optimizables in the join order
1: 	 * other than the given one.
1: 	 */
1: 	private boolean unorderedOptimizablesOtherThan(Optimizable optimizable)
1: 	{
1: 		for (int i = 0; i < unorderedOptimizables.size(); i++)
1: 		{
1: 			Optimizable thisOpt =
0: 				(Optimizable) unorderedOptimizables.elementAt(i);
1: 
1: 			if (thisOpt != optimizable)
1: 				return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.util.Vector;
0: 
0: class RowOrderingImpl implements RowOrdering { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	/* This vector contains ColumnOrderings */
0: 	Vector ordering;
0: 
0: 	/*
0: 	** This ColumnOrdering represents the columns that can be considered
0: 	** ordered no matter what.  For example, columns that are compared to
0: 	** constants with = are always ordered.  Also, all columns in a one-row
0: 	** result set are ordered.
0: 	*/
0: 	ColumnOrdering	columnsAlwaysOrdered;
0: 
0: 	/*
0: 	** This vector contains table numbers for tables that are always ordered.
0: 	** This happens for one-row tables.
0: 	*/
0: 	Vector alwaysOrderedOptimizables;
0: 
0: 	ColumnOrdering	currentColumnOrdering;
0: 
0: 	/* This vector contains unordered Optimizables */
0: 	Vector unorderedOptimizables;
0: 
0: 	RowOrderingImpl() {
0: 		ordering = new Vector();
0: 		unorderedOptimizables = new Vector();
0: 		columnsAlwaysOrdered = new ColumnOrdering(RowOrdering.DONTCARE);
0: 		alwaysOrderedOptimizables = new Vector();
0: 	}
0: 
0: 	/**
0: 	 * @see RowOrdering#orderedOnColumn
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean orderedOnColumn(int direction,
0: 									int orderPosition,
0: 									int tableNumber,
0: 									int columnNumber)
0: 				throws StandardException {
0: 
0: 		/*
0: 		** Return true if the table is always ordered.
0: 		*/
0: 		if (vectorContainsOptimizable(tableNumber, alwaysOrderedOptimizables))
0: 		{
0: 			return true;
0: 		}
0: 
0: 		/*
0: 		** Return true if the column is always ordered.
0: 		*/
0: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
0: 			return true;
0: 		}
0: 
0: 		/*
0: 		** Return false if we're looking for an ordering position that isn't
0: 		** in this ordering.
0: 		*/
0: 		if (orderPosition >= ordering.size())
0: 			return false;
0: 
0: 		ColumnOrdering co = (ColumnOrdering) ordering.elementAt(orderPosition);
0: 
0: 		/*
0: 		** Is the column in question ordered with the given direction at
0: 		** this position?
0: 		*/
0: 		return co.ordered(direction, tableNumber, columnNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see RowOrdering#orderedOnColumn
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean orderedOnColumn(int direction,
0: 									int tableNumber,
0: 									int columnNumber)
0: 				throws StandardException {
0: 
0: 		/*
0: 		** Return true if the table is always ordered.
0: 		*/
0: 		if (vectorContainsOptimizable(tableNumber, alwaysOrderedOptimizables))
0: 		{
0: 			return true;
0: 		}
0: 
0: 		/*
0: 		** Return true if the column is always ordered.
0: 		*/
0: 		if (columnsAlwaysOrdered.contains(tableNumber, columnNumber)) {
0: 			return true;
0: 		}
0: 
0: 		boolean ordered = false;
0: 
0: 		for (int i = 0; i < ordering.size(); i++) {
0: 			ColumnOrdering co = (ColumnOrdering) ordering.elementAt(i);
0: 
0: 			/*
0: 			** Is the column in question ordered with the given direction at
0: 			** this position?
0: 			*/
0: 			boolean thisOrdered = co.ordered(direction,
0: 											tableNumber,
0: 											columnNumber);
0: 
0: 			if (thisOrdered) {
0: 				ordered = true;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return ordered;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the given vector of Optimizables contains an Optimizable
0: 	 * with the given table number.
0: 	 */
0: 	private boolean vectorContainsOptimizable(int tableNumber, Vector vec)
0: 	{
0: 		int i;
0: 
0: 		for (i = vec.size() - 1; i >= 0; i--)
0: 		{
0: 			Optimizable optTable =
0: 							(Optimizable) vec.elementAt(i);
0: 
0: 			if (optTable.hasTableNumber())
0: 			{
0: 				if (optTable.getTableNumber() == tableNumber)
0: 				{
0: 					return true;
0: 				}
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/** @see RowOrdering#addOrderedColumn */
0: 	public void addOrderedColumn(int direction,
0: 								int tableNumber,
0: 								int columnNumber)
0: 	{
0: 		if (unorderedOptimizables.size() > 0)
0: 			return;
0: 
0: 		ColumnOrdering currentColumnOrdering;
0: 
0: 		if (ordering.size() == 0)
0: 		{
0: 			currentColumnOrdering = new ColumnOrdering(direction);
0: 			ordering.addElement(currentColumnOrdering);
0: 		}
0: 		else
0: 		{
0: 			currentColumnOrdering =
0: 				(ColumnOrdering) ordering.elementAt(ordering.size() - 1);
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (currentColumnOrdering.direction() != direction)
0: 			{
0: 				SanityManager.THROWASSERT("direction == " + direction +
0: 					", currentColumnOrdering.direction() == " +
0: 					currentColumnOrdering.direction());
0: 			}
0: 		}
0: 
0: 		currentColumnOrdering.addColumn(tableNumber, columnNumber);
0: 	}
0: 
0: 	/** @see RowOrdering#nextOrderPosition */
0: 	public void nextOrderPosition(int direction)
0: 	{
0: 		if (unorderedOptimizables.size() > 0)
0: 			return;
0: 
0: 		currentColumnOrdering = new ColumnOrdering(direction);
0: 		ordering.addElement(currentColumnOrdering);
0: 	}
0: 
0: 	public void optimizableAlwaysOrdered(Optimizable optimizable)
0: 	{
0: 		// A table can't be ordered if there is an outer unordered table
0: 		if (unorderedOptimizablesOtherThan(optimizable))
0: 		{
0: 			return;
0: 		}
0: 
0: 		/*
0: 		** A table is not "always ordered" if any of the other ordered tables
0: 		** in the join order are not also "always ordered".  In other words,
0: 		** if any outer table is not a one-row table, this table is not
0: 		** always ordered.
0: 		**
0: 		** The table that was passed in as a parameter may have already been
0: 		** added as a table with ordered columns.  If it is the first table
0: 		** in the list of ordered columns, then there should be no other
0: 		** tables in this list, so we remove it from the list and add it
0: 		** to the list of always-ordered tables.
0: 		*/
0: 		boolean hasTableNumber = optimizable.hasTableNumber();
0: 		int tableNumber = (hasTableNumber ? optimizable.getTableNumber() : 0);
0: 		if (
0: 			(
0: 				(ordering.size() == 0) ||
0: 				(
0: 					hasTableNumber &&
0: 					((ColumnOrdering) ordering.elementAt(0)).hasTable(
0: 																	tableNumber)
0: 				)
0: 			)
0: 			&&
0: 			(
0: 				hasTableNumber &&
0: 				! columnsAlwaysOrdered.hasAnyOtherTable(tableNumber)
0: 			)
0: 		   )
0: 		{
0: 			if (optimizable.hasTableNumber())
0: 				removeOptimizable(optimizable.getTableNumber());
0: 
0: 			alwaysOrderedOptimizables.addElement(optimizable);
0: 		}
0: 	}
0: 
0: 	/** @see RowOrdering#columnAlwaysOrdered */
0: 	public void columnAlwaysOrdered(Optimizable optimizable, int columnNumber)
0: 	{
0: 		columnsAlwaysOrdered.addColumn(optimizable.getTableNumber(),
0: 										columnNumber);
0: 	}
0: 
0: 	/** @see RowOrdering#alwaysOrdered */
0: 	public boolean alwaysOrdered(int tableNumber)
0: 	{
0: 		return vectorContainsOptimizable(
0: 										tableNumber,
0: 										alwaysOrderedOptimizables
0: 										);
0: 	}
0: 
0: 	/** @see RowOrdering#removeOptimizable */
0: 	public void removeOptimizable(int tableNumber)
0: 	{
0: 		int i;
0: 
0: 		/*
0: 		** Walk the list backwards, so we can remove elements
0: 		** by position.
0: 		*/
0: 		for (i = ordering.size() - 1; i >= 0; i--)
0: 		{
0: 			/*
0: 			** First, remove the table from all the ColumnOrderings
0: 			*/
0: 			ColumnOrdering ord = (ColumnOrdering) ordering.elementAt(i);
0: 			ord.removeColumns(tableNumber);
0: 			if (ord.empty())
0: 				ordering.removeElementAt(i);
0: 		}
0: 
0: 		/* Remove from list of always-ordered columns */
0: 		columnsAlwaysOrdered.removeColumns(tableNumber);
0: 
0: 		/* Also remove from list of unordered optimizables */
0: 		removeOptimizableFromVector(tableNumber, unorderedOptimizables);
0: 
0: 		/* Also remove from list of always ordered optimizables */
0: 		removeOptimizableFromVector(tableNumber, alwaysOrderedOptimizables);
0: 	}
0: 
0: 	/**
0: 	 * Remove all optimizables with the given table number from the
0: 	 * given vector of optimizables.
0: 	 */
0: 	private void removeOptimizableFromVector(int tableNumber, Vector vec)
0: 	{
0: 		int i;
0: 
0: 		for (i = vec.size() - 1; i >= 0; i--)
0: 		{
0: 			Optimizable optTable =
0: 							(Optimizable) vec.elementAt(i);
0: 
0: 			if (optTable.hasTableNumber())
0: 			{
0: 				if (optTable.getTableNumber() == tableNumber)
0: 				{
0: 					vec.removeElementAt(i);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/** @see RowOrdering#addUnorderedOptimizable */
0: 	public void addUnorderedOptimizable(Optimizable optimizable)
0: 	{
0: 		unorderedOptimizables.addElement(optimizable);
0: 	}
0: 
0: 	/** @see RowOrdering#copy */
0: 	public void copy(RowOrdering copyTo) {
0: 		if (SanityManager.DEBUG) {
0: 			if ( ! (copyTo instanceof RowOrderingImpl) ) {
0: 				SanityManager.THROWASSERT(
0: 					"copyTo should be a RowOrderingImpl, is a " +
0: 					copyTo.getClass().getName());
0: 			}
0: 		}
0: 
0: 		RowOrderingImpl dest = (RowOrderingImpl) copyTo;
0: 
0: 		/* Clear the ordering of what we're copying to */
0: 		dest.ordering.removeAllElements();
0: 		dest.currentColumnOrdering = null;
0: 
0: 		dest.unorderedOptimizables.removeAllElements();
0: 		for (int i = 0; i < unorderedOptimizables.size(); i++) {
0: 			dest.unorderedOptimizables.addElement(
0: 											unorderedOptimizables.elementAt(i));
0: 		}
0: 
0: 		dest.alwaysOrderedOptimizables.removeAllElements();
0: 		for (int i = 0; i < alwaysOrderedOptimizables.size(); i++) {
0: 			dest.alwaysOrderedOptimizables.addElement(
0: 										alwaysOrderedOptimizables.elementAt(i));
0: 		}
0: 
0: 		for (int i = 0; i < ordering.size(); i++) {
0: 			ColumnOrdering co = (ColumnOrdering) ordering.elementAt(i);
0: 
0: 			dest.ordering.addElement(co.cloneMe());
0: 
0: 			if (co == currentColumnOrdering)
0: 				dest.rememberCurrentColumnOrdering(i);
0: 		}
0: 
0: 		dest.columnsAlwaysOrdered = null;
0: 		if (columnsAlwaysOrdered != null)
0: 			dest.columnsAlwaysOrdered = columnsAlwaysOrdered.cloneMe();
0: 	}
0: 
0: 	private void rememberCurrentColumnOrdering(int posn) {
0: 		currentColumnOrdering = (ColumnOrdering) ordering.elementAt(posn);
0: 	}
0: 
0: 	public String toString() {
0: 		String retval = null;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			int i;
0: 
0: 			retval = "Unordered optimizables: ";
0: 
0: 			for (i = 0; i < unorderedOptimizables.size(); i++) 
0: 			{
0: 				Optimizable opt = (Optimizable) unorderedOptimizables.elementAt(i);
0: 				if (opt.getBaseTableName() != null)
0: 				{
0: 					retval += opt.getBaseTableName();
0: 				}
0: 				else
0: 				{
0: 					retval += unorderedOptimizables.elementAt(i).toString();
0: 				}
0: 				retval += " ";
0: 			}
0: 			retval += "\n";
0: 
0: 			retval += "\nAlways ordered optimizables: ";
0: 
0: 			for (i = 0; i < alwaysOrderedOptimizables.size(); i++) 
0: 			{
0: 				Optimizable opt = (Optimizable) alwaysOrderedOptimizables.elementAt(i);
0: 				if (opt.getBaseTableName() != null)
0: 				{
0: 					retval += opt.getBaseTableName();
0: 				}
0: 				else
0: 				{
0: 					retval += alwaysOrderedOptimizables.elementAt(i).toString();
0: 				}
0: 				retval += " ";
0: 			}
0: 			retval += "\n";
0: 
0: 			for (i = 0; i < ordering.size(); i++) {
0: 				retval += " ColumnOrdering " + i + ": " + ordering.elementAt(i);
0: 			}
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * Returns true if there are unordered optimizables in the join order
0: 	 * other than the given one.
0: 	 */
0: 	private boolean unorderedOptimizablesOtherThan(Optimizable optimizable)
0: 	{
0: 		for (int i = 0; i < unorderedOptimizables.size(); i++)
0: 		{
0: 			Optimizable thisOpt =
0: 				(Optimizable) unorderedOptimizables.elementAt(i);
0: 
0: 			if (thisOpt != optimizable)
0: 				return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: }
============================================================================