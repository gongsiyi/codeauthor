1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.load.ImportAbstract
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:eac0369: 
1:2732872: import java.io.ByteArrayInputStream;
1:2732872: import java.io.ObjectInputStream;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.SQLWarning;
1:eac0369: import java.sql.ResultSetMetaData;
1:eac0369: import org.apache.derby.vti.VTITemplate;
1:eac0369: import java.util.ArrayList;
1:2732872: import java.util.HashMap;
1:ea980d3: import org.apache.derby.iapi.util.StringUtil;
1:7c20bd0: import org.apache.derby.iapi.error.PublicAPI;
1:7c20bd0: import org.apache.derby.iapi.reference.SQLState;
1:7c20bd0: import org.apache.derby.iapi.error.StandardException;
1:7c20bd0: 
1:eac0369: 
2:eac0369: /**
1:eac0369:  * 
1:eac0369:  * <P>
1:eac0369:  */
1:eac0369: abstract class ImportAbstract extends VTITemplate {
1:eac0369: 
1:7a92d1f:   ControlInfo controlFileReader;
1:7a92d1f:   ImportReadData importReadData;
1:eac0369: 
1:7a92d1f:   String[] columnNames;
1:7a92d1f:   int numberOfColumns;
1:7a92d1f:   int[] columnWidths;
1:eac0369: 
1:97fdc36:   int lineNumber = 0;
1:7a92d1f:   String[] nextRow;
1:eac0369: 
1:2732872:   ImportResultSetMetaData importResultSetMetaData;
1:7a92d1f:   int noOfColumnsExpected;
1:eac0369: 
1:84e347a:   protected boolean lobsInExtFile = false;
1:84e347a: 
1:84e347a:   String tableColumnTypesStr;
1:84e347a:   int[] tableColumnTypes;
1:2732872:   String columnTypeNamesString;
1:2732872:   String[] columnTypeNames;
1:2732872:   String  udtClassNamesString;
1:2732872:   HashMap udtClasses;
1:eac0369:   private boolean wasNull;
1:eac0369: 
1:7a92d1f: 	static final String COLUMNNAMEPREFIX = "COLUMN";
1:eac0369: 
1:7a92d1f:   abstract ImportReadData getImportReadData() throws Exception;
1:eac0369: 
1:eac0369:   /** Does all the work
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:7a92d1f:   void doAllTheWork() throws Exception {
1:eac0369: 
1:eac0369:     //prepare the input file for import. Get the number of columns per row
1:eac0369:     //from the input file.
1:eac0369:     importReadData = getImportReadData();
1:eac0369:     numberOfColumns = importReadData.getNumberOfColumns();
1:eac0369: 	if(numberOfColumns == 0)
1:eac0369: 	{
1:eac0369: 		//file is empty. Assume same number of columns expected 
1:eac0369: 		//and return no data , But No rows gets insereted.
1:eac0369: 		this.numberOfColumns = noOfColumnsExpected;
1:eac0369: 	}
1:3568cea: 
1:eac0369:     columnWidths = controlFileReader.getColumnWidths();
1:eac0369:     columnNames = new String[numberOfColumns];
1:eac0369:     loadColumnNames();
1:eac0369:     nextRow = new String[numberOfColumns];
1:84e347a:     tableColumnTypes = ColumnInfo.getExpectedVtiColumnTypes(tableColumnTypesStr,
1:84e347a:                                                             numberOfColumns);
1:2732872:     columnTypeNames =  ColumnInfo.getExpectedColumnTypeNames( columnTypeNamesString, numberOfColumns );
1:2732872:     udtClasses = ColumnInfo.getExpectedUDTClasses( udtClassNamesString );
1:eac0369: 	// get the ResultSetMetaData now as we know it's needed
1:eac0369: 	importResultSetMetaData =
1:84e347a: 		new ImportResultSetMetaData(numberOfColumns, columnNames, columnWidths,
1:2732872:                                     tableColumnTypes, columnTypeNames, udtClasses );
1:3568cea: 
1:3568cea: 
1:eac0369:     //FIXME don't go through the resultset here. just for testing
1:eac0369: //    while (next()) ;
1:eac0369:   }
1:eac0369:   //the column names will be Column#
1:7a92d1f:   void loadColumnNames() {
1:eac0369:     for (int i=1; i<=numberOfColumns; i++)
1:eac0369:       columnNames[i-1] = COLUMNNAMEPREFIX + i;
1:84e347a: 
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369:   /** Gets the resultset meta data
1:eac0369:  	* @exception	SQLException if there is an error
1:eac0369: 	*/
1:eac0369:   public ResultSetMetaData getMetaData() {
1:eac0369:     return importResultSetMetaData;
1:eac0369:   }
1:eac0369: 
1:eac0369:   //all the resultset interface methods
1:eac0369:   /** gets the next row
1:eac0369:  	* @exception	SQLException if there is an error
1:eac0369: 	*/
1:eac0369:   public int getRow() throws SQLException {
1:eac0369:     return (importReadData.getCurrentRowNumber());
1:eac0369:   }
1:eac0369:   
1:97fdc36:     /** gets the current line number */
1:97fdc36:     public    int getCurrentLineNumber() { return lineNumber; }
1:97fdc36:     
1:eac0369:   public boolean next() throws SQLException {
1:eac0369:     try {
1:97fdc36:       lineNumber++;
1:eac0369:       return (importReadData.readNextRow(nextRow));
1:eac0369:     } catch (Exception ex) {
1:c0a8467: 		throw importError(ex);
1:eac0369: 	}
1:eac0369:   }
1:eac0369: 
1:eac0369:   /** closes the resultset
1:eac0369:  	* @exception	SQLException if there is an error
1:eac0369: 	*/
1:eac0369:   public void close() throws SQLException {
1:eac0369:     try {
1:eac0369: 		if(importReadData!=null)
1:eac0369: 			importReadData.closeStream();
1:eac0369:     } catch (Exception ex) {
2:eac0369: 		throw LoadError.unexpectedError(ex);
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   public boolean wasNull() {
1:eac0369: 		return wasNull;
1:eac0369:   }
1:eac0369: 
1:3568cea:   /**
1:eac0369:  	* @exception	SQLException if there is an error
1:eac0369: 	*/
1:eac0369:   public String getString(int columnIndex) throws SQLException {
1:eac0369: 
1:84e347a:     if (columnIndex <= numberOfColumns) {
1:eac0369: 		String val = nextRow[columnIndex-1];
1:3568cea:         if (isColumnInExtFile(columnIndex)) {
1:84e347a:             // a clob column data is stored in an external 
1:84e347a:             // file, the reference to it is in the main file. 
1:84e347a:             // read the data from the external file using the 
1:84e347a:             // reference from the main file. 
1:3568cea: 			val = importReadData.getClobColumnFromExtFileAsString(val, 
1:3568cea:                                                                   columnIndex);
1:84e347a:         }
1:eac0369: 		wasNull = (val == null);
1:84e347a: 		return val;
1:eac0369:     }
1:eac0369:     else {
1:eac0369:        throw LoadError.invalidColumnNumber(numberOfColumns);
1:eac0369:     }
1:eac0369:   }
1:84e347a: 
1:84e347a: 
1:84e347a:     /**
1:3568cea:      * Returns <code> java.sql.Clob </code> type object that 
1:2732872:      * contains the column data from the import file. 
1:3568cea:      * @param columnIndex number of the column. starts at 1.
1:3568cea:      * @exception SQLException if any occurs during create of the clob object.
1:3568cea:      */
1:3568cea: 	public java.sql.Clob getClob(int columnIndex) throws SQLException {
1:3568cea: 
1:3568cea:         java.sql.Clob clob = null;
1:3568cea: 		if (lobsInExtFile) 
1:3568cea:         {
1:3568cea:             // lob data is in another file, read from the external file.
1:3568cea:             clob = importReadData.getClobColumnFromExtFile(
1:3568cea:                                          nextRow[columnIndex-1], columnIndex);
1:3568cea:         } else {
1:3568cea:             // data is in the main export file.
1:3568cea:             String data =  nextRow[columnIndex-1];
1:3568cea:             if (data != null) {
1:3568cea:                 clob = new ImportClob(data);                
1:3568cea:             }
1:3568cea:         }
1:3568cea:         
1:3568cea:         wasNull = (clob == null);
1:3568cea:         return clob;
1:3568cea: 	}
1:3568cea: 
1:eac0369: 	
1:eac0369:     /**
1:84e347a:      * Returns <code> java.sql.Blob </code> type object that 
1:2732872:      * contains the column data from the import file. 
1:84e347a:      * @param columnIndex number of the column. starts at 1.
1:84e347a:      * @exception SQLException if any occurs during create of the blob object.
1:84e347a:      */
1:84e347a: 	public java.sql.Blob getBlob(int columnIndex) throws SQLException {
1:84e347a: 
1:ffdaf1e:         java.sql.Blob blob = null;
1:84e347a: 		if (lobsInExtFile) 
1:84e347a:         {
1:84e347a:             // lob data is in another file, read from the external file.
1:ffdaf1e:             blob = importReadData.getBlobColumnFromExtFile(
1:3568cea:                                          nextRow[columnIndex-1], columnIndex);
1:84e347a:         } else {
1:84e347a:             // data is in the main export file, stored in hex format.
1:ffdaf1e:             String hexData = nextRow[columnIndex-1];
1:ffdaf1e:             byte[] data = null;
1:ffdaf1e:             if (hexData != null) {
1:ffdaf1e:                 // Derby export calls Resultset.getString() method
1:ffdaf1e:                 // when blob column data is not exported to an 
1:ffdaf1e:                 // external file. Derby getString() method return 
1:ffdaf1e:                 // the data in hex format for binary types, by 
1:ffdaf1e:                 // calling  StringUtil.toHexString(). If the data 
1:ffdaf1e:                 // is being imported from a file that exported 
1:ffdaf1e:                 // from non-derby source, hex data is expected to be 
1:ffdaf1e:                 // same format as one written using 
1:ffdaf1e:                 // StringUtil.toHexString(). StringUtil.fromHexString() 
1:ffdaf1e:                 // is used to covert the hex data  to byte array. 
1:ffdaf1e: 
1:ffdaf1e:                 data = StringUtil.fromHexString(
1:ffdaf1e:                                hexData, 0, hexData.length());
1:ffdaf1e:                 // fromHexString() returns null if the hex string 
1:ffdaf1e:                 // is invalid one. It is invalid if the data string 
1:ffdaf1e:                 // length is not multiple of 2 or the data string 
1:ffdaf1e:                 // contains non-hex characters. 
1:ffdaf1e:                 if (data == null) {
1:ffdaf1e:                     throw PublicAPI.wrapStandardException(
1:ffdaf1e:                       StandardException.newException(
1:ffdaf1e:                       SQLState.IMPORTFILE_HAS_INVALID_HEXSTRING, 
1:ffdaf1e:                       hexData));
1:ffdaf1e:                 }
1:ffdaf1e: 
1:ffdaf1e:                 blob = new ImportBlob(data);                
1:ffdaf1e:             }
1:84e347a:         }
1:ffdaf1e:         
1:ffdaf1e:         wasNull = (blob == null);
1:ffdaf1e:         return blob;
1:84e347a: 	}
1:84e347a: 
1:2732872:     /**
1:2732872:      * Returns Object that contains the column data 
1:2732872:      * from the import file. 
1:2732872:      * @param columnIndex number of the column. starts at 1.
1:2732872:      * @exception SQLException if any error occurs.
1:2732872:      */
1:2732872: 	public Object getObject(int columnIndex) throws SQLException
1:2732872:     {
1:2732872:         byte[] bytes = getBytes( columnIndex );
1:84e347a: 
1:2732872:         try {
1:2732872:             Class udtClass = importResultSetMetaData.getUDTClass( columnIndex );
1:2732872:             
1:2732872:             Object obj = readObject( bytes );
1:2732872:             
1:2732872:             //
1:2732872:             // We need to make sure that the user is not trying to import some
1:2732872:             // other object into the target column. This could happen if, for instance,
1:2732872:             // you try to import the exported contents of a table which has the same
1:2732872:             // shape as the target table except that its udt columns are of different type.
1:2732872:             //
1:2732872:             if ( (obj !=null) && (!udtClass.isInstance( obj )) )
1:2732872:             {
1:2732872:                 throw new ClassCastException( obj.getClass().getName() + " -> " + udtClass.getName() );
1:2732872:             }
1:2732872:             
1:2732872:             return obj;
1:2732872:         }
1:2732872:         catch (Exception e) { throw importError( e ); }
1:2732872:     }
1:2732872: 
1:2732872:     /** Read a serializable from a set of bytes. */
1:2732872:     public static Object readObject( byte[] bytes ) throws Exception
1:2732872:     {
1:2732872:         ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
1:2732872:         ObjectInputStream ois = new ObjectInputStream( bais );
1:2732872: 
1:2732872:         return ois.readObject();
1:2732872:     }
1:2732872: 
1:2732872:     /** Read an object which was serialized to a string using StringUtil */
1:2732872:     public static Object destringifyObject( String raw ) throws Exception
1:2732872:     {
1:2732872:         byte[] bytes = StringUtil.fromHexString( raw, 0, raw.length());
1:2732872: 
1:2732872:         return readObject( bytes );
1:2732872:     }
1:eac0369: 
1:eac0369: 
1:84e347a:     /**
1:2732872:      * Returns byte array that contains the column data 
1:ea980d3:      * from the import file. 
1:ea980d3:      * @param columnIndex number of the column. starts at 1.
1:ea980d3:      * @exception SQLException if any error occurs.
1:ea980d3:      */
1:ea980d3: 	public byte[] getBytes(int columnIndex) throws SQLException {
1:ea980d3:         
1:ea980d3:         // This method is called to import data into 
1:ea980d3:         // LONG VARCHAR FOR BIT DATA VARCHAR FOR BIT DATA,  
1:ea980d3:         // and CHAR FOR BIT DATA  type columns. Data for 
1:ea980d3:         // these type of columns expected to be in the  
1:ea980d3:         // main import file in hex format.  
1:ea980d3: 
1:ea980d3:         // convert the binary data in the hex format to a byte array.
1:ea980d3:         String hexData = nextRow[columnIndex-1];
1:ea980d3:         // if hex data is null, then column value is SQL NULL
1:ea980d3:         wasNull = (hexData == null);
1:ea980d3:         byte[] data = null;
1:7c20bd0:         if (hexData != null) {
1:ffdaf1e:             // Derby export calls Resultset.getString() method
1:ffdaf1e:             // to write binary data types.  Derby getString() 
1:ffdaf1e:             // method return the data in hex format for binary types,
1:ffdaf1e:             // by  calling  StringUtil.toHexString(). If the data 
1:ffdaf1e:             // is being imported from a file that is exported 
1:ffdaf1e:             // from non-derby source, hex data is expected to be 
1:ffdaf1e:             // same format as one written using 
1:ffdaf1e:             // StringUtil.toHexString(). StringUtil.fromHexString() 
1:ffdaf1e:             // is used to covert the hex data  to byte array. 
1:ffdaf1e: 
1:ea980d3:             data = StringUtil.fromHexString(hexData, 0, hexData.length());
1:7c20bd0:             // fromHexString() returns null if the hex string is invalid one.
1:7c20bd0:             // It is invalid if the data string length is not multiple of 2 
1:7c20bd0:             // or the data string contains non-hex characters. 
1:7c20bd0:             if (data == null) {
1:7c20bd0:                 throw PublicAPI.wrapStandardException(
1:7c20bd0:                       StandardException.newException(
1:7c20bd0:                       SQLState.IMPORTFILE_HAS_INVALID_HEXSTRING, 
1:7c20bd0:                       hexData));
1:7c20bd0:             }
1:7c20bd0:         }
1:ea980d3:         return data;
1:ea980d3: 	}
1:ea980d3: 
1:ea980d3: 
1:ea980d3: 
1:ea980d3:     /**
1:84e347a:      * Check if for this column type, real data is stored in an 
1:84e347a:      * external file and only the reference is in the main import 
1:84e347a:      * file.
1:84e347a:      * @param colIndex number of the column. starts at 1.
1:84e347a:      * @return         true, if the column data in a different file 
1:84e347a:      *                 from the main import file , otherwise false.
1:84e347a:      */
1:84e347a: 	private boolean isColumnInExtFile(int colIndex) 
1:84e347a: 	{
1:84e347a: 		if (lobsInExtFile && 
1:84e347a:             (tableColumnTypes[colIndex -1] == java.sql.Types.BLOB || 
1:84e347a:              tableColumnTypes[colIndex -1] == java.sql.Types.CLOB ))
1:84e347a: 			return true;
1:84e347a: 		else 
1:84e347a: 			return false;
1:c0a8467: 
1:84e347a: 	}
1:84e347a:         
1:c0a8467:         /**
1:c0a8467:          * Close the stream and wrap exception in a SQLException
1:c0a8467:          * 
1:c0a8467:          * @param ex  Exception causing the import error
1:c0a8467:          * @throws SQLException
1:c0a8467:          */
1:c0a8467:         public  SQLException importError(Exception ex) {
1:c0a8467:             Exception closeException = null;
1:c0a8467:             if (importReadData != null)
1:c0a8467:                 try {
1:c0a8467:                     importReadData.closeStream(); 
1:c0a8467:                 } catch (Exception e) {
1:c0a8467:                     closeException = e;
1:c0a8467:                 }
1:c0a8467:                 SQLException le = LoadError.unexpectedError(ex);
1:c0a8467:                 if (closeException != null)
1:c0a8467:                     le.setNextException(LoadError.unexpectedError(closeException));
1:c0a8467:                 return le;
1:c0a8467:         }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2732872
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.ObjectInputStream;
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:   ImportResultSetMetaData importResultSetMetaData;
1:   String columnTypeNamesString;
1:   String[] columnTypeNames;
1:   String  udtClassNamesString;
1:   HashMap udtClasses;
/////////////////////////////////////////////////////////////////////////
1:     columnTypeNames =  ColumnInfo.getExpectedColumnTypeNames( columnTypeNamesString, numberOfColumns );
1:     udtClasses = ColumnInfo.getExpectedUDTClasses( udtClassNamesString );
1:                                     tableColumnTypes, columnTypeNames, udtClasses );
/////////////////////////////////////////////////////////////////////////
1:      * contains the column data from the import file. 
/////////////////////////////////////////////////////////////////////////
1:      * contains the column data from the import file. 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns Object that contains the column data 
1:      * from the import file. 
1:      * @param columnIndex number of the column. starts at 1.
1:      * @exception SQLException if any error occurs.
1:      */
1: 	public Object getObject(int columnIndex) throws SQLException
1:     {
1:         byte[] bytes = getBytes( columnIndex );
1:         try {
1:             Class udtClass = importResultSetMetaData.getUDTClass( columnIndex );
1:             
1:             Object obj = readObject( bytes );
1:             
1:             //
1:             // We need to make sure that the user is not trying to import some
1:             // other object into the target column. This could happen if, for instance,
1:             // you try to import the exported contents of a table which has the same
1:             // shape as the target table except that its udt columns are of different type.
1:             //
1:             if ( (obj !=null) && (!udtClass.isInstance( obj )) )
1:             {
1:                 throw new ClassCastException( obj.getClass().getName() + " -> " + udtClass.getName() );
1:             }
1:             
1:             return obj;
1:         }
1:         catch (Exception e) { throw importError( e ); }
1:     }
1: 
1:     /** Read a serializable from a set of bytes. */
1:     public static Object readObject( byte[] bytes ) throws Exception
1:     {
1:         ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
1:         ObjectInputStream ois = new ObjectInputStream( bais );
1: 
1:         return ois.readObject();
1:     }
1: 
1:     /** Read an object which was serialized to a string using StringUtil */
1:     public static Object destringifyObject( String raw ) throws Exception
1:     {
1:         byte[] bytes = StringUtil.fromHexString( raw, 0, raw.length());
1: 
1:         return readObject( bytes );
1:     }
1:      * Returns byte array that contains the column data 
commit:97fdc36
/////////////////////////////////////////////////////////////////////////
1:   int lineNumber = 0;
/////////////////////////////////////////////////////////////////////////
1:     /** gets the current line number */
1:     public    int getCurrentLineNumber() { return lineNumber; }
1:     
1:       lineNumber++;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c0a8467
/////////////////////////////////////////////////////////////////////////
0: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: 		throw importError(ex);
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Close the stream and wrap exception in a SQLException
1:          * 
1:          * @param ex  Exception causing the import error
1:          * @throws SQLException
1:          */
1:         public  SQLException importError(Exception ex) {
1:             Exception closeException = null;
1:             if (importReadData != null)
1:                 try {
1:                     importReadData.closeStream(); 
1:                 } catch (Exception e) {
1:                     closeException = e;
1:                 }
1:                 SQLException le = LoadError.unexpectedError(ex);
1:                 if (closeException != null)
1:                     le.setNextException(LoadError.unexpectedError(closeException));
1:                 return le;
1:         }
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:3568cea
/////////////////////////////////////////////////////////////////////////
1:         if (isColumnInExtFile(columnIndex)) {
1: 			val = importReadData.getClobColumnFromExtFileAsString(val, 
1:                                                                   columnIndex);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Returns <code> java.sql.Clob </code> type object that 
0:      * contains the columnn data from the import file. 
1:      * @param columnIndex number of the column. starts at 1.
1:      * @exception SQLException if any occurs during create of the clob object.
1:      */
1: 	public java.sql.Clob getClob(int columnIndex) throws SQLException {
1: 
1:         java.sql.Clob clob = null;
1: 		if (lobsInExtFile) 
1:         {
1:             // lob data is in another file, read from the external file.
1:             clob = importReadData.getClobColumnFromExtFile(
1:                                          nextRow[columnIndex-1], columnIndex);
1:         } else {
1:             // data is in the main export file.
1:             String data =  nextRow[columnIndex-1];
1:             if (data != null) {
1:                 clob = new ImportClob(data);                
1:             }
1:         }
1:         
1:         wasNull = (clob == null);
1:         return clob;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1:                                          nextRow[columnIndex-1], columnIndex);
/////////////////////////////////////////////////////////////////////////
1: 
1: 
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1:         java.sql.Blob blob = null;
1:             blob = importReadData.getBlobColumnFromExtFile(
1:             String hexData = nextRow[columnIndex-1];
1:             byte[] data = null;
1:             if (hexData != null) {
1:                 // Derby export calls Resultset.getString() method
1:                 // when blob column data is not exported to an 
1:                 // external file. Derby getString() method return 
1:                 // the data in hex format for binary types, by 
1:                 // calling  StringUtil.toHexString(). If the data 
1:                 // is being imported from a file that exported 
1:                 // from non-derby source, hex data is expected to be 
1:                 // same format as one written using 
1:                 // StringUtil.toHexString(). StringUtil.fromHexString() 
1:                 // is used to covert the hex data  to byte array. 
1: 
1:                 data = StringUtil.fromHexString(
1:                                hexData, 0, hexData.length());
1:                 // fromHexString() returns null if the hex string 
1:                 // is invalid one. It is invalid if the data string 
1:                 // length is not multiple of 2 or the data string 
1:                 // contains non-hex characters. 
1:                 if (data == null) {
1:                     throw PublicAPI.wrapStandardException(
1:                       StandardException.newException(
1:                       SQLState.IMPORTFILE_HAS_INVALID_HEXSTRING, 
1:                       hexData));
1:                 }
1: 
1:                 blob = new ImportBlob(data);                
1:             }
1:         
1:         wasNull = (blob == null);
1:         return blob;
/////////////////////////////////////////////////////////////////////////
1:             // Derby export calls Resultset.getString() method
1:             // to write binary data types.  Derby getString() 
1:             // method return the data in hex format for binary types,
1:             // by  calling  StringUtil.toHexString(). If the data 
1:             // is being imported from a file that is exported 
1:             // from non-derby source, hex data is expected to be 
1:             // same format as one written using 
1:             // StringUtil.toHexString(). StringUtil.fromHexString() 
1:             // is used to covert the hex data  to byte array. 
1: 
commit:7c20bd0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.PublicAPI;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (hexData != null) {
1:             // fromHexString() returns null if the hex string is invalid one.
1:             // It is invalid if the data string length is not multiple of 2 
1:             // or the data string contains non-hex characters. 
1:             if (data == null) {
1:                 throw PublicAPI.wrapStandardException(
1:                       StandardException.newException(
1:                       SQLState.IMPORTFILE_HAS_INVALID_HEXSTRING, 
1:                       hexData));
1:             }
1:         }
commit:ea980d3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.StringUtil;
/////////////////////////////////////////////////////////////////////////
0:      * Returns byte array that contains the columnn data 
1:      * from the import file. 
1:      * @param columnIndex number of the column. starts at 1.
1:      * @exception SQLException if any error occurs.
1:      */
1: 	public byte[] getBytes(int columnIndex) throws SQLException {
1:         
1:         // This method is called to import data into 
1:         // LONG VARCHAR FOR BIT DATA VARCHAR FOR BIT DATA,  
1:         // and CHAR FOR BIT DATA  type columns. Data for 
1:         // these type of columns expected to be in the  
1:         // main import file in hex format.  
1: 
1:         // convert the binary data in the hex format to a byte array.
1:         String hexData = nextRow[columnIndex-1];
1:         // if hex data is null, then column value is SQL NULL
1:         wasNull = (hexData == null);
1:         byte[] data = null;
0:         if (hexData != null) 
1:             data = StringUtil.fromHexString(hexData, 0, hexData.length());
1:         return data;
1: 	}
1: 
1: 
1: 
1:     /**
commit:84e347a
/////////////////////////////////////////////////////////////////////////
1:   protected boolean lobsInExtFile = false;
1: 
1:   String tableColumnTypesStr;
1:   int[] tableColumnTypes;
/////////////////////////////////////////////////////////////////////////
1:     tableColumnTypes = ColumnInfo.getExpectedVtiColumnTypes(tableColumnTypesStr,
1:                                                             numberOfColumns);
1: 		new ImportResultSetMetaData(numberOfColumns, columnNames, columnWidths,
0:                                     tableColumnTypes);
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     if (columnIndex <= numberOfColumns) {
0: 		if (isColumnInExtFile(columnIndex)) {
1:             // a clob column data is stored in an external 
1:             // file, the reference to it is in the main file. 
1:             // read the data from the external file using the 
1:             // reference from the main file. 
0: 			val = importReadData.getClobColumnFromExtFile(val);
1:         }
1: 		return val;
1: 
1: 	
1:     /**
1:      * Returns <code> java.sql.Blob </code> type object that 
0:      * contains the columnn data from the import file. 
1:      * @param columnIndex number of the column. starts at 1.
1:      * @exception SQLException if any occurs during create of the blob object.
1:      */
1: 	public java.sql.Blob getBlob(int columnIndex) throws SQLException {
1: 
1: 		if (lobsInExtFile) 
1:         {
1:             // lob data is in another file, read from the external file.
0:             return importReadData.getBlobColumnFromExtFile(
0:                                          nextRow[columnIndex-1]);
1:         } else {
1:             // data is in the main export file, stored in hex format.
0:             return new ImportBlob(nextRow[columnIndex-1]);
1:         }
1: 	}
1: 
1: 
1:     /**
1:      * Check if for this column type, real data is stored in an 
1:      * external file and only the reference is in the main import 
1:      * file.
1:      * @param colIndex number of the column. starts at 1.
1:      * @return         true, if the column data in a different file 
1:      *                 from the main import file , otherwise false.
1:      */
1: 	private boolean isColumnInExtFile(int colIndex) 
1: 	{
1: 		if (lobsInExtFile && 
1:             (tableColumnTypes[colIndex -1] == java.sql.Types.BLOB || 
1:              tableColumnTypes[colIndex -1] == java.sql.Types.CLOB ))
1: 			return true;
1: 		else 
1: 			return false;
1: 
1: 	}
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
1:   ControlInfo controlFileReader;
1:   ImportReadData importReadData;
1:   String[] columnNames;
1:   int numberOfColumns;
1:   int[] columnWidths;
1:   String[] nextRow;
0:   ResultSetMetaData importResultSetMetaData;
1:   int noOfColumnsExpected;
1: 	static final String COLUMNNAMEPREFIX = "COLUMN";
1:   abstract ImportReadData getImportReadData() throws Exception;
1:   void doAllTheWork() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:   void loadColumnNames() {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.ImportAbstract
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.ResultSetMetaData;
1: import org.apache.derby.vti.VTITemplate;
1: import java.util.ArrayList;
1: 
1: /**
1:  * 
1:  * <P>
1:  */
1: abstract class ImportAbstract extends VTITemplate {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
0:   protected ControlInfo controlFileReader;
0:   protected ImportReadData importReadData;
1: 
0:   protected String[] columnNames;
0:   protected int numberOfColumns;
0:   protected int[] columnWidths;
1: 
0:   protected String[] nextRow;
1: 
0:   protected ResultSetMetaData importResultSetMetaData;
0:   protected int noOfColumnsExpected;
1: 
1:   private boolean wasNull;
1: 
0: 	protected static final String COLUMNNAMEPREFIX = "COLUMN";
1: 
0:   protected abstract ImportReadData getImportReadData() throws Exception;
1: 
1:   /** Does all the work
1:  	* @exception	Exception if there is an error
1: 	*/
0:   protected void doAllTheWork() throws Exception {
1: 
1:     //prepare the input file for import. Get the number of columns per row
1:     //from the input file.
1:     importReadData = getImportReadData();
1:     numberOfColumns = importReadData.getNumberOfColumns();
1: 	if(numberOfColumns == 0)
1: 	{
1: 		//file is empty. Assume same number of columns expected 
1: 		//and return no data , But No rows gets insereted.
1: 		this.numberOfColumns = noOfColumnsExpected;
1: 	}
1: 
1:     columnWidths = controlFileReader.getColumnWidths();
1:     columnNames = new String[numberOfColumns];
1:     loadColumnNames();
1:     nextRow = new String[numberOfColumns];
1: 
1: 	// get the ResultSetMetaData now as we know it's needed
1: 	importResultSetMetaData =
0: 		new ImportResultSetMetaData(numberOfColumns, columnNames, columnWidths);
1: 
1: 
1:     //FIXME don't go through the resultset here. just for testing
1: //    while (next()) ;
1:   }
1:   //the column names will be Column#
0:   protected void loadColumnNames() {
1:     for (int i=1; i<=numberOfColumns; i++)
1:       columnNames[i-1] = COLUMNNAMEPREFIX + i;
1:   }
1: 
1: 
1:   /** Gets the resultset meta data
1:  	* @exception	SQLException if there is an error
1: 	*/
1:   public ResultSetMetaData getMetaData() {
1:     return importResultSetMetaData;
1:   }
1: 
1:   //all the resultset interface methods
1:   /** gets the next row
1:  	* @exception	SQLException if there is an error
1: 	*/
1:   public int getRow() throws SQLException {
1:     return (importReadData.getCurrentRowNumber());
1:   }
1:   
1:   public boolean next() throws SQLException {
1:     try {
1:       return (importReadData.readNextRow(nextRow));
1:     } catch (Exception ex) {
1: 		throw LoadError.unexpectedError(ex);
1: 	}
1:   }
1: 
1:   /** closes the resultset
1:  	* @exception	SQLException if there is an error
1: 	*/
1:   public void close() throws SQLException {
1:     try {
1: 		if(importReadData!=null)
1: 			importReadData.closeStream();
1:     } catch (Exception ex) {
1: 		throw LoadError.unexpectedError(ex);
1:     }
1:   }
1: 
1:   public boolean wasNull() {
1: 		return wasNull;
1:   }
1: 
1:   /**
1:  	* @exception	SQLException if there is an error
1: 	*/
1:   public String getString(int columnIndex) throws SQLException {
0:     if (columnIndex <= numberOfColumns) {
1: 
1: 		String val = nextRow[columnIndex-1];
1: 		wasNull = (val == null);
0:        return val;
1:     }
1:     else {
1:        throw LoadError.invalidColumnNumber(numberOfColumns);
1:     }
1:   }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
0: import java.sql.ResultSetMetaData;
0: import org.apache.derby.vti.VTITemplate;
0: import java.util.ArrayList;
0: 
0: /**
0:  * 
0:  * <P>
0:  */
0: abstract class ImportAbstract extends VTITemplate {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:   protected ControlInfo controlFileReader;
0:   protected ImportReadData importReadData;
0: 
0:   protected String[] columnNames;
0:   protected int numberOfColumns;
0:   protected int[] columnWidths;
0: 
0:   protected String[] nextRow;
0: 
0:   protected ResultSetMetaData importResultSetMetaData;
0:   protected int noOfColumnsExpected;
0: 
0:   private boolean wasNull;
0: 
0: 	protected static final String COLUMNNAMEPREFIX = "COLUMN";
0: 
0:   protected abstract ImportReadData getImportReadData() throws Exception;
0: 
0:   /** Does all the work
0:  	* @exception	Exception if there is an error
0: 	*/
0:   protected void doAllTheWork() throws Exception {
0: 
0:     //prepare the input file for import. Get the number of columns per row
0:     //from the input file.
0:     importReadData = getImportReadData();
0:     numberOfColumns = importReadData.getNumberOfColumns();
0: 	if(numberOfColumns == 0)
0: 	{
0: 		//file is empty. Assume same number of columns expected 
0: 		//and return no data , But No rows gets insereted.
0: 		this.numberOfColumns = noOfColumnsExpected;
0: 	}
0: 
0:     columnWidths = controlFileReader.getColumnWidths();
0:     columnNames = new String[numberOfColumns];
0:     loadColumnNames();
0:     nextRow = new String[numberOfColumns];
0: 
0: 	// get the ResultSetMetaData now as we know it's needed
0: 	importResultSetMetaData =
0: 		new ImportResultSetMetaData(numberOfColumns, columnNames, columnWidths);
0: 
0: 
0:     //FIXME don't go through the resultset here. just for testing
0: //    while (next()) ;
0:   }
0:   //the column names will be Column#
0:   protected void loadColumnNames() {
0:     for (int i=1; i<=numberOfColumns; i++)
0:       columnNames[i-1] = COLUMNNAMEPREFIX + i;
0:   }
0: 
0: 
0:   /** Gets the resultset meta data
0:  	* @exception	SQLException if there is an error
0: 	*/
0:   public ResultSetMetaData getMetaData() {
0:     return importResultSetMetaData;
0:   }
0: 
0:   //all the resultset interface methods
0:   /** gets the next row
0:  	* @exception	SQLException if there is an error
0: 	*/
0:   public int getRow() throws SQLException {
0:     return (importReadData.getCurrentRowNumber());
0:   }
0:   
0:   public boolean next() throws SQLException {
0:     try {
0:       return (importReadData.readNextRow(nextRow));
0:     } catch (Exception ex) {
0: 		throw LoadError.unexpectedError(ex);
0: 	}
0:   }
0: 
0:   /** closes the resultset
0:  	* @exception	SQLException if there is an error
0: 	*/
0:   public void close() throws SQLException {
0:     try {
0: 		if(importReadData!=null)
0: 			importReadData.closeStream();
0:     } catch (Exception ex) {
0: 		throw LoadError.unexpectedError(ex);
0:     }
0:   }
0: 
0:   public boolean wasNull() {
0: 		return wasNull;
0:   }
0: 
0:   /**
0:  	* @exception	SQLException if there is an error
0: 	*/
0:   public String getString(int columnIndex) throws SQLException {
0:     if (columnIndex <= numberOfColumns) {
0: 
0: 		String val = nextRow[columnIndex-1];
0: 		wasNull = (val == null);
0:        return val;
0:     }
0:     else {
0:        throw LoadError.invalidColumnNumber(numberOfColumns);
0:     }
0:   }
0: }
============================================================================