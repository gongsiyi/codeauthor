1:88e75e5: /*
4:88e75e5: 
1:88e75e5:    Derby - Class org.apache.derbyTesting.functionsTests.tests.memorydb.DropWhileConnectingTest
1:88e75e5: 
1:88e75e5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88e75e5:    contributor license agreements.  See the NOTICE file distributed with
1:88e75e5:    this work for additional information regarding copyright ownership.
1:88e75e5:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88e75e5:    (the "License"); you may not use this file except in compliance with
1:88e75e5:    the License.  You may obtain a copy of the License at
1:88e75e5: 
1:88e75e5:       http://www.apache.org/licenses/LICENSE-2.0
1:88e75e5: 
1:88e75e5:    Unless required by applicable law or agreed to in writing, software
1:88e75e5:    distributed under the License is distributed on an "AS IS" BASIS,
1:88e75e5:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:88e75e5:    See the License for the specific language governing permissions and
1:88e75e5:    limitations under the License.
1:88e75e5: 
2:88e75e5:  */
1:88e75e5: package org.apache.derbyTesting.functionTests.tests.memorydb;
1:88e75e5: 
1:88e75e5: import java.io.File;
1:88e75e5: import java.io.IOException;
1:88e75e5: import java.io.PrintWriter;
1:88e75e5: import java.sql.Connection;
1:88e75e5: import java.sql.DriverManager;
1:88e75e5: import java.sql.ResultSet;
1:88e75e5: import java.sql.SQLException;
1:88e75e5: import java.sql.Statement;
1:88e75e5: import java.util.Random;
1:88e75e5: import junit.framework.Test;
1:88e75e5: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:88e75e5: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:88e75e5: 
2:88e75e5: /**
1:88e75e5:  * <em>WARNING: This test isn't finalized!</em>
2:88e75e5:  *
1:88e75e5:  * Tests the behavior when several threads are accessing the database
1:88e75e5:  * and one thread comes in and drops the database.
1:88e75e5:  * The success of the test is defined by allowing only certain exceptions
1:88e75e5:  * from the access threads / connections. During connection, the following
1:88e75e5:  * exceptions are allowed:
1:88e75e5:  * <ul> <li>XJ004: Database not found.</li>
1:88e75e5:  *      <li>?????: Database access blocked.<li>
1:88e75e5:  * </ul>
1:88e75e5:  * During normal operation, the set is:
1:88e75e5:  * <ul>
1:88e75e5:  *      <li>XJ001*: Shutdown exception.</li>
1:88e75e5:  *      <li>08003: No current connection.</li>
1:88e75e5:  *  </ul>
1:88e75e5:  * <p>
1:88e75e5:  * This test has a known weakness in that it doesn't execute long-running
1:88e75e5:  * queries. It is not clear how these react when the database is dropped
1:88e75e5:  * under their feet.
1:88e75e5:  */
1:88e75e5: public class DropWhileConnectingTest
1:88e75e5:         extends BaseJDBCTestCase {
1:88e75e5: 
1:88e75e5:     public DropWhileConnectingTest(String name) {
1:88e75e5:         super(name);
3:88e75e5:     }
1:88e75e5: 
1:88e75e5:     public void testConcurrentAccessAndDrop()
1:88e75e5:             throws SQLException {
1:88e75e5:         final String url = "jdbc:derby:memory:testDB";
1:88e75e5:         // Database owner is the default user APP.
1:88e75e5:         Connection con =
1:88e75e5:                 MemoryDbManager.getSharedInstance().createDatabase("testDB");
1:88e75e5:         con.close();
1:88e75e5:         String threadsStr = getSystemProperty("derby.tests.threadCount");
1:88e75e5:         if (threadsStr == null) {
1:88e75e5:             threadsStr = "20";
1:88e75e5:         }
1:88e75e5:         int accessThreads = Integer.parseInt(threadsStr);
1:88e75e5:         println("threadCount=" + accessThreads);
1:88e75e5:         Report report = new Report(getFailureFolder(), accessThreads);
1:88e75e5:         // Start the access threads.
1:88e75e5:         for (int i=0; i < accessThreads; i++) {
1:88e75e5:             Thread t = new Thread(new AccessThread(report, url));
1:88e75e5:             t.start();
1:88e75e5:         }
1:88e75e5:         // Signal start, then wait a little before deleting the database.
1:88e75e5:         report.start();
1:88e75e5:         sleep(2500);
2:88e75e5:         try {
1:88e75e5:             MemoryDbManager.getSharedInstance().dropDatabase("testDB");
1:88e75e5:             fail("Dropping database should have raised exception.");
1:88e75e5:         } catch (SQLException sqle) {
1:88e75e5:             assertSQLState("08006", sqle);
1:88e75e5:         }
1:88e75e5:         println("Drop database request executed.");
1:88e75e5:         // Wait for all the threads to finish (they may be sleeping).
1:88e75e5:         while (!report.allThreadsDone()) {
1:88e75e5:             println("Waiting for " + report.remainingThreads() +
1:88e75e5:                     " remaining thread(s) to finish...");
1:88e75e5:             sleep(500);
1:88e75e5:         }
1:88e75e5:         assertFalse(report.toString(), report.hasUnexpectedExceptions());
1:88e75e5:         println(report.toString());
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     public static Test suite() {
1:1ae02c9:        return new BaseTestSuite(DropWhileConnectingTest.class);
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:88e75e5:      * Simple report class holding results from the test run. Also used to
1:88e75e5:      * control the start of the worker threads.
1:88e75e5:      */
1:88e75e5:     private static class Report {
1:88e75e5:         /** Sync object used to start the threads. */
1:88e75e5:         private final Object sync = new Object();
1:88e75e5:         //@GuardedBy("sync")
1:88e75e5:         private boolean ready;
1:88e75e5: 
1:88e75e5:         /** Failure folder where any exceptions will be logged to file. */
1:88e75e5:         private final File failureFolder;
1:88e75e5:         /** Writer used to log stack traces, lazily initialized. */
1:88e75e5:         private PrintWriter writer;
1:88e75e5:         /** The number of successful connections made by the worker threads. */
1:88e75e5:         private final int[] accessCounts;
1:88e75e5:         /** Any unexpected exceptions encountered by the worker threads. */
1:88e75e5:         private final Throwable[] exceptions;
1:88e75e5:         private int threadsDone;
1:88e75e5:         private boolean hasExceptions;
1:88e75e5:        
1:88e75e5:         /**
1:88e75e5:          * Creates a report object.
1:88e75e5:          *
1:88e75e5:          * @param failureFolder where to write exceptions to
1:88e75e5:          * @param accessThreads number of worker threads
1:88e75e5:          */
1:88e75e5:         public Report(File failureFolder, int accessThreads) {
1:88e75e5:             this.failureFolder = failureFolder;
1:88e75e5:             accessCounts = new int[accessThreads];
1:88e75e5:             exceptions = new Throwable[accessThreads];
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public synchronized boolean hasUnexpectedExceptions() {
1:88e75e5:             return this.hasExceptions;
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Reports the access count for the specified worker thread.
1:88e75e5:          *
1:dbed020:          * @param id worker thread id, must be in the range [0, threadCount&gt;
1:88e75e5:          * @param accessCount number of successful accesses made to the db
1:88e75e5:          */
1:88e75e5:         public synchronized void reportAccessCount(int id, int accessCount) {
1:88e75e5:             accessCounts[id] = accessCount;
1:88e75e5:             threadsDone++;
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Reports an unexpected error and the access count for the specified
1:88e75e5:          * worker thread.
1:88e75e5:          *
1:dbed020:          * @param id worker thread id, must be in the range [0, threadCount&gt;
1:88e75e5:          * @param accessCount number of successful accesses made to the db
1:488a749:          * @param error error to report
1:88e75e5:          */
1:88e75e5:         public synchronized void reportError(int id, int accessCount,
1:88e75e5:                                              Throwable error) {
1:88e75e5:             reportAccessCount(id, accessCount);
1:88e75e5:             exceptions[id] = error;
1:88e75e5:             hasExceptions = true;
1:88e75e5:             // Print the stack trace to file.
1:88e75e5:             dumpToFile(id, error);
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Tells if all the access threads have finished.
1:88e75e5:          *
1:88e75e5:          * @return {@code true} if all threads have finished,
1:88e75e5:          *      {@code false} otherwise.
1:88e75e5:          */
1:88e75e5:         public synchronized boolean allThreadsDone() {
1:88e75e5:             return (threadsDone == accessCounts.length);
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public synchronized int remainingThreads() {
1:88e75e5:             return accessCounts.length - threadsDone;
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public Object getSync() {
1:88e75e5:             return this.sync;
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Tells if the test is ready to start.
1:88e75e5:          *
1:88e75e5:          * @return {@code true} if the access threads can start.
1:88e75e5:          */
1:88e75e5:         public boolean ready() {
1:88e75e5:             synchronized (sync) {
1:88e75e5:                 return ready;
1:88e75e5:             }
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public void start() {
1:88e75e5:             synchronized (sync) {
1:88e75e5:                 ready = true;
1:88e75e5:                 sync.notifyAll();
1:88e75e5:             }
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public synchronized String toString() {
1:88e75e5:             int totalAccessCount = 0;
1:88e75e5:             for (int i=0; i < accessCounts.length; i++) {
1:88e75e5:                 int c = accessCounts[i];
1:88e75e5:                 if (c > 0) {
1:88e75e5:                     totalAccessCount += c;
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:             String sep = "\n";
1:88e75e5:             StringBuffer sb = new StringBuffer(sep +
1:88e75e5:                     "Number of access threads: ").append(accessCounts.length).
1:88e75e5:                     append(sep);
1:88e75e5:             sb.append("Access count: " + totalAccessCount).append(sep);
1:88e75e5:             if (hasExceptions) {
1:88e75e5:                 sb.append("Exceptions (see " + failureFolder +
1:88e75e5:                         "/exceptions.log):" + sep);
1:88e75e5:                 for (int i=0; i < exceptions.length; i++) {
1:88e75e5:                     Throwable t = exceptions[i];
1:88e75e5:                     if (t instanceof SQLException) {
1:88e75e5:                         SQLException s = (SQLException)t;
1:88e75e5:                         sb.append("id=").append(i).append(" : (").
1:88e75e5:                         append(s.getSQLState()).append(") ").
1:88e75e5:                         append(s.getMessage()).append(sep);
1:88e75e5:                     } else if (t != null) {
1:88e75e5:                         sb.append("id=").append(i).append(" : (     ) ").
1:88e75e5:                         append(t.getMessage()).append(sep);
1:88e75e5: 
1:88e75e5:                        
1:88e75e5:                     }
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:             return sb.toString();
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Dumps the exception to file.
1:88e75e5:          *
1:88e75e5:          * @param id internal id for the thread that got the exception
1:88e75e5:          * @param exception the exception to dump
1:88e75e5:          */
1:88e75e5:         private void dumpToFile(int id, Throwable exception) {
1:88e75e5:             if (writer == null) {
1:88e75e5:                 try {
1:88e75e5:                     writer = new PrintWriter(
1:88e75e5:                             PrivilegedFileOpsForTests.getFileOutputStream(
1:88e75e5:                             new File(failureFolder, ("exceptions.log"))));
1:88e75e5:                     writer.println(new java.util.Date());
1:88e75e5:                 } catch (IOException ioe) {
1:88e75e5:                     alarm("Failed to create exception log file: " +
1:88e75e5:                             ioe.getMessage());
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:             if (writer != null) {
1:88e75e5:                 writer.println("-----");
1:88e75e5:                 writer.println("id=" + id);
1:88e75e5:                 writer.println("--");
1:88e75e5:                 exception.printStackTrace(writer);
1:88e75e5:                 writer.flush();
1:88e75e5:             }
1:88e75e5:         }
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:88e75e5:      * Access thread connection to the database and performing a simple SQL
1:88e75e5:      * select query. Will accept a few specific exceptions as the database
1:88e75e5:      * is deleted "under its feet", all other exceptions are considered a
1:88e75e5:      * failure and will be reported.
1:88e75e5:      */
1:88e75e5:     private static class AccessThread
1:88e75e5:             implements Runnable {
1:88e75e5: 
1:88e75e5:         private static final Object LOCK = new Object();
1:88e75e5:         //@GuardedBy("LOCK")
1:88e75e5:         private static int idCounter = 0;
1:88e75e5:         /** Whether to wait at certain points in the execution. */
1:88e75e5:         private static final boolean noWait;
1:88e75e5:         static {
1:88e75e5:             String tmp = getSystemProperty("derby.tests.noWait");
1:88e75e5:             noWait = Boolean.valueOf(tmp).booleanValue();
1:88e75e5:             println("noWait=" + noWait);
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         private final int id;
1:88e75e5:         private final Report master;
1:88e75e5:         private final String url;
1:88e75e5:         private final Random rnd = new Random();
1:88e75e5:         /** Flag used to avoid waiting at multiple points in the execution. */
1:88e75e5:         private boolean waited;
1:88e75e5: 
1:88e75e5:         public AccessThread(Report master, String url) {
1:88e75e5:             synchronized (LOCK) {
1:88e75e5:                 this.id = idCounter++;                
1:88e75e5:             }
1:88e75e5:             this.master = master;
1:88e75e5:             // Connect with a different user than the DBO. There is no real
1:88e75e5:             // reaon for doing this, other than making sure this user will
1:88e75e5:             // be blocked out by Derby during the shutdown.
1:88e75e5:             this.url = url + ";user=test;password=test";
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         public void run() {
1:88e75e5:             int access = 0;
1:88e75e5:             Connection con = null;
1:88e75e5:             // Wait for signal to start testing.
1:88e75e5:             while (!master.ready()) {
1:88e75e5:                 synchronized (master.getSync()) {
1:88e75e5:                     try {
1:88e75e5:                         master.getSync().wait();
2:88e75e5:                     } catch (InterruptedException ie) {
1:88e75e5:                         // Ignore, just check the loop condition again.
1:88e75e5:                     }
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:             // Start accessing the database.
1:88e75e5:             try {
1:88e75e5:                 while (true) {
1:88e75e5:                     waited = false;
1:88e75e5:                     try {
1:88e75e5:                         con = DriverManager.getConnection(url);
1:88e75e5:                         access++;
1:88e75e5:                     } catch (SQLException sqle) {
1:88e75e5:                         // See if the exception says database not found.
1:88e75e5:                         // An additional check would be to make sure this
1:88e75e5:                         // happens after the database has been dropped, and
1:88e75e5:                         // that it is not caused by a bug during boot.
1:88e75e5:                         if (sqle.getSQLState().equals("XJ004")) {
1:88e75e5:                             master.reportAccessCount(id, access);
1:88e75e5:                             break;
1:88e75e5:                         }
1:88e75e5:                         // TODO: Adjust SQLState or remove.
1:88e75e5:                         if (sqle.getSQLState().equals("XJ005")) {
1:88e75e5:                             // Attempt blocked, keep pounding on the database.
1:88e75e5:                             allowWait(false);
1:88e75e5:                             continue;
1:88e75e5:                         }
1:88e75e5:                         // The connection process failed unexpectedly.
1:88e75e5:                         throw sqle;
1:88e75e5:                     }
1:88e75e5:                     // The set of allowed exceptions here is different from
1:88e75e5:                     // the one during connection.
1:88e75e5:                     try {
1:88e75e5:                         Statement stmt = con.createStatement();
1:88e75e5:                         allowWait(true);
1:88e75e5:                         ResultSet rs = stmt.executeQuery(
1:88e75e5:                             "select * from sys.systables order by random()");
1:88e75e5:                         allowWait(true);
1:88e75e5:                         while (rs.next()) {
1:88e75e5:                             allowWait(true);
1:88e75e5:                             rs.getString(1);
1:88e75e5:                         }
1:88e75e5:                         rs.close();
1:88e75e5:                         stmt.close();
1:88e75e5:                         con.close();
1:88e75e5:                         allowWait(false);
1:88e75e5:                     } catch (SQLException sqle) {
1:88e75e5:                         // Accept no current connection here
1:88e75e5:                         if (sqle.getSQLState().equals("08003")) {
1:88e75e5:                             master.reportAccessCount(id, access);
1:88e75e5:                         } else if (sqle.getSQLState().equals("XJ001") &&
1:88e75e5:                                 sqle.getMessage().indexOf("ShutdownException")
1:88e75e5:                                                                         != -1) {
1:88e75e5:                             master.reportAccessCount(id, access);
1:88e75e5:                         } else {
1:88e75e5:                             master.reportError(id, access, sqle);
1:88e75e5:                         }
1:88e75e5:                     }
1:88e75e5:                 }
1:88e75e5:             } catch (Throwable t) {
1:4b58cc0:                 if (t instanceof org.apache.derby.shared.common.error.ShutdownException){
1:88e75e5:                     // Not sure if this is a good thing yet.
1:88e75e5:                     System.out.println(
1:88e75e5:                             "Got ShutdownException (extends RuntimeException)");
1:88e75e5:                     master.reportAccessCount(id, access);
1:88e75e5:                 } else {
1:88e75e5:                     master.reportError(id, access, t);
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:         }
1:88e75e5: 
1:88e75e5:         /**
1:88e75e5:          * Method mostly doing nothing, but sometimes it decides to put the
1:88e75e5:          * thread to sleep for a little while.
1:88e75e5:          */
1:88e75e5:         private void allowWait(boolean onlyWaitOnce) {
1:88e75e5:             if (!noWait && ((!waited && onlyWaitOnce) || !onlyWaitOnce)) {
1:88e75e5:                 int split = rnd.nextInt(100);
1:88e75e5:                 if (split >= 97) {
1:88e75e5:                     // Potentially a long sleep
1:88e75e5:                     sleep(100 + (long)(rnd.nextDouble() * 1200));
1:88e75e5:                     waited = true;
1:88e75e5:                 } else if (split > 80){
1:88e75e5:                     sleep((long)(rnd.nextDouble() * 100));
1:88e75e5:                     waited = true;
1:88e75e5:                 }
1:88e75e5:             }
1:88e75e5:         }
1:88e75e5:     }
1:88e75e5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:          * @param id worker thread id, must be in the range [0, threadCount&gt;
/////////////////////////////////////////////////////////////////////////
1:          * @param id worker thread id, must be in the range [0, threadCount&gt;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:4b58cc0
/////////////////////////////////////////////////////////////////////////
1:                 if (t instanceof org.apache.derby.shared.common.error.ShutdownException){
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:        return new BaseTestSuite(DropWhileConnectingTest.class);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:afe4dfd
/////////////////////////////////////////////////////////////////////////
commit:488a749
/////////////////////////////////////////////////////////////////////////
1:          * @param error error to report
commit:88e75e5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionsTests.tests.memorydb.DropWhileConnectingTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.memorydb;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.Random;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: 
1: /**
1:  * <em>WARNING: This test isn't finalized!</em>
1:  *
1:  * Tests the behavior when several threads are accessing the database
1:  * and one thread comes in and drops the database.
1:  * The success of the test is defined by allowing only certain exceptions
1:  * from the access threads / connections. During connection, the following
1:  * exceptions are allowed:
1:  * <ul> <li>XJ004: Database not found.</li>
1:  *      <li>?????: Database access blocked.<li>
1:  * </ul>
1:  * During normal operation, the set is:
1:  * <ul>
1:  *      <li>XJ001*: Shutdown exception.</li>
1:  *      <li>08003: No current connection.</li>
1:  *  </ul>
1:  * <p>
1:  * This test has a known weakness in that it doesn't execute long-running
1:  * queries. It is not clear how these react when the database is dropped
1:  * under their feet.
1:  */
1: public class DropWhileConnectingTest
1:         extends BaseJDBCTestCase {
1: 
1:     public DropWhileConnectingTest(String name) {
1:         super(name);
1:     }
1: 
1:     public void testConcurrentAccessAndDrop()
1:             throws SQLException {
1:         final String url = "jdbc:derby:memory:testDB";
1:         // Database owner is the default user APP.
1:         Connection con =
1:                 MemoryDbManager.getSharedInstance().createDatabase("testDB");
1:         con.close();
1:         String threadsStr = getSystemProperty("derby.tests.threadCount");
1:         if (threadsStr == null) {
1:             threadsStr = "20";
1:         }
1:         int accessThreads = Integer.parseInt(threadsStr);
1:         println("threadCount=" + accessThreads);
1:         Report report = new Report(getFailureFolder(), accessThreads);
1:         // Start the access threads.
1:         for (int i=0; i < accessThreads; i++) {
1:             Thread t = new Thread(new AccessThread(report, url));
1:             t.start();
1:         }
1:         // Signal start, then wait a little before deleting the database.
1:         report.start();
1:         sleep(2500);
1:         try {
1:             MemoryDbManager.getSharedInstance().dropDatabase("testDB");
1:             fail("Dropping database should have raised exception.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }
1:         println("Drop database request executed.");
1:         // Wait for all the threads to finish (they may be sleeping).
1:         while (!report.allThreadsDone()) {
1:             println("Waiting for " + report.remainingThreads() +
1:                     " remaining thread(s) to finish...");
1:             sleep(500);
1:         }
1:         assertFalse(report.toString(), report.hasUnexpectedExceptions());
1:         println(report.toString());
1:     }
1: 
1:     /**
0:      * Puts the current thread to sleep, but <em>does not</em> guarantee
0:      * that the thread sleeps for the specified amount of time (interrupts are
0:      * not handled).
1:      *
0:      * @param millis number of milliseconds to sleep
1:      */
0:     private static void sleep(long millis) {
1:         try {
0:             Thread.sleep(millis);
1:         } catch (InterruptedException ie) {
0:             alarm("sleep call interrupted");
1:         }
1:     }
1: 
1:     public static Test suite() {
0:        return new TestSuite(DropWhileConnectingTest.class);
1:     }
1: 
1:     /**
1:      * Simple report class holding results from the test run. Also used to
1:      * control the start of the worker threads.
1:      */
1:     private static class Report {
1:         /** Sync object used to start the threads. */
1:         private final Object sync = new Object();
1:         //@GuardedBy("sync")
1:         private boolean ready;
1: 
1:         /** Failure folder where any exceptions will be logged to file. */
1:         private final File failureFolder;
1:         /** Writer used to log stack traces, lazily initialized. */
1:         private PrintWriter writer;
1:         /** The number of successful connections made by the worker threads. */
1:         private final int[] accessCounts;
1:         /** Any unexpected exceptions encountered by the worker threads. */
1:         private final Throwable[] exceptions;
1:         private int threadsDone;
1:         private boolean hasExceptions;
1:        
1:         /**
1:          * Creates a report object.
1:          *
1:          * @param failureFolder where to write exceptions to
1:          * @param accessThreads number of worker threads
1:          */
1:         public Report(File failureFolder, int accessThreads) {
1:             this.failureFolder = failureFolder;
1:             accessCounts = new int[accessThreads];
1:             exceptions = new Throwable[accessThreads];
1:         }
1: 
1:         public synchronized boolean hasUnexpectedExceptions() {
1:             return this.hasExceptions;
1:         }
1: 
1:         /**
1:          * Reports the access count for the specified worker thread.
1:          *
0:          * @param id worker thread id, must be in the range [0, threadCount>
1:          * @param accessCount number of successful accesses made to the db
1:          */
1:         public synchronized void reportAccessCount(int id, int accessCount) {
1:             accessCounts[id] = accessCount;
1:             threadsDone++;
1:         }
1: 
1:         /**
1:          * Reports an unexpected error and the access count for the specified
1:          * worker thread.
1:          *
0:          * @param id worker thread id, must be in the range [0, threadCount>
1:          * @param accessCount number of successful accesses made to the db
0:          * @param SQL
1:          */
1:         public synchronized void reportError(int id, int accessCount,
1:                                              Throwable error) {
1:             reportAccessCount(id, accessCount);
1:             exceptions[id] = error;
1:             hasExceptions = true;
1:             // Print the stack trace to file.
1:             dumpToFile(id, error);
1:         }
1: 
1:         /**
1:          * Tells if all the access threads have finished.
1:          *
1:          * @return {@code true} if all threads have finished,
1:          *      {@code false} otherwise.
1:          */
1:         public synchronized boolean allThreadsDone() {
1:             return (threadsDone == accessCounts.length);
1:         }
1: 
1:         public synchronized int remainingThreads() {
1:             return accessCounts.length - threadsDone;
1:         }
1: 
1:         public Object getSync() {
1:             return this.sync;
1:         }
1: 
1:         /**
1:          * Tells if the test is ready to start.
1:          *
1:          * @return {@code true} if the access threads can start.
1:          */
1:         public boolean ready() {
1:             synchronized (sync) {
1:                 return ready;
1:             }
1:         }
1: 
1:         public void start() {
1:             synchronized (sync) {
1:                 ready = true;
1:                 sync.notifyAll();
1:             }
1:         }
1: 
1:         public synchronized String toString() {
1:             int totalAccessCount = 0;
1:             for (int i=0; i < accessCounts.length; i++) {
1:                 int c = accessCounts[i];
1:                 if (c > 0) {
1:                     totalAccessCount += c;
1:                 }
1:             }
1:             String sep = "\n";
1:             StringBuffer sb = new StringBuffer(sep +
1:                     "Number of access threads: ").append(accessCounts.length).
1:                     append(sep);
1:             sb.append("Access count: " + totalAccessCount).append(sep);
1:             if (hasExceptions) {
1:                 sb.append("Exceptions (see " + failureFolder +
1:                         "/exceptions.log):" + sep);
1:                 for (int i=0; i < exceptions.length; i++) {
1:                     Throwable t = exceptions[i];
1:                     if (t instanceof SQLException) {
1:                         SQLException s = (SQLException)t;
1:                         sb.append("id=").append(i).append(" : (").
1:                         append(s.getSQLState()).append(") ").
1:                         append(s.getMessage()).append(sep);
1:                     } else if (t != null) {
1:                         sb.append("id=").append(i).append(" : (     ) ").
1:                         append(t.getMessage()).append(sep);
1: 
1:                        
1:                     }
1:                 }
1:             }
1:             return sb.toString();
1:         }
1: 
1:         /**
1:          * Dumps the exception to file.
1:          *
1:          * @param id internal id for the thread that got the exception
1:          * @param exception the exception to dump
1:          */
1:         private void dumpToFile(int id, Throwable exception) {
1:             if (writer == null) {
1:                 try {
1:                     writer = new PrintWriter(
1:                             PrivilegedFileOpsForTests.getFileOutputStream(
1:                             new File(failureFolder, ("exceptions.log"))));
1:                     writer.println(new java.util.Date());
1:                 } catch (IOException ioe) {
1:                     alarm("Failed to create exception log file: " +
1:                             ioe.getMessage());
1:                 }
1:             }
1:             if (writer != null) {
1:                 writer.println("-----");
1:                 writer.println("id=" + id);
1:                 writer.println("--");
1:                 exception.printStackTrace(writer);
1:                 writer.flush();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Access thread connection to the database and performing a simple SQL
1:      * select query. Will accept a few specific exceptions as the database
1:      * is deleted "under its feet", all other exceptions are considered a
1:      * failure and will be reported.
1:      */
1:     private static class AccessThread
1:             implements Runnable {
1: 
1:         private static final Object LOCK = new Object();
1:         //@GuardedBy("LOCK")
1:         private static int idCounter = 0;
1:         /** Whether to wait at certain points in the execution. */
1:         private static final boolean noWait;
1:         static {
1:             String tmp = getSystemProperty("derby.tests.noWait");
1:             noWait = Boolean.valueOf(tmp).booleanValue();
1:             println("noWait=" + noWait);
1:         }
1: 
1:         private final int id;
1:         private final Report master;
1:         private final String url;
1:         private final Random rnd = new Random();
1:         /** Flag used to avoid waiting at multiple points in the execution. */
1:         private boolean waited;
1: 
1:         public AccessThread(Report master, String url) {
1:             synchronized (LOCK) {
1:                 this.id = idCounter++;                
1:             }
1:             this.master = master;
1:             // Connect with a different user than the DBO. There is no real
1:             // reaon for doing this, other than making sure this user will
1:             // be blocked out by Derby during the shutdown.
1:             this.url = url + ";user=test;password=test";
1:         }
1: 
1:         public void run() {
1:             int access = 0;
1:             Connection con = null;
1:             // Wait for signal to start testing.
1:             while (!master.ready()) {
1:                 synchronized (master.getSync()) {
1:                     try {
1:                         master.getSync().wait();
1:                     } catch (InterruptedException ie) {
1:                         // Ignore, just check the loop condition again.
1:                     }
1:                 }
1:             }
1:             // Start accessing the database.
1:             try {
1:                 while (true) {
1:                     waited = false;
1:                     try {
1:                         con = DriverManager.getConnection(url);
1:                         access++;
1:                     } catch (SQLException sqle) {
1:                         // See if the exception says database not found.
1:                         // An additional check would be to make sure this
1:                         // happens after the database has been dropped, and
1:                         // that it is not caused by a bug during boot.
1:                         if (sqle.getSQLState().equals("XJ004")) {
1:                             master.reportAccessCount(id, access);
1:                             break;
1:                         }
1:                         // TODO: Adjust SQLState or remove.
1:                         if (sqle.getSQLState().equals("XJ005")) {
1:                             // Attempt blocked, keep pounding on the database.
1:                             allowWait(false);
1:                             continue;
1:                         }
1:                         // The connection process failed unexpectedly.
1:                         throw sqle;
1:                     }
1:                     // The set of allowed exceptions here is different from
1:                     // the one during connection.
1:                     try {
1:                         Statement stmt = con.createStatement();
1:                         allowWait(true);
1:                         ResultSet rs = stmt.executeQuery(
1:                             "select * from sys.systables order by random()");
1:                         allowWait(true);
1:                         while (rs.next()) {
1:                             allowWait(true);
1:                             rs.getString(1);
1:                         }
1:                         rs.close();
1:                         stmt.close();
1:                         con.close();
1:                         allowWait(false);
1:                     } catch (SQLException sqle) {
1:                         // Accept no current connection here
1:                         if (sqle.getSQLState().equals("08003")) {
1:                             master.reportAccessCount(id, access);
1:                         } else if (sqle.getSQLState().equals("XJ001") &&
1:                                 sqle.getMessage().indexOf("ShutdownException")
1:                                                                         != -1) {
1:                             master.reportAccessCount(id, access);
1:                         } else {
1:                             master.reportError(id, access, sqle);
1:                         }
1:                     }
1:                 }
1:             } catch (Throwable t) {
0:                 if (t instanceof org.apache.derby.iapi.error.ShutdownException){
1:                     // Not sure if this is a good thing yet.
1:                     System.out.println(
1:                             "Got ShutdownException (extends RuntimeException)");
1:                     master.reportAccessCount(id, access);
1:                 } else {
1:                     master.reportError(id, access, t);
1:                 }
1:             }
1:         }
1: 
1:         /**
1:          * Method mostly doing nothing, but sometimes it decides to put the
1:          * thread to sleep for a little while.
1:          */
1:         private void allowWait(boolean onlyWaitOnce) {
1:             if (!noWait && ((!waited && onlyWaitOnce) || !onlyWaitOnce)) {
1:                 int split = rnd.nextInt(100);
1:                 if (split >= 97) {
1:                     // Potentially a long sleep
1:                     sleep(100 + (long)(rnd.nextDouble() * 1200));
1:                     waited = true;
1:                 } else if (split > 80){
1:                     sleep((long)(rnd.nextDouble() * 100));
1:                     waited = true;
1:                 }
1:             }
1:         }
1:     }
1: }
============================================================================