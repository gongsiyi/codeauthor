1:078bb79: /*
1:bb8f25a:   Class org.apache.derbyTesting.functionTests.tests.store.InterruptResilienceTest
1:fc9859e: 
1:078bb79:   Licensed to the Apache Software Foundation (ASF) under one or more
1:078bb79:   contributor license agreements.  See the NOTICE file distributed with
1:078bb79:   this work for additional information regarding copyright ownership.
1:078bb79:   The ASF licenses this file to you under the Apache License, Version 2.0
1:078bb79:   (the "License"); you may not use this file except in compliance with
1:078bb79:   the License.  You may obtain a copy of the License at
1:fc9859e: 
1:078bb79:   http://www.apache.org/licenses/LICENSE-2.0
1:fc9859e: 
1:078bb79:   Unless required by applicable law or agreed to in writing, software
1:078bb79:   distributed under the License is distributed on an "AS IS" BASIS,
1:078bb79:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:078bb79:   See the License for the specific language governing permissions and
1:078bb79:   limitations under the License.
1:7f3c16b: 
1:078bb79: */
1:078bb79: package org.apache.derbyTesting.functionTests.tests.store;
23:078bb79: 
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.DriverManager;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import java.util.ArrayList;
1:1ae02c9: import java.util.Properties;
1:1ae02c9: import java.util.Random;
1:1ae02c9: import junit.framework.Test;
1:078bb79: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:59ff24c: import org.apache.derbyTesting.junit.JDBC;
1:616c0d0: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:078bb79: 
1:078bb79: /**
1:4e72f55:  * This test started out as a test reproduce and verify fix for DERBY-151.
1:4e72f55:  * Later evolved into test for DERBY-4741.
1:4e72f55:  * <p/>
1:4e72f55:  * The use of stored procedures was done to make the tests meaningful in client
1:4e72f55:  * server mode as well, but be removed/simplified as long as we only make
1:4e72f55:  * claims about the resilience of embedded Derby.
1:078bb79:  */
1:078bb79: 
1:bb8f25a: public class InterruptResilienceTest extends BaseJDBCTestCase
1:078bb79: {
1:59ff24c: 
1:bb8f25a:     public InterruptResilienceTest(String name)
1:078bb79:     {
1:078bb79:         super(name);
1:fc9859e:     }
1:2c09e2c: 
1:616c0d0:     // Share the main thread's configuration with the server side threads.
1:616c0d0:     private static volatile TestConfiguration thisConf;
1:2c09e2c: 
1:616c0d0:     protected static Test makeSuite(String name)
1:59ff24c:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:bb8f25a: 
1:616c0d0:         Test est = TestConfiguration.embeddedSuite(
1:616c0d0:             InterruptResilienceTest.class);
1:616c0d0:         Test cst = TestConfiguration.clientServerSuite(
1:616c0d0:             InterruptResilienceTest.class);
1:59ff24c: 
1:616c0d0:         est = TestConfiguration.singleUseDatabaseDecorator(est);
1:616c0d0:         cst = TestConfiguration.singleUseDatabaseDecorator(cst);
1:616c0d0:         // Cut down on running time:
1:616c0d0:         Properties p = new Properties();
1:616c0d0:         p.put("derby.system.durability", "test");
1:616c0d0:         p.put("derby.infolog.append", "true");
1:f24f53c:         // we'll force interrupts and thus serious errors, which with
1:f24f53c:         // ibm jvms would result in javacore files, which aren't of 
1:f24f53c:         // interest if the test passes. Setting the stream error level 
1:f24f53c:         // so we don't get those javacores.
1:f24f53c:         p.put("derby.stream.error.extendedDiagSeverityLevel", "50000");
1:616c0d0: 
1:616c0d0:         suite.addTest(
1:616c0d0:                 new SystemPropertyTestSetup(est, p, true));
1:616c0d0: 
1:616c0d0:         suite.addTest(
1:616c0d0:                 new SystemPropertyTestSetup(cst, p, true));
1:616c0d0:         return suite;
1:59ff24c:     }
1:078bb79: 
1:59ff24c:     public static Test suite()
1:078bb79:     {
1:616c0d0:         String testName = "InterruptResilienceTest";
1:616c0d0: 
1:064cc93:         if (isIBMJVM()) {
1:c16a687:             if (getSystemProperty("java.version").startsWith("1.4.2"))
1:078bb79:             {
1:c16a687:                 println("InterruptResilienceTest skipped for this VM, cf. DERBY-5074/5109");
1:1ae02c9:                 return new BaseTestSuite(testName);
1:616c0d0:             }
1:59ff24c:         }
1:616c0d0: 
1:616c0d0:         if (!JDBC.vmSupportsJDBC3()) {
1:616c0d0:             println("Test skipped for this VM, " +
1:616c0d0:                     "DriverManager is not supported with JSR169");
1:1ae02c9:             return new BaseTestSuite(testName);
5:078bb79:         }
1:59ff24c: 
1:391d4a6:         if (hasInterruptibleIO()) {
1:391d4a6:             println("Test skipped due to interruptible IO.");
1:391d4a6:             println("This is default on Solaris/Sun Java <= 1.6, use " +
1:391d4a6:                     "-XX:-UseVMInterruptibleIO if available.");
1:1ae02c9:             return new BaseTestSuite(testName);
1:391d4a6:         }
1:391d4a6: 
1:616c0d0:         return makeSuite(testName);
1:078bb79:     }
1:59ff24c: 
1:078bb79:     protected void setUp()
1:078bb79:             throws java.lang.Exception {
1:616c0d0:         try {
1:4469400:             Class<?> clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:4469400:             clazz.getConstructor().newInstance();
1:3abf75f:         } catch (Exception e) {
1:616c0d0:         }
1:078bb79:         super.setUp();
2:078bb79:         Statement stmt = createStatement();
1:616c0d0:         stmt.executeUpdate("create table t1(x int primary key)");
1:616c0d0:         stmt.executeUpdate("create table mtTab(i bigint, " +
1:616c0d0:                            "inserter varchar(40), " +
1:616c0d0:                            "primary key(i, inserter))");
2:078bb79:         stmt.close();
1:616c0d0: 
1:616c0d0:         thisConf = TestConfiguration.getCurrent();
1:616c0d0:         threadNo = 0;    // counter for multiple threads tests
1:d5beee7: 
1:8ce125f:         // DERBY-6122
1:078bb79:         //
1:8ce125f:         // Set a big enough timeout such that no fixture in this test encounters
1:8ce125f:         // a timeout.  The point is to force the Derby tests to exercise a new 
1:8ce125f:         // block of code added to Driver20 to handle interrupts raised during 
1:8ce125f:         // login attempts. As InterruptResilienceTest runs, interrupts are 
1:8ce125f:         // supposed to happen--although it's hard to force the exact timing of 
1:8ce125f:         // the interrupts. The login timeout added to this test is only 
1:8ce125f:         // supposed to test the following case:
1:078bb79:         //
1:8ce125f:         // 1) An interrupt occurs within the time limit set 
1:8ce125f:         //    by DriverManager.setLoginTimeout()
3:8ce125f:         //
1:8ce125f:         // 2) The new code added to Driver20 fields the interrupt and continues
1:8ce125f:         //    attempting to log in.
1:8ce125f:         //
1:8ce125f:         DriverManager.setLoginTimeout( 1000 );
1:d5beee7:         
1:616c0d0:         allDone = false; // flag for threads to terminate
1:078bb79:     }
1:59ff24c: 
1:078bb79:     /**
1:078bb79:      * Clean up the connection maintained by this test.
1:078bb79:      */
1:078bb79:     protected void tearDown()
1:078bb79:             throws java.lang.Exception {
1:078bb79: 
1:d5beee7:         DriverManager.setLoginTimeout( 0 );
1:d5beee7: 
1:ac0be7f:         // Forget about uncommitted changes
1:ac0be7f:         rollback();
1:4e72f55: 
1:ac0be7f:         // Drop the tables created in setUp() if they still exist
1:ac0be7f:         dropTable("t1");
1:ac0be7f:         dropTable("mtTab");
1:ac0be7f:         commit();
1:4e72f55: 
1:078bb79:         super.tearDown();
1:078bb79:     }
1:59ff24c: 
1:2c09e2c:     // We do the actual test inside a stored procedure so we can test this for
1:2c09e2c:     // client/server as well, otherwise we would just interrupt the client
1:616c0d0:     // thread. This SP correposnds to #testRAFWriteInterrupted.
1:616c0d0:     public static void tstRAFwriteInterrupted() throws SQLException {
1:59ff24c:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:bb8f25a:         c.setAutoCommit(false);
1:59ff24c:         PreparedStatement insert = null;
1:bb8f25a:         long seen = 0;
1:bb8f25a:         long lost = 0;
2:59ff24c:         try {
1:616c0d0:             insert = c.prepareStatement("insert into t1 values (?)");
1:59ff24c: 
1:bb8f25a:             // About 75000 iterations is needed to see any concurrency
1:bb8f25a:             // wait on RawDaemonThread during recovery, cf.
1:616c0d0:             // running with debug flag "RAF4" for RAFContainer4.
1:bb8f25a:             for (int i = 0; i < 100000; i++) {
1:bb8f25a:                 if (i % 1000 == 0) {
1:bb8f25a:                     c.commit();
1:bb8f25a:                 }
1:bb8f25a: 
1:bb8f25a:                 // Make sure to interrupt after commit, since log writing isn't
1:bb8f25a:                 // safe for interrupts (on Solaris only) yet.
1:bb8f25a:                 Thread.currentThread().interrupt();
1:bb8f25a: 
1:616c0d0:                 insert.setLong(1, i);
1:078bb79:                 insert.executeUpdate();
1:bb8f25a: 
1:616c0d0:                 assertTrue("interrupt flag lost", Thread.interrupted());
1:bb8f25a:             }
1:59ff24c:         } finally {
1:14ff5da:             // always clear flag
1:26f891c:             Thread.interrupted();
1:bb8f25a: 
1:59ff24c:             if (insert != null) {
1:616c0d0:                 try {
1:59ff24c:                     insert.close(); // already closed by error
1:616c0d0:                 } catch (SQLException e) {
1:59ff24c:                 }
1:59ff24c:             }
1:14ff5da: 
1:59ff24c:             c.close();
1:59ff24c:         }
1:59ff24c:     }
1:59ff24c: 
1:616c0d0:     public void testRAFWriteInterrupted () throws SQLException {
1:59ff24c:         Statement s = createStatement();
1:59ff24c:         s.executeUpdate(
1:616c0d0:             "create procedure tstRAFWriteInterrupted () modifies sql data " +
1:59ff24c:             "external name 'org.apache.derbyTesting.functionTests" +
1:616c0d0:             ".tests.store.InterruptResilienceTest.tstRAFwriteInterrupted' " +
1:59ff24c:             "language java parameter style java");
1:bb8f25a: 
1:616c0d0:         s.executeUpdate("call tstRAFWriteInterrupted()");
1:078bb79:     }
1:bb8f25a: 
1:59ff24c: 
1:616c0d0:     // We do the actual test inside a stored procedure so we can test this for
1:616c0d0:     // client/server as well, otherwise we would just interrupt the client
1:616c0d0:     // thread. This SP correponds to #testRAFReadWriteMultipleThreads.
1:616c0d0:     public static void tstRAFReadWriteMultipleThreads() throws Exception {
1:616c0d0: 
1:616c0d0:         //--------------------
1:616c0d0:         // part 1
1:616c0d0:         //--------------------
1:616c0d0: 
1:616c0d0:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:616c0d0: 
1:3f5c48a:         ArrayList<WorkerThread> workers = new ArrayList<WorkerThread>();
1:616c0d0: 
1:3f5c48a:         ArrayList<InterruptorThread> interruptors =
1:3f5c48a:                 new ArrayList<InterruptorThread>();
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < NO_OF_THREADS; i++) {
1:616c0d0:             WorkerThread w = new WorkerThread(
1:616c0d0:                 thisConf.openDefaultConnection(),
1:616c0d0:                 false /* read */,
1:616c0d0:                 NO_OF_MT_OPS);
1:616c0d0: 
1:616c0d0:             workers.add(w);
1:616c0d0: 
1:616c0d0:             w.start();
1:616c0d0:             try {
1:616c0d0:                 Thread.sleep(1000);
1:616c0d0:             } catch (Exception e) {
1:616c0d0:             }
1:616c0d0: 
1:616c0d0:             InterruptorThread it = new InterruptorThread(w, 500);
1:616c0d0:             interruptors.add(it);
1:616c0d0:             it.start();
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < workers.size(); i++) {
1:3f5c48a:             WorkerThread w = workers.get(i);
1:616c0d0:             w.join();
1:616c0d0: 
1:616c0d0:             if (w.e != null) {
1:616c0d0:                 fail("WorkerThread " + i, w.e);
1:616c0d0:             }
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         allDone = true;
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < interruptors.size(); i++) {
1:3f5c48a:             interruptors.get(i).join();
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         try {
1:616c0d0:             Thread.sleep(1000);
2:616c0d0:         } catch (Exception e) {
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         Statement s = c.createStatement();
1:616c0d0:         ResultSet rs = s.executeQuery("select count(*) from mtTab");
1:616c0d0: 
1:616c0d0:         JDBC.assertSingleValueResultSet(
1:616c0d0:             rs, Long.toString(NO_OF_THREADS * NO_OF_MT_OPS));
1:616c0d0: 
1:616c0d0:         //--------------------
1:616c0d0:         // part 2
1:616c0d0:         //--------------------
1:616c0d0: 
1:616c0d0:         // Reset thread state variables
1:616c0d0:         allDone = false;
1:616c0d0:         threadNo = 0;
1:616c0d0: 
1:616c0d0:         workers.clear();
1:616c0d0:         interruptors.clear();
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < NO_OF_THREADS; i++) {
1:616c0d0:             WorkerThread w = new WorkerThread(
1:616c0d0:                 // This will be an embedded connection always since for the
1:616c0d0:                 // server thread current cf will be JUNIT_CONFIG.
1:616c0d0:                 thisConf.openDefaultConnection(),
1:616c0d0:                 true,
1:616c0d0:                 NO_OF_MT_OPS);
1:616c0d0: 
1:616c0d0:             workers.add(w);
1:616c0d0: 
1:616c0d0:             try {
1:616c0d0:                 Thread.sleep(1000);
1:616c0d0:             } catch (Exception e) {
1:616c0d0:             }
1:616c0d0: 
1:616c0d0:             InterruptorThread it = new InterruptorThread(w, 500);
1:616c0d0:             interruptors.add(it);
1:616c0d0:             it.start();
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         // Wait till here to start works, so interruptors don't get too late to
1:616c0d0:         // the game
1:616c0d0:         for (int i = 0; i < workers.size(); i++) {
1:3f5c48a:             workers.get(i).start();
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < workers.size(); i++) {
1:3f5c48a:             WorkerThread w = workers.get(i);
1:616c0d0:             w.join();
1:616c0d0: 
1:616c0d0:             if (w.e != null) {
1:616c0d0:                 fail("WorkerThread " + i, w.e);
1:616c0d0:             }
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         allDone = true;
1:616c0d0: 
1:616c0d0:         for (int i = 0; i < interruptors.size(); i++) {
1:3f5c48a:             interruptors.get(i).join();
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         c.close();
1:616c0d0:     }
1:616c0d0: 
1:616c0d0: 
1:616c0d0:     static class InterruptorThread extends Thread {
1:616c0d0:         private WorkerThread myVictim;
1:616c0d0:         private int millisBetweenShots;
1:616c0d0: 
1:616c0d0:         public InterruptorThread(WorkerThread v, int m){
1:616c0d0:             super();
1:616c0d0:             myVictim = v;
1:616c0d0:             millisBetweenShots = m;
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         public void run() {
1:616c0d0:             setName("InterruptorThread. Thread #" + getThreadNo());
1:616c0d0:             println("Running " + getName() +
1:616c0d0:                     " with victim " + myVictim.getName());
1:616c0d0: 
1:616c0d0:             int shots = 0;
1:616c0d0: 
1:616c0d0:             while (!allDone) {
1:616c0d0:                 try {
1:616c0d0:                     Thread.sleep(millisBetweenShots);
1:616c0d0:                     myVictim.interrupt();
1:616c0d0:                     shots++;
1:616c0d0:                 } catch (Exception e) {
1:616c0d0:                 }
1:616c0d0:             }
1:616c0d0: 
1:616c0d0:             println(getName() + " shot " + shots +
1:616c0d0:                     " interrupts at " + myVictim.getName());
1:616c0d0:         }
1:616c0d0:     }
1:616c0d0: 
1:616c0d0: 
1:616c0d0:     static class WorkerThread extends Thread {
1:616c0d0:         private final boolean readertest;
1:616c0d0:         private final long noOps;
1:a00a031:         public Throwable e; // if any seen
1:616c0d0:         private Connection c;
1:616c0d0: 
1:616c0d0:         public WorkerThread(Connection c, boolean readertest, long noOps) {
1:616c0d0:             super();
1:616c0d0:             this.readertest = readertest;
1:616c0d0:             this.noOps = noOps;
1:616c0d0:             this.c = c;
1:616c0d0:         }
1:616c0d0: 
1:616c0d0:         public void run() {
1:616c0d0:             int threadNo = getThreadNo();
1:616c0d0:             int interruptsSeen = 0;
1:616c0d0: 
1:616c0d0:             setName("WorkerThread. Thread#" + threadNo);
1:616c0d0:             println("Running " + getName());
1:616c0d0: 
1:616c0d0:             try {
1:616c0d0:                 c.setAutoCommit(false);
1:616c0d0: 
1:3abf75f:                 String pStmtText =
1:616c0d0:                     readertest ?
1:616c0d0:                     "select * from mtTab where i=?" :
1:3abf75f:                     "insert into mtTab values (?,?)";
1:3abf75f:                 PreparedStatement s = c.prepareStatement(pStmtText);
1:616c0d0: 
1:616c0d0:                 Random rnd = new Random();
1:616c0d0: 
1:198f9bb:                 int retries = 0;
1:198f9bb: 
1:198f9bb:                 for (long ops = 0; ops < noOps + retries; ops++) {
1:616c0d0: 
1:616c0d0:                     if (readertest) {
1:616c0d0:                         // Arbitrarily select one of the rows int the tables to
1:616c0d0:                         // read
1:616c0d0:                         long candidate = randAbs(rnd.nextLong()) % noOps;
1:616c0d0:                         s.setLong(1, candidate);
1:3abf75f: 
1:3abf75f:                         // Since when we query, we might see 08000 if the
1:3abf75f:                         // interrupt flag is set when the rs.getNextRow calls
1:3abf75f:                         // checkCancellationFlag, we must be prepared to
1:3abf75f:                         // reestablish connection.
1:3abf75f: 
1:3abf75f:                         try {
1:3abf75f:                             ResultSet rs = s.executeQuery();
1:3abf75f:                             rs.next();
1:4e72f55:                             if (interrupted()) {
1:3abf75f:                                 interruptsSeen++;
1:3abf75f:                             }
1:3abf75f: 
1:3abf75f:                             assertEquals("wrong row content",
1:3abf75f:                                          candidate, rs.getLong(1));
1:3abf75f: 
1:3abf75f:                             rs.close();
1:3abf75f:                         } catch (SQLException e) {
1:3abf75f:                             if ("08000".equals(e.getSQLState())) {
1:3abf75f:                                 c = thisConf.openDefaultConnection();
1:3abf75f:                                 s = c.prepareStatement(pStmtText);
1:3abf75f:                                 assertTrue(interrupted());
1:3abf75f:                                 interruptsSeen++;
1:198f9bb:                                 retries++;
1:3abf75f:                                 continue;
1:3abf75f:                             } else {
1:a00a031:                                 fail("expected 08000", e);
1:3abf75f:                             }
1:616c0d0:                         }
1:616c0d0: 
1:616c0d0:                         c.commit();
1:616c0d0: 
1:3abf75f:                         if (interrupted()) {
2:616c0d0:                             interruptsSeen++;
1:616c0d0:                         }
1:616c0d0:                     } else {
1:616c0d0:                         s.setLong(1, ops);
1:616c0d0:                         s.setString(2, getName());
1:7711d18: 
1:7711d18:                         try {
1:7711d18:                             s.executeUpdate();
1:7711d18:                         } catch (SQLException e) {
1:7711d18:                             // Occasionally we could see a lock wait being
1:7711d18:                             // interrupted: reconnect and continue. DERBY-5001.
1:7711d18:                             // See also LockInterruptTest.
1:7711d18:                             if ("08000".equals(e.getSQLState())) {
1:7711d18:                                 c = thisConf.openDefaultConnection();
1:7711d18:                                 s = c.prepareStatement(pStmtText);
1:7711d18:                                 assertTrue(interrupted());
1:7711d18:                                 interruptsSeen++;
1:198f9bb:                                 retries++;
1:7711d18:                                 continue;
1:7711d18:                             } else {
1:a00a031:                                 fail("expected 08000", e);
1:7711d18:                             }
1:7711d18:                         }
1:7711d18: 
1:616c0d0: 
2:616c0d0:                         if (interrupted()) {
1:616c0d0:                             interruptsSeen++;
1:616c0d0:                         }
1:616c0d0: 
1:616c0d0:                         c.commit();
1:616c0d0: 
1:616c0d0:                         if (interrupted()) {
1:616c0d0:                             interruptsSeen++;
1:616c0d0:                         }
1:616c0d0:                     }
1:616c0d0:                 }
1:616c0d0:                 s.close();
1:a00a031:             } catch (Throwable e) {
1:616c0d0:                 this.e = e;
1:616c0d0:             } finally {
1:616c0d0:                 try { c.close(); } catch (Exception e) {}
1:616c0d0:             }
1:616c0d0: 
1:616c0d0:             println("Thread " + getName() + " saw " + interruptsSeen +
1:616c0d0:                     " interrupts");
1:616c0d0:         }
1:616c0d0:     }
1:616c0d0: 
1:616c0d0:     // Number of parallel threads to use
1:616c0d0:     static int NO_OF_THREADS = 3;
1:616c0d0: 
1:616c0d0:     static long NO_OF_MT_OPS = 10000;
1:616c0d0: 
1:616c0d0:     // Counter to enumerate threads for tests employing several threads.  Reset
1:616c0d0:     // for each test in setUp.
1:616c0d0:     private static int threadNo;
1:616c0d0: 
1:616c0d0:     synchronized static int getThreadNo() {
1:616c0d0:         return ++threadNo;
1:616c0d0:     }
1:616c0d0: 
1:616c0d0:     private static long randAbs(long l) {
1:616c0d0:         if (l == Long.MIN_VALUE) {
1:616c0d0:             return Long.MAX_VALUE; // 2's complement, so no way to make value
1:616c0d0:                                    // positive
1:616c0d0:         } else {
1:616c0d0:             return Math.abs(l);
1:616c0d0:         }
1:616c0d0:     }
1:616c0d0: 
1:616c0d0:     // Signal to threads to stop whatever they are doing. Reset
1:616c0d0:     // for each test in setUp.
1:616c0d0:     static volatile boolean allDone;
1:616c0d0: 
1:616c0d0:     /**
1:616c0d0:      * MT write (part 1) and read (part 2) test under interrupt shower.  This
1:616c0d0:      * stess tests the NIO random access file interrupt channel recovery in
1:616c0d0:      * RAFContainer4.
1:616c0d0:      */
1:616c0d0:     public void testRAFReadWriteMultipleThreads () throws SQLException {
1:616c0d0:         Statement s = createStatement();
1:616c0d0: 
1:616c0d0:         s.executeUpdate(
1:616c0d0:             "create procedure tstRAFReadWriteMultipleThreads () " +
1:616c0d0:             "modifies sql data " +
1:616c0d0:             "external name 'org.apache.derbyTesting.functionTests" +
1:616c0d0:             ".tests.store.InterruptResilienceTest" +
1:616c0d0:             ".tstRAFReadWriteMultipleThreads' " +
1:616c0d0:             "language java parameter style java");
1:616c0d0: 
1:616c0d0:         s.executeUpdate("call tstRAFReadWriteMultipleThreads()");
1:616c0d0:     }
1:3abf75f: 
1:3abf75f:     // We do the actual test inside a stored procedure so we can test this for
1:3abf75f:     // client/server as well, otherwise we would just interrupt the client
1:3abf75f:     // thread. This SP correponds to #testLongQueryInterrupt
1:3abf75f:     public static void tstInterruptLongQuery() throws Exception {
1:3abf75f:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:3abf75f:         Statement s = c.createStatement();
1:3abf75f: 
1:3abf75f:         try {
1:3abf75f:             Thread.currentThread().interrupt();
1:3abf75f:             ResultSet rs = s.executeQuery(
1:3abf75f:                 "select * from sys.syscolumns");
1:3abf75f:             while (rs.next()) {};
1:3abf75f:             fail("expected CONN_INTERRUPT");
1:3abf75f:         } catch (SQLException e) {
1:3abf75f:             assertSQLState("expected CONN_INTERRUPT", "08000", e);
1:3abf75f:             // assertTrue(c.isClosed()); // DERBY-4993
1:4e72f55:             assertTrue(Thread.interrupted());
1:3abf75f:         }
1:3abf75f:     }
1:3abf75f: 
1:3abf75f:     // Test that query if interrupted will get stopped as expected in
1:3abf75f:     // BasicNoPutResultSetImpl#checkCancellationFlag
1:3abf75f:     public void testLongQueryInterrupt() throws SQLException {
1:3abf75f:         Connection c = getConnection();
1:3abf75f:         Statement s = createStatement();
1:3abf75f:         s.executeUpdate(
1:3abf75f:             "create procedure tstInterruptLongQuery() " +
1:3abf75f:             "reads sql data " +
1:3abf75f:             "external name 'org.apache.derbyTesting.functionTests" +
1:3abf75f:             ".tests.store.InterruptResilienceTest" +
1:3abf75f:             ".tstInterruptLongQuery' " +
1:3abf75f:             "language java parameter style java");
1:3abf75f:         try {
1:3abf75f:             s.executeUpdate("call tstInterruptLongQuery()");
1:3abf75f:             fail("expected 40XC0 exception");
1:3abf75f:         } catch (SQLException e) {
1:3abf75f:             assertSQLState("expected 40XC0", "40XC0", e); // dead statement
1:3abf75f:             assertTrue(c.isClosed());
1:3abf75f:         }
1:3abf75f: 
1:3abf75f:     }
1:3abf75f: 
1:616c0d0: 
1:59ff24c:     // We do the actual test inside a stored procedure so we can test this for
1:59ff24c:     // client/server as well, otherwise we would just interrupt the client
1:2c09e2c:     // thread. This SP correponds to #testInterruptBatch
1:2c09e2c:     public static void tstInterruptBatch() throws Exception {
1:2c09e2c:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:2c09e2c:         Statement s = c.createStatement();
1:2c09e2c:         s.executeUpdate("create table tmp(i int)");
1:2c09e2c:         PreparedStatement ps = c.prepareStatement("insert into tmp values (?)");
1:2c09e2c: 
1:2c09e2c:         // fill batch:
1:2c09e2c:         for (int i=0; i < 10; i++) {
1:2c09e2c:             s.addBatch("insert into tmp values (" + i + ")");
1:2c09e2c:         }
1:2c09e2c: 
1:2c09e2c:         s.executeBatch(); // should work OK, since no interrupt present
1:2c09e2c: 
1:2c09e2c:         // refill batch:
1:2c09e2c:         for (int i=0; i < 10; i++) {
1:2c09e2c:             s.addBatch("insert into tmp values (" + i + ")");
1:2c09e2c:         }
1:2c09e2c: 
1:2c09e2c:         try {
1:2c09e2c:             Thread.currentThread().interrupt();
1:2c09e2c:             s.executeBatch();
1:2c09e2c:             fail("expected CONN_INTERRUPT");
1:2c09e2c:         } catch (SQLException e) {
1:2c09e2c:             assertSQLState("expected CONN_INTERRUPT", "08000", e);
1:2c09e2c:             // assertTrue(c.isClosed()); // DERBY-4993
1:2c09e2c:             assertTrue(Thread.interrupted());
1:2c09e2c:         }
1:2c09e2c:     }
1:2c09e2c: 
1:2c09e2c: 
1:2c09e2c:     // Test that batched statements, if interrupted, will get stopped as
1:2c09e2c:     // expected.
1:2c09e2c:     public void testInterruptBatch() throws SQLException {
1:2c09e2c:         Connection c = getConnection();
1:2c09e2c:         Statement s = createStatement();
1:2c09e2c:         setAutoCommit(false);
1:2c09e2c: 
1:2c09e2c:         s.executeUpdate(
1:2c09e2c:             "create procedure tstInterruptBatch() " +
1:2c09e2c:             "modifies sql data " +
1:2c09e2c:             "external name 'org.apache.derbyTesting.functionTests" +
1:2c09e2c:             ".tests.store.InterruptResilienceTest" +
1:2c09e2c:             ".tstInterruptBatch' " +
1:2c09e2c:             "language java parameter style java");
1:2c09e2c:         try {
1:2c09e2c:             s.executeUpdate("call tstInterruptBatch()");
1:2c09e2c:             fail("expected 40XC0 exception");
1:2c09e2c:         } catch (SQLException e) {
1:2c09e2c:             assertSQLState("expected 40XC0", "40XC0", e); // dead statement
1:2c09e2c:             assertTrue(c.isClosed());
1:2c09e2c:         }
1:2c09e2c: 
1:2c09e2c:         setAutoCommit(false);
1:2c09e2c:         s = createStatement();
1:2c09e2c:         // The table created inside stored routine should be gone:
1:2c09e2c:         s.executeUpdate("create table tmp(i int)");
1:2c09e2c:         rollback();
1:2c09e2c: 
1:2c09e2c:     }
1:616c0d0: 
1:616c0d0: 
1:4e72f55:     public void testInterruptShutdown() throws SQLException {
1:4e72f55:         if (!usingEmbedded()) {
1:4e72f55:             // Only meaningful for embedded.
1:4e72f55:             return;
1:4e72f55:         }
1:4e72f55: 
1:4e72f55:         setAutoCommit(false);
1:4e72f55: 
1:4e72f55:         try {
1:4e72f55:             Statement s = createStatement();
1:4e72f55:             s.executeUpdate("create table foo (i int)");
1:4e72f55:             PreparedStatement ps =
1:4e72f55:                 prepareStatement("insert into foo values ?");
1:4e72f55: 
1:4e72f55:             for (int i = 0; i < 1000; i++) {
1:4e72f55:                 ps.setInt(1,i);
1:4e72f55:                 ps.executeUpdate();
1:4e72f55:             }
1:4e72f55: 
1:4e72f55:             Thread.currentThread().interrupt();
1:4e72f55: 
1:4e72f55:             TestConfiguration.getCurrent().shutdownDatabase();
1:4e72f55: 
1:6e61723:             // Assert thread's flag:
1:4e72f55:             // DERBY-5152: Fails before fix due to lcc going away.
1:6e61723:             assertTrue(Thread.currentThread().isInterrupted());
1:6e61723: 
1:6e61723:         } finally {
1:6e61723:             Thread.interrupted(); // clear flag
1:6e61723:         }
1:6e61723:     }
1:6e61723: 
1:6e61723:     /**
1:6e61723:      * DERBY-5233: verify that CREATE TABLE (i.e. container creation) survives
1:6e61723:      * interrupts with NIO.
1:6e61723:      */
1:6e61723:     public void testCreateDropInterrupted() throws SQLException {
1:6e61723: 
1:6e61723:         if (!usingEmbedded()) {
1:6e61723:             // Only meaningful for embedded.
1:6e61723:             return;
1:6e61723:         }
1:6e61723: 
1:6e61723:         setAutoCommit(false);
1:6e61723: 
1:6e61723:         Statement s = createStatement();
1:6e61723: 
1:6e61723:         try {
1:6e61723:             Thread.currentThread().interrupt();
1:6e61723: 
1:6e61723:             s.executeUpdate("create table foo (i int)");
1:6e61723:             s.executeUpdate("insert into foo values 1");
1:6e61723:             s.executeUpdate("drop table foo");
1:6e61723: 
1:6e61723:             // Assert thread's flag:
1:6e61723:             assertTrue(Thread.currentThread().isInterrupted());
1:4e72f55: 
1:4e72f55:         } finally {
1:4e72f55:             Thread.interrupted(); // clear flag
1:4e72f55:         }
1:4e72f55:     }
1:616c0d0: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
1:             clazz.getConstructor().newInstance();
commit:d5beee7
/////////////////////////////////////////////////////////////////////////
1: 
0:         // test that we recover from login timeouts
0:         DriverManager.setLoginTimeout( 10 );
1:         
/////////////////////////////////////////////////////////////////////////
1:         DriverManager.setLoginTimeout( 0 );
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.util.ArrayList;
1: import java.util.Properties;
1: import java.util.Random;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:                 return new BaseTestSuite(testName);
1:             return new BaseTestSuite(testName);
1:             return new BaseTestSuite(testName);
commit:6e61723
/////////////////////////////////////////////////////////////////////////
1:             // Assert thread's flag:
1:             assertTrue(Thread.currentThread().isInterrupted());
1: 
1:         } finally {
1:             Thread.interrupted(); // clear flag
1:         }
1:     }
1: 
1:     /**
1:      * DERBY-5233: verify that CREATE TABLE (i.e. container creation) survives
1:      * interrupts with NIO.
1:      */
1:     public void testCreateDropInterrupted() throws SQLException {
1: 
1:         if (!usingEmbedded()) {
1:             // Only meaningful for embedded.
1:             return;
1:         }
1: 
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1: 
1:         try {
1:             Thread.currentThread().interrupt();
1: 
1:             s.executeUpdate("create table foo (i int)");
1:             s.executeUpdate("insert into foo values 1");
1:             s.executeUpdate("drop table foo");
1: 
1:             // Assert thread's flag:
1:             assertTrue(Thread.currentThread().isInterrupted());
commit:a00a031
/////////////////////////////////////////////////////////////////////////
1:         public Throwable e; // if any seen
/////////////////////////////////////////////////////////////////////////
1:                                 fail("expected 08000", e);
/////////////////////////////////////////////////////////////////////////
1:                                 fail("expected 08000", e);
/////////////////////////////////////////////////////////////////////////
1:             } catch (Throwable e) {
commit:4e72f55
/////////////////////////////////////////////////////////////////////////
0: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1:  * This test started out as a test reproduce and verify fix for DERBY-151.
1:  * Later evolved into test for DERBY-4741.
1:  * <p/>
1:  * The use of stored procedures was done to make the tests meaningful in client
1:  * server mode as well, but be removed/simplified as long as we only make
1:  * claims about the resilience of embedded Derby.
/////////////////////////////////////////////////////////////////////////
1:                         if (interrupted()) {
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     public void testInterruptShutdown() throws SQLException {
1:         if (!usingEmbedded()) {
1:             // Only meaningful for embedded.
1:             return;
1:         }
1: 
1:         setAutoCommit(false);
1: 
1:         try {
1:             Statement s = createStatement();
1:             s.executeUpdate("create table foo (i int)");
1:             PreparedStatement ps =
1:                 prepareStatement("insert into foo values ?");
1: 
1:             for (int i = 0; i < 1000; i++) {
1:                 ps.setInt(1,i);
1:                 ps.executeUpdate();
1:             }
1: 
1:             Thread.currentThread().interrupt();
1: 
1:             TestConfiguration.getCurrent().shutdownDatabase();
1: 
0:             // Assert and clear thread's flag:
1:             // DERBY-5152: Fails before fix due to lcc going away.
1:             assertTrue(Thread.interrupted());
1: 
1:         } finally {
1:             Thread.interrupted(); // clear flag
1:         }
1:     }
commit:198f9bb
/////////////////////////////////////////////////////////////////////////
1:                 int retries = 0;
1: 
1:                 for (long ops = 0; ops < noOps + retries; ops++) {
/////////////////////////////////////////////////////////////////////////
1:                                 retries++;
/////////////////////////////////////////////////////////////////////////
1:                                 retries++;
commit:7711d18
/////////////////////////////////////////////////////////////////////////
1: 
1:                         try {
1:                             s.executeUpdate();
1:                         } catch (SQLException e) {
1:                             // Occasionally we could see a lock wait being
1:                             // interrupted: reconnect and continue. DERBY-5001.
1:                             // See also LockInterruptTest.
1:                             if ("08000".equals(e.getSQLState())) {
1:                                 c = thisConf.openDefaultConnection();
1:                                 s = c.prepareStatement(pStmtText);
1:                                 assertTrue(interrupted());
1:                                 interruptsSeen++;
1:                                 continue;
1:                             } else {
0:                                 throw new Exception("expected 08000, saw" + e);
1:                             }
1:                         }
1: 
commit:2c09e2c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     // We do the actual test inside a stored procedure so we can test this for
1:     // client/server as well, otherwise we would just interrupt the client
1:     // thread. This SP correponds to #testInterruptBatch
1:     public static void tstInterruptBatch() throws Exception {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1:         s.executeUpdate("create table tmp(i int)");
1:         PreparedStatement ps = c.prepareStatement("insert into tmp values (?)");
1: 
1:         // fill batch:
1:         for (int i=0; i < 10; i++) {
1:             s.addBatch("insert into tmp values (" + i + ")");
1:         }
1: 
1:         s.executeBatch(); // should work OK, since no interrupt present
1: 
1:         // refill batch:
1:         for (int i=0; i < 10; i++) {
1:             s.addBatch("insert into tmp values (" + i + ")");
1:         }
1: 
1:         try {
1:             Thread.currentThread().interrupt();
1:             s.executeBatch();
1:             fail("expected CONN_INTERRUPT");
1:         } catch (SQLException e) {
1:             assertSQLState("expected CONN_INTERRUPT", "08000", e);
1:             // assertTrue(c.isClosed()); // DERBY-4993
1:             assertTrue(Thread.interrupted());
1:         }
1:     }
1: 
1: 
1:     // Test that batched statements, if interrupted, will get stopped as
1:     // expected.
1:     public void testInterruptBatch() throws SQLException {
1:         Connection c = getConnection();
1:         Statement s = createStatement();
1:         setAutoCommit(false);
1: 
1:         s.executeUpdate(
1:             "create procedure tstInterruptBatch() " +
1:             "modifies sql data " +
1:             "external name 'org.apache.derbyTesting.functionTests" +
1:             ".tests.store.InterruptResilienceTest" +
1:             ".tstInterruptBatch' " +
1:             "language java parameter style java");
1:         try {
1:             s.executeUpdate("call tstInterruptBatch()");
1:             fail("expected 40XC0 exception");
1:         } catch (SQLException e) {
1:             assertSQLState("expected 40XC0", "40XC0", e); // dead statement
1:             assertTrue(c.isClosed());
1:         }
1: 
1:         setAutoCommit(false);
1:         s = createStatement();
1:         // The table created inside stored routine should be gone:
1:         s.executeUpdate("create table tmp(i int)");
1:         rollback();
1: 
1:     }
commit:3abf75f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         public Exception e; // if any seen
/////////////////////////////////////////////////////////////////////////
1:                 String pStmtText =
1:                     "insert into mtTab values (?,?)";
1:                 PreparedStatement s = c.prepareStatement(pStmtText);
/////////////////////////////////////////////////////////////////////////
1: 
1:                         // Since when we query, we might see 08000 if the
1:                         // interrupt flag is set when the rs.getNextRow calls
1:                         // checkCancellationFlag, we must be prepared to
1:                         // reestablish connection.
1: 
1:                         try {
1:                             ResultSet rs = s.executeQuery();
1:                             rs.next();
1:                             if (interrupted()) {
1:                                 interruptsSeen++;
1:                             }
1: 
1:                             assertEquals("wrong row content",
1:                                          candidate, rs.getLong(1));
1: 
1:                             rs.close();
1:                         } catch (SQLException e) {
1:                             if ("08000".equals(e.getSQLState())) {
1:                                 c = thisConf.openDefaultConnection();
1:                                 s = c.prepareStatement(pStmtText);
1:                                 assertTrue(interrupted());
1:                                 interruptsSeen++;
1:                                 continue;
1:                             } else {
0:                                 throw new Exception("expected 08000, saw" + e);
1:                             }
/////////////////////////////////////////////////////////////////////////
1:             } catch (Exception e) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     // We do the actual test inside a stored procedure so we can test this for
1:     // client/server as well, otherwise we would just interrupt the client
1:     // thread. This SP correponds to #testLongQueryInterrupt
1:     public static void tstInterruptLongQuery() throws Exception {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         Statement s = c.createStatement();
1: 
1:         try {
1:             Thread.currentThread().interrupt();
1:             ResultSet rs = s.executeQuery(
1:                 "select * from sys.syscolumns");
1:             while (rs.next()) {};
1:             fail("expected CONN_INTERRUPT");
1:         } catch (SQLException e) {
1:             assertSQLState("expected CONN_INTERRUPT", "08000", e);
1:             // assertTrue(c.isClosed()); // DERBY-4993
0:             assertTrue(Thread.interrupted());
1:         }
1: 
1:     }
1: 
1:     // Test that query if interrupted will get stopped as expected in
1:     // BasicNoPutResultSetImpl#checkCancellationFlag
1:     public void testLongQueryInterrupt() throws SQLException {
1:         Connection c = getConnection();
1:         Statement s = createStatement();
1:         s.executeUpdate(
1:             "create procedure tstInterruptLongQuery() " +
1:             "reads sql data " +
1:             "external name 'org.apache.derbyTesting.functionTests" +
1:             ".tests.store.InterruptResilienceTest" +
1:             ".tstInterruptLongQuery' " +
1:             "language java parameter style java");
1:         try {
1:             s.executeUpdate("call tstInterruptLongQuery()");
1:             fail("expected 40XC0 exception");
1:         } catch (SQLException e) {
1:             assertSQLState("expected 40XC0", "40XC0", e); // dead statement
1:             assertTrue(c.isClosed());
1:         }
1: 
1:     }
commit:616c0d0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ResultSet;
0: import java.util.ArrayList;
0: import java.util.Random;
0: import java.lang.Math;
0: import java.util.Properties;
0:  * Test started as a test reproduce and verify fix for DERBY-151.  Later
0:  * evolved into test for DERBY-4741.
/////////////////////////////////////////////////////////////////////////
1:     // Share the main thread's configuration with the server side threads.
1:     private static volatile TestConfiguration thisConf;
1:     protected static Test makeSuite(String name)
1:         Test est = TestConfiguration.embeddedSuite(
1:             InterruptResilienceTest.class);
1:         Test cst = TestConfiguration.clientServerSuite(
1:             InterruptResilienceTest.class);
1:         est = TestConfiguration.singleUseDatabaseDecorator(est);
1:         cst = TestConfiguration.singleUseDatabaseDecorator(cst);
1:         // Cut down on running time:
1:         Properties p = new Properties();
1:         p.put("derby.system.durability", "test");
1:         p.put("derby.infolog.append", "true");
1: 
1:         suite.addTest(
0:             // new CleanDatabaseTestSetup(
0:             // TestConfiguration.singleUseDatabaseDecorator(
1:                 new SystemPropertyTestSetup(est, p, true));
1: 
1:         suite.addTest(
0:             // new CleanDatabaseTestSetup(
0:             // TestConfiguration.singleUseDatabaseDecorator(
1:                 new SystemPropertyTestSetup(cst, p, true));
1:         return suite;
1:         String testName = "InterruptResilienceTest";
1: 
0:             return new TestSuite(testName);
1:         }
1: 
1:         if (!JDBC.vmSupportsJDBC3()) {
1:             println("Test skipped for this VM, " +
1:                     "DriverManager is not supported with JSR169");
0:             return new TestSuite(testName);
0:             return new TestSuite(testName);
1:         return makeSuite(testName);
1:         try {
0:             Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
1:         } catch (Exception e) {
1:         }
1:         stmt.executeUpdate("create table t1(x int primary key)");
1:         stmt.executeUpdate("create table mtTab(i bigint, " +
1:                            "inserter varchar(40), " +
1:                            "primary key(i, inserter))");
1: 
1:         thisConf = TestConfiguration.getCurrent();
1:         threadNo = 0;    // counter for multiple threads tests
1:         allDone = false; // flag for threads to terminate
/////////////////////////////////////////////////////////////////////////
0:         stmt.executeUpdate("drop table t1");
0:         stmt.executeUpdate("drop table mtTab");
/////////////////////////////////////////////////////////////////////////
1:     // thread. This SP correposnds to #testRAFWriteInterrupted.
1:     public static void tstRAFwriteInterrupted() throws SQLException {
1:             insert = c.prepareStatement("insert into t1 values (?)");
1:             // running with debug flag "RAF4" for RAFContainer4.
/////////////////////////////////////////////////////////////////////////
1:                 insert.setLong(1, i);
1:                 assertTrue("interrupt flag lost", Thread.interrupted());
/////////////////////////////////////////////////////////////////////////
1:     public void testRAFWriteInterrupted () throws SQLException {
1:             "create procedure tstRAFWriteInterrupted () modifies sql data " +
1:             ".tests.store.InterruptResilienceTest.tstRAFwriteInterrupted' " +
1:         s.executeUpdate("call tstRAFWriteInterrupted()");
1:     // We do the actual test inside a stored procedure so we can test this for
1:     // client/server as well, otherwise we would just interrupt the client
1:     // thread. This SP correponds to #testRAFReadWriteMultipleThreads.
1:     public static void tstRAFReadWriteMultipleThreads() throws Exception {
1: 
1:         //--------------------
1:         // part 1
1:         //--------------------
1: 
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1: 
0:         ArrayList workers = new ArrayList();
1: 
0:         ArrayList interruptors = new ArrayList();
1: 
1:         for (int i = 0; i < NO_OF_THREADS; i++) {
1:             WorkerThread w = new WorkerThread(
1:                 thisConf.openDefaultConnection(),
1:                 false /* read */,
1:                 NO_OF_MT_OPS);
1: 
1:             workers.add(w);
1: 
1:             w.start();
1:             try {
1:                 Thread.sleep(1000);
1:             } catch (Exception e) {
1:             }
1: 
1:             InterruptorThread it = new InterruptorThread(w, 500);
1:             interruptors.add(it);
1:             it.start();
1:         }
1: 
1:         for (int i = 0; i < workers.size(); i++) {
0:             WorkerThread w = (WorkerThread)workers.get(i);
1:             w.join();
1: 
1:             if (w.e != null) {
1:                 fail("WorkerThread " + i, w.e);
1:             }
1:         }
1: 
1:         allDone = true;
1: 
1:         for (int i = 0; i < interruptors.size(); i++) {
0:             ((Thread)interruptors.get(i)).join();
1:         }
1: 
1:         try {
1:             Thread.sleep(1000);
1:         } catch (Exception e) {
1:         }
1: 
1:         Statement s = c.createStatement();
1:         ResultSet rs = s.executeQuery("select count(*) from mtTab");
1: 
1:         JDBC.assertSingleValueResultSet(
1:             rs, Long.toString(NO_OF_THREADS * NO_OF_MT_OPS));
1: 
1:         //--------------------
1:         // part 2
1:         //--------------------
1: 
1:         // Reset thread state variables
1:         allDone = false;
1:         threadNo = 0;
1: 
1:         workers.clear();
1:         interruptors.clear();
1: 
1:         for (int i = 0; i < NO_OF_THREADS; i++) {
1:             WorkerThread w = new WorkerThread(
1:                 // This will be an embedded connection always since for the
1:                 // server thread current cf will be JUNIT_CONFIG.
1:                 thisConf.openDefaultConnection(),
1:                 true,
1:                 NO_OF_MT_OPS);
1: 
1:             workers.add(w);
1: 
1:             try {
1:                 Thread.sleep(1000);
1:             } catch (Exception e) {
1:             }
1: 
1:             InterruptorThread it = new InterruptorThread(w, 500);
1:             interruptors.add(it);
1:             it.start();
1:         }
1: 
1:         // Wait till here to start works, so interruptors don't get too late to
1:         // the game
1:         for (int i = 0; i < workers.size(); i++) {
0:             ((Thread)workers.get(i)).start();
1:         }
1: 
1:         for (int i = 0; i < workers.size(); i++) {
0:             WorkerThread w = (WorkerThread)workers.get(i);
1:             w.join();
1: 
1:             if (w.e != null) {
1:                 fail("WorkerThread " + i, w.e);
1:             }
1:         }
1: 
1:         allDone = true;
1: 
1:         for (int i = 0; i < interruptors.size(); i++) {
0:             ((Thread)interruptors.get(i)).join();
1:         }
1: 
1:         c.close();
1:     }
1: 
1: 
1:     static class InterruptorThread extends Thread {
1:         private WorkerThread myVictim;
1:         private int millisBetweenShots;
1: 
1:         public InterruptorThread(WorkerThread v, int m){
1:             super();
1:             myVictim = v;
1:             millisBetweenShots = m;
1:         }
1: 
1:         public void run() {
1:             setName("InterruptorThread. Thread #" + getThreadNo());
1:             println("Running " + getName() +
1:                     " with victim " + myVictim.getName());
1: 
1:             int shots = 0;
1: 
1:             while (!allDone) {
1:                 try {
1:                     Thread.sleep(millisBetweenShots);
1:                     myVictim.interrupt();
1:                     shots++;
1:                 } catch (Exception e) {
1:                 }
1:             }
1: 
1:             println(getName() + " shot " + shots +
1:                     " interrupts at " + myVictim.getName());
1:         }
1:     }
1: 
1: 
1:     static class WorkerThread extends Thread {
1:         private final boolean readertest;
1:         private final long noOps;
0:         public SQLException e; // if any seen
1:         private Connection c;
1: 
1:         public WorkerThread(Connection c, boolean readertest, long noOps) {
1:             super();
1:             this.readertest = readertest;
1:             this.noOps = noOps;
1:             this.c = c;
1:         }
1: 
1:         public void run() {
1:             int threadNo = getThreadNo();
1:             int interruptsSeen = 0;
1: 
1:             setName("WorkerThread. Thread#" + threadNo);
1:             println("Running " + getName());
1: 
1:             try {
1:                 c.setAutoCommit(false);
1: 
0:                 PreparedStatement s = c.prepareStatement(
1:                     readertest ?
1:                     "select * from mtTab where i=?" :
0:                     "insert into mtTab values (?,?)");
1: 
1:                 Random rnd = new Random();
1: 
0:                 for (long ops = 0; ops < noOps; ops++) {
1: 
1:                     if (readertest) {
1:                         // Arbitrarily select one of the rows int the tables to
1:                         // read
1:                         long candidate = randAbs(rnd.nextLong()) % noOps;
1:                         s.setLong(1, candidate);
0:                         ResultSet rs = s.executeQuery();
0:                         rs.next();
1:                         if (interrupted()) {
1:                             interruptsSeen++;
1:                         }
1: 
0:                         assertEquals("wrong row content",
0:                                      candidate, rs.getLong(1));
1: 
0:                         rs.close();
1: 
1:                         c.commit();
1: 
1:                         if (interrupted()) {
1:                             interruptsSeen++;
1:                         }
1: 
0:                         rs.close();
1:                     } else {
1:                         s.setLong(1, ops);
1:                         s.setString(2, getName());
0:                         s.executeUpdate();
1: 
0:                         if (Thread.interrupted()) {
1:                             interruptsSeen++;
1:                         }
1: 
1:                         c.commit();
1: 
1:                         if (interrupted()) {
1:                             interruptsSeen++;
1:                         }
1:                     }
1:                 }
1:                 s.close();
1:             } catch (SQLException e) {
1:                 this.e = e;
1:             } finally {
1:                 try { c.close(); } catch (Exception e) {}
1:             }
1: 
1:             println("Thread " + getName() + " saw " + interruptsSeen +
1:                     " interrupts");
1:         }
1:     }
1: 
1:     // Number of parallel threads to use
1:     static int NO_OF_THREADS = 3;
1: 
1:     static long NO_OF_MT_OPS = 10000;
1: 
1:     // Counter to enumerate threads for tests employing several threads.  Reset
1:     // for each test in setUp.
1:     private static int threadNo;
1: 
1:     synchronized static int getThreadNo() {
1:         return ++threadNo;
1:     }
1: 
1:     private static long randAbs(long l) {
1:         if (l == Long.MIN_VALUE) {
1:             return Long.MAX_VALUE; // 2's complement, so no way to make value
1:                                    // positive
1:         } else {
1:             return Math.abs(l);
1:         }
1:     }
1: 
1:     // Signal to threads to stop whatever they are doing. Reset
1:     // for each test in setUp.
1:     static volatile boolean allDone;
1: 
1:     /**
1:      * MT write (part 1) and read (part 2) test under interrupt shower.  This
1:      * stess tests the NIO random access file interrupt channel recovery in
1:      * RAFContainer4.
1:      */
1:     public void testRAFReadWriteMultipleThreads () throws SQLException {
1:             try {
0:                 Class.forName("org.apache.derby.jdbc.EmbeddedDriver");
0:             } catch (ClassNotFoundException e) {
1:             }
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate(
1:             "create procedure tstRAFReadWriteMultipleThreads () " +
1:             "modifies sql data " +
1:             "external name 'org.apache.derbyTesting.functionTests" +
1:             ".tests.store.InterruptResilienceTest" +
1:             ".tstRAFReadWriteMultipleThreads' " +
1:             "language java parameter style java");
1: 
1:         s.executeUpdate("call tstRAFReadWriteMultipleThreads()");
1:     }
commit:391d4a6
/////////////////////////////////////////////////////////////////////////
1:         if (hasInterruptibleIO()) {
1:             println("Test skipped due to interruptible IO.");
1:             println("This is default on Solaris/Sun Java <= 1.6, use " +
1:                     "-XX:-UseVMInterruptibleIO if available.");
0:             return suite;
1:         }
1: 
commit:bb8f25a
/////////////////////////////////////////////////////////////////////////
1:   Class org.apache.derbyTesting.functionTests.tests.store.InterruptResilienceTest
/////////////////////////////////////////////////////////////////////////
0: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1: public class InterruptResilienceTest extends BaseJDBCTestCase
1:     public InterruptResilienceTest(String name)
/////////////////////////////////////////////////////////////////////////
0:             suite.addTestSuite(InterruptResilienceTest.class);
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("InterruptResilienceTest");
0:             return suite;
1: 
0:             baseSuite("InterruptResilienceTest:embedded"));
0:                 baseSuite("InterruptResilienceTest:c/s")));
/////////////////////////////////////////////////////////////////////////
0:         stmt.executeUpdate("CREATE TABLE irt(x int primary key)");
/////////////////////////////////////////////////////////////////////////
0:         stmt.executeUpdate("DROP TABLE irt");
/////////////////////////////////////////////////////////////////////////
0:     public static void irt() throws SQLException {
1:         c.setAutoCommit(false);
1:         long seen = 0;
1:         long lost = 0;
0:             insert = c.prepareStatement("insert into irt values (?)");
1:             // About 75000 iterations is needed to see any concurrency
1:             // wait on RawDaemonThread during recovery, cf.
0:             // running with debug flag "RAF4Recovery".
1:             for (int i = 0; i < 100000; i++) {
1:                 if (i % 1000 == 0) {
1:                     c.commit();
1:                 }
1: 
1:                 // Make sure to interrupt after commit, since log writing isn't
1:                 // safe for interrupts (on Solaris only) yet.
1:                 Thread.currentThread().interrupt();
1: 
1: 
0:                 if (Thread.interrupted()) { // test and reset
0:                     seen++;
0:                     // println(ff() + "interrupt seen");
0:                 } else {
0:                     // println(ff() + "interrupt lost");
0:                     lost++;
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
0:             println("interrupts recovered: " + seen);
0:             println("interrupts lost: " + lost + " (" +
0:                     (lost * 100.0/(seen + lost)) + "%)");
0:     public void testIRT () throws SQLException {
0:             "create procedure IRT () MODIFIES SQL DATA " +
0:             ".tests.store.InterruptResilienceTest.irt' " +
0:         s.executeUpdate("call IRT()");
1: 
1: 
0:     // private static String ff() {
0:     //     return Thread.currentThread().getName();
0:     // }
commit:fc9859e
/////////////////////////////////////////////////////////////////////////
1: 
0:             if ("Sun Microsystems Inc.".equals(
0:                         System.getProperty("java.vendor"))) {
1: 
0:                 suite.addTestSuite(Derby151Test.class);
0:                 return new CleanDatabaseTestSetup(
0:                     new TestSuite(Derby151Test.class, name));
1: 
0:             } else {
0:                 // DERBY-4463 test fails on IBM VMs. Remove this
0:                 // exception when that issue is solved.
0:                 println("Test skipped for this VM, cf. DERBY-4463");
0:                 return suite;
1:             }
commit:14ff5da
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // always clear flag
0:             Thread.currentThread().interrupted();
1: 
commit:7f3c16b
/////////////////////////////////////////////////////////////////////////
0:         // Clearing the interrupt flag; makes sense for embedded part of
0:         // the test. When running c/s, it would be the server thread which
0:         // receives the interrupt, and since db is shut down, that should
0:         // be ok for later tests. We need to clear the flag here since, for
0:         // embedded, the app thread is affected.
0:         Thread.currentThread().interrupted();
1: 
/////////////////////////////////////////////////////////////////////////
commit:b472c86
/////////////////////////////////////////////////////////////////////////
0:             // Clearing the interrupt flag; makes sense for embedded part of
0:             // the test. When running c/s, it would be the server thread which
0:             // receives the interrupt, and since db is shut down, that should
0:             // be ok for later tests. We need to clear the flag here since, for
0:             // embedded, the app thread is affected.
0:             Thread.currentThread().interrupted();
commit:59ff24c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (!JDBC.vmSupportsJSR169()) {
0:             // JSR169 cannot run with tests with stored procedures
0:             // that do database access - for they require a
0:             // DriverManager connection to jdbc:default:connection;
0:             // DriverManager is not supported with JSR169.
0:             suite.addTestSuite(Derby151Test.class);
0:             return new CleanDatabaseTestSetup(
0:                 new TestSuite(Derby151Test.class, name));
0:         } else {
0:             return suite;
1:         }
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("Derby151Test");
1: 
0:         suite.addTest(
0:             baseSuite("Derby151Test:embedded"));
1: 
0:         suite.addTest(
0:             TestConfiguration.clientServerDecorator(
0:                 baseSuite("Derby151Test:c/s")));
1: 
0:         return suite;
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     // We do the actual test inside a stored procedure so we can test this for
1:     // client/server as well, otherwise we would just interrupt the client
0:     // thread.
0:     public static void d151() throws SQLException {
1:         Connection c = DriverManager.getConnection("jdbc:default:connection");
1:         PreparedStatement insert = null;
0:             insert = c.prepareStatement("insert into d151 values (?)");
1: 
1:         } finally {
1:             if (insert != null) {
1:                 try {
1:                     insert.close(); // already closed by error
0:                 } catch (SQLException e) {
1:                 }
1:             }
1: 
1:             c.close();
1:         }
1:     }
1: 
0:     public void testD151 () throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate(
0:             "create procedure D151 () MODIFIES SQL DATA " +
1:             "external name 'org.apache.derbyTesting.functionTests" +
0:             ".tests.store.Derby151Test.d151' " +
1:             "language java parameter style java");
1: 
1:         try {
0:             s.executeUpdate("call D151()");
0:             // the test; the results here may depend on VMs possibly.  So just
commit:078bb79
/////////////////////////////////////////////////////////////////////////
1: /*
0:   Class org.apache.derbyTesting.functionTests.tests.store.Derby151Test
1: 
1:   Licensed to the Apache Software Foundation (ASF) under one or more
1:   contributor license agreements.  See the NOTICE file distributed with
1:   this work for additional information regarding copyright ownership.
1:   The ASF licenses this file to you under the Apache License, Version 2.0
1:   (the "License"); you may not use this file except in compliance with
1:   the License.  You may obtain a copy of the License at
1: 
1:   http://www.apache.org/licenses/LICENSE-2.0
1: 
1:   Unless required by applicable law or agreed to in writing, software
1:   distributed under the License is distributed on an "AS IS" BASIS,
1:   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:   See the License for the specific language governing permissions and
1:   limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import org.apache.derby.shared.common.sanity.SanityManager;
1: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.SQLException;
1: 
1: /**
0:  *   Test to reproduce and verify fix for DERBY-151.
1:  */
1: 
0: public class Derby151Test extends BaseJDBCTestCase
1: {
1: 
0:     public Derby151Test(String name)
1:     {
1:         super(name);
1:     }
1: 
1: 
0:     protected static Test baseSuite(String name)
1:     {
0:         TestSuite suite = new TestSuite(name);
0:         suite.addTestSuite(Derby151Test.class);
0:         return new CleanDatabaseTestSetup(
0:             new TestSuite(Derby151Test.class, name));
1:     }
1: 
1: 
1:     protected void setUp()
1:             throws java.lang.Exception {
1:         super.setUp();
1: 
1:         Statement stmt = createStatement();
0:         stmt.executeUpdate("CREATE TABLE d151(x int primary key)");
1:         stmt.close();
1:     }
1:     /**
1:      * Clean up the connection maintained by this test.
1:      */
1:     protected void tearDown()
1:             throws java.lang.Exception {
1: 
1:         Statement stmt = createStatement();
0:         stmt.executeUpdate("DROP TABLE d151");
1:         stmt.close();
1: 
1:         super.tearDown();
1:     }
1: 
1: 
0:     public void testD151 () throws SQLException {
0:         PreparedStatement insert =
0:             prepareStatement("insert into d151 values (?)");
0:         try {
0:             for (int i = 0; i < 10000; i++) {
0:                 insert.setInt(1, i);
1:                 insert.executeUpdate();
0:                 Thread.currentThread().interrupt();
1:             }
1: 
0:             // We were not able to prokove any error, but that should not fail
0:             // the test; the results here may depend on VMs possibly.  So just,
0:             // report this fact in verbose mode:
1: 
0:             println("Not able to test fix for DERBY-151: No interrupt seen");
1: 
0:         } catch (SQLException e) {
0:             assertSQLState("XSDG9", e);
1:         }
0:         insert.close(); // already closed by error
1:     }
1: 
0:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("Derby151Test");
0:         suite.addTest(
0:             baseSuite("Derby151Test:embedded"));
1: 
0:         // Note: We are not adding a client/Server version since the explicit
0:         // interrupt may (will) upset the communication socket to the client.
0:         // I see 08006 SQL state on OpenSolaris/JDK1.6.
1:         //
0:         //    :
0:         // org.apache.derby.client.am.DisconnectException:
0:         //                    A communications error has been detected: null.
0:         //    :
0:         // java.io.InterruptedIOException
0:         //    at java.net.SocketOutputStream.socketWrite0(Native Method)
0:         //    at java.net.SocketOutputStream.socketWrite(
0:         //                                         SocketOutputStream.java:92)
0:         //    at java.net.SocketOutputStream.write(SocketOutputStream.java:136)
1:         //
0:         // which happened before any error in RAFContainer4.
1: 
1: 
0:         return suite;
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<WorkerThread> workers = new ArrayList<WorkerThread>();
1:         ArrayList<InterruptorThread> interruptors =
1:                 new ArrayList<InterruptorThread>();
/////////////////////////////////////////////////////////////////////////
1:             WorkerThread w = workers.get(i);
/////////////////////////////////////////////////////////////////////////
1:             interruptors.get(i).join();
/////////////////////////////////////////////////////////////////////////
1:             workers.get(i).start();
1:             WorkerThread w = workers.get(i);
/////////////////////////////////////////////////////////////////////////
1:             interruptors.get(i).join();
commit:ac0be7f
/////////////////////////////////////////////////////////////////////////
1:         // Forget about uncommitted changes
1:         rollback();
0: 
1:         // Drop the tables created in setUp() if they still exist
1:         dropTable("t1");
1:         dropTable("mtTab");
1:         commit();
commit:26f891c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (JDBC.vmSupportsJDBC3()) {
0:             // We need a JDBC level that supports DriverManager in order
0:             // to run tests that access the database from a stored procedure
0:             // using DriverManager and jdbc:default:connection.
0:             return new CleanDatabaseTestSetup(suite);
/////////////////////////////////////////////////////////////////////////
1:             Thread.interrupted();
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:8ce125f
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6122
1:         //
1:         // Set a big enough timeout such that no fixture in this test encounters
1:         // a timeout.  The point is to force the Derby tests to exercise a new 
1:         // block of code added to Driver20 to handle interrupts raised during 
1:         // login attempts. As InterruptResilienceTest runs, interrupts are 
1:         // supposed to happen--although it's hard to force the exact timing of 
1:         // the interrupts. The login timeout added to this test is only 
1:         // supposed to test the following case:
1:         //
1:         // 1) An interrupt occurs within the time limit set 
1:         //    by DriverManager.setLoginTimeout()
1:         //
1:         // 2) The new code added to Driver20 fields the interrupt and continues
1:         //    attempting to log in.
1:         //
1:         DriverManager.setLoginTimeout( 1000 );
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:8e65593
/////////////////////////////////////////////////////////////////////////
commit:c16a687
/////////////////////////////////////////////////////////////////////////
0:                 println("InterruptResilienceTest skipped for this VM, cf. DERBY-4463");
0:                 return new TestSuite(testName);
0:             }
1:             if (getSystemProperty("java.version").startsWith("1.4.2"))
0:             {
1:                 println("InterruptResilienceTest skipped for this VM, cf. DERBY-5074/5109");
commit:064cc93
/////////////////////////////////////////////////////////////////////////
1:         if (isIBMJVM()) {
commit:f24f53c
/////////////////////////////////////////////////////////////////////////
1:         // we'll force interrupts and thus serious errors, which with
1:         // ibm jvms would result in javacore files, which aren't of 
1:         // interest if the test passes. Setting the stream error level 
1:         // so we don't get those javacores.
1:         p.put("derby.stream.error.extendedDiagSeverityLevel", "50000");
/////////////////////////////////////////////////////////////////////////
0:             // DERBY-4463 test fails on IBM VM 1.5.
0:             // It's fixed in IBM VM 1.6 SR9 and above.
0:             // Remove this condition when that issue is solved in IBM VM 1.5 SR13.
0:             if (getSystemProperty("java.version").startsWith("1.5.0"))
0:             {
0:                 println("Test skipped for this VM, cf. DERBY-4463");
0:                 return new TestSuite(testName);
0:             }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:30efca7
/////////////////////////////////////////////////////////////////////////
0:             suite.addTestSuite(Derby151Test.class);
/////////////////////////////////////////////////////////////////////////
0:         if (! isSunJVM()) {
0:             // DERBY-4463 test fails on IBM VMs. Remove this
0:             // exception when that issue is solved.
0:             println("Test skipped for this VM, cf. DERBY-4463");
0:             return suite;            
0:         }
0:         
============================================================================