1:ea335da: /*
1:dbed020:   
1:ea335da: 
1:ea335da:    Derby - Class org.apache.derby.impl.tools.optional.DBMDWrapper
1:ea335da: 
1:ea335da:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ea335da:    contributor license agreements.  See the NOTICE file distributed with
1:ea335da:    this work for additional information regarding copyright ownership.
1:ea335da:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ea335da:    (the "License"); you may not use this file except in compliance with
1:ea335da:    the License.  You may obtain a copy of the License at
1:ea335da: 
1:ea335da:       http://www.apache.org/licenses/LICENSE-2.0
1:ea335da: 
1:ea335da:    Unless required by applicable law or agreed to in writing, software
1:ea335da:    distributed under the License is distributed on an "AS IS" BASIS,
1:ea335da:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ea335da:    See the License for the specific language governing permissions and
1:ea335da:    limitations under the License.
1:ea335da: 
1:ea335da:  */
1:ea335da: 
1:ea335da: package org.apache.derby.impl.tools.optional;
1:ea335da: 
1:ea335da: import java.lang.reflect.InvocationTargetException;
1:ea335da: import java.lang.reflect.Method;
1:ea335da: import java.lang.reflect.Modifier;
1:ea335da: import java.sql.Connection;
1:ea335da: import java.sql.DriverManager;
1:ea335da: import java.sql.DatabaseMetaData;
1:ea335da: import java.sql.PreparedStatement;
1:ea335da: import java.sql.ResultSet;
1:ea335da: import java.sql.ResultSetMetaData;
1:ea335da: import java.sql.SQLException;
1:ea335da: import java.sql.Types;
1:ea335da: 
1:ea335da: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1:ea335da: 
1:ea335da: /**
1:ea335da:  * <p>
1:ea335da:  * OptionalTool to create wrapper functions which allow you to invoke DatabaseMetaData methods
1:ea335da:  * via SQL. The wrapper functions slightly change the signature of the metadata
1:ea335da:  * methods as follows:
1:ea335da:  * </p>
1:ea335da:  *
1:ea335da:  * <ul>
1:ea335da:  * <li>Arguments of type int[] and String[] have been eliminated--they are
1:ea335da:  * automatically wildcarded.</li>
1:ea335da:  * <li>The method getRowIdLifetime() has been commented out--Derby does not
1:ea335da:  * support object types.</li>
1:ea335da:  * <li>The method getSchemas() has been
1:ea335da:  * commented out--it can be uncommented when the registration logic is made
1:ea335da:  * smarter to handle the dropping of different overloads.</li>
1:ea335da:  * <li>The method supportsConvert() has been
1:ea335da:  * commented out because Derby only allows one function by a given name and
1:ea335da:  * the supportsConvert( int, int ) overload is more general.</li>
1:ea335da:  * </ul>
1:ea335da:  *
1:ea335da:  * <p>
1:ea335da:  * Methods which return ResultSet are mapped to table functions. You can join
1:ea335da:  * the metadata table functions like this:
1:ea335da:  * </p>
1:ea335da:  *
1:ea335da:  * <pre>
1:ea335da:  * -- list all of the columns in the connected Derby database
1:ea335da:  * select t.table_schem, t.table_name, c.column_name, c.type_name
1:ea335da:  * from table( getTables( null, null, null ) ) t,
1:ea335da:  *         table( getColumns( null, null, null, null ) ) c
1:ea335da:  * where c.table_schem = t.table_schem
1:ea335da:  * and c.table_name = t.table_name
1:ea335da:  * and t.table_type = 'TABLE'
1:ea335da:  * ;
1:ea335da:  * 
1:ea335da:  * 
1:ea335da:  * -- now list metadata in a foreign database
1:dbed020:  * call setDatabaseURL( 'com.mysql.jdbc.Driver', 'jdbc:mysql://localhost/world?user=root&amp;password=' );
1:ea335da:  * 
1:ea335da:  * select t.table_schem, t.table_name, c.column_name, c.type_name
1:ea335da:  * from table( getTables( 'WORLD', null, null ) ) t,
1:ea335da:  *         table( getColumns( 'WORLD', null, null, null) ) c
1:ea335da:  * where c.table_name = t.table_name
1:ea335da:  * and t.table_type = 'TABLE'
1:ea335da:  * ;
1:ea335da:  * 
1:ea335da:  * -- release the foreign connection
1:ea335da:  * call setDatabaseURL( '', '' );
1:ea335da:  * </pre>
1:ea335da:  */
1:ea335da: public  class   DBMDWrapper implements OptionalTool
1:ea335da: {
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // CONSTANTS
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     private static  final   int DEFAULT_PRECISION = 128;
1:ea335da: 
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // STATE
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // CONSTRUCTOR
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     /** 0-arg constructor to satisfy the OptionalTool contract */
1:ea335da:     public  DBMDWrapper() {}
1:ea335da:     
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // OptionalTool BEHAVIOR
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     public  void    loadTool( String... configurationParameters )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         register( true );
1:ea335da:     }
1:ea335da: 
1:ea335da:     public  void    unloadTool( String... configurationParameters )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         register( false );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /**
1:ea335da:      * <p>
1:ea335da:      * Workhorse to register or unregister all public static methods as
1:ea335da:      * Derby routines.
1:ea335da:      * </p>
1:ea335da:      */
1:ea335da:     private  void    register( boolean register )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         Connection  conn = getDefaultConnection();
1:ea335da: 
1:ea335da:         Method[]    methods = getClass().getDeclaredMethods();
1:ea335da:         int             count = methods.length;
1:ea335da: 
1:ea335da:         for ( int midx = 0; midx < count; midx++ )
1:ea335da:         {
1:ea335da:             Method  method = methods[ midx ];
1:ea335da:             int         modifiers = method.getModifiers();
1:ea335da: 
1:ea335da:             if (
1:ea335da:                 isSet( modifiers, Modifier.PUBLIC ) &&
1:ea335da:                 isSet( modifiers, Modifier.STATIC )
1:ea335da:                 )
1:ea335da:             {
1:ea335da:                 if ( register ) { registerFunction( conn,  method ); }
1:ea335da:                 else { unregisterFunction( conn, method ); }
1:ea335da:             }
1:ea335da:         }
1:ea335da:     }
1:ea335da: 
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // WRAPPER FUNCTIONS WHICH ARE REGISTERED WITH DERBY
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     public  static  boolean 	allProceduresAreCallable() throws SQLException
1:ea335da:     { return getDBMD().allProceduresAreCallable(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	allTablesAreSelectable() throws SQLException
1:ea335da:     { return getDBMD().allTablesAreSelectable(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	autoCommitFailureClosesAllResultSets() throws SQLException
1:ea335da:     { return getDBMD().autoCommitFailureClosesAllResultSets(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	dataDefinitionCausesTransactionCommit() throws SQLException
1:ea335da:     { return getDBMD().dataDefinitionCausesTransactionCommit(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	dataDefinitionIgnoredInTransactions() throws SQLException
1:ea335da:     { return getDBMD().dataDefinitionIgnoredInTransactions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	deletesAreDetected(int type) throws SQLException
1:ea335da:     { return getDBMD().deletesAreDetected( type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	doesMaxRowSizeIncludeBlobs() throws SQLException
1:ea335da:     { return getDBMD().doesMaxRowSizeIncludeBlobs(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getAttributes( String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getAttributes( catalog,  schemaPattern,  typeNamePattern,  attributeNamePattern); }
1:ea335da:     
1:ea335da: 
1:ea335da:     public  static  ResultSet 	getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable ) throws SQLException
1:ea335da:     { return getDBMD().getBestRowIdentifier( catalog,  schema,  table,  scope,  nullable ); }
1:ea335da:     
1:ea335da: 
1:ea335da:     public  static  ResultSet 	getCatalogs() throws SQLException
1:ea335da:     { return getDBMD().getCatalogs(); }
1:ea335da:     
1:ea335da:     public  static  String 	getCatalogSeparator() throws SQLException
1:ea335da:     { return getDBMD().getCatalogSeparator(); }
1:ea335da:     
1:ea335da:     public  static  String 	getCatalogTerm() throws SQLException
1:ea335da:     { return getDBMD().getCatalogTerm(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getClientInfoProperties() throws SQLException
1:ea335da:     { return getDBMD().getClientInfoProperties(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getColumnPrivileges( catalog,  schema,  table,  columnNamePattern); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getColumns( catalog,  schemaPattern,  tableNamePattern,  columnNamePattern); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getCrossReference(String parentCatalog, String parentSchema, String parentTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException
1:ea335da:     { return getDBMD().getCrossReference( parentCatalog,  parentSchema,  parentTable,  foreignCatalog,  foreignSchema,  foreignTable); }
1:ea335da:     
1:ea335da:     public  static  int 	getDatabaseMajorVersion() throws SQLException
1:ea335da:     { return getDBMD().getDatabaseMajorVersion(); }
1:ea335da:     
1:ea335da:     public  static  int 	getDatabaseMinorVersion() throws SQLException
1:ea335da:     { return getDBMD().getDatabaseMinorVersion(); }
1:ea335da:     
1:ea335da:     public  static  String 	getDatabaseProductName() throws SQLException
1:ea335da:     { return getDBMD().getDatabaseProductName(); }
1:ea335da:     
1:ea335da:     public  static  String 	getDatabaseProductVersion() throws SQLException
1:ea335da:     { return getDBMD().getDatabaseProductVersion(); }
1:ea335da:     
1:ea335da:     public  static  int 	getDefaultTransactionIsolation() throws SQLException
1:ea335da:     { return getDBMD().getDefaultTransactionIsolation(); }
1:ea335da:     
1:ea335da:     public  static  int 	getDriverMajorVersion() throws SQLException
1:ea335da:     { return getDBMD().getDriverMajorVersion(); }
1:ea335da:     
1:ea335da:     public  static  int 	getDriverMinorVersion() throws SQLException
1:ea335da:     { return getDBMD().getDriverMinorVersion(); }
1:ea335da:     
1:ea335da:     public  static  String 	getDriverName() throws SQLException
1:ea335da:     { return getDBMD().getDriverName(); }
1:ea335da:     
1:ea335da:     public  static  String 	getDriverVersion() throws SQLException
1:ea335da:     { return getDBMD().getDriverVersion(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getExportedKeys(String catalog, String schema, String table) throws SQLException
1:ea335da:     { return getDBMD().getExportedKeys( catalog,  schema,  table); }
1:ea335da:     
1:ea335da:     public  static  String 	getExtraNameCharacters() throws SQLException
1:ea335da:     { return getDBMD().getExtraNameCharacters(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getFunctionColumns( catalog,  schemaPattern,  functionNamePattern,  columnNamePattern); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getFunctions( catalog,  schemaPattern,  functionNamePattern); }
1:ea335da:     
1:ea335da:     public  static  String 	getIdentifierQuoteString() throws SQLException
1:ea335da:     { return getDBMD().getIdentifierQuoteString(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getImportedKeys(String catalog, String schema, String table) throws SQLException
1:ea335da:     { return getDBMD().getImportedKeys( catalog,  schema,  table); }
1:ea335da:     
1:ea335da: 
1:ea335da:     public  static  ResultSet 	getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException
1:ea335da:     { return getDBMD().getIndexInfo( catalog,  schema,  table,  unique,  approximate ); }
1:ea335da:     
1:ea335da: 
1:ea335da:     public  static  int 	getJDBCMajorVersion() throws SQLException
1:ea335da:     { return getDBMD().getJDBCMajorVersion(); }
1:ea335da:     
1:ea335da:     public  static  int 	getJDBCMinorVersion() throws SQLException
1:ea335da:     { return getDBMD().getJDBCMinorVersion(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxBinaryLiteralLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxBinaryLiteralLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxCatalogNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxCatalogNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxCharLiteralLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxCharLiteralLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnsInGroupBy() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnsInGroupBy(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnsInIndex() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnsInIndex(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnsInOrderBy() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnsInOrderBy(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnsInSelect() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnsInSelect(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxColumnsInTable() throws SQLException
1:ea335da:     { return getDBMD().getMaxColumnsInTable(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxConnections() throws SQLException
1:ea335da:     { return getDBMD().getMaxConnections(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxCursorNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxCursorNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxIndexLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxIndexLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxProcedureNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxProcedureNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxRowSize() throws SQLException
1:ea335da:     { return getDBMD().getMaxRowSize(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxSchemaNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxSchemaNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxStatementLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxStatementLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxStatements() throws SQLException
1:ea335da:     { return getDBMD().getMaxStatements(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxTableNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxTableNameLength(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxTablesInSelect() throws SQLException
1:ea335da:     { return getDBMD().getMaxTablesInSelect(); }
1:ea335da:     
1:ea335da:     public  static  int 	getMaxUserNameLength() throws SQLException
1:ea335da:     { return getDBMD().getMaxUserNameLength(); }
1:ea335da:     
1:ea335da:     public  static  String 	getNumericFunctions() throws SQLException
1:ea335da:     { return getDBMD().getNumericFunctions(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getPrimaryKeys(String catalog, String schema, String table) throws SQLException
1:ea335da:     { return getDBMD().getPrimaryKeys( catalog,  schema,  table); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getProcedureColumns( catalog,  schemaPattern,  procedureNamePattern,  columnNamePattern); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getProcedures( catalog,  schemaPattern,  procedureNamePattern); }
1:ea335da:     
1:ea335da:     public  static  String 	getProcedureTerm() throws SQLException
1:ea335da:     { return getDBMD().getProcedureTerm(); }
1:ea335da:     
1:ea335da:     public  static  int 	getResultSetHoldability() throws SQLException
1:ea335da:     { return getDBMD().getResultSetHoldability(); }
1:ea335da: 
1:ea335da:     // Comment out this method because we don't support this datatype
1:ea335da:     //public  static  RowIdLifetime 	getRowIdLifetime() throws SQLException
1:ea335da:     //{ return getDBMD().getRowIdLifetime(); }
1:ea335da:     
1:ea335da:     // Comment out this method so that we don't drop the following method
1:ea335da:     //public  static  ResultSet 	getSchemas() throws SQLException
1:ea335da:     //{ return getDBMD().getSchemas(); }
1:ea335da: 
1:ea335da:     public  static  ResultSet 	getSchemas(String catalog, String schemaPattern) throws SQLException
1:ea335da:     { return getDBMD().getSchemas( catalog,  schemaPattern); }
1:ea335da:     
1:ea335da:     public  static  String 	getSchemaTerm() throws SQLException
1:ea335da:     { return getDBMD().getSchemaTerm(); }
1:ea335da:     
1:ea335da:     public  static  String 	getSearchStringEscape() throws SQLException
1:ea335da:     { return getDBMD().getSearchStringEscape(); }
1:ea335da:     
1:ea335da:     public  static  String 	getSQLKeywords() throws SQLException
1:ea335da:     { return getDBMD().getSQLKeywords(); }
1:ea335da:     
1:ea335da:     public  static  int 	getSQLStateType() throws SQLException
1:ea335da:     { return getDBMD().getSQLStateType(); }
1:ea335da:     
1:ea335da:     public  static  String 	getStringFunctions() throws SQLException
1:ea335da:     { return getDBMD().getStringFunctions(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getSuperTables( catalog,  schemaPattern,  tableNamePattern); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getSuperTypes( catalog,  schemaPattern,  typeNamePattern); }
1:ea335da:     
1:ea335da:     public  static  String 	getSystemFunctions() throws SQLException
1:ea335da:     { return getDBMD().getSystemFunctions(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getTablePrivileges( catalog,  schemaPattern,  tableNamePattern); }
1:ea335da: 
1:ea335da:     // Needs to cast String[] to something else
1:ea335da:     public  static  ResultSet 	getTables(String catalog, String schemaPattern, String tableNamePattern ) throws SQLException
1:ea335da:     { return getDBMD().getTables( catalog,  schemaPattern,  tableNamePattern, (String[]) null ); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getTableTypes() throws SQLException
1:ea335da:     { return getDBMD().getTableTypes(); }
1:ea335da:     
1:ea335da:     public  static  String 	getTimeDateFunctions() throws SQLException
1:ea335da:     { return getDBMD().getTimeDateFunctions(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getTypeInfo() throws SQLException
1:ea335da:     { return getDBMD().getTypeInfo(); }
1:ea335da:      
1:ea335da:     // Eliminated the final "int[] types" argument
1:ea335da:     public  static  ResultSet 	getUDTs(String catalog, String schemaPattern, String typeNamePattern) throws SQLException
1:ea335da:     { return getDBMD().getUDTs( catalog,  schemaPattern,  typeNamePattern, (int[]) null ); }
1:ea335da:     
1:ea335da:     public  static  String 	getURL() throws SQLException
1:ea335da:     { return getDBMD().getURL(); }
1:ea335da:     
1:ea335da:     public  static  String 	getUserName() throws SQLException
1:ea335da:     { return getDBMD().getUserName(); }
1:ea335da:     
1:ea335da:     public  static  ResultSet 	getVersionColumns(String catalog, String schema, String table) throws SQLException
1:ea335da:     { return getDBMD().getVersionColumns( catalog,  schema,  table); }
1:ea335da:     
1:ea335da:     public  static  boolean 	insertsAreDetected(int type) throws SQLException
1:ea335da:     { return getDBMD().insertsAreDetected(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	isCatalogAtStart() throws SQLException
1:ea335da:     { return getDBMD().isCatalogAtStart(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	isReadOnly() throws SQLException
1:ea335da:     { return getDBMD().isReadOnly(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	locatorsUpdateCopy() throws SQLException
1:ea335da:     { return getDBMD().locatorsUpdateCopy(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	nullPlusNonNullIsNull() throws SQLException
1:ea335da:     { return getDBMD().nullPlusNonNullIsNull(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	nullsAreSortedAtEnd() throws SQLException
1:ea335da:     { return getDBMD().nullsAreSortedAtEnd(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	nullsAreSortedAtStart() throws SQLException
1:ea335da:     { return getDBMD().nullsAreSortedAtStart(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	nullsAreSortedHigh() throws SQLException
1:ea335da:     { return getDBMD().nullsAreSortedHigh(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	nullsAreSortedLow() throws SQLException
1:ea335da:     { return getDBMD().nullsAreSortedLow(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	othersDeletesAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().othersDeletesAreVisible( type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	othersInsertsAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().othersInsertsAreVisible(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	othersUpdatesAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().othersUpdatesAreVisible( type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	ownDeletesAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().ownDeletesAreVisible(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	ownInsertsAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().ownInsertsAreVisible(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	ownUpdatesAreVisible(int type) throws SQLException
1:ea335da:     { return getDBMD().ownUpdatesAreVisible(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesLowerCaseIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesLowerCaseIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesLowerCaseQuotedIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesLowerCaseQuotedIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesMixedCaseIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesMixedCaseIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesMixedCaseQuotedIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesMixedCaseQuotedIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesUpperCaseIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesUpperCaseIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	storesUpperCaseQuotedIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().storesUpperCaseQuotedIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsAlterTableWithAddColumn() throws SQLException
1:ea335da:     { return getDBMD().supportsAlterTableWithAddColumn(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsAlterTableWithDropColumn() throws SQLException
1:ea335da:     { return getDBMD().supportsAlterTableWithDropColumn(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsANSI92EntryLevelSQL() throws SQLException
1:ea335da:     { return getDBMD().supportsANSI92EntryLevelSQL(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsANSI92FullSQL() throws SQLException
1:ea335da:     { return getDBMD().supportsANSI92FullSQL(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsANSI92IntermediateSQL() throws SQLException
1:ea335da:     { return getDBMD().supportsANSI92IntermediateSQL(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsBatchUpdates() throws SQLException
1:ea335da:     { return getDBMD().supportsBatchUpdates(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCatalogsInDataManipulation() throws SQLException
1:ea335da:     { return getDBMD().supportsCatalogsInDataManipulation(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCatalogsInIndexDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsCatalogsInIndexDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCatalogsInPrivilegeDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsCatalogsInPrivilegeDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCatalogsInProcedureCalls() throws SQLException
1:ea335da:     { return getDBMD().supportsCatalogsInProcedureCalls(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCatalogsInTableDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsCatalogsInTableDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsColumnAliasing() throws SQLException
1:ea335da:     { return getDBMD().supportsColumnAliasing(); }
1:ea335da: 
1:ea335da:     // Comment this out in favor of the more general overload which follows.
1:ea335da:     // Derby only allows one function by a given name in a given schema.
1:ea335da:     //public  static  boolean 	supportsConvert() throws SQLException
1:ea335da:     //{ return getDBMD().supportsConvert(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsConvert(int fromType, int toType) throws SQLException
1:ea335da:     { return getDBMD().supportsConvert( fromType,  toType); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCoreSQLGrammar() throws SQLException
1:ea335da:     { return getDBMD().supportsCoreSQLGrammar(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsCorrelatedSubqueries() throws SQLException
1:ea335da:     { return getDBMD().supportsCorrelatedSubqueries(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsDataDefinitionAndDataManipulationTransactions() throws SQLException
1:ea335da:     { return getDBMD().supportsDataDefinitionAndDataManipulationTransactions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsDataManipulationTransactionsOnly() throws SQLException
1:ea335da:     { return getDBMD().supportsDataManipulationTransactionsOnly(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsDifferentTableCorrelationNames() throws SQLException
1:ea335da:     { return getDBMD().supportsDifferentTableCorrelationNames(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsExpressionsInOrderBy() throws SQLException
1:ea335da:     { return getDBMD().supportsExpressionsInOrderBy(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsExtendedSQLGrammar() throws SQLException
1:ea335da:     { return getDBMD().supportsExtendedSQLGrammar(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsFullOuterJoins() throws SQLException
1:ea335da:     { return getDBMD().supportsFullOuterJoins(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsGetGeneratedKeys() throws SQLException
1:ea335da:     { return getDBMD().supportsGetGeneratedKeys(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsGroupBy() throws SQLException
1:ea335da:     { return getDBMD().supportsGroupBy(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsGroupByBeyondSelect() throws SQLException
1:ea335da:     { return getDBMD().supportsGroupByBeyondSelect(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsGroupByUnrelated() throws SQLException
1:ea335da:     { return getDBMD().supportsGroupByUnrelated(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsIntegrityEnhancementFacility() throws SQLException
1:ea335da:     { return getDBMD().supportsIntegrityEnhancementFacility(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsLikeEscapeClause() throws SQLException
1:ea335da:     { return getDBMD().supportsLikeEscapeClause(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsLimitedOuterJoins() throws SQLException
1:ea335da:     { return getDBMD().supportsLimitedOuterJoins(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMinimumSQLGrammar() throws SQLException
1:ea335da:     { return getDBMD().supportsMinimumSQLGrammar(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMixedCaseIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().supportsMixedCaseIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMixedCaseQuotedIdentifiers() throws SQLException
1:ea335da:     { return getDBMD().supportsMixedCaseQuotedIdentifiers(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMultipleOpenResults() throws SQLException
1:ea335da:     { return getDBMD().supportsMultipleOpenResults(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMultipleResultSets() throws SQLException
1:ea335da:     { return getDBMD().supportsMultipleResultSets(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsMultipleTransactions() throws SQLException
1:ea335da:     { return getDBMD().supportsMultipleTransactions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsNamedParameters() throws SQLException
1:ea335da:     { return getDBMD().supportsNamedParameters(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsNonNullableColumns() throws SQLException
1:ea335da:     { return getDBMD().supportsNonNullableColumns(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOpenCursorsAcrossCommit() throws SQLException
1:ea335da:     { return getDBMD().supportsOpenCursorsAcrossCommit(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOpenCursorsAcrossRollback() throws SQLException
1:ea335da:     { return getDBMD().supportsOpenCursorsAcrossRollback(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOpenStatementsAcrossCommit() throws SQLException
1:ea335da:     { return getDBMD().supportsOpenStatementsAcrossCommit(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOpenStatementsAcrossRollback() throws SQLException
1:ea335da:     { return getDBMD().supportsOpenStatementsAcrossRollback(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOrderByUnrelated() throws SQLException
1:ea335da:     { return getDBMD().supportsOrderByUnrelated(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsOuterJoins() throws SQLException
1:ea335da:     { return getDBMD().supportsOuterJoins(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsPositionedDelete() throws SQLException
1:ea335da:     { return getDBMD().supportsPositionedDelete(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsPositionedUpdate() throws SQLException
1:ea335da:     { return getDBMD().supportsPositionedUpdate(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsResultSetConcurrency(int type, int concurrency) throws SQLException
1:ea335da:     { return getDBMD().supportsResultSetConcurrency( type,  concurrency); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsResultSetHoldability(int holdability) throws SQLException
1:ea335da:     { return getDBMD().supportsResultSetHoldability( holdability); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsResultSetType(int type) throws SQLException
1:ea335da:     { return getDBMD().supportsResultSetType( type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSavepoints() throws SQLException
1:ea335da:     { return getDBMD().supportsSavepoints(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSchemasInDataManipulation() throws SQLException
1:ea335da:     { return getDBMD().supportsSchemasInDataManipulation(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSchemasInIndexDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsSchemasInIndexDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSchemasInPrivilegeDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsSchemasInPrivilegeDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSchemasInProcedureCalls() throws SQLException
1:ea335da:     { return getDBMD().supportsSchemasInProcedureCalls(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSchemasInTableDefinitions() throws SQLException
1:ea335da:     { return getDBMD().supportsSchemasInTableDefinitions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSelectForUpdate() throws SQLException
1:ea335da:     { return getDBMD().supportsSelectForUpdate(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsStatementPooling() throws SQLException
1:ea335da:     { return getDBMD().supportsStatementPooling(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsStoredFunctionsUsingCallSyntax() throws SQLException
1:ea335da:     { return getDBMD().supportsStoredFunctionsUsingCallSyntax(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsStoredProcedures() throws SQLException
1:ea335da:     { return getDBMD().supportsStoredProcedures(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSubqueriesInComparisons() throws SQLException
1:ea335da:     { return getDBMD().supportsSubqueriesInComparisons(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSubqueriesInExists() throws SQLException
1:ea335da:     { return getDBMD().supportsSubqueriesInExists(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSubqueriesInIns() throws SQLException
1:ea335da:     { return getDBMD().supportsSubqueriesInIns(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsSubqueriesInQuantifieds() throws SQLException
1:ea335da:     { return getDBMD().supportsSubqueriesInQuantifieds(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsTableCorrelationNames() throws SQLException
1:ea335da:     { return getDBMD().supportsTableCorrelationNames(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsTransactionIsolationLevel(int level) throws SQLException
1:ea335da:     { return getDBMD().supportsTransactionIsolationLevel(level); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsTransactions() throws SQLException
1:ea335da:     { return getDBMD().supportsTransactions(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsUnion() throws SQLException
1:ea335da:     { return getDBMD().supportsUnion(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	supportsUnionAll() throws SQLException
1:ea335da:     { return getDBMD().supportsUnionAll(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	updatesAreDetected(int type) throws SQLException
1:ea335da:     { return getDBMD().updatesAreDetected(type); }
1:ea335da:     
1:ea335da:     public  static  boolean 	usesLocalFilePerTable() throws SQLException
1:ea335da:     { return getDBMD().usesLocalFilePerTable(); }
1:ea335da:     
1:ea335da:     public  static  boolean 	usesLocalFiles() throws SQLException
1:ea335da:     { return getDBMD().usesLocalFiles(); }
1:ea335da:     
1:ea335da:        
1:ea335da: 
1:ea335da: 
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // REGISTRATION MINIONS
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     /** <p>Return true if the requested modifer is set</p> */
1:ea335da:     private boolean isSet( int allModifiers, int requestedModifier )
1:ea335da:     {
1:ea335da:         return ( ( allModifiers & requestedModifier ) != 0 );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Drop the function with this method name.</p> */
1:ea335da:     private void    unregisterFunction( Connection conn, Method method )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         // maybe the method doesn't exist. swallow the exception.
1:ea335da:         try {
1:ea335da:             executeDDL( conn, "drop function " + method.getName() );
1:ea335da:         } catch (SQLException se) {}
1:ea335da:     }
1:ea335da:     
1:ea335da:     /** <p>Register the method as a Derby function.</p> */
1:ea335da:     private void    registerFunction( Connection conn, Method method )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         StringBuffer   buffer = new StringBuffer();
1:ea335da:         String              name = method.getName();
1:ea335da:         boolean         isTableFunction = isTableFunction( method );
1:ea335da: 
1:ea335da:         buffer.append( "create function " + name + "\n(" );
1:ea335da:         appendArgs( buffer, method );
1:ea335da:         buffer.append( "\n)\n" );
1:ea335da:         buffer.append( "returns " );
1:ea335da:         appendReturnType( buffer, conn, method );
1:ea335da:         buffer.append( "\nlanguage java\nreads sql data\nparameter style " );
1:ea335da:         if ( isTableFunction ) { buffer.append( "DERBY_JDBC_RESULT_SET" ); }
1:ea335da:         else { buffer.append( "java" ); }
1:ea335da:         buffer.append( "\nexternal name '" + getClass().getName() + "." + name + "'" );
1:ea335da: 
1:ea335da:         executeDDL( conn, buffer.toString() );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Return true if the method describes a table function.</p> */
1:ea335da:     private boolean isTableFunction( Method method )
1:ea335da:     {
1:ea335da:         Class   returnType = method.getReturnType();
1:ea335da: 
1:ea335da:         return ( returnType == java.sql.ResultSet.class );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Append function arguments to an evolving ddl text buffer.</p> */
1:ea335da:     private void    appendArgs( StringBuffer buffer, Method method )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         Class[] parameterTypes = method.getParameterTypes();
1:ea335da:         int         count = parameterTypes.length;
1:ea335da:         String  paramStub = "a_";
1:ea335da: 
1:ea335da:         for ( int pidx = 0; pidx < count; pidx++ )
1:ea335da:         {
1:ea335da:             Class paramType = parameterTypes[ pidx ];
1:ea335da: 
1:ea335da:             if ( pidx > 0 ) { buffer.append( "," ); }
1:ea335da:             buffer.append( "\n\t" );
1:ea335da:             buffer.append( paramStub + pidx );
1:ea335da:             buffer.append( ' ' );
1:ea335da:             buffer.append( mapJavaToSQLType( paramType ) );
1:ea335da:         }
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Append return type to an evolving ddl text buffer</p> */
1:ea335da:     private void    appendReturnType( StringBuffer buffer, Connection conn, Method method )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         Class   returnType = method.getReturnType();
1:ea335da: 
1:ea335da:         if ( java.sql.ResultSet.class == returnType ) { appendTableFunctionSignature( buffer, conn, method ); }
1:ea335da:         else { buffer.append( mapJavaToSQLType( returnType ) ); }
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Append the signature of a table function to an evolving ddl text buffer</p> */
1:ea335da:     private void    appendTableFunctionSignature( StringBuffer buffer, Connection conn, Method method )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         buffer.append( "table\n(" );
1:ea335da: 
1:ea335da:         Class[]                     parameterTypes = method.getParameterTypes();
1:ea335da:         int                         argCount = parameterTypes.length;
1:ea335da:         Object[]                argValues = new Object[ argCount ];
1:ea335da:         for ( int i = 0; i < argCount; i++ ) { argValues[ i ] = getDummyValue( parameterTypes[ i ] ); }
1:ea335da:         ResultSet               returnValue;
1:ea335da: 
1:ea335da:         try {
1:ea335da:             returnValue = (ResultSet) method.invoke( null, argValues );
1:ea335da:         }
1:ea335da:         catch (IllegalAccessException iae) { throw wrap( iae ); }
1:ea335da:         catch (InvocationTargetException ite) { throw wrap( ite ); }
1:ea335da: 
1:ea335da:         ResultSetMetaData   rsmd = returnValue.getMetaData();
1:ea335da:         int                         columnCount = rsmd.getColumnCount();
1:ea335da: 
1:ea335da:         for ( int i = 0; i < columnCount; i++ )
1:ea335da:         {
1:ea335da:             int columnNumber = i + 1;
1:ea335da:             
1:ea335da:             if ( i > 0 ) { buffer.append( "," ); }
1:ea335da:             buffer.append( "\n\t" );
1:ea335da:             buffer.append( rsmd.getColumnName( columnNumber ) );
1:ea335da:             buffer.append( "\t" );
1:ea335da:             stringifyJDBCType(  buffer, rsmd, columnNumber );
1:ea335da:         }
1:ea335da:         
1:ea335da:         buffer.append( "\n)" );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /** <p>Get a dummy value for an argument to a DBMD method.</p> */
1:ea335da:     private Object  getDummyValue( Class type )
1:ea335da:     {
1:ea335da:         if ( String.class == type ) { return ""; }
1:ce40a31:         else if ( Integer.TYPE == type ) { return 1; }
1:ce40a31:         else if ( Short.TYPE == type ) { return (short) 1; }
1:ea335da:         else if ( Boolean.TYPE == type ) { return Boolean.TRUE; }
1:ea335da:         else { return null; }
1:ea335da:     }
1:ea335da:     
1:ea335da:     /** <p>Append the name of a SQL type to an evolving ddl text buffer</p> */
1:ea335da:     private void    stringifyJDBCType( StringBuffer buffer, ResultSetMetaData rsmd, int columnNumber )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         switch ( rsmd.getColumnType( columnNumber ) )
1:ea335da:         {
1:ea335da:         case Types.CHAR:
1:ea335da:         case Types.VARCHAR:
1:ea335da:             buffer.append( rsmd.getColumnTypeName( columnNumber ) );
1:ea335da:             buffer.append( "( " );
1:ea335da:             int precision = rsmd.getPrecision( columnNumber );
1:ea335da:             if ( precision <= 0 ) { precision = DEFAULT_PRECISION; }
1:ea335da:             buffer.append( precision );
1:ea335da:             buffer.append( " )" );
1:ea335da:             break;
1:ea335da:         default:
1:ea335da:             buffer.append( rsmd.getColumnTypeName( columnNumber ) );
1:ea335da:             break;
1:ea335da:         }
1:ea335da:     }
1:ea335da:     
1:ea335da:     /**<p>Get the SQL type which corresponds to a Java type.</p> */
1:ea335da:     private String  mapJavaToSQLType( Class javaType )
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         if ( Short.TYPE == javaType ) { return "smallint"; }
1:ea335da:         else if ( Integer.TYPE == javaType ) { return "int"; }
1:ea335da:         else if ( Boolean.TYPE == javaType ) { return "boolean"; }
1:ea335da:         else if ( String.class == javaType ) { return "varchar( 32672 )"; }
1:ea335da:         else { throw new SQLException( "Unsupported type: " + javaType.getName() ); }
1:ea335da:     }
1:ea335da: 
1:ea335da:     
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da:     //
1:ea335da:     // GENERAL MINIONS
1:ea335da:     //
1:ea335da:     ///////////////////////////////////////////////////////////////////////////////////
1:ea335da: 
1:ea335da:     /**
1:ea335da:      * <p>
1:ea335da:      * Get the current session's database metadata.
1:ea335da:      * </p>
1:ea335da:      */
1:ea335da:     private static DatabaseMetaData getDBMD()
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         return getDefaultConnection().getMetaData();
1:ea335da:     }
1:ea335da:     
1:ea335da:     /**
1:ea335da:      * <p>
1:ea335da:      * Get the default connection, called from inside the database engine.
1:ea335da:      * </p>
1:ea335da:      */
1:ea335da:     private static Connection getDefaultConnection()
1:ea335da:         throws SQLException
1:ea335da:     {
1:ea335da:         return DriverManager.getConnection( "jdbc:default:connection" );
1:ea335da:     }
1:ea335da: 
1:ea335da:     /**<p>Execute a DDL statement.</p> */
1:ea335da: 	private	static	void	executeDDL( Connection conn, String text )
1:ea335da: 		throws SQLException
1:ea335da: 	{
1:ea335da: 		PreparedStatement	ps = null;
1:ea335da: 
1:ea335da: 		try {
1:ea335da: 			ps = prepareStatement( conn, text );
1:ea335da: 
1:ea335da: 			ps.execute();
1:ea335da: 		}
1:ea335da: 		finally { if ( ps != null ) { ps.close(); } }
1:ea335da: 	}
1:ea335da: 	
1:ea335da:     /**
1:ea335da:      *<p>
1:ea335da:      * Prepare a statement and print out the text.
1:ea335da:      * </p>
1:ea335da:      */
1:ea335da: 	private	static	PreparedStatement	prepareStatement( Connection conn, String text )
1:ea335da: 		throws SQLException
1:ea335da: 	{
1:ea335da: 		PreparedStatement	ps = conn.prepareStatement( text );
1:ea335da: 
1:ea335da: 		return ps;
1:ea335da: 	}
1:ea335da: 
1:ea335da:     /**
1:ea335da:      * <p>
1:ea335da:      * Wrap an exception in a SQLException.
1:ea335da:      * </p>
1:ea335da:      */
1:ea335da:     private static  SQLException    wrap( Throwable t )
1:ea335da:     {
1:ea335da:         return new SQLException( t.getMessage(), t );
1:ea335da:     }
1:ea335da:     
1:ea335da: }
1:ea335da: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:   
/////////////////////////////////////////////////////////////////////////
1:  * call setDatabaseURL( 'com.mysql.jdbc.Driver', 'jdbc:mysql://localhost/world?user=root&amp;password=' );
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:         else if ( Integer.TYPE == type ) { return 1; }
1:         else if ( Short.TYPE == type ) { return (short) 1; }
commit:ea335da
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.tools.optional.DBMDWrapper
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.optional;
1: 
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: 
1: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1: 
1: /**
1:  * <p>
1:  * OptionalTool to create wrapper functions which allow you to invoke DatabaseMetaData methods
1:  * via SQL. The wrapper functions slightly change the signature of the metadata
1:  * methods as follows:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li>Arguments of type int[] and String[] have been eliminated--they are
1:  * automatically wildcarded.</li>
1:  * <li>The method getRowIdLifetime() has been commented out--Derby does not
1:  * support object types.</li>
1:  * <li>The method getSchemas() has been
1:  * commented out--it can be uncommented when the registration logic is made
1:  * smarter to handle the dropping of different overloads.</li>
1:  * <li>The method supportsConvert() has been
1:  * commented out because Derby only allows one function by a given name and
1:  * the supportsConvert( int, int ) overload is more general.</li>
1:  * </ul>
1:  *
1:  * <p>
1:  * Methods which return ResultSet are mapped to table functions. You can join
1:  * the metadata table functions like this:
1:  * </p>
1:  *
1:  * <pre>
1:  * -- list all of the columns in the connected Derby database
1:  * select t.table_schem, t.table_name, c.column_name, c.type_name
1:  * from table( getTables( null, null, null ) ) t,
1:  *         table( getColumns( null, null, null, null ) ) c
1:  * where c.table_schem = t.table_schem
1:  * and c.table_name = t.table_name
1:  * and t.table_type = 'TABLE'
1:  * ;
1:  * 
1:  * 
1:  * -- now list metadata in a foreign database
0:  * call setDatabaseURL( 'com.mysql.jdbc.Driver', 'jdbc:mysql://localhost/world?user=root&password=' );
1:  * 
1:  * select t.table_schem, t.table_name, c.column_name, c.type_name
1:  * from table( getTables( 'WORLD', null, null ) ) t,
1:  *         table( getColumns( 'WORLD', null, null, null) ) c
1:  * where c.table_name = t.table_name
1:  * and t.table_type = 'TABLE'
1:  * ;
1:  * 
1:  * -- release the foreign connection
1:  * call setDatabaseURL( '', '' );
1:  * </pre>
1:  */
1: public  class   DBMDWrapper implements OptionalTool
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   int DEFAULT_PRECISION = 128;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** 0-arg constructor to satisfy the OptionalTool contract */
1:     public  DBMDWrapper() {}
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // OptionalTool BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  void    loadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         register( true );
1:     }
1: 
1:     public  void    unloadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         register( false );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Workhorse to register or unregister all public static methods as
1:      * Derby routines.
1:      * </p>
1:      */
1:     private  void    register( boolean register )
1:         throws SQLException
1:     {
1:         Connection  conn = getDefaultConnection();
1: 
1:         Method[]    methods = getClass().getDeclaredMethods();
1:         int             count = methods.length;
1: 
1:         for ( int midx = 0; midx < count; midx++ )
1:         {
1:             Method  method = methods[ midx ];
1:             int         modifiers = method.getModifiers();
1: 
1:             if (
1:                 isSet( modifiers, Modifier.PUBLIC ) &&
1:                 isSet( modifiers, Modifier.STATIC )
1:                 )
1:             {
1:                 if ( register ) { registerFunction( conn,  method ); }
1:                 else { unregisterFunction( conn, method ); }
1:             }
1:         }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // WRAPPER FUNCTIONS WHICH ARE REGISTERED WITH DERBY
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  boolean 	allProceduresAreCallable() throws SQLException
1:     { return getDBMD().allProceduresAreCallable(); }
1:     
1:     public  static  boolean 	allTablesAreSelectable() throws SQLException
1:     { return getDBMD().allTablesAreSelectable(); }
1:     
1:     public  static  boolean 	autoCommitFailureClosesAllResultSets() throws SQLException
1:     { return getDBMD().autoCommitFailureClosesAllResultSets(); }
1:     
1:     public  static  boolean 	dataDefinitionCausesTransactionCommit() throws SQLException
1:     { return getDBMD().dataDefinitionCausesTransactionCommit(); }
1:     
1:     public  static  boolean 	dataDefinitionIgnoredInTransactions() throws SQLException
1:     { return getDBMD().dataDefinitionIgnoredInTransactions(); }
1:     
1:     public  static  boolean 	deletesAreDetected(int type) throws SQLException
1:     { return getDBMD().deletesAreDetected( type); }
1:     
1:     public  static  boolean 	doesMaxRowSizeIncludeBlobs() throws SQLException
1:     { return getDBMD().doesMaxRowSizeIncludeBlobs(); }
1:     
1:     public  static  ResultSet 	getAttributes( String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException
1:     { return getDBMD().getAttributes( catalog,  schemaPattern,  typeNamePattern,  attributeNamePattern); }
1:     
1: 
1:     public  static  ResultSet 	getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable ) throws SQLException
1:     { return getDBMD().getBestRowIdentifier( catalog,  schema,  table,  scope,  nullable ); }
1:     
1: 
1:     public  static  ResultSet 	getCatalogs() throws SQLException
1:     { return getDBMD().getCatalogs(); }
1:     
1:     public  static  String 	getCatalogSeparator() throws SQLException
1:     { return getDBMD().getCatalogSeparator(); }
1:     
1:     public  static  String 	getCatalogTerm() throws SQLException
1:     { return getDBMD().getCatalogTerm(); }
1:     
1:     public  static  ResultSet 	getClientInfoProperties() throws SQLException
1:     { return getDBMD().getClientInfoProperties(); }
1:     
1:     public  static  ResultSet 	getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws SQLException
1:     { return getDBMD().getColumnPrivileges( catalog,  schema,  table,  columnNamePattern); }
1:     
1:     public  static  ResultSet 	getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException
1:     { return getDBMD().getColumns( catalog,  schemaPattern,  tableNamePattern,  columnNamePattern); }
1:     
1:     public  static  ResultSet 	getCrossReference(String parentCatalog, String parentSchema, String parentTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException
1:     { return getDBMD().getCrossReference( parentCatalog,  parentSchema,  parentTable,  foreignCatalog,  foreignSchema,  foreignTable); }
1:     
1:     public  static  int 	getDatabaseMajorVersion() throws SQLException
1:     { return getDBMD().getDatabaseMajorVersion(); }
1:     
1:     public  static  int 	getDatabaseMinorVersion() throws SQLException
1:     { return getDBMD().getDatabaseMinorVersion(); }
1:     
1:     public  static  String 	getDatabaseProductName() throws SQLException
1:     { return getDBMD().getDatabaseProductName(); }
1:     
1:     public  static  String 	getDatabaseProductVersion() throws SQLException
1:     { return getDBMD().getDatabaseProductVersion(); }
1:     
1:     public  static  int 	getDefaultTransactionIsolation() throws SQLException
1:     { return getDBMD().getDefaultTransactionIsolation(); }
1:     
1:     public  static  int 	getDriverMajorVersion() throws SQLException
1:     { return getDBMD().getDriverMajorVersion(); }
1:     
1:     public  static  int 	getDriverMinorVersion() throws SQLException
1:     { return getDBMD().getDriverMinorVersion(); }
1:     
1:     public  static  String 	getDriverName() throws SQLException
1:     { return getDBMD().getDriverName(); }
1:     
1:     public  static  String 	getDriverVersion() throws SQLException
1:     { return getDBMD().getDriverVersion(); }
1:     
1:     public  static  ResultSet 	getExportedKeys(String catalog, String schema, String table) throws SQLException
1:     { return getDBMD().getExportedKeys( catalog,  schema,  table); }
1:     
1:     public  static  String 	getExtraNameCharacters() throws SQLException
1:     { return getDBMD().getExtraNameCharacters(); }
1:     
1:     public  static  ResultSet 	getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws SQLException
1:     { return getDBMD().getFunctionColumns( catalog,  schemaPattern,  functionNamePattern,  columnNamePattern); }
1:     
1:     public  static  ResultSet 	getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws SQLException
1:     { return getDBMD().getFunctions( catalog,  schemaPattern,  functionNamePattern); }
1:     
1:     public  static  String 	getIdentifierQuoteString() throws SQLException
1:     { return getDBMD().getIdentifierQuoteString(); }
1:     
1:     public  static  ResultSet 	getImportedKeys(String catalog, String schema, String table) throws SQLException
1:     { return getDBMD().getImportedKeys( catalog,  schema,  table); }
1:     
1: 
1:     public  static  ResultSet 	getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException
1:     { return getDBMD().getIndexInfo( catalog,  schema,  table,  unique,  approximate ); }
1:     
1: 
1:     public  static  int 	getJDBCMajorVersion() throws SQLException
1:     { return getDBMD().getJDBCMajorVersion(); }
1:     
1:     public  static  int 	getJDBCMinorVersion() throws SQLException
1:     { return getDBMD().getJDBCMinorVersion(); }
1:     
1:     public  static  int 	getMaxBinaryLiteralLength() throws SQLException
1:     { return getDBMD().getMaxBinaryLiteralLength(); }
1:     
1:     public  static  int 	getMaxCatalogNameLength() throws SQLException
1:     { return getDBMD().getMaxCatalogNameLength(); }
1:     
1:     public  static  int 	getMaxCharLiteralLength() throws SQLException
1:     { return getDBMD().getMaxCharLiteralLength(); }
1:     
1:     public  static  int 	getMaxColumnNameLength() throws SQLException
1:     { return getDBMD().getMaxColumnNameLength(); }
1:     
1:     public  static  int 	getMaxColumnsInGroupBy() throws SQLException
1:     { return getDBMD().getMaxColumnsInGroupBy(); }
1:     
1:     public  static  int 	getMaxColumnsInIndex() throws SQLException
1:     { return getDBMD().getMaxColumnsInIndex(); }
1:     
1:     public  static  int 	getMaxColumnsInOrderBy() throws SQLException
1:     { return getDBMD().getMaxColumnsInOrderBy(); }
1:     
1:     public  static  int 	getMaxColumnsInSelect() throws SQLException
1:     { return getDBMD().getMaxColumnsInSelect(); }
1:     
1:     public  static  int 	getMaxColumnsInTable() throws SQLException
1:     { return getDBMD().getMaxColumnsInTable(); }
1:     
1:     public  static  int 	getMaxConnections() throws SQLException
1:     { return getDBMD().getMaxConnections(); }
1:     
1:     public  static  int 	getMaxCursorNameLength() throws SQLException
1:     { return getDBMD().getMaxCursorNameLength(); }
1:     
1:     public  static  int 	getMaxIndexLength() throws SQLException
1:     { return getDBMD().getMaxIndexLength(); }
1:     
1:     public  static  int 	getMaxProcedureNameLength() throws SQLException
1:     { return getDBMD().getMaxProcedureNameLength(); }
1:     
1:     public  static  int 	getMaxRowSize() throws SQLException
1:     { return getDBMD().getMaxRowSize(); }
1:     
1:     public  static  int 	getMaxSchemaNameLength() throws SQLException
1:     { return getDBMD().getMaxSchemaNameLength(); }
1:     
1:     public  static  int 	getMaxStatementLength() throws SQLException
1:     { return getDBMD().getMaxStatementLength(); }
1:     
1:     public  static  int 	getMaxStatements() throws SQLException
1:     { return getDBMD().getMaxStatements(); }
1:     
1:     public  static  int 	getMaxTableNameLength() throws SQLException
1:     { return getDBMD().getMaxTableNameLength(); }
1:     
1:     public  static  int 	getMaxTablesInSelect() throws SQLException
1:     { return getDBMD().getMaxTablesInSelect(); }
1:     
1:     public  static  int 	getMaxUserNameLength() throws SQLException
1:     { return getDBMD().getMaxUserNameLength(); }
1:     
1:     public  static  String 	getNumericFunctions() throws SQLException
1:     { return getDBMD().getNumericFunctions(); }
1:     
1:     public  static  ResultSet 	getPrimaryKeys(String catalog, String schema, String table) throws SQLException
1:     { return getDBMD().getPrimaryKeys( catalog,  schema,  table); }
1:     
1:     public  static  ResultSet 	getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException
1:     { return getDBMD().getProcedureColumns( catalog,  schemaPattern,  procedureNamePattern,  columnNamePattern); }
1:     
1:     public  static  ResultSet 	getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException
1:     { return getDBMD().getProcedures( catalog,  schemaPattern,  procedureNamePattern); }
1:     
1:     public  static  String 	getProcedureTerm() throws SQLException
1:     { return getDBMD().getProcedureTerm(); }
1:     
1:     public  static  int 	getResultSetHoldability() throws SQLException
1:     { return getDBMD().getResultSetHoldability(); }
1: 
1:     // Comment out this method because we don't support this datatype
1:     //public  static  RowIdLifetime 	getRowIdLifetime() throws SQLException
1:     //{ return getDBMD().getRowIdLifetime(); }
1:     
1:     // Comment out this method so that we don't drop the following method
1:     //public  static  ResultSet 	getSchemas() throws SQLException
1:     //{ return getDBMD().getSchemas(); }
1: 
1:     public  static  ResultSet 	getSchemas(String catalog, String schemaPattern) throws SQLException
1:     { return getDBMD().getSchemas( catalog,  schemaPattern); }
1:     
1:     public  static  String 	getSchemaTerm() throws SQLException
1:     { return getDBMD().getSchemaTerm(); }
1:     
1:     public  static  String 	getSearchStringEscape() throws SQLException
1:     { return getDBMD().getSearchStringEscape(); }
1:     
1:     public  static  String 	getSQLKeywords() throws SQLException
1:     { return getDBMD().getSQLKeywords(); }
1:     
1:     public  static  int 	getSQLStateType() throws SQLException
1:     { return getDBMD().getSQLStateType(); }
1:     
1:     public  static  String 	getStringFunctions() throws SQLException
1:     { return getDBMD().getStringFunctions(); }
1:     
1:     public  static  ResultSet 	getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException
1:     { return getDBMD().getSuperTables( catalog,  schemaPattern,  tableNamePattern); }
1:     
1:     public  static  ResultSet 	getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException
1:     { return getDBMD().getSuperTypes( catalog,  schemaPattern,  typeNamePattern); }
1:     
1:     public  static  String 	getSystemFunctions() throws SQLException
1:     { return getDBMD().getSystemFunctions(); }
1:     
1:     public  static  ResultSet 	getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws SQLException
1:     { return getDBMD().getTablePrivileges( catalog,  schemaPattern,  tableNamePattern); }
1: 
1:     // Needs to cast String[] to something else
1:     public  static  ResultSet 	getTables(String catalog, String schemaPattern, String tableNamePattern ) throws SQLException
1:     { return getDBMD().getTables( catalog,  schemaPattern,  tableNamePattern, (String[]) null ); }
1:     
1:     public  static  ResultSet 	getTableTypes() throws SQLException
1:     { return getDBMD().getTableTypes(); }
1:     
1:     public  static  String 	getTimeDateFunctions() throws SQLException
1:     { return getDBMD().getTimeDateFunctions(); }
1:     
1:     public  static  ResultSet 	getTypeInfo() throws SQLException
1:     { return getDBMD().getTypeInfo(); }
1:      
1:     // Eliminated the final "int[] types" argument
1:     public  static  ResultSet 	getUDTs(String catalog, String schemaPattern, String typeNamePattern) throws SQLException
1:     { return getDBMD().getUDTs( catalog,  schemaPattern,  typeNamePattern, (int[]) null ); }
1:     
1:     public  static  String 	getURL() throws SQLException
1:     { return getDBMD().getURL(); }
1:     
1:     public  static  String 	getUserName() throws SQLException
1:     { return getDBMD().getUserName(); }
1:     
1:     public  static  ResultSet 	getVersionColumns(String catalog, String schema, String table) throws SQLException
1:     { return getDBMD().getVersionColumns( catalog,  schema,  table); }
1:     
1:     public  static  boolean 	insertsAreDetected(int type) throws SQLException
1:     { return getDBMD().insertsAreDetected(type); }
1:     
1:     public  static  boolean 	isCatalogAtStart() throws SQLException
1:     { return getDBMD().isCatalogAtStart(); }
1:     
1:     public  static  boolean 	isReadOnly() throws SQLException
1:     { return getDBMD().isReadOnly(); }
1:     
1:     public  static  boolean 	locatorsUpdateCopy() throws SQLException
1:     { return getDBMD().locatorsUpdateCopy(); }
1:     
1:     public  static  boolean 	nullPlusNonNullIsNull() throws SQLException
1:     { return getDBMD().nullPlusNonNullIsNull(); }
1:     
1:     public  static  boolean 	nullsAreSortedAtEnd() throws SQLException
1:     { return getDBMD().nullsAreSortedAtEnd(); }
1:     
1:     public  static  boolean 	nullsAreSortedAtStart() throws SQLException
1:     { return getDBMD().nullsAreSortedAtStart(); }
1:     
1:     public  static  boolean 	nullsAreSortedHigh() throws SQLException
1:     { return getDBMD().nullsAreSortedHigh(); }
1:     
1:     public  static  boolean 	nullsAreSortedLow() throws SQLException
1:     { return getDBMD().nullsAreSortedLow(); }
1:     
1:     public  static  boolean 	othersDeletesAreVisible(int type) throws SQLException
1:     { return getDBMD().othersDeletesAreVisible( type); }
1:     
1:     public  static  boolean 	othersInsertsAreVisible(int type) throws SQLException
1:     { return getDBMD().othersInsertsAreVisible(type); }
1:     
1:     public  static  boolean 	othersUpdatesAreVisible(int type) throws SQLException
1:     { return getDBMD().othersUpdatesAreVisible( type); }
1:     
1:     public  static  boolean 	ownDeletesAreVisible(int type) throws SQLException
1:     { return getDBMD().ownDeletesAreVisible(type); }
1:     
1:     public  static  boolean 	ownInsertsAreVisible(int type) throws SQLException
1:     { return getDBMD().ownInsertsAreVisible(type); }
1:     
1:     public  static  boolean 	ownUpdatesAreVisible(int type) throws SQLException
1:     { return getDBMD().ownUpdatesAreVisible(type); }
1:     
1:     public  static  boolean 	storesLowerCaseIdentifiers() throws SQLException
1:     { return getDBMD().storesLowerCaseIdentifiers(); }
1:     
1:     public  static  boolean 	storesLowerCaseQuotedIdentifiers() throws SQLException
1:     { return getDBMD().storesLowerCaseQuotedIdentifiers(); }
1:     
1:     public  static  boolean 	storesMixedCaseIdentifiers() throws SQLException
1:     { return getDBMD().storesMixedCaseIdentifiers(); }
1:     
1:     public  static  boolean 	storesMixedCaseQuotedIdentifiers() throws SQLException
1:     { return getDBMD().storesMixedCaseQuotedIdentifiers(); }
1:     
1:     public  static  boolean 	storesUpperCaseIdentifiers() throws SQLException
1:     { return getDBMD().storesUpperCaseIdentifiers(); }
1:     
1:     public  static  boolean 	storesUpperCaseQuotedIdentifiers() throws SQLException
1:     { return getDBMD().storesUpperCaseQuotedIdentifiers(); }
1:     
1:     public  static  boolean 	supportsAlterTableWithAddColumn() throws SQLException
1:     { return getDBMD().supportsAlterTableWithAddColumn(); }
1:     
1:     public  static  boolean 	supportsAlterTableWithDropColumn() throws SQLException
1:     { return getDBMD().supportsAlterTableWithDropColumn(); }
1:     
1:     public  static  boolean 	supportsANSI92EntryLevelSQL() throws SQLException
1:     { return getDBMD().supportsANSI92EntryLevelSQL(); }
1:     
1:     public  static  boolean 	supportsANSI92FullSQL() throws SQLException
1:     { return getDBMD().supportsANSI92FullSQL(); }
1:     
1:     public  static  boolean 	supportsANSI92IntermediateSQL() throws SQLException
1:     { return getDBMD().supportsANSI92IntermediateSQL(); }
1:     
1:     public  static  boolean 	supportsBatchUpdates() throws SQLException
1:     { return getDBMD().supportsBatchUpdates(); }
1:     
1:     public  static  boolean 	supportsCatalogsInDataManipulation() throws SQLException
1:     { return getDBMD().supportsCatalogsInDataManipulation(); }
1:     
1:     public  static  boolean 	supportsCatalogsInIndexDefinitions() throws SQLException
1:     { return getDBMD().supportsCatalogsInIndexDefinitions(); }
1:     
1:     public  static  boolean 	supportsCatalogsInPrivilegeDefinitions() throws SQLException
1:     { return getDBMD().supportsCatalogsInPrivilegeDefinitions(); }
1:     
1:     public  static  boolean 	supportsCatalogsInProcedureCalls() throws SQLException
1:     { return getDBMD().supportsCatalogsInProcedureCalls(); }
1:     
1:     public  static  boolean 	supportsCatalogsInTableDefinitions() throws SQLException
1:     { return getDBMD().supportsCatalogsInTableDefinitions(); }
1:     
1:     public  static  boolean 	supportsColumnAliasing() throws SQLException
1:     { return getDBMD().supportsColumnAliasing(); }
1: 
1:     // Comment this out in favor of the more general overload which follows.
1:     // Derby only allows one function by a given name in a given schema.
1:     //public  static  boolean 	supportsConvert() throws SQLException
1:     //{ return getDBMD().supportsConvert(); }
1:     
1:     public  static  boolean 	supportsConvert(int fromType, int toType) throws SQLException
1:     { return getDBMD().supportsConvert( fromType,  toType); }
1:     
1:     public  static  boolean 	supportsCoreSQLGrammar() throws SQLException
1:     { return getDBMD().supportsCoreSQLGrammar(); }
1:     
1:     public  static  boolean 	supportsCorrelatedSubqueries() throws SQLException
1:     { return getDBMD().supportsCorrelatedSubqueries(); }
1:     
1:     public  static  boolean 	supportsDataDefinitionAndDataManipulationTransactions() throws SQLException
1:     { return getDBMD().supportsDataDefinitionAndDataManipulationTransactions(); }
1:     
1:     public  static  boolean 	supportsDataManipulationTransactionsOnly() throws SQLException
1:     { return getDBMD().supportsDataManipulationTransactionsOnly(); }
1:     
1:     public  static  boolean 	supportsDifferentTableCorrelationNames() throws SQLException
1:     { return getDBMD().supportsDifferentTableCorrelationNames(); }
1:     
1:     public  static  boolean 	supportsExpressionsInOrderBy() throws SQLException
1:     { return getDBMD().supportsExpressionsInOrderBy(); }
1:     
1:     public  static  boolean 	supportsExtendedSQLGrammar() throws SQLException
1:     { return getDBMD().supportsExtendedSQLGrammar(); }
1:     
1:     public  static  boolean 	supportsFullOuterJoins() throws SQLException
1:     { return getDBMD().supportsFullOuterJoins(); }
1:     
1:     public  static  boolean 	supportsGetGeneratedKeys() throws SQLException
1:     { return getDBMD().supportsGetGeneratedKeys(); }
1:     
1:     public  static  boolean 	supportsGroupBy() throws SQLException
1:     { return getDBMD().supportsGroupBy(); }
1:     
1:     public  static  boolean 	supportsGroupByBeyondSelect() throws SQLException
1:     { return getDBMD().supportsGroupByBeyondSelect(); }
1:     
1:     public  static  boolean 	supportsGroupByUnrelated() throws SQLException
1:     { return getDBMD().supportsGroupByUnrelated(); }
1:     
1:     public  static  boolean 	supportsIntegrityEnhancementFacility() throws SQLException
1:     { return getDBMD().supportsIntegrityEnhancementFacility(); }
1:     
1:     public  static  boolean 	supportsLikeEscapeClause() throws SQLException
1:     { return getDBMD().supportsLikeEscapeClause(); }
1:     
1:     public  static  boolean 	supportsLimitedOuterJoins() throws SQLException
1:     { return getDBMD().supportsLimitedOuterJoins(); }
1:     
1:     public  static  boolean 	supportsMinimumSQLGrammar() throws SQLException
1:     { return getDBMD().supportsMinimumSQLGrammar(); }
1:     
1:     public  static  boolean 	supportsMixedCaseIdentifiers() throws SQLException
1:     { return getDBMD().supportsMixedCaseIdentifiers(); }
1:     
1:     public  static  boolean 	supportsMixedCaseQuotedIdentifiers() throws SQLException
1:     { return getDBMD().supportsMixedCaseQuotedIdentifiers(); }
1:     
1:     public  static  boolean 	supportsMultipleOpenResults() throws SQLException
1:     { return getDBMD().supportsMultipleOpenResults(); }
1:     
1:     public  static  boolean 	supportsMultipleResultSets() throws SQLException
1:     { return getDBMD().supportsMultipleResultSets(); }
1:     
1:     public  static  boolean 	supportsMultipleTransactions() throws SQLException
1:     { return getDBMD().supportsMultipleTransactions(); }
1:     
1:     public  static  boolean 	supportsNamedParameters() throws SQLException
1:     { return getDBMD().supportsNamedParameters(); }
1:     
1:     public  static  boolean 	supportsNonNullableColumns() throws SQLException
1:     { return getDBMD().supportsNonNullableColumns(); }
1:     
1:     public  static  boolean 	supportsOpenCursorsAcrossCommit() throws SQLException
1:     { return getDBMD().supportsOpenCursorsAcrossCommit(); }
1:     
1:     public  static  boolean 	supportsOpenCursorsAcrossRollback() throws SQLException
1:     { return getDBMD().supportsOpenCursorsAcrossRollback(); }
1:     
1:     public  static  boolean 	supportsOpenStatementsAcrossCommit() throws SQLException
1:     { return getDBMD().supportsOpenStatementsAcrossCommit(); }
1:     
1:     public  static  boolean 	supportsOpenStatementsAcrossRollback() throws SQLException
1:     { return getDBMD().supportsOpenStatementsAcrossRollback(); }
1:     
1:     public  static  boolean 	supportsOrderByUnrelated() throws SQLException
1:     { return getDBMD().supportsOrderByUnrelated(); }
1:     
1:     public  static  boolean 	supportsOuterJoins() throws SQLException
1:     { return getDBMD().supportsOuterJoins(); }
1:     
1:     public  static  boolean 	supportsPositionedDelete() throws SQLException
1:     { return getDBMD().supportsPositionedDelete(); }
1:     
1:     public  static  boolean 	supportsPositionedUpdate() throws SQLException
1:     { return getDBMD().supportsPositionedUpdate(); }
1:     
1:     public  static  boolean 	supportsResultSetConcurrency(int type, int concurrency) throws SQLException
1:     { return getDBMD().supportsResultSetConcurrency( type,  concurrency); }
1:     
1:     public  static  boolean 	supportsResultSetHoldability(int holdability) throws SQLException
1:     { return getDBMD().supportsResultSetHoldability( holdability); }
1:     
1:     public  static  boolean 	supportsResultSetType(int type) throws SQLException
1:     { return getDBMD().supportsResultSetType( type); }
1:     
1:     public  static  boolean 	supportsSavepoints() throws SQLException
1:     { return getDBMD().supportsSavepoints(); }
1:     
1:     public  static  boolean 	supportsSchemasInDataManipulation() throws SQLException
1:     { return getDBMD().supportsSchemasInDataManipulation(); }
1:     
1:     public  static  boolean 	supportsSchemasInIndexDefinitions() throws SQLException
1:     { return getDBMD().supportsSchemasInIndexDefinitions(); }
1:     
1:     public  static  boolean 	supportsSchemasInPrivilegeDefinitions() throws SQLException
1:     { return getDBMD().supportsSchemasInPrivilegeDefinitions(); }
1:     
1:     public  static  boolean 	supportsSchemasInProcedureCalls() throws SQLException
1:     { return getDBMD().supportsSchemasInProcedureCalls(); }
1:     
1:     public  static  boolean 	supportsSchemasInTableDefinitions() throws SQLException
1:     { return getDBMD().supportsSchemasInTableDefinitions(); }
1:     
1:     public  static  boolean 	supportsSelectForUpdate() throws SQLException
1:     { return getDBMD().supportsSelectForUpdate(); }
1:     
1:     public  static  boolean 	supportsStatementPooling() throws SQLException
1:     { return getDBMD().supportsStatementPooling(); }
1:     
1:     public  static  boolean 	supportsStoredFunctionsUsingCallSyntax() throws SQLException
1:     { return getDBMD().supportsStoredFunctionsUsingCallSyntax(); }
1:     
1:     public  static  boolean 	supportsStoredProcedures() throws SQLException
1:     { return getDBMD().supportsStoredProcedures(); }
1:     
1:     public  static  boolean 	supportsSubqueriesInComparisons() throws SQLException
1:     { return getDBMD().supportsSubqueriesInComparisons(); }
1:     
1:     public  static  boolean 	supportsSubqueriesInExists() throws SQLException
1:     { return getDBMD().supportsSubqueriesInExists(); }
1:     
1:     public  static  boolean 	supportsSubqueriesInIns() throws SQLException
1:     { return getDBMD().supportsSubqueriesInIns(); }
1:     
1:     public  static  boolean 	supportsSubqueriesInQuantifieds() throws SQLException
1:     { return getDBMD().supportsSubqueriesInQuantifieds(); }
1:     
1:     public  static  boolean 	supportsTableCorrelationNames() throws SQLException
1:     { return getDBMD().supportsTableCorrelationNames(); }
1:     
1:     public  static  boolean 	supportsTransactionIsolationLevel(int level) throws SQLException
1:     { return getDBMD().supportsTransactionIsolationLevel(level); }
1:     
1:     public  static  boolean 	supportsTransactions() throws SQLException
1:     { return getDBMD().supportsTransactions(); }
1:     
1:     public  static  boolean 	supportsUnion() throws SQLException
1:     { return getDBMD().supportsUnion(); }
1:     
1:     public  static  boolean 	supportsUnionAll() throws SQLException
1:     { return getDBMD().supportsUnionAll(); }
1:     
1:     public  static  boolean 	updatesAreDetected(int type) throws SQLException
1:     { return getDBMD().updatesAreDetected(type); }
1:     
1:     public  static  boolean 	usesLocalFilePerTable() throws SQLException
1:     { return getDBMD().usesLocalFilePerTable(); }
1:     
1:     public  static  boolean 	usesLocalFiles() throws SQLException
1:     { return getDBMD().usesLocalFiles(); }
1:     
1:        
1: 
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // REGISTRATION MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** <p>Return true if the requested modifer is set</p> */
1:     private boolean isSet( int allModifiers, int requestedModifier )
1:     {
1:         return ( ( allModifiers & requestedModifier ) != 0 );
1:     }
1: 
1:     /** <p>Drop the function with this method name.</p> */
1:     private void    unregisterFunction( Connection conn, Method method )
1:         throws SQLException
1:     {
1:         // maybe the method doesn't exist. swallow the exception.
1:         try {
1:             executeDDL( conn, "drop function " + method.getName() );
1:         } catch (SQLException se) {}
1:     }
1:     
1:     /** <p>Register the method as a Derby function.</p> */
1:     private void    registerFunction( Connection conn, Method method )
1:         throws SQLException
1:     {
1:         StringBuffer   buffer = new StringBuffer();
1:         String              name = method.getName();
1:         boolean         isTableFunction = isTableFunction( method );
1: 
1:         buffer.append( "create function " + name + "\n(" );
1:         appendArgs( buffer, method );
1:         buffer.append( "\n)\n" );
1:         buffer.append( "returns " );
1:         appendReturnType( buffer, conn, method );
1:         buffer.append( "\nlanguage java\nreads sql data\nparameter style " );
1:         if ( isTableFunction ) { buffer.append( "DERBY_JDBC_RESULT_SET" ); }
1:         else { buffer.append( "java" ); }
1:         buffer.append( "\nexternal name '" + getClass().getName() + "." + name + "'" );
1: 
1:         executeDDL( conn, buffer.toString() );
1:     }
1: 
1:     /** <p>Return true if the method describes a table function.</p> */
1:     private boolean isTableFunction( Method method )
1:     {
1:         Class   returnType = method.getReturnType();
1: 
1:         return ( returnType == java.sql.ResultSet.class );
1:     }
1: 
1:     /** <p>Append function arguments to an evolving ddl text buffer.</p> */
1:     private void    appendArgs( StringBuffer buffer, Method method )
1:         throws SQLException
1:     {
1:         Class[] parameterTypes = method.getParameterTypes();
1:         int         count = parameterTypes.length;
1:         String  paramStub = "a_";
1: 
1:         for ( int pidx = 0; pidx < count; pidx++ )
1:         {
1:             Class paramType = parameterTypes[ pidx ];
1: 
1:             if ( pidx > 0 ) { buffer.append( "," ); }
1:             buffer.append( "\n\t" );
1:             buffer.append( paramStub + pidx );
1:             buffer.append( ' ' );
1:             buffer.append( mapJavaToSQLType( paramType ) );
1:         }
1:     }
1: 
1:     /** <p>Append return type to an evolving ddl text buffer</p> */
1:     private void    appendReturnType( StringBuffer buffer, Connection conn, Method method )
1:         throws SQLException
1:     {
1:         Class   returnType = method.getReturnType();
1: 
1:         if ( java.sql.ResultSet.class == returnType ) { appendTableFunctionSignature( buffer, conn, method ); }
1:         else { buffer.append( mapJavaToSQLType( returnType ) ); }
1:     }
1: 
1:     /** <p>Append the signature of a table function to an evolving ddl text buffer</p> */
1:     private void    appendTableFunctionSignature( StringBuffer buffer, Connection conn, Method method )
1:         throws SQLException
1:     {
1:         buffer.append( "table\n(" );
1: 
1:         Class[]                     parameterTypes = method.getParameterTypes();
1:         int                         argCount = parameterTypes.length;
1:         Object[]                argValues = new Object[ argCount ];
1:         for ( int i = 0; i < argCount; i++ ) { argValues[ i ] = getDummyValue( parameterTypes[ i ] ); }
1:         ResultSet               returnValue;
1: 
1:         try {
1:             returnValue = (ResultSet) method.invoke( null, argValues );
1:         }
1:         catch (IllegalAccessException iae) { throw wrap( iae ); }
1:         catch (InvocationTargetException ite) { throw wrap( ite ); }
1: 
1:         ResultSetMetaData   rsmd = returnValue.getMetaData();
1:         int                         columnCount = rsmd.getColumnCount();
1: 
1:         for ( int i = 0; i < columnCount; i++ )
1:         {
1:             int columnNumber = i + 1;
1:             
1:             if ( i > 0 ) { buffer.append( "," ); }
1:             buffer.append( "\n\t" );
1:             buffer.append( rsmd.getColumnName( columnNumber ) );
1:             buffer.append( "\t" );
1:             stringifyJDBCType(  buffer, rsmd, columnNumber );
1:         }
1:         
1:         buffer.append( "\n)" );
1:     }
1: 
1:     /** <p>Get a dummy value for an argument to a DBMD method.</p> */
1:     private Object  getDummyValue( Class type )
1:     {
1:         if ( String.class == type ) { return ""; }
0:         else if ( Integer.TYPE == type ) { return new Integer( 1 ); }
0:         else if ( Short.TYPE == type ) { return new Short( (short) 1 ); }
1:         else if ( Boolean.TYPE == type ) { return Boolean.TRUE; }
1:         else { return null; }
1:     }
1:     
1:     /** <p>Append the name of a SQL type to an evolving ddl text buffer</p> */
1:     private void    stringifyJDBCType( StringBuffer buffer, ResultSetMetaData rsmd, int columnNumber )
1:         throws SQLException
1:     {
1:         switch ( rsmd.getColumnType( columnNumber ) )
1:         {
1:         case Types.CHAR:
1:         case Types.VARCHAR:
1:             buffer.append( rsmd.getColumnTypeName( columnNumber ) );
1:             buffer.append( "( " );
1:             int precision = rsmd.getPrecision( columnNumber );
1:             if ( precision <= 0 ) { precision = DEFAULT_PRECISION; }
1:             buffer.append( precision );
1:             buffer.append( " )" );
1:             break;
1:         default:
1:             buffer.append( rsmd.getColumnTypeName( columnNumber ) );
1:             break;
1:         }
1:     }
1:     
1:     /**<p>Get the SQL type which corresponds to a Java type.</p> */
1:     private String  mapJavaToSQLType( Class javaType )
1:         throws SQLException
1:     {
1:         if ( Short.TYPE == javaType ) { return "smallint"; }
1:         else if ( Integer.TYPE == javaType ) { return "int"; }
1:         else if ( Boolean.TYPE == javaType ) { return "boolean"; }
1:         else if ( String.class == javaType ) { return "varchar( 32672 )"; }
1:         else { throw new SQLException( "Unsupported type: " + javaType.getName() ); }
1:     }
1: 
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // GENERAL MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get the current session's database metadata.
1:      * </p>
1:      */
1:     private static DatabaseMetaData getDBMD()
1:         throws SQLException
1:     {
1:         return getDefaultConnection().getMetaData();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the default connection, called from inside the database engine.
1:      * </p>
1:      */
1:     private static Connection getDefaultConnection()
1:         throws SQLException
1:     {
1:         return DriverManager.getConnection( "jdbc:default:connection" );
1:     }
1: 
1:     /**<p>Execute a DDL statement.</p> */
1: 	private	static	void	executeDDL( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		PreparedStatement	ps = null;
1: 
1: 		try {
1: 			ps = prepareStatement( conn, text );
1: 
1: 			ps.execute();
1: 		}
1: 		finally { if ( ps != null ) { ps.close(); } }
1: 	}
1: 	
1:     /**
1:      *<p>
1:      * Prepare a statement and print out the text.
1:      * </p>
1:      */
1: 	private	static	PreparedStatement	prepareStatement( Connection conn, String text )
1: 		throws SQLException
1: 	{
1: 		PreparedStatement	ps = conn.prepareStatement( text );
1: 
1: 		return ps;
1: 	}
1: 
1:     /**
1:      * <p>
1:      * Wrap an exception in a SQLException.
1:      * </p>
1:      */
1:     private static  SQLException    wrap( Throwable t )
1:     {
1:         return new SQLException( t.getMessage(), t );
1:     }
1:     
1: }
1: 
============================================================================