1:a1f09e9: /**
1:a1f09e9:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.BigDataTest
1:a1f09e9:  * 
1:a1f09e9:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
1:a1f09e9:  * agreements. See the NOTICE file distributed with this work for additional information
1:a1f09e9:  * regarding copyright ownership. The ASF licenses this file to you under the Apache
1:a1f09e9:  * License, Version 2.0 (the "License"); you may not use this file except in compliance
1:a1f09e9:  * with the License. You may obtain a copy of the License at
1:a1f09e9:  * 
1:a1f09e9:  * http://www.apache.org/licenses/LICENSE-2.0
1:a1f09e9:  * 
1:a1f09e9:  * Unless required by applicable law or agreed to in writing, software distributed under
1:a1f09e9:  * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:a1f09e9:  * KIND, either express or implied. See the License for the specific language governing
1:a1f09e9:  * permissions and limitations under the License.
1:a1f09e9:  */
1:a1f09e9: package org.apache.derbyTesting.functionTests.tests.lang;
3:a1f09e9: 
1:a1f09e9: import java.sql.Clob;
1:a1f09e9: import java.sql.PreparedStatement;
1:a1f09e9: import java.sql.ResultSet;
1:a1f09e9: import java.sql.SQLException;
1:a1f09e9: import java.sql.Statement;
1:a1f09e9: import junit.framework.Test;
1:a1f09e9: import org.apache.derbyTesting.functionTests.util.Formatters;
1:a1f09e9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:a1f09e9: import org.apache.derbyTesting.junit.JDBC;
1:a1f09e9: import org.apache.derbyTesting.junit.TestConfiguration;
1:a1f09e9: 
1:a1f09e9: /**
1:a1f09e9:  * A test case for big.sql.
1:a1f09e9:  */
1:a1f09e9: public class BigDataTest extends BaseJDBCTestCase {
1:a1f09e9:     private static final String BIG_TABLE_NAME = "big";
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Constructor.
1:a1f09e9:      * 
1:a1f09e9:      * @param name
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public BigDataTest(String name) throws SQLException {
1:a1f09e9:         super(name);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Get a String to select all records from the table defined.
1:a1f09e9:      * 
1:a1f09e9:      * @param tableName
1:a1f09e9:      *            The table to fetch records from.
1:a1f09e9:      * @return "select * from " + tableName.
1:a1f09e9:      */
1:a1f09e9:     public static String getSelectSql(String tableName) {
1:a1f09e9:         return "select * from " + tableName;
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Create table by the name defined, and each column of the table has the type of
1:a1f09e9:      * varchar or clob, which is determined by the element in useClob. At the same time,
1:a1f09e9:      * each column is as big as identified by lengths. i.e. to call createTable(conn,
1:a1f09e9:      * "big", {1000, 1000, }, {true, false,}) equals calling the sql sentence "create
1:a1f09e9:      * table big(c1 clob(1000), c2 varchar(1000));"
1:a1f09e9:      * 
1:a1f09e9:      * @param tableName
1:a1f09e9:      * @param lengths
1:a1f09e9:      * @param useClob
1:a1f09e9:      *            for element of useClob, if true, use clob as an element for a column;
1:a1f09e9:      *            false, use varchar as an element for a column.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     private void createTable(String tableName, int[] lengths, boolean[] useClob)
1:a1f09e9:             throws SQLException {
1:a1f09e9:         StringBuffer sqlSb = new StringBuffer();
1:a1f09e9:         sqlSb.append("create table ");
1:a1f09e9:         sqlSb.append(tableName);
1:a1f09e9:         sqlSb.append(" (");
1:a1f09e9:         for (int i = 0; i < lengths.length - 1; i++) {
1:a1f09e9:             sqlSb.append("c" + (i + 1) + (useClob[i] ? " clob(" : " varchar(")
1:a1f09e9:                     + lengths[i] + "),");
1:a1f09e9:         }
1:a1f09e9:         sqlSb.append("c" + lengths.length
1:a1f09e9:                 + (useClob[lengths.length - 1] ? " clob(" : " varchar(")
1:a1f09e9:                 + lengths[lengths.length - 1] + ")");
1:a1f09e9:         sqlSb.append(")");
1:a1f09e9:         String sql = sqlSb.toString();
1:a1f09e9: 
1:a1f09e9:         createTable(sql);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Create a new table with defined sql sentence.
1:a1f09e9:      * 
1:a1f09e9:      * @param sql
1:a1f09e9:      *            a sql sentence a create a table, which should use BIG_TABLE_NAME as new
1:a1f09e9:      *            table's name.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     private void createTable(String sql) throws SQLException {
1:a1f09e9:         Statement ps = createStatement();
1:a1f09e9:         ps.executeUpdate(sql);
1:a1f09e9:         ps.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Generate String array according to String array and int array defined. i.e. calling
1:a1f09e9:      * getStringArray({"a", "b",}, {3, 4}) returns {"aaa", "bbbb",}.
1:a1f09e9:      * 
1:a1f09e9:      * @param sa
1:a1f09e9:      *            the sort string array to use.
1:a1f09e9:      * @param timesArray
1:a1f09e9:      *            stores repeated times of String constructed by elements in sa.
1:a1f09e9:      * @return A String array, whose elements is constructed by elements in sa, and each
1:a1f09e9:      *         element repeated times defined by ia.
1:a1f09e9:      */
1:a1f09e9:     private String[] getStringArray(String[] sa, int[] timesArray) {
1:a1f09e9:         String[] result = new String[sa.length];
1:a1f09e9:         for (int i = 0; i < sa.length; i++) {
1:a1f09e9:             result[i] = new String(Formatters.repeatChar(sa[i], timesArray[i]));
1:a1f09e9:         }
1:a1f09e9: 
1:a1f09e9:         return result;
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Generate String array with two dimensions according to String array and int array
1:a1f09e9:      * defined. i.e. calling getStringArray({"a", "b",}, {3, 4}) returns {"aaa", "bbbb",}.
1:a1f09e9:      * 
1:a1f09e9:      * @param sa
1:a1f09e9:      *            the sort string array to use.
1:a1f09e9:      * @param timesArray
1:a1f09e9:      *            stores repeated times of String constructed by elements in sa.
1:a1f09e9:      * @return A String array with two dimensions, whose elements is constructed by
1:a1f09e9:      *         elements in sa, and each element repeated times defined by ia, for each
1:a1f09e9:      *         row, it has only one column.
1:a1f09e9:      */
1:a1f09e9:     private String[][] getRowsWithOnlyOneColumn(String[] sa, int[] timesArray) {
1:a1f09e9:         String[][] result = new String[sa.length][1];
1:a1f09e9:         for (int i = 0; i < sa.length; i++) {
1:a1f09e9:             result[i][0] = new String(Formatters.repeatChar(sa[i], timesArray[i]));
1:a1f09e9:         }
1:a1f09e9: 
1:a1f09e9:         return result;
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Insert one row into a table named by tableName, with defined table, and String
1:a1f09e9:      * array and int array to construct params.
1:a1f09e9:      * 
1:a1f09e9:      * @param tableName
1:a1f09e9:      *            can not be null.
1:a1f09e9:      * @param sa
1:a1f09e9:      *            the string array to use.
1:a1f09e9:      * @param timesArray
1:a1f09e9:      *            stores repeated times of String constructed by elements in sa.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     private void insertOneRow(String tableName, String[] sa, int[] timesArray)
1:a1f09e9:             throws SQLException {
1:a1f09e9:         String[] params = getStringArray(sa, timesArray);
1:a1f09e9:         insertOneRow(tableName, params);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Insert a row into a table named by tableName, with defined table and params.
1:a1f09e9:      * 
1:a1f09e9:      * @param tableName
1:a1f09e9:      *            can not be null.
1:a1f09e9:      * @param columns
1:a1f09e9:      *            can not be null, and has a length bigger than 0.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      *             if SQLException occurs.
1:a1f09e9:      */
1:a1f09e9:     private void insertOneRow(String tableName, String[] columns) throws SQLException {
1:a1f09e9:         StringBuffer sqlSb = new StringBuffer();
1:a1f09e9:         sqlSb.append("insert into ");
1:a1f09e9:         sqlSb.append(tableName);
1:a1f09e9:         sqlSb.append(" values (");
1:a1f09e9:         for (int i = 0; i < columns.length - 1; i++)
1:a1f09e9:             sqlSb.append("?, ");
1:a1f09e9:         sqlSb.append("?)");
1:a1f09e9:         String sql = sqlSb.toString();
1:a1f09e9: 
1:a1f09e9:         PreparedStatement ps = prepareStatement(sql);
1:a1f09e9:         for (int i = 1; i <= columns.length; i++)
1:a1f09e9:             ps.setString(i, columns[i - 1]);
1:a1f09e9:         ps.executeUpdate();
1:a1f09e9:         ps.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Insert multiple rows into one table.
1:a1f09e9:      * 
1:a1f09e9:      * @param tableName
1:a1f09e9:      *            the table will receive new rows.
1:a1f09e9:      * @param rows
1:a1f09e9:      *            new rows for the table. Each row has only one column.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     private void insertMultipleRows(String tableName, String[][] rows)
1:a1f09e9:             throws SQLException {
1:a1f09e9:         for (int i = 0; i < rows.length; i++) {
1:a1f09e9:             String[] row = rows[i];
1:a1f09e9:             insertOneRow(tableName, row);
1:a1f09e9:         }
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Valid content in defined table.
1:a1f09e9:      * 
1:d127717:      * @param expected
1:a1f09e9:      *            the values expected, it has the same order with the table.
1:a1f09e9:      *            i.e.expected[0] means the expected values for the first row in rs.
1:a1f09e9:      * @param tableName
1:a1f09e9:      *            whose content will be compared.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      *             means invalid.
1:a1f09e9:      */
1:a1f09e9:     private void validTable(String[][] expected, String tableName) throws SQLException {
1:a1f09e9:         String sql = getSelectSql(tableName);
1:a1f09e9:         Statement st = createStatement();
1:a1f09e9:         ResultSet rs = st.executeQuery(sql);
1:a1f09e9:         JDBC.assertFullResultSet(rs, expected);
1:a1f09e9:         st.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Valid the current row record of passed ResultSet.
1:a1f09e9:      * 
2:a1f09e9:      * @param exected
1:a1f09e9:      *            the values expected, it has the same order with the table.
1:a1f09e9:      * @param useClob
1:a1f09e9:      *            for each element of useColb, true means the column is Clob, false means
1:a1f09e9:      *            varchar.
1:a1f09e9:      * @param rs
1:a1f09e9:      *            whose current row will be compared.
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      *             means invalid.
1:a1f09e9:      */
1:a1f09e9:     private void validSingleRow(String[] exected, boolean[] useClob, ResultSet rs)
1:a1f09e9:             throws SQLException {
1:a1f09e9:         for (int i = 0; i < exected.length; i++) {
1:a1f09e9:             String real;
1:a1f09e9:             if (useClob[i]) {
1:a1f09e9:                 Clob c = rs.getClob(i + 1);
1:a1f09e9:                 real = c.getSubString(1, (int) c.length());
1:a1f09e9:             } else {
1:a1f09e9:                 real = rs.getString(i + 1);
1:a1f09e9:             }
1:a1f09e9: 
1:a1f09e9:             assertEquals("Compare column " + (i + 1), exected[i], real);
1:a1f09e9:         }
1:a1f09e9:     }
1:a1f09e9: 
1:b91e25a:     public void tearDown() throws Exception {
1:a1f09e9:         dropTable(BIG_TABLE_NAME);
1:b91e25a:         super.tearDown();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("BigDataTest");
1:a1f09e9:         suite.addTest(TestConfiguration.defaultSuite(BigDataTest.class));
1:a1f09e9:         return suite;
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Mix clob and varchar in the table. The commented part in big.sql has been revived
1:a1f09e9:      * without DRDAProtocolException thrown.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testMixture() throws SQLException {
1:a1f09e9:         int[] ia = { 32672, 32672, 32672, 32672, };
1:a1f09e9:         boolean[] useClob = { true, false, false, true, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, ia, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", "c", "d", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9: 
1:a1f09e9:         String[] row = getStringArray(sa, ia);
1:a1f09e9:         String[][] expected = { row, };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9: 
1:a1f09e9:         expected = new String[][] { row, row, row, };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         String sql1 = getSelectSql(BIG_TABLE_NAME);
1:a1f09e9:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1f09e9:                 ResultSet.CONCUR_READ_ONLY);
1:a1f09e9:         ResultSet rs = st.executeQuery(sql1);
1:a1f09e9:         assertEquals("Before operation, row No. is 0.", 0, rs.getRow());
1:a1f09e9:         rs.first();
1:a1f09e9:         assertEquals("After calling first(), row No. is 1.", 1, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.next();
1:a1f09e9:         assertEquals("After calling next(), row No. is 2.", 2, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.previous();
1:a1f09e9:         assertEquals("After calling previous(), row No. is 1.", 1, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.last();
1:a1f09e9:         assertEquals("After calling last(), row No. is 3.", 3, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.close();
1:a1f09e9: 
1:a1f09e9:         st.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * let's try scrolling.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testScrolling() throws SQLException {
1:a1f09e9:         int[] lens = { 10000, 10000, 10000, 10000, };
1:a1f09e9:         boolean[] useClob = { false, false, false, false, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, lens, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa1 = { "a", "b", "c", "d", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa1, lens);
1:a1f09e9:         String[] sa2 = new String[] { "e", "f", "g", "h", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa2, lens);
1:a1f09e9:         String[] sa3 = new String[] { "i", "j", "k", "l", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa3, lens);
1:a1f09e9:         String[] sa4 = new String[] { "m", "n", "o", "p", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa4, lens);
1:a1f09e9: 
1:a1f09e9:         String[] row1 = getStringArray(sa1, lens);
1:a1f09e9:         String[] row2 = getStringArray(sa2, lens);
1:a1f09e9:         String[] row3 = getStringArray(sa3, lens);
1:a1f09e9:         String[] row4 = getStringArray(sa4, lens);
1:a1f09e9:         String[][] expected = { row1, row2, row3, row4, };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         String sql = getSelectSql(BIG_TABLE_NAME);
1:a1f09e9:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1f09e9:                 ResultSet.CONCUR_READ_ONLY);
1:a1f09e9:         ResultSet rs = st.executeQuery(sql);
1:a1f09e9: 
1:a1f09e9:         rs.first();
1:a1f09e9:         validSingleRow(row1, useClob, rs);
1:a1f09e9:         rs.next();
1:a1f09e9:         validSingleRow(row2, useClob, rs);
1:a1f09e9:         rs.previous();
1:a1f09e9:         validSingleRow(row1, useClob, rs);
1:a1f09e9:         rs.last();
1:a1f09e9:         validSingleRow(row4, useClob, rs);
1:a1f09e9:         rs.close();
1:a1f09e9: 
1:a1f09e9:         rs = st.executeQuery(sql);
1:a1f09e9:         rs.last();
1:a1f09e9:         validSingleRow(row4, useClob, rs);
1:a1f09e9:         rs.close();
1:a1f09e9: 
1:a1f09e9:         st.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:dbed020:      * try a column which is &gt; 32767
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testBigColumn() throws SQLException {
1:a1f09e9:         int[] ia = { 40000, };
1:a1f09e9:         boolean[] useClob = { true, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, ia, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9: 
1:a1f09e9:         String[][] expected = { getStringArray(sa, ia), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:dbed020:      * try several columns &gt; 32767.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testSeveralBigColumns() throws SQLException {
1:a1f09e9:         int[] ia = { 40000, 40000, 40000, };
1:a1f09e9:         boolean[] useClob = { true, true, true, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, ia, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", "c", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9: 
1:a1f09e9:         String[] sa1 = new String[] { "d", "e", "f", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa1, ia);
1:a1f09e9: 
1:a1f09e9:         String[][] expected = { getStringArray(sa, ia), getStringArray(sa1, ia), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * create table with row greater than 32K.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testBigRow() throws SQLException {
1:a1f09e9:         int[] ia = { 10000, 10000, 10000, 10000, };
1:a1f09e9:         boolean[] useClob = { false, false, false, false, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, ia, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", "c", "d", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:a1f09e9: 
1:a1f09e9:         String[][] expected = { getStringArray(sa, ia), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         String[] sa1 = new String[] { "e", "f", "g", "h", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa1, ia);
1:a1f09e9: 
1:a1f09e9:         expected = new String[][] { expected[0], getStringArray(sa1, ia), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * the overhead for DSS on QRYDTA is 15 bytes let's try a row which is exactly 32767
1:a1f09e9:      * (default client query block size).
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testDefaultQueryBlock() throws SQLException {
1:a1f09e9:         int[] lens = { 30000, 2752, };
1:a1f09e9:         boolean[] useClob = { false, false, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, lens, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:a1f09e9: 
1:a1f09e9:         String[][] expected = { getStringArray(sa, lens), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Various tests for JIRA-614: handling of rows which span QRYDTA blocks. What happens
1:a1f09e9:      * when the SplitQRYDTA has to span 3+ blocks.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testSpanQRYDTABlocks() throws SQLException {
1:a1f09e9:         int[] lens = { 32672, 32672, 32672, 32672, };
1:a1f09e9:         boolean[] useClob = { false, false, false, false, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, lens, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", "c", "d", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:a1f09e9: 
1:a1f09e9:         String[] row = getStringArray(sa, lens);
1:a1f09e9:         String[][] expected = { row, };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:a1f09e9: 
1:a1f09e9:         expected = new String[][] { row, row, row, };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9: 
1:a1f09e9:         String sql1 = getSelectSql(BIG_TABLE_NAME);
1:a1f09e9:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1f09e9:                 ResultSet.CONCUR_READ_ONLY);
1:a1f09e9:         ResultSet rs = st.executeQuery(sql1);
1:a1f09e9:         assertEquals("Before operation, row No. is 0.", 0, rs.getRow());
1:a1f09e9:         rs.first();
1:a1f09e9:         assertEquals("After calling first(), row No. is 1.", 1, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.next();
1:a1f09e9:         assertEquals("After calling next(), row No. is 2.", 2, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.previous();
1:a1f09e9:         assertEquals("After calling previous(), row No. is 1.", 1, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.last();
1:a1f09e9:         assertEquals("After calling last(), row No. is 3.", 3, rs.getRow());
1:a1f09e9:         validSingleRow(row, useClob, rs);
1:a1f09e9:         rs.close();
1:a1f09e9:         st.close();
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * What happens when the row + the ending SQLCARD is too big.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testTooBigSQLCARD() throws SQLException {
1:a1f09e9:         int[] lens = { 30000, 2750, };
1:a1f09e9:         boolean[] useClob = { false, false, };
1:a1f09e9:         createTable(BIG_TABLE_NAME, lens, useClob);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "b", };
1:a1f09e9:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:a1f09e9: 
1:a1f09e9:         String[][] expected = { getStringArray(sa, lens), };
1:a1f09e9:         validTable(expected, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Test a table just has only one column typed long varchar. This is a Test case
1:a1f09e9:      * commented in big.sql, but revived partly now. When inserting a big row, a
1:a1f09e9:      * SQLException is thrown with the prompt that 33000 is a invalid length.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testLongVarchar() throws SQLException {
1:a1f09e9:         String sql = "create table " + BIG_TABLE_NAME + "(lvc long varchar )";
1:a1f09e9:         createTable(sql);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "a", "a", "a", "a", };
1:a1f09e9:         int[] timesArray = { 1000, 2000, 3000, 32000, 32700, };
1:a1f09e9:         String[][] rows = getRowsWithOnlyOneColumn(sa, timesArray);
1:a1f09e9: 
1:a1f09e9:         insertMultipleRows(BIG_TABLE_NAME, rows);
1:a1f09e9:         validTable(rows, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: 
1:a1f09e9:     /**
1:a1f09e9:      * Test a table just has only one column typed varchar. This is a Test case commented
1:a1f09e9:      * in big.sql, but revived partly now.
1:a1f09e9:      * 
1:a1f09e9:      * @throws SQLException
1:a1f09e9:      */
1:a1f09e9:     public void testVarchar() throws SQLException {
1:a1f09e9:         String sql = "create table " + BIG_TABLE_NAME + "(vc varchar(32672))";
1:a1f09e9:         createTable(sql);
1:a1f09e9: 
1:a1f09e9:         String[] sa = { "a", "a", "a", "a", "a", };
1:a1f09e9:         int[] timesArray = { 1000, 2000, 3000, 32000, 32672, };
1:a1f09e9:         String[][] rows = getRowsWithOnlyOneColumn(sa, timesArray);
1:a1f09e9: 
1:a1f09e9:         insertMultipleRows(BIG_TABLE_NAME, rows);
1:a1f09e9:         validTable(rows, BIG_TABLE_NAME);
1:a1f09e9:     }
1:a1f09e9: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * try a column which is &gt; 32767
/////////////////////////////////////////////////////////////////////////
1:      * try several columns &gt; 32767.
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("BigDataTest");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:b91e25a
/////////////////////////////////////////////////////////////////////////
1:     public void tearDown() throws Exception {
1:         super.tearDown();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:d127717
/////////////////////////////////////////////////////////////////////////
1:      * @param expected
commit:a1f09e9
/////////////////////////////////////////////////////////////////////////
1: /**
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.BigDataTest
1:  * 
1:  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
1:  * agreements. See the NOTICE file distributed with this work for additional information
1:  * regarding copyright ownership. The ASF licenses this file to you under the Apache
1:  * License, Version 2.0 (the "License"); you may not use this file except in compliance
1:  * with the License. You may obtain a copy of the License at
1:  * 
1:  * http://www.apache.org/licenses/LICENSE-2.0
1:  * 
1:  * Unless required by applicable law or agreed to in writing, software distributed under
1:  * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied. See the License for the specific language governing
1:  * permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Clob;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.Formatters;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * A test case for big.sql.
1:  */
1: public class BigDataTest extends BaseJDBCTestCase {
1:     private static final String BIG_TABLE_NAME = "big";
1: 
1:     /**
1:      * Constructor.
1:      * 
1:      * @param name
1:      * @throws SQLException
1:      */
1:     public BigDataTest(String name) throws SQLException {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Get a String to select all records from the table defined.
1:      * 
1:      * @param tableName
1:      *            The table to fetch records from.
1:      * @return "select * from " + tableName.
1:      */
1:     public static String getSelectSql(String tableName) {
1:         return "select * from " + tableName;
1:     }
1: 
1:     /**
1:      * Create table by the name defined, and each column of the table has the type of
1:      * varchar or clob, which is determined by the element in useClob. At the same time,
1:      * each column is as big as identified by lengths. i.e. to call createTable(conn,
1:      * "big", {1000, 1000, }, {true, false,}) equals calling the sql sentence "create
1:      * table big(c1 clob(1000), c2 varchar(1000));"
1:      * 
1:      * @param tableName
1:      * @param lengths
1:      * @param useClob
1:      *            for element of useClob, if true, use clob as an element for a column;
1:      *            false, use varchar as an element for a column.
1:      * @throws SQLException
1:      */
1:     private void createTable(String tableName, int[] lengths, boolean[] useClob)
1:             throws SQLException {
1:         StringBuffer sqlSb = new StringBuffer();
1:         sqlSb.append("create table ");
1:         sqlSb.append(tableName);
1:         sqlSb.append(" (");
1:         for (int i = 0; i < lengths.length - 1; i++) {
1:             sqlSb.append("c" + (i + 1) + (useClob[i] ? " clob(" : " varchar(")
1:                     + lengths[i] + "),");
1:         }
1:         sqlSb.append("c" + lengths.length
1:                 + (useClob[lengths.length - 1] ? " clob(" : " varchar(")
1:                 + lengths[lengths.length - 1] + ")");
1:         sqlSb.append(")");
1:         String sql = sqlSb.toString();
1: 
1:         createTable(sql);
1:     }
1: 
1:     /**
1:      * Create a new table with defined sql sentence.
1:      * 
1:      * @param sql
1:      *            a sql sentence a create a table, which should use BIG_TABLE_NAME as new
1:      *            table's name.
1:      * @throws SQLException
1:      */
1:     private void createTable(String sql) throws SQLException {
1:         Statement ps = createStatement();
1:         ps.executeUpdate(sql);
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Generate String array according to String array and int array defined. i.e. calling
1:      * getStringArray({"a", "b",}, {3, 4}) returns {"aaa", "bbbb",}.
1:      * 
1:      * @param sa
1:      *            the sort string array to use.
1:      * @param timesArray
1:      *            stores repeated times of String constructed by elements in sa.
1:      * @return A String array, whose elements is constructed by elements in sa, and each
1:      *         element repeated times defined by ia.
1:      */
1:     private String[] getStringArray(String[] sa, int[] timesArray) {
1:         String[] result = new String[sa.length];
1:         for (int i = 0; i < sa.length; i++) {
1:             result[i] = new String(Formatters.repeatChar(sa[i], timesArray[i]));
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * Generate String array with two dimensions according to String array and int array
1:      * defined. i.e. calling getStringArray({"a", "b",}, {3, 4}) returns {"aaa", "bbbb",}.
1:      * 
1:      * @param sa
1:      *            the sort string array to use.
1:      * @param timesArray
1:      *            stores repeated times of String constructed by elements in sa.
1:      * @return A String array with two dimensions, whose elements is constructed by
1:      *         elements in sa, and each element repeated times defined by ia, for each
1:      *         row, it has only one column.
1:      */
1:     private String[][] getRowsWithOnlyOneColumn(String[] sa, int[] timesArray) {
1:         String[][] result = new String[sa.length][1];
1:         for (int i = 0; i < sa.length; i++) {
1:             result[i][0] = new String(Formatters.repeatChar(sa[i], timesArray[i]));
1:         }
1: 
1:         return result;
1:     }
1: 
1:     /**
1:      * Insert one row into a table named by tableName, with defined table, and String
1:      * array and int array to construct params.
1:      * 
1:      * @param tableName
1:      *            can not be null.
1:      * @param sa
1:      *            the string array to use.
1:      * @param timesArray
1:      *            stores repeated times of String constructed by elements in sa.
1:      * @throws SQLException
1:      */
1:     private void insertOneRow(String tableName, String[] sa, int[] timesArray)
1:             throws SQLException {
1:         String[] params = getStringArray(sa, timesArray);
1:         insertOneRow(tableName, params);
1:     }
1: 
1:     /**
1:      * Insert a row into a table named by tableName, with defined table and params.
1:      * 
1:      * @param tableName
1:      *            can not be null.
1:      * @param columns
1:      *            can not be null, and has a length bigger than 0.
1:      * @throws SQLException
1:      *             if SQLException occurs.
1:      */
1:     private void insertOneRow(String tableName, String[] columns) throws SQLException {
1:         StringBuffer sqlSb = new StringBuffer();
1:         sqlSb.append("insert into ");
1:         sqlSb.append(tableName);
1:         sqlSb.append(" values (");
1:         for (int i = 0; i < columns.length - 1; i++)
1:             sqlSb.append("?, ");
1:         sqlSb.append("?)");
1:         String sql = sqlSb.toString();
1: 
1:         PreparedStatement ps = prepareStatement(sql);
1:         for (int i = 1; i <= columns.length; i++)
1:             ps.setString(i, columns[i - 1]);
1:         ps.executeUpdate();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Insert multiple rows into one table.
1:      * 
1:      * @param tableName
1:      *            the table will receive new rows.
1:      * @param rows
1:      *            new rows for the table. Each row has only one column.
1:      * @throws SQLException
1:      */
1:     private void insertMultipleRows(String tableName, String[][] rows)
1:             throws SQLException {
1:         for (int i = 0; i < rows.length; i++) {
1:             String[] row = rows[i];
1:             insertOneRow(tableName, row);
1:         }
1:     }
1: 
1:     /**
1:      * Valid content in defined table.
1:      * 
1:      * @param exected
1:      *            the values expected, it has the same order with the table.
1:      *            i.e.expected[0] means the expected values for the first row in rs.
1:      * @param tableName
1:      *            whose content will be compared.
1:      * @throws SQLException
1:      *             means invalid.
1:      */
1:     private void validTable(String[][] expected, String tableName) throws SQLException {
1:         String sql = getSelectSql(tableName);
1:         Statement st = createStatement();
1:         ResultSet rs = st.executeQuery(sql);
1:         JDBC.assertFullResultSet(rs, expected);
1:         st.close();
1:     }
1: 
1:     /**
1:      * Valid the current row record of passed ResultSet.
1:      * 
1:      * @param exected
1:      *            the values expected, it has the same order with the table.
1:      * @param useClob
1:      *            for each element of useColb, true means the column is Clob, false means
1:      *            varchar.
1:      * @param rs
1:      *            whose current row will be compared.
1:      * @throws SQLException
1:      *             means invalid.
1:      */
1:     private void validSingleRow(String[] exected, boolean[] useClob, ResultSet rs)
1:             throws SQLException {
1:         for (int i = 0; i < exected.length; i++) {
1:             String real;
1:             if (useClob[i]) {
1:                 Clob c = rs.getClob(i + 1);
1:                 real = c.getSubString(1, (int) c.length());
1:             } else {
1:                 real = rs.getString(i + 1);
1:             }
1: 
1:             assertEquals("Compare column " + (i + 1), exected[i], real);
1:         }
1:     }
1: 
0:     public void tearDown() throws SQLException {
1:         dropTable(BIG_TABLE_NAME);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("BigDataTest");
1:         suite.addTest(TestConfiguration.defaultSuite(BigDataTest.class));
1:         return suite;
1:     }
1: 
1:     /**
1:      * Mix clob and varchar in the table. The commented part in big.sql has been revived
1:      * without DRDAProtocolException thrown.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testMixture() throws SQLException {
1:         int[] ia = { 32672, 32672, 32672, 32672, };
1:         boolean[] useClob = { true, false, false, true, };
1:         createTable(BIG_TABLE_NAME, ia, useClob);
1: 
1:         String[] sa = { "a", "b", "c", "d", };
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1: 
1:         String[] row = getStringArray(sa, ia);
1:         String[][] expected = { row, };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1: 
1:         expected = new String[][] { row, row, row, };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         String sql1 = getSelectSql(BIG_TABLE_NAME);
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = st.executeQuery(sql1);
1:         assertEquals("Before operation, row No. is 0.", 0, rs.getRow());
1:         rs.first();
1:         assertEquals("After calling first(), row No. is 1.", 1, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.next();
1:         assertEquals("After calling next(), row No. is 2.", 2, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.previous();
1:         assertEquals("After calling previous(), row No. is 1.", 1, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.last();
1:         assertEquals("After calling last(), row No. is 3.", 3, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.close();
1: 
1:         st.close();
1:     }
1: 
1:     /**
1:      * let's try scrolling.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testScrolling() throws SQLException {
1:         int[] lens = { 10000, 10000, 10000, 10000, };
1:         boolean[] useClob = { false, false, false, false, };
1:         createTable(BIG_TABLE_NAME, lens, useClob);
1: 
1:         String[] sa1 = { "a", "b", "c", "d", };
1:         insertOneRow(BIG_TABLE_NAME, sa1, lens);
1:         String[] sa2 = new String[] { "e", "f", "g", "h", };
1:         insertOneRow(BIG_TABLE_NAME, sa2, lens);
1:         String[] sa3 = new String[] { "i", "j", "k", "l", };
1:         insertOneRow(BIG_TABLE_NAME, sa3, lens);
1:         String[] sa4 = new String[] { "m", "n", "o", "p", };
1:         insertOneRow(BIG_TABLE_NAME, sa4, lens);
1: 
1:         String[] row1 = getStringArray(sa1, lens);
1:         String[] row2 = getStringArray(sa2, lens);
1:         String[] row3 = getStringArray(sa3, lens);
1:         String[] row4 = getStringArray(sa4, lens);
1:         String[][] expected = { row1, row2, row3, row4, };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         String sql = getSelectSql(BIG_TABLE_NAME);
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = st.executeQuery(sql);
1: 
1:         rs.first();
1:         validSingleRow(row1, useClob, rs);
1:         rs.next();
1:         validSingleRow(row2, useClob, rs);
1:         rs.previous();
1:         validSingleRow(row1, useClob, rs);
1:         rs.last();
1:         validSingleRow(row4, useClob, rs);
1:         rs.close();
1: 
1:         rs = st.executeQuery(sql);
1:         rs.last();
1:         validSingleRow(row4, useClob, rs);
1:         rs.close();
1: 
1:         st.close();
1:     }
1: 
1:     /**
0:      * try a column which is > 32767
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testBigColumn() throws SQLException {
1:         int[] ia = { 40000, };
1:         boolean[] useClob = { true, };
1:         createTable(BIG_TABLE_NAME, ia, useClob);
1: 
1:         String[] sa = { "a", };
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1: 
1:         String[][] expected = { getStringArray(sa, ia), };
1:         validTable(expected, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
0:      * try several columns > 32767.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testSeveralBigColumns() throws SQLException {
1:         int[] ia = { 40000, 40000, 40000, };
1:         boolean[] useClob = { true, true, true, };
1:         createTable(BIG_TABLE_NAME, ia, useClob);
1: 
1:         String[] sa = { "a", "b", "c", };
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1: 
1:         String[] sa1 = new String[] { "d", "e", "f", };
1:         insertOneRow(BIG_TABLE_NAME, sa1, ia);
1: 
1:         String[][] expected = { getStringArray(sa, ia), getStringArray(sa1, ia), };
1:         validTable(expected, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
1:      * create table with row greater than 32K.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testBigRow() throws SQLException {
1:         int[] ia = { 10000, 10000, 10000, 10000, };
1:         boolean[] useClob = { false, false, false, false, };
1:         createTable(BIG_TABLE_NAME, ia, useClob);
1: 
1:         String[] sa = { "a", "b", "c", "d", };
1:         insertOneRow(BIG_TABLE_NAME, sa, ia);
1: 
1:         String[][] expected = { getStringArray(sa, ia), };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         String[] sa1 = new String[] { "e", "f", "g", "h", };
1:         insertOneRow(BIG_TABLE_NAME, sa1, ia);
1: 
1:         expected = new String[][] { expected[0], getStringArray(sa1, ia), };
1:         validTable(expected, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
1:      * the overhead for DSS on QRYDTA is 15 bytes let's try a row which is exactly 32767
1:      * (default client query block size).
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDefaultQueryBlock() throws SQLException {
1:         int[] lens = { 30000, 2752, };
1:         boolean[] useClob = { false, false, };
1:         createTable(BIG_TABLE_NAME, lens, useClob);
1: 
1:         String[] sa = { "a", "b", };
1:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1: 
1:         String[][] expected = { getStringArray(sa, lens), };
1:         validTable(expected, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
1:      * Various tests for JIRA-614: handling of rows which span QRYDTA blocks. What happens
1:      * when the SplitQRYDTA has to span 3+ blocks.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testSpanQRYDTABlocks() throws SQLException {
1:         int[] lens = { 32672, 32672, 32672, 32672, };
1:         boolean[] useClob = { false, false, false, false, };
1:         createTable(BIG_TABLE_NAME, lens, useClob);
1: 
1:         String[] sa = { "a", "b", "c", "d", };
1:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1: 
1:         String[] row = getStringArray(sa, lens);
1:         String[][] expected = { row, };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1: 
1:         expected = new String[][] { row, row, row, };
1:         validTable(expected, BIG_TABLE_NAME);
1: 
1:         String sql1 = getSelectSql(BIG_TABLE_NAME);
1:         Statement st = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                 ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = st.executeQuery(sql1);
1:         assertEquals("Before operation, row No. is 0.", 0, rs.getRow());
1:         rs.first();
1:         assertEquals("After calling first(), row No. is 1.", 1, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.next();
1:         assertEquals("After calling next(), row No. is 2.", 2, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.previous();
1:         assertEquals("After calling previous(), row No. is 1.", 1, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.last();
1:         assertEquals("After calling last(), row No. is 3.", 3, rs.getRow());
1:         validSingleRow(row, useClob, rs);
1:         rs.close();
1:         st.close();
1:     }
1: 
1:     /**
1:      * What happens when the row + the ending SQLCARD is too big.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testTooBigSQLCARD() throws SQLException {
1:         int[] lens = { 30000, 2750, };
1:         boolean[] useClob = { false, false, };
1:         createTable(BIG_TABLE_NAME, lens, useClob);
1: 
1:         String[] sa = { "a", "b", };
1:         insertOneRow(BIG_TABLE_NAME, sa, lens);
1: 
1:         String[][] expected = { getStringArray(sa, lens), };
1:         validTable(expected, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
1:      * Test a table just has only one column typed long varchar. This is a Test case
1:      * commented in big.sql, but revived partly now. When inserting a big row, a
1:      * SQLException is thrown with the prompt that 33000 is a invalid length.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testLongVarchar() throws SQLException {
1:         String sql = "create table " + BIG_TABLE_NAME + "(lvc long varchar )";
1:         createTable(sql);
1: 
1:         String[] sa = { "a", "a", "a", "a", "a", };
1:         int[] timesArray = { 1000, 2000, 3000, 32000, 32700, };
1:         String[][] rows = getRowsWithOnlyOneColumn(sa, timesArray);
1: 
1:         insertMultipleRows(BIG_TABLE_NAME, rows);
1:         validTable(rows, BIG_TABLE_NAME);
1:     }
1: 
1:     /**
1:      * Test a table just has only one column typed varchar. This is a Test case commented
1:      * in big.sql, but revived partly now.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testVarchar() throws SQLException {
1:         String sql = "create table " + BIG_TABLE_NAME + "(vc varchar(32672))";
1:         createTable(sql);
1: 
1:         String[] sa = { "a", "a", "a", "a", "a", };
1:         int[] timesArray = { 1000, 2000, 3000, 32000, 32672, };
1:         String[][] rows = getRowsWithOnlyOneColumn(sa, timesArray);
1: 
1:         insertMultipleRows(BIG_TABLE_NAME, rows);
1:         validTable(rows, BIG_TABLE_NAME);
1:     }
1: }
============================================================================