1:eac0369: /*
13:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.MaterializedResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:b31849d: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:b31849d: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:b31849d: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Materialize the underlying ResultSet tree into a temp table on the 1st open.
1:eac0369:  * Return rows from temp table on subsequent scans.
1:eac0369:  */
1:eac0369: 
1:f77f36d: class MaterializedResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet
2:eac0369: {
1:eac0369: 	/*
1:eac0369:     ** Set in constructor and not altered during life of object.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     public NoPutResultSet	source;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	private	ExecRow						materializedRowBuffer;
1:eac0369: 	protected long						materializedCID;
1:eac0369: 	public    boolean					materializedCreated;
1:eac0369: 	private   boolean					fromSource = true;
1:eac0369: 	protected ConglomerateController	materializedCC;
1:eac0369: 	protected ScanController			materializedScan;
1:eac0369: 	private TransactionController		tc;
1:eac0369: 	private   boolean					sourceDrained;
1:eac0369: 
1:eac0369: 	public	  long						createTCTime;
1:eac0369: 	public	  long						fetchTCTime;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a MaterializedResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param source					The NoPutResultSet from which to get rows
1:eac0369: 	 *									to be materialized
1:eac0369: 	 * @param activation				The activation for this execution
1:eac0369: 	 * @param resultSetNumber			The resultSetNumber
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public MaterializedResultSet(NoPutResultSet source,
1:eac0369: 							  Activation activation, int resultSetNumber,
1:eac0369: 							  double optimizerEstimatedRowCount,
1:f77f36d: 							  double optimizerEstimatedCost) throws StandardException
1:eac0369: 	{
1:eac0369: 		super(activation, resultSetNumber, 
1:eac0369: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369: 		this.source = source;
1:eac0369: 
1:eac0369:         // Get the current transaction controller
1:eac0369:         tc = activation.getTransactionController();
1:eac0369: 
1:7008b63:         recordConstructorTime();
2:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// ResultSet interface (leftover from NoPutResultSet)
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the source. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 	    	SanityManager.ASSERT( ! isOpen, "MaterializedResultSet already open");
1:eac0369: 
1:eac0369:         source.openCore();
1:eac0369: 	    isOpen = true;
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * reopen a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	reopenCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean constantEval = true;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT(isOpen, "MaterializedResultSet already open");
1:eac0369: 
1:eac0369: 		// Finish draining the source into the temp table
1:eac0369: 		while (! sourceDrained)
1:eac0369: 		{
1:eac0369: 			getNextRowFromSource();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Results will now come from the temp table
1:eac0369: 		fromSource = false;
1:eac0369: 
1:eac0369: 		// Close the temp table if open
1:eac0369: 		if (materializedScan != null)
1:eac0369: 		{
1:eac0369: 			materializedScan.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Open a scan on the temp conglomerate,
1:eac0369: 		 * if one exists.
1:eac0369: 		 */
1:eac0369: 		if (materializedCID != 0)
1:eac0369: 		{
1:eac0369: 			materializedScan = 
1:eac0369:                 tc.openScan(materializedCID,
1:eac0369:                     false,		// hold
1:eac0369:                     0,          // for update
1:eac0369:                     TransactionController.MODE_TABLE,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE,
1:eac0369:                     (FormatableBitSet) null, // all fields as objects
1:eac0369:                     null,		// start key value
1:eac0369:                     0,			// start operator
1:eac0369:                     null,		// qualifier
1:eac0369:                     null,		// stop key value
1:eac0369:                     0);			// stop operator
1:eac0369: 		
1:eac0369: 			isOpen = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException
1:eac0369: 	{
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:2a4654b: 
1:eac0369: 		ExecRow result = null;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		if (!isOpen)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1:eac0369: 
1:eac0369: 		/* Should we get the next row from the source or the materialized result set? */
1:eac0369: 		if (fromSource)
1:eac0369: 		{
1:eac0369: 			result = getNextRowFromSource();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			result = getNextRowFromTempTable();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (result != null)
1:eac0369: 		{
1:eac0369: 			rowsSeen++;
1:eac0369: 		}
1:eac0369: 
1:4e784bb: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		nextTime += getElapsedMillis(beginTime);
1:eac0369: 
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Get the next row from the source ResultSet tree and insert into the temp table */
1:eac0369: 	private ExecRow getNextRowFromSource() throws StandardException
1:eac0369: 	{
1:eac0369: 		// Nothing to do if source is already drained
1:eac0369: 		if (sourceDrained)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ExecRow		sourceRow = null;
1:eac0369: 		ExecRow		result = null;
1:eac0369: 
1:eac0369: 		sourceRow = source.getNextRowCore();
1:eac0369: 
1:eac0369: 		if (sourceRow != null)
1:eac0369: 		{
1:eac0369: 			long beginTCTime = getCurrentTimeMillis();
1:eac0369: 			/* If this is the first row from the source then clone it as our own
1:eac0369: 			 * for use when fetching from temp table.
1:eac0369: 			 * This is also the place where we create the temp table.
1:eac0369: 			 */
1:eac0369: 			if (materializedRowBuffer == null)
1:eac0369: 			{
1:eac0369: 				materializedRowBuffer = sourceRow.getClone();
1:eac0369: 
1:eac0369: 				tc = activation.getTransactionController();
1:eac0369: 
1:b61f876: 				materializedCID = 
1:b61f876:                     tc.createConglomerate(
1:b61f876:                         "heap",	
1:b61f876:                         materializedRowBuffer.getRowArray(),
1:b61f876:                         null, 
1:b61f876:                         (int[]) null, // TODO-COLLATION, implement collation in materialized result sets if necessary
1:b61f876:                         null, 
1:b61f876:                         (TransactionController.IS_TEMPORARY |
1:b61f876:                          TransactionController.IS_KEPT));
1:eac0369: 
1:eac0369: 				materializedCreated = true;
1:eac0369: 				materializedCC = 
1:eac0369:                     tc.openConglomerate(
1:eac0369:                         materializedCID, 
1:eac0369:                         false,
1:eac0369:                         TransactionController.OPENMODE_FORUPDATE,
1:eac0369:                         TransactionController.MODE_TABLE,
1:eac0369:                         TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369: 			}
1:0c5bc3a:             materializedCC.insert(sourceRow.getRowArray());
1:eac0369: 
1:eac0369: 			createTCTime += getElapsedMillis(beginTCTime);
1:eac0369: 		}
1:eac0369: 		// Remember whether or not we've drained the source
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			sourceDrained = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return sourceRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Get the next Row from the temp table */
1:eac0369: 	private ExecRow getNextRowFromTempTable() throws StandardException
1:eac0369: 	{
1:eac0369: 		long beginTCTime = getCurrentTimeMillis();
1:eac0369: 		/* Get and return the next row from the temp conglomerate,
1:eac0369: 		 * if one exists.
1:eac0369: 		 */
1:d3a4f64: 		if (materializedScan != null && materializedScan.fetchNext(materializedRowBuffer.getRowArray()))
1:eac0369: 		{
1:eac0369: 			fetchTCTime += getElapsedMillis(beginTCTime);
1:eac0369: 			return materializedRowBuffer;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen )
1:eac0369: 	    {
1:eac0369: 			currentRow = null;
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			if (materializedScan != null)
1:eac0369: 				materializedScan.close();
1:eac0369: 			materializedScan = null;
1:eac0369: 
1:eac0369: 			if (materializedCC != null)
1:eac0369: 				materializedCC.close();
1:eac0369: 			materializedCC = null;
1:eac0369: 
1:eac0369: 			if (materializedCreated)
1:eac0369: 				tc.dropConglomerate(materializedCID);
1:eac0369: 
1:eac0369: 			materializedCreated = false;
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of MaterializedResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from its source. We might want
1:eac0369: 	 * to have this take a CursorResultSet in its constructor some day,
1:eac0369: 	 * instead of doing a cast here?
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 *
1:eac0369:  	 * @exception StandardException thrown on failure 
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException 
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
1:eac0369: 		return ( (CursorResultSet)source ).getRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from last getNextRow call.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() 
1:eac0369: 	{
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// class implementation
1:eac0369: 	//
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:             materializedCC.insert(sourceRow.getRowArray());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4e784bb
/////////////////////////////////////////////////////////////////////////
1: 		setCurrentRow(result);
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1:         recordConstructorTime();
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.types.RowLocation;
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class MaterializedResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 							  double optimizerEstimatedCost) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d3a4f64
/////////////////////////////////////////////////////////////////////////
1: 		if (materializedScan != null && materializedScan.fetchNext(materializedRowBuffer.getRowArray()))
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.MaterializedResultSet
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: 
0: import org.apache.derby.iapi.sql.Activation;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1:  * Materialize the underlying ResultSet tree into a temp table on the 1st open.
1:  * Return rows from temp table on subsequent scans.
1:  */
1: 
0: public class MaterializedResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/*
1:     ** Set in constructor and not altered during life of object.
1: 	*/
1: 
1:     public NoPutResultSet	source;
1: 
1: 
1: 
1: 	private	ExecRow						materializedRowBuffer;
1: 	protected long						materializedCID;
1: 	public    boolean					materializedCreated;
1: 	private   boolean					fromSource = true;
1: 	protected ConglomerateController	materializedCC;
1: 	protected ScanController			materializedScan;
1: 	private TransactionController		tc;
1: 	private   boolean					sourceDrained;
1: 
1: 	public	  long						createTCTime;
1: 	public	  long						fetchTCTime;
1: 
1: 
0:     private GeneratedMethod closeCleanup;
1: 
1: 	/**
1: 	 * Constructor for a MaterializedResultSet
1: 	 *
1: 	 * @param source					The NoPutResultSet from which to get rows
1: 	 *									to be materialized
1: 	 * @param activation				The activation for this execution
1: 	 * @param resultSetNumber			The resultSetNumber
1: 	 *
1: 	 * @exception StandardException	on error
1: 	 */
1: 
1: 	public MaterializedResultSet(NoPutResultSet source,
1: 							  Activation activation, int resultSetNumber,
1: 							  double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod c) throws StandardException
1: 	{
1: 		super(activation, resultSetNumber, 
1: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
1: 		this.source = source;
1: 
1:         // Get the current transaction controller
1:         tc = activation.getTransactionController();
1: 
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 
1: 	//
1: 	// ResultSet interface (leftover from NoPutResultSet)
1: 	//
1: 
1: 	/**
1:      * open a scan on the source. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1:      */
1: 	public void	openCore() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 		if (SanityManager.DEBUG)
1: 	    	SanityManager.ASSERT( ! isOpen, "MaterializedResultSet already open");
1: 
1:         source.openCore();
1: 	    isOpen = true;
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1:      * reopen a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	reopenCore() throws StandardException 
1: 	{
1: 		boolean constantEval = true;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT(isOpen, "MaterializedResultSet already open");
1: 
1: 		// Finish draining the source into the temp table
1: 		while (! sourceDrained)
1: 		{
1: 			getNextRowFromSource();
1: 		}
1: 
1: 		// Results will now come from the temp table
1: 		fromSource = false;
1: 
1: 		// Close the temp table if open
1: 		if (materializedScan != null)
1: 		{
1: 			materializedScan.close();
1: 		}
1: 
1: 		/* Open a scan on the temp conglomerate,
1: 		 * if one exists.
1: 		 */
1: 		if (materializedCID != 0)
1: 		{
1: 			materializedScan = 
1:                 tc.openScan(materializedCID,
1:                     false,		// hold
1:                     0,          // for update
1:                     TransactionController.MODE_TABLE,
1:                     TransactionController.ISOLATION_SERIALIZABLE,
1:                     (FormatableBitSet) null, // all fields as objects
1:                     null,		// start key value
1:                     0,			// start operator
1:                     null,		// qualifier
1:                     null,		// stop key value
1:                     0);			// stop operator
1: 		
1: 			isOpen = true;
1: 		}
1: 
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException
1: 	{
1: 		ExecRow result = null;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 		if (!isOpen)
1: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
1: 
1: 		/* Should we get the next row from the source or the materialized result set? */
1: 		if (fromSource)
1: 		{
1: 			result = getNextRowFromSource();
1: 		}
1: 		else
1: 		{
1: 			result = getNextRowFromTempTable();
1: 		}
1: 
1: 		if (result != null)
1: 		{
1: 			rowsSeen++;
1: 		}
1: 
0: 		currentRow = result;
0: 		setCurrentRow(currentRow);
1: 
1: 		nextTime += getElapsedMillis(beginTime);
1: 
1: 		return result;
1: 	}
1: 
1: 	/* Get the next row from the source ResultSet tree and insert into the temp table */
1: 	private ExecRow getNextRowFromSource() throws StandardException
1: 	{
1: 		// Nothing to do if source is already drained
1: 		if (sourceDrained)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		ExecRow		sourceRow = null;
1: 		ExecRow		result = null;
1: 
1: 		sourceRow = source.getNextRowCore();
1: 
1: 		if (sourceRow != null)
1: 		{
1: 			long beginTCTime = getCurrentTimeMillis();
1: 			/* If this is the first row from the source then clone it as our own
1: 			 * for use when fetching from temp table.
1: 			 * This is also the place where we create the temp table.
1: 			 */
1: 			if (materializedRowBuffer == null)
1: 			{
1: 				materializedRowBuffer = sourceRow.getClone();
1: 
1: 				tc = activation.getTransactionController();
1: 
0: 				materializedCID = tc.createConglomerate("heap",	materializedRowBuffer.getRowArray(),
0: 														null, null,
0: 														TransactionController.IS_TEMPORARY |
0: 														TransactionController.IS_KEPT);
1: 				materializedCreated = true;
1: 				materializedCC = 
1:                     tc.openConglomerate(
1:                         materializedCID, 
1:                         false,
1:                         TransactionController.OPENMODE_FORUPDATE,
1:                         TransactionController.MODE_TABLE,
1:                         TransactionController.ISOLATION_SERIALIZABLE);
1: 			}
0: 			materializedCC.insert(sourceRow.getRowArray());
1: 
1: 			createTCTime += getElapsedMillis(beginTCTime);
1: 		}
1: 		// Remember whether or not we've drained the source
1: 		else
1: 		{
1: 			sourceDrained = true;
1: 		}
1: 
1: 		return sourceRow;
1: 	}
1: 
1: 	/* Get the next Row from the temp table */
1: 	private ExecRow getNextRowFromTempTable() throws StandardException
1: 	{
1: 		long beginTCTime = getCurrentTimeMillis();
1: 		/* Get and return the next row from the temp conglomerate,
1: 		 * if one exists.
1: 		 */
0: 		if (materializedScan != null && materializedScan.next())
1: 		{
0: 			materializedScan.fetch(materializedRowBuffer.getRowArray());
1: 			fetchTCTime += getElapsedMillis(beginTCTime);
1: 			return materializedRowBuffer;
1: 		}
1: 		else
1: 		{
1: 			return null;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen )
1: 	    {
0: 			if (closeCleanup != null) 
1: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			} 
1: 			currentRow = null;
1: 	        source.close();
1: 
1: 			if (materializedScan != null)
1: 				materializedScan.close();
1: 			materializedScan = null;
1: 
1: 			if (materializedCC != null)
1: 				materializedCC.close();
1: 			materializedCC = null;
1: 
1: 			if (materializedCreated)
1: 				tc.dropConglomerate(materializedCID);
1: 
1: 			materializedCreated = false;
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of MaterializedResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * Gets information from its source. We might want
1: 	 * to have this take a CursorResultSet in its constructor some day,
1: 	 * instead of doing a cast here?
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 *
1:  	 * @exception StandardException thrown on failure 
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException 
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
1: 		return ( (CursorResultSet)source ).getRowLocation();
1: 	}
1: 
1: 	/**
1: 	 * Gets information from last getNextRow call.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() 
1: 	{
1: 		return currentRow;
1: 	}
1: 
1: 	//
1: 	// class implementation
1: 	//
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: 				materializedCID = 
1:                     tc.createConglomerate(
1:                         "heap",	
1:                         materializedRowBuffer.getRowArray(),
1:                         null, 
1:                         (int[]) null, // TODO-COLLATION, implement collation in materialized result sets if necessary
1:                         null, 
1:                         (TransactionController.IS_TEMPORARY |
1:                          TransactionController.IS_KEPT));
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * Materialize the underlying ResultSet tree into a temp table on the 1st open.
0:  * Return rows from temp table on subsequent scans.
0:  */
0: 
0: public class MaterializedResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/*
0:     ** Set in constructor and not altered during life of object.
0: 	*/
0: 
0:     public NoPutResultSet	source;
0: 
0: 
0: 
0: 	private	ExecRow						materializedRowBuffer;
0: 	protected long						materializedCID;
0: 	public    boolean					materializedCreated;
0: 	private   boolean					fromSource = true;
0: 	protected ConglomerateController	materializedCC;
0: 	protected ScanController			materializedScan;
0: 	private TransactionController		tc;
0: 	private   boolean					sourceDrained;
0: 
0: 	public	  long						createTCTime;
0: 	public	  long						fetchTCTime;
0: 
0: 
0:     private GeneratedMethod closeCleanup;
0: 
0: 	/**
0: 	 * Constructor for a MaterializedResultSet
0: 	 *
0: 	 * @param source					The NoPutResultSet from which to get rows
0: 	 *									to be materialized
0: 	 * @param activation				The activation for this execution
0: 	 * @param resultSetNumber			The resultSetNumber
0: 	 *
0: 	 * @exception StandardException	on error
0: 	 */
0: 
0: 	public MaterializedResultSet(NoPutResultSet source,
0: 							  Activation activation, int resultSetNumber,
0: 							  double optimizerEstimatedRowCount,
0: 							  double optimizerEstimatedCost,
0: 							  GeneratedMethod c) throws StandardException
0: 	{
0: 		super(activation, resultSetNumber, 
0: 			  optimizerEstimatedRowCount, optimizerEstimatedCost);
0: 		this.source = source;
0: 
0:         // Get the current transaction controller
0:         tc = activation.getTransactionController();
0: 
0:         closeCleanup = c;
0: 		constructorTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 
0: 	//
0: 	// ResultSet interface (leftover from NoPutResultSet)
0: 	//
0: 
0: 	/**
0:      * open a scan on the source. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0:      */
0: 	public void	openCore() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 		if (SanityManager.DEBUG)
0: 	    	SanityManager.ASSERT( ! isOpen, "MaterializedResultSet already open");
0: 
0:         source.openCore();
0: 	    isOpen = true;
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * reopen a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	reopenCore() throws StandardException 
0: 	{
0: 		boolean constantEval = true;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT(isOpen, "MaterializedResultSet already open");
0: 
0: 		// Finish draining the source into the temp table
0: 		while (! sourceDrained)
0: 		{
0: 			getNextRowFromSource();
0: 		}
0: 
0: 		// Results will now come from the temp table
0: 		fromSource = false;
0: 
0: 		// Close the temp table if open
0: 		if (materializedScan != null)
0: 		{
0: 			materializedScan.close();
0: 		}
0: 
0: 		/* Open a scan on the temp conglomerate,
0: 		 * if one exists.
0: 		 */
0: 		if (materializedCID != 0)
0: 		{
0: 			materializedScan = 
0:                 tc.openScan(materializedCID,
0:                     false,		// hold
0:                     0,          // for update
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_SERIALIZABLE,
0:                     (FormatableBitSet) null, // all fields as objects
0:                     null,		// start key value
0:                     0,			// start operator
0:                     null,		// qualifier
0:                     null,		// stop key value
0:                     0);			// stop operator
0: 		
0: 			isOpen = true;
0: 		}
0: 
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException
0: 	{
0: 		ExecRow result = null;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 		if (!isOpen)
0: 			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
0: 
0: 		/* Should we get the next row from the source or the materialized result set? */
0: 		if (fromSource)
0: 		{
0: 			result = getNextRowFromSource();
0: 		}
0: 		else
0: 		{
0: 			result = getNextRowFromTempTable();
0: 		}
0: 
0: 		if (result != null)
0: 		{
0: 			rowsSeen++;
0: 		}
0: 
0: 		currentRow = result;
0: 		setCurrentRow(currentRow);
0: 
0: 		nextTime += getElapsedMillis(beginTime);
0: 
0: 		return result;
0: 	}
0: 
0: 	/* Get the next row from the source ResultSet tree and insert into the temp table */
0: 	private ExecRow getNextRowFromSource() throws StandardException
0: 	{
0: 		// Nothing to do if source is already drained
0: 		if (sourceDrained)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		ExecRow		sourceRow = null;
0: 		ExecRow		result = null;
0: 
0: 		sourceRow = source.getNextRowCore();
0: 
0: 		if (sourceRow != null)
0: 		{
0: 			long beginTCTime = getCurrentTimeMillis();
0: 			/* If this is the first row from the source then clone it as our own
0: 			 * for use when fetching from temp table.
0: 			 * This is also the place where we create the temp table.
0: 			 */
0: 			if (materializedRowBuffer == null)
0: 			{
0: 				materializedRowBuffer = sourceRow.getClone();
0: 
0: 				tc = activation.getTransactionController();
0: 
0: 				materializedCID = tc.createConglomerate("heap",	materializedRowBuffer.getRowArray(),
0: 														null, null,
0: 														TransactionController.IS_TEMPORARY |
0: 														TransactionController.IS_KEPT);
0: 				materializedCreated = true;
0: 				materializedCC = 
0:                     tc.openConglomerate(
0:                         materializedCID, 
0:                         false,
0:                         TransactionController.OPENMODE_FORUPDATE,
0:                         TransactionController.MODE_TABLE,
0:                         TransactionController.ISOLATION_SERIALIZABLE);
0: 			}
0: 			materializedCC.insert(sourceRow.getRowArray());
0: 
0: 			createTCTime += getElapsedMillis(beginTCTime);
0: 		}
0: 		// Remember whether or not we've drained the source
0: 		else
0: 		{
0: 			sourceDrained = true;
0: 		}
0: 
0: 		return sourceRow;
0: 	}
0: 
0: 	/* Get the next Row from the temp table */
0: 	private ExecRow getNextRowFromTempTable() throws StandardException
0: 	{
0: 		long beginTCTime = getCurrentTimeMillis();
0: 		/* Get and return the next row from the temp conglomerate,
0: 		 * if one exists.
0: 		 */
0: 		if (materializedScan != null && materializedScan.next())
0: 		{
0: 			materializedScan.fetch(materializedRowBuffer.getRowArray());
0: 			fetchTCTime += getElapsedMillis(beginTCTime);
0: 			return materializedRowBuffer;
0: 		}
0: 		else
0: 		{
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen )
0: 	    {
0: 			if (closeCleanup != null) 
0: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			} 
0: 			currentRow = null;
0: 	        source.close();
0: 
0: 			if (materializedScan != null)
0: 				materializedScan.close();
0: 			materializedScan = null;
0: 
0: 			if (materializedCC != null)
0: 				materializedCC.close();
0: 			materializedCC = null;
0: 
0: 			if (materializedCreated)
0: 				tc.dropConglomerate(materializedCID);
0: 
0: 			materializedCreated = false;
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of MaterializedResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * Gets information from its source. We might want
0: 	 * to have this take a CursorResultSet in its constructor some day,
0: 	 * instead of doing a cast here?
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 *
0:  	 * @exception StandardException thrown on failure 
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException 
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source not CursorResultSet");
0: 		return ( (CursorResultSet)source ).getRowLocation();
0: 	}
0: 
0: 	/**
0: 	 * Gets information from last getNextRow call.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() 
0: 	{
0: 		return currentRow;
0: 	}
0: 
0: 	//
0: 	// class implementation
0: 	//
0: }
============================================================================