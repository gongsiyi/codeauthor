1:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.ij.utilMain
1:985fc85: 
1:11bc2d0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11bc2d0:    contributor license agreements.  See the NOTICE file distributed with
1:11bc2d0:    this work for additional information regarding copyright ownership.
1:11bc2d0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:11bc2d0:    (the "License"); you may not use this file except in compliance with
1:11bc2d0:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
39:fe77ca5: 
6:fe77ca5:  */
1:c06280c: 
1:fe77ca5: package org.apache.derby.impl.tools.ij;
1:fe77ca5:                 
1:fe77ca5: import org.apache.derby.tools.JDBCDisplayUtil;
1:fe77ca5: import org.apache.derby.iapi.tools.i18n.*;
1:fe77ca5: 
1:fe77ca5: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1:fe77ca5: import org.apache.derby.iapi.services.info.ProductGenusNames;
1:fe77ca5: 
1:7b5fc1e: import java.util.List;
1:fe77ca5: import java.util.Stack;
1:fe77ca5: import java.util.Hashtable;
1:fe77ca5: 
1:fe77ca5: import java.io.InputStream;
1:fe77ca5: import java.io.FileInputStream;
1:fe77ca5: import java.io.BufferedInputStream;
1:fe77ca5: import java.io.FileNotFoundException;
1:fe77ca5: import java.io.StringReader;
1:fe77ca5: import java.sql.DriverManager;
1:fe77ca5: import java.sql.Driver;
1:fe77ca5: import java.sql.Connection;
1:fe77ca5: import java.sql.SQLException;
1:fe77ca5: import java.sql.ResultSet;
1:fe77ca5: import java.sql.Statement;
1:fe77ca5: import java.sql.PreparedStatement;
1:fe77ca5: 
7:fe77ca5: /**
1:fe77ca5: 	This class is utilities specific to the two ij Main's.
1:fe77ca5: 	This factoring enables sharing the functionality for
1:fe77ca5: 	single and dual connection ij runs.
1:fe77ca5: 
1:fe77ca5:  */
1:8d64950: public class utilMain {
1:fe77ca5: 
1:a5a98ce: 	private StatementFinder[] commandGrabber;
1:fe77ca5: 	UCode_CharStream charStream;
1:fe77ca5: 	ijTokenManager ijTokMgr;
1:fe77ca5: 	ij ijParser;
1:fe77ca5: 	ConnectionEnv[] connEnv;
1:a5a98ce: 	private int currCE;
1:43e6994: 	private final int		numConnections;
1:fe77ca5: 	private boolean fileInput;
1:fe77ca5: 	private boolean initialFileInput;
1:fe77ca5: 	private boolean mtUse;
1:fe77ca5: 	private boolean firstRun = true;
1:fe77ca5: 	private LocalizedOutput out = null;
1:fe77ca5: 	private Hashtable ignoreErrors;
1:351dad8: 	/**
1:351dad8: 	 * True if to display the error code when
1:351dad8: 	 * displaying a SQLException.
1:351dad8: 	 */
1:351dad8: 	private final boolean showErrorCode;
1:95011a0:     
1:95011a0:     /**
1:95011a0:      * Value of the system property ij.execptionTrace
1:95011a0:      */
1:95011a0:     private final String ijExceptionTrace;
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 		In the goodness of time, this could be an ij property
1:fe77ca5: 	 */
1:fe77ca5: 	public static final int BUFFEREDFILESIZE = 2048;
1:fe77ca5: 
1:fe77ca5: 	/*
1:fe77ca5: 	 * command can be redirected, so we stack up command
1:fe77ca5: 	 * grabbers as needed.
1:fe77ca5: 	 */
1:16d3334: 	Stack<StatementFinder> oldGrabbers = new Stack<StatementFinder>();
1:fe77ca5: 
1:fe77ca5: 	LocalizedResource langUtil = LocalizedResource.getInstance();
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set up the test to run with 'numConnections' connections/users.
8:fe77ca5: 	 *
1:fe77ca5: 	 * @param numConnections	The number of connections/users to test.
1:fe77ca5: 	 */
1:43e6994: 	utilMain(int numConnections, LocalizedOutput out)
1:fe77ca5: 		throws ijFatalException
19:fe77ca5: 	{
1:fe77ca5: 		this(numConnections, out, (Hashtable)null);
1:38520af: 	}
1:fe77ca5: 
1:a39c84c:     /**
1:a39c84c: 	 * Set up the test to run with 'numConnections' connections/users.
1:a39c84c:      * This overload allows the choice of whether the system properties
1:a39c84c:      * will be used or not.
1:a39c84c: 	 *
1:a39c84c: 	 * @param numConnections	The number of connections/users to test.
1:a39c84c: 	 */
1:a39c84c:     utilMain(int numConnections, LocalizedOutput out, boolean loadSystemProperties)
1:a39c84c: 		throws ijFatalException
1:a39c84c: 	{
1:a39c84c: 		this(numConnections, out, (Hashtable)null);
1:a39c84c:         if (loadSystemProperties) {
1:a39c84c:             initFromEnvironment();
1:a39c84c:         }
1:a39c84c: 	}
1:a39c84c: 
1:a5a98ce: 	/**
1:fe77ca5: 	 * Set up the test to run with 'numConnections' connections/users.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param numConnections	The number of connections/users to test.
1:fe77ca5: 	 * @param ignoreErrors		A list of errors to ignore.  If null,
1:fe77ca5: 	 *							all errors are printed out and nothing
1:fe77ca5: 	 *							is fatal.  If non-null, if an error is
1:fe77ca5: 	 *							hit and it is in this list, it is silently	
1:fe77ca5: 	 *							ignore.  Otherwise, an ijFatalException is
1:fe77ca5: 	 *							thrown.  ignoreErrors is used for stress
1:fe77ca5: 	 *							tests.
1:fe77ca5: 	 */
1:5766493: 	public utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors)
1:fe77ca5: 		throws ijFatalException
1:fe77ca5: 	{
1:fe77ca5: 		/* init the parser; give it no input to start with.
1:fe77ca5: 		 * (1 parser for entire test.)
1:fe77ca5: 		 */
1:fe77ca5: 		charStream = new UCode_CharStream(
1:fe77ca5: 						new StringReader(" "), 1, 1);
1:fe77ca5: 		ijTokMgr = new ijTokenManager(charStream);
1:b1153d5: 		ijParser = new ij(ijTokMgr, this);
1:a5a98ce: 		this.out = out;
1:0d74a93: 		if ( ignoreErrors != null ) { this.ignoreErrors = (Hashtable) ignoreErrors.clone(); }
1:351dad8: 		
1:351dad8: 		showErrorCode = 
1:351dad8: 			Boolean.valueOf(
1:351dad8: 					util.getSystemProperty("ij.showErrorCode")
1:351dad8: 					).booleanValue();
1:95011a0:         
1:95011a0:         ijExceptionTrace = util.getSystemProperty("ij.exceptionTrace");
1:fe77ca5: 
1:fe77ca5: 		this.numConnections = numConnections;
1:fe77ca5: 		/* 1 StatementFinder and ConnectionEnv per connection/user. */
1:fe77ca5: 		commandGrabber = new StatementFinder[numConnections];
1:fe77ca5: 		connEnv = new ConnectionEnv[numConnections];
1:fe77ca5: 
1:fe77ca5: 		for (int ictr = 0; ictr < numConnections; ictr++)
1:fe77ca5: 		{
1:c0c3716: 		    commandGrabber[ictr] = new StatementFinder(langUtil.getNewInput(System.in), out);
1:fe77ca5: 			connEnv[ictr] = new ConnectionEnv(ictr, (numConnections > 1), (numConnections == 1));
1:43e6994: 		}
1:43e6994: 
1:43e6994: 		/* Start with connection/user 0 */
1:43e6994: 		currCE = 0;
1:43e6994: 		fileInput = false;
1:43e6994: 		initialFileInput = false;
1:43e6994: 		firstRun = true;
1:43e6994: 	}
1:43e6994: 	
1:43e6994: 	/**
1:43e6994: 	 * Initialize the connections from the environment.
1:43e6994: 	 *
1:43e6994: 	 */
1:351dad8: 	public void initFromEnvironment()
1:43e6994: 	{
1:351dad8: 		ijParser.initFromEnvironment();
1:351dad8: 		
1:43e6994: 		for (int ictr = 0; ictr < numConnections; ictr++)
1:43e6994: 		{
11:fe77ca5: 			try {
1:fe77ca5: 				connEnv[ictr].init(out);
1:fe77ca5: 			} catch (SQLException s) {
1:fe77ca5: 				JDBCDisplayUtil.ShowException(out, s); // will continue past connect failure
1:fe77ca5: 			} catch (ClassNotFoundException c) {
1:fe77ca5: 				JDBCDisplayUtil.ShowException(out, c); // will continue past driver failure
1:fe77ca5: 			} catch (InstantiationException i) {
1:fe77ca5: 				JDBCDisplayUtil.ShowException(out, i); // will continue past driver failure
1:fe77ca5: 			} catch (IllegalAccessException ia) {
1:fe77ca5: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
1:4469400: 			} catch (NoSuchMethodException ia) {
1:4469400: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
1:4469400: 			} catch (java.lang.reflect.InvocationTargetException ia) {
1:4469400: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
1:59f29e4:             } catch (ijException ie) {
1:59f29e4:                 JDBCDisplayUtil.ShowException(out, ie); // will continue past driver failure
1:59f29e4:             }
1:c06280c: 		}
35:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * run ij over the specified input, sending output to the
1:fe77ca5: 	 * specified output. Any prior input and output will be lost.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param in source for input to ij
1:fe77ca5: 	 * @param out sink for output from ij
1:fe77ca5: 	 */
1:1b0debd: 	public void go(LocalizedInput[] in, LocalizedOutput out)
1:1b0debd: 				   throws ijFatalException
1:fe77ca5: 	{
1:fe77ca5: 		this.out = out;
1:fe77ca5: 		
1:fe77ca5: 		ijParser.setConnection(connEnv[currCE], (numConnections > 1));
1:fe77ca5: 		fileInput = initialFileInput = (!in[currCE].isStandardInput());
1:fe77ca5: 
1:fe77ca5: 		for (int ictr = 0; ictr < commandGrabber.length; ictr++) {
1:fe77ca5: 			commandGrabber[ictr].ReInit(in[ictr]);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (firstRun) {
1:fe77ca5: 
1:fe77ca5: 			// figure out which version this is
1:8d64950:             InputStream versionStream = util.getResourceAsStream(
1:8d64950:                     ProductGenusNames.TOOLS_INFO);
1:fe77ca5: 
1:fe77ca5: 			// figure out which version this is
1:fe77ca5: 			ProductVersionHolder ijVersion = 
1:fe77ca5: 				ProductVersionHolder.getProductVersionHolderFromMyEnv(versionStream);
1:fe77ca5: 
1:fe77ca5: 			String version;
1:fe77ca5: 			if (ijVersion != null)
1:fe77ca5: 			{
1:fe77ca5: 				version = "" + ijVersion.getMajorVersion() + "." +
1:fe77ca5: 					ijVersion.getMinorVersion();
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				version = "?";
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5:    			out.println(langUtil.getTextMessage("IJ_IjVers30C199", version));
1:fe77ca5: 			for (int i=connEnv.length-1;i>=0;i--) { // print out any initial warnings...
1:fe77ca5: 				Connection c = connEnv[i].getConnection();
1:fe77ca5: 				if (c!=null) {
1:fe77ca5: 					JDBCDisplayUtil.ShowWarnings(out,c);
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 			firstRun = false;
1:fe77ca5: 
1:400ea2e: 			supportIJProperties(connEnv[currCE]);
1:fe77ca5:     	}
1:fe77ca5: 		this.out = out;
2:a5a98ce: 		runScriptGuts();
1:a5a98ce: 		cleanupGo(in);
1:a5a98ce: 	}
1:a5a98ce: 	
1:a5a98ce: 	/**
1:a5a98ce: 	 * Support to run a script. Performs minimal setup
1:a5a98ce: 	 * to set the passed in connection into the existing
1:a5a98ce: 	 * ij setup, ConnectionEnv.
1:a5a98ce: 	 * @param conn
1:a5a98ce: 	 * @param in
1:a5a98ce: 	 */
1:351dad8: 	public int goScript(Connection conn,
1:a5a98ce: 			LocalizedInput in)
1:a5a98ce: 	{
1:400ea2e: 	    connEnv[0].addSession(conn, (String) null);
1:400ea2e:         ijParser.setConnection(connEnv[0], (numConnections > 1));
1:400ea2e: 	    supportIJProperties(connEnv[0]);   
1:400ea2e: 	    		
1:a5a98ce: 		fileInput = initialFileInput = !in.isStandardInput();
1:a5a98ce: 		commandGrabber[0].ReInit(in);
1:351dad8: 		return runScriptGuts();
1:a5a98ce: 	}
1:a5a98ce: 	
1:400ea2e: 	private void supportIJProperties(ConnectionEnv env) {
1:400ea2e: 	  //check if the property is set to not show select count and set the static variable
1:400ea2e:         //accordingly. 
1:400ea2e:         boolean showNoCountForSelect = Boolean.valueOf(util.getSystemProperty("ij.showNoCountForSelect")).booleanValue();
1:80d6162:         JDBCDisplayUtil.setShowSelectCount( !showNoCountForSelect );
1:400ea2e: 
1:400ea2e:         //check if the property is set to not show initial connections and accordingly set the
1:400ea2e:         //static variable.
1:400ea2e:         boolean showNoConnectionsAtStart = Boolean.valueOf(util.getSystemProperty("ij.showNoConnectionsAtStart")).booleanValue();
1:400ea2e: 
1:400ea2e:         if (!(showNoConnectionsAtStart)) {
1:400ea2e:             try {
1:400ea2e:                 ijResult result = ijParser.showConnectionsMethod(true);
1:400ea2e:                 displayResult(out,result,env.getConnection());
1:400ea2e:             } catch (SQLException ex) {
1:400ea2e:                 handleSQLException(out,ex);
1:400ea2e:             }
1:400ea2e:         }        
1:400ea2e:     }
1:400ea2e: 
1:400ea2e:     /**
1:a5a98ce: 	 * Run the guts of the script. Split out to allow
1:a5a98ce: 	 * calling from the full ij and the minimal goScript.
1:351dad8:      * @return The number of errors seen in the script.
1:a5a98ce: 	 *
1:a5a98ce: 	 */
1:351dad8: 	private int runScriptGuts() {
1:38520af: 
1:351dad8:         int scriptErrorCount = 0;
1:a5a98ce: 		
1:a5a98ce: 		boolean done = false;
1:a5a98ce: 		String command = null;
1:fe77ca5: 		while (!ijParser.exit && !done) {
1:fe77ca5: 			try{
1:fe77ca5: 				ijParser.setConnection(connEnv[currCE], (numConnections > 1));
1:fe77ca5: 			} catch(Throwable t){
1:fe77ca5: 				//do nothing
1:38520af: 				}
1:fe77ca5: 
1:fe77ca5: 			connEnv[currCE].doPrompt(true, out);
1:fe77ca5:    			try {
1:a5a98ce:    				command = null;
1:fe77ca5: 				out.flush();
1:fe77ca5: 				command = commandGrabber[currCE].nextStatement();
1:fe77ca5: 
1:fe77ca5: 				// if there is no next statement,
1:fe77ca5: 				// pop back to the top saved grabber.
1:fe77ca5: 				while (command == null && ! oldGrabbers.empty()) {
1:fe77ca5: 					// close the old input file if not System.in
1:fe77ca5: 					if (fileInput) commandGrabber[currCE].close();
1:16d3334: 					commandGrabber[currCE] = oldGrabbers.pop();
1:fe77ca5: 					if (oldGrabbers.empty())
1:fe77ca5: 						fileInput = initialFileInput;
1:fe77ca5: 					command = commandGrabber[currCE].nextStatement();
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5: 				// if there are no grabbers left,
1:fe77ca5: 				// we are done.
1:fe77ca5: 				if (command == null && oldGrabbers.empty()) {
1:fe77ca5: 					done = true;
1:fe77ca5: 				}
1:fe77ca5: 				else {
1:fe77ca5: 					boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
1:fe77ca5: 					long	beginTime = 0;
1:fe77ca5: 					long	endTime;
1:fe77ca5: 
1:fe77ca5: 					if (fileInput) {
1:fe77ca5: 						out.println(command+";");
1:fe77ca5: 						out.flush();
1:fe77ca5: 					}
1:fe77ca5: 
1:fe77ca5: 					charStream.ReInit(new StringReader(command), 1, 1);
1:fe77ca5: 					ijTokMgr.ReInit(charStream);
1:fe77ca5: 					ijParser.ReInit(ijTokMgr);
1:fe77ca5: 
1:fe77ca5: 					if (elapsedTimeOn) {
1:fe77ca5: 						beginTime = System.currentTimeMillis();
1:fe77ca5: 					}
1:fe77ca5: 
1:fe77ca5: 					ijResult result = ijParser.ijStatement();
2:fe77ca5: 					displayResult(out,result,connEnv[currCE].getConnection());
1:fe77ca5: 
1:fe77ca5: 					// if something went wrong, an SQLException or ijException was thrown.
1:fe77ca5: 					// we can keep going to the next statement on those (see catches below).
1:fe77ca5: 					// ijParseException means we try the SQL parser.
1:fe77ca5: 
1:fe77ca5: 					/* Print the elapsed time if appropriate */
1:fe77ca5: 					if (elapsedTimeOn) {
1:fe77ca5: 						endTime = System.currentTimeMillis();
1:fe77ca5: 						out.println(langUtil.getTextMessage("IJ_ElapTime0Mil", 
1:fe77ca5: 						langUtil.getNumberAsString(endTime - beginTime)));
1:fe77ca5: 					}
1:fe77ca5: 
1:fe77ca5: 					// would like when it completes a statement
1:fe77ca5: 					// to see if there is stuff after the ;
1:fe77ca5: 					// and before the <EOL> that we will IGNORE
1:fe77ca5: 					// (with a warning to that effect)
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5:     			} catch (ParseException e) {
1:95011a0:  					if (command != null)
1:95011a0:                         scriptErrorCount += doCatch(command) ? 0 : 1;
1:fe77ca5: 				} catch (TokenMgrError e) {
1:95011a0:  					if (command != null)
1:95011a0:                         scriptErrorCount += doCatch(command) ? 0 : 1;
1:fe77ca5:     			} catch (SQLException e) {
3:351dad8:                     scriptErrorCount++;
1:fe77ca5: 					// SQL exception occurred in ij's actions; print and continue
1:fe77ca5: 					// unless it is considered fatal.
1:fe77ca5: 					handleSQLException(out,e);
1:fe77ca5:     			} catch (ijException e) {
1:351dad8:                     scriptErrorCount++;
1:fe77ca5: 					// exception occurred in ij's actions; print and continue
1:fe77ca5:     			  	out.println(langUtil.getTextMessage("IJ_IjErro0",e.getMessage()));
1:fe77ca5: 					doTrace(e);
1:fe77ca5:     			} catch (Throwable e) {
1:351dad8:                     scriptErrorCount++;
1:fe77ca5:     			  	out.println(langUtil.getTextMessage("IJ_JavaErro0",e.toString()));
1:fe77ca5: 					doTrace(e);
1:fe77ca5: 				}
1:fe77ca5: 
1:fe77ca5: 			/* Go to the next connection/user, if there is one */
1:fe77ca5: 			currCE = ++currCE % connEnv.length;
1:a5a98ce: 		}
1:351dad8:         
1:351dad8:         return scriptErrorCount;
1:fe77ca5: 	}
1:a5a98ce: 	
1:a5a98ce: 	/**
1:a5a98ce: 	 * Perform cleanup after a script has been run.
1:a5a98ce: 	 * Close the input streams if required and shutdown
1:a5a98ce: 	 * derby on an exit.
1:a5a98ce: 	 * @param in
1:a5a98ce: 	 */
1:a5a98ce: 	private void cleanupGo(LocalizedInput[] in) {
1:fe77ca5: 
1:fe77ca5: 		// we need to close all sessions when done; otherwise we have
1:fe77ca5: 		// a problem when a single VM runs successive IJ threads
1:fe77ca5: 		try {
1:fe77ca5: 			for (int i = 0; i < connEnv.length; i++) {
1:fe77ca5: 				connEnv[i].removeAllSessions();
1:fe77ca5: 			}
1:fe77ca5: 		} catch (SQLException se ) {
1:fe77ca5: 			handleSQLException(out,se);
1:fe77ca5: 		}
1:fe77ca5: 		// similarly must close input files
1:fe77ca5: 		for (int i = 0; i < numConnections; i++) {
1:fe77ca5: 			try {
1:a5a98ce: 				in[i].close();	
1:fe77ca5: 			} catch (Exception e ) {
1:fe77ca5:     			  	out.println(langUtil.getTextMessage("IJ_CannotCloseInFile",
1:fe77ca5: 					e.toString()));
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/*
1:fe77ca5: 			If an exit was requested, then we will be shutting down.
1:fe77ca5: 		 */
1:fe77ca5: 		if (ijParser.exit || (initialFileInput && !mtUse)) {
1:fe77ca5: 			Driver d = null;
1:fe77ca5: 			try {
1:fe77ca5: 			    d = DriverManager.getDriver("jdbc:derby:");
1:6daf45b: 			} catch (Throwable e) {
1:fe77ca5: 				d = null;
1:fe77ca5: 			}
1:fe77ca5: 			if (d!=null) { // do we have a driver running? shutdown on exit.
1:fe77ca5: 				try {
1:fe77ca5: 					DriverManager.getConnection("jdbc:derby:;shutdown=true");
1:fe77ca5: 				} catch (SQLException e) {
1:fe77ca5: 					// ignore the errors, they are expected.
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5:   	}
1:fe77ca5: 
1:fe77ca5: 	private void displayResult(LocalizedOutput out, ijResult result, Connection conn) throws SQLException {
1:fe77ca5: 		// display the result, if appropriate.
1:fe77ca5: 		if (result!=null) {
1:fe77ca5: 			if (result.isConnection()) {
1:fe77ca5: 				if (result.hasWarnings()) {
1:fe77ca5: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1:fe77ca5: 					result.clearSQLWarnings();
1:fe77ca5: 				}
1:fe77ca5: 			} else if (result.isStatement()) {
1:fe77ca5: 				Statement s = result.getStatement();
1:fe77ca5: 				try {
1:fe77ca5: 				    JDBCDisplayUtil.DisplayResults(out,s,connEnv[currCE].getConnection());
1:fe77ca5: 				} catch (SQLException se) {
1:fe77ca5: 				    result.closeStatement();
1:c06280c: 					throw se;
1:c06280c: 				}
1:fe77ca5: 				result.closeStatement();
1:fe77ca5: 			} else if (result.isNextRowOfResultSet()) {
1:fe77ca5: 				ResultSet r = result.getNextRowOfResultSet();
1:fe77ca5: 				JDBCDisplayUtil.DisplayCurrentRow(out,r,connEnv[currCE].getConnection());
1:fe77ca5: 			} else if (result.isVector()) {
1:fe77ca5: 				util.DisplayVector(out,result.getVector());
1:fe77ca5: 				if (result.hasWarnings()) {
1:fe77ca5: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1:fe77ca5: 					result.clearSQLWarnings();
1:c06280c: 				}
1:fe77ca5: 			} else if (result.isMulti()) {
1:fe77ca5: 			    try {
1:fe77ca5: 				    util.DisplayMulti(out,(PreparedStatement)result.getStatement(),result.getResultSet(),connEnv[currCE].getConnection());
1:fe77ca5: 				} catch (SQLException se) {
1:fe77ca5: 				    result.closeStatement();
2:fe77ca5: 					throw se;
1:fe77ca5: 				}
1:fe77ca5: 				result.closeStatement(); // done with the statement now
1:fe77ca5: 				if (result.hasWarnings()) {
1:fe77ca5: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1:fe77ca5: 					result.clearSQLWarnings();
1:fe77ca5: 				}
1:a9217e9: 			} else if (result.isResultSet()) {
1:a9217e9: 				ResultSet rs = result.getResultSet();
1:a9217e9: 				try {
1:a9217e9: 					JDBCDisplayUtil.DisplayResults(out,rs,connEnv[currCE].getConnection(), result.getColumnDisplayList(), result.getColumnWidthList());
1:a9217e9: 				} catch (SQLException se) {
1:a9217e9: 					result.closeStatement();
1:a9217e9: 					throw se;
1:a9217e9: 				}
1:a9217e9: 				result.closeStatement();
1:7b5fc1e:             } else if (result.isMultipleResultSetResult()) {
1:16d3334:               List<ResultSet> resultSets = result.getMultipleResultSets();
1:7b5fc1e:               try {
1:7b5fc1e:                 JDBCDisplayUtil.DisplayMultipleResults(out,resultSets,
1:7b5fc1e:                                      connEnv[currCE].getConnection(),
1:7b5fc1e:                                      result.getColumnDisplayList(),
1:7b5fc1e:                                      result.getColumnWidthList());
1:7b5fc1e:               } catch (SQLException se) {
1:7b5fc1e:                 result.closeStatement();
1:7b5fc1e:                 throw se;
1:7b5fc1e:               }
1:fe77ca5: 			} else if (result.isException()) {
1:fe77ca5: 				JDBCDisplayUtil.ShowException(out,result.getException());
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * catch processing on failed commands. This really ought to
1:fe77ca5: 	 * be in ij somehow, but it was easier to catch in Main.
1:fe77ca5: 	 */
1:95011a0: 	private boolean doCatch(String command) {
1:fe77ca5: 		// this retries the failed statement
1:fe77ca5: 		// as a JSQL statement; it uses the
1:fe77ca5: 		// ijParser since that maintains our
1:fe77ca5: 		// connection and state.
1:95011a0: 
1:fe77ca5:         
1:fe77ca5: 	    try {
1:fe77ca5: 			boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
1:fe77ca5: 			long	beginTime = 0;
1:fe77ca5: 			long	endTime;
1:fe77ca5: 
1:fe77ca5: 			if (elapsedTimeOn) {
1:fe77ca5: 				beginTime = System.currentTimeMillis();
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			ijResult result = ijParser.executeImmediate(command);
1:fe77ca5: 			displayResult(out,result,connEnv[currCE].getConnection());
1:fe77ca5: 
1:fe77ca5: 			/* Print the elapsed time if appropriate */
1:fe77ca5: 			if (elapsedTimeOn) {
1:fe77ca5: 				endTime = System.currentTimeMillis();
1:fe77ca5: 				out.println(langUtil.getTextMessage("IJ_ElapTime0Mil_4", 
1:fe77ca5: 				langUtil.getNumberAsString(endTime - beginTime)));
1:fe77ca5: 			}
1:95011a0:             return true;
1:fe77ca5: 
1:fe77ca5: 	    } catch (SQLException e) {
1:fe77ca5: 			// SQL exception occurred in ij's actions; print and continue
1:fe77ca5: 			// unless it is considered fatal.
1:fe77ca5: 			handleSQLException(out,e);
1:fe77ca5: 	    } catch (ijException i) {
1:fe77ca5: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_5", i.getMessage()));
1:fe77ca5: 			doTrace(i);
1:fe77ca5: 		} catch (ijTokenException ie) {
1:fe77ca5: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_6", ie.getMessage()));
1:fe77ca5: 			doTrace(ie);
1:fe77ca5: 	    } catch (Throwable t) {
1:fe77ca5: 	  		out.println(langUtil.getTextMessage("IJ_JavaErro0_7", t.toString()));
1:fe77ca5: 			doTrace(t);
1:fe77ca5: 	    }
1:95011a0:         return false;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * This routine displays SQL exceptions and decides whether they
1:fe77ca5: 	 * are fatal or not, based on the ignoreErrors field. If they
1:fe77ca5: 	 * are fatal, an ijFatalException is thrown.
1:fe77ca5: 	 * Lifted from ij/util.java:ShowSQLException
1:fe77ca5: 	 */
1:b1153d5: 	private void handleSQLException(LocalizedOutput out, SQLException e) 
1:fe77ca5: 		throws ijFatalException
1:fe77ca5: 	{
1:fe77ca5: 		String errorCode;
1:fe77ca5: 		String sqlState = null;
1:fe77ca5: 		SQLException fatalException = null;
1:fe77ca5: 
1:351dad8: 		if (showErrorCode) {
1:fe77ca5: 			errorCode = langUtil.getTextMessage("IJ_Erro0", 
1:fe77ca5: 			langUtil.getNumberAsString(e.getErrorCode()));
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			errorCode = "";
1:fe77ca5: 		}
1:fe77ca5: 
1:1f22952: 		boolean syntaxErrorOccurred = false;
1:fe77ca5: 		for (; e!=null; e=e.getNextException())
1:fe77ca5: 		{
1:1f22952: 			sqlState = e.getSQLState();
1:1f22952: 			if ("42X01".equals(sqlState))
1:1f22952: 				syntaxErrorOccurred = true;
1:fe77ca5: 			/*
1:fe77ca5: 			** If we are to throw errors, then throw the exceptions
1:fe77ca5: 			** that aren't in the ignoreErrors list.  If
1:fe77ca5: 			** the ignoreErrors list is null we don't throw
1:fe77ca5: 			** any errors.
1:fe77ca5: 			*/
1:fe77ca5: 		 	if (ignoreErrors != null) 
1:fe77ca5: 			{
1:fe77ca5: 				if ((sqlState != null) &&
1:fe77ca5: 					(ignoreErrors.get(sqlState) != null))
1:fe77ca5: 				{
1:fe77ca5: 					continue;
1:fe77ca5: 				}
1:fe77ca5: 				else
1:fe77ca5: 				{
1:fe77ca5: 					fatalException = e;
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			String st1 = JDBCDisplayUtil.mapNull(e.getSQLState(),langUtil.getTextMessage("IJ_NoSqls"));
1:fe77ca5: 			String st2 = JDBCDisplayUtil.mapNull(e.getMessage(),langUtil.getTextMessage("IJ_NoMess"));
1:fe77ca5: 			out.println(langUtil.getTextMessage("IJ_Erro012",  st1, st2, errorCode));
1:95011a0: 			doTrace(e);
1:fe77ca5: 		}
1:fe77ca5: 		if (fatalException != null)
1:fe77ca5: 		{
1:fe77ca5: 			throw new ijFatalException(fatalException);
1:fe77ca5: 		}
1:1f22952: 		if (syntaxErrorOccurred)
1:1f22952: 			out.println(langUtil.getTextMessage("IJ_SuggestHelp"));
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * stack trace dumper
1:fe77ca5: 	 */
1:fe77ca5: 	private void doTrace(Throwable t) {
1:95011a0: 		if (ijExceptionTrace != null) {
1:fe77ca5: 			t.printStackTrace(out);
1:fe77ca5: 		}
1:fe77ca5: 		out.flush();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	void newInput(String fileName) {
1:fe77ca5: 		FileInputStream newFile = null;
1:fe77ca5: 		try {
1:fe77ca5: 			newFile = new FileInputStream(fileName);
1:fe77ca5:       	} catch (FileNotFoundException e) {
1:fe77ca5:         	throw ijException.fileNotFound();
1:fe77ca5: 		}
1:fe77ca5: 		if (newFile == null) return;
1:fe77ca5: 
1:fe77ca5: 		// if the file was opened, move to use it for input.
1:fe77ca5: 		oldGrabbers.push(commandGrabber[currCE]);
1:fe77ca5: 	    commandGrabber[currCE] = 
1:c0c3716:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(newFile, BUFFEREDFILESIZE)), null);
1:fe77ca5: 		fileInput = true;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	void newResourceInput(String resourceName) {
1:fe77ca5: 		InputStream is = util.getResourceAsStream(resourceName);
1:fe77ca5: 		if (is==null) throw ijException.resourceNotFound();
1:fe77ca5: 		oldGrabbers.push(commandGrabber[currCE]);
1:fe77ca5: 	    commandGrabber[currCE] = 
1:c0c3716:                 new StatementFinder(langUtil.getNewEncodedInput(new BufferedInputStream(is, BUFFEREDFILESIZE), "UTF8"), null);
1:fe77ca5: 		fileInput = true;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * REMIND: eventually this might be part of StatementFinder,
1:fe77ca5: 	 * used at each carriage return to show that it is still "live"
1:fe77ca5: 	 * when it is reading multi-line input.
1:fe77ca5: 	 */
1:fe77ca5: 	static void doPrompt(boolean newStatement, LocalizedOutput out, String tag) 
1:fe77ca5: 	 {
1:fe77ca5: 		if (newStatement) {
1:fe77ca5: 	  		out.print("ij"+(tag==null?"":tag)+"> ");
1:fe77ca5: 		}
1:fe77ca5: 		else {
1:fe77ca5: 			out.print("> ");
1:fe77ca5: 		}
1:fe77ca5: 		out.flush();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	void setMtUse(boolean b) {
1:fe77ca5: 		mtUse = b;
1:fe77ca5: 	}
1:fe77ca5: 
1:ccf72fb:     /**
1:ccf72fb:      * Check that the cursor is scrollable.
1:ccf72fb:      *
1:ccf72fb:      * @param rs the ResultSet to check
1:ccf72fb:      * @param operation which operation this is checked for
1:ccf72fb:      * @exception ijException if the cursor isn't scrollable
1:ccf72fb:      * @exception SQLException if a database error occurs
1:ccf72fb:      */
1:ccf72fb:     private void checkScrollableCursor(ResultSet rs, String operation)
1:ccf72fb:             throws ijException, SQLException {
1:ccf72fb:         if (rs.getType() == ResultSet.TYPE_FORWARD_ONLY) {
1:ccf72fb:             throw ijException.forwardOnlyCursor(operation);
1:fe77ca5:         }
1:fe77ca5:     }
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position on the specified row of the specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 * @param row	The row # to move to.
1:fe77ca5: 	 *				(Negative means from the end of the result set.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	NULL.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(absolute() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult absolute(ResultSet rs, int row)
4:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "ABSOLUTE");
1:ff0fafb: 		// 0 is an *VALID* value for row
1:fe77ca5: 		return new ijRowResult(rs, rs.absolute(row));
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Move the cursor position by the specified amount.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 * @param row	The # of rows to move.
1:fe77ca5: 	 *				(Negative means toward the beginning of the result set.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	NULL.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(relative() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult relative(ResultSet rs, int row)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "RELATIVE");
1:fe77ca5: 		return new ijRowResult(rs, rs.relative(row));
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position before the first row of the specified ResultSet
1:fe77ca5: 	 * and return NULL to the user.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	NULL.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(beforeFirst() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult beforeFirst(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "BEFORE FIRST");
1:fe77ca5: 		rs.beforeFirst();
1:fe77ca5: 		return new ijRowResult(rs, false);
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position on the first row of the specified ResultSet
1:fe77ca5: 	 * and return that row to the user.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The first row of the ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(first() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult first(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "FIRST");
1:fe77ca5: 		return new ijRowResult(rs, rs.first());
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position after the last row of the specified ResultSet
1:fe77ca5: 	 * and return NULL to the user.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	NULL.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(afterLast() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult afterLast(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "AFTER LAST");
1:fe77ca5: 		rs.afterLast();
1:fe77ca5: 		return new ijRowResult(rs, false);
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position on the last row of the specified ResultSet
1:fe77ca5: 	 * and return that row to the user.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The last row of the ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(last() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult last(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "LAST");
1:fe77ca5: 		return new ijRowResult(rs, rs.last());
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Position on the previous row of the specified ResultSet
1:fe77ca5: 	 * and return that row to the user.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The previous row of the ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(previous() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	ijResult previous(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "PREVIOUS");
1:fe77ca5: 		return new ijRowResult(rs, rs.previous());
1:fe77ca5: 	}
1:b1153d5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the current row number
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param rs	The specified ResultSet.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The current row number
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception	SQLException thrown on error.
1:fe77ca5: 	 *				(getRow() not supported pre-JDBC2.0)
1:fe77ca5: 	 */
1:b1153d5: 	int getCurrentRowNumber(ResultSet rs)
1:fe77ca5: 		throws SQLException
1:fe77ca5: 	{
1:ccf72fb:         checkScrollableCursor(rs, "GETCURRENTROWNUMBER");
1:fe77ca5: 		return rs.getRow();
1:fe77ca5: 	}
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: 			} catch (NoSuchMethodException ia) {
1: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
1: 			} catch (java.lang.reflect.InvocationTargetException ia) {
1: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
commit:16d3334
/////////////////////////////////////////////////////////////////////////
0: public class utilMain implements java.security.PrivilegedAction<Object> {
/////////////////////////////////////////////////////////////////////////
1: 	Stack<StatementFinder> oldGrabbers = new Stack<StatementFinder>();
/////////////////////////////////////////////////////////////////////////
1: 					commandGrabber[currCE] = oldGrabbers.pop();
/////////////////////////////////////////////////////////////////////////
1:               List<ResultSet> resultSets = result.getMultipleResultSets();
commit:80d6162
/////////////////////////////////////////////////////////////////////////
1:         JDBCDisplayUtil.setShowSelectCount( !showNoCountForSelect );
commit:0d74a93
/////////////////////////////////////////////////////////////////////////
1: 		if ( ignoreErrors != null ) { this.ignoreErrors = (Hashtable) ignoreErrors.clone(); }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:59f29e4
/////////////////////////////////////////////////////////////////////////
1:             } catch (ijException ie) {
1:                 JDBCDisplayUtil.ShowException(out, ie); // will continue past driver failure
1:             }
commit:8d64950
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public class utilMain {
/////////////////////////////////////////////////////////////////////////
1:             InputStream versionStream = util.getResourceAsStream(
1:                     ProductGenusNames.TOOLS_INFO);
/////////////////////////////////////////////////////////////////////////
commit:ccf72fb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check that the cursor is scrollable.
1:      *
1:      * @param rs the ResultSet to check
1:      * @param operation which operation this is checked for
1:      * @exception ijException if the cursor isn't scrollable
1:      * @exception SQLException if a database error occurs
1:      */
1:     private void checkScrollableCursor(ResultSet rs, String operation)
1:             throws ijException, SQLException {
1:         if (rs.getType() == ResultSet.TYPE_FORWARD_ONLY) {
1:             throw ijException.forwardOnlyCursor(operation);
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "ABSOLUTE");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "RELATIVE");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "BEFORE FIRST");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "FIRST");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "AFTER LAST");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "LAST");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "PREVIOUS");
/////////////////////////////////////////////////////////////////////////
1:         checkScrollableCursor(rs, "GETCURRENTROWNUMBER");
commit:c06280c
/////////////////////////////////////////////////////////////////////////
0:     private static final String JDBC_NOTSUPPORTED =
0:         "JDBC 3 method called - not yet supported";
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:             return conn.createStatement(
0:                 scrollType, ResultSet.CONCUR_READ_ONLY, holdType);
0:         } catch(SQLException se) {
0:             // since jcc doesn't yet support JDBC3.0 we have to go back to
0:             // JDBC2.0
0:             if (isJCC && se.getMessage().equals(JDBC_NOTSUPPORTED)) {
0:                 return conn.createStatement(scrollType,
0:                                             ResultSet.CONCUR_READ_ONLY);
1:             }
1:             throw se;
0:             // because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces,
0:             // we need to go back to jdbc 1.x functionality
0:             // The jcc obfuscated jar gets this error
0:             if (isJCC) {
0:                 return conn.createStatement(scrollType,
0:                                             ResultSet.CONCUR_READ_ONLY);
1:             }
0:             return conn.createStatement();
1:     }
commit:613392c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * or ResultSet.CLOSE_CURSORS_AT_COMMIT.
/////////////////////////////////////////////////////////////////////////
0:         conn.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:         return conn;
0: 	 * Connection object.
/////////////////////////////////////////////////////////////////////////
0:         return conn.getHoldability();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:400ea2e
/////////////////////////////////////////////////////////////////////////
1: 			supportIJProperties(connEnv[currCE]);
/////////////////////////////////////////////////////////////////////////
1: 	    connEnv[0].addSession(conn, (String) null);
1:         ijParser.setConnection(connEnv[0], (numConnections > 1));
1: 	    supportIJProperties(connEnv[0]);   
1: 	    		
1: 	private void supportIJProperties(ConnectionEnv env) {
1: 	  //check if the property is set to not show select count and set the static variable
1:         //accordingly. 
1:         boolean showNoCountForSelect = Boolean.valueOf(util.getSystemProperty("ij.showNoCountForSelect")).booleanValue();
0:         JDBCDisplayUtil.showSelectCount = !showNoCountForSelect;
1: 
1:         //check if the property is set to not show initial connections and accordingly set the
1:         //static variable.
1:         boolean showNoConnectionsAtStart = Boolean.valueOf(util.getSystemProperty("ij.showNoConnectionsAtStart")).booleanValue();
1: 
1:         if (!(showNoConnectionsAtStart)) {
1:             try {
1:                 ijResult result = ijParser.showConnectionsMethod(true);
1:                 displayResult(out,result,env.getConnection());
1:             } catch (SQLException ex) {
1:                 handleSQLException(out,ex);
1:             }
1:         }        
1:     }
1: 
1:     /**
commit:1b0debd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public void go(LocalizedInput[] in, LocalizedOutput out)
1: 				   throws ijFatalException
/////////////////////////////////////////////////////////////////////////
commit:1f22952
/////////////////////////////////////////////////////////////////////////
1: 		boolean syntaxErrorOccurred = false;
1: 			sqlState = e.getSQLState();
1: 			if ("42X01".equals(sqlState))
1: 				syntaxErrorOccurred = true;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (syntaxErrorOccurred)
1: 			out.println(langUtil.getTextMessage("IJ_SuggestHelp"));
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:a39c84c
/////////////////////////////////////////////////////////////////////////
1:     /**
1: 	 * Set up the test to run with 'numConnections' connections/users.
1:      * This overload allows the choice of whether the system properties
1:      * will be used or not.
1: 	 *
1: 	 * @param numConnections	The number of connections/users to test.
1: 	 */
1:     utilMain(int numConnections, LocalizedOutput out, boolean loadSystemProperties)
1: 		throws ijFatalException
1: 	{
1: 		this(numConnections, out, (Hashtable)null);
1:         if (loadSystemProperties) {
1:             initFromEnvironment();
1:         }
1: 	}
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:c0c3716
/////////////////////////////////////////////////////////////////////////
1: 		    commandGrabber[ictr] = new StatementFinder(langUtil.getNewInput(System.in), out);
/////////////////////////////////////////////////////////////////////////
1:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(newFile, BUFFEREDFILESIZE)), null);
/////////////////////////////////////////////////////////////////////////
1:                 new StatementFinder(langUtil.getNewEncodedInput(new BufferedInputStream(is, BUFFEREDFILESIZE), "UTF8"), null);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7b5fc1e
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:             } else if (result.isMultipleResultSetResult()) {
0:               List resultSets = result.getMultipleResultSets();
1:               try {
1:                 JDBCDisplayUtil.DisplayMultipleResults(out,resultSets,
1:                                      connEnv[currCE].getConnection(),
1:                                      result.getColumnDisplayList(),
1:                                      result.getColumnWidthList());
1:               } catch (SQLException se) {
1:                 result.closeStatement();
1:                 throw se;
1:               }
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:fedee29
/////////////////////////////////////////////////////////////////////////
0:     		boolean showNoCountForSelect = Boolean.valueOf(util.getSystemProperty("ij.showNoCountForSelect")).booleanValue();
0:     		boolean showNoConnectionsAtStart = Boolean.valueOf(util.getSystemProperty("ij.showNoConnectionsAtStart")).booleanValue();
commit:38520af
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
0:     		//boolean showNoCountForSelect = Boolean.getBoolean("ij.showNoCountForSelect");
0:     		String prop = (String) AccessController.doPrivileged(new PrivilegedAction() {
0:     					public Object run() {
0:     						return System.getProperty("ij.showNoCountForSelect");
1:     					}
0:     		});
0:     		boolean showNoCountForSelect = Boolean.valueOf(prop).booleanValue();
0:     		prop = (String) AccessController.doPrivileged(new PrivilegedAction() {
0: 				public Object run() {
0: 					return System.getProperty("ij.showNoConnectionsAtStart");
1: 				}
0:          	});
0:     		boolean showNoConnectionsAtStart = Boolean.valueOf(prop).booleanValue();
1: 
0:     		if (!(showNoConnectionsAtStart)) {
commit:a9217e9
/////////////////////////////////////////////////////////////////////////
1: 			} else if (result.isResultSet()) {
1: 				ResultSet rs = result.getResultSet();
1: 				try {
1: 					JDBCDisplayUtil.DisplayResults(out,rs,connEnv[currCE].getConnection(), result.getColumnDisplayList(), result.getColumnWidthList());
1: 				} catch (SQLException se) {
1: 					result.closeStatement();
1: 					throw se;
1: 				}
1: 				result.closeStatement();
commit:1edcdb3
/////////////////////////////////////////////////////////////////////////
0:                 new StatementFinder(langUtil.getNewEncodedInput(new BufferedInputStream(is, BUFFEREDFILESIZE), "UTF8"));
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:95011a0
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Value of the system property ij.execptionTrace
1:      */
1:     private final String ijExceptionTrace;
/////////////////////////////////////////////////////////////////////////
1:         
1:         ijExceptionTrace = util.getSystemProperty("ij.exceptionTrace");
/////////////////////////////////////////////////////////////////////////
1:  					if (command != null)
1:                         scriptErrorCount += doCatch(command) ? 0 : 1;
1:  					if (command != null)
1:                         scriptErrorCount += doCatch(command) ? 0 : 1;
/////////////////////////////////////////////////////////////////////////
1: 	private boolean doCatch(String command) {
1:         
/////////////////////////////////////////////////////////////////////////
1:             return true;
/////////////////////////////////////////////////////////////////////////
1:         return false;
/////////////////////////////////////////////////////////////////////////
1: 			doTrace(e);
/////////////////////////////////////////////////////////////////////////
1: 		if (ijExceptionTrace != null) {
commit:351dad8
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * True if to display the error code when
1: 	 * displaying a SQLException.
1: 	 */
1: 	private final boolean showErrorCode;
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		showErrorCode = 
1: 			Boolean.valueOf(
1: 					util.getSystemProperty("ij.showErrorCode")
1: 					).booleanValue();
/////////////////////////////////////////////////////////////////////////
1: 	public void initFromEnvironment()
1: 		ijParser.initFromEnvironment();
1: 		
/////////////////////////////////////////////////////////////////////////
1: 	public int goScript(Connection conn,
1: 		return runScriptGuts();
1:      * @return The number of errors seen in the script.
1: 	private int runScriptGuts() {
1:         int scriptErrorCount = 0;
/////////////////////////////////////////////////////////////////////////
1:                     scriptErrorCount++;
1:                     scriptErrorCount++;
1:                     scriptErrorCount++;
1:                     scriptErrorCount++;
1:                     scriptErrorCount++;
/////////////////////////////////////////////////////////////////////////
1:         
1:         return scriptErrorCount;
/////////////////////////////////////////////////////////////////////////
1: 		if (showErrorCode) {
commit:eb37b68
/////////////////////////////////////////////////////////////////////////
0: 	public void initConnections()
commit:5766493
/////////////////////////////////////////////////////////////////////////
1: 	public utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors)
commit:43e6994
/////////////////////////////////////////////////////////////////////////
1: 	private final int		numConnections;
/////////////////////////////////////////////////////////////////////////
1: 	utilMain(int numConnections, LocalizedOutput out)
/////////////////////////////////////////////////////////////////////////
0: 	utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors)
/////////////////////////////////////////////////////////////////////////
1: 		}
1: 
1: 		/* Start with connection/user 0 */
1: 		currCE = 0;
1: 		fileInput = false;
1: 		initialFileInput = false;
1: 		firstRun = true;
1: 	}
1: 	
1: 	/**
1: 	 * Initialize the connections from the environment.
1: 	 *
1: 	 */
0: 	void initConnections()
1: 	{
1: 		for (int ictr = 0; ictr < numConnections; ictr++)
1: 		{
/////////////////////////////////////////////////////////////////////////
commit:b1153d5
/////////////////////////////////////////////////////////////////////////
1: 		ijParser = new ij(ijTokMgr, this);
/////////////////////////////////////////////////////////////////////////
1: 	private void handleSQLException(LocalizedOutput out, SQLException e) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	Connection setHoldability(Connection conn, int holdType)
/////////////////////////////////////////////////////////////////////////
0: 	int getHoldability(Connection conn)
/////////////////////////////////////////////////////////////////////////
0: 	Statement createStatement(Connection conn, int scrollType, int holdType)
/////////////////////////////////////////////////////////////////////////
1: 	ijResult absolute(ResultSet rs, int row)
0:         boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	ijResult relative(ResultSet rs, int row)
0:     	boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1: 
0:     	// relative is only allowed on scroll cursors
/////////////////////////////////////////////////////////////////////////
1: 	ijResult beforeFirst(ResultSet rs)
0:     	boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1: 
0:     	// before first is only allowed on scroll cursors
/////////////////////////////////////////////////////////////////////////
1: 	ijResult first(ResultSet rs)
0:     	boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1: 
0:     	// first is only allowed on scroll cursors
/////////////////////////////////////////////////////////////////////////
1: 	ijResult afterLast(ResultSet rs)
/////////////////////////////////////////////////////////////////////////
1: 	ijResult last(ResultSet rs)
0:     	boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1: 
/////////////////////////////////////////////////////////////////////////
1: 	ijResult previous(ResultSet rs)
0:     	boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
1:  
0:     	// first is only allowed on scroll cursors
/////////////////////////////////////////////////////////////////////////
1: 	int getCurrentRowNumber(ResultSet rs)
1: 
0: 		boolean forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
/////////////////////////////////////////////////////////////////////////
0: 	Properties getConnAttributeDefaults ()
commit:a5a98ce
/////////////////////////////////////////////////////////////////////////
0:   private static final Class[] CONN_PARAM = { Integer.TYPE };
0:   private static final Object[] CONN_ARG = { new Integer(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)};
1: 	private StatementFinder[] commandGrabber;
1: 	private int currCE;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		this.out = out;
1: 		runScriptGuts();
1: 		cleanupGo(in);
1: 	}
1: 	
1: 	/**
1: 	 * Support to run a script. Performs minimal setup
1: 	 * to set the passed in connection into the existing
1: 	 * ij setup, ConnectionEnv.
1: 	 * @param conn
1: 	 * @param in
1: 	 */
0: 	public void goScript(Connection conn,
1: 			LocalizedInput in)
1: 	{
0: 		JDBCDisplayUtil.showSelectCount = false;
0: 		connEnv[0].addSession(conn, (String) null);
1: 		fileInput = initialFileInput = !in.isStandardInput();
1: 		commandGrabber[0].ReInit(in);
1: 		runScriptGuts();
1: 	}
1: 	
1: 	/**
1: 	 * Run the guts of the script. Split out to allow
1: 	 * calling from the full ij and the minimal goScript.
1: 	 *
1: 	 */
0: 	private void runScriptGuts() {
1: 		
1: 		boolean done = false;
1: 		String command = null;
/////////////////////////////////////////////////////////////////////////
1:    				command = null;
/////////////////////////////////////////////////////////////////////////
1: 	}
1: 	
1: 	/**
1: 	 * Perform cleanup after a script has been run.
1: 	 * Close the input streams if required and shutdown
1: 	 * derby on an exit.
1: 	 * @param in
1: 	 */
1: 	private void cleanupGo(LocalizedInput[] in) {
/////////////////////////////////////////////////////////////////////////
1: 				in[i].close();	
commit:ff0fafb
/////////////////////////////////////////////////////////////////////////
1: 		// 0 is an *VALID* value for row
commit:6daf45b
/////////////////////////////////////////////////////////////////////////
1: 			} catch (Throwable e) {
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.ij.utilMain
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.ij;
1:                 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: import org.apache.derby.tools.JDBCDisplayUtil;
1: import org.apache.derby.iapi.tools.i18n.*;
1: 
1: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1: import org.apache.derby.iapi.services.info.ProductGenusNames;
1: 
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import java.util.Stack;
1: import java.util.Hashtable;
0: import java.util.Properties;
1: 
1: import java.io.InputStream;
1: import java.io.FileInputStream;
1: import java.io.BufferedInputStream;
1: import java.io.FileNotFoundException;
1: import java.io.StringReader;
1: import java.sql.DriverManager;
1: import java.sql.Driver;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: 
0: import java.lang.reflect.*;
1: 
1: /**
1: 	This class is utilities specific to the two ij Main's.
1: 	This factoring enables sharing the functionality for
1: 	single and dual connection ij runs.
1: 
0: 	@author jerry
1:  */
0: public class utilMain implements java.security.PrivilegedAction {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
0:   private static Class[] CONN_PARAM = { Integer.TYPE };
0:   private static Object[] CONN_ARG = { new Integer(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)};
1: 
0: 	StatementFinder[] commandGrabber;
1: 	UCode_CharStream charStream;
1: 	ijTokenManager ijTokMgr;
1: 	ij ijParser;
1: 	ConnectionEnv[] connEnv;
0: 	int currCE;
0: 	private int		numConnections;
1: 	private boolean fileInput;
1: 	private boolean initialFileInput;
1: 	private boolean mtUse;
1: 	private boolean firstRun = true;
1: 	private LocalizedOutput out = null;
0: 	private Properties connAttributeDefaults;
1: 	private Hashtable ignoreErrors;
1: 
0: 	protected boolean isJCC;	//The driver being used is JCC
1: 
1: 	/*
1: 		In the goodness of time, this could be an ij property
1: 	 */
1: 	public static final int BUFFEREDFILESIZE = 2048;
1: 
1: 	/*
1: 	 * command can be redirected, so we stack up command
1: 	 * grabbers as needed.
1: 	 */
0: 	Stack oldGrabbers = new Stack();
1: 
1: 	LocalizedResource langUtil = LocalizedResource.getInstance();
1: 	/**
1: 	 * Set up the test to run with 'numConnections' connections/users.
1: 	 *
1: 	 * @param numConnections	The number of connections/users to test.
1: 	 */
0: 	public utilMain(int numConnections, LocalizedOutput out)
1: 		throws ijFatalException
1: 	{
1: 		this(numConnections, out, (Hashtable)null);
1: 	}
1: 
1: 	/**
1: 	 * Set up the test to run with 'numConnections' connections/users.
1: 	 *
1: 	 * @param numConnections	The number of connections/users to test.
1: 	 * @param ignoreErrors		A list of errors to ignore.  If null,
1: 	 *							all errors are printed out and nothing
1: 	 *							is fatal.  If non-null, if an error is
1: 	 *							hit and it is in this list, it is silently	
1: 	 *							ignore.  Otherwise, an ijFatalException is
1: 	 *							thrown.  ignoreErrors is used for stress
1: 	 *							tests.
1: 	 */
0: 	public utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors)
1: 		throws ijFatalException
1: 	{
0: 		String framework_property = util.getSystemProperty("framework");
1: 		
0: 		if (framework_property != null)
1: 		{
0: 			if (framework_property.equals("DB2jNet") 
0: 					|| framework_property.equals("DB2jcc"))
0: 				isJCC = true;
1: 		}
1: 		/* init the parser; give it no input to start with.
1: 		 * (1 parser for entire test.)
1: 		 */
1: 		charStream = new UCode_CharStream(
1: 						new StringReader(" "), 1, 1);
1: 		ijTokMgr = new ijTokenManager(charStream);
0: 		ijParser = new ij(ijTokMgr, getUtilMain());
1: 		this.out = out;
0: 		this.ignoreErrors = ignoreErrors;
1: 
1: 		this.numConnections = numConnections;
1: 		/* 1 StatementFinder and ConnectionEnv per connection/user. */
1: 		commandGrabber = new StatementFinder[numConnections];
1: 		connEnv = new ConnectionEnv[numConnections];
1: 
1: 		for (int ictr = 0; ictr < numConnections; ictr++)
1: 		{
0: 		    commandGrabber[ictr] = new StatementFinder(langUtil.getNewInput(System.in));
1: 			connEnv[ictr] = new ConnectionEnv(ictr, (numConnections > 1), (numConnections == 1));
1: 			try {
1: 				connEnv[ictr].init(out);
1: 			} catch (SQLException s) {
1: 				JDBCDisplayUtil.ShowException(out, s); // will continue past connect failure
1: 			} catch (ClassNotFoundException c) {
1: 				JDBCDisplayUtil.ShowException(out, c); // will continue past driver failure
1: 			} catch (InstantiationException i) {
1: 				JDBCDisplayUtil.ShowException(out, i); // will continue past driver failure
1: 			} catch (IllegalAccessException ia) {
1: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
1: 			}
1: 		}
1: 
0: 		/* Start with connection/user 0 */
0: 		currCE = 0;
0: 		fileInput = false;
0: 		initialFileInput = false;
0: 		firstRun = true;
1: 	}
1: 
1: 
1: 	/**
1: 	 * run ij over the specified input, sending output to the
1: 	 * specified output. Any prior input and output will be lost.
1: 	 *
1: 	 * @param in source for input to ij
1: 	 * @param out sink for output from ij
0: 	 * @param connAttributeDefaults  connection attributes from -ca ij arg
1: 	 */
0: 	public void go(LocalizedInput[] in, LocalizedOutput out,
0: 				   Properties connAttributeDefaults) throws ijFatalException
1: 	{
0: 		boolean done = false;
1: 
0: 		String command = null;
1: 
1: 		this.out = out;
0: 		this.connAttributeDefaults = connAttributeDefaults;
1: 		
1: 		ijParser.setConnection(connEnv[currCE], (numConnections > 1));
1: 		fileInput = initialFileInput = (!in[currCE].isStandardInput());
1: 
1: 		for (int ictr = 0; ictr < commandGrabber.length; ictr++) {
1: 			commandGrabber[ictr].ReInit(in[ictr]);
1: 		}
1: 
1: 		if (firstRun) {
1: 
1: 			// figure out which version this is
0: 			InputStream versionStream = (InputStream) java.security.AccessController.doPrivileged(this);
1: 
1: 			// figure out which version this is
1: 			ProductVersionHolder ijVersion = 
1: 				ProductVersionHolder.getProductVersionHolderFromMyEnv(versionStream);
1: 
1: 			String version;
1: 			if (ijVersion != null)
1: 			{
1: 				version = "" + ijVersion.getMajorVersion() + "." +
1: 					ijVersion.getMinorVersion();
1: 			}
1: 			else
1: 			{
1: 				version = "?";
1: 			}
1: 
1:    			out.println(langUtil.getTextMessage("IJ_IjVers30C199", version));
1: 			for (int i=connEnv.length-1;i>=0;i--) { // print out any initial warnings...
1: 				Connection c = connEnv[i].getConnection();
1: 				if (c!=null) {
1: 					JDBCDisplayUtil.ShowWarnings(out,c);
1: 				}
1: 			}
1: 			firstRun = false;
1: 
0:       		//check if the property is set to not show select count and set the static variable
0:       		//accordingly. 
0:     		boolean showNoCountForSelect = Boolean.getBoolean("ij.showNoCountForSelect");
0:       		JDBCDisplayUtil.showSelectCount = !showNoCountForSelect;
1: 
0:       		//check if the property is set to not show initial connections and accordingly set the
0:       		//static variable.
0:     		boolean showNoConnectionsAtStart = Boolean.getBoolean("ij.showNoConnectionsAtStart");
0:       		if (!(showNoConnectionsAtStart)) {
1:          		try {
0:            			ijResult result = ijParser.showConnectionsMethod(true);
1:  					displayResult(out,result,connEnv[currCE].getConnection());
0:          		} catch (SQLException ex) {
0:            			handleSQLException(out,ex);
1:          		}
1:       		}
1:     	}
1: 
1: 		while (!ijParser.exit && !done) {
1: 			try{
1: 				ijParser.setConnection(connEnv[currCE], (numConnections > 1));
1: 			} catch(Throwable t){
1: 				//do nothing
1: 				}
1: 
1: 			connEnv[currCE].doPrompt(true, out);
1:    			try {
0: 				command = null;
1: 
1: 				out.flush();
1: 				command = commandGrabber[currCE].nextStatement();
1: 
1: 				// if there is no next statement,
1: 				// pop back to the top saved grabber.
1: 				while (command == null && ! oldGrabbers.empty()) {
1: 					// close the old input file if not System.in
1: 					if (fileInput) commandGrabber[currCE].close();
0: 					commandGrabber[currCE] = (StatementFinder)oldGrabbers.pop();
1: 					if (oldGrabbers.empty())
1: 						fileInput = initialFileInput;
1: 					command = commandGrabber[currCE].nextStatement();
1: 				}
1: 
1: 				// if there are no grabbers left,
1: 				// we are done.
1: 				if (command == null && oldGrabbers.empty()) {
1: 					done = true;
1: 				}
1: 				else {
1: 					boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
1: 					long	beginTime = 0;
1: 					long	endTime;
1: 
1: 					if (fileInput) {
1: 						out.println(command+";");
1: 						out.flush();
1: 					}
1: 
1: 					charStream.ReInit(new StringReader(command), 1, 1);
1: 					ijTokMgr.ReInit(charStream);
1: 					ijParser.ReInit(ijTokMgr);
1: 
1: 					if (elapsedTimeOn) {
1: 						beginTime = System.currentTimeMillis();
1: 					}
1: 
1: 					ijResult result = ijParser.ijStatement();
1: 					displayResult(out,result,connEnv[currCE].getConnection());
1: 
1: 					// if something went wrong, an SQLException or ijException was thrown.
1: 					// we can keep going to the next statement on those (see catches below).
1: 					// ijParseException means we try the SQL parser.
1: 
1: 					/* Print the elapsed time if appropriate */
1: 					if (elapsedTimeOn) {
1: 						endTime = System.currentTimeMillis();
1: 						out.println(langUtil.getTextMessage("IJ_ElapTime0Mil", 
1: 						langUtil.getNumberAsString(endTime - beginTime)));
1: 					}
1: 
1: 					// would like when it completes a statement
1: 					// to see if there is stuff after the ;
1: 					// and before the <EOL> that we will IGNORE
1: 					// (with a warning to that effect)
1: 				}
1: 
1:     			} catch (ParseException e) {
0: 					if (command != null) doCatch(command);
1: 				} catch (TokenMgrError e) {
0: 					if (command != null) doCatch(command);
1:     			} catch (SQLException e) {
1: 					// SQL exception occurred in ij's actions; print and continue
1: 					// unless it is considered fatal.
1: 					handleSQLException(out,e);
1:     			} catch (ijException e) {
1: 					// exception occurred in ij's actions; print and continue
1:     			  	out.println(langUtil.getTextMessage("IJ_IjErro0",e.getMessage()));
1: 					doTrace(e);
1:     			} catch (Throwable e) {
1:     			  	out.println(langUtil.getTextMessage("IJ_JavaErro0",e.toString()));
1: 					doTrace(e);
1: 				}
1: 
1: 			/* Go to the next connection/user, if there is one */
1: 			currCE = ++currCE % connEnv.length;
1: 		}
1: 
1: 		// we need to close all sessions when done; otherwise we have
1: 		// a problem when a single VM runs successive IJ threads
1: 		try {
1: 			for (int i = 0; i < connEnv.length; i++) {
1: 				connEnv[i].removeAllSessions();
1: 			}
1: 		} catch (SQLException se ) {
1: 			handleSQLException(out,se);
1: 		}
1: 		// similarly must close input files
1: 		for (int i = 0; i < numConnections; i++) {
1: 			try {
0: 				if (!in[i].isStandardInput() )
0: 					in[i].close();	
1: 			} catch (Exception e ) {
1:     			  	out.println(langUtil.getTextMessage("IJ_CannotCloseInFile",
1: 					e.toString()));
1: 			}
1: 		}
1: 
1: 		/*
1: 			If an exit was requested, then we will be shutting down.
1: 		 */
1: 		if (ijParser.exit || (initialFileInput && !mtUse)) {
1: 			Driver d = null;
1: 			try {
1: 			    d = DriverManager.getDriver("jdbc:derby:");
0: 			} catch (Exception e) {
1: 				d = null;
1: 			}
1: 			if (d!=null) { // do we have a driver running? shutdown on exit.
1: 				try {
1: 					DriverManager.getConnection("jdbc:derby:;shutdown=true");
1: 				} catch (SQLException e) {
1: 					// ignore the errors, they are expected.
1: 				}
1: 			}
1: 		}
1:   	}
1: 
1: 	private void displayResult(LocalizedOutput out, ijResult result, Connection conn) throws SQLException {
1: 		// display the result, if appropriate.
1: 		if (result!=null) {
1: 			if (result.isConnection()) {
1: 				if (result.hasWarnings()) {
1: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1: 					result.clearSQLWarnings();
1: 				}
1: 			} else if (result.isStatement()) {
1: 				Statement s = result.getStatement();
1: 				try {
1: 				    JDBCDisplayUtil.DisplayResults(out,s,connEnv[currCE].getConnection());
1: 				} catch (SQLException se) {
1: 				    result.closeStatement();
1: 					throw se;
1: 				}
1: 				result.closeStatement();
1: 			} else if (result.isNextRowOfResultSet()) {
1: 				ResultSet r = result.getNextRowOfResultSet();
1: 				JDBCDisplayUtil.DisplayCurrentRow(out,r,connEnv[currCE].getConnection());
1: 			} else if (result.isVector()) {
1: 				util.DisplayVector(out,result.getVector());
1: 				if (result.hasWarnings()) {
1: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1: 					result.clearSQLWarnings();
1: 				}
1: 			} else if (result.isMulti()) {
1: 			    try {
1: 				    util.DisplayMulti(out,(PreparedStatement)result.getStatement(),result.getResultSet(),connEnv[currCE].getConnection());
1: 				} catch (SQLException se) {
1: 				    result.closeStatement();
1: 					throw se;
1: 				}
1: 				result.closeStatement(); // done with the statement now
1: 				if (result.hasWarnings()) {
1: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
1: 					result.clearSQLWarnings();
1: 				}
1: 			} else if (result.isException()) {
1: 				JDBCDisplayUtil.ShowException(out,result.getException());
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * catch processing on failed commands. This really ought to
1: 	 * be in ij somehow, but it was easier to catch in Main.
1: 	 */
0: 	private void doCatch(String command) {
1: 		// this retries the failed statement
1: 		// as a JSQL statement; it uses the
1: 		// ijParser since that maintains our
1: 		// connection and state.
1: 
1: 	    try {
1: 			boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
1: 			long	beginTime = 0;
1: 			long	endTime;
1: 
1: 			if (elapsedTimeOn) {
1: 				beginTime = System.currentTimeMillis();
1: 			}
1: 
1: 			ijResult result = ijParser.executeImmediate(command);
1: 			displayResult(out,result,connEnv[currCE].getConnection());
1: 
1: 			/* Print the elapsed time if appropriate */
1: 			if (elapsedTimeOn) {
1: 				endTime = System.currentTimeMillis();
1: 				out.println(langUtil.getTextMessage("IJ_ElapTime0Mil_4", 
1: 				langUtil.getNumberAsString(endTime - beginTime)));
1: 			}
1: 
1: 	    } catch (SQLException e) {
1: 			// SQL exception occurred in ij's actions; print and continue
1: 			// unless it is considered fatal.
1: 			handleSQLException(out,e);
1: 	    } catch (ijException i) {
1: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_5", i.getMessage()));
1: 			doTrace(i);
1: 		} catch (ijTokenException ie) {
1: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_6", ie.getMessage()));
1: 			doTrace(ie);
1: 	    } catch (Throwable t) {
1: 	  		out.println(langUtil.getTextMessage("IJ_JavaErro0_7", t.toString()));
1: 			doTrace(t);
1: 	    }
1: 	}
1: 
1: 	/**
1: 	 * This routine displays SQL exceptions and decides whether they
1: 	 * are fatal or not, based on the ignoreErrors field. If they
1: 	 * are fatal, an ijFatalException is thrown.
1: 	 * Lifted from ij/util.java:ShowSQLException
1: 	 */
0: 	public void handleSQLException(LocalizedOutput out, SQLException e) 
1: 		throws ijFatalException
1: 	{
1: 		String errorCode;
1: 		String sqlState = null;
1: 		SQLException fatalException = null;
1: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
1: 			errorCode = langUtil.getTextMessage("IJ_Erro0", 
1: 			langUtil.getNumberAsString(e.getErrorCode()));
1: 		}
1: 		else {
1: 			errorCode = "";
1: 		}
1: 
1: 		for (; e!=null; e=e.getNextException())
1: 		{
1: 			/*
1: 			** If we are to throw errors, then throw the exceptions
1: 			** that aren't in the ignoreErrors list.  If
1: 			** the ignoreErrors list is null we don't throw
1: 			** any errors.
1: 			*/
1: 		 	if (ignoreErrors != null) 
1: 			{
0: 				sqlState = e.getSQLState();
1: 				if ((sqlState != null) &&
1: 					(ignoreErrors.get(sqlState) != null))
1: 				{
1: 					continue;
1: 				}
1: 				else
1: 				{
1: 					fatalException = e;
1: 				}
1: 			}
1: 
1: 			String st1 = JDBCDisplayUtil.mapNull(e.getSQLState(),langUtil.getTextMessage("IJ_NoSqls"));
1: 			String st2 = JDBCDisplayUtil.mapNull(e.getMessage(),langUtil.getTextMessage("IJ_NoMess"));
1: 			out.println(langUtil.getTextMessage("IJ_Erro012",  st1, st2, errorCode));
0: 			JDBCDisplayUtil.doTrace(out, e);
1: 		}
1: 		if (fatalException != null)
1: 		{
1: 			throw new ijFatalException(fatalException);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * stack trace dumper
1: 	 */
1: 	private void doTrace(Throwable t) {
0: 		if (util.getSystemProperty("ij.exceptionTrace") != null) {
1: 			t.printStackTrace(out);
1: 		}
1: 		out.flush();
1: 	}
1: 
1: 	void newInput(String fileName) {
1: 		FileInputStream newFile = null;
1: 		try {
1: 			newFile = new FileInputStream(fileName);
1:       	} catch (FileNotFoundException e) {
1:         	throw ijException.fileNotFound();
1: 		}
1: 		if (newFile == null) return;
1: 
1: 		// if the file was opened, move to use it for input.
1: 		oldGrabbers.push(commandGrabber[currCE]);
1: 	    commandGrabber[currCE] = 
0:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(newFile, BUFFEREDFILESIZE)));
1: 		fileInput = true;
1: 	}
1: 
1: 	void newResourceInput(String resourceName) {
1: 		InputStream is = util.getResourceAsStream(resourceName);
1: 		if (is==null) throw ijException.resourceNotFound();
1: 		oldGrabbers.push(commandGrabber[currCE]);
1: 	    commandGrabber[currCE] = 
0:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(is, BUFFEREDFILESIZE)));
1: 		fileInput = true;
1: 	}
1: 
1: 	/**
1: 	 * REMIND: eventually this might be part of StatementFinder,
1: 	 * used at each carriage return to show that it is still "live"
1: 	 * when it is reading multi-line input.
1: 	 */
1: 	static void doPrompt(boolean newStatement, LocalizedOutput out, String tag) 
1: 	 {
1: 		if (newStatement) {
1: 	  		out.print("ij"+(tag==null?"":tag)+"> ");
1: 		}
1: 		else {
1: 			out.print("> ");
1: 		}
1: 		out.flush();
1: 	}
1: 
1: 	void setMtUse(boolean b) {
1: 		mtUse = b;
1: 	}
1: 
0: 	// JDBC 2.0 support
1: 
1: 	/**
0: 	 * Return the right utilMain to use.  (JDBC 1.1 or 2.0)
1: 	 *
1: 	 */
0: 	public utilMain getUtilMain()
1: 	{
0: 		return this;
1: 	}
1: 
1: 	/**
0: 	 * Connections by default create ResultSet objects with holdability true. This method can be used
0: 	 * to change the holdability of the connection by passing one of ResultSet.HOLD_CURSORS_OVER_COMMIT
0: 	 * or ResultSet.CLOSE_CURSORS_AT_COMMIT. We implement this using reflection in jdk13 and lower
1: 	 *
0: 	 * @param conn			The connection.
0: 	 * @param holdType	The new holdability for the Connection object.
1: 	 *
0: 	 * @return	The connection object with holdability set to passed value.
1: 	 */
0: 	public Connection setHoldability(Connection conn, int holdType)
1: 		throws SQLException
1: 	{
0:     //Prior to db2 compatibility work, the default holdability for connections was close cursors over commit and all the tests
0:     //were written based on that assumption
0:     //Later, as part of db2 compatibility, we changed the default holdability for connection to hold cursors over commit.
0:     //But in order for the existing tests to work fine, the tests needed a way to set the holdability to close cursors for connections
0:     //Since there is no direct jdbc api in jdk13 and lower to do that, we are using reflection to set the holdability to close cursors
0:     try { //for jdks prior to jdk14, need to use reflection to set holdability to false. 
0:     	Method sh = conn.getClass().getMethod("setHoldability", CONN_PARAM);
0:     	sh.invoke(conn, CONN_ARG);
0:     } catch( Exception e) {
0:     	throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
1:     }
0:     return conn;
1: 	}
1: 
1: 	/**
0: 	 * Retrieves the current holdability of ResultSet objects created using this
0: 	 * Connection object. We implement this using reflection in jdk13 and lower
1: 	 *
0: 	 * @return  The holdability, one of ResultSet.HOLD_CURSORS_OVER_COMMIT
0: 	 * or ResultSet.CLOSE_CURSORS_AT_COMMIT
1: 	 *
1: 	 */
0: 	public int getHoldability(Connection conn)
1: 		throws SQLException
1: 	{
0:     //this method is used to make sure we are not trying to create a statement with holdability different than the connection holdability
0:     //This is because jdk13 and lower does not have support for that.
0:     //The holdability of connection and statement can differ if connection holdability is set to close cursor on commit using reflection
0:     //and statement is getting created with holdability true
0:     //Another instance of holdability of connection and statement not being same is when connection holdability is hold cursor
0:     //over commit and statement is being created with holdability false
0:     int defaultHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
1:     try {
0:     	Method sh = conn.getClass().getMethod("getHoldability", null);
0:     	defaultHoldability = ((Integer)sh.invoke(conn, null)).intValue();
0:     } catch( Exception e) {
0:     	throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
1:     }
0:     return defaultHoldability;
1: 	}
1: 
1: 	/**
0: 	 * Create the right kind of statement (scrolling or not)
0: 	 * off of the specified connection.
1: 	 *
0: 	 * @param conn			The connection.
0: 	 * @param scrollType	The scroll type of the cursor.
1: 	 *
0: 	 * @return	The statement.
1: 	 */
0: 	public Statement createStatement(Connection conn, int scrollType, int holdType)
1: 		throws SQLException
1: 	{
0:     	//following if is used to make sure we are not trying to create a statement with holdability different that the connection
0:     	//holdability. This is because jdk13 and lower does not have support for that.
0:     	//The holdability of connection and statement can differ if connection holdability is set to close cursor on commit using reflection
0:     	//and statement is getting created with holdability true
0:     	//Another instance of holdability of connection and statement not being same is when connection holdability is hold cursor
0:     	//over commit and statement is being created with holdability false
0:     	if (holdType != getHoldability(conn))
1:     	{
0:         	throw ijException.holdCursorsNotSupported();
1:     	}
1:       
0:     	Statement stmt;
1:         try {
0:         	stmt = conn.createStatement(scrollType, JDBC20Translation.CONCUR_READ_ONLY);
0:         } catch(AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:         	stmt = conn.createStatement();
1:         }
0: 		return stmt;
1: 	}
1: 
1: 	/**
1: 	 * Position on the specified row of the specified ResultSet.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 * @param row	The row # to move to.
1: 	 *				(Negative means from the end of the result set.)
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(absolute() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult absolute(ResultSet rs, int row)
1: 		throws SQLException
1: 	{
0:         boolean forwardOnly;
1:     	try {
0: 		// absolute is only allowed on scroll cursors
0: 		    forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0:         if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("ABSOLUTE");
1: 		}
1: 
0: 		// 0 is an invalid value for row
0: 		if (row == 0)
1: 		{
0: 			throw ijException.zeroInvalidForAbsolute();
1: 		}
1: 
1: 		return new ijRowResult(rs, rs.absolute(row));
1: 	}
1: 
1: 	/**
1: 	 * Move the cursor position by the specified amount.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 * @param row	The # of rows to move.
1: 	 *				(Negative means toward the beginning of the result set.)
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(relative() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult relative(ResultSet rs, int row)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// relative is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("RELATIVE");
1: 		}
1: 
1: 		return new ijRowResult(rs, rs.relative(row));
1: 	}
1: 
1: 	/**
1: 	 * Position before the first row of the specified ResultSet
1: 	 * and return NULL to the user.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(beforeFirst() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult beforeFirst(ResultSet rs)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// before first is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("BEFORE FIRST");
1: 		}
1: 
1: 		rs.beforeFirst();
1: 		return new ijRowResult(rs, false);
1: 	}
1: 
1: 	/**
1: 	 * Position on the first row of the specified ResultSet
1: 	 * and return that row to the user.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	The first row of the ResultSet.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(first() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult first(ResultSet rs)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// first is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("FIRST");
1: 		}
1: 
1: 		return new ijRowResult(rs, rs.first());
1: 	}
1: 
1: 	/**
1: 	 * Position after the last row of the specified ResultSet
1: 	 * and return NULL to the user.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(afterLast() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult afterLast(ResultSet rs)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// after last is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("AFTER LAST");
1: 		}
1: 
1: 		rs.afterLast();
1: 		return new ijRowResult(rs, false);
1: 	}
1: 
1: 	/**
1: 	 * Position on the last row of the specified ResultSet
1: 	 * and return that row to the user.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	The last row of the ResultSet.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(last() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult last(ResultSet rs)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// last is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("LAST");
1: 		}
1: 
1: 		return new ijRowResult(rs, rs.last());
1: 	}
1: 
1: 	/**
1: 	 * Position on the previous row of the specified ResultSet
1: 	 * and return that row to the user.
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	The previous row of the ResultSet.
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(previous() not supported pre-JDBC2.0)
1: 	 */
0: 	public ijResult previous(ResultSet rs)
1: 		throws SQLException
1: 	{
0:     	boolean forwardOnly;
1:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
1:         }
0: 		// first is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("PREVIOUS");
1: 		}
1: 
1: 		return new ijRowResult(rs, rs.previous());
1: 	}
1: 
1: 	/**
1: 	 * Get the current row number
1: 	 *
1: 	 * @param rs	The specified ResultSet.
1: 	 *
1: 	 * @return	The current row number
1: 	 *
1: 	 * @exception	SQLException thrown on error.
1: 	 *				(getRow() not supported pre-JDBC2.0)
1: 	 */
0: 	public int getCurrentRowNumber(ResultSet rs)
1: 		throws SQLException
1: 	{
0: 		boolean forwardOnly;
0: 		try 
1: 		{
0: 			forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0: 		} catch (AbstractMethodError ame) 
1: 		{
0: 			//because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0: 			//to jdbc 1.x functionality
0: 			forwardOnly = true;
1:         }
1: 
0: 		// getCurrentRow is only allowed on scroll cursors
0: 		if (forwardOnly)
1: 		{
0: 			throw ijException.forwardOnlyCursor("GETCURRENTROWNUMBER");
1: 		}
1: 
1: 		return rs.getRow();
1: 	}
1: 
0: 	public Properties getConnAttributeDefaults ()
1: 	{
0: 		return connAttributeDefaults;
1: 	}
1: 
0: 	public final Object run() {
0: 		return  getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11bc2d0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.tools.ij;
0:                 
0: import org.apache.derby.iapi.reference.JDBC20Translation;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import org.apache.derby.tools.JDBCDisplayUtil;
0: import org.apache.derby.iapi.tools.i18n.*;
0: 
0: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: 
0: import org.apache.derby.iapi.error.PublicAPI;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.util.Stack;
0: import java.util.Hashtable;
0: import java.util.Properties;
0: 
0: import java.io.InputStream;
0: import java.io.FileInputStream;
0: import java.io.BufferedInputStream;
0: import java.io.FileNotFoundException;
0: import java.io.StringReader;
0: import java.sql.DriverManager;
0: import java.sql.Driver;
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: 
0: import java.lang.reflect.*;
0: 
0: /**
0: 	This class is utilities specific to the two ij Main's.
0: 	This factoring enables sharing the functionality for
0: 	single and dual connection ij runs.
0: 
0: 	@author jerry
0:  */
0: public class utilMain implements java.security.PrivilegedAction {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:   private static Class[] CONN_PARAM = { Integer.TYPE };
0:   private static Object[] CONN_ARG = { new Integer(JDBC30Translation.CLOSE_CURSORS_AT_COMMIT)};
0: 
0: 	StatementFinder[] commandGrabber;
0: 	UCode_CharStream charStream;
0: 	ijTokenManager ijTokMgr;
0: 	ij ijParser;
0: 	ConnectionEnv[] connEnv;
0: 	int currCE;
0: 	private int		numConnections;
0: 	private boolean fileInput;
0: 	private boolean initialFileInput;
0: 	private boolean mtUse;
0: 	private boolean firstRun = true;
0: 	private LocalizedOutput out = null;
0: 	private Properties connAttributeDefaults;
0: 	private Hashtable ignoreErrors;
0: 
0: 	protected boolean isJCC;	//The driver being used is JCC
0: 
0: 	/*
0: 		In the goodness of time, this could be an ij property
0: 	 */
0: 	public static final int BUFFEREDFILESIZE = 2048;
0: 
0: 	/*
0: 	 * command can be redirected, so we stack up command
0: 	 * grabbers as needed.
0: 	 */
0: 	Stack oldGrabbers = new Stack();
0: 
0: 	LocalizedResource langUtil = LocalizedResource.getInstance();
0: 	/**
0: 	 * Set up the test to run with 'numConnections' connections/users.
0: 	 *
0: 	 * @param numConnections	The number of connections/users to test.
0: 	 */
0: 	public utilMain(int numConnections, LocalizedOutput out)
0: 		throws ijFatalException
0: 	{
0: 		this(numConnections, out, (Hashtable)null);
0: 	}
0: 
0: 	/**
0: 	 * Set up the test to run with 'numConnections' connections/users.
0: 	 *
0: 	 * @param numConnections	The number of connections/users to test.
0: 	 * @param ignoreErrors		A list of errors to ignore.  If null,
0: 	 *							all errors are printed out and nothing
0: 	 *							is fatal.  If non-null, if an error is
0: 	 *							hit and it is in this list, it is silently	
0: 	 *							ignore.  Otherwise, an ijFatalException is
0: 	 *							thrown.  ignoreErrors is used for stress
0: 	 *							tests.
0: 	 */
0: 	public utilMain(int numConnections, LocalizedOutput out, Hashtable ignoreErrors)
0: 		throws ijFatalException
0: 	{
0: 		String framework_property = util.getSystemProperty("framework");
0: 		
0: 		if (framework_property != null)
0: 		{
0: 			if (framework_property.equals("DB2jNet") 
0: 					|| framework_property.equals("DB2jcc"))
0: 				isJCC = true;
0: 		}
0: 		/* init the parser; give it no input to start with.
0: 		 * (1 parser for entire test.)
0: 		 */
0: 		charStream = new UCode_CharStream(
0: 						new StringReader(" "), 1, 1);
0: 		ijTokMgr = new ijTokenManager(charStream);
0: 		ijParser = new ij(ijTokMgr, getUtilMain());
0: 		this.out = out;
0: 		this.ignoreErrors = ignoreErrors;
0: 
0: 		this.numConnections = numConnections;
0: 		/* 1 StatementFinder and ConnectionEnv per connection/user. */
0: 		commandGrabber = new StatementFinder[numConnections];
0: 		connEnv = new ConnectionEnv[numConnections];
0: 
0: 		for (int ictr = 0; ictr < numConnections; ictr++)
0: 		{
0: 		    commandGrabber[ictr] = new StatementFinder(langUtil.getNewInput(System.in));
0: 			connEnv[ictr] = new ConnectionEnv(ictr, (numConnections > 1), (numConnections == 1));
0: 			try {
0: 				connEnv[ictr].init(out);
0: 			} catch (SQLException s) {
0: 				JDBCDisplayUtil.ShowException(out, s); // will continue past connect failure
0: 			} catch (ClassNotFoundException c) {
0: 				JDBCDisplayUtil.ShowException(out, c); // will continue past driver failure
0: 			} catch (InstantiationException i) {
0: 				JDBCDisplayUtil.ShowException(out, i); // will continue past driver failure
0: 			} catch (IllegalAccessException ia) {
0: 				JDBCDisplayUtil.ShowException(out, ia); // will continue past driver failure
0: 			}
0: 		}
0: 
0: 		/* Start with connection/user 0 */
0: 		currCE = 0;
0: 		fileInput = false;
0: 		initialFileInput = false;
0: 		firstRun = true;
0: 	}
0: 
0: 
0: 	/**
0: 	 * run ij over the specified input, sending output to the
0: 	 * specified output. Any prior input and output will be lost.
0: 	 *
0: 	 * @param in source for input to ij
0: 	 * @param out sink for output from ij
0: 	 * @param connAttributeDefaults  connection attributes from -ca ij arg
0: 	 */
0: 	public void go(LocalizedInput[] in, LocalizedOutput out,
0: 				   Properties connAttributeDefaults) throws ijFatalException
0: 	{
0: 		boolean done = false;
0: 
0: 		String command = null;
0: 
0: 		this.out = out;
0: 		this.connAttributeDefaults = connAttributeDefaults;
0: 		
0: 		ijParser.setConnection(connEnv[currCE], (numConnections > 1));
0: 		fileInput = initialFileInput = (!in[currCE].isStandardInput());
0: 
0: 		for (int ictr = 0; ictr < commandGrabber.length; ictr++) {
0: 			commandGrabber[ictr].ReInit(in[ictr]);
0: 		}
0: 
0: 		if (firstRun) {
0: 
0: 			// figure out which version this is
0: 			InputStream versionStream = (InputStream) java.security.AccessController.doPrivileged(this);
0: 
0: 			// figure out which version this is
0: 			ProductVersionHolder ijVersion = 
0: 				ProductVersionHolder.getProductVersionHolderFromMyEnv(versionStream);
0: 
0: 			String version;
0: 			if (ijVersion != null)
0: 			{
0: 				version = "" + ijVersion.getMajorVersion() + "." +
0: 					ijVersion.getMinorVersion();
0: 			}
0: 			else
0: 			{
0: 				version = "?";
0: 			}
0: 
0:    			out.println(langUtil.getTextMessage("IJ_IjVers30C199", version));
0: 			for (int i=connEnv.length-1;i>=0;i--) { // print out any initial warnings...
0: 				Connection c = connEnv[i].getConnection();
0: 				if (c!=null) {
0: 					JDBCDisplayUtil.ShowWarnings(out,c);
0: 				}
0: 			}
0: 			firstRun = false;
0: 
0:       		//check if the property is set to not show select count and set the static variable
0:       		//accordingly. 
0:     		boolean showNoCountForSelect = Boolean.getBoolean("ij.showNoCountForSelect");
0:       		JDBCDisplayUtil.showSelectCount = !showNoCountForSelect;
0: 
0:       		//check if the property is set to not show initial connections and accordingly set the
0:       		//static variable.
0:     		boolean showNoConnectionsAtStart = Boolean.getBoolean("ij.showNoConnectionsAtStart");
0:       		if (!(showNoConnectionsAtStart)) {
0:          		try {
0:            			ijResult result = ijParser.showConnectionsMethod(true);
0:  					displayResult(out,result,connEnv[currCE].getConnection());
0:          		} catch (SQLException ex) {
0:            			handleSQLException(out,ex);
0:          		}
0:       		}
0:     	}
0: 
0: 		while (!ijParser.exit && !done) {
0: 			try{
0: 				ijParser.setConnection(connEnv[currCE], (numConnections > 1));
0: 			} catch(Throwable t){
0: 				//do nothing
0: 				}
0: 
0: 			connEnv[currCE].doPrompt(true, out);
0:    			try {
0: 				command = null;
0: 
0: 				out.flush();
0: 				command = commandGrabber[currCE].nextStatement();
0: 
0: 				// if there is no next statement,
0: 				// pop back to the top saved grabber.
0: 				while (command == null && ! oldGrabbers.empty()) {
0: 					// close the old input file if not System.in
0: 					if (fileInput) commandGrabber[currCE].close();
0: 					commandGrabber[currCE] = (StatementFinder)oldGrabbers.pop();
0: 					if (oldGrabbers.empty())
0: 						fileInput = initialFileInput;
0: 					command = commandGrabber[currCE].nextStatement();
0: 				}
0: 
0: 				// if there are no grabbers left,
0: 				// we are done.
0: 				if (command == null && oldGrabbers.empty()) {
0: 					done = true;
0: 				}
0: 				else {
0: 					boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
0: 					long	beginTime = 0;
0: 					long	endTime;
0: 
0: 					if (fileInput) {
0: 						out.println(command+";");
0: 						out.flush();
0: 					}
0: 
0: 					charStream.ReInit(new StringReader(command), 1, 1);
0: 					ijTokMgr.ReInit(charStream);
0: 					ijParser.ReInit(ijTokMgr);
0: 
0: 					if (elapsedTimeOn) {
0: 						beginTime = System.currentTimeMillis();
0: 					}
0: 
0: 					ijResult result = ijParser.ijStatement();
0: 					displayResult(out,result,connEnv[currCE].getConnection());
0: 
0: 					// if something went wrong, an SQLException or ijException was thrown.
0: 					// we can keep going to the next statement on those (see catches below).
0: 					// ijParseException means we try the SQL parser.
0: 
0: 					/* Print the elapsed time if appropriate */
0: 					if (elapsedTimeOn) {
0: 						endTime = System.currentTimeMillis();
0: 						out.println(langUtil.getTextMessage("IJ_ElapTime0Mil", 
0: 						langUtil.getNumberAsString(endTime - beginTime)));
0: 					}
0: 
0: 					// would like when it completes a statement
0: 					// to see if there is stuff after the ;
0: 					// and before the <EOL> that we will IGNORE
0: 					// (with a warning to that effect)
0: 				}
0: 
0:     			} catch (ParseException e) {
0: 					if (command != null) doCatch(command);
0: 				} catch (TokenMgrError e) {
0: 					if (command != null) doCatch(command);
0:     			} catch (SQLException e) {
0: 					// SQL exception occurred in ij's actions; print and continue
0: 					// unless it is considered fatal.
0: 					handleSQLException(out,e);
0:     			} catch (ijException e) {
0: 					// exception occurred in ij's actions; print and continue
0:     			  	out.println(langUtil.getTextMessage("IJ_IjErro0",e.getMessage()));
0: 					doTrace(e);
0:     			} catch (Throwable e) {
0:     			  	out.println(langUtil.getTextMessage("IJ_JavaErro0",e.toString()));
0: 					doTrace(e);
0: 				}
0: 
0: 			/* Go to the next connection/user, if there is one */
0: 			currCE = ++currCE % connEnv.length;
0: 		}
0: 
0: 		// we need to close all sessions when done; otherwise we have
0: 		// a problem when a single VM runs successive IJ threads
0: 		try {
0: 			for (int i = 0; i < connEnv.length; i++) {
0: 				connEnv[i].removeAllSessions();
0: 			}
0: 		} catch (SQLException se ) {
0: 			handleSQLException(out,se);
0: 		}
0: 		// similarly must close input files
0: 		for (int i = 0; i < numConnections; i++) {
0: 			try {
0: 				if (!in[i].isStandardInput() )
0: 					in[i].close();	
0: 			} catch (Exception e ) {
0:     			  	out.println(langUtil.getTextMessage("IJ_CannotCloseInFile",
0: 					e.toString()));
0: 			}
0: 		}
0: 
0: 		/*
0: 			If an exit was requested, then we will be shutting down.
0: 		 */
0: 		if (ijParser.exit || (initialFileInput && !mtUse)) {
0: 			Driver d = null;
0: 			try {
0: 			    d = DriverManager.getDriver("jdbc:derby:");
0: 			} catch (Exception e) {
0: 				d = null;
0: 			}
0: 			if (d!=null) { // do we have a driver running? shutdown on exit.
0: 				try {
0: 					DriverManager.getConnection("jdbc:derby:;shutdown=true");
0: 				} catch (SQLException e) {
0: 					// ignore the errors, they are expected.
0: 				}
0: 			}
0: 		}
0:   	}
0: 
0: 	private void displayResult(LocalizedOutput out, ijResult result, Connection conn) throws SQLException {
0: 		// display the result, if appropriate.
0: 		if (result!=null) {
0: 			if (result.isConnection()) {
0: 				if (result.hasWarnings()) {
0: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
0: 					result.clearSQLWarnings();
0: 				}
0: 			} else if (result.isStatement()) {
0: 				Statement s = result.getStatement();
0: 				try {
0: 				    JDBCDisplayUtil.DisplayResults(out,s,connEnv[currCE].getConnection());
0: 				} catch (SQLException se) {
0: 				    result.closeStatement();
0: 					throw se;
0: 				}
0: 				result.closeStatement();
0: 			} else if (result.isNextRowOfResultSet()) {
0: 				ResultSet r = result.getNextRowOfResultSet();
0: 				JDBCDisplayUtil.DisplayCurrentRow(out,r,connEnv[currCE].getConnection());
0: 			} else if (result.isVector()) {
0: 				util.DisplayVector(out,result.getVector());
0: 				if (result.hasWarnings()) {
0: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
0: 					result.clearSQLWarnings();
0: 				}
0: 			} else if (result.isMulti()) {
0: 			    try {
0: 				    util.DisplayMulti(out,(PreparedStatement)result.getStatement(),result.getResultSet(),connEnv[currCE].getConnection());
0: 				} catch (SQLException se) {
0: 				    result.closeStatement();
0: 					throw se;
0: 				}
0: 				result.closeStatement(); // done with the statement now
0: 				if (result.hasWarnings()) {
0: 					JDBCDisplayUtil.ShowWarnings(out,result.getSQLWarnings());
0: 					result.clearSQLWarnings();
0: 				}
0: 			} else if (result.isException()) {
0: 				JDBCDisplayUtil.ShowException(out,result.getException());
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * catch processing on failed commands. This really ought to
0: 	 * be in ij somehow, but it was easier to catch in Main.
0: 	 */
0: 	private void doCatch(String command) {
0: 		// this retries the failed statement
0: 		// as a JSQL statement; it uses the
0: 		// ijParser since that maintains our
0: 		// connection and state.
0: 
0: 	    try {
0: 			boolean	elapsedTimeOn = ijParser.getElapsedTimeState();
0: 			long	beginTime = 0;
0: 			long	endTime;
0: 
0: 			if (elapsedTimeOn) {
0: 				beginTime = System.currentTimeMillis();
0: 			}
0: 
0: 			ijResult result = ijParser.executeImmediate(command);
0: 			displayResult(out,result,connEnv[currCE].getConnection());
0: 
0: 			/* Print the elapsed time if appropriate */
0: 			if (elapsedTimeOn) {
0: 				endTime = System.currentTimeMillis();
0: 				out.println(langUtil.getTextMessage("IJ_ElapTime0Mil_4", 
0: 				langUtil.getNumberAsString(endTime - beginTime)));
0: 			}
0: 
0: 	    } catch (SQLException e) {
0: 			// SQL exception occurred in ij's actions; print and continue
0: 			// unless it is considered fatal.
0: 			handleSQLException(out,e);
0: 	    } catch (ijException i) {
0: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_5", i.getMessage()));
0: 			doTrace(i);
0: 		} catch (ijTokenException ie) {
0: 	  		out.println(langUtil.getTextMessage("IJ_IjErro0_6", ie.getMessage()));
0: 			doTrace(ie);
0: 	    } catch (Throwable t) {
0: 	  		out.println(langUtil.getTextMessage("IJ_JavaErro0_7", t.toString()));
0: 			doTrace(t);
0: 	    }
0: 	}
0: 
0: 	/**
0: 	 * This routine displays SQL exceptions and decides whether they
0: 	 * are fatal or not, based on the ignoreErrors field. If they
0: 	 * are fatal, an ijFatalException is thrown.
0: 	 * Lifted from ij/util.java:ShowSQLException
0: 	 */
0: 	public void handleSQLException(LocalizedOutput out, SQLException e) 
0: 		throws ijFatalException
0: 	{
0: 		String errorCode;
0: 		String sqlState = null;
0: 		SQLException fatalException = null;
0: 
0: 		if (Boolean.getBoolean("ij.showErrorCode")) {
0: 			errorCode = langUtil.getTextMessage("IJ_Erro0", 
0: 			langUtil.getNumberAsString(e.getErrorCode()));
0: 		}
0: 		else {
0: 			errorCode = "";
0: 		}
0: 
0: 		for (; e!=null; e=e.getNextException())
0: 		{
0: 			/*
0: 			** If we are to throw errors, then throw the exceptions
0: 			** that aren't in the ignoreErrors list.  If
0: 			** the ignoreErrors list is null we don't throw
0: 			** any errors.
0: 			*/
0: 		 	if (ignoreErrors != null) 
0: 			{
0: 				sqlState = e.getSQLState();
0: 				if ((sqlState != null) &&
0: 					(ignoreErrors.get(sqlState) != null))
0: 				{
0: 					continue;
0: 				}
0: 				else
0: 				{
0: 					fatalException = e;
0: 				}
0: 			}
0: 
0: 			String st1 = JDBCDisplayUtil.mapNull(e.getSQLState(),langUtil.getTextMessage("IJ_NoSqls"));
0: 			String st2 = JDBCDisplayUtil.mapNull(e.getMessage(),langUtil.getTextMessage("IJ_NoMess"));
0: 			out.println(langUtil.getTextMessage("IJ_Erro012",  st1, st2, errorCode));
0: 			JDBCDisplayUtil.doTrace(out, e);
0: 		}
0: 		if (fatalException != null)
0: 		{
0: 			throw new ijFatalException(fatalException);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * stack trace dumper
0: 	 */
0: 	private void doTrace(Throwable t) {
0: 		if (util.getSystemProperty("ij.exceptionTrace") != null) {
0: 			t.printStackTrace(out);
0: 		}
0: 		out.flush();
0: 	}
0: 
0: 	void newInput(String fileName) {
0: 		FileInputStream newFile = null;
0: 		try {
0: 			newFile = new FileInputStream(fileName);
0:       	} catch (FileNotFoundException e) {
0:         	throw ijException.fileNotFound();
0: 		}
0: 		if (newFile == null) return;
0: 
0: 		// if the file was opened, move to use it for input.
0: 		oldGrabbers.push(commandGrabber[currCE]);
0: 	    commandGrabber[currCE] = 
0:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(newFile, BUFFEREDFILESIZE)));
0: 		fileInput = true;
0: 	}
0: 
0: 	void newResourceInput(String resourceName) {
0: 		InputStream is = util.getResourceAsStream(resourceName);
0: 		if (is==null) throw ijException.resourceNotFound();
0: 		oldGrabbers.push(commandGrabber[currCE]);
0: 	    commandGrabber[currCE] = 
0:                 new StatementFinder(langUtil.getNewInput(new BufferedInputStream(is, BUFFEREDFILESIZE)));
0: 		fileInput = true;
0: 	}
0: 
0: 	/**
0: 	 * REMIND: eventually this might be part of StatementFinder,
0: 	 * used at each carriage return to show that it is still "live"
0: 	 * when it is reading multi-line input.
0: 	 */
0: 	static void doPrompt(boolean newStatement, LocalizedOutput out, String tag) 
0: 	 {
0: 		if (newStatement) {
0: 	  		out.print("ij"+(tag==null?"":tag)+"> ");
0: 		}
0: 		else {
0: 			out.print("> ");
0: 		}
0: 		out.flush();
0: 	}
0: 
0: 	void setMtUse(boolean b) {
0: 		mtUse = b;
0: 	}
0: 
0: 	// JDBC 2.0 support
0: 
0: 	/**
0: 	 * Return the right utilMain to use.  (JDBC 1.1 or 2.0)
0: 	 *
0: 	 */
0: 	public utilMain getUtilMain()
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Connections by default create ResultSet objects with holdability true. This method can be used
0: 	 * to change the holdability of the connection by passing one of ResultSet.HOLD_CURSORS_OVER_COMMIT
0: 	 * or ResultSet.CLOSE_CURSORS_AT_COMMIT. We implement this using reflection in jdk13 and lower
0: 	 *
0: 	 * @param conn			The connection.
0: 	 * @param holdType	The new holdability for the Connection object.
0: 	 *
0: 	 * @return	The connection object with holdability set to passed value.
0: 	 */
0: 	public Connection setHoldability(Connection conn, int holdType)
0: 		throws SQLException
0: 	{
0:     //Prior to db2 compatibility work, the default holdability for connections was close cursors over commit and all the tests
0:     //were written based on that assumption
0:     //Later, as part of db2 compatibility, we changed the default holdability for connection to hold cursors over commit.
0:     //But in order for the existing tests to work fine, the tests needed a way to set the holdability to close cursors for connections
0:     //Since there is no direct jdbc api in jdk13 and lower to do that, we are using reflection to set the holdability to close cursors
0:     try { //for jdks prior to jdk14, need to use reflection to set holdability to false. 
0:     	Method sh = conn.getClass().getMethod("setHoldability", CONN_PARAM);
0:     	sh.invoke(conn, CONN_ARG);
0:     } catch( Exception e) {
0:     	throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
0:     }
0:     return conn;
0: 	}
0: 
0: 	/**
0: 	 * Retrieves the current holdability of ResultSet objects created using this
0: 	 * Connection object. We implement this using reflection in jdk13 and lower
0: 	 *
0: 	 * @return  The holdability, one of ResultSet.HOLD_CURSORS_OVER_COMMIT
0: 	 * or ResultSet.CLOSE_CURSORS_AT_COMMIT
0: 	 *
0: 	 */
0: 	public int getHoldability(Connection conn)
0: 		throws SQLException
0: 	{
0:     //this method is used to make sure we are not trying to create a statement with holdability different than the connection holdability
0:     //This is because jdk13 and lower does not have support for that.
0:     //The holdability of connection and statement can differ if connection holdability is set to close cursor on commit using reflection
0:     //and statement is getting created with holdability true
0:     //Another instance of holdability of connection and statement not being same is when connection holdability is hold cursor
0:     //over commit and statement is being created with holdability false
0:     int defaultHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
0:     try {
0:     	Method sh = conn.getClass().getMethod("getHoldability", null);
0:     	defaultHoldability = ((Integer)sh.invoke(conn, null)).intValue();
0:     } catch( Exception e) {
0:     	throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
0:     }
0:     return defaultHoldability;
0: 	}
0: 
0: 	/**
0: 	 * Create the right kind of statement (scrolling or not)
0: 	 * off of the specified connection.
0: 	 *
0: 	 * @param conn			The connection.
0: 	 * @param scrollType	The scroll type of the cursor.
0: 	 *
0: 	 * @return	The statement.
0: 	 */
0: 	public Statement createStatement(Connection conn, int scrollType, int holdType)
0: 		throws SQLException
0: 	{
0:     	//following if is used to make sure we are not trying to create a statement with holdability different that the connection
0:     	//holdability. This is because jdk13 and lower does not have support for that.
0:     	//The holdability of connection and statement can differ if connection holdability is set to close cursor on commit using reflection
0:     	//and statement is getting created with holdability true
0:     	//Another instance of holdability of connection and statement not being same is when connection holdability is hold cursor
0:     	//over commit and statement is being created with holdability false
0:     	if (holdType != getHoldability(conn))
0:     	{
0:         	throw ijException.holdCursorsNotSupported();
0:     	}
0:       
0:     	Statement stmt;
0:         try {
0:         	stmt = conn.createStatement(scrollType, JDBC20Translation.CONCUR_READ_ONLY);
0:         } catch(AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:         	stmt = conn.createStatement();
0:         }
0: 		return stmt;
0: 	}
0: 
0: 	/**
0: 	 * Position on the specified row of the specified ResultSet.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 * @param row	The row # to move to.
0: 	 *				(Negative means from the end of the result set.)
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(absolute() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult absolute(ResultSet rs, int row)
0: 		throws SQLException
0: 	{
0:         boolean forwardOnly;
0:     	try {
0: 		// absolute is only allowed on scroll cursors
0: 		    forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0:         if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("ABSOLUTE");
0: 		}
0: 
0: 		// 0 is an invalid value for row
0: 		if (row == 0)
0: 		{
0: 			throw ijException.zeroInvalidForAbsolute();
0: 		}
0: 
0: 		return new ijRowResult(rs, rs.absolute(row));
0: 	}
0: 
0: 	/**
0: 	 * Move the cursor position by the specified amount.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 * @param row	The # of rows to move.
0: 	 *				(Negative means toward the beginning of the result set.)
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(relative() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult relative(ResultSet rs, int row)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// relative is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("RELATIVE");
0: 		}
0: 
0: 		return new ijRowResult(rs, rs.relative(row));
0: 	}
0: 
0: 	/**
0: 	 * Position before the first row of the specified ResultSet
0: 	 * and return NULL to the user.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(beforeFirst() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult beforeFirst(ResultSet rs)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// before first is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("BEFORE FIRST");
0: 		}
0: 
0: 		rs.beforeFirst();
0: 		return new ijRowResult(rs, false);
0: 	}
0: 
0: 	/**
0: 	 * Position on the first row of the specified ResultSet
0: 	 * and return that row to the user.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	The first row of the ResultSet.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(first() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult first(ResultSet rs)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// first is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("FIRST");
0: 		}
0: 
0: 		return new ijRowResult(rs, rs.first());
0: 	}
0: 
0: 	/**
0: 	 * Position after the last row of the specified ResultSet
0: 	 * and return NULL to the user.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(afterLast() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult afterLast(ResultSet rs)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// after last is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("AFTER LAST");
0: 		}
0: 
0: 		rs.afterLast();
0: 		return new ijRowResult(rs, false);
0: 	}
0: 
0: 	/**
0: 	 * Position on the last row of the specified ResultSet
0: 	 * and return that row to the user.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	The last row of the ResultSet.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(last() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult last(ResultSet rs)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// last is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("LAST");
0: 		}
0: 
0: 		return new ijRowResult(rs, rs.last());
0: 	}
0: 
0: 	/**
0: 	 * Position on the previous row of the specified ResultSet
0: 	 * and return that row to the user.
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	The previous row of the ResultSet.
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(previous() not supported pre-JDBC2.0)
0: 	 */
0: 	public ijResult previous(ResultSet rs)
0: 		throws SQLException
0: 	{
0:     	boolean forwardOnly;
0:         try {
0:         	forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0:         } catch (AbstractMethodError ame) {
0:         //because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0:         //to jdbc 1.x functionality
0:             forwardOnly = true;
0:         }
0: 		// first is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("PREVIOUS");
0: 		}
0: 
0: 		return new ijRowResult(rs, rs.previous());
0: 	}
0: 
0: 	/**
0: 	 * Get the current row number
0: 	 *
0: 	 * @param rs	The specified ResultSet.
0: 	 *
0: 	 * @return	The current row number
0: 	 *
0: 	 * @exception	SQLException thrown on error.
0: 	 *				(getRow() not supported pre-JDBC2.0)
0: 	 */
0: 	public int getCurrentRowNumber(ResultSet rs)
0: 		throws SQLException
0: 	{
0: 		boolean forwardOnly;
0: 		try 
0: 		{
0: 			forwardOnly = (rs.getStatement().getResultSetType() == JDBC20Translation.TYPE_FORWARD_ONLY);
0: 		} catch (AbstractMethodError ame) 
0: 		{
0: 			//because weblogic 4.5 doesn't yet implement jdbc 2.0 interfaces, need to go back
0: 			//to jdbc 1.x functionality
0: 			forwardOnly = true;
0:         }
0: 
0: 		// getCurrentRow is only allowed on scroll cursors
0: 		if (forwardOnly)
0: 		{
0: 			throw ijException.forwardOnlyCursor("GETCURRENTROWNUMBER");
0: 		}
0: 
0: 		return rs.getRow();
0: 	}
0: 
0: 	public Properties getConnAttributeDefaults ()
0: 	{
0: 		return connAttributeDefaults;
0: 	}
0: 
0: 	public final Object run() {
0: 		return  getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);
0: 	}
0: }
============================================================================