1:eac0369: /*
27:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.RowResultSetNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:43fdf45: import java.util.ArrayList;
1:47d4a4c: import java.util.List;
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:eac0369: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:7a27cab: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:7a27cab: import org.apache.derby.iapi.types.TypeId;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:7a27cab: 
4:eac0369: /**
1:eac0369:  * A RowResultSetNode represents the result set for a VALUES clause.
13:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class RowResultSetNode extends FromTable
7:eac0369: {
1:eac0369: 	SubqueryList subquerys;
1:71c8e86:     private List<AggregateNode> aggregates;
1:b4cda60: 
1:b4cda60:     QueryExpressionClauses qec = new QueryExpressionClauses();
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a RowResultSetNode.
1:eac0369: 	 *
1:eac0369: 	 * @param valuesClause	The result column list for the VALUES clause.
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:3bb140c:     RowResultSetNode(ResultColumnList valuesClause,
1:3bb140c:                      Properties tableProperties,
1:3bb140c:                      ContextManager cm) {
1:3bb140c:         super(null /* correlationName */, tableProperties, cm);
1:11f7ee3:         setResultColumns( valuesClause );
1:3bb140c: 
1:11f7ee3:         if (getResultColumns() != null) {
1:11f7ee3: 			getResultColumns().markInitialSize();
1:3bb140c:         }
1:4d044a3: 	}
1:4d044a3: 
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "VALUES";
1:4d044a3: 	}
1:4d044a3: 
1:a8db665: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:1a58030:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (subquerys != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "subquerys: ");
1:eac0369: 				subquerys.treePrint(depth + 1);
1:4d044a3: 			}
1:4d044a3: 
1:b4cda60:             printQueryExpressionSuffixClauses(depth, qec);
1:4d044a3: 		}
1:4d044a3: 	}
1:4d044a3: 
1:b4cda60:     @Override
1:1a58030:     public boolean referencesSessionSchema() throws StandardException {
1:1a58030:         return subquerys != null && subquerys.referencesSessionSchema();
1:1a58030:     }
1:1a58030: 
1:108305b: 	/**
1:a8db665: 	 * Modify the RCL of this node to match the target of the insert.
1:a8db665: 	 */
1:3bb140c:     @Override
1:a8db665: 	ResultSetNode enhanceRCLForInsert(
1:a8db665: 			InsertNode target, boolean inOrder, int[] colMap)
1:a8db665: 		throws StandardException
1:a8db665: 	{
1:11f7ee3: 		if (!inOrder || getResultColumns().size() < target.resultColumnList.size()) {
1:11f7ee3: 			setResultColumns( getRCLForInsert(target, colMap) );
1:a8db665: 		}
1:a8db665: 		return this;
1:a8db665: 	}
1:4d044a3: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:4d044a3: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#estimateCost
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1:eac0369: 										ConglomerateDescriptor cd,
1:eac0369: 										CostEstimate outerCost,
1:eac0369: 										Optimizer optimizer,
1:eac0369: 										RowOrdering rowOrdering)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Assume for now that the cost of a VALUES clause is zero, with one row
1:eac0369: 		** fetched.  Is this true, and if not, does it make a difference?
1:eac0369: 		** There's nothing to optimize in this case.
1:eac0369: 		*/
1:11f7ee3: 		if (getCostEstimate() == null)
1:eac0369: 		{
1:11f7ee3: 			setCostEstimate( getOptimizerFactory().getCostEstimate() );
11:eac0369: 		}
1:7a27cab: 
1:11f7ee3: 		getCostEstimate().setCost(0.0d, 1.0d, 1.0d);
1:eac0369: 
1:eac0369: 		/* A single row is always ordered */
1:eac0369: 		rowOrdering.optimizableAlwaysOrdered(this);
1:eac0369: 
1:11f7ee3: 		return getCostEstimate();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the non VTI tables in this ResultSetNode.  This includes getting their
1:eac0369: 	 * descriptors from the data dictionary and numbering them.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for binding
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
1:eac0369: 							FromList fromListParam) 
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Assign the tableNumber */
1:eac0369: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1:eac0369: 			tableNumber = getCompilerContext().getNextTableNumber();
1:eac0369: 
1:eac0369: 		/* VALUES clause has no tables, so nothing to do */
2:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in this RowResultSetNode.  This means binding the
1:eac0369: 	 * sub-expressions, as well as figuring out what the return type is
1:eac0369: 	 * for each expression.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressions(FromList fromListParam)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		int nestingLevel;
1:eac0369: 
1:3bb140c:         subquerys = new SubqueryList(getContextManager());
1:eac0369: 
1:71c8e86:         aggregates = new ArrayList<AggregateNode>();
1:eac0369: 
1:eac0369: 		/* Verify that there are no DEFAULTs in the RCL.
1:eac0369: 		 * DEFAULT is only valid for an insert, and it has
1:eac0369: 		 * already been coverted into the tree by the time we get here.
1:eac0369: 		 * The grammar allows:
1:eac0369: 		 *		VALUES DEFAULT;
1:eac0369: 		 * so we need to check for that here and throw an exception if found.
1:eac0369: 		 */
1:11f7ee3: 		getResultColumns().checkForInvalidDefaults();
1:eac0369: 
1:eac0369: 		/* Believe it or not, a values clause can contain correlated column references
1:eac0369: 		 * and subqueries.  In order to get correlated column resolution working 
1:eac0369: 		 * correctly, we need to set our nesting level to be 1 deeper than the current
1:eac0369: 		 * level and push ourselves into the FROM list.  
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* Set the nesting level in this node */
1:eac0369: 		if (fromListParam.size() == 0)
1:eac0369: 		{
1:eac0369: 			nestingLevel = 0;
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			nestingLevel = ((FromTable) fromListParam.elementAt(0)).getLevel() + 1;
1:eac0369: 		}
1:eac0369: 		setLevel(nestingLevel);
1:eac0369: 		fromListParam.insertElementAt(this, 0);
1:11f7ee3: 		getResultColumns().bindExpressions(fromListParam, subquerys,
1:09c2697:                                       aggregates);
1:eac0369: 		// Pop ourselves back out of the FROM list
1:eac0369: 		fromListParam.removeElementAt(0);
1:eac0369: 
1:09c2697:         if (!aggregates.isEmpty())
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_NO_AGGREGATES_IN_WHERE_CLAUSE);
1:eac0369: 		}
1:7a9ce7e: 
1:11f7ee3: 		SelectNode.checkNoWindowFunctions(getResultColumns(), "VALUES");
1:eac0369: 
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:eac0369: 
1:b4cda60:             if (obl != null) {
1:b4cda60:                 obl.pullUpOrderByColumns(this);
1:b4cda60:                 obl.bindOrderByColumns(this);
1:b4cda60:             }
1:b4cda60: 
1:b4cda60:             bindOffsetFetch(qec.getOffset(i), qec.getFetchFirst(i));
1:b4cda60:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
1:eac0369: 	 * sub-expressions, as well as figuring out what the return type is for
1:eac0369: 	 * each expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromListParam		FromList to use/append to.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressionsWithTables(FromList fromListParam)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We don't have any tables, so just return */
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind the expressions in the target list.  This means binding the
1:eac0369: 	 * sub-expressions, as well as figuring out what the return type is
1:eac0369: 	 * for each expression.  This is useful for EXISTS subqueries, where we
1:eac0369: 	 * need to validate the target list before blowing it away and replacing
1:eac0369: 	 * it with a SELECT true.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindTargetExpressions(FromList fromListParam)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		bindExpressions(fromListParam);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1:eac0369: 	 *
1:eac0369: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** If bindingRCL is null, then we are
1:eac0369: 		** under a cursor node that is inferring
1:eac0369: 		** its RCL from us.  It passes null to
1:eac0369: 		** get union to use both sides of the union
1:eac0369: 		** for the check.  Anyway, since there is
1:eac0369: 		** nothing under us but an RCL, just pass
1:eac0369: 		** in our RCL.
1:eac0369: 		*/
1:eac0369: 		if (bindingRCL == null)
1:11f7ee3: 			bindingRCL = getResultColumns();
1:eac0369: 
1:11f7ee3: 		getResultColumns().bindUntypedNullsToResultColumns(bindingRCL);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Try to find a ResultColumn in the table represented by this FromTable
1:eac0369: 	 * that matches the name in the given ColumnReference.
1:eac0369: 	 *
1:eac0369: 	 * @param columnReference	The columnReference whose name we're looking
1:eac0369: 	 *				for in the given table.
1:eac0369: 	 *
1:eac0369: 	 * @return	A ResultColumn whose expression is the ColumnNode
1:eac0369: 	 *			that matches the ColumnReference.
1:eac0369: 	 *		Returns null if there is no match.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultColumn getMatchingColumn(
1:eac0369: 						ColumnReference columnReference)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the exposed name for this table, which is the name that can
1:eac0369: 	 * be used to refer to it in the rest of the query.
1:eac0369: 	 *
1:eac0369: 	 * @return	The exposed name of this table.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getExposedName() throws StandardException
1:eac0369: 	{
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that a SELECT * is valid for this type of subquery.
1:eac0369: 	 *
1:eac0369: 	 * @param outerFromList	The FromList from the outer query block(s)
1:eac0369: 	 * @param subqueryType	The subquery type
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void verifySelectStarSubquery(FromList outerFromList, int subqueryType)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:b4cda60:     public void pushQueryExpressionSuffix() {
1:b4cda60:         qec.push();
1:b4cda60:     }
1:b4cda60: 
1:eac0369: 	/**
1:eac0369: 	 * Push the order by list down from the cursor node
1:eac0369: 	 * into its child result set so that the optimizer
1:eac0369: 	 * has all of the information that it needs to 
1:eac0369: 	 * consider sort avoidance.
1:eac0369: 	 *
1:eac0369: 	 * @param orderByList	The order by list
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void pushOrderByList(OrderByList orderByList)
1:eac0369: 	{
1:b4cda60:         qec.setOrderByList(orderByList);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:108305b:      * Push down the offset and fetch first parameters, if any, to this node.
1:108305b:      *
1:108305b:      * @param offset    the OFFSET, if any
1:108305b:      * @param fetchFirst the OFFSET FIRST, if any
1:57c1b5c:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:108305b:      */
1:3bb140c:     @Override
1:57c1b5c:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:108305b:     {
1:b4cda60:         qec.setOffset(offset);
1:b4cda60:         qec.setFetchFirst(fetchFirst);
1:b4cda60:         qec.setHasJDBCLimitClause(hasJDBClimitClause);
1:108305b:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:eac0369: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:eac0369: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:eac0369: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:eac0369: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:eac0369: 	 * which points to the FromTable and the ResultColumn that is the source for
1:eac0369: 	 * the ColumnReference.  
1:eac0369: 	 * (The new PRN will have the original of the ResultColumnList and
1:eac0369: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:eac0369: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:eac0369: 	 * will remain at the FromTable, with the PRN getting a new 
1:eac0369: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:eac0369: 	 * We then project out the non-referenced columns.  If there are no referenced
1:eac0369: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:eac0369: 	 * whose expression is 1.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:09c30dd:         getResultColumns().preprocess(
1:3bb140c:                 numTables,
1:09c30dd:                 fromList,
1:09c30dd:                 subquerys,
1:3bb140c:                 new PredicateList(getContextManager()));
1:eac0369: 
1:eac0369: 		/* Allocate a dummy referenced table map */ 
1:11f7ee3: 		setReferencedTableMap( new JBitSet(numTables) );
1:11f7ee3: 		getReferencedTableMap().set(tableNumber);
1:4d044a3: 
1:4d044a3:         // If we have more than 1 ORDERBY columns, we may be able to
1:4d044a3:         // remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1:4d044a3:         // Well, not very likely here, since we're here:
1:4d044a3:         //     VALUES x followed by ORDER BY 1,1,2
1:4d044a3:         // but for completeness...
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:b4cda60: 
1:b4cda60: 
1:b4cda60:             if (obl != null && obl.size() > 1) {
1:b4cda60:                 obl.removeDupColumns();
1:b4cda60:             }
1:4d044a3:         }
1:4d044a3: 
1:4d044a3:         return this;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Ensure that the top of the RSN tree has a PredicateList.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			The number of tables in the query.
1:eac0369: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode ensurePredicateList(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return genProjectRestrict(numTables);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add a new predicate to the list.  This is useful when doing subquery
1:eac0369: 	 * transformations, when we build a new predicate with the left side of
1:eac0369: 	 * the subquery operator and the subquery's result column.
1:eac0369: 	 *
1:eac0369: 	 * @param predicate		The predicate to add
1:eac0369: 	 *
1:eac0369: 	 * @return ResultSetNode	The new top of the tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode addNewPredicate(Predicate predicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		PredicateList		predList;
1:eac0369: 		ResultColumnList	prRCList;
1:eac0369: 		ResultSetNode		newPRN;
1:eac0369: 		
1:eac0369: 		/* We are the body of a quantified predicate subquery.  We
1:eac0369: 		 * need to generate (and return) a PRN above us so that there will be
1:eac0369: 		 * a place to attach the new predicate.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		/* We get a shallow copy of the ResultColumnList and its 
1:eac0369: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1:eac0369: 		 */
1:11f7ee3: 		prRCList = getResultColumns();
1:11f7ee3: 		setResultColumns( getResultColumns().copyListAndObjects() );
1:eac0369: 
1:eac0369: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1:eac0369: 		 * in the ProjectRestrictNode's ResultColumnList.  (VirtualColumnNodes include
1:eac0369: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
1:eac0369: 		 */
1:11f7ee3: 		prRCList.genVirtualColumnNodes(this, getResultColumns());
1:eac0369: 
1:eac0369: 		/* Put the new predicate in a list */
1:3bb140c:         predList = new PredicateList(getContextManager());
1:eac0369: 		predList.addPredicate(predicate);
1:eac0369: 
1:3bb140c:         return new ProjectRestrictNode(
1:eac0369: 								this,
1:eac0369: 								prRCList,
1:eac0369: 								null,	/* Restriction */
1:eac0369: 								predList,   /* Restriction as PredicateList */
1:eac0369: 								null,	/* Project subquery list */
1:eac0369: 								null,	/* Restrict subquery list */
1:3bb140c: 								tableProperties,
1:eac0369: 								getContextManager()				 );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1:eac0369: 	 * Currently, a FSqry is flattenable if all of the following are true:
1:eac0369: 	 *		o  Subquery is a SelectNode or a RowResultSetNode (not a UnionNode)
1:eac0369: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1:eac0369: 	 *		o  It does not contain a group by or having clause
1:eac0369: 	 *		o  It does not contain aggregates.
1:eac0369: 	 *		o  There is at least one result set in the from list that is
1:eac0369: 	 *		   not a RowResultSetNode (the reason is to avoid having
1:eac0369: 	 *		   an outer SelectNode with an empty FromList.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList	The outer from list
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean flattenableInFromSubquery(FromList fromList)
1:eac0369: 	{
1:eac0369: 		if ((subquerys != null) &&
1:eac0369: 			(subquerys.size() > 0))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:09c2697:         if ((aggregates != null) && !aggregates.isEmpty())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Don't flatten if select list contains something
1:eac0369: 		** that isn't clonable
1:eac0369: 		*/
1:11f7ee3: 		if ( ! getResultColumns().isCloneable())
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean nonRowResultSetFound = false;
1:eac0369: 		int flSize = fromList.size();
1:eac0369: 		for (int index = 0; index < flSize; index++)
1:eac0369: 		{
1:eac0369: 			FromTable ft = (FromTable) fromList.elementAt(index);
1:eac0369: 
1:eac0369: 			if (ft instanceof FromSubquery)
1:eac0369: 			{
1:eac0369: 				ResultSetNode subq = ((FromSubquery) ft).getSubquery();
1:eac0369: 				if ( ! (subq instanceof RowResultSetNode))
1:eac0369: 				{
1:eac0369: 					nonRowResultSetFound = true;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				nonRowResultSetFound = true;
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return nonRowResultSetFound;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize this SelectNode.  This means choosing the best access path
1:eac0369: 	 * for each table, among other things.
1:eac0369: 	 *
1:eac0369: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:eac0369: 	 * @param predicateList		The predicate list to optimize against
1:eac0369: 	 * @param outerRows			The number of outer joining rows
1:eac0369: 	 *
1:eac0369: 	 * @return	ResultSetNode	The top of the optimized tree
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:eac0369: 								  PredicateList	predicateList,
1:eac0369: 								  double outerRows) 
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Get an optimizer.  The only reason we need one is to get a
1:eac0369: 		** CostEstimate object, so we can represent the cost of this node.
1:eac0369: 		** This seems like overkill, but it's just an object allocation...
1:eac0369: 		*/
1:11f7ee3:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:3bb140c: 
1:eac0369: 		// RESOLVE: THE COST SHOULD TAKE SUBQUERIES INTO ACCOUNT
1:11f7ee3: 		getCostEstimate().setCost(0.0d, outerRows, outerRows);
1:eac0369: 
1:eac0369: 		subquerys.optimize(dataDictionary, outerRows);
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#modifyAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* For most types of Optimizable, do nothing */
1:eac0369: 		return (Optimizable) modifyAccessPaths();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSetNode#modifyAccessPaths
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode modifyAccessPaths() throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultSetNode treeTop = this;
1:eac0369: 
1:eac0369: 		subquerys.modifyAccessPaths();
1:eac0369: 
1:eac0369: 		/* Generate the OrderByNode if a sort is still required for
1:eac0369: 		 * the order by.
1:eac0369: 		 */
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:b4cda60:             if (obl != null) {
1:b4cda60:                 treeTop = new OrderByNode(treeTop,
1:b4cda60:                         obl,
1:b4cda60:                         tableProperties,
1:b4cda60:                         getContextManager());
1:b4cda60:             }
1:108305b: 
1:b4cda60:             final ValueNode offset = qec.getOffset(i);
1:b4cda60:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1:b4cda60:             Boolean hasJDBClimitClause = qec.getHasJDBCLimitClause()[i];
1:108305b: 
1:b4cda60:             if (offset != null || fetchFirst != null) {
1:b4cda60:                 ResultColumnList newRcl =
1:b4cda60:                     treeTop.getResultColumns().copyListAndObjects();
1:b4cda60:                 newRcl.genVirtualColumnNodes(
1:b4cda60:                     treeTop, treeTop.getResultColumns());
1:b4cda60: 
1:b4cda60:                 treeTop = new RowCountNode(
1:b4cda60:                         treeTop,
1:b4cda60:                         newRcl,
1:b4cda60:                         offset,
1:b4cda60:                         fetchFirst,
1:b4cda60:                         hasJDBClimitClause.booleanValue(),
1:b4cda60:                         getContextManager());
1:b4cda60:             }
1:108305b:         }
1:108305b: 
1:eac0369: 		return treeTop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this ResultSet tree is guaranteed to return
1:eac0369: 	 * at most 1 row based on heuristics.  (A RowResultSetNode and a
1:eac0369: 	 * SELECT with a non-grouped aggregate will return at most 1 row.)
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this ResultSet tree is guaranteed to return
1:eac0369: 	 * at most 1 row based on heuristics.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	boolean returnsAtMostOneRow()
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:7a27cab: 
1:7a27cab: 	/**
1:7a27cab: 	 * Set the type of each parameter in the result column list for this table constructor.
1:7a27cab: 	 *
1:7a27cab: 	 * @param typeColumns	The ResultColumnList containing the desired result
1:7a27cab: 	 *						types.
1:7a27cab: 	 *
1:7a27cab: 	 * @exception StandardException		Thrown on error
1:7a27cab: 	 */
1:3bb140c:     @Override
1:7a27cab: 	void setTableConstructorTypes(ResultColumnList typeColumns)
1:7a27cab: 			throws StandardException
1:7a27cab: 	{
1:7a27cab: 		if (SanityManager.DEBUG)
1:11f7ee3: 			SanityManager.ASSERT(getResultColumns().visibleSize() <= typeColumns.size(),
1:7a27cab: 				"More columns in ResultColumnList than in base table");
1:7a27cab: 
1:7a27cab: 		/* Look for ? parameters in the result column list */
1:11f7ee3: 		int rclSize = getResultColumns().size();
1:7a27cab: 		for (int index = 0; index < rclSize; index++)
1:7a27cab: 		{
1:11f7ee3:             ResultColumn rc = getResultColumns().elementAt(index);
1:7a27cab: 			ValueNode re = rc.getExpression();
1:7a27cab: 
1:7a27cab: 			if (re.requiresTypeFromContext())
1:7a27cab: 			{
1:e1f49ca:                 ResultColumn typeCol = typeColumns.elementAt(index);
1:7a27cab: 				/*
1:7a27cab: 				** We found a ? - set its type to the type of the
1:7a27cab: 				** corresponding column of the target table.
1:7a27cab: 				*/
1:7a27cab: 				re.setType(typeCol.getTypeServices());
1:7a27cab: 			}
1:7a27cab: 			else if (re instanceof CharConstantNode)
1:7a27cab: 			{
1:7a27cab: 				// Character constants are of type CHAR (fixed length string).
1:7a27cab: 				// This causes a problem (beetle 5160) when multiple row values are provided
1:7a27cab: 				// as constants for insertion into a variable length string column.
1:7a27cab: 				//
1:7a27cab: 				// This issue is the query expression
1:7a27cab: 				// VALUES 'abc', 'defghi'
1:7a27cab: 				// has type of CHAR(6), ie. the length of largest row value for that column.
1:7a27cab: 				// This is from the UNION defined behaviour.
1:7a27cab: 				// This causes strings with less than the maximum length to be blank padded
1:7a27cab: 				// to that length (CHAR semantics). Thus if this VALUES clause is used to
1:7a27cab: 				// insert into a variable length string column, then these blank padded values
1:7a27cab: 				// are inserted, which is not what is required ...
1:7a27cab: 				//
1:7a27cab: 				// BECAUSE, when the VALUES is used as a table constructor SQL standard says the
1:7a27cab: 				// types of the table constructor's columns are set by the table's column types.
1:7a27cab: 				// Thus, in this case, each of those string constants should be of type VARCHAR
1:7a27cab: 				// (or the matching string type for the table).
1:7a27cab: 				//
1:7a27cab: 				//
1:7a27cab: 				// This is only an issue for fixed length character (CHAR, BIT) string or
1:7a27cab: 				// binary consraints being inserted into variable length types.
1:7a27cab: 				// This is because any other type's fundemental literal value is not affected
1:7a27cab: 				// by its data type. E.g. Numeric types such as INT, REAL, BIGINT, DECIMAL etc.
1:7a27cab: 				// do not have their value modifed by the union since even if the type is promoted
1:7a27cab: 				// to a higher type, its fundemental value remains unchanged.
1:7a27cab: 				// values (1.2, 34.4567, 234.47) will be promoted to
1:7a27cab: 				// values (1.2000, 34.4567, 234.4700)
1:7a27cab: 				// but their numeric value remains the same.
1:7a27cab: 				//
1:7a27cab: 				//
1:7a27cab: 				//
1:7a27cab: 				// The fix is to change the base type of the table constructor's value to
1:7a27cab: 				// match the column type. Its length can be left as-is, because there is
1:7a27cab: 				// still a normailzation step when the value is inserted into the table.
1:7a27cab: 				// That will set the correct length and perform truncation checks etc.
1:7a27cab: 
1:e1f49ca:                 ResultColumn typeCol = typeColumns.elementAt(index);
1:7a27cab: 
2:7a27cab: 				TypeId colTypeId = typeCol.getTypeId();
1:7a27cab: 
1:7a27cab: 				if (colTypeId.isStringTypeId()) {
1:7a27cab: 
1:7a27cab: 					if (colTypeId.getJDBCTypeId() != java.sql.Types.CHAR) {
1:7a27cab: 
1:7a27cab: 						int maxWidth = re.getTypeServices().getMaximumWidth();
1:7a27cab: 
1:7a27cab: 						re.setType(new DataTypeDescriptor(colTypeId, true, maxWidth));
1:7a27cab: 					}
1:7a27cab: 				}
1:7a27cab: 				else if (colTypeId.isBitTypeId()) {
1:7a27cab: 					if (colTypeId.getJDBCTypeId() == java.sql.Types.VARBINARY) {
1:7a27cab: 					// then we're trying to cast a char literal into a
1:7a27cab: 					// variable bit column.  We can't change the base
1:7a27cab: 					// type of the table constructor's value from char
1:7a27cab: 					// to bit, so instead, we just change the base type
1:7a27cab: 					// of that value from char to varchar--that way,
1:7a27cab: 					// no padding will be added when we convert to
1:7a27cab: 					// bits later on (Beetle 5306).
1:7a27cab: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.VARCHAR);
1:7a27cab: 						re.setType(new DataTypeDescriptor(tId, true));
1:7a27cab: 						typeColumns.setElementAt(typeCol, index);
1:7a27cab: 					}
1:7a27cab: 					else if (colTypeId.getJDBCTypeId() == java.sql.Types.LONGVARBINARY) {
1:7a27cab: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.LONGVARCHAR);
1:7a27cab: 						re.setType(new DataTypeDescriptor(tId, true));
1:7a27cab: 						typeColumns.setElementAt(typeCol, index);
1:7a27cab: 					}
1:7a27cab: 				}
1:7a27cab: 
1:7a27cab: 			}
1:7a27cab: 			else if (re instanceof BitConstantNode)
1:7a27cab: 			{
1:e1f49ca:                 ResultColumn typeCol   = typeColumns.elementAt(index);
1:e1f49ca:                 TypeId       colTypeId = typeCol.getTypeId();
1:7a27cab: 
1:7a27cab: 				if (colTypeId.isBitTypeId()) {
1:7a27cab: 
1:7a27cab: 					// NOTE: Don't bother doing this if the column type is BLOB,
1:7a27cab: 					// as we don't allow bit literals to be inserted into BLOB
1:7a27cab: 					// columns (they have to be explicitly casted first); beetle 5266.
1:7a27cab: 					if ((colTypeId.getJDBCTypeId() != java.sql.Types.BINARY) &&
1:7a27cab: 						(colTypeId.getJDBCTypeId() != java.sql.Types.BLOB)) {
1:7a27cab: 
1:7a27cab: 						int maxWidth = re.getTypeServices().getMaximumWidth();
1:7a27cab: 
1:7a27cab: 						re.setType(new DataTypeDescriptor(colTypeId, true, maxWidth));
1:7a27cab: 					}
1:7a27cab: 				}
1:7a27cab: 				else if (colTypeId.isStringTypeId()) {
1:7a27cab: 					if (colTypeId.getJDBCTypeId() == java.sql.Types.VARCHAR) {
1:7a27cab: 					// then we're trying to cast a bit literal into a
1:7a27cab: 					// variable char column.  We can't change the base
1:7a27cab: 					// type of the table constructor's value from bit
1:7a27cab: 					// to char, so instead, we just change the base
1:7a27cab: 					// type of that value from bit to varbit--that way,
1:7a27cab: 					// no padding will be added when we convert to
1:7a27cab: 					// char later on.
1:7a27cab: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.VARBINARY);
1:7a27cab: 						re.setType(new DataTypeDescriptor(tId, true));
1:7a27cab: 						typeColumns.setElementAt(typeCol, index);
1:7a27cab: 					}
1:7a27cab: 					else if (colTypeId.getJDBCTypeId() == java.sql.Types.LONGVARCHAR) {
1:7a27cab: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.LONGVARBINARY);
1:7a27cab: 						re.setType(new DataTypeDescriptor(tId, true));
1:7a27cab: 						typeColumns.setElementAt(typeCol, index);
1:7a27cab: 					}
1:7a27cab: 				}
1:7a27cab: 			}
1:7a27cab: 		}
1:7a27cab: 	}
1:7a27cab: 
1:eac0369:     /**
1:eac0369:      * The generated ResultSet will be:
1:eac0369:      *
1:eac0369:      *      RowResultSet -- for the VALUES clause
1:eac0369:      *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
1:7a27cab: 
1:ab10884: 		// Get our final cost estimate.
1:11f7ee3: 		setCostEstimate( getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Check and see if everything below us is a constant or not.
1:eac0369: 		** If so, we'll let execution know that it can do some caching.
1:eac0369: 		** Before we do the check, we are going to temporarily set
1:eac0369: 		*/
1:eac0369: 		boolean canCache = canWeCacheResults();
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:eac0369: 	    // we are dealing with
1:eac0369: 		// VALUES(value1, value2, value3)
1:eac0369: 	    // so we generate a RowResultSet to return the values listed.
1:eac0369: 
1:eac0369: 		// we can reduce the tree to one RowResultSet
1:eac0369:     	// since there is nothing but the resultColumns
1:eac0369: 
1:eac0369:     	// RowResultSet takes the row-generating function
1:eac0369:     	// so we generate one and get back the expression
1:eac0369:     	// pointing to it.
1:eac0369: 	    //
1:eac0369: 		// generate the expression to return, which is:
1:eac0369: 		// ResultSetFactory.getRowResultSet(this, planX.exprN)
1:eac0369: 		// [planX is the name of the class being generated,
1:eac0369:     	// exprN is the name of the function being generated.]
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		acb.pushThisAsActivation(mb);
1:11f7ee3: 		getResultColumns().generate(acb, mb);
1:eac0369: 		mb.push(canCache);
1:11f7ee3: 		mb.push(getResultSetNumber());
1:11f7ee3: 		mb.push(getCostEstimate().rowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:9e6e461: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getRowResultSet",
1:9e6e461:                 ClassName.NoPutResultSet, 6);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:c341dc4:      * {@inheritDoc}
1:eac0369: 	 */
1:3bb140c:     @Override
1:c341dc4: 	void replaceOrForbidDefaults(TableDescriptor ttd,
1:c341dc4:                                  ResultColumnList tcl,
1:c341dc4:                                  boolean allowDefaults)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:11f7ee3: 		getResultColumns().replaceOrForbidDefaults(ttd, tcl, allowDefaults);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Optimize any subqueries that haven't been optimized any where
1:eac0369: 	 * else.  This is useful for a RowResultSetNode as a derived table
1:eac0369: 	 * because it doesn't get optimized otherwise.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		subquerys.optimize(dd, rowCount);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:cf530d5: 	 * @see ResultSetNode#adjustForSortElimination
1:eac0369: 	 */
1:3bb140c:     @Override
1:cf530d5: 	void adjustForSortElimination()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Check and see if everything below us is a constant or not.
1:eac0369: 	** If so, we'll let execution know that it can do some caching.
1:eac0369: 	** Before we do the check, we are going to temporarily set
1:eac0369: 	** ParameterNodes to CONSTANT.  We do this because we know
1:eac0369: 	** that we can cache a row with a parameter value and get
1:eac0369: 	** the param column reset by the user setting a param, so
1:eac0369: 	** we can skip over parameter nodes.  We are doing this
1:eac0369: 	** extra work to optimize inserts of the form:
1:eac0369: 	**
1:eac0369: 	** prepare: insert into mytab values (?,?);
1:eac0369: 	** setParam
1:eac0369: 	** execute()
1:eac0369: 	** setParam
1:eac0369: 	** execute()
1:eac0369: 	*/
1:eac0369: 	private boolean canWeCacheResults() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Check the tree below us
1:eac0369: 		*/
1:eac0369: 		HasVariantValueNodeVisitor visitor = 
1:eac0369: 			new HasVariantValueNodeVisitor(Qualifier.QUERY_INVARIANT, true);
1:eac0369: 
1:eac0369: 		super.accept(visitor);
1:eac0369: 		boolean canCache = !visitor.hasVariant();
1:eac0369: 
1:eac0369: 		return canCache;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:09c30dd
/////////////////////////////////////////////////////////////////////////
1:         getResultColumns().preprocess(
1:                 fromList,
1:                 subquerys,
commit:1a58030
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesSessionSchema() throws StandardException {
1:         return subquerys != null && subquerys.referencesSessionSchema();
1:     }
1: 
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
0:     private List aggregates;
/////////////////////////////////////////////////////////////////////////
0:         aggregates = new ArrayList();
/////////////////////////////////////////////////////////////////////////
1:                                       aggregates);
1:         if (!aggregates.isEmpty())
/////////////////////////////////////////////////////////////////////////
1:         if ((aggregates != null) && !aggregates.isEmpty())
commit:43fdf45
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		aggregateVector = new ArrayList();
/////////////////////////////////////////////////////////////////////////
0: 		if (!aggregateVector.isEmpty())
commit:47d4a4c
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 	private List aggregateVector;
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0:             treeTop = (ResultSetNode)getNodeFactory().getNode(
commit:a8db665
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Modify the RCL of this node to match the target of the insert.
1: 	 */
1: 	ResultSetNode enhanceRCLForInsert(
1: 			InsertNode target, boolean inOrder, int[] colMap)
1: 		throws StandardException
1: 	{
0: 		if (!inOrder || resultColumns.size() < target.resultColumnList.size()) {
0: 			resultColumns = getRCLForInsert(target, colMap);
1: 		}
1: 		return this;
1: 	}
commit:7a27cab
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set the type of each parameter in the result column list for this table constructor.
1: 	 *
1: 	 * @param typeColumns	The ResultColumnList containing the desired result
1: 	 *						types.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void setTableConstructorTypes(ResultColumnList typeColumns)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(resultColumns.visibleSize() <= typeColumns.size(),
1: 				"More columns in ResultColumnList than in base table");
1: 
1: 		/* Look for ? parameters in the result column list */
0: 		int rclSize = resultColumns.size();
1: 		for (int index = 0; index < rclSize; index++)
1: 		{
0: 			ResultColumn	rc = (ResultColumn) resultColumns.elementAt(index);
1: 
1: 			ValueNode re = rc.getExpression();
1: 
1: 			if (re.requiresTypeFromContext())
1: 			{
0: 				ResultColumn	typeCol =
0: 					(ResultColumn) typeColumns.elementAt(index);
1: 
1: 				/*
1: 				** We found a ? - set its type to the type of the
1: 				** corresponding column of the target table.
1: 				*/
1: 				re.setType(typeCol.getTypeServices());
1: 			}
1: 			else if (re instanceof CharConstantNode)
1: 			{
1: 				// Character constants are of type CHAR (fixed length string).
1: 				// This causes a problem (beetle 5160) when multiple row values are provided
1: 				// as constants for insertion into a variable length string column.
1: 				//
1: 				// This issue is the query expression
1: 				// VALUES 'abc', 'defghi'
1: 				// has type of CHAR(6), ie. the length of largest row value for that column.
1: 				// This is from the UNION defined behaviour.
1: 				// This causes strings with less than the maximum length to be blank padded
1: 				// to that length (CHAR semantics). Thus if this VALUES clause is used to
1: 				// insert into a variable length string column, then these blank padded values
1: 				// are inserted, which is not what is required ...
1: 				//
1: 				// BECAUSE, when the VALUES is used as a table constructor SQL standard says the
1: 				// types of the table constructor's columns are set by the table's column types.
1: 				// Thus, in this case, each of those string constants should be of type VARCHAR
1: 				// (or the matching string type for the table).
1: 				//
1: 				//
1: 				// This is only an issue for fixed length character (CHAR, BIT) string or
1: 				// binary consraints being inserted into variable length types.
1: 				// This is because any other type's fundemental literal value is not affected
1: 				// by its data type. E.g. Numeric types such as INT, REAL, BIGINT, DECIMAL etc.
1: 				// do not have their value modifed by the union since even if the type is promoted
1: 				// to a higher type, its fundemental value remains unchanged.
1: 				// values (1.2, 34.4567, 234.47) will be promoted to
1: 				// values (1.2000, 34.4567, 234.4700)
1: 				// but their numeric value remains the same.
1: 				//
1: 				//
1: 				//
1: 				// The fix is to change the base type of the table constructor's value to
1: 				// match the column type. Its length can be left as-is, because there is
1: 				// still a normailzation step when the value is inserted into the table.
1: 				// That will set the correct length and perform truncation checks etc.
1: 
0: 				ResultColumn	typeCol =
0: 					(ResultColumn) typeColumns.elementAt(index);
1: 
1: 				TypeId colTypeId = typeCol.getTypeId();
1: 
1: 				if (colTypeId.isStringTypeId()) {
1: 
1: 					if (colTypeId.getJDBCTypeId() != java.sql.Types.CHAR) {
1: 
1: 						int maxWidth = re.getTypeServices().getMaximumWidth();
1: 
1: 						re.setType(new DataTypeDescriptor(colTypeId, true, maxWidth));
1: 					}
1: 				}
1: 				else if (colTypeId.isBitTypeId()) {
1: 					if (colTypeId.getJDBCTypeId() == java.sql.Types.VARBINARY) {
1: 					// then we're trying to cast a char literal into a
1: 					// variable bit column.  We can't change the base
1: 					// type of the table constructor's value from char
1: 					// to bit, so instead, we just change the base type
1: 					// of that value from char to varchar--that way,
1: 					// no padding will be added when we convert to
1: 					// bits later on (Beetle 5306).
1: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.VARCHAR);
1: 						re.setType(new DataTypeDescriptor(tId, true));
1: 						typeColumns.setElementAt(typeCol, index);
1: 					}
1: 					else if (colTypeId.getJDBCTypeId() == java.sql.Types.LONGVARBINARY) {
1: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.LONGVARCHAR);
1: 						re.setType(new DataTypeDescriptor(tId, true));
1: 						typeColumns.setElementAt(typeCol, index);
1: 					}
1: 				}
1: 
1: 			}
1: 			else if (re instanceof BitConstantNode)
1: 			{
0: 				ResultColumn	typeCol =
0: 					(ResultColumn) typeColumns.elementAt(index);
1: 
1: 				TypeId colTypeId = typeCol.getTypeId();
1: 
1: 				if (colTypeId.isBitTypeId()) {
1: 
1: 					// NOTE: Don't bother doing this if the column type is BLOB,
1: 					// as we don't allow bit literals to be inserted into BLOB
1: 					// columns (they have to be explicitly casted first); beetle 5266.
1: 					if ((colTypeId.getJDBCTypeId() != java.sql.Types.BINARY) &&
1: 						(colTypeId.getJDBCTypeId() != java.sql.Types.BLOB)) {
1: 
1: 						int maxWidth = re.getTypeServices().getMaximumWidth();
1: 
1: 						re.setType(new DataTypeDescriptor(colTypeId, true, maxWidth));
1: 					}
1: 				}
1: 				else if (colTypeId.isStringTypeId()) {
1: 					if (colTypeId.getJDBCTypeId() == java.sql.Types.VARCHAR) {
1: 					// then we're trying to cast a bit literal into a
1: 					// variable char column.  We can't change the base
1: 					// type of the table constructor's value from bit
1: 					// to char, so instead, we just change the base
1: 					// type of that value from bit to varbit--that way,
1: 					// no padding will be added when we convert to
1: 					// char later on.
1: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.VARBINARY);
1: 						re.setType(new DataTypeDescriptor(tId, true));
1: 						typeColumns.setElementAt(typeCol, index);
1: 					}
1: 					else if (colTypeId.getJDBCTypeId() == java.sql.Types.LONGVARCHAR) {
1: 						TypeId tId = TypeId.getBuiltInTypeId(java.sql.Types.LONGVARBINARY);
1: 						re.setType(new DataTypeDescriptor(tId, true));
1: 						typeColumns.setElementAt(typeCol, index);
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( valuesClause );
1:         if (getResultColumns() != null) {
1: 			getResultColumns().markInitialSize();
/////////////////////////////////////////////////////////////////////////
1: 		if (!inOrder || getResultColumns().size() < target.resultColumnList.size()) {
1: 			setResultColumns( getRCLForInsert(target, colMap) );
/////////////////////////////////////////////////////////////////////////
1: 		if (getCostEstimate() == null)
1: 			setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		getCostEstimate().setCost(0.0d, 1.0d, 1.0d);
1: 		return getCostEstimate();
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().checkForInvalidDefaults();
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().bindExpressions(fromListParam, subquerys,
/////////////////////////////////////////////////////////////////////////
1: 		SelectNode.checkNoWindowFunctions(getResultColumns(), "VALUES");
/////////////////////////////////////////////////////////////////////////
1: 			bindingRCL = getResultColumns();
1: 		getResultColumns().bindUntypedNullsToResultColumns(bindingRCL);
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( new JBitSet(numTables) );
1: 		getReferencedTableMap().set(tableNumber);
/////////////////////////////////////////////////////////////////////////
1: 		prRCList = getResultColumns();
1: 		setResultColumns( getResultColumns().copyListAndObjects() );
1: 		prRCList.genVirtualColumnNodes(this, getResultColumns());
/////////////////////////////////////////////////////////////////////////
1: 		if ( ! getResultColumns().isCloneable())
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1: 		getCostEstimate().setCost(0.0d, outerRows, outerRows);
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(getResultColumns().visibleSize() <= typeColumns.size(),
1: 		int rclSize = getResultColumns().size();
1:             ResultColumn rc = getResultColumns().elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
1: 		setCostEstimate( getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().generate(acb, mb);
1: 		mb.push(getResultSetNumber());
1: 		mb.push(getCostEstimate().rowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
/////////////////////////////////////////////////////////////////////////
1: 		getResultColumns().replaceOrForbidDefaults(ttd, tcl, allowDefaults);
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0: 			costEstimate = getOptimizerFactory().getCostEstimate();
/////////////////////////////////////////////////////////////////////////
0:         costEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
0:                 (RequiredRowOrdering) null,
0:                 null );
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     private List<AggregateNode> aggregates;
/////////////////////////////////////////////////////////////////////////
1:         aggregates = new ArrayList<AggregateNode>();
commit:87d06c2
/////////////////////////////////////////////////////////////////////////
0:                 Boolean.valueOf( hasJDBClimitClause ),
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
0:     boolean   hasJDBClimitClause; //  were OFFSET/FETCH FIRST specified by a JDBC LIMIT clause?
/////////////////////////////////////////////////////////////////////////
1:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
0:         this.hasJDBClimitClause = hasJDBClimitClause;
/////////////////////////////////////////////////////////////////////////
0:                 new Boolean( hasJDBClimitClause ),
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1: 
1:     QueryExpressionClauses qec = new QueryExpressionClauses();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             printQueryExpressionSuffixClauses(depth, qec);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1:             if (obl != null) {
1:                 obl.pullUpOrderByColumns(this);
1:                 obl.bindOrderByColumns(this);
1:             }
1: 
1:             bindOffsetFetch(qec.getOffset(i), qec.getFetchFirst(i));
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void pushQueryExpressionSuffix() {
1:         qec.push();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         qec.setOrderByList(orderByList);
/////////////////////////////////////////////////////////////////////////
1:         qec.setOffset(offset);
1:         qec.setFetchFirst(fetchFirst);
1:         qec.setHasJDBCLimitClause(hasJDBClimitClause);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1: 
1: 
1:             if (obl != null && obl.size() > 1) {
1:                 obl.removeDupColumns();
1:             }
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1:             if (obl != null) {
1:                 treeTop = new OrderByNode(treeTop,
1:                         obl,
1:                         tableProperties,
1:                         getContextManager());
1:             }
1:             final ValueNode offset = qec.getOffset(i);
1:             final ValueNode fetchFirst = qec.getFetchFirst(i);
1:             Boolean hasJDBClimitClause = qec.getHasJDBCLimitClause()[i];
1:             if (offset != null || fetchFirst != null) {
1:                 ResultColumnList newRcl =
1:                     treeTop.getResultColumns().copyListAndObjects();
1:                 newRcl.genVirtualColumnNodes(
1:                     treeTop, treeTop.getResultColumns());
1: 
1:                 treeTop = new RowCountNode(
1:                         treeTop,
1:                         newRcl,
1:                         offset,
1:                         fetchFirst,
1:                         hasJDBClimitClause.booleanValue(),
1:                         getContextManager());
1:             }
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:             ResultColumn rc = resultColumns.elementAt(index);
1:                 ResultColumn typeCol = typeColumns.elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn typeCol = typeColumns.elementAt(index);
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn typeCol   = typeColumns.elementAt(index);
1:                 TypeId       colTypeId = typeCol.getTypeId();
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: class RowResultSetNode extends FromTable
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a RowResultSetNode.
1:      * @param cm            The context manager
1:     RowResultSetNode(ResultColumnList valuesClause,
1:                      Properties tableProperties,
1:                      ContextManager cm) {
1:         super(null /* correlationName */, tableProperties, cm);
0:         setNodeType(C_NodeTypes.ROW_RESULT_SET_NODE);
0:         resultColumns = valuesClause;
1: 
0:         if (resultColumns != null) {
1:         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressions(FromList fromListParam)
1:         subquerys = new SubqueryList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressionsWithTables(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindTargetExpressions(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultColumn getMatchingColumn(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getExposedName() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void verifySelectStarSubquery(FromList outerFromList, int subqueryType)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:                 numTables,
0:                 new FromList(
0:                     getOptimizerFactory().doJoinOrderOptimization(),
0:                     getContextManager()),
0:                 new SubqueryList(getContextManager()),
1:                 new PredicateList(getContextManager()));
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode ensurePredicateList(int numTables)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode addNewPredicate(Predicate predicate)
/////////////////////////////////////////////////////////////////////////
1:         predList = new PredicateList(getContextManager());
1:         return new ProjectRestrictNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean flattenableInFromSubquery(FromList fromList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
0:         Optimizer opt = getOptimizer(
0:                 new FromList(getOptimizerFactory().doJoinOrderOptimization(),
0:                              getContextManager()),
0:                 predicateList,
0:                 dataDictionary,
0:                 (RequiredRowOrdering) null);
1: 
0:         costEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode modifyAccessPaths() throws StandardException
/////////////////////////////////////////////////////////////////////////
0:             treeTop = new OrderByNode(treeTop,
0:                                       orderByList,
1:                                       tableProperties,
0:                                       getContextManager());
/////////////////////////////////////////////////////////////////////////
0:             treeTop = new RowCountNode(
0:                 hasJDBClimitClause,
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
0:     @Override
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
1: 
0:             if (orderByList != null) {
0:                 printLabel(depth, "orderByList:");
0:                 orderByList.treePrint(depth + 1);
1:             }
1: 
0:             if (offset != null) {
0:                 printLabel(depth, "offset:");
0:                 offset.treePrint(depth + 1);
1:             }
1: 
0:             if (fetchFirst != null) {
0:                 printLabel(depth, "fetch first/next:");
0:                 fetchFirst.treePrint(depth + 1);
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (orderByList != null) {
0:             orderByList.pullUpOrderByColumns(this);
0:             orderByList.bindOrderByColumns(this);
1:         }
1: 
0:         bindOffsetFetch(offset, fetchFirst);
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If we have more than 1 ORDERBY columns, we may be able to
1:         // remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1:         // Well, not very likely here, since we're here:
1:         //     VALUES x followed by ORDER BY 1,1,2
1:         // but for completeness...
0:         if (orderByList != null && orderByList.size() > 1) {
0:             orderByList.removeDupColumns();
1:         }
1: 
1:         return this;
commit:108305b
/////////////////////////////////////////////////////////////////////////
0:     ValueNode    offset; // OFFSET n ROWS
0:     ValueNode    fetchFirst; // FETCH FIRST n ROWS ONLY
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push down the offset and fetch first parameters, if any, to this node.
1:      *
1:      * @param offset    the OFFSET, if any
1:      * @param fetchFirst the OFFSET FIRST, if any
1:      */
0:     void pushOffsetFetchFirst(ValueNode offset, ValueNode fetchFirst)
1:     {
0:         this.offset = offset;
0:         this.fetchFirst = fetchFirst;
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
0:         if (offset != null || fetchFirst != null) {
0:             ResultColumnList newRcl =
0:                 treeTop.getResultColumns().copyListAndObjects();
0:             newRcl.genVirtualColumnNodes(treeTop, treeTop.getResultColumns());
1: 
0:             treeTop = (RowCountNode)getNodeFactory().getNode(
0:                 C_NodeTypes.ROW_COUNT_NODE,
0:                 treeTop,
0:                 newRcl,
0:                 offset,
0:                 fetchFirst,
0:                 getContextManager());
1:         }
1: 
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
1:      * {@inheritDoc}
1: 	void replaceOrForbidDefaults(TableDescriptor ttd,
1:                                  ResultColumnList tcl,
1:                                  boolean allowDefaults)
0: 		resultColumns.replaceOrForbidDefaults(ttd, tcl, allowDefaults);
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 
0: 		SelectNode.checkNoWindowFunctions(resultColumns, "VALUES");
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Army
-------------------------------------------------------------------------------
commit:cf530d5
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	void adjustForSortElimination()
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getRowResultSet",
1:                 ClassName.NoPutResultSet, 6);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.RowResultSetNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
1: 
1: /**
1:  * A RowResultSetNode represents the result set for a VALUES clause.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class RowResultSetNode extends FromTable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	SubqueryList subquerys;
0: 	Vector		 aggregateVector;
0: 	OrderByList	 orderByList;
1: 
1: 	/**
0: 	 * Initializer for a RowResultSetNode.
1: 	 *
1: 	 * @param valuesClause	The result column list for the VALUES clause.
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 */
0: 	public void init(Object valuesClause, Object tableProperties)
1: 	{
0: 		super.init(null, tableProperties);
0: 		resultColumns = (ResultColumnList) valuesClause;
1: 	}
1: 
1: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
1: 	 *
0: 	 * @return	This object as a String
1: 	 */
1: 
0: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return 	"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
0: 				super.toString();
1: 		}
1: 		else
1: 		{
0: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "VALUES";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (subquerys != null)
1: 			{
1: 				printLabel(depth, "subquerys: ");
1: 				subquerys.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see Optimizable#estimateCost
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
1: 										ConglomerateDescriptor cd,
1: 										CostEstimate outerCost,
1: 										Optimizer optimizer,
1: 										RowOrdering rowOrdering)
1: 								throws StandardException
1: 	{
1: 		/*
1: 		** Assume for now that the cost of a VALUES clause is zero, with one row
1: 		** fetched.  Is this true, and if not, does it make a difference?
1: 		** There's nothing to optimize in this case.
1: 		*/
0: 		if (costEstimate == null)
1: 		{
0: 			costEstimate = optimizer.newCostEstimate();
1: 		}
1: 
0: 		costEstimate.setCost(0.0d, 1.0d, 1.0d);
1: 
1: 		/* A single row is always ordered */
1: 		rowOrdering.optimizableAlwaysOrdered(this);
1: 
0: 		return costEstimate;
1: 	}
1: 
1: 	/**
1: 	 * Bind the non VTI tables in this ResultSetNode.  This includes getting their
1: 	 * descriptors from the data dictionary and numbering them.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for binding
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
1: 							FromList fromListParam) 
1: 					throws StandardException
1: 	{
1: 		/* Assign the tableNumber */
1: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1: 			tableNumber = getCompilerContext().getNextTableNumber();
1: 
1: 		/* VALUES clause has no tables, so nothing to do */
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this RowResultSetNode.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is
1: 	 * for each expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindExpressions(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		int nestingLevel;
1: 
0: 		subquerys = (SubqueryList) getNodeFactory().getNode(
0: 										C_NodeTypes.SUBQUERY_LIST,
0: 										getContextManager());
1: 
0: 		aggregateVector = new Vector();
1: 
1: 		/* Verify that there are no DEFAULTs in the RCL.
1: 		 * DEFAULT is only valid for an insert, and it has
1: 		 * already been coverted into the tree by the time we get here.
1: 		 * The grammar allows:
1: 		 *		VALUES DEFAULT;
1: 		 * so we need to check for that here and throw an exception if found.
1: 		 */
0: 		resultColumns.checkForInvalidDefaults();
1: 
1: 		/* Believe it or not, a values clause can contain correlated column references
1: 		 * and subqueries.  In order to get correlated column resolution working 
1: 		 * correctly, we need to set our nesting level to be 1 deeper than the current
1: 		 * level and push ourselves into the FROM list.  
1: 		 */
1: 
1: 		/* Set the nesting level in this node */
1: 		if (fromListParam.size() == 0)
1: 		{
1: 			nestingLevel = 0;
1: 		}
1: 		else
1: 		{
1: 			nestingLevel = ((FromTable) fromListParam.elementAt(0)).getLevel() + 1;
1: 		}
1: 		setLevel(nestingLevel);
1: 		fromListParam.insertElementAt(this, 0);
0: 		resultColumns.bindExpressions(fromListParam, subquerys,
0: 									  aggregateVector);
1: 		// Pop ourselves back out of the FROM list
1: 		fromListParam.removeElementAt(0);
1: 
0: 		if (aggregateVector.size() > 0)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_NO_AGGREGATES_IN_WHERE_CLAUSE);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is for
1: 	 * each expression.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindExpressionsWithTables(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		/* We don't have any tables, so just return */
0: 		return;
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in the target list.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is
1: 	 * for each expression.  This is useful for EXISTS subqueries, where we
1: 	 * need to validate the target list before blowing it away and replacing
1: 	 * it with a SELECT true.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindTargetExpressions(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		bindExpressions(fromListParam);
1: 	}
1: 
1: 	/**
1: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
1: 	 *
1: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** If bindingRCL is null, then we are
1: 		** under a cursor node that is inferring
1: 		** its RCL from us.  It passes null to
1: 		** get union to use both sides of the union
1: 		** for the check.  Anyway, since there is
1: 		** nothing under us but an RCL, just pass
1: 		** in our RCL.
1: 		*/
1: 		if (bindingRCL == null)
0: 			bindingRCL = resultColumns;
1: 
0: 		resultColumns.bindUntypedNullsToResultColumns(bindingRCL);
1: 	}
1: 
1: 	/**
1: 	 * Try to find a ResultColumn in the table represented by this FromTable
1: 	 * that matches the name in the given ColumnReference.
1: 	 *
1: 	 * @param columnReference	The columnReference whose name we're looking
1: 	 *				for in the given table.
1: 	 *
1: 	 * @return	A ResultColumn whose expression is the ColumnNode
1: 	 *			that matches the ColumnReference.
1: 	 *		Returns null if there is no match.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultColumn getMatchingColumn(
1: 						ColumnReference columnReference)
1: 						throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Get the exposed name for this table, which is the name that can
1: 	 * be used to refer to it in the rest of the query.
1: 	 *
1: 	 * @return	The exposed name of this table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public String getExposedName() throws StandardException
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Verify that a SELECT * is valid for this type of subquery.
1: 	 *
1: 	 * @param outerFromList	The FromList from the outer query block(s)
1: 	 * @param subqueryType	The subquery type
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
1: 					throws StandardException
1: 	{
0: 		return; 
1: 	}
1: 
1: 	/**
1: 	 * Push the order by list down from the cursor node
1: 	 * into its child result set so that the optimizer
1: 	 * has all of the information that it needs to 
1: 	 * consider sort avoidance.
1: 	 *
1: 	 * @param orderByList	The order by list
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void pushOrderByList(OrderByList orderByList)
1: 	{
0: 		this.orderByList = orderByList;
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 
0: 		if (subquerys.size() > 0)
1: 		{
0: 			subquerys.preprocess(
0: 								numTables,
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 								(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
0: 													getContextManager()),
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager()));
1: 		}
1: 
1: 		/* Allocate a dummy referenced table map */ 
0: 		referencedTableMap = new JBitSet(numTables);
0: 		referencedTableMap.set(tableNumber);
1: 		return this;
1: 	}
1: 	
1: 	/**
1: 	 * Ensure that the top of the RSN tree has a PredicateList.
1: 	 *
1: 	 * @param numTables			The number of tables in the query.
1: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
1: 		throws StandardException
1: 	{
1: 		return genProjectRestrict(numTables);
1: 	}
1: 
1: 	/**
1: 	 * Add a new predicate to the list.  This is useful when doing subquery
1: 	 * transformations, when we build a new predicate with the left side of
1: 	 * the subquery operator and the subquery's result column.
1: 	 *
1: 	 * @param predicate		The predicate to add
1: 	 *
1: 	 * @return ResultSetNode	The new top of the tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
1: 			throws StandardException
1: 	{
1: 		PredicateList		predList;
1: 		ResultColumnList	prRCList;
1: 		ResultSetNode		newPRN;
1: 		
1: 		/* We are the body of a quantified predicate subquery.  We
1: 		 * need to generate (and return) a PRN above us so that there will be
1: 		 * a place to attach the new predicate.
1: 		 */
1: 
1: 		/* We get a shallow copy of the ResultColumnList and its 
1: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
1: 		 */
0: 		prRCList = resultColumns;
0: 		resultColumns = resultColumns.copyListAndObjects();
1: 
1: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
1: 		 * in the ProjectRestrictNode's ResultColumnList.  (VirtualColumnNodes include
1: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
1: 		 */
0: 		prRCList.genVirtualColumnNodes(this, resultColumns);
1: 
1: 		/* Put the new predicate in a list */
0: 		predList = (PredicateList) getNodeFactory().getNode(
0: 										C_NodeTypes.PREDICATE_LIST,
0: 										getContextManager());
1: 		predList.addPredicate(predicate);
1: 
0: 		/* Finally, we create the new ProjectRestrictNode */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 								C_NodeTypes.PROJECT_RESTRICT_NODE,
1: 								this,
1: 								prRCList,
1: 								null,	/* Restriction */
1: 								predList,   /* Restriction as PredicateList */
1: 								null,	/* Project subquery list */
1: 								null,	/* Restrict subquery list */
0: 								tableProperties,
1: 								getContextManager()				 );
1: 	}
1: 
1: 	/**
1: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1: 	 * Currently, a FSqry is flattenable if all of the following are true:
1: 	 *		o  Subquery is a SelectNode or a RowResultSetNode (not a UnionNode)
1: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1: 	 *		o  It does not contain a group by or having clause
1: 	 *		o  It does not contain aggregates.
1: 	 *		o  There is at least one result set in the from list that is
1: 	 *		   not a RowResultSetNode (the reason is to avoid having
1: 	 *		   an outer SelectNode with an empty FromList.
1: 	 *
1: 	 * @param fromList	The outer from list
1: 	 *
1: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
1: 		if ((subquerys != null) &&
1: 			(subquerys.size() > 0))
1: 		{
1: 			return false;
1: 		}
1: 
0: 		if ((aggregateVector != null) &&
0: 			(aggregateVector.size() > 0))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		/*
1: 		** Don't flatten if select list contains something
1: 		** that isn't clonable
1: 		*/
0: 		if ( ! resultColumns.isCloneable())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		boolean nonRowResultSetFound = false;
1: 		int flSize = fromList.size();
1: 		for (int index = 0; index < flSize; index++)
1: 		{
1: 			FromTable ft = (FromTable) fromList.elementAt(index);
1: 
1: 			if (ft instanceof FromSubquery)
1: 			{
1: 				ResultSetNode subq = ((FromSubquery) ft).getSubquery();
1: 				if ( ! (subq instanceof RowResultSetNode))
1: 				{
1: 					nonRowResultSetFound = true;
1: 					break;
1: 				}
1: 			}
1: 			else
1: 			{
1: 				nonRowResultSetFound = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		return nonRowResultSetFound;
1: 	}
1: 
1: 	/**
1: 	 * Optimize this SelectNode.  This means choosing the best access path
1: 	 * for each table, among other things.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
1: 	 * @param predicateList		The predicate list to optimize against
1: 	 * @param outerRows			The number of outer joining rows
1: 	 *
1: 	 * @return	ResultSetNode	The top of the optimized tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 								  PredicateList	predicateList,
1: 								  double outerRows) 
1: 			throws StandardException
1: 	{
1: 		/*
1: 		** Get an optimizer.  The only reason we need one is to get a
1: 		** CostEstimate object, so we can represent the cost of this node.
1: 		** This seems like overkill, but it's just an object allocation...
1: 		*/
0: 		Optimizer optimizer =
0: 					getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 								predicateList,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
0: 		costEstimate = optimizer.newCostEstimate();
1: 
1: 		// RESOLVE: THE COST SHOULD TAKE SUBQUERIES INTO ACCOUNT
0: 		costEstimate.setCost(0.0d, outerRows, outerRows);
1: 
1: 		subquerys.optimize(dataDictionary, outerRows);
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1: 	{
1: 		/* For most types of Optimizable, do nothing */
1: 		return (Optimizable) modifyAccessPaths();
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#modifyAccessPaths
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
1: 	{
1: 		ResultSetNode treeTop = this;
1: 
1: 		subquerys.modifyAccessPaths();
1: 
1: 		/* Generate the OrderByNode if a sort is still required for
1: 		 * the order by.
1: 		 */
0: 		if (orderByList != null)
1: 		{
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.ORDER_BY_NODE,
0: 											treeTop,
0: 											orderByList,
0: 											tableProperties,
0: 											getContextManager());
1: 		}
1: 		return treeTop;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not this ResultSet tree is guaranteed to return
1: 	 * at most 1 row based on heuristics.  (A RowResultSetNode and a
1: 	 * SELECT with a non-grouped aggregate will return at most 1 row.)
1: 	 *
1: 	 * @return Whether or not this ResultSet tree is guaranteed to return
1: 	 * at most 1 row based on heuristics.
1: 	 */
1: 	boolean returnsAtMostOneRow()
1: 	{
1: 		return true;
1: 	}
1: 
1:     /**
1:      * The generated ResultSet will be:
1:      *
1:      *      RowResultSet -- for the VALUES clause
1:      *
1: 	 *
0: 	 * @return		A compiled Expression returning a ResultSet
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
1: 
1: 		/*
1: 		** Check and see if everything below us is a constant or not.
1: 		** If so, we'll let execution know that it can do some caching.
1: 		** Before we do the check, we are going to temporarily set
1: 		*/
1: 		boolean canCache = canWeCacheResults();
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 	    // we are dealing with
1: 		// VALUES(value1, value2, value3)
1: 	    // so we generate a RowResultSet to return the values listed.
1: 
1: 		// we can reduce the tree to one RowResultSet
1:     	// since there is nothing but the resultColumns
1: 
1:     	// RowResultSet takes the row-generating function
1:     	// so we generate one and get back the expression
1:     	// pointing to it.
1: 	    //
1: 		// generate the expression to return, which is:
1: 		// ResultSetFactory.getRowResultSet(this, planX.exprN)
1: 		// [planX is the name of the class being generated,
1:     	// exprN is the name of the function being generated.]
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		acb.pushThisAsActivation(mb);
0: 		resultColumns.generate(acb, mb);
1: 		mb.push(canCache);
0: 		mb.push(resultSetNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getRowResultSet", ClassName.NoPutResultSet, 7);
1: 	}
1: 
1: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
1: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
1: 		throws StandardException
1: 	{
0: 		resultColumns.replaceDefaults(ttd, tcl);
1: 	}
1: 
1: 	/**
1: 	 * Optimize any subqueries that haven't been optimized any where
1: 	 * else.  This is useful for a RowResultSetNode as a derived table
1: 	 * because it doesn't get optimized otherwise.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
1: 		throws StandardException
1: 	{
1: 		subquerys.optimize(dd, rowCount);
1: 	}
1: 
1: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void markOrderingDependent()
1: 	{
1: 	}
1: 
1: 	/*
1: 	** Check and see if everything below us is a constant or not.
1: 	** If so, we'll let execution know that it can do some caching.
1: 	** Before we do the check, we are going to temporarily set
1: 	** ParameterNodes to CONSTANT.  We do this because we know
1: 	** that we can cache a row with a parameter value and get
1: 	** the param column reset by the user setting a param, so
1: 	** we can skip over parameter nodes.  We are doing this
1: 	** extra work to optimize inserts of the form:
1: 	**
1: 	** prepare: insert into mytab values (?,?);
1: 	** setParam
1: 	** execute()
1: 	** setParam
1: 	** execute()
1: 	*/
1: 	private boolean canWeCacheResults() throws StandardException
1: 	{
1: 
1: 		/*
1: 		** Check the tree below us
1: 		*/
1: 		HasVariantValueNodeVisitor visitor = 
1: 			new HasVariantValueNodeVisitor(Qualifier.QUERY_INVARIANT, true);
1: 
1: 		super.accept(visitor);
1: 		boolean canCache = !visitor.hasVariant();
1: 
1: 		return canCache;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		// Get our final cost estimate.
0: 		costEstimate = getFinalCostEstimate();
0: 
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: 		if (resultColumns != null)
0: 			resultColumns.markInitialSize();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Row;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.Vector;
0: 
0: /**
0:  * A RowResultSetNode represents the result set for a VALUES clause.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class RowResultSetNode extends FromTable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	SubqueryList subquerys;
0: 	Vector		 aggregateVector;
0: 	OrderByList	 orderByList;
0: 
0: 	/**
0: 	 * Initializer for a RowResultSetNode.
0: 	 *
0: 	 * @param valuesClause	The result column list for the VALUES clause.
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 */
0: 	public void init(Object valuesClause, Object tableProperties)
0: 	{
0: 		super.init(null, tableProperties);
0: 		resultColumns = (ResultColumnList) valuesClause;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return 	"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "VALUES";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (subquerys != null)
0: 			{
0: 				printLabel(depth, "subquerys: ");
0: 				subquerys.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see Optimizable#estimateCost
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public CostEstimate estimateCost(OptimizablePredicateList predList,
0: 										ConglomerateDescriptor cd,
0: 										CostEstimate outerCost,
0: 										Optimizer optimizer,
0: 										RowOrdering rowOrdering)
0: 								throws StandardException
0: 	{
0: 		/*
0: 		** Assume for now that the cost of a VALUES clause is zero, with one row
0: 		** fetched.  Is this true, and if not, does it make a difference?
0: 		** There's nothing to optimize in this case.
0: 		*/
0: 		if (costEstimate == null)
0: 		{
0: 			costEstimate = optimizer.newCostEstimate();
0: 		}
0: 
0: 		costEstimate.setCost(0.0d, 1.0d, 1.0d);
0: 
0: 		/* A single row is always ordered */
0: 		rowOrdering.optimizableAlwaysOrdered(this);
0: 
0: 		return costEstimate;
0: 	}
0: 
0: 	/**
0: 	 * Bind the non VTI tables in this ResultSetNode.  This includes getting their
0: 	 * descriptors from the data dictionary and numbering them.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
0: 							FromList fromListParam) 
0: 					throws StandardException
0: 	{
0: 		/* Assign the tableNumber */
0: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
0: 			tableNumber = getCompilerContext().getNextTableNumber();
0: 
0: 		/* VALUES clause has no tables, so nothing to do */
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this RowResultSetNode.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is
0: 	 * for each expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindExpressions(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		int nestingLevel;
0: 
0: 		subquerys = (SubqueryList) getNodeFactory().getNode(
0: 										C_NodeTypes.SUBQUERY_LIST,
0: 										getContextManager());
0: 
0: 		aggregateVector = new Vector();
0: 
0: 		/* Verify that there are no DEFAULTs in the RCL.
0: 		 * DEFAULT is only valid for an insert, and it has
0: 		 * already been coverted into the tree by the time we get here.
0: 		 * The grammar allows:
0: 		 *		VALUES DEFAULT;
0: 		 * so we need to check for that here and throw an exception if found.
0: 		 */
0: 		resultColumns.checkForInvalidDefaults();
0: 
0: 		/* Believe it or not, a values clause can contain correlated column references
0: 		 * and subqueries.  In order to get correlated column resolution working 
0: 		 * correctly, we need to set our nesting level to be 1 deeper than the current
0: 		 * level and push ourselves into the FROM list.  
0: 		 */
0: 
0: 		/* Set the nesting level in this node */
0: 		if (fromListParam.size() == 0)
0: 		{
0: 			nestingLevel = 0;
0: 		}
0: 		else
0: 		{
0: 			nestingLevel = ((FromTable) fromListParam.elementAt(0)).getLevel() + 1;
0: 		}
0: 		setLevel(nestingLevel);
0: 		fromListParam.insertElementAt(this, 0);
0: 		resultColumns.bindExpressions(fromListParam, subquerys,
0: 									  aggregateVector);
0: 		// Pop ourselves back out of the FROM list
0: 		fromListParam.removeElementAt(0);
0: 
0: 		if (aggregateVector.size() > 0)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_NO_AGGREGATES_IN_WHERE_CLAUSE);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is for
0: 	 * each expression.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindExpressionsWithTables(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		/* We don't have any tables, so just return */
0: 		return;
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in the target list.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is
0: 	 * for each expression.  This is useful for EXISTS subqueries, where we
0: 	 * need to validate the target list before blowing it away and replacing
0: 	 * it with a SELECT true.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindTargetExpressions(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		bindExpressions(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Bind any untyped null nodes to the types in the given ResultColumnList.
0: 	 *
0: 	 * @param bindingRCL	The ResultColumnList with the types to bind to.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList bindingRCL)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** If bindingRCL is null, then we are
0: 		** under a cursor node that is inferring
0: 		** its RCL from us.  It passes null to
0: 		** get union to use both sides of the union
0: 		** for the check.  Anyway, since there is
0: 		** nothing under us but an RCL, just pass
0: 		** in our RCL.
0: 		*/
0: 		if (bindingRCL == null)
0: 			bindingRCL = resultColumns;
0: 
0: 		resultColumns.bindUntypedNullsToResultColumns(bindingRCL);
0: 	}
0: 
0: 	/**
0: 	 * Try to find a ResultColumn in the table represented by this FromTable
0: 	 * that matches the name in the given ColumnReference.
0: 	 *
0: 	 * @param columnReference	The columnReference whose name we're looking
0: 	 *				for in the given table.
0: 	 *
0: 	 * @return	A ResultColumn whose expression is the ColumnNode
0: 	 *			that matches the ColumnReference.
0: 	 *		Returns null if there is no match.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultColumn getMatchingColumn(
0: 						ColumnReference columnReference)
0: 						throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get the exposed name for this table, which is the name that can
0: 	 * be used to refer to it in the rest of the query.
0: 	 *
0: 	 * @return	The exposed name of this table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public String getExposedName() throws StandardException
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Verify that a SELECT * is valid for this type of subquery.
0: 	 *
0: 	 * @param outerFromList	The FromList from the outer query block(s)
0: 	 * @param subqueryType	The subquery type
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
0: 					throws StandardException
0: 	{
0: 		return; 
0: 	}
0: 
0: 	/**
0: 	 * Push the order by list down from the cursor node
0: 	 * into its child result set so that the optimizer
0: 	 * has all of the information that it needs to 
0: 	 * consider sort avoidance.
0: 	 *
0: 	 * @param orderByList	The order by list
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void pushOrderByList(OrderByList orderByList)
0: 	{
0: 		this.orderByList = orderByList;
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 
0: 		if (subquerys.size() > 0)
0: 		{
0: 			subquerys.preprocess(
0: 								numTables,
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 								(SubqueryList) getNodeFactory().getNode(
0: 													C_NodeTypes.SUBQUERY_LIST,
0: 													getContextManager()),
0: 								(PredicateList) getNodeFactory().getNode(
0: 													C_NodeTypes.PREDICATE_LIST,
0: 													getContextManager()));
0: 		}
0: 
0: 		/* Allocate a dummy referenced table map */ 
0: 		referencedTableMap = new JBitSet(numTables);
0: 		referencedTableMap.set(tableNumber);
0: 		return this;
0: 	}
0: 	
0: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
0: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
0: 		throws StandardException
0: 	{
0: 		return genProjectRestrict(numTables);
0: 	}
0: 
0: 	/**
0: 	 * Add a new predicate to the list.  This is useful when doing subquery
0: 	 * transformations, when we build a new predicate with the left side of
0: 	 * the subquery operator and the subquery's result column.
0: 	 *
0: 	 * @param predicate		The predicate to add
0: 	 *
0: 	 * @return ResultSetNode	The new top of the tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode addNewPredicate(Predicate predicate)
0: 			throws StandardException
0: 	{
0: 		PredicateList		predList;
0: 		ResultColumnList	prRCList;
0: 		ResultSetNode		newPRN;
0: 		
0: 		/* We are the body of a quantified predicate subquery.  We
0: 		 * need to generate (and return) a PRN above us so that there will be
0: 		 * a place to attach the new predicate.
0: 		 */
0: 
0: 		/* We get a shallow copy of the ResultColumnList and its 
0: 		 * ResultColumns.  (Copy maintains ResultColumn.expression for now.)
0: 		 */
0: 		prRCList = resultColumns;
0: 		resultColumns = resultColumns.copyListAndObjects();
0: 
0: 		/* Replace ResultColumn.expression with new VirtualColumnNodes
0: 		 * in the ProjectRestrictNode's ResultColumnList.  (VirtualColumnNodes include
0: 		 * pointers to source ResultSetNode, this, and source ResultColumn.)
0: 		 */
0: 		prRCList.genVirtualColumnNodes(this, resultColumns);
0: 
0: 		/* Put the new predicate in a list */
0: 		predList = (PredicateList) getNodeFactory().getNode(
0: 										C_NodeTypes.PREDICATE_LIST,
0: 										getContextManager());
0: 		predList.addPredicate(predicate);
0: 
0: 		/* Finally, we create the new ProjectRestrictNode */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 								C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 								this,
0: 								prRCList,
0: 								null,	/* Restriction */
0: 								predList,   /* Restriction as PredicateList */
0: 								null,	/* Project subquery list */
0: 								null,	/* Restrict subquery list */
0: 								tableProperties,
0: 								getContextManager()				 );
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode or a RowResultSetNode (not a UnionNode)
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *		o  There is at least one result set in the from list that is
0: 	 *		   not a RowResultSetNode (the reason is to avoid having
0: 	 *		   an outer SelectNode with an empty FromList.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		if ((subquerys != null) &&
0: 			(subquerys.size() > 0))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		if ((aggregateVector != null) &&
0: 			(aggregateVector.size() > 0))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		/*
0: 		** Don't flatten if select list contains something
0: 		** that isn't clonable
0: 		*/
0: 		if ( ! resultColumns.isCloneable())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		boolean nonRowResultSetFound = false;
0: 		int flSize = fromList.size();
0: 		for (int index = 0; index < flSize; index++)
0: 		{
0: 			FromTable ft = (FromTable) fromList.elementAt(index);
0: 
0: 			if (ft instanceof FromSubquery)
0: 			{
0: 				ResultSetNode subq = ((FromSubquery) ft).getSubquery();
0: 				if ( ! (subq instanceof RowResultSetNode))
0: 				{
0: 					nonRowResultSetFound = true;
0: 					break;
0: 				}
0: 			}
0: 			else
0: 			{
0: 				nonRowResultSetFound = true;
0: 				break;
0: 			}
0: 		}
0: 
0: 		return nonRowResultSetFound;
0: 	}
0: 
0: 	/**
0: 	 * Optimize this SelectNode.  This means choosing the best access path
0: 	 * for each table, among other things.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The predicate list to optimize against
0: 	 * @param outerRows			The number of outer joining rows
0: 	 *
0: 	 * @return	ResultSetNode	The top of the optimized tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 								  PredicateList	predicateList,
0: 								  double outerRows) 
0: 			throws StandardException
0: 	{
0: 		/*
0: 		** Get an optimizer.  The only reason we need one is to get a
0: 		** CostEstimate object, so we can represent the cost of this node.
0: 		** This seems like overkill, but it's just an object allocation...
0: 		*/
0: 		Optimizer optimizer =
0: 					getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager()),
0: 								predicateList,
0: 								dataDictionary,
0: 								(RequiredRowOrdering) null);
0: 		costEstimate = optimizer.newCostEstimate();
0: 
0: 		// RESOLVE: THE COST SHOULD TAKE SUBQUERIES INTO ACCOUNT
0: 		costEstimate.setCost(0.0d, outerRows, outerRows);
0: 
0: 		subquerys.optimize(dataDictionary, outerRows);
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
0: 	{
0: 		/* For most types of Optimizable, do nothing */
0: 		return (Optimizable) modifyAccessPaths();
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#modifyAccessPaths
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
0: 	{
0: 		ResultSetNode treeTop = this;
0: 
0: 		subquerys.modifyAccessPaths();
0: 
0: 		/* Generate the OrderByNode if a sort is still required for
0: 		 * the order by.
0: 		 */
0: 		if (orderByList != null)
0: 		{
0: 			treeTop = (ResultSetNode) getNodeFactory().getNode(
0: 											C_NodeTypes.ORDER_BY_NODE,
0: 											treeTop,
0: 											orderByList,
0: 											tableProperties,
0: 											getContextManager());
0: 		}
0: 		return treeTop;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not this ResultSet tree is guaranteed to return
0: 	 * at most 1 row based on heuristics.  (A RowResultSetNode and a
0: 	 * SELECT with a non-grouped aggregate will return at most 1 row.)
0: 	 *
0: 	 * @return Whether or not this ResultSet tree is guaranteed to return
0: 	 * at most 1 row based on heuristics.
0: 	 */
0: 	boolean returnsAtMostOneRow()
0: 	{
0: 		return true;
0: 	}
0: 
0:     /**
0:      * The generated ResultSet will be:
0:      *
0:      *      RowResultSet -- for the VALUES clause
0:      *
0: 	 *
0: 	 * @return		A compiled Expression returning a ResultSet
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
0: 
0: 		/*
0: 		** Check and see if everything below us is a constant or not.
0: 		** If so, we'll let execution know that it can do some caching.
0: 		** Before we do the check, we are going to temporarily set
0: 		*/
0: 		boolean canCache = canWeCacheResults();
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 	    // we are dealing with
0: 		// VALUES(value1, value2, value3)
0: 	    // so we generate a RowResultSet to return the values listed.
0: 
0: 		// we can reduce the tree to one RowResultSet
0:     	// since there is nothing but the resultColumns
0: 
0:     	// RowResultSet takes the row-generating function
0:     	// so we generate one and get back the expression
0:     	// pointing to it.
0: 	    //
0: 		// generate the expression to return, which is:
0: 		// ResultSetFactory.getRowResultSet(this, planX.exprN)
0: 		// [planX is the name of the class being generated,
0:     	// exprN is the name of the function being generated.]
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		acb.pushThisAsActivation(mb);
0: 		resultColumns.generate(acb, mb);
0: 		mb.push(canCache);
0: 		mb.push(resultSetNumber);
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getRowResultSet", ClassName.NoPutResultSet, 7);
0: 	}
0: 
0: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
0: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
0: 		throws StandardException
0: 	{
0: 		resultColumns.replaceDefaults(ttd, tcl);
0: 	}
0: 
0: 	/**
0: 	 * Optimize any subqueries that haven't been optimized any where
0: 	 * else.  This is useful for a RowResultSetNode as a derived table
0: 	 * because it doesn't get optimized otherwise.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void optimizeSubqueries(DataDictionary dd, double rowCount)
0: 		throws StandardException
0: 	{
0: 		subquerys.optimize(dd, rowCount);
0: 	}
0: 
0: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markOrderingDependent()
0: 	{
0: 	}
0: 
0: 	/*
0: 	** Check and see if everything below us is a constant or not.
0: 	** If so, we'll let execution know that it can do some caching.
0: 	** Before we do the check, we are going to temporarily set
0: 	** ParameterNodes to CONSTANT.  We do this because we know
0: 	** that we can cache a row with a parameter value and get
0: 	** the param column reset by the user setting a param, so
0: 	** we can skip over parameter nodes.  We are doing this
0: 	** extra work to optimize inserts of the form:
0: 	**
0: 	** prepare: insert into mytab values (?,?);
0: 	** setParam
0: 	** execute()
0: 	** setParam
0: 	** execute()
0: 	*/
0: 	private boolean canWeCacheResults() throws StandardException
0: 	{
0: 
0: 		/*
0: 		** Check the tree below us
0: 		*/
0: 		HasVariantValueNodeVisitor visitor = 
0: 			new HasVariantValueNodeVisitor(Qualifier.QUERY_INVARIANT, true);
0: 
0: 		super.accept(visitor);
0: 		boolean canCache = !visitor.hasVariant();
0: 
0: 		return canCache;
0: 	}
0: }
============================================================================