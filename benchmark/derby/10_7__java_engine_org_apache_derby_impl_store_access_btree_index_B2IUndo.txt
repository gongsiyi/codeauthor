1:eac0369: /*
4:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2IUndo
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree.index;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.LogicalUndoable;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: // imports of inherited impl's
1:eac0369: import org.apache.derby.impl.store.access.btree.BTree;
1:eac0369: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
1:eac0369: import org.apache.derby.impl.store.access.btree.ControlRow;
1:eac0369: import org.apache.derby.impl.store.access.btree.OpenBTree;
1:eac0369: import org.apache.derby.impl.store.access.btree.SearchParameters;
1:eac0369: 
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import org.apache.derby.iapi.services.io.LimitObjectInput;
1:eac0369: 
2:eac0369: /**
1:787ceb4:  * @derby.formatId ACCESS_B2IUNDO_V1_ID
1:eac0369:  *
1:787ceb4:  * @derby.purpose   Implements the LogicalUndo and Formatable interfaces, basically
1:eac0369:  *            providing a way for raw store recovery to "call back" access code
1:eac0369:  *            to provide logical undo ability.
1:eac0369:  *
1:787ceb4:  * @derby.upgrade   RESOLVE.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout 
1:eac0369:  *     No state associated with this format.
1:eac0369:  *
1:eac0369:  **/
1:eac0369: 
1:eac0369: /**
1:eac0369: 
1:eac0369: The B2IUndo interface packages up the routines which the rawstore needs
1:eac0369: to call to perform logical undo of a record in a B2i.  The rawstore will
1:eac0369: determine that a page has changed since the record was written, and if it
1:eac0369: has it will call the findUndo() interface, to find the page where the record
1:eac0369: exists (as it may have moved).
1:eac0369: <p>
1:eac0369: This class must not contain any persistent state, as this class is stored
1:eac0369: in the log record of the insert/delete.
1:eac0369: 
1:eac0369: @see org.apache.derby.iapi.store.raw.LogicalUndoable
1:eac0369: @see org.apache.derby.iapi.store.raw.Undoable#generateUndo 
1:eac0369: **/
1:eac0369: public class B2IUndo implements LogicalUndo, Formatable
2:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * Find the page and record to undo.  If no logical undo is necessary,
1:eac0369: 	 * i.e., row has not moved, then just return the latched page where undo
1:eac0369: 	 * should go.  If the record has moved, it has a new recordId on the new
1:eac0369: 	 * page, this routine needs to call pageOp.resetRecord with the new
1:eac0369: 	 * RecordHandle so that the logging system can update the compensation
1:eac0369: 	 * Operation with the new location.
1:eac0369:      *
1:06dbbcf: 	 * @param rawtran   the transaction doing the rollback
1:06dbbcf: 	 * @param pageOp    the page operation that supports logical undo.  This
1:06dbbcf: 	 * 		            LogicalUndo function pointer is a field of that 
1:06dbbcf:      * 		            pageOperation
1:06dbbcf: 	 * @param in        data stored in the log stream that contains the record 
1:06dbbcf:      *                  data necessary to restore the row.
1:eac0369:      *
1:94f158a:      * @exception StandardException Standard Derby error policy
1:06dbbcf: 	 * @exception IOException Method may read from InputStream
1:06dbbcf:      *
1:eac0369: 	 */
1:eac0369: 	public Page findUndo(
1:06dbbcf:     Transaction         rawtran, 
1:06dbbcf:     LogicalUndoable     pageOp,
1:06dbbcf:     LimitObjectInput    in)
1:eac0369:         throws StandardException, IOException
1:eac0369:     {
1:eac0369:         ControlRow            root                      = null;
1:eac0369:         ControlRow            control_row               = null;
1:eac0369:         DataValueDescriptor[] logged_index_row_template = null;
1:eac0369:         DataValueDescriptor[] template                  = null;
1:eac0369:         Page                  ret_page                  = null;
1:eac0369:         ContainerHandle       container                 = pageOp.getContainer();
1:eac0369:         RecordHandle          rechandle                 = pageOp.getRecordHandle();
1:eac0369:         boolean               ok_exit                   = false;
1:eac0369:         int                   compare_result            = 1;
1:eac0369:         B2I                   btree                     = null;
1:eac0369: 
1:eac0369:         // Open the btree to associate the open contain handle, thus the 
1:eac0369:         // current xact with all subsequent operations during undo.
1:eac0369: 
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369: 
1:eac0369:             // Need Conglomerate to create templates - get from the root page.
1:4a2b0d9:             root = ControlRow.get(container, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(root.getPage().isLatched());
1:eac0369: 
1:eac0369:             btree = (B2I) root.getConglom(B2I.FORMAT_NUMBER);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(btree instanceof B2I);
1:eac0369: 
1:eac0369:             // create a template for the logged index row from the conglomerate.
1:722a889:             logged_index_row_template = btree.createTemplate(rawtran);
1:eac0369: 
1:eac0369:             // create a template for the page index row from the conglomerate.
1:722a889:             template                  = btree.createTemplate(rawtran);
2:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Get logged row from record.
1:eac0369:         pageOp.restoreLoggedRow(logged_index_row_template, in);
1:eac0369: 
1:eac0369:         // RESOLVE (mikem) - currently restoreLoggedRow() may latch and unlatch
1:eac0369:         // a page in the container (see ST059).
1:eac0369:         // Now get the page where the record used to be.
1:eac0369: 
1:eac0369:         ok_exit = false;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // "open" the btree, using recovery's already opened container 
1:eac0369:             OpenBTree open_btree = new OpenBTree();
1:eac0369: 
1:eac0369:             open_btree.init(
1:eac0369:                 (TransactionManager) null,  // current user xact - not needed
1:eac0369:                 (TransactionManager) null,  // current xact      - not needed
1:eac0369:                 pageOp.getContainer(),      // recovery already opened container
1:eac0369:                 rawtran, 
1:eac0369:                 false,
1:eac0369:                 ContainerHandle.MODE_FORUPDATE, 
1:eac0369:                                             // open_mode not used - container is
1:eac0369:                                             // already opened.
1:eac0369:                 TransactionManager.MODE_NONE,
1:eac0369:                 (BTreeLockingPolicy) null,  // don't get locks during undo
1:eac0369:                 btree,                       
1:eac0369:                 (LogicalUndo) null,         // no logical undo necessary, as 
1:eac0369:                                             // this code only does read.
1:eac0369:                 (DynamicCompiledOpenConglomInfo) null);
1:eac0369: 
1:eac0369:             // System.out.println(
1:eac0369:               //   "calling logical undo, recordhandle = " + rechandle);
1:eac0369:             // System.out.println("calling logical undo, record= " + 
1:eac0369:               //    logged_index_row_template);
1:eac0369: 
1:eac0369:             // Get the page where the record was originally, before splits
1:eac0369:             // could have possibly moved it.
1:4a2b0d9:             control_row = ControlRow.get(open_btree, rechandle.getPageNumber());
1:eac0369: 
1:eac0369:             // init compare_result, if record doesn't exist do the search 
1:eac0369:             compare_result = 1;
1:eac0369: 
1:eac0369:             if (control_row.getPage().recordExists(rechandle, true))
1:eac0369:             {
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         control_row.getPage().fetchNumFields(rechandle) ==
1:eac0369:                         logged_index_row_template.length);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // create template for the page index row from the conglomerate.
1:eac0369:                 RecordHandle ret_rechandle = 
1:eac0369:                     control_row.getPage().fetchFromSlot(
1:eac0369:                         (RecordHandle) null,
1:eac0369:                         control_row.getPage().getSlotNumber(rechandle),
1:eac0369:                         template, 
1:eac0369:                         (FetchDescriptor) null,
1:eac0369:                         true);
1:eac0369: 
1:eac0369:                 // compare the 2 rows, and if they are the same then the raw 
1:eac0369:                 // store has the right page and record and there is no work to
1:eac0369:                 // be done (this is usual case).
1:4a2b0d9:                 compare_result = ControlRow.compareIndexRowToKey(
1:eac0369:                     template, logged_index_row_template, 
1:eac0369:                     logged_index_row_template.length, 1, 
1:eac0369:                     open_btree.getColumnSortOrderInfo());
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (compare_result == 0)
1:eac0369:             {
1:eac0369:                 ret_page = control_row.getPage();
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // if the 2 don't compare equal, search the btree from the root 
1:eac0369:                 // for the logged row, find the leaf, reset the row for the raw 
1:eac0369:                 // store, and return the new page latched.
1:eac0369:                 
1:eac0369:                 // Create the objects needed for the insert.
1:eac0369:                 SearchParameters sp = new SearchParameters(
1:eac0369:                         logged_index_row_template, ScanController.GE, 
1:eac0369:                         template, open_btree, false);
1:eac0369: 
1:eac0369:                 control_row.release();
1:eac0369:                 control_row = null;
1:eac0369:                 control_row = 
1:4a2b0d9:                     ControlRow.get(open_btree, BTree.ROOTPAGEID).search(sp);
1:eac0369: 
1:eac0369:                 if (!sp.resultExact)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         SanityManager.THROWASSERT(
1:eac0369:                             "B2IUndo - could not find key being searched for:" +
1:eac0369:                             ";key = " + 
1:eac0369:                                 RowUtil.toString(logged_index_row_template) + 
1:eac0369:                             ";sp = " + sp +
1:eac0369:                             "control_row = " + control_row +
1:eac0369:                             "control_row.debugPage() = " +
1:eac0369:                                 control_row.debugPage(open_btree) +
1:eac0369:                             "control_row.getPage() = " + 
1:eac0369:                                 control_row.getPage());
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     throw StandardException.newException(
1:eac0369:                             SQLState.BTREE_ROW_NOT_FOUND_DURING_UNDO);
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     RecordHandle rh = 
1:eac0369:                         control_row.getPage().fetchFromSlot(
1:eac0369:                             (RecordHandle) null,
1:eac0369:                             sp.resultSlot, new DataValueDescriptor[0], 
1:eac0369:                             (FetchDescriptor) null,
1:eac0369:                             true);
1:eac0369: 
1:eac0369:                     pageOp.resetRecordHandle(rh);
1:eac0369: 
1:eac0369:                     ret_page = control_row.getPage();
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             ok_exit = true;
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             //System.out.println("B2iUndo returning with rec handle: " +  
1:eac0369:              //                   pageOp.getRecordHandle());
1:eac0369:             if ((!ok_exit) && (control_row != null))
1:eac0369:                 control_row.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_page);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() 
1:eac0369:     {
1:eac0369: 		return StoredFormatIds.ACCESS_B2IUNDO_V1_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     This object has no state, so nothing to write.*/
1:eac0369: 
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369:     {
2:eac0369:         return;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Restore the in-memory representation from the stream.
1:eac0369: 
1:eac0369:     This object has no state, so nothing to restore.
1:eac0369: 	@exception ClassNotFoundException Thrown if the stored representation is
1:eac0369: 	serialized and a class named in the stream could not be found.
1:eac0369: 
1:eac0369: 	@see java.io.Externalizable#readExternal
1:eac0369: 	*/
1:eac0369: 	public void readExternal(ObjectInput in)
2:eac0369: 		throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369:         return;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5baee93
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_B2IUNDO_V1_ID
1:  * @derby.purpose   Implements the LogicalUndo and Formatable interfaces, basically
1:  * @derby.upgrade   RESOLVE.
1:  * @derby.diskLayout 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:             logged_index_row_template = btree.createTemplate(rawtran);
1:             template                  = btree.createTemplate(rawtran);
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
1: 	 * @param rawtran   the transaction doing the rollback
1: 	 * @param pageOp    the page operation that supports logical undo.  This
1: 	 * 		            LogicalUndo function pointer is a field of that 
1:      * 		            pageOperation
1: 	 * @param in        data stored in the log stream that contains the record 
1:      *                  data necessary to restore the row.
0:      * @exception StandardException Standard Cloudscape error policy
1: 	 * @exception IOException Method may read from InputStream
1:      *
1:     Transaction         rawtran, 
1:     LogicalUndoable     pageOp,
1:     LimitObjectInput    in)
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(container, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:             control_row = ControlRow.get(open_btree, rechandle.getPageNumber());
/////////////////////////////////////////////////////////////////////////
1:                 compare_result = ControlRow.compareIndexRowToKey(
/////////////////////////////////////////////////////////////////////////
1:                     ControlRow.get(open_btree, BTree.ROOTPAGEID).search(sp);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException Standard Derby error policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2IUndo
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree.index;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.LogicalUndoable;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: // imports of inherited impl's
1: import org.apache.derby.impl.store.access.btree.BTree;
1: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
1: import org.apache.derby.impl.store.access.btree.ControlRow;
1: import org.apache.derby.impl.store.access.btree.OpenBTree;
1: import org.apache.derby.impl.store.access.btree.SearchParameters;
1: 
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: import java.io.ObjectOutput;
1: import org.apache.derby.iapi.services.io.LimitObjectInput;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
0:  * @format_id ACCESS_B2IUNDO_V1_ID
1:  *
0:  * @purpose   Implements the LogicalUndo and Formatable interfaces, basically
1:  *            providing a way for raw store recovery to "call back" access code
1:  *            to provide logical undo ability.
1:  *
0:  * @upgrade   RESOLVE.
1:  *
0:  * @disk_layout 
1:  *     No state associated with this format.
1:  *
1:  **/
1: 
1: /**
1: 
1: The B2IUndo interface packages up the routines which the rawstore needs
1: to call to perform logical undo of a record in a B2i.  The rawstore will
1: determine that a page has changed since the record was written, and if it
1: has it will call the findUndo() interface, to find the page where the record
1: exists (as it may have moved).
1: <p>
1: This class must not contain any persistent state, as this class is stored
1: in the log record of the insert/delete.
1: 
1: @see org.apache.derby.iapi.store.raw.LogicalUndoable
1: @see org.apache.derby.iapi.store.raw.Undoable#generateUndo 
1: **/
1: public class B2IUndo implements LogicalUndo, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 * Find the page and record to undo.  If no logical undo is necessary,
1: 	 * i.e., row has not moved, then just return the latched page where undo
1: 	 * should go.  If the record has moved, it has a new recordId on the new
1: 	 * page, this routine needs to call pageOp.resetRecord with the new
1: 	 * RecordHandle so that the logging system can update the compensation
1: 	 * Operation with the new location.
1:      *
0: 	 * @param transaction the transaction doing the rollback
0: 	 * @param pageOp the page operation that supports logical undo.  This
0: 	 * 		LogicalUndo function pointer is a field of that pageOperation
0: 	 * @param in data stored in the log stream that contains the record data
0: 	 * 		necessary to restore the row.
1:      *
0:      *	@exception StandardException Standard Cloudscape error policy
0: 	 *  @exception IOException Method may read from InputStream
1: 	 */
1: 	public Page findUndo(
0:     Transaction     rawtran, 
0:     LogicalUndoable pageOp,
0:     LimitObjectInput     in)
1:         throws StandardException, IOException
1:     {
1:         ControlRow            root                      = null;
1:         ControlRow            control_row               = null;
1:         DataValueDescriptor[] logged_index_row_template = null;
1:         DataValueDescriptor[] template                  = null;
1:         Page                  ret_page                  = null;
1:         ContainerHandle       container                 = pageOp.getContainer();
1:         RecordHandle          rechandle                 = pageOp.getRecordHandle();
1:         boolean               ok_exit                   = false;
1:         int                   compare_result            = 1;
1:         B2I                   btree                     = null;
1: 
1:         // Open the btree to associate the open contain handle, thus the 
1:         // current xact with all subsequent operations during undo.
1: 
1: 
1:         try
1:         {
1: 
1:             // Need Conglomerate to create templates - get from the root page.
0:             root = ControlRow.Get(container, BTree.ROOTPAGEID);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(root.getPage().isLatched());
1: 
1:             btree = (B2I) root.getConglom(B2I.FORMAT_NUMBER);
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(btree instanceof B2I);
1: 
1:             // create a template for the logged index row from the conglomerate.
0:             logged_index_row_template = btree.createTemplate();
1: 
1:             // create a template for the page index row from the conglomerate.
0:             template                  = btree.createTemplate();
1:         }
1:         finally
1:         {
1:             if (root != null)
1:                 root.release();
1:         }
1: 
1:         // Get logged row from record.
1:         pageOp.restoreLoggedRow(logged_index_row_template, in);
1: 
1:         // RESOLVE (mikem) - currently restoreLoggedRow() may latch and unlatch
1:         // a page in the container (see ST059).
1:         // Now get the page where the record used to be.
1: 
1:         ok_exit = false;
1:         try
1:         {
1:             // "open" the btree, using recovery's already opened container 
1:             OpenBTree open_btree = new OpenBTree();
1: 
1:             open_btree.init(
1:                 (TransactionManager) null,  // current user xact - not needed
1:                 (TransactionManager) null,  // current xact      - not needed
1:                 pageOp.getContainer(),      // recovery already opened container
1:                 rawtran, 
1:                 false,
1:                 ContainerHandle.MODE_FORUPDATE, 
1:                                             // open_mode not used - container is
1:                                             // already opened.
1:                 TransactionManager.MODE_NONE,
1:                 (BTreeLockingPolicy) null,  // don't get locks during undo
1:                 btree,                       
1:                 (LogicalUndo) null,         // no logical undo necessary, as 
1:                                             // this code only does read.
1:                 (DynamicCompiledOpenConglomInfo) null);
1: 
1:             // System.out.println(
1:               //   "calling logical undo, recordhandle = " + rechandle);
1:             // System.out.println("calling logical undo, record= " + 
1:               //    logged_index_row_template);
1: 
1:             // Get the page where the record was originally, before splits
1:             // could have possibly moved it.
0:             control_row = ControlRow.Get(open_btree, rechandle.getPageNumber());
1: 
1:             // init compare_result, if record doesn't exist do the search 
1:             compare_result = 1;
1: 
1:             if (control_row.getPage().recordExists(rechandle, true))
1:             {
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(
1:                         control_row.getPage().fetchNumFields(rechandle) ==
1:                         logged_index_row_template.length);
1:                 }
1: 
1:                 // create template for the page index row from the conglomerate.
1:                 RecordHandle ret_rechandle = 
1:                     control_row.getPage().fetchFromSlot(
1:                         (RecordHandle) null,
1:                         control_row.getPage().getSlotNumber(rechandle),
1:                         template, 
1:                         (FetchDescriptor) null,
1:                         true);
1: 
1:                 // compare the 2 rows, and if they are the same then the raw 
1:                 // store has the right page and record and there is no work to
1:                 // be done (this is usual case).
0:                 compare_result = ControlRow.CompareIndexRowToKey(
1:                     template, logged_index_row_template, 
1:                     logged_index_row_template.length, 1, 
1:                     open_btree.getColumnSortOrderInfo());
1:             }
1: 
1:             if (compare_result == 0)
1:             {
1:                 ret_page = control_row.getPage();
1:             }
1:             else
1:             {
1:                 // if the 2 don't compare equal, search the btree from the root 
1:                 // for the logged row, find the leaf, reset the row for the raw 
1:                 // store, and return the new page latched.
1:                 
1:                 // Create the objects needed for the insert.
1:                 SearchParameters sp = new SearchParameters(
1:                         logged_index_row_template, ScanController.GE, 
1:                         template, open_btree, false);
1: 
1:                 control_row.release();
1:                 control_row = null;
1:                 control_row = 
0:                     ControlRow.Get(open_btree, BTree.ROOTPAGEID).search(sp);
1: 
1:                 if (!sp.resultExact)
1:                 {
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.THROWASSERT(
1:                             "B2IUndo - could not find key being searched for:" +
1:                             ";key = " + 
1:                                 RowUtil.toString(logged_index_row_template) + 
1:                             ";sp = " + sp +
1:                             "control_row = " + control_row +
1:                             "control_row.debugPage() = " +
1:                                 control_row.debugPage(open_btree) +
1:                             "control_row.getPage() = " + 
1:                                 control_row.getPage());
1:                     }
1: 
1:                     throw StandardException.newException(
1:                             SQLState.BTREE_ROW_NOT_FOUND_DURING_UNDO);
1:                 }
1:                 else
1:                 {
1:                     RecordHandle rh = 
1:                         control_row.getPage().fetchFromSlot(
1:                             (RecordHandle) null,
1:                             sp.resultSlot, new DataValueDescriptor[0], 
1:                             (FetchDescriptor) null,
1:                             true);
1: 
1:                     pageOp.resetRecordHandle(rh);
1: 
1:                     ret_page = control_row.getPage();
1:                 }
1:             }
1:             ok_exit = true;
1:         }
1:         finally
1:         {
1:             //System.out.println("B2iUndo returning with rec handle: " +  
1:              //                   pageOp.getRecordHandle());
1:             if ((!ok_exit) && (control_row != null))
1:                 control_row.release();
1:         }
1: 
1:         return(ret_page);
1:     }
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() 
1:     {
1: 		return StoredFormatIds.ACCESS_B2IUNDO_V1_ID;
1: 	}
1: 
1: 	/**
1:     This object has no state, so nothing to write.*/
1: 
1: 	public void writeExternal(ObjectOutput out) throws IOException
1:     {
1:         return;
1: 	}
1: 
1: 	/**
1: 	Restore the in-memory representation from the stream.
1: 
1:     This object has no state, so nothing to restore.
1: 	@exception ClassNotFoundException Thrown if the stored representation is
1: 	serialized and a class named in the stream could not be found.
1: 
1: 	@see java.io.Externalizable#readExternal
1: 	*/
1: 	public void readExternal(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1:         return;
1: 	}
0: 	public void readExternal(ArrayInputStream in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1:         return;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree.index;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.LogicalUndoable;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: // imports of inherited impl's
0: import org.apache.derby.impl.store.access.btree.BTree;
0: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
0: import org.apache.derby.impl.store.access.btree.ControlRow;
0: import org.apache.derby.impl.store.access.btree.OpenBTree;
0: import org.apache.derby.impl.store.access.btree.SearchParameters;
0: 
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.io.ObjectOutput;
0: import org.apache.derby.iapi.services.io.LimitObjectInput;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * @format_id ACCESS_B2IUNDO_V1_ID
0:  *
0:  * @purpose   Implements the LogicalUndo and Formatable interfaces, basically
0:  *            providing a way for raw store recovery to "call back" access code
0:  *            to provide logical undo ability.
0:  *
0:  * @upgrade   RESOLVE.
0:  *
0:  * @disk_layout 
0:  *     No state associated with this format.
0:  *
0:  **/
0: 
0: /**
0: 
0: The B2IUndo interface packages up the routines which the rawstore needs
0: to call to perform logical undo of a record in a B2i.  The rawstore will
0: determine that a page has changed since the record was written, and if it
0: has it will call the findUndo() interface, to find the page where the record
0: exists (as it may have moved).
0: <p>
0: This class must not contain any persistent state, as this class is stored
0: in the log record of the insert/delete.
0: 
0: @see org.apache.derby.iapi.store.raw.LogicalUndoable
0: @see org.apache.derby.iapi.store.raw.Undoable#generateUndo 
0: **/
0: public class B2IUndo implements LogicalUndo, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * Find the page and record to undo.  If no logical undo is necessary,
0: 	 * i.e., row has not moved, then just return the latched page where undo
0: 	 * should go.  If the record has moved, it has a new recordId on the new
0: 	 * page, this routine needs to call pageOp.resetRecord with the new
0: 	 * RecordHandle so that the logging system can update the compensation
0: 	 * Operation with the new location.
0:      *
0: 	 * @param transaction the transaction doing the rollback
0: 	 * @param pageOp the page operation that supports logical undo.  This
0: 	 * 		LogicalUndo function pointer is a field of that pageOperation
0: 	 * @param in data stored in the log stream that contains the record data
0: 	 * 		necessary to restore the row.
0:      *
0:      *	@exception StandardException Standard Cloudscape error policy
0: 	 *  @exception IOException Method may read from InputStream
0: 	 */
0: 	public Page findUndo(
0:     Transaction     rawtran, 
0:     LogicalUndoable pageOp,
0:     LimitObjectInput     in)
0:         throws StandardException, IOException
0:     {
0:         ControlRow            root                      = null;
0:         ControlRow            control_row               = null;
0:         DataValueDescriptor[] logged_index_row_template = null;
0:         DataValueDescriptor[] template                  = null;
0:         Page                  ret_page                  = null;
0:         ContainerHandle       container                 = pageOp.getContainer();
0:         RecordHandle          rechandle                 = pageOp.getRecordHandle();
0:         boolean               ok_exit                   = false;
0:         int                   compare_result            = 1;
0:         B2I                   btree                     = null;
0: 
0:         // Open the btree to associate the open contain handle, thus the 
0:         // current xact with all subsequent operations during undo.
0: 
0: 
0:         try
0:         {
0: 
0:             // Need Conglomerate to create templates - get from the root page.
0:             root = ControlRow.Get(container, BTree.ROOTPAGEID);
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(root.getPage().isLatched());
0: 
0:             btree = (B2I) root.getConglom(B2I.FORMAT_NUMBER);
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(btree instanceof B2I);
0: 
0:             // create a template for the logged index row from the conglomerate.
0:             logged_index_row_template = btree.createTemplate();
0: 
0:             // create a template for the page index row from the conglomerate.
0:             template                  = btree.createTemplate();
0:         }
0:         finally
0:         {
0:             if (root != null)
0:                 root.release();
0:         }
0: 
0:         // Get logged row from record.
0:         pageOp.restoreLoggedRow(logged_index_row_template, in);
0: 
0:         // RESOLVE (mikem) - currently restoreLoggedRow() may latch and unlatch
0:         // a page in the container (see ST059).
0:         // Now get the page where the record used to be.
0: 
0:         ok_exit = false;
0:         try
0:         {
0:             // "open" the btree, using recovery's already opened container 
0:             OpenBTree open_btree = new OpenBTree();
0: 
0:             open_btree.init(
0:                 (TransactionManager) null,  // current user xact - not needed
0:                 (TransactionManager) null,  // current xact      - not needed
0:                 pageOp.getContainer(),      // recovery already opened container
0:                 rawtran, 
0:                 false,
0:                 ContainerHandle.MODE_FORUPDATE, 
0:                                             // open_mode not used - container is
0:                                             // already opened.
0:                 TransactionManager.MODE_NONE,
0:                 (BTreeLockingPolicy) null,  // don't get locks during undo
0:                 btree,                       
0:                 (LogicalUndo) null,         // no logical undo necessary, as 
0:                                             // this code only does read.
0:                 (DynamicCompiledOpenConglomInfo) null);
0: 
0:             // System.out.println(
0:               //   "calling logical undo, recordhandle = " + rechandle);
0:             // System.out.println("calling logical undo, record= " + 
0:               //    logged_index_row_template);
0: 
0:             // Get the page where the record was originally, before splits
0:             // could have possibly moved it.
0:             control_row = ControlRow.Get(open_btree, rechandle.getPageNumber());
0: 
0:             // init compare_result, if record doesn't exist do the search 
0:             compare_result = 1;
0: 
0:             if (control_row.getPage().recordExists(rechandle, true))
0:             {
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT(
0:                         control_row.getPage().fetchNumFields(rechandle) ==
0:                         logged_index_row_template.length);
0:                 }
0: 
0:                 // create template for the page index row from the conglomerate.
0:                 RecordHandle ret_rechandle = 
0:                     control_row.getPage().fetchFromSlot(
0:                         (RecordHandle) null,
0:                         control_row.getPage().getSlotNumber(rechandle),
0:                         template, 
0:                         (FetchDescriptor) null,
0:                         true);
0: 
0:                 // compare the 2 rows, and if they are the same then the raw 
0:                 // store has the right page and record and there is no work to
0:                 // be done (this is usual case).
0:                 compare_result = ControlRow.CompareIndexRowToKey(
0:                     template, logged_index_row_template, 
0:                     logged_index_row_template.length, 1, 
0:                     open_btree.getColumnSortOrderInfo());
0:             }
0: 
0:             if (compare_result == 0)
0:             {
0:                 ret_page = control_row.getPage();
0:             }
0:             else
0:             {
0:                 // if the 2 don't compare equal, search the btree from the root 
0:                 // for the logged row, find the leaf, reset the row for the raw 
0:                 // store, and return the new page latched.
0:                 
0:                 // Create the objects needed for the insert.
0:                 SearchParameters sp = new SearchParameters(
0:                         logged_index_row_template, ScanController.GE, 
0:                         template, open_btree, false);
0: 
0:                 control_row.release();
0:                 control_row = null;
0:                 control_row = 
0:                     ControlRow.Get(open_btree, BTree.ROOTPAGEID).search(sp);
0: 
0:                 if (!sp.resultExact)
0:                 {
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         SanityManager.THROWASSERT(
0:                             "B2IUndo - could not find key being searched for:" +
0:                             ";key = " + 
0:                                 RowUtil.toString(logged_index_row_template) + 
0:                             ";sp = " + sp +
0:                             "control_row = " + control_row +
0:                             "control_row.debugPage() = " +
0:                                 control_row.debugPage(open_btree) +
0:                             "control_row.getPage() = " + 
0:                                 control_row.getPage());
0:                     }
0: 
0:                     throw StandardException.newException(
0:                             SQLState.BTREE_ROW_NOT_FOUND_DURING_UNDO);
0:                 }
0:                 else
0:                 {
0:                     RecordHandle rh = 
0:                         control_row.getPage().fetchFromSlot(
0:                             (RecordHandle) null,
0:                             sp.resultSlot, new DataValueDescriptor[0], 
0:                             (FetchDescriptor) null,
0:                             true);
0: 
0:                     pageOp.resetRecordHandle(rh);
0: 
0:                     ret_page = control_row.getPage();
0:                 }
0:             }
0:             ok_exit = true;
0:         }
0:         finally
0:         {
0:             //System.out.println("B2iUndo returning with rec handle: " +  
0:              //                   pageOp.getRecordHandle());
0:             if ((!ok_exit) && (control_row != null))
0:                 control_row.release();
0:         }
0: 
0:         return(ret_page);
0:     }
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() 
0:     {
0: 		return StoredFormatIds.ACCESS_B2IUNDO_V1_ID;
0: 	}
0: 
0: 	/**
0:     This object has no state, so nothing to write.*/
0: 
0: 	public void writeExternal(ObjectOutput out) throws IOException
0:     {
0:         return;
0: 	}
0: 
0: 	/**
0: 	Restore the in-memory representation from the stream.
0: 
0:     This object has no state, so nothing to restore.
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
0: 
0: 	@see java.io.Externalizable#readExternal
0: 	*/
0: 	public void readExternal(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0:         return;
0: 	}
0: 	public void readExternal(ArrayInputStream in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0:         return;
0: 	}
0: }
============================================================================