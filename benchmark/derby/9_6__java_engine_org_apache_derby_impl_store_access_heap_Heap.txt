2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.Heap
1:b61f876: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
13:eac0369: 
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatIdUtil;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
2:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:b61f876: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:c05d3df: import org.apache.derby.iapi.store.raw.PageKey;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b61f876: import org.apache.derby.iapi.types.StringDataValue;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1:eac0369: 
3:eac0369: /**
1:787ceb4:  * @derby.formatId ACCESS_HEAP_V2_ID
5:eac0369:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the Heap
1:b61f876:  *            conglomerate object.  Access contains no "directory" of 
1:b61f876:  *            conglomerate information.  In order to bootstrap opening a file
1:b61f876:  *            it encodes the factory that can open the conglomerate in the 
1:b61f876:  *            conglomerate id itself.  There exists a single HeapFactory which
1:b61f876:  *            must be able to read all heap format id's.  
1:b61f876:  *
1:b61f876:  *            This format was used for all Derby database Heap's in version
1:b61f876:  *            10.2 and previous versions.
1:eac0369:  *
1:787ceb4:  * @derby.upgrade   The format id of this object is currently always read from disk
1:b61f876:  *            as the first field of the conglomerate itself.  A bootstrap
1:b61f876:  *            problem exists as we don't know the format id of the heap 
1:b61f876:  *            until we are in the "middle" of reading the Heap.  Thus the
1:b61f876:  *            base Heap implementation must be able to read and write 
1:b61f876:  *            all formats based on the reading the 
1:b61f876:  *            "format_of_this_conglomerate". 
1:eac0369:  *
1:b61f876:  *            soft upgrade to ACCESS_HEAP_V3_ID:
1:b61f876:  *                read:
1:b61f876:  *                    old format is readable by current Heap implementation,
1:b61f876:  *                    with automatic in memory creation of default collation
1:b61f876:  *                    id needed by new format.  No code other than
1:b61f876:  *                    readExternal and writeExternal need know about old format.
1:b61f876:  *                write:
1:b61f876:  *                    will never write out new format id in soft upgrade mode.
1:b61f876:  *                    Code in readExternal and writeExternal handles writing
1:b61f876:  *                    correct version.  Code in the factory handles making
1:b61f876:  *                    sure new conglomerates use the Heap_v10_2 class to 
1:b61f876:  *                    that will write out old format info.
1:b61f876:  *
1:b61f876:  *            hard upgrade to ACCESS_HEAP_V3_ID:
1:b61f876:  *                read:
1:b61f876:  *                    old format is readable by current Heap implementation,
1:b61f876:  *                    with automatic in memory creation of default collation
1:b61f876:  *                    id needed by new format.
1:b61f876:  *                write:
1:b61f876:  *                    Only "lazy" upgrade will happen.  New format will only
1:b61f876:  *                    get written for new conglomerate created after the 
1:b61f876:  *                    upgrade.  Old conglomerates continue to be handled the
1:b61f876:  *                    same as soft upgrade.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout
1:eac0369:  *     format_of_this_conlgomerate(byte[])
2:eac0369:  *     containerid(long)
2:eac0369:  *     segmentid(int)
1:eac0369:  *     number_of_columns(int)
1:eac0369:  *     array_of_format_ids(byte[][])
2:eac0369:  **/
1:eac0369: 
1:eac0369: /**
1:787ceb4:  * @derby.formatId ACCESS_HEAP_V3_ID
1:b61f876:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the Heap
1:b61f876:  *            conglomerate object.  The Heap conglomerate object is stored in
1:b61f876:  *            a field of a row in the Conglomerate directory.
1:b61f876:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the Heap
1:b61f876:  *            conglomerate object.  Access contains no "directory" of 
1:b61f876:  *            conglomerate information.  In order to bootstrap opening a file
1:b61f876:  *            it encodes the factory that can open the conglomerate in the 
1:b61f876:  *            conglomerate id itself.  There exists a single HeapFactory which
1:b61f876:  *            must be able to read all heap format id's.  
1:b61f876:  *
1:b61f876:  *            This format is used for all Derby database Heap's in versions
1:b61f876:  *            subsequent to 10.2.  The format is contains first the 
1:b61f876:  *            ACCESS_HEAP_V2_ID format, followed by a compressed representation
1:b61f876:  *            of the collation id's of each column in the heap.
1:b61f876:  *
1:787ceb4:  * @derby.upgrade   This is the current version, no upgrade necessary.
1:b61f876:  *
1:787ceb4:  * @derby.diskLayout
1:b61f876:  *     format_of_this_conlgomerate(byte[])
1:b61f876:  *     containerid(long)
1:b61f876:  *     segmentid(int)
1:b61f876:  *     number_of_columns(int)
1:b61f876:  *     array_of_format_ids(byte[][])
1:b61f876:  *     collation_ids(compressed array of ints)
1:b61f876:  **/
1:b61f876: 
1:b61f876: /**
1:eac0369: 
1:eac0369:   A heap object corresponds to an instance of a heap conglomerate.  It caches
1:eac0369:   information which makes it fast to open heap controllers from it.
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:b61f876: public class Heap 
1:eac0369:     extends    GenericConglomerate
1:eac0369:     implements Conglomerate, StaticCompiledOpenConglomInfo
1:b61f876: {
1:b61f876: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Fields of Heap.
1:eac0369: 	*/
1:eac0369: 
1:b61f876:     /**
1:b61f876:      * Format id of the conglomerate.
1:b61f876:      **/
1:b61f876: 	protected int conglom_format_id;
1:b61f876: 
1:18176ce: 	private ContainerKey id;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The format id's of each of the columns in the heap table.
1:eac0369:      **/
1:eac0369:     int[]    format_ids;
1:eac0369: 
1:b61f876:     /**
1:b61f876:     The array of collation id's for each column in the template.
1:b61f876:     **/
1:b61f876:     protected int[]   collation_ids;
1:9a3cbed:     /**
1:9a3cbed:      * Tells if there is at least one column in the conglomerate whose collation
1:9a3cbed:      * isn't StringDataValue.COLLATION_TYPE_UCS_BASIC.
1:9a3cbed:      */
1:9a3cbed:     private boolean hasCollatedTypes;
1:b61f876: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( Heap.class);
1:eac0369:     private static final int CONTAINER_KEY_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( ContainerKey.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
5:eac0369:     {
1:eac0369:         int sz = BASE_MEMORY_USAGE;
1:eac0369: 
1:eac0369:         if( null != id)
1:eac0369:             sz += CONTAINER_KEY_MEMORY_USAGE;
1:eac0369:         if( null != format_ids)
1:eac0369:             sz += format_ids.length*ClassSize.getIntSize();
1:eac0369:         return sz;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Heap.
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /* Constructors for This class: */
1:eac0369: 
1:eac0369:     /**
1:75b112d:      * Zero arg constructor for Monitor to create empty object.
1:eac0369:      **/
1:eac0369:     public Heap()
1:eac0369:     {
3:eac0369:     }
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a heap conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Create a heap conglomerate.  This method is called from the heap factory
1:eac0369:      * to create a new instance of a heap.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected void create(
1:eac0369:     Transaction             rawtran,
1:eac0369:     int                     segmentId,
1:eac0369:     long                    input_containerid,
1:eac0369:     DataValueDescriptor[]   template,
1:b61f876:     ColumnOrdering[]        columnOrder,
1:b61f876:     int[]                   collationIds,
1:eac0369:     Properties              properties,
1:b61f876:     int                     conglom_format_id,
1:eac0369: 	int                     tmpFlag)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Create a container for the heap table with
1:eac0369: 		// default minimumRecordSize to be at least
1:eac0369: 		// MINIMUM_RECORD_SIZE_DEFAULT (12),
1:eac0369: 		// to guarantee there is enough room for updates
1:eac0369: 		// of the row.
1:eac0369: 		// Here we only take care of the case that
1:eac0369: 		// that the properties are set with the create
1:eac0369: 		// statement.  For the case when properties are
1:eac0369: 		// not set with the create statement, it is taken
1:eac0369: 		// care of in fileContainer.java: createInfoFromProp().
1:eac0369: 		if (properties != null) 
1:eac0369:         {
1:eac0369: 			String value = properties.getProperty(
1:eac0369: 				RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER);
1:eac0369: 
1:eac0369: 			int minimumRecordSize =
1:eac0369: 				(value == null) ? 
1:eac0369:                     RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT : 
1:eac0369:                     Integer.parseInt(value);
1:eac0369: 
1:eac0369: 			if (minimumRecordSize < RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT)
1:eac0369: 			{
1:eac0369: 				properties.put(
1:eac0369:                     RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,
1:eac0369: 					Integer.toString(
1:eac0369:                         RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Create a container for the heap with default page size.
1:eac0369: 		long containerid = 
1:eac0369:             rawtran.addContainer(
1:eac0369:                 segmentId, input_containerid, 
1:eac0369:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
1:eac0369: 
1:eac0369: 		// Make sure the container was actually created.
1:eac0369: 		if (containerid < 0)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_CANT_CREATE_CONTAINER);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Keep track of what segment the container's in.
1:eac0369: 		id = new ContainerKey(segmentId, containerid);
1:eac0369: 
1:eac0369: 		// Heap requires a template representing every column in the table.
1:eac0369:         if ((template == null) || (template.length == 0))
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_COULD_NOT_CREATE_CONGLOMERATE);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // get format id's from each column in template and store it in the
1:eac0369:         // conglomerate state.
1:eac0369:         this.format_ids = ConglomerateUtil.createFormatIds(template);
1:eac0369: 
1:b61f876:         // copy the format id of the conglomerate.
1:b61f876:         this.conglom_format_id = conglom_format_id;
1:b61f876: 
1:b61f876:         // get collation ids from input collation ids, store it in the 
1:b61f876:         // conglom state.
1:b61f876:         collation_ids = 
1:b61f876:             ConglomerateUtil.createCollationIds(
1:b61f876:                 format_ids.length, collationIds);
1:9a3cbed:         hasCollatedTypes = hasCollatedColumns(collation_ids);
1:eac0369: 
1:eac0369:         // need to open the container and insert the row.  Since we are
1:eac0369:         // creating it no need to bother with locking since no one can get
1:eac0369:         // to it until after we have created it and returned it's id.
1:eac0369:         ContainerHandle container = null;
1:eac0369:         Page            page      = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             container = 
1:eac0369:                 rawtran.openContainer(
1:eac0369:                     id, (LockingPolicy) null, 
1:eac0369:                     ContainerHandle.MODE_FORUPDATE | 
1:eac0369:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
1:eac0369: 
1:eac0369:             // row in slot 0 of heap page 1 which is just a single column with
1:eac0369:             // the heap entry.
1:eac0369:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
1:eac0369:             control_row[0] = this;
1:eac0369: 
1:eac0369:             page =
1:eac0369:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1:eac0369: 
1:eac0369:             page.insertAtSlot(
1:eac0369:                 Page.FIRST_SLOT_NUMBER,
1:eac0369:                 control_row,
1:eac0369:                 (FormatableBitSet) null,
1:eac0369:                 (LogicalUndo) null, 
1:eac0369:                 Page.INSERT_OVERFLOW,
1:eac0369:                 AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:eac0369:             page.unlatch();
1:eac0369:             page = null;
1:eac0369: 
1:eac0369:             // Don't include the control row in the estimated row count.
1:eac0369:             container.setEstimatedRowCount(0, /* unused flag */ 0);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (container != null)
1:eac0369:                 container.close();
1:eac0369:             if (page !=null)
1:eac0369:                 page.unlatch();
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Create a heap conglomerate during the boot process.
1:eac0369:      * <p>
1:eac0369:      * Manufacture a Heap Conglomerate out of "thin" air, to boot strap
1:eac0369:      * the system.  Create an in-memory Heap Conglomerate with the input
1:eac0369:      * parameters, The caller will use this to open the conglomerate
1:eac0369:      * conglomerate and read the "real" values from disk.  Conglom-conglom
1:eac0369:      * is always on segment 0.
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param containerid The container id of the conglomerate.
1:eac0369:      * @param template    Object array describing the columns of the heap.
1:eac0369:      **/
1:eac0369:     public void boot_create(
1:eac0369:     long                    containerid,
1:eac0369:     DataValueDescriptor[]   template)
1:eac0369:     {
1:eac0369: 		id = new ContainerKey(0, containerid);
1:eac0369:         this.format_ids = ConglomerateUtil.createFormatIds(template);
1:eac0369:     }
1:eac0369: 
1:dbde907: 	/*
1:eac0369: 	** Methods of Conglomerate
1:dbde907: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Add a column to the heap conglomerate.
1:eac0369:      * <p>
1:eac0369:      * This routine update's the in-memory object version of the Heap
1:eac0369:      * Conglomerate to have one more column of the type described by the
1:eac0369:      * input template column.  
1:eac0369:      * 
1:eac0369:      * @param column_id        The column number to add this column at.
1:eac0369:      * @param template_column  An instance of the column to be added to table.
1:b61f876:      * @param collation_id     Collation id of the column added.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void addColumn(
1:eac0369: 	TransactionManager  xact_manager,
1:eac0369:     int                 column_id,
1:b61f876:     Storable            template_column,
1:b61f876:     int                 collation_id)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // need to open the container and update the row containing the 
1:eac0369:         // serialized format of the heap.  
1:eac0369:         ContainerHandle container = null;
1:eac0369:         Page            page      = null;
1:eac0369:         Transaction     rawtran   = xact_manager.getRawStoreXact();
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             container = 
1:eac0369:                 rawtran.openContainer(
1:eac0369:                     id, 
1:eac0369:                     rawtran.newLockingPolicy(
1:eac0369:                         LockingPolicy.MODE_CONTAINER,
1:eac0369:                         TransactionController.ISOLATION_SERIALIZABLE, true),
1:eac0369:                     ContainerHandle.MODE_FORUPDATE | 
1:eac0369:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
1:eac0369: 
1:dbde907:             // DERBY-6774 - temp disabling this ASSERT while working on
1:dbde907:             // why it is firing in trunk.   The hope is that trunk tests
1:dbde907:             // will pass for others while I work on fixing DERBY-6774.
1:dbde907:             //
1:dbde907:             // The code always adds the column after the last field even
1:dbde907:             // if there is a mismatch with what is requested.  The store
1:dbde907:             // only supports adding a column at the end anyway.
1:dbde907:             //
1:dbde907:             // I believe the issue is some sort of timing with background
1:dbde907:             // threads and alter table and the conglomerate cache.  The
1:dbde907:             // conglomerate cache was created assuming the data was static,
1:dbde907:             // but in the case of alter table add and drop column this is
1:dbde907:             // not true.  There are some attempts in the access layer to
1:dbde907:             // invalidate the cache after an abort of a alter table, but
1:dbde907:             // I think there is still a race condition.
1:dbde907: 
1:eac0369:             if (column_id != format_ids.length)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                     SanityManager.THROWASSERT(
1:888d12e:                         "Expected (column_id == format_ids.length)" +
1:eac0369:                         "column_id = " + column_id +
1:eac0369:                         "format_ids.length = " + format_ids.length +
1:eac0369:                         "format_ids = " + format_ids);
1:eac0369: 
1:eac0369:                 throw(StandardException.newException(
1:eac0369:                         SQLState.HEAP_TEMPLATE_MISMATCH,
1:ce40a31:                         column_id, 
1:ce40a31:                         this.format_ids.length));
1:eac0369:             }
1:eac0369: 
1:eac0369:             // create a new array, and copy old values to it.
1:eac0369:             int[] old_format_ids = format_ids;
1:eac0369:             format_ids              = new int[old_format_ids.length + 1];
1:eac0369:             System.arraycopy(
1:eac0369:                 old_format_ids, 0, format_ids, 0, old_format_ids.length);
1:eac0369: 
1:eac0369:             // add the new column
1:eac0369:             format_ids[old_format_ids.length] = 
1:eac0369:                 template_column.getTypeFormatId();
1:eac0369: 
1:b61f876:             // create a new collation array, and copy old values to it.
1:b61f876:             int[] old_collation_ids = collation_ids;
1:b61f876:             collation_ids           = new int[old_collation_ids.length + 1];
1:b61f876:             System.arraycopy(
1:b61f876:                 old_collation_ids, 0, collation_ids, 0, 
1:b61f876:                 old_collation_ids.length);
1:b61f876: 
1:b61f876:             // add the new column's collation id.
1:b61f876:             collation_ids[old_collation_ids.length] =  collation_id;
1:eac0369:            
1:eac0369:             // row in slot 0 of heap page 1 which is just a single column with
1:eac0369:             // the heap entry.
1:eac0369:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
1:eac0369:             control_row[0] = this;
1:eac0369: 
1:eac0369:             page =
1:eac0369:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1:eac0369: 
1:eac0369:             page.updateAtSlot(
1:eac0369:                 Page.FIRST_SLOT_NUMBER,
1:eac0369:                 control_row,
1:eac0369:                 (FormatableBitSet) null);
1:eac0369: 
1:eac0369:             page.unlatch();
1:eac0369:             page = null;
1:eac0369:         }
1:eac0369:         finally
1:b61f876:         {
1:eac0369:             if (container != null)
1:eac0369:                 container.close();
1:eac0369:             if (page !=null)
1:eac0369:                 page.unlatch();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Drop this heap.
1:eac0369: 	@see Conglomerate#drop
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public void drop(TransactionManager xact_manager)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         xact_manager.getRawStoreXact().dropContainer(id);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Retrieve the maximum value row in an ordered conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:eac0369:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:eac0369:      * there are no rows in the conglomerate it returns false.
1:eac0369:      * <p>
1:eac0369:      * Non-ordered conglomerates will not implement this interface, calls
1:eac0369:      * will generate a StandardException.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:eac0369:      * functionality will be provided by the openBackwardScan() interface.  
1:eac0369:      *
1:eac0369: 	 * @param conglomId       The identifier of the conglomerate
1:eac0369: 	 *                        to open the scan for.
1:eac0369:      *
1:eac0369: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:eac0369:      *                        OPENMODE_FORUPDATE - if set open the table for
1:eac0369:      *                        update otherwise open table shared.
1:eac0369:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:eac0369:      *
1:eac0369:      * @param isolation_level The isolation level to lock the conglomerate at.
1:eac0369:      *                        One of (ISOLATION_READ_COMMITTED or 
1:eac0369:      *                        ISOLATION_SERIALIZABLE).
1:eac0369:      *
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan.  template, 
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      *
1:eac0369:      * @param fetchRow        The row to retrieve the maximum value into.
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating if a row was found and retrieved or not.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public boolean fetchMaxOnBTree(
1:eac0369: 	TransactionManager      xact_manager,
1:eac0369:     Transaction             rawtran,
1:eac0369:     long                    conglomId,
1:eac0369:     int                     open_mode,
1:eac0369:     int                     lock_level,
1:eac0369:     LockingPolicy           locking_policy,
1:eac0369:     int                     isolation_level,
1:eac0369:     FormatableBitSet                 scanColumnList,
1:eac0369:     DataValueDescriptor[]   fetchRow)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // no support for max on a heap table.
1:eac0369:         throw(StandardException.newException(
1:eac0369:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the id of the container of the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Will have to change when a conglomerate could have more than one 
1:eac0369:      * container.  The ContainerKey is a combination of the container id
1:eac0369:      * and segment id.
1:eac0369:      *
1:eac0369: 	 * @return The ContainerKey.
1:eac0369:      **/
1:eac0369:     public final ContainerKey getId()
1:eac0369:     {
1:eac0369:         return(id);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final long getContainerid()
1:eac0369:     {
1:eac0369:         return(id.getContainerId());
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return dynamic information about the conglomerate to be dynamically 
1:eac0369:      * reused in repeated execution of a statement.
1:eac0369:      * <p>
1:eac0369:      * The dynamic info is a set of variables to be used in a given 
1:eac0369:      * ScanController or ConglomerateController.  It can only be used in one 
1:eac0369:      * controller at a time.  It is up to the caller to insure the correct 
1:eac0369:      * thread access to this info.  The type of info in this is a scratch 
1:eac0369:      * template for btree traversal, other scratch variables for qualifier 
1:eac0369:      * evaluation, ...
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The dynamic information.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:57a0040:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:9a3cbed:         return(new OpenConglomerateScratchSpace(
1:9a3cbed:                 format_ids, collation_ids, hasCollatedTypes));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return static information about the conglomerate to be included in a
1:eac0369:      * a compiled plan.
1:eac0369:      * <p>
1:eac0369:      * The static info would be valid until any ddl was executed on the 
1:eac0369:      * conglomid, and would be up to the caller to throw away when that 
1:eac0369:      * happened.  This ties in with what language already does for other 
1:eac0369:      * invalidation of static info.  The type of info in this would be 
1:eac0369:      * containerid and array of format id's from which templates can be created.
1:eac0369:      * The info in this object is read only and can be shared among as many 
1:eac0369:      * threads as necessary.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The static compiled information.
1:eac0369:      *
2:eac0369:      * @param conglomId The identifier of the conglomerate to open.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:eac0369:     TransactionController   tc,
1:eac0369:     long                    conglomId)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is this conglomerate temporary?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return whether conglomerate is temporary or not.
1:eac0369:      **/
1:eac0369:     public boolean isTemporary()
1:eac0369:     {
1:eac0369:         return(id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Bulk load into the conglomerate.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @see Conglomerate#load
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public long load(
1:eac0369: 	TransactionManager      xact_manager,
1:eac0369: 	boolean                 createConglom,
1:eac0369: 	RowLocationRetRowSource rowSource)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         long num_rows_loaded = 0;
1:eac0369: 
1:eac0369: 		HeapController heapcontroller = new HeapController();
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			num_rows_loaded = 
1:eac0369:                 heapcontroller.load(
1:eac0369:                     xact_manager,
1:eac0369:                     this, 
1:eac0369:                     createConglom,
1:eac0369:                     rowSource);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			// Done with this heap controller.
1:eac0369: 			heapcontroller.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369:         return(num_rows_loaded);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open a heap controller.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @see Conglomerate#open
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public ConglomerateController open(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         OpenConglomerate open_conglom = new OpenHeap();
1:eac0369: 
1:eac0369:         if (open_conglom.init(
1:eac0369:                 (ContainerHandle) null,
1:eac0369:                 this,
1:eac0369:                 this.format_ids,
1:722a889:                 this.collation_ids,
1:eac0369:                 xact_manager,
2:eac0369:                 rawtran,
1:eac0369:                 hold,
1:eac0369:                 open_mode,
1:eac0369:                 lock_level,
1:eac0369:                 locking_policy,
1:eac0369:                 dynamic_info) == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     Long.toString(id.getContainerId()));
1:eac0369:         }
1:eac0369: 
1:eac0369: 		HeapController heapcontroller = new HeapController();
1:eac0369: 
1:eac0369:         heapcontroller.init(open_conglom);
1:eac0369: 
1:eac0369: 		return(heapcontroller);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:c05d3df:      * Open a heap controller given ContainerKey.
1:c05d3df:      * <p>
1:c05d3df:      * Static routine to open a container given input of the ContainerKey.
1:c05d3df:      * Routine will lock the container first, and then get the Heap from
1:c05d3df:      * the conglomerate cache.  This insures that interaction with the
1:c05d3df:      * conglomerate cache is safe with respect to concurrent alter table's 
1:c05d3df:      * which may or may not commit.  
1:c05d3df:      *
1:c05d3df:      * Currently only package accessible and only used by HeapPostCommit.
1:c05d3df:      * Longer term would be better to change all of the open interfaces
1:c05d3df:      * to get lock before accessing conglomerate cache rather than have a 
1:c05d3df:      * specific interface for HeapPostCommit.
1:c05d3df:      *
1:c05d3df: 	 * @see Conglomerate#open
1:c05d3df:      *
1:c05d3df: 	 * @exception  StandardException  Standard exception policy.
1:c05d3df:      **/
1:c05d3df: 	static /* package */ ConglomerateController openByContainerKey(
1:c05d3df:     ContainerKey                    container_key,
1:c05d3df:     TransactionManager              xact_manager,
1:c05d3df:     Transaction                     rawtran,
1:c05d3df:     boolean                         hold,
1:c05d3df:     int                             open_mode,
1:c05d3df:     int                             lock_level,
1:c05d3df:     LockingPolicy                   locking_policy,
1:c05d3df:     StaticCompiledOpenConglomInfo   static_info,
1:c05d3df:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:c05d3df: 		throws StandardException
1:c05d3df: 	{
1:c05d3df:         // get lock on conglomerate before accessing the conglomerate cache.
1:c05d3df:         // This prevents background competing threads from loading an
1:c05d3df:         // inconsistent conglomerate into the cache while competing with 
1:c05d3df:         // something like an alter table add column that may or may not
1:c05d3df:         // commit.
1:c05d3df: 
1:c05d3df:         if (container_key.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT)
1:c05d3df:         {
1:c05d3df: 			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1:c05d3df:         }
1:c05d3df: 
1:c05d3df:         // TODO (mikem) - check about open_mode and temp containers.
1:c05d3df:         ContainerHandle open_container = 
1:c05d3df:              rawtran.openContainer(container_key, locking_policy, open_mode); 
1:c05d3df: 
1:c05d3df:         Heap heap = (Heap)
1:c05d3df:             xact_manager.findExistingConglomerateFromKey(container_key);
1:c05d3df: 
1:c05d3df:         OpenConglomerate open_conglom = new OpenHeap();
1:c05d3df: 
1:c05d3df: 
1:c05d3df:         if (open_conglom.init(
1:c05d3df:                 (ContainerHandle) open_container,
1:c05d3df:                 heap,
1:c05d3df:                 heap.format_ids,
1:c05d3df:                 heap.collation_ids,
1:c05d3df:                 xact_manager,
1:c05d3df:                 rawtran,
1:c05d3df:                 hold,
1:c05d3df:                 open_mode,
1:c05d3df:                 lock_level,
1:c05d3df:                 locking_policy,
1:c05d3df:                 dynamic_info) == null)
1:c05d3df:         {
1:c05d3df:             throw StandardException.newException(
1:c05d3df:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     Long.toString(container_key.getContainerId()));
1:c05d3df:         }
1:c05d3df: 
1:c05d3df: 		HeapController heapcontroller = new HeapController();
1:c05d3df: 
1:c05d3df:         heapcontroller.init(open_conglom);
1:c05d3df: 
1:c05d3df: 		return(heapcontroller);
1:c05d3df: 	}
1:c05d3df: 
1:c05d3df:     /**
1:eac0369:      * Open a heap scan controller.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @see Conglomerate#openScan
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public ScanManager openScan(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     int                             isolation_level,
1:bbc927c: 	FormatableBitSet				scanColumnList,
1:eac0369:     DataValueDescriptor[]	        startKeyValue,
1:eac0369:     int                             startSearchOperator,
1:eac0369:     Qualifier                       qualifier[][],
1:eac0369:     DataValueDescriptor[]	        stopKeyValue,
1:eac0369:     int                             stopSearchOperator,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:040d5c5:         if (SanityManager.DEBUG) {
1:040d5c5:             if ((open_mode &
1:040d5c5:                     TransactionController.OPENMODE_LOCK_ROW_NOWAIT) != 0) {
1:040d5c5:                 SanityManager.THROWASSERT(
1:040d5c5:                     "Bad open mode to Heap#openScan:" +
1:040d5c5:                     Integer.toHexString(open_mode));
1:040d5c5:             }
1:040d5c5:         }
1:040d5c5: 
1:eac0369:         // Heap scans do not suppport start and stop scan positions (these
1:eac0369:         // only make sense for ordered storage structures).
1:00d8393: 		if (!RowUtil.isRowEmpty(startKeyValue)
1:00d8393: 			|| !RowUtil.isRowEmpty(stopKeyValue))
1:eac0369: 		{
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_UNIMPLEMENTED_FEATURE);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         OpenConglomerate open_conglom = new OpenHeap();
1:eac0369: 
1:eac0369:         if (open_conglom.init(
1:eac0369:                 (ContainerHandle) null,
1:eac0369:                 this,
1:eac0369:                 this.format_ids,
1:722a889:                 this.collation_ids,
1:eac0369:                 xact_manager,
1:bbc927c:                 rawtran,
1:eac0369:                 hold,
1:eac0369:                 open_mode,
1:eac0369:                 lock_level,
1:eac0369:                 locking_policy,
1:eac0369:                 dynamic_info) == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     id.getContainerId());
1:eac0369:         }
1:eac0369: 
1:eac0369: 		HeapScan heapscan = new HeapScan();
1:eac0369: 
1:eac0369:         heapscan.init(
1:eac0369:             open_conglom,
1:eac0369:             scanColumnList,
1:eac0369:             startKeyValue,
1:eac0369:             startSearchOperator,
1:eac0369:             qualifier,
1:eac0369:             stopKeyValue,
1:eac0369:             stopSearchOperator);
1:eac0369: 
1:eac0369: 		return(heapscan);
1:eac0369: 	}
1:eac0369: 
1:bbc927c: 	public void purgeConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         OpenConglomerate        open_for_ddl_lock   = null;
1:bbc927c:         HeapController          heapcontroller      = null;
1:bbc927c:         TransactionManager      nested_xact         = null;
1:bbc927c: 
1:bbc927c:         try
1:bbc927c:         {
1:bbc927c:             open_for_ddl_lock = new OpenHeap();
1:bbc927c: 
1:bbc927c:             // Open table in intended exclusive mode in the top level 
1:bbc927c:             // transaction, this will stop any ddl from happening until 
1:bbc927c:             // purge of whole table is finished.
1:bbc927c: 
1:bbc927c:             if (open_for_ddl_lock.init(
1:bbc927c:                     (ContainerHandle) null,
1:bbc927c:                     this,
1:bbc927c:                     this.format_ids,
1:722a889:                     this.collation_ids,
1:bbc927c:                     xact_manager,
1:bbc927c:                     rawtran,
1:bbc927c:                     false,
1:bbc927c:                     TransactionController.OPENMODE_FORUPDATE,
2:bbc927c:                     TransactionController.MODE_RECORD,
4:bbc927c:                     null,
1:bbc927c:                     null) == null)
1:bbc927c:             {
1:bbc927c:                 throw StandardException.newException(
1:bbc927c:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                         id.getContainerId());
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             // perform all the "real" work in a non-readonly nested user 
1:bbc927c:             // transaction, so that as work is completed on each page resources
1:bbc927c:             // can be released.  Must be careful as all locks obtained in nested
1:bbc927c:             // transaction will conflict with parent transaction - so this call
1:bbc927c:             // must be made only if parent transaction can have no conflicting
1:bbc927c:             // locks on the table, otherwise the purge will fail with a self
1:bbc927c:             // deadlock.
1:bbc927c:             nested_xact = (TransactionManager) 
1:ceaf7df:                 xact_manager.startNestedUserTransaction(false, true);
1:bbc927c: 
1:bbc927c:             // now open the table in a nested user transaction so that each
1:bbc927c:             // page worth of work can be committed after it is done.
1:bbc927c: 
1:bbc927c:             OpenConglomerate open_conglom = new OpenHeap();
1:bbc927c: 
1:bbc927c:             if (open_conglom.init(
1:bbc927c:                 (ContainerHandle) null,
1:bbc927c:                 this,
1:bbc927c:                 this.format_ids,
1:722a889:                 this.collation_ids,
1:bbc927c:                 nested_xact,
1:965be70:                 nested_xact.getRawStoreXact(),
1:bbc927c:                 true,
1:bbc927c:                 TransactionController.OPENMODE_FORUPDATE,
1:bbc927c:                 TransactionController.MODE_RECORD,
1:965be70:                 nested_xact.getRawStoreXact().newLockingPolicy(
1:965be70:                     LockingPolicy.MODE_RECORD,
1:965be70:                         TransactionController.ISOLATION_REPEATABLE_READ, true),
1:bbc927c:                 null) == null)
1:bbc927c:             {
1:bbc927c:                 throw StandardException.newException(
1:bbc927c:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                         Long.toString(id.getContainerId()));
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             heapcontroller = new HeapController();
1:bbc927c: 
1:bbc927c:             heapcontroller.init(open_conglom);
1:bbc927c: 
1:bbc927c:             Page page   = open_conglom.getContainer().getFirstPage();
1:bbc927c: 
1:bbc927c:             boolean purgingDone = false;
1:bbc927c: 
1:bbc927c:             while (page != null)
1:bbc927c:             {
1:bbc927c:                 long pageno = page.getPageNumber();
1:bbc927c:                 purgingDone = heapcontroller.purgeCommittedDeletes(page);
1:bbc927c: 
1:bbc927c:                 if (purgingDone)
1:bbc927c:                 {
1:bbc927c:                     page = null;
1:bbc927c: 
1:bbc927c:                     // commit xact to free resouurces ASAP, commit will
1:bbc927c:                     // unlatch the page if it has not already been unlatched
1:bbc927c:                     // by a remove.
1:bbc927c:                     open_conglom.getXactMgr().commitNoSync(
1:bbc927c:                                 TransactionController.RELEASE_LOCKS);
1:965be70: 
1:965be70:                     // the commit closes the underlying container, so let
1:965be70:                     // the heapcontroller know this has happened.  Usually
1:965be70:                     // the transaction takes care of this, but this controller
1:965be70:                     // is internal, so the transaction does not know about it.
1:965be70:                     heapcontroller.closeForEndTransaction(false);
1:965be70:                     
1:965be70:                     // the commit will close the underlying 
1:bbc927c:                     open_conglom.reopen();
1:bbc927c:                 }
1:bbc927c:                 else
1:bbc927c:                 {
1:bbc927c:                     page.unlatch();
1:bbc927c:                     page = null;
1:bbc927c:                 }
1:bbc927c: 
1:bbc927c:                 page = open_conglom.getContainer().getNextPage(pageno);
1:bbc927c:             }
1:bbc927c:         }
1:bbc927c:         finally
1:bbc927c:         {
1:bbc927c:             if (open_for_ddl_lock != null)
1:bbc927c:                 open_for_ddl_lock.close();
1:bbc927c:             if (heapcontroller != null)
1:bbc927c:                 heapcontroller.close();
1:bbc927c:             if (nested_xact != null)
1:bbc927c:             {
1:bbc927c:                 nested_xact.commitNoSync(TransactionController.RELEASE_LOCKS);
1:bbc927c:                 nested_xact.destroy();
1:bbc927c:             }
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         return;
1:bbc927c:     }
1:bbc927c: 
1:bbc927c: 	public void compressConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         OpenConglomerate        open_conglom    = null;
1:bbc927c:         HeapController          heapcontroller  = null;
1:bbc927c: 
1:bbc927c:         try
1:bbc927c:         {
1:bbc927c:             open_conglom = new OpenHeap();
1:bbc927c: 
1:bbc927c:             // Open table in intended exclusive mode in the top level 
1:bbc927c:             // transaction, this will stop any ddl from happening until 
1:bbc927c:             // purge of whole table is finished.
1:bbc927c: 
1:bbc927c:             if (open_conglom.init(
1:bbc927c:                     (ContainerHandle) null,
1:bbc927c:                     this,
1:bbc927c:                     this.format_ids,
1:722a889:                     this.collation_ids,
1:bbc927c:                     xact_manager,
1:bbc927c:                     rawtran,
1:bbc927c:                     false,
1:bbc927c:                     TransactionController.OPENMODE_FORUPDATE,
1:04a2f12:                     TransactionController.MODE_TABLE,
1:965be70:                     rawtran.newLockingPolicy(
1:04a2f12:                         LockingPolicy.MODE_CONTAINER,
1:965be70:                         TransactionController.ISOLATION_REPEATABLE_READ, true),
1:bbc927c:                     null) == null)
1:bbc927c:             {
1:bbc927c:                 throw StandardException.newException(
1:bbc927c:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                         id.getContainerId());
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             heapcontroller = new HeapController();
1:bbc927c: 
1:bbc927c:             heapcontroller.init(open_conglom);
1:bbc927c: 
1:bbc927c:             open_conglom.getContainer().compressContainer();
1:bbc927c:         }
1:bbc927c:         finally
1:bbc927c:         {
1:bbc927c:             if (open_conglom != null)
1:bbc927c:                 open_conglom.close();
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         return;
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:bbc927c:      * Open a heap compress scan.
1:bbc927c:      * <p>
1:bbc927c:      *
1:41a0826:      * @see Conglomerate#defragmentConglomerate
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c: 	public ScanManager defragmentConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran,
1:bbc927c:     boolean                         hold,
1:bbc927c:     int                             open_mode,
1:bbc927c:     int                             lock_level,
1:bbc927c:     LockingPolicy                   locking_policy,
1:bbc927c:     int                             isolation_level)
1:bbc927c: 		throws StandardException
1:bbc927c: 	{
1:bbc927c:         OpenConglomerate open_conglom = new OpenHeap();
1:bbc927c: 
1:bbc927c:         if (open_conglom.init(
1:bbc927c:                 (ContainerHandle) null,
1:bbc927c:                 this,
1:bbc927c:                 this.format_ids,
1:722a889:                 this.collation_ids,
1:bbc927c:                 xact_manager,
1:bbc927c:                 rawtran,
1:bbc927c:                 hold,
1:bbc927c:                 open_mode,
1:bbc927c:                 lock_level,
1:965be70:                 rawtran.newLockingPolicy(
1:965be70:                     LockingPolicy.MODE_RECORD,
1:965be70:                     TransactionController.ISOLATION_REPEATABLE_READ, true),
1:bbc927c:                 null) == null)
1:bbc927c:         {
1:bbc927c:             throw StandardException.newException(
1:bbc927c:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     id.getContainerId());
1:bbc927c:         }
1:bbc927c: 
1:bbc927c: 		HeapCompressScan heap_compress_scan = new HeapCompressScan();
1:bbc927c: 
1:bbc927c:         heap_compress_scan.init(
1:bbc927c:             open_conglom,
1:bbc927c:             null,
1:bbc927c:             null,
1:bbc927c:             0,
1:bbc927c:             null,
1:bbc927c:             null,
1:bbc927c:             0);
1:bbc927c: 
1:bbc927c: 		return(heap_compress_scan);
1:bbc927c: 	}
1:bbc927c: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an open StoreCostController for the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Return an open StoreCostController which can be used to ask about 
1:eac0369:      * the estimated row counts and costs of ScanController and 
1:eac0369:      * ConglomerateController operations, on the given conglomerate.
1:eac0369:      * <p>
1:eac0369: 	 * @param xact_manager The TransactionController under which this 
1:eac0369:      *                     operation takes place.
1:eac0369: 	 * @param rawtran  raw transaction context in which scan is managed.
1:eac0369:      *
1:eac0369: 	 * @return The open StoreCostController.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369:      * @see StoreCostController
1:eac0369:      **/
1:eac0369:     public StoreCostController openStoreCost(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     Transaction         rawtran)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         OpenHeap open_conglom = new OpenHeap();
1:eac0369: 
1:eac0369:         if (open_conglom.init(
1:eac0369:                 (ContainerHandle) null,
1:eac0369:                 this,
1:eac0369:                 this.format_ids,
1:722a889:                 this.collation_ids,
1:eac0369:                 xact_manager,
1:eac0369:                 rawtran,
1:eac0369:                 false,
1:eac0369:                 ContainerHandle.MODE_READONLY,
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 (LockingPolicy) null,
1:eac0369:                 (DynamicCompiledOpenConglomInfo) null) == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
1:ce40a31:                     id.getContainerId());
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         HeapCostController heapcost = new HeapCostController();
1:eac0369: 
1:eac0369:         heapcost.init(open_conglom);
1:eac0369: 
1:eac0369: 		return(heapcost);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Print this heap.
1:eac0369:      **/
1:eac0369:     public String toString()
1:eac0369:     {
1:eac0369:         return (id == null) ? "null" : id.toString();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of StaticCompiledOpenConglomInfo Interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:75b112d:      * return the "Conglomerate".
1:eac0369:      * <p>
1:eac0369:      * For heap just return "this", which both implements Conglomerate and
1:eac0369:      * StaticCompiledOpenConglomInfo.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return this
1:eac0369:      **/
1:eac0369:     public DataValueDescriptor getConglom()
1:eac0369:     {
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369: 	 * Methods of Storable (via Conglomerate)
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return my format identifier.
1:eac0369:      *
1:eac0369:      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369:      **/
1:eac0369: 	public int getTypeFormatId()
1:eac0369:     {
1:b61f876: 		return StoredFormatIds.ACCESS_HEAP_V3_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return whether the value is null or not.
1:eac0369:      *
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
1:eac0369:      **/
1:eac0369: 	public boolean isNull()
1:eac0369: 	{
1:eac0369: 		return id == null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Restore the in-memory representation to the null value.
1:eac0369:      *
1:eac0369:      * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		id = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Store the stored representation of the column value in the stream.
1:eac0369:      *
1:eac0369:      **/
1:b61f876: 
1:b61f876:     /**
1:b61f876:      * Store the 10.2 format stored representation of column value in stream.
1:b61f876:      * <p>
1:b61f876:      * This routine stores the 10.2 version the Heap, ie. the ACCESS_HEAP_V2_ID
1:b61f876:      * format.  It is used by any database which has been created in 
1:b61f876:      * 10.2 or a previous release and has not been hard upgraded to a 
1:b61f876:      * version subsequent to 10.2.
1:b61f876:      * <p>
1:b61f876:      **/
1:b61f876: 	protected void writeExternal_v10_2(ObjectOutput out) throws IOException
1:eac0369:     {
1:eac0369: 
1:eac0369:         // write the format id of this conglomerate
1:eb9f9c6:         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);
1:eac0369: 
1:eac0369: 		out.writeInt((int) id.getSegmentId());
1:eac0369:         out.writeLong(id.getContainerId());
1:eac0369: 
1:eac0369:         // write number of columns in heap.
1:eac0369:         out.writeInt(format_ids.length);
1:eac0369: 
1:eac0369:         // write out array of format id's
1:eac0369:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:b61f876:      * Store the stored representation of column value in stream.
1:b61f876:      * <p>
1:b61f876:      * This routine uses the current database version to either store the
1:b61f876:      * the 10.2 format (ACCESS_HEAP_V2_ID) or the current format 
1:b61f876:      * (ACCESS_HEAP_V3_ID).  
1:b61f876:      * <p>
1:b61f876:      **/
1:b61f876: 	public void writeExternal(ObjectOutput out) throws IOException
1:b61f876:     {
1:b61f876:         writeExternal_v10_2(out);
1:b61f876: 
1:b61f876:         if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID)
1:b61f876:         {
1:b61f876:             // Now append sparse array of collation ids
1:b61f876:             ConglomerateUtil.writeCollationIdArray(collation_ids, out);
1:b61f876:         }
1:b61f876: 	}
1:b61f876: 
1:b61f876:     /**
1:eac0369:      * Restore the in-memory representation from the stream.
1:b61f876:      * <p>
1:b61f876:      *
1:b61f876:      * @exception ClassNotFoundException Thrown if the stored representation 
1:b61f876:      *                                   is serialized and a class named in 
1:b61f876:      *                                   the stream could not be found.
1:eac0369:      *
1:eac0369:      * @see java.io.Externalizable#readExternal
1:eac0369:      **/
1:b61f876:     public void readExternal(ObjectInput in)
1:b61f876: 		throws IOException, ClassNotFoundException
1:b61f876: 	{
1:b61f876: 
2:eac0369:         // read the format id of this conglomerate.
1:b61f876:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
1:eac0369: 
2:eac0369: 		int segmentid = in.readInt();
2:eac0369:         long containerid = in.readLong();
1:eac0369: 
2:eac0369: 		id = new ContainerKey(segmentid, containerid);
1:eac0369: 
2:eac0369:         // read the number of columns in the heap.
2:eac0369:         int num_columns = in.readInt();
1:eac0369: 
2:eac0369:         // read the array of format ids.
2:eac0369:         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);
1:eac0369: 
1:b61f876:         // In memory maintain a collation id per column in the template.
1:b61f876:         collation_ids = new int[format_ids.length];
1:9a3cbed:         if (SanityManager.DEBUG) {
1:9a3cbed:             SanityManager.ASSERT(!hasCollatedTypes);
1:9a3cbed:         }
1:b61f876: 
1:b61f876:         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, 
1:b61f876:         // and then reset as necessary.  For version ACCESS_HEAP_V2_ID,
1:b61f876:         // this is the default and no resetting is necessary.
1:b61f876:         for (int i = 0; i < format_ids.length; i++)
1:b61f876:             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;
1:b61f876: 
1:b61f876: 		if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID)
1:b61f876:         {
1:b61f876:             // current format id, read collation info from disk
1:b61f876: 
1:9a3cbed:             hasCollatedTypes =
1:b61f876:                     ConglomerateUtil.readCollationIdArray(collation_ids, in);
1:b61f876:         }
1:b61f876:         else if (conglom_format_id != StoredFormatIds.ACCESS_HEAP_V2_ID)
1:b61f876:         {
1:b61f876:             // Currently only V2 and V3 should be possible in a Derby DB.
1:b61f876:             // Actual work for V2 is handled by default code above, so no
1:b61f876:             // special work is necessary.
1:b61f876: 
1:b61f876:             if (SanityManager.DEBUG)
1:b61f876:             {
1:b61f876:                 SanityManager.THROWASSERT(
1:b61f876:                     "Unexpected format id: " + conglom_format_id);
1:b61f876:             }
1:b61f876:         }
1:b61f876:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         column_id, 
1:                         this.format_ids.length));
/////////////////////////////////////////////////////////////////////////
1:                     Long.toString(id.getContainerId()));
/////////////////////////////////////////////////////////////////////////
1:                     Long.toString(container_key.getContainerId()));
/////////////////////////////////////////////////////////////////////////
1:                     id.getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                         id.getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                         Long.toString(id.getContainerId()));
/////////////////////////////////////////////////////////////////////////
1:                         id.getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                     id.getContainerId());
/////////////////////////////////////////////////////////////////////////
1:                     id.getContainerId());
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c05d3df
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.PageKey;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Open a heap controller given ContainerKey.
1:      * <p>
1:      * Static routine to open a container given input of the ContainerKey.
1:      * Routine will lock the container first, and then get the Heap from
1:      * the conglomerate cache.  This insures that interaction with the
1:      * conglomerate cache is safe with respect to concurrent alter table's 
1:      * which may or may not commit.  
1:      *
1:      * Currently only package accessible and only used by HeapPostCommit.
1:      * Longer term would be better to change all of the open interfaces
1:      * to get lock before accessing conglomerate cache rather than have a 
1:      * specific interface for HeapPostCommit.
1:      *
1: 	 * @see Conglomerate#open
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	static /* package */ ConglomerateController openByContainerKey(
1:     ContainerKey                    container_key,
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException
1: 	{
1:         // get lock on conglomerate before accessing the conglomerate cache.
1:         // This prevents background competing threads from loading an
1:         // inconsistent conglomerate into the cache while competing with 
1:         // something like an alter table add column that may or may not
1:         // commit.
1: 
1:         if (container_key.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT)
1:         {
1: 			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1:         }
1: 
1:         // TODO (mikem) - check about open_mode and temp containers.
1:         ContainerHandle open_container = 
1:              rawtran.openContainer(container_key, locking_policy, open_mode); 
1: 
1:         Heap heap = (Heap)
1:             xact_manager.findExistingConglomerateFromKey(container_key);
1: 
1:         OpenConglomerate open_conglom = new OpenHeap();
1: 
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) open_container,
1:                 heap,
1:                 heap.format_ids,
1:                 heap.collation_ids,
1:                 xact_manager,
1:                 rawtran,
1:                 hold,
1:                 open_mode,
1:                 lock_level,
1:                 locking_policy,
1:                 dynamic_info) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(container_key.getContainerId()).toString());
1:         }
1: 
1: 		HeapController heapcontroller = new HeapController();
1: 
1:         heapcontroller.init(open_conglom);
1: 
1: 		return(heapcontroller);
1: 	}
1: 
1:     /**
commit:dbde907
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-6774 - temp disabling this ASSERT while working on
1:             // why it is firing in trunk.   The hope is that trunk tests
1:             // will pass for others while I work on fixing DERBY-6774.
1:             //
1:             // The code always adds the column after the last field even
1:             // if there is a mismatch with what is requested.  The store
1:             // only supports adding a column at the end anyway.
1:             //
1:             // I believe the issue is some sort of timing with background
1:             // threads and alter table and the conglomerate cache.  The
1:             // conglomerate cache was created assuming the data was static,
1:             // but in the case of alter table add and drop column this is
1:             // not true.  There are some attempts in the access layer to
1:             // invalidate the cache after an abort of a alter table, but
1:             // I think there is still a race condition.
1: 
1:             /*
/////////////////////////////////////////////////////////////////////////
1:             */
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:                         "Expected (column_id == format_ids.length)" +
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1:                 xact_manager.startNestedUserTransaction(false, true);
commit:eb9f9c6
/////////////////////////////////////////////////////////////////////////
1:         FormatIdUtil.writeFormatIdInteger(out, conglom_format_id);
commit:722a889
/////////////////////////////////////////////////////////////////////////
0:         return(new OpenConglomerateScratchSpace(format_ids, collation_ids));
/////////////////////////////////////////////////////////////////////////
1:                 this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                 this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                     this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                 this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                     this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                 this.collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                 this.collation_ids,
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:  *            conglomerate object.  Access contains no "directory" of 
1:  *            conglomerate information.  In order to bootstrap opening a file
1:  *            it encodes the factory that can open the conglomerate in the 
1:  *            conglomerate id itself.  There exists a single HeapFactory which
1:  *            must be able to read all heap format id's.  
1:  *
1:  *            This format was used for all Derby database Heap's in version
1:  *            10.2 and previous versions.
1:  *            as the first field of the conglomerate itself.  A bootstrap
1:  *            problem exists as we don't know the format id of the heap 
1:  *            until we are in the "middle" of reading the Heap.  Thus the
1:  *            base Heap implementation must be able to read and write 
1:  *            all formats based on the reading the 
1:  *            "format_of_this_conglomerate". 
1:  *            soft upgrade to ACCESS_HEAP_V3_ID:
1:  *                read:
1:  *                    old format is readable by current Heap implementation,
1:  *                    with automatic in memory creation of default collation
1:  *                    id needed by new format.  No code other than
1:  *                    readExternal and writeExternal need know about old format.
1:  *                write:
1:  *                    will never write out new format id in soft upgrade mode.
1:  *                    Code in readExternal and writeExternal handles writing
1:  *                    correct version.  Code in the factory handles making
1:  *                    sure new conglomerates use the Heap_v10_2 class to 
1:  *                    that will write out old format info.
1:  *
1:  *            hard upgrade to ACCESS_HEAP_V3_ID:
1:  *                read:
1:  *                    old format is readable by current Heap implementation,
1:  *                    with automatic in memory creation of default collation
1:  *                    id needed by new format.
1:  *                write:
1:  *                    Only "lazy" upgrade will happen.  New format will only
1:  *                    get written for new conglomerate created after the 
1:  *                    upgrade.  Old conglomerates continue to be handled the
1:  *                    same as soft upgrade.
/////////////////////////////////////////////////////////////////////////
0:  * @format_id ACCESS_HEAP_V3_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
1:  *            conglomerate object.  The Heap conglomerate object is stored in
1:  *            a field of a row in the Conglomerate directory.
1:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
1:  *            conglomerate object.  Access contains no "directory" of 
1:  *            conglomerate information.  In order to bootstrap opening a file
1:  *            it encodes the factory that can open the conglomerate in the 
1:  *            conglomerate id itself.  There exists a single HeapFactory which
1:  *            must be able to read all heap format id's.  
1:  *
1:  *            This format is used for all Derby database Heap's in versions
1:  *            subsequent to 10.2.  The format is contains first the 
1:  *            ACCESS_HEAP_V2_ID format, followed by a compressed representation
1:  *            of the collation id's of each column in the heap.
1:  *
0:  * @upgrade   This is the current version, no upgrade necessary.
1:  *
0:  * @disk_layout
1:  *     format_of_this_conlgomerate(byte[])
1:  *     containerid(long)
1:  *     segmentid(int)
1:  *     number_of_columns(int)
1:  *     array_of_format_ids(byte[][])
1:  *     collation_ids(compressed array of ints)
1:  **/
1: 
1: /**
1: public class Heap 
1: 
1:     /**
1:      * Format id of the conglomerate.
1:      **/
1: 	protected int conglom_format_id;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:     The array of collation id's for each column in the template.
1:     **/
1:     protected int[]   collation_ids;
1: 
/////////////////////////////////////////////////////////////////////////
1:     ColumnOrdering[]        columnOrder,
1:     int[]                   collationIds,
1:     int                     conglom_format_id,
/////////////////////////////////////////////////////////////////////////
1:         // copy the format id of the conglomerate.
1:         this.conglom_format_id = conglom_format_id;
1: 
1:         // get collation ids from input collation ids, store it in the 
1:         // conglom state.
1:         collation_ids = 
1:             ConglomerateUtil.createCollationIds(
1:                 format_ids.length, collationIds);
/////////////////////////////////////////////////////////////////////////
1:      * @param collation_id     Collation id of the column added.
1:     Storable            template_column,
1:     int                 collation_id)
/////////////////////////////////////////////////////////////////////////
1:             // create a new collation array, and copy old values to it.
1:             int[] old_collation_ids = collation_ids;
1:             collation_ids           = new int[old_collation_ids.length + 1];
1:             System.arraycopy(
1:                 old_collation_ids, 0, collation_ids, 0, 
1:                 old_collation_ids.length);
1: 
1:             // add the new column's collation id.
1:             collation_ids[old_collation_ids.length] =  collation_id;
/////////////////////////////////////////////////////////////////////////
1: 		return StoredFormatIds.ACCESS_HEAP_V3_ID;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Store the 10.2 format stored representation of column value in stream.
1:      * <p>
1:      * This routine stores the 10.2 version the Heap, ie. the ACCESS_HEAP_V2_ID
1:      * format.  It is used by any database which has been created in 
1:      * 10.2 or a previous release and has not been hard upgraded to a 
1:      * version subsequent to 10.2.
1:      * <p>
1:      **/
1: 	protected void writeExternal_v10_2(ObjectOutput out) throws IOException
/////////////////////////////////////////////////////////////////////////
1:      * Store the stored representation of column value in stream.
1:      * <p>
1:      * This routine uses the current database version to either store the
1:      * the 10.2 format (ACCESS_HEAP_V2_ID) or the current format 
1:      * (ACCESS_HEAP_V3_ID).  
1:      * <p>
1:      **/
1: 	public void writeExternal(ObjectOutput out) throws IOException
1:     {
1:         writeExternal_v10_2(out);
1: 
1:         if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID)
1:         {
1:             // Now append sparse array of collation ids
1:             ConglomerateUtil.writeCollationIdArray(collation_ids, out);
1:         }
1: 	}
1: 
1:     /**
1:      * <p>
1:      *
1:      * @exception ClassNotFoundException Thrown if the stored representation 
1:      *                                   is serialized and a class named in 
1:      *                                   the stream could not be found.
0: 	private final void localReadExternal(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1: 
1:         conglom_format_id = FormatIdUtil.readFormatIdInteger(in);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // In memory maintain a collation id per column in the template.
1:         collation_ids = new int[format_ids.length];
1: 
1:         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, 
1:         // and then reset as necessary.  For version ACCESS_HEAP_V2_ID,
1:         // this is the default and no resetting is necessary.
1:         for (int i = 0; i < format_ids.length; i++)
1:             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;
1: 
1: 		if (conglom_format_id == StoredFormatIds.ACCESS_HEAP_V3_ID)
1:         {
1:             // current format id, read collation info from disk
1: 
1:             ConglomerateUtil.readCollationIdArray(collation_ids, in);
1:         }
1:         else if (conglom_format_id != StoredFormatIds.ACCESS_HEAP_V2_ID)
1:         {
1:             // Currently only V2 and V3 should be possible in a Derby DB.
1:             // Actual work for V2 is handled by default code above, so no
1:             // special work is necessary.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "Unexpected format id: " + conglom_format_id);
1:             }
1:         }
1: 	public void readExternal(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
1: 	{
0:         localReadExternal(in);
0: 	public void readExternalFromArray(ArrayInputStream in)
0: 		throws IOException, ClassNotFoundException
1: 	{
0:         localReadExternal(in);
1:     }
commit:04a2f12
/////////////////////////////////////////////////////////////////////////
1:                     TransactionController.MODE_TABLE,
1:                         LockingPolicy.MODE_CONTAINER,
commit:965be70
/////////////////////////////////////////////////////////////////////////
1:                 nested_xact.getRawStoreXact(),
1:                 nested_xact.getRawStoreXact().newLockingPolicy(
1:                     LockingPolicy.MODE_RECORD,
1:                         TransactionController.ISOLATION_REPEATABLE_READ, true),
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // the commit closes the underlying container, so let
1:                     // the heapcontroller know this has happened.  Usually
1:                     // the transaction takes care of this, but this controller
1:                     // is internal, so the transaction does not know about it.
1:                     heapcontroller.closeForEndTransaction(false);
1:                     
1:                     // the commit will close the underlying 
/////////////////////////////////////////////////////////////////////////
1:                     rawtran.newLockingPolicy(
1:                         LockingPolicy.MODE_RECORD,
1:                         TransactionController.ISOLATION_REPEATABLE_READ, true),
/////////////////////////////////////////////////////////////////////////
1:                 rawtran.newLockingPolicy(
0:                     LockingPolicy.MODE_RECORD,
1:                     TransactionController.ISOLATION_REPEATABLE_READ, true),
commit:75b112d
/////////////////////////////////////////////////////////////////////////
1:      * Zero arg constructor for Monitor to create empty object.
/////////////////////////////////////////////////////////////////////////
1:      * return the "Conglomerate".
commit:41a0826
/////////////////////////////////////////////////////////////////////////
1:      * @see Conglomerate#defragmentConglomerate
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.store.raw.RecordHandle;
/////////////////////////////////////////////////////////////////////////
1: 	FormatableBitSet				scanColumnList,
/////////////////////////////////////////////////////////////////////////
1: 	public void purgeConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException
1:     {
1:         OpenConglomerate        open_for_ddl_lock   = null;
1:         HeapController          heapcontroller      = null;
1:         TransactionManager      nested_xact         = null;
1: 
1:         try
1:         {
1:             open_for_ddl_lock = new OpenHeap();
1: 
1:             // Open table in intended exclusive mode in the top level 
1:             // transaction, this will stop any ddl from happening until 
1:             // purge of whole table is finished.
1: 
1:             if (open_for_ddl_lock.init(
1:                     (ContainerHandle) null,
1:                     this,
1:                     this.format_ids,
1:                     xact_manager,
1:                     rawtran,
1:                     false,
1:                     TransactionController.OPENMODE_FORUPDATE,
1:                     TransactionController.MODE_RECORD,
1:                     null,
1:                     null) == null)
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                         new Long(id.getContainerId()));
1:             }
1: 
1:             // perform all the "real" work in a non-readonly nested user 
1:             // transaction, so that as work is completed on each page resources
1:             // can be released.  Must be careful as all locks obtained in nested
1:             // transaction will conflict with parent transaction - so this call
1:             // must be made only if parent transaction can have no conflicting
1:             // locks on the table, otherwise the purge will fail with a self
1:             // deadlock.
1:             nested_xact = (TransactionManager) 
0:                 xact_manager.startNestedUserTransaction(false);
1: 
1:             // now open the table in a nested user transaction so that each
1:             // page worth of work can be committed after it is done.
1: 
1:             OpenConglomerate open_conglom = new OpenHeap();
1: 
1:             if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 this,
1:                 this.format_ids,
1:                 nested_xact,
1:                 rawtran,
1:                 true,
1:                 TransactionController.OPENMODE_FORUPDATE,
1:                 TransactionController.MODE_RECORD,
1:                 null,
1:                 null) == null)
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                         new Long(id.getContainerId()).toString());
1:             }
1: 
1:             heapcontroller = new HeapController();
1: 
1:             heapcontroller.init(open_conglom);
1: 
1:             Page page   = open_conglom.getContainer().getFirstPage();
1: 
1:             boolean purgingDone = false;
1: 
1:             while (page != null)
1:             {
1:                 long pageno = page.getPageNumber();
1:                 purgingDone = heapcontroller.purgeCommittedDeletes(page);
1: 
1:                 if (purgingDone)
1:                 {
1:                     page = null;
1: 
1:                     // commit xact to free resouurces ASAP, commit will
1:                     // unlatch the page if it has not already been unlatched
1:                     // by a remove.
1:                     open_conglom.getXactMgr().commitNoSync(
1:                                 TransactionController.RELEASE_LOCKS);
1:                     open_conglom.reopen();
1:                 }
1:                 else
1:                 {
1:                     page.unlatch();
1:                     page = null;
1:                 }
1: 
1:                 page = open_conglom.getContainer().getNextPage(pageno);
1:             }
1:         }
1:         finally
1:         {
1:             if (open_for_ddl_lock != null)
1:                 open_for_ddl_lock.close();
1:             if (heapcontroller != null)
1:                 heapcontroller.close();
1:             if (nested_xact != null)
1:             {
1:                 nested_xact.commitNoSync(TransactionController.RELEASE_LOCKS);
1:                 nested_xact.destroy();
1:             }
1:         }
1: 
1:         return;
1:     }
1: 
1: 	public void compressConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException
1:     {
1:         OpenConglomerate        open_conglom    = null;
1:         HeapController          heapcontroller  = null;
1: 
1:         try
1:         {
1:             open_conglom = new OpenHeap();
1: 
1:             // Open table in intended exclusive mode in the top level 
1:             // transaction, this will stop any ddl from happening until 
1:             // purge of whole table is finished.
1: 
1:             if (open_conglom.init(
1:                     (ContainerHandle) null,
1:                     this,
1:                     this.format_ids,
1:                     xact_manager,
1:                     rawtran,
1:                     false,
1:                     TransactionController.OPENMODE_FORUPDATE,
1:                     TransactionController.MODE_RECORD,
1:                     null,
1:                     null) == null)
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                         new Long(id.getContainerId()));
1:             }
1: 
1:             heapcontroller = new HeapController();
1: 
1:             heapcontroller.init(open_conglom);
1: 
1:             open_conglom.getContainer().compressContainer();
1:         }
1:         finally
1:         {
1:             if (open_conglom != null)
1:                 open_conglom.close();
1:         }
1: 
1:         return;
1:     }
1: 
1:     /**
1:      * Open a heap compress scan.
1:      * <p>
1:      *
0:      * @see Conglomerate#openCompressScan
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public ScanManager defragmentConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level)
1: 		throws StandardException
1: 	{
1:         OpenConglomerate open_conglom = new OpenHeap();
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 this,
1:                 this.format_ids,
1:                 xact_manager,
1:                 rawtran,
1:                 hold,
1:                 open_mode,
1:                 lock_level,
1:                 null,
1:                 null) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()));
1:         }
1: 
1: 		HeapCompressScan heap_compress_scan = new HeapCompressScan();
1: 
1:         heap_compress_scan.init(
1:             open_conglom,
1:             null,
1:             null,
1:             0,
1:             null,
1:             null,
1:             0);
1: 
1: 		return(heap_compress_scan);
1: 	}
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:040d5c5
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             if ((open_mode &
1:                     TransactionController.OPENMODE_LOCK_ROW_NOWAIT) != 0) {
1:                 SanityManager.THROWASSERT(
1:                     "Bad open mode to Heap#openScan:" +
1:                     Integer.toHexString(open_mode));
1:             }
1:         }
1: 
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_HEAP_V2_ID
1:  * @derby.purpose   The tag that describes the on disk representation of the Heap
/////////////////////////////////////////////////////////////////////////
1:  * @derby.upgrade   The format id of this object is currently always read from disk
/////////////////////////////////////////////////////////////////////////
1:  * @derby.diskLayout
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_HEAP_V3_ID
1:  * @derby.purpose   The tag that describes the on disk representation of the Heap
1:  * @derby.purpose   The tag that describes the on disk representation of the Heap
/////////////////////////////////////////////////////////////////////////
1:  * @derby.upgrade   This is the current version, no upgrade necessary.
1:  * @derby.diskLayout
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     public void readExternal(ObjectInput in)
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells if there is at least one column in the conglomerate whose collation
1:      * isn't StringDataValue.COLLATION_TYPE_UCS_BASIC.
1:      */
1:     private boolean hasCollatedTypes;
/////////////////////////////////////////////////////////////////////////
1:         hasCollatedTypes = hasCollatedColumns(collation_ids);
/////////////////////////////////////////////////////////////////////////
1:         return(new OpenConglomerateScratchSpace(
1:                 format_ids, collation_ids, hasCollatedTypes));
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(!hasCollatedTypes);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             hasCollatedTypes =
0:                     ConglomerateUtil.readCollationIdArray(collation_ids, in);
commit:57a0040
/////////////////////////////////////////////////////////////////////////
1:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
commit:18176ce
/////////////////////////////////////////////////////////////////////////
1: 	private ContainerKey id;
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:00d8393
/////////////////////////////////////////////////////////////////////////
1: 		if (!RowUtil.isRowEmpty(startKeyValue)
1: 			|| !RowUtil.isRowEmpty(stopKeyValue))
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.Heap
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
0: import org.apache.derby.iapi.types.DataType;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
1: 
1: 
1: /**
0:  * @format_id ACCESS_HEAP_V1_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
0:  *            conglomerate object.  The Heap conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.
1:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
1:  *
0:  * @disk_layout
1:  *     containerid(long)
1:  *     segmentid(int)
1:  **/
1: 
1: /**
0:  * @format_id ACCESS_HEAP_V2_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
0:  *            conglomerate object.  The Heap conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.
1:  *
0:  * @upgrade   The format id of this object is currently always read from disk
0:  *            as a separate column in the conglomerate directory.  To read
0:  *            A conglomerate object from disk and upgrade it to the current
0:  *            version do the following:
1:  *
0:  *                format_id = get format id from a separate column
0:  *                Upgradable conglom_obj = instantiate empty obj(format_id)
0:  *                read in conglom_obj from disk
0:  *                conglom = conglom_obj.upgradeToCurrent();
1:  *
0:  * @disk_layout
1:  *     format_of_this_conlgomerate(byte[])
1:  *     containerid(long)
1:  *     segmentid(int)
1:  *     number_of_columns(int)
1:  *     array_of_format_ids(byte[][])
1:  **/
1: 
1: /**
1: 
1:   A heap object corresponds to an instance of a heap conglomerate.  It caches
1:   information which makes it fast to open heap controllers from it.
1: 
1: **/
1: 
0: public final class Heap 
1:     extends    GenericConglomerate
1:     implements Conglomerate, StaticCompiledOpenConglomInfo
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	** Fields of Heap.
1: 	*/
1: 
0: 	protected ContainerKey id;
1: 
1:     /**
1:      * The format id's of each of the columns in the heap table.
1:      **/
1:     int[]    format_ids;
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( Heap.class);
1:     private static final int CONTAINER_KEY_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( ContainerKey.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         int sz = BASE_MEMORY_USAGE;
1: 
1:         if( null != id)
1:             sz += CONTAINER_KEY_MEMORY_USAGE;
1:         if( null != format_ids)
1:             sz += format_ids.length*ClassSize.getIntSize();
1:         return sz;
1:     } // end of estimateMemoryUsage
1: 
1: 	/*
1: 	** Methods of Heap.
1: 	*/
1: 
1:     /* Constructors for This class: */
1: 
1:     /**
0:      * Zero arg. constructor for Monitor to create empty object.
1:      **/
1:     public Heap()
1:     {
1:     }
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /**
1:      * Create a heap conglomerate.
1:      * <p>
1:      * Create a heap conglomerate.  This method is called from the heap factory
1:      * to create a new instance of a heap.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected void create(
1:     Transaction             rawtran,
1:     int                     segmentId,
1:     long                    input_containerid,
1:     DataValueDescriptor[]   template,
1:     Properties              properties,
1: 	int                     tmpFlag)
1: 		throws StandardException
1: 	{
1: 		// Create a container for the heap table with
1: 		// default minimumRecordSize to be at least
1: 		// MINIMUM_RECORD_SIZE_DEFAULT (12),
1: 		// to guarantee there is enough room for updates
1: 		// of the row.
1: 		// Here we only take care of the case that
1: 		// that the properties are set with the create
1: 		// statement.  For the case when properties are
1: 		// not set with the create statement, it is taken
1: 		// care of in fileContainer.java: createInfoFromProp().
1: 		if (properties != null) 
1:         {
1: 			String value = properties.getProperty(
1: 				RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER);
1: 
1: 			int minimumRecordSize =
1: 				(value == null) ? 
1:                     RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT : 
1:                     Integer.parseInt(value);
1: 
1: 			if (minimumRecordSize < RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT)
1: 			{
1: 				properties.put(
1:                     RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,
1: 					Integer.toString(
1:                         RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT));
1: 			}
1: 		}
1: 
1: 		// Create a container for the heap with default page size.
1: 		long containerid = 
1:             rawtran.addContainer(
1:                 segmentId, input_containerid, 
1:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
1: 
1: 		// Make sure the container was actually created.
1: 		if (containerid < 0)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CANT_CREATE_CONTAINER);
1:         }
1: 
1: 		// Keep track of what segment the container's in.
1: 		id = new ContainerKey(segmentId, containerid);
1: 
1: 		// Heap requires a template representing every column in the table.
1:         if ((template == null) || (template.length == 0))
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_COULD_NOT_CREATE_CONGLOMERATE);
1:         }
1: 
1:         // get format id's from each column in template and store it in the
1:         // conglomerate state.
1:         this.format_ids = ConglomerateUtil.createFormatIds(template);
1: 
1: 
1:         // need to open the container and insert the row.  Since we are
1:         // creating it no need to bother with locking since no one can get
1:         // to it until after we have created it and returned it's id.
1:         ContainerHandle container = null;
1:         Page            page      = null;
1: 
1:         try
1:         {
1:             container = 
1:                 rawtran.openContainer(
1:                     id, (LockingPolicy) null, 
1:                     ContainerHandle.MODE_FORUPDATE | 
1:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
1: 
1:             // row in slot 0 of heap page 1 which is just a single column with
1:             // the heap entry.
1:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
1:             control_row[0] = this;
1: 
1:             page =
1:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:             page.insertAtSlot(
1:                 Page.FIRST_SLOT_NUMBER,
1:                 control_row,
1:                 (FormatableBitSet) null,
1:                 (LogicalUndo) null, 
1:                 Page.INSERT_OVERFLOW,
1:                 AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
1:             page.unlatch();
1:             page = null;
1: 
1:             // Don't include the control row in the estimated row count.
1:             container.setEstimatedRowCount(0, /* unused flag */ 0);
1:         }
1:         finally
1:         {
1:             if (container != null)
1:                 container.close();
1:             if (page !=null)
1:                 page.unlatch();
1:         }
1: 	}
1: 
1:     /**
1:      * Create a heap conglomerate during the boot process.
1:      * <p>
1:      * Manufacture a Heap Conglomerate out of "thin" air, to boot strap
1:      * the system.  Create an in-memory Heap Conglomerate with the input
1:      * parameters, The caller will use this to open the conglomerate
1:      * conglomerate and read the "real" values from disk.  Conglom-conglom
1:      * is always on segment 0.
1:      *
1:      *
1:      * @param containerid The container id of the conglomerate.
1:      * @param template    Object array describing the columns of the heap.
1:      **/
1:     public void boot_create(
1:     long                    containerid,
1:     DataValueDescriptor[]   template)
1:     {
1: 		id = new ContainerKey(0, containerid);
1:         this.format_ids = ConglomerateUtil.createFormatIds(template);
1:     }
1: 
1: 	/*
1: 	** Methods of Conglomerate
1: 	*/
1: 
1:     /**
1:      * Add a column to the heap conglomerate.
1:      * <p>
1:      * This routine update's the in-memory object version of the Heap
1:      * Conglomerate to have one more column of the type described by the
1:      * input template column.  
1:      * 
1:      * @param column_id        The column number to add this column at.
1:      * @param template_column  An instance of the column to be added to table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void addColumn(
1: 	TransactionManager  xact_manager,
1:     int                 column_id,
0:     Storable            template_column)
1:         throws StandardException
1:     {
1:         // need to open the container and update the row containing the 
1:         // serialized format of the heap.  
1:         ContainerHandle container = null;
1:         Page            page      = null;
1:         Transaction     rawtran   = xact_manager.getRawStoreXact();
1: 
1:         try
1:         {
1:             container = 
1:                 rawtran.openContainer(
1:                     id, 
1:                     rawtran.newLockingPolicy(
1:                         LockingPolicy.MODE_CONTAINER,
1:                         TransactionController.ISOLATION_SERIALIZABLE, true),
1:                     ContainerHandle.MODE_FORUPDATE | 
1:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
1: 
1:             if (column_id != format_ids.length)
1:             {
1:                 if (SanityManager.DEBUG)
1:                     SanityManager.THROWASSERT(
1:                         "column_id = " + column_id +
1:                         "format_ids.length = " + format_ids.length +
1:                         "format_ids = " + format_ids);
1: 
1:                 throw(StandardException.newException(
1:                         SQLState.HEAP_TEMPLATE_MISMATCH,
0:                         new Long(column_id), 
0:                         new Long(this.format_ids.length)));
1:             }
1: 
1:             // create a new array, and copy old values to it.
1:             int[] old_format_ids = format_ids;
1:             format_ids              = new int[old_format_ids.length + 1];
1:             System.arraycopy(
1:                 old_format_ids, 0, format_ids, 0, old_format_ids.length);
1: 
1:             // add the new column
1:             format_ids[old_format_ids.length] = 
1:                 template_column.getTypeFormatId();
1: 
1:            
1:             // row in slot 0 of heap page 1 which is just a single column with
1:             // the heap entry.
1:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
1:             control_row[0] = this;
1: 
1:             page =
1:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:             page.updateAtSlot(
1:                 Page.FIRST_SLOT_NUMBER,
1:                 control_row,
1:                 (FormatableBitSet) null);
1: 
1:             page.unlatch();
1:             page = null;
1:         }
1:         finally
1:         {
1:             if (container != null)
1:                 container.close();
1:             if (page !=null)
1:                 page.unlatch();
1:         }
1: 
1:         return;
1:     }
1: 
1: 
1: 	/**
1: 	Drop this heap.
1: 	@see Conglomerate#drop
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	public void drop(TransactionManager xact_manager)
1: 		throws StandardException
1: 	{
1:         xact_manager.getRawStoreXact().dropContainer(id);
1: 	}
1: 
1:     /**
1:      * Retrieve the maximum value row in an ordered conglomerate.
1:      * <p>
1:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:      * there are no rows in the conglomerate it returns false.
1:      * <p>
1:      * Non-ordered conglomerates will not implement this interface, calls
1:      * will generate a StandardException.
1:      * <p>
1:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:      * functionality will be provided by the openBackwardScan() interface.  
1:      *
1: 	 * @param conglomId       The identifier of the conglomerate
1: 	 *                        to open the scan for.
1:      *
1: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:      *                        OPENMODE_FORUPDATE - if set open the table for
1:      *                        update otherwise open table shared.
1:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:      *
1:      * @param isolation_level The isolation level to lock the conglomerate at.
1:      *                        One of (ISOLATION_READ_COMMITTED or 
1:      *                        ISOLATION_SERIALIZABLE).
1:      *
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan.  template, 
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      *
1:      * @param fetchRow        The row to retrieve the maximum value into.
1:      *
1: 	 * @return boolean indicating if a row was found and retrieved or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public boolean fetchMaxOnBTree(
1: 	TransactionManager      xact_manager,
1:     Transaction             rawtran,
1:     long                    conglomId,
1:     int                     open_mode,
1:     int                     lock_level,
1:     LockingPolicy           locking_policy,
1:     int                     isolation_level,
1:     FormatableBitSet                 scanColumnList,
1:     DataValueDescriptor[]   fetchRow)
1:         throws StandardException
1:     {
1:         // no support for max on a heap table.
1:         throw(StandardException.newException(
1:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
1:     }
1: 
1:     /**
1:      * Get the id of the container of the conglomerate.
1:      * <p>
1:      * Will have to change when a conglomerate could have more than one 
1:      * container.  The ContainerKey is a combination of the container id
1:      * and segment id.
1:      *
1: 	 * @return The ContainerKey.
1:      **/
1:     public final ContainerKey getId()
1:     {
1:         return(id);
1:     }
1: 
1: 
1:     public final long getContainerid()
1:     {
1:         return(id.getContainerId());
1:     }
1: 
1:     /**
1:      * Return dynamic information about the conglomerate to be dynamically 
1:      * reused in repeated execution of a statement.
1:      * <p>
1:      * The dynamic info is a set of variables to be used in a given 
1:      * ScanController or ConglomerateController.  It can only be used in one 
1:      * controller at a time.  It is up to the caller to insure the correct 
1:      * thread access to this info.  The type of info in this is a scratch 
1:      * template for btree traversal, other scratch variables for qualifier 
1:      * evaluation, ...
1:      * <p>
1:      *
1: 	 * @return The dynamic information.
1:      *
1:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
1: 		throws StandardException
1:     {
0:         return(new OpenConglomerateScratchSpace(format_ids));
1:     }
1: 
1:     /**
1:      * Return static information about the conglomerate to be included in a
1:      * a compiled plan.
1:      * <p>
1:      * The static info would be valid until any ddl was executed on the 
1:      * conglomid, and would be up to the caller to throw away when that 
1:      * happened.  This ties in with what language already does for other 
1:      * invalidation of static info.  The type of info in this would be 
1:      * containerid and array of format id's from which templates can be created.
1:      * The info in this object is read only and can be shared among as many 
1:      * threads as necessary.
1:      * <p>
1:      *
1: 	 * @return The static compiled information.
1:      *
1:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:     TransactionController   tc,
1:     long                    conglomId)
1: 		throws StandardException
1:     {
1:         return(this);
1:     }
1: 
1: 
1:     /**
1:      * Is this conglomerate temporary?
1:      * <p>
1:      *
1: 	 * @return whether conglomerate is temporary or not.
1:      **/
1:     public boolean isTemporary()
1:     {
1:         return(id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
1:     }
1: 
1: 
1:     /**
1:      * Bulk load into the conglomerate.
1:      * <p>
1:      *
1:      * @see Conglomerate#load
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public long load(
1: 	TransactionManager      xact_manager,
1: 	boolean                 createConglom,
1: 	RowLocationRetRowSource rowSource)
1: 		 throws StandardException
1: 	{
1:         long num_rows_loaded = 0;
1: 
1: 		HeapController heapcontroller = new HeapController();
1: 
1: 		try
1: 		{
1: 			num_rows_loaded = 
1:                 heapcontroller.load(
1:                     xact_manager,
1:                     this, 
1:                     createConglom,
1:                     rowSource);
1: 		}
1: 		finally
1: 		{
1: 			// Done with this heap controller.
1: 			heapcontroller.close();
1: 		}
1: 
1:         return(num_rows_loaded);
1: 	}
1: 
1:     /**
1:      * Open a heap controller.
1:      * <p>
1:      *
1: 	 * @see Conglomerate#open
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public ConglomerateController open(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException
1: 	{
1:         OpenConglomerate open_conglom = new OpenHeap();
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 this,
1:                 this.format_ids,
1:                 xact_manager,
1:                 rawtran,
1:                 hold,
1:                 open_mode,
1:                 lock_level,
1:                 locking_policy,
1:                 dynamic_info) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()).toString());
1:         }
1: 
1: 		HeapController heapcontroller = new HeapController();
1: 
1:         heapcontroller.init(open_conglom);
1: 
1: 		return(heapcontroller);
1: 	}
1: 
1:     /**
1:      * Open a heap scan controller.
1:      * <p>
1:      *
1:      * @see Conglomerate#openScan
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public ScanManager openScan(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level,
0: 	FormatableBitSet				            scanColumnList,
1:     DataValueDescriptor[]	        startKeyValue,
1:     int                             startSearchOperator,
1:     Qualifier                       qualifier[][],
1:     DataValueDescriptor[]	        stopKeyValue,
1:     int                             stopSearchOperator,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException
1: 	{
1:         // Heap scans do not suppport start and stop scan positions (these
1:         // only make sense for ordered storage structures).
0: 		if (!RowUtil.isRowEmpty(startKeyValue, (FormatableBitSet) null)
0: 			|| !RowUtil.isRowEmpty(stopKeyValue, (FormatableBitSet) null))
1: 		{
1:             throw StandardException.newException(
1:                     SQLState.HEAP_UNIMPLEMENTED_FEATURE);
1: 		}
1: 
1:         OpenConglomerate open_conglom = new OpenHeap();
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 this,
1:                 this.format_ids,
1:                 xact_manager,
1:                 rawtran,
1:                 hold,
1:                 open_mode,
1:                 lock_level,
1:                 locking_policy,
1:                 dynamic_info) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()));
1:         }
1: 
1: 		HeapScan heapscan = new HeapScan();
1: 
1:         heapscan.init(
1:             open_conglom,
1:             scanColumnList,
1:             startKeyValue,
1:             startSearchOperator,
1:             qualifier,
1:             stopKeyValue,
1:             stopSearchOperator);
1: 
1: 		return(heapscan);
1: 	}
1: 
1: 
1:     /**
1:      * Return an open StoreCostController for the conglomerate.
1:      * <p>
1:      * Return an open StoreCostController which can be used to ask about 
1:      * the estimated row counts and costs of ScanController and 
1:      * ConglomerateController operations, on the given conglomerate.
1:      * <p>
1: 	 * @param xact_manager The TransactionController under which this 
1:      *                     operation takes place.
1: 	 * @param rawtran  raw transaction context in which scan is managed.
1:      *
1: 	 * @return The open StoreCostController.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see StoreCostController
1:      **/
1:     public StoreCostController openStoreCost(
1:     TransactionManager  xact_manager,
1:     Transaction         rawtran)
1: 		throws StandardException
1:     {
1:         OpenHeap open_conglom = new OpenHeap();
1: 
1:         if (open_conglom.init(
1:                 (ContainerHandle) null,
1:                 this,
1:                 this.format_ids,
1:                 xact_manager,
1:                 rawtran,
1:                 false,
1:                 ContainerHandle.MODE_READONLY,
1:                 TransactionController.MODE_TABLE,
1:                 (LockingPolicy) null,
1:                 (DynamicCompiledOpenConglomInfo) null) == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()));
1:         }
1: 
1: 
1:         HeapCostController heapcost = new HeapCostController();
1: 
1:         heapcost.init(open_conglom);
1: 
1: 		return(heapcost);
1:     }
1: 
1: 
1:     /**
1:      * Print this heap.
1:      **/
1:     public String toString()
1:     {
1:         return (id == null) ? "null" : id.toString();
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of StaticCompiledOpenConglomInfo Interface:
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * return the "Conglomerate"
1:      * <p>
1:      * For heap just return "this", which both implements Conglomerate and
1:      * StaticCompiledOpenConglomInfo.
1:      * <p>
1:      *
1: 	 * @return this
1:      **/
1:     public DataValueDescriptor getConglom()
1:     {
1:         return(this);
1:     }
1: 
1: 
1:     /**************************************************************************
1: 	 * Methods of Storable (via Conglomerate)
1: 	 * Storable interface, implies Externalizable, TypedFormat
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Return my format identifier.
1:      *
1:      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:      **/
1: 	public int getTypeFormatId()
1:     {
0: 		return StoredFormatIds.ACCESS_HEAP_V2_ID;
1: 	}
1: 
1:     /**
1:      * Return whether the value is null or not.
1:      *
1: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
1:      **/
1: 	public boolean isNull()
1: 	{
1: 		return id == null;
1: 	}
1: 
1:     /**
1:      * Restore the in-memory representation to the null value.
1:      *
1:      * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:      *
1:      **/
1: 	public void restoreToNull()
1: 	{
1: 		id = null;
1: 	}
1: 
1:     /**
1:      * Store the stored representation of the column value in the stream.
1:      *
1:      **/
0: 	public void writeExternal(ObjectOutput out) throws IOException
1:     {
1: 
1:         // write the format id of this conglomerate
0:         FormatIdUtil.writeFormatIdInteger(out, this.getTypeFormatId());
1: 
1: 		out.writeInt((int) id.getSegmentId());
1:         out.writeLong(id.getContainerId());
1: 
1:         // write number of columns in heap.
1:         out.writeInt(format_ids.length);
1: 
1:         // write out array of format id's
1:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
1: 	}
1: 
1:     /**
1:      * Restore the in-memory representation from the stream.
1:      *
1:      * @see java.io.Externalizable#readExternal
1:      **/
0: 	public void readExternal(ObjectInput in) throws IOException 
1:     {
1:         // read the format id of this conglomerate.
0:         FormatIdUtil.readFormatIdInteger(in);
1: 
1: 		int segmentid = in.readInt();
1:         long containerid = in.readLong();
1: 
1: 		id = new ContainerKey(segmentid, containerid);
1: 
1:         // read the number of columns in the heap.
1:         int num_columns = in.readInt();
1: 
1:         // read the array of format ids.
1:         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);
1:     }
1: 
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException 
1:     {
1:         // read the format id of this conglomerate.
0:         FormatIdUtil.readFormatIdInteger(in);
1: 
1: 		int segmentid = in.readInt();
1:         long containerid = in.readLong();
1: 
1: 		id = new ContainerKey(segmentid, containerid);
1: 
1:         // read the number of columns in the heap.
1:         int num_columns = in.readInt();
1: 
1:         // read the array of format ids.
1:         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);
1:     }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: import org.apache.derby.iapi.types.DataType;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.GenericConglomerate;
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerate;
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: 
0: /**
0:  * @format_id ACCESS_HEAP_V1_ID
0:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
0:  *            conglomerate object.  The Heap conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.
0:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
0:  *
0:  * @disk_layout
0:  *     containerid(long)
0:  *     segmentid(int)
0:  **/
0: 
0: /**
0:  * @format_id ACCESS_HEAP_V2_ID
0:  *
0:  * @purpose   The tag that describes the on disk representation of the Heap
0:  *            conglomerate object.  The Heap conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.
0:  *
0:  * @upgrade   The format id of this object is currently always read from disk
0:  *            as a separate column in the conglomerate directory.  To read
0:  *            A conglomerate object from disk and upgrade it to the current
0:  *            version do the following:
0:  *
0:  *                format_id = get format id from a separate column
0:  *                Upgradable conglom_obj = instantiate empty obj(format_id)
0:  *                read in conglom_obj from disk
0:  *                conglom = conglom_obj.upgradeToCurrent();
0:  *
0:  * @disk_layout
0:  *     format_of_this_conlgomerate(byte[])
0:  *     containerid(long)
0:  *     segmentid(int)
0:  *     number_of_columns(int)
0:  *     array_of_format_ids(byte[][])
0:  **/
0: 
0: /**
0: 
0:   A heap object corresponds to an instance of a heap conglomerate.  It caches
0:   information which makes it fast to open heap controllers from it.
0: 
0: **/
0: 
0: public final class Heap 
0:     extends    GenericConglomerate
0:     implements Conglomerate, StaticCompiledOpenConglomInfo
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	** Fields of Heap.
0: 	*/
0: 
0: 	protected ContainerKey id;
0: 
0:     /**
0:      * The format id's of each of the columns in the heap table.
0:      **/
0:     int[]    format_ids;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( Heap.class);
0:     private static final int CONTAINER_KEY_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( ContainerKey.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE;
0: 
0:         if( null != id)
0:             sz += CONTAINER_KEY_MEMORY_USAGE;
0:         if( null != format_ids)
0:             sz += format_ids.length*ClassSize.getIntSize();
0:         return sz;
0:     } // end of estimateMemoryUsage
0: 
0: 	/*
0: 	** Methods of Heap.
0: 	*/
0: 
0:     /* Constructors for This class: */
0: 
0:     /**
0:      * Zero arg. constructor for Monitor to create empty object.
0:      **/
0:     public Heap()
0:     {
0:     }
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /**
0:      * Create a heap conglomerate.
0:      * <p>
0:      * Create a heap conglomerate.  This method is called from the heap factory
0:      * to create a new instance of a heap.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected void create(
0:     Transaction             rawtran,
0:     int                     segmentId,
0:     long                    input_containerid,
0:     DataValueDescriptor[]   template,
0:     Properties              properties,
0: 	int                     tmpFlag)
0: 		throws StandardException
0: 	{
0: 		// Create a container for the heap table with
0: 		// default minimumRecordSize to be at least
0: 		// MINIMUM_RECORD_SIZE_DEFAULT (12),
0: 		// to guarantee there is enough room for updates
0: 		// of the row.
0: 		// Here we only take care of the case that
0: 		// that the properties are set with the create
0: 		// statement.  For the case when properties are
0: 		// not set with the create statement, it is taken
0: 		// care of in fileContainer.java: createInfoFromProp().
0: 		if (properties != null) 
0:         {
0: 			String value = properties.getProperty(
0: 				RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER);
0: 
0: 			int minimumRecordSize =
0: 				(value == null) ? 
0:                     RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT : 
0:                     Integer.parseInt(value);
0: 
0: 			if (minimumRecordSize < RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT)
0: 			{
0: 				properties.put(
0:                     RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER,
0: 					Integer.toString(
0:                         RawStoreFactory.MINIMUM_RECORD_SIZE_DEFAULT));
0: 			}
0: 		}
0: 
0: 		// Create a container for the heap with default page size.
0: 		long containerid = 
0:             rawtran.addContainer(
0:                 segmentId, input_containerid, 
0:                 ContainerHandle.MODE_DEFAULT, properties, tmpFlag);
0: 
0: 		// Make sure the container was actually created.
0: 		if (containerid < 0)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_CANT_CREATE_CONTAINER);
0:         }
0: 
0: 		// Keep track of what segment the container's in.
0: 		id = new ContainerKey(segmentId, containerid);
0: 
0: 		// Heap requires a template representing every column in the table.
0:         if ((template == null) || (template.length == 0))
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_COULD_NOT_CREATE_CONGLOMERATE);
0:         }
0: 
0:         // get format id's from each column in template and store it in the
0:         // conglomerate state.
0:         this.format_ids = ConglomerateUtil.createFormatIds(template);
0: 
0: 
0:         // need to open the container and insert the row.  Since we are
0:         // creating it no need to bother with locking since no one can get
0:         // to it until after we have created it and returned it's id.
0:         ContainerHandle container = null;
0:         Page            page      = null;
0: 
0:         try
0:         {
0:             container = 
0:                 rawtran.openContainer(
0:                     id, (LockingPolicy) null, 
0:                     ContainerHandle.MODE_FORUPDATE | 
0:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
0: 
0:             // row in slot 0 of heap page 1 which is just a single column with
0:             // the heap entry.
0:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
0:             control_row[0] = this;
0: 
0:             page =
0:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:             page.insertAtSlot(
0:                 Page.FIRST_SLOT_NUMBER,
0:                 control_row,
0:                 (FormatableBitSet) null,
0:                 (LogicalUndo) null, 
0:                 Page.INSERT_OVERFLOW,
0:                 AccessFactoryGlobals.HEAP_OVERFLOW_THRESHOLD);
0:             page.unlatch();
0:             page = null;
0: 
0:             // Don't include the control row in the estimated row count.
0:             container.setEstimatedRowCount(0, /* unused flag */ 0);
0:         }
0:         finally
0:         {
0:             if (container != null)
0:                 container.close();
0:             if (page !=null)
0:                 page.unlatch();
0:         }
0: 	}
0: 
0:     /**
0:      * Create a heap conglomerate during the boot process.
0:      * <p>
0:      * Manufacture a Heap Conglomerate out of "thin" air, to boot strap
0:      * the system.  Create an in-memory Heap Conglomerate with the input
0:      * parameters, The caller will use this to open the conglomerate
0:      * conglomerate and read the "real" values from disk.  Conglom-conglom
0:      * is always on segment 0.
0:      *
0:      *
0:      * @param containerid The container id of the conglomerate.
0:      * @param template    Object array describing the columns of the heap.
0:      **/
0:     public void boot_create(
0:     long                    containerid,
0:     DataValueDescriptor[]   template)
0:     {
0: 		id = new ContainerKey(0, containerid);
0:         this.format_ids = ConglomerateUtil.createFormatIds(template);
0:     }
0: 
0: 	/*
0: 	** Methods of Conglomerate
0: 	*/
0: 
0:     /**
0:      * Add a column to the heap conglomerate.
0:      * <p>
0:      * This routine update's the in-memory object version of the Heap
0:      * Conglomerate to have one more column of the type described by the
0:      * input template column.  
0:      * 
0:      * @param column_id        The column number to add this column at.
0:      * @param template_column  An instance of the column to be added to table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void addColumn(
0: 	TransactionManager  xact_manager,
0:     int                 column_id,
0:     Storable            template_column)
0:         throws StandardException
0:     {
0:         // need to open the container and update the row containing the 
0:         // serialized format of the heap.  
0:         ContainerHandle container = null;
0:         Page            page      = null;
0:         Transaction     rawtran   = xact_manager.getRawStoreXact();
0: 
0:         try
0:         {
0:             container = 
0:                 rawtran.openContainer(
0:                     id, 
0:                     rawtran.newLockingPolicy(
0:                         LockingPolicy.MODE_CONTAINER,
0:                         TransactionController.ISOLATION_SERIALIZABLE, true),
0:                     ContainerHandle.MODE_FORUPDATE | 
0:                         (isTemporary() ? ContainerHandle.MODE_TEMP_IS_KEPT : 0));
0: 
0:             if (column_id != format_ids.length)
0:             {
0:                 if (SanityManager.DEBUG)
0:                     SanityManager.THROWASSERT(
0:                         "column_id = " + column_id +
0:                         "format_ids.length = " + format_ids.length +
0:                         "format_ids = " + format_ids);
0: 
0:                 throw(StandardException.newException(
0:                         SQLState.HEAP_TEMPLATE_MISMATCH,
0:                         new Long(column_id), 
0:                         new Long(this.format_ids.length)));
0:             }
0: 
0:             // create a new array, and copy old values to it.
0:             int[] old_format_ids = format_ids;
0:             format_ids              = new int[old_format_ids.length + 1];
0:             System.arraycopy(
0:                 old_format_ids, 0, format_ids, 0, old_format_ids.length);
0: 
0:             // add the new column
0:             format_ids[old_format_ids.length] = 
0:                 template_column.getTypeFormatId();
0: 
0:            
0:             // row in slot 0 of heap page 1 which is just a single column with
0:             // the heap entry.
0:             DataValueDescriptor[] control_row = new DataValueDescriptor[1];
0:             control_row[0] = this;
0: 
0:             page =
0:                 container.getPage(ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:             page.updateAtSlot(
0:                 Page.FIRST_SLOT_NUMBER,
0:                 control_row,
0:                 (FormatableBitSet) null);
0: 
0:             page.unlatch();
0:             page = null;
0:         }
0:         finally
0:         {
0:             if (container != null)
0:                 container.close();
0:             if (page !=null)
0:                 page.unlatch();
0:         }
0: 
0:         return;
0:     }
0: 
0: 
0: 	/**
0: 	Drop this heap.
0: 	@see Conglomerate#drop
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	public void drop(TransactionManager xact_manager)
0: 		throws StandardException
0: 	{
0:         xact_manager.getRawStoreXact().dropContainer(id);
0: 	}
0: 
0:     /**
0:      * Retrieve the maximum value row in an ordered conglomerate.
0:      * <p>
0:      * Returns true and fetches the rightmost row of an ordered conglomerate 
0:      * into "fetchRow" if there is at least one row in the conglomerate.  If
0:      * there are no rows in the conglomerate it returns false.
0:      * <p>
0:      * Non-ordered conglomerates will not implement this interface, calls
0:      * will generate a StandardException.
0:      * <p>
0:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
0:      * functionality will be provided by the openBackwardScan() interface.  
0:      *
0: 	 * @param conglomId       The identifier of the conglomerate
0: 	 *                        to open the scan for.
0:      *
0: 	 * @param open_mode       Specifiy flags to control opening of table.  
0:      *                        OPENMODE_FORUPDATE - if set open the table for
0:      *                        update otherwise open table shared.
0:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
0:      *
0:      * @param isolation_level The isolation level to lock the conglomerate at.
0:      *                        One of (ISOLATION_READ_COMMITTED or 
0:      *                        ISOLATION_SERIALIZABLE).
0:      *
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      *
0:      * @param fetchRow        The row to retrieve the maximum value into.
0:      *
0: 	 * @return boolean indicating if a row was found and retrieved or not.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public boolean fetchMaxOnBTree(
0: 	TransactionManager      xact_manager,
0:     Transaction             rawtran,
0:     long                    conglomId,
0:     int                     open_mode,
0:     int                     lock_level,
0:     LockingPolicy           locking_policy,
0:     int                     isolation_level,
0:     FormatableBitSet                 scanColumnList,
0:     DataValueDescriptor[]   fetchRow)
0:         throws StandardException
0:     {
0:         // no support for max on a heap table.
0:         throw(StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
0:     }
0: 
0:     /**
0:      * Get the id of the container of the conglomerate.
0:      * <p>
0:      * Will have to change when a conglomerate could have more than one 
0:      * container.  The ContainerKey is a combination of the container id
0:      * and segment id.
0:      *
0: 	 * @return The ContainerKey.
0:      **/
0:     public final ContainerKey getId()
0:     {
0:         return(id);
0:     }
0: 
0: 
0:     public final long getContainerid()
0:     {
0:         return(id.getContainerId());
0:     }
0: 
0:     /**
0:      * Return dynamic information about the conglomerate to be dynamically 
0:      * reused in repeated execution of a statement.
0:      * <p>
0:      * The dynamic info is a set of variables to be used in a given 
0:      * ScanController or ConglomerateController.  It can only be used in one 
0:      * controller at a time.  It is up to the caller to insure the correct 
0:      * thread access to this info.  The type of info in this is a scratch 
0:      * template for btree traversal, other scratch variables for qualifier 
0:      * evaluation, ...
0:      * <p>
0:      *
0: 	 * @return The dynamic information.
0:      *
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
0: 		throws StandardException
0:     {
0:         return(new OpenConglomerateScratchSpace(format_ids));
0:     }
0: 
0:     /**
0:      * Return static information about the conglomerate to be included in a
0:      * a compiled plan.
0:      * <p>
0:      * The static info would be valid until any ddl was executed on the 
0:      * conglomid, and would be up to the caller to throw away when that 
0:      * happened.  This ties in with what language already does for other 
0:      * invalidation of static info.  The type of info in this would be 
0:      * containerid and array of format id's from which templates can be created.
0:      * The info in this object is read only and can be shared among as many 
0:      * threads as necessary.
0:      * <p>
0:      *
0: 	 * @return The static compiled information.
0:      *
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
0:     TransactionController   tc,
0:     long                    conglomId)
0: 		throws StandardException
0:     {
0:         return(this);
0:     }
0: 
0: 
0:     /**
0:      * Is this conglomerate temporary?
0:      * <p>
0:      *
0: 	 * @return whether conglomerate is temporary or not.
0:      **/
0:     public boolean isTemporary()
0:     {
0:         return(id.getSegmentId() == ContainerHandle.TEMPORARY_SEGMENT);
0:     }
0: 
0: 
0:     /**
0:      * Bulk load into the conglomerate.
0:      * <p>
0:      *
0:      * @see Conglomerate#load
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public long load(
0: 	TransactionManager      xact_manager,
0: 	boolean                 createConglom,
0: 	RowLocationRetRowSource rowSource)
0: 		 throws StandardException
0: 	{
0:         long num_rows_loaded = 0;
0: 
0: 		HeapController heapcontroller = new HeapController();
0: 
0: 		try
0: 		{
0: 			num_rows_loaded = 
0:                 heapcontroller.load(
0:                     xact_manager,
0:                     this, 
0:                     createConglom,
0:                     rowSource);
0: 		}
0: 		finally
0: 		{
0: 			// Done with this heap controller.
0: 			heapcontroller.close();
0: 		}
0: 
0:         return(num_rows_loaded);
0: 	}
0: 
0:     /**
0:      * Open a heap controller.
0:      * <p>
0:      *
0: 	 * @see Conglomerate#open
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public ConglomerateController open(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException
0: 	{
0:         OpenConglomerate open_conglom = new OpenHeap();
0: 
0:         if (open_conglom.init(
0:                 (ContainerHandle) null,
0:                 this,
0:                 this.format_ids,
0:                 xact_manager,
0:                 rawtran,
0:                 hold,
0:                 open_mode,
0:                 lock_level,
0:                 locking_policy,
0:                 dynamic_info) == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()).toString());
0:         }
0: 
0: 		HeapController heapcontroller = new HeapController();
0: 
0:         heapcontroller.init(open_conglom);
0: 
0: 		return(heapcontroller);
0: 	}
0: 
0:     /**
0:      * Open a heap scan controller.
0:      * <p>
0:      *
0:      * @see Conglomerate#openScan
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public ScanManager openScan(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     int                             isolation_level,
0: 	FormatableBitSet				            scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]	        stopKeyValue,
0:     int                             stopSearchOperator,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException
0: 	{
0:         // Heap scans do not suppport start and stop scan positions (these
0:         // only make sense for ordered storage structures).
0: 		if (!RowUtil.isRowEmpty(startKeyValue, (FormatableBitSet) null)
0: 			|| !RowUtil.isRowEmpty(stopKeyValue, (FormatableBitSet) null))
0: 		{
0:             throw StandardException.newException(
0:                     SQLState.HEAP_UNIMPLEMENTED_FEATURE);
0: 		}
0: 
0:         OpenConglomerate open_conglom = new OpenHeap();
0: 
0:         if (open_conglom.init(
0:                 (ContainerHandle) null,
0:                 this,
0:                 this.format_ids,
0:                 xact_manager,
0:                 rawtran,
0:                 hold,
0:                 open_mode,
0:                 lock_level,
0:                 locking_policy,
0:                 dynamic_info) == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()));
0:         }
0: 
0: 		HeapScan heapscan = new HeapScan();
0: 
0:         heapscan.init(
0:             open_conglom,
0:             scanColumnList,
0:             startKeyValue,
0:             startSearchOperator,
0:             qualifier,
0:             stopKeyValue,
0:             stopSearchOperator);
0: 
0: 		return(heapscan);
0: 	}
0: 
0: 
0:     /**
0:      * Return an open StoreCostController for the conglomerate.
0:      * <p>
0:      * Return an open StoreCostController which can be used to ask about 
0:      * the estimated row counts and costs of ScanController and 
0:      * ConglomerateController operations, on the given conglomerate.
0:      * <p>
0: 	 * @param xact_manager The TransactionController under which this 
0:      *                     operation takes place.
0: 	 * @param rawtran  raw transaction context in which scan is managed.
0:      *
0: 	 * @return The open StoreCostController.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see StoreCostController
0:      **/
0:     public StoreCostController openStoreCost(
0:     TransactionManager  xact_manager,
0:     Transaction         rawtran)
0: 		throws StandardException
0:     {
0:         OpenHeap open_conglom = new OpenHeap();
0: 
0:         if (open_conglom.init(
0:                 (ContainerHandle) null,
0:                 this,
0:                 this.format_ids,
0:                 xact_manager,
0:                 rawtran,
0:                 false,
0:                 ContainerHandle.MODE_READONLY,
0:                 TransactionController.MODE_TABLE,
0:                 (LockingPolicy) null,
0:                 (DynamicCompiledOpenConglomInfo) null) == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_CONTAINER_NOT_FOUND, 
0:                     new Long(id.getContainerId()));
0:         }
0: 
0: 
0:         HeapCostController heapcost = new HeapCostController();
0: 
0:         heapcost.init(open_conglom);
0: 
0: 		return(heapcost);
0:     }
0: 
0: 
0:     /**
0:      * Print this heap.
0:      **/
0:     public String toString()
0:     {
0:         return (id == null) ? "null" : id.toString();
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of StaticCompiledOpenConglomInfo Interface:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * return the "Conglomerate"
0:      * <p>
0:      * For heap just return "this", which both implements Conglomerate and
0:      * StaticCompiledOpenConglomInfo.
0:      * <p>
0:      *
0: 	 * @return this
0:      **/
0:     public DataValueDescriptor getConglom()
0:     {
0:         return(this);
0:     }
0: 
0: 
0:     /**************************************************************************
0: 	 * Methods of Storable (via Conglomerate)
0: 	 * Storable interface, implies Externalizable, TypedFormat
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return my format identifier.
0:      *
0:      * @see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0:      **/
0: 	public int getTypeFormatId()
0:     {
0: 		return StoredFormatIds.ACCESS_HEAP_V2_ID;
0: 	}
0: 
0:     /**
0:      * Return whether the value is null or not.
0:      *
0: 	 * @see org.apache.derby.iapi.services.io.Storable#isNull
0:      **/
0: 	public boolean isNull()
0: 	{
0: 		return id == null;
0: 	}
0: 
0:     /**
0:      * Restore the in-memory representation to the null value.
0:      *
0:      * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0:      *
0:      **/
0: 	public void restoreToNull()
0: 	{
0: 		id = null;
0: 	}
0: 
0:     /**
0:      * Store the stored representation of the column value in the stream.
0:      *
0:      **/
0: 	public void writeExternal(ObjectOutput out) throws IOException
0:     {
0: 
0:         // write the format id of this conglomerate
0:         FormatIdUtil.writeFormatIdInteger(out, this.getTypeFormatId());
0: 
0: 		out.writeInt((int) id.getSegmentId());
0:         out.writeLong(id.getContainerId());
0: 
0:         // write number of columns in heap.
0:         out.writeInt(format_ids.length);
0: 
0:         // write out array of format id's
0:         ConglomerateUtil.writeFormatIdArray(format_ids, out);
0: 	}
0: 
0:     /**
0:      * Restore the in-memory representation from the stream.
0:      *
0:      * @see java.io.Externalizable#readExternal
0:      **/
0: 	public void readExternal(ObjectInput in) throws IOException 
0:     {
0:         // read the format id of this conglomerate.
0:         FormatIdUtil.readFormatIdInteger(in);
0: 
0: 		int segmentid = in.readInt();
0:         long containerid = in.readLong();
0: 
0: 		id = new ContainerKey(segmentid, containerid);
0: 
0:         // read the number of columns in the heap.
0:         int num_columns = in.readInt();
0: 
0:         // read the array of format ids.
0:         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);
0:     }
0: 
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException 
0:     {
0:         // read the format id of this conglomerate.
0:         FormatIdUtil.readFormatIdInteger(in);
0: 
0: 		int segmentid = in.readInt();
0:         long containerid = in.readLong();
0: 
0: 		id = new ContainerKey(segmentid, containerid);
0: 
0:         // read the number of columns in the heap.
0:         int num_columns = in.readInt();
0: 
0:         // read the array of format ids.
0:         format_ids = ConglomerateUtil.readFormatIdArray(num_columns, in);
0:     }
0: 
0: }
============================================================================