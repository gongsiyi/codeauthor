1:24bbe75: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.xact.RawTransaction
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
12:eac0369: 
8:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.raw.xact;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:a12152a: import org.apache.derby.iapi.services.monitor.DerbyObservable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.Compensation;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Loggable;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:f824190: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.ByteArray;
1:eac0369: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.LimitObjectInput;
1:eac0369: 
7:eac0369: /**
1:eac0369: 	RawTransaction is the form of Transaction used within the raw store. This
1:eac0369: 	allows the break down of RawStore functionality into (at least) three modules
1:eac0369: 	(Transactions, Data, Log) without exposing internal information on the
1:eac0369: 	external interface.
1:eac0369: 
1:eac0369: 	<P>
1:eac0369: 	The transaction will notify any Observer's just before the transaction
1:eac0369: 	is committed, aborted or a rollback to savepoint occurs. The argument passed
1:eac0369: 	to the update() method of the Observer's will be one of
1:eac0369: 	<UL>
1:eac0369: 	<LI> RawTransaction.COMMIT - transaction is committing
1:eac0369: 	<LI> RawTransaction.ABORT - transaction is aborting
1:eac0369: 	<LI> RawTransaction.SAVEPOINTROLLBACK - transaction is being rolled back to a savepoint
1:eac0369: 	</UL>
1:eac0369: 	The observer's must perform a value equality check (equals()) on the 
1:eac0369:     update arg to see why it is being notified.
1:eac0369: 
1:eac0369: 	@see java.util.Observer
1:eac0369: */
1:eac0369: 
1:a12152a: public abstract class RawTransaction extends DerbyObservable implements Transaction
1:a12152a: {
1:eac0369: 
1:ce40a31: 	public static final Integer		COMMIT =             0;
1:ce40a31: 	public static final Integer		ABORT =              1;
1:ce40a31: 	public static final Integer     SAVEPOINT_ROLLBACK = 2;
1:ce40a31: 	public static final Integer		LOCK_ESCALATE      = 3;
1:eac0369: 
1:eac0369: 	protected StandardException		observerException;
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 		Get the lock factory to be used during this transaction.
1:eac0369: 	*/
1:eac0369: 	public abstract LockFactory getLockFactory();
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 		Get the data factory to be used during this transaction.
1:eac0369: 	*/
1:eac0369: 	public abstract DataFactory getDataFactory();
1:eac0369: 
1:f824190: 	/**	
1:f824190: 		Get the log factory to be used during this transaction.
1:f824190: 	*/
1:f824190: 	public abstract LogFactory getLogFactory();
1:f824190: 
1:eac0369: 	/**
1:eac0369: 		Get the log buffer to be used during this transaction.
1:eac0369: 	*/
1:eac0369: 	public abstract DynamicByteArrayOutputStream getLogBuffer();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Log a compensation operation and then action it in the context of this 
1:eac0369:         transaction.
1:eac0369: 		The CompensationOperation is logged in the transaction log file and 
1:eac0369:         then its doMe method is called to perform the required change.  This 
1:eac0369:         compensation operation will rollback the change that was done by the 
1:eac0369:         Loggable Operation at undoInstant. 
1:eac0369: 
1:eac0369: 		@param compensation	the Compensation Operation
1:eac0369: 		@param undoInstant	the LogInstant of the Loggable Operation this 
1:eac0369: 							compensation operation is going to roll back
1:eac0369: 		@param in			optional data for the rollback operation
1:eac0369: 
1:eac0369: 		@see Compensation
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 	*/
1:eac0369: 	public abstract void logAndUndo(Compensation compensation, LogInstant undoInstant, 
1:eac0369: 									LimitObjectInput in) 
2:eac0369: 		throws StandardException;
1:b4b8d3b: 
1:eac0369: 	/** Methods to help logging and recovery */
1:eac0369: 
1:ee9c803: 	/**
1:eac0369: 		Set the transactionId (Global and internal) of this transaction using a
1:eac0369: 		log record that contains the Global id
1:eac0369: 	*/
1:eac0369: 	abstract public void setTransactionId(Loggable beginXact, TransactionId shortId);
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 		Get the shortId of this transaction.  May return null if transactio
1:eac0369: 		has no ID.
1:eac0369: 	*/
1:eac0369: 	abstract public TransactionId getId();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the shortId of this transaction.  May return null if transactio
1:eac0369: 		has no ID.
1:eac0369: 	*/
1:eac0369: 	abstract public GlobalTransactionId getGlobalId();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add this raw transaction on to the list of update transaction
1:eac0369: 	*/
1:eac0369: 	public abstract void addUpdateTransaction(int transactionStatus);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove this raw transaction from the list of update transaction
1:eac0369: 	*/
1:eac0369: 	public abstract void removeUpdateTransaction();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Change the state of transaction in table to prepare.
1:eac0369: 	*/
1:eac0369: 	public abstract void prepareTransaction();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the log instant for the first log record written by this 
1:eac0369:         transaction.
1:eac0369: 	*/
1:eac0369: 	abstract public void setFirstLogInstant(LogInstant instant);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the log instant for the first log record written by this 
1:eac0369:         transaction.
1:eac0369: 	*/
1:eac0369: 	abstract public LogInstant getFirstLogInstant();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the log instant for the last log record written by this transaction. 
1:eac0369: 	*/
1:eac0369: 	abstract public void setLastLogInstant(LogInstant instant);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the log instant for the last log record written by this transaction. 
1:eac0369: 		If the transaction is unclear what its last log instant is, 
1:eac0369: 		than it may return null.
1:eac0369: 	*/
1:eac0369: 	abstract public LogInstant getLastLogInstant();
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check to see if a logical operation is allowed by this transaction, 
1:eac0369:         throws a TransactionExceotion if it isn't. This implementation allows
1:eac0369: 		logical operations. Transactions that need to disallow logical 
1:eac0369:         operations should hide this method.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy,
1:eac0369: 	*/
1:eac0369: 	public void checkLogicalOperationOk() throws StandardException {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return true if this transaction should be rolled back first
1:eac0369: 		in recovery. This implementation returns false. Transactions that
1:eac0369: 		need to rollback first during recovery should hide this method.
1:eac0369: 	*/
1:eac0369: 	public boolean recoveryRollbackFirst() {
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * During recovery re-prepare a transaction.
1:eac0369:      * <p>
1:eac0369:      * After redo() and undo(), this routine is called on all outstanding 
1:eac0369:      * in-doubt (prepared) transactions.  This routine re-acquires all 
1:eac0369:      * logical write locks for operations in the xact, and then modifies
1:eac0369:      * the transaction table entry to make the transaction look as if it
1:eac0369:      * had just been prepared following startup after recovery.
1:eac0369:      * <p>
1:24bbe75:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     abstract public void reprepare()
1:eac0369: 		throws StandardException;
1:b4b8d3b: 
1:eac0369: 	/**
1:eac0369: 		Allow an Observer to indicate an exception to the transaction that
1:eac0369: 		is raised in its update() method.
1:b4b8d3b: 	*/
1:eac0369: 	public void setObserverException(StandardException se) {
1:eac0369: 		if (observerException == null)
1:eac0369: 			observerException = se;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start a nested top transaction. A nested top transaction behaves exactly
1:eac0369: 		like a user transaction. Nested top transaction allow system type work
1:eac0369: 		to proceed in a separate transaction to the current user transaction
1:eac0369: 		and be committed independently of the user transaction (usually before
1:eac0369: 		the user transaction).
1:eac0369: 		Only one nested top transaction can be active in a context at any one
1:eac0369:         time.
1:eac0369: 		After a commit the transaction may be re-used.
1:eac0369: 
1:eac0369: 		A nested top transaction conflicts on the logical locks of its "parent"
1:eac0369:         transaction.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public abstract RawTransaction startNestedTopTransaction() throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Open a container that may be dropped - use only by logging and recovery.
1:eac0369: 		During recovery redo, a log record may refer to a container that has
1:eac0369: 		long been dropped.  This interface is provided so a dropped container
1:eac0369: 		may be opened.
1:eac0369: 
1:eac0369: 		If the container has been dropped and is known to be committed, then
1:eac0369: 		even if we open the dropped container with forUpdate true, the
1:eac0369: 		container will be silently opened as read only.  Logging and recovery
1:eac0369: 		code always check for committed drop status.  Anybody else wanting to
1:eac0369: 		use this interface must keep this in mind.
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 	*/
1:eac0369: 	public abstract RawContainerHandle openDroppedContainer
1:eac0369: 		(ContainerKey containerId, LockingPolicy locking)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:f57b07d: 		Recreate a container during redo recovery.
1:f57b07d: 
1:f57b07d:         Used during redo recovery when processing log records trying to 
1:f57b07d:         create a container, but no container is found in the db.
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 	 */
1:f57b07d: 	public abstract void reCreateContainerForRedoRecovery
1:eac0369: 		(long segmentId, long containerId, ByteArray containerInfo)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Status that needs to go into the begin transaction log record, if there
1:eac0369: 		is one, to help with recovery
1:eac0369: 	*/
1:eac0369: 	protected abstract int statusForBeginXactLog();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Status that needs to go into the end transaction log record, if there
1:eac0369: 		is one, to help with recovery
1:eac0369: 	*/
1:eac0369: 	protected abstract int statusForEndXactLog();
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 		Is the transaction in the middle of an abort.
1:eac0369: 	*/
1:eac0369: 	public abstract boolean inAbort();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Can this transaction handles post termination work
1:eac0369: 	*/
1:eac0369: 	public abstract boolean handlesPostTerminationWork();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Make this transaction aware that it is being used by recovery
1:eac0369: 	 */
1:eac0369: 	public abstract void recoveryTransaction();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Allow my users to notigy my observers.
1:eac0369: 	*/
1:eac0369: 	public void notifyObservers(Object arg) {
1:eac0369: 		if (countObservers() != 0) {
1:eac0369: 			setChanged();
1:eac0369: 			super.notifyObservers(arg);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**	
1:eac0369: 	 *Retunrs true if the transaction is part of rollforward recovery
1:eac0369: 	 */
1:eac0369: 	public abstract boolean inRollForwardRecovery();
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**	
1:a292c89:      * Redo a checkpoint during rollforward recovery.
1:a292c89:      *
1:a292c89:      * @param cinstant The LogInstant of the checkpoint
1:a292c89:      * @param redoLWM  Redo Low Water Mark in the check point record
1:a292c89:      * @param undoLWM Undo Low Water Mark in the checkpoint
1:a292c89:      * @exception StandardException Exception encountered during checkpoint
1:eac0369: 	 */
1:eac0369: 	public abstract void checkpointInRollForwardRecovery(LogInstant cinstant,
1:a292c89: 														 long redoLWM,
1:a292c89: 														 long undoLWM)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	
1:eac0369:     /**
1:402725c:      * Make the transaction block the online backup.
1:b4b8d3b:      *
1:24bbe75:      * @param wait if <tt>true</tt>, waits until the transaction
1:402725c:      *             can block the backup.
1:402725c:      * @return     <tt>true</tt> if the transaction  blocked the  
1:402725c:      *             backup.  <tt>false</tt> otherwise.
1:24bbe75:      * @exception StandardException if interrupted while waiting 
1:402725c:      *            for the backup in progress to complete.
1:24bbe75:      */
1:402725c:     public abstract boolean blockBackup(boolean wait)
1:24bbe75:         throws StandardException;
1:eac0369: 
1:402725c:     /**
1:402725c:      * Check if the transaction is blocking the backup ?
1:402725c:      * @return <tt> true </tt> if this transaction is 
1:402725c:      *         blocking the backup, otherwise <tt> false </tt>
1:402725c:      */
1:402725c:     public abstract boolean isBlockingBackup();
1:402725c: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a12152a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.DerbyObservable;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public abstract class RawTransaction extends DerbyObservable implements Transaction
1: {
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 	public static final Integer		COMMIT =             0;
1: 	public static final Integer		ABORT =              1;
1: 	public static final Integer     SAVEPOINT_ROLLBACK = 2;
1: 	public static final Integer		LOCK_ESCALATE      = 3;
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0fad4e6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:721f895
/////////////////////////////////////////////////////////////////////////
commit:ee9c803
/////////////////////////////////////////////////////////////////////////
1:     /**
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:a292c89
/////////////////////////////////////////////////////////////////////////
1:      * Redo a checkpoint during rollforward recovery.
1:      *
1:      * @param cinstant The LogInstant of the checkpoint
1:      * @param redoLWM  Redo Low Water Mark in the check point record
1:      * @param undoLWM Undo Low Water Mark in the checkpoint
1:      * @exception StandardException Exception encountered during checkpoint
1: 														 long redoLWM,
1: 														 long undoLWM)
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy,
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:f824190
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
/////////////////////////////////////////////////////////////////////////
1: 	/**	
1: 		Get the log factory to be used during this transaction.
1: 	*/
1: 	public abstract LogFactory getLogFactory();
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:f57b07d
/////////////////////////////////////////////////////////////////////////
1: 		Recreate a container during redo recovery.
1: 
1:         Used during redo recovery when processing log records trying to 
1:         create a container, but no container is found in the db.
1: 	public abstract void reCreateContainerForRedoRecovery
commit:402725c
/////////////////////////////////////////////////////////////////////////
1:      * Make the transaction block the online backup.
1:      *             can block the backup.
1:      * @return     <tt>true</tt> if the transaction  blocked the  
1:      *             backup.  <tt>false</tt> otherwise.
1:      *            for the backup in progress to complete.
1:     public abstract boolean blockBackup(boolean wait)
1:     /**
1:      * Check if the transaction is blocking the backup ?
1:      * @return <tt> true </tt> if this transaction is 
1:      *         blocking the backup, otherwise <tt> false </tt>
1:      */
1:     public abstract boolean isBlockingBackup();
1: 
commit:24bbe75
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * Try setting the transaction to be in backup blocking state.
1:      *
1:      * @param wait if <tt>true</tt>, waits until the transaction
0:      *             can be set into backup blocking state.
0:      * @return     <tt>true</tt> if the transaction can be set to a 
0:      *             blocking state. 
0:      *             <tt>false</tt> otherwise.
1:      * @exception StandardException if interrupted while waiting 
0:      *            for backup to complete to set the transaction into
0:      *            backup blocking state.
1:      */
0:     public abstract boolean setBackupBlockingState(boolean wait)
1:         throws StandardException;
commit:b4b8d3b
/////////////////////////////////////////////////////////////////////////
1: 	
0: 	/*
0: 	 * Try setting  the transaction to be in backup blocking state.
1: 	 *
0: 	 * @return     <tt>true</tt> if the transaction can be set to a 
0: 	 *             blocking state. 
0: 	 *             <tt>false</tt> otherwise.
1: 	 */
0: 	public abstract boolean setBackupBlockingState();
1: 
commit:a5bdbd4
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.xact.RawTransaction
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.raw.xact;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: 
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: 
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: import org.apache.derby.iapi.store.raw.Compensation;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Loggable;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
1: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
0: import org.apache.derby.catalog.UUID;
1: 
1: 
0: import java.util.Observable;
1: 
1: import org.apache.derby.iapi.services.io.LimitObjectInput;
1: 
1: /**
1: 	RawTransaction is the form of Transaction used within the raw store. This
1: 	allows the break down of RawStore functionality into (at least) three modules
1: 	(Transactions, Data, Log) without exposing internal information on the
1: 	external interface.
1: 
1: 	<P>
1: 	The transaction will notify any Observer's just before the transaction
1: 	is committed, aborted or a rollback to savepoint occurs. The argument passed
1: 	to the update() method of the Observer's will be one of
1: 	<UL>
1: 	<LI> RawTransaction.COMMIT - transaction is committing
1: 	<LI> RawTransaction.ABORT - transaction is aborting
1: 	<LI> RawTransaction.SAVEPOINTROLLBACK - transaction is being rolled back to a savepoint
1: 	</UL>
1: 	The observer's must perform a value equality check (equals()) on the 
1:     update arg to see why it is being notified.
1: 
1: 	@see java.util.Observer
1: */
1: 
0: public abstract class RawTransaction extends Observable implements Transaction {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
0: 	public static final Integer		COMMIT =             new Integer(0);
0: 	public static final Integer		ABORT =              new Integer(1);
0: 	public static final Integer     SAVEPOINT_ROLLBACK = new Integer(2);
0: 	public static final Integer		LOCK_ESCALATE      = new Integer(3);
1: 
1: 	protected StandardException		observerException;
1: 
1: 	/**	
1: 		Get the lock factory to be used during this transaction.
1: 	*/
1: 	public abstract LockFactory getLockFactory();
1: 
1: 	/**	
1: 		Get the data factory to be used during this transaction.
1: 	*/
1: 	public abstract DataFactory getDataFactory();
1: 
1: 	/**
0: 		Get cache statistics for the specified cache
1: 	*/
0: 	public abstract long[] getCacheStats(String cacheName);
1: 
1: 	/**
0: 		Reset the cache statistics for the specified cache
1: 	*/
0: 	public abstract void resetCacheStats(String cacheName);
1: 
1: 	/**
1: 		Get the log buffer to be used during this transaction.
1: 	*/
1: 	public abstract DynamicByteArrayOutputStream getLogBuffer();
1: 
1: 	/**
1: 		Log a compensation operation and then action it in the context of this 
1:         transaction.
1: 		The CompensationOperation is logged in the transaction log file and 
1:         then its doMe method is called to perform the required change.  This 
1:         compensation operation will rollback the change that was done by the 
1:         Loggable Operation at undoInstant. 
1: 
1: 		@param compensation	the Compensation Operation
1: 		@param undoInstant	the LogInstant of the Loggable Operation this 
1: 							compensation operation is going to roll back
1: 		@param in			optional data for the rollback operation
0: 		@param dataLengt	optional data length
1: 
1: 		@see Compensation
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 	*/
1: 	public abstract void logAndUndo(Compensation compensation, LogInstant undoInstant, 
1: 									LimitObjectInput in) 
1: 		throws StandardException;
1: 
1: 	/** Methods to help logging and recovery */
1: 
1: 	/** 
0: 		Set the transaction Ids (Global and internal) of this transaction
1: 	*/
0: 	public abstract void setTransactionId(GlobalTransactionId id, TransactionId shortId);
1: 
1: 	/**
1: 		Set the transactionId (Global and internal) of this transaction using a
1: 		log record that contains the Global id
1: 	*/
1: 	abstract public void setTransactionId(Loggable beginXact, TransactionId shortId);
1: 
1: 		
1: 	/**
1: 		Get the shortId of this transaction.  May return null if transactio
1: 		has no ID.
1: 	*/
1: 	abstract public TransactionId getId();
1: 
1: 	/**
1: 		Get the shortId of this transaction.  May return null if transactio
1: 		has no ID.
1: 	*/
1: 	abstract public GlobalTransactionId getGlobalId();
1: 
1: 	/**
1: 		Add this raw transaction on to the list of update transaction
1: 	*/
1: 	public abstract void addUpdateTransaction(int transactionStatus);
1: 
1: 	/**
1: 		Remove this raw transaction from the list of update transaction
1: 	*/
1: 	public abstract void removeUpdateTransaction();
1: 
1: 	/**
1: 		Change the state of transaction in table to prepare.
1: 	*/
1: 	public abstract void prepareTransaction();
1: 
1: 	/**
1: 		Set the log instant for the first log record written by this 
1:         transaction.
1: 	*/
1: 	abstract public void setFirstLogInstant(LogInstant instant);
1: 
1: 	/**
1: 		Get the log instant for the first log record written by this 
1:         transaction.
1: 	*/
1: 	abstract public LogInstant getFirstLogInstant();
1: 
1: 	/**
1: 		Set the log instant for the last log record written by this transaction. 
1: 	*/
1: 	abstract public void setLastLogInstant(LogInstant instant);
1: 
1: 	/**
1: 		Get the log instant for the last log record written by this transaction. 
1: 		If the transaction is unclear what its last log instant is, 
1: 		than it may return null.
1: 	*/
1: 	abstract public LogInstant getLastLogInstant();
1: 
1: 
1: 	/**
1: 		Check to see if a logical operation is allowed by this transaction, 
1:         throws a TransactionExceotion if it isn't. This implementation allows
1: 		logical operations. Transactions that need to disallow logical 
1:         operations should hide this method.
1: 
0: 		@exception StandardException Standard Cloudscape error policy,
1: 	*/
1: 	public void checkLogicalOperationOk() throws StandardException {
1: 	}
1: 
1: 	/**
1: 		Return true if this transaction should be rolled back first
1: 		in recovery. This implementation returns false. Transactions that
1: 		need to rollback first during recovery should hide this method.
1: 	*/
1: 	public boolean recoveryRollbackFirst() {
1: 		return false;
1: 	}
1: 
1:     /**
1:      * During recovery re-prepare a transaction.
1:      * <p>
1:      * After redo() and undo(), this routine is called on all outstanding 
1:      * in-doubt (prepared) transactions.  This routine re-acquires all 
1:      * logical write locks for operations in the xact, and then modifies
1:      * the transaction table entry to make the transaction look as if it
1:      * had just been prepared following startup after recovery.
1:      * <p>
0:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     abstract public void reprepare()
1: 		throws StandardException;
1: 
1: 	/**
1: 		Allow an Observer to indicate an exception to the transaction that
1: 		is raised in its update() method.
1: 	*/
1: 	public void setObserverException(StandardException se) {
1: 		if (observerException == null)
1: 			observerException = se;
1: 	}
1: 
1: 	/**
1: 		Start a nested top transaction. A nested top transaction behaves exactly
1: 		like a user transaction. Nested top transaction allow system type work
1: 		to proceed in a separate transaction to the current user transaction
1: 		and be committed independently of the user transaction (usually before
1: 		the user transaction).
1: 		Only one nested top transaction can be active in a context at any one
1:         time.
1: 		After a commit the transaction may be re-used.
1: 
1: 		A nested top transaction conflicts on the logical locks of its "parent"
1:         transaction.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 
1: 	public abstract RawTransaction startNestedTopTransaction() throws StandardException;
1: 
1: 
1: 	/**
1: 		Open a container that may be dropped - use only by logging and recovery.
1: 		During recovery redo, a log record may refer to a container that has
1: 		long been dropped.  This interface is provided so a dropped container
1: 		may be opened.
1: 
1: 		If the container has been dropped and is known to be committed, then
1: 		even if we open the dropped container with forUpdate true, the
1: 		container will be silently opened as read only.  Logging and recovery
1: 		code always check for committed drop status.  Anybody else wanting to
1: 		use this interface must keep this in mind.
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 	*/
1: 	public abstract RawContainerHandle openDroppedContainer
1: 		(ContainerKey containerId, LockingPolicy locking)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Recreate a container during load tran - use only by media recovery.
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 	 */
0: 	public abstract void reCreateContainerForLoadTran
1: 		(long segmentId, long containerId, ByteArray containerInfo)
1: 		throws StandardException;
1: 
1: 
1: 	/**
0: 		Add a truncation LWM to the log factory
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
0: 	public abstract void addTruncationLWM(UUID name, LogInstant instant)
1: 		 throws StandardException;
1: 
1: 
1: 	/**
0: 		Remove a truncation LWM from the log factory
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
0: 	public abstract void removeTruncationLWM(UUID name) throws StandardException;
1: 
1: 
1: 	/**
1: 		Status that needs to go into the begin transaction log record, if there
1: 		is one, to help with recovery
1: 	*/
1: 	protected abstract int statusForBeginXactLog();
1: 
1: 	/**
1: 		Status that needs to go into the end transaction log record, if there
1: 		is one, to help with recovery
1: 	*/
1: 	protected abstract int statusForEndXactLog();
1: 
1: 	/**	
1: 		Is the transaction in the middle of an abort.
1: 	*/
1: 	public abstract boolean inAbort();
1: 
1: 	/**
1: 		Can this transaction handles post termination work
1: 	*/
1: 	public abstract boolean handlesPostTerminationWork();
1: 
1: 	/**
1: 		Make this transaction aware that it is being used by recovery
1: 	 */
1: 	public abstract void recoveryTransaction();
1: 
1: 	/**
1: 		Allow my users to notigy my observers.
1: 	*/
1: 	public void notifyObservers(Object arg) {
1: 		if (countObservers() != 0) {
1: 			setChanged();
1: 			super.notifyObservers(arg);
1: 		}
1: 	}
1: 
1: 	
1: 	/**	
1: 	 *Retunrs true if the transaction is part of rollforward recovery
1: 	 */
1: 	public abstract boolean inRollForwardRecovery();
1: 
1: 
1: 	/**	
0: 	 * redo a checkpoint during rollforward recovery
1: 	 */
1: 	public abstract void checkpointInRollForwardRecovery(LogInstant cinstant,
0: 														 long redoLWM) 
1: 		throws StandardException;
1: 
1: }
1: 
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw.xact
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw.xact;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: 
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: 
0: import org.apache.derby.iapi.store.raw.data.DataFactory;
0: import org.apache.derby.iapi.store.raw.Compensation;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Loggable;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.GlobalTransactionId;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.data.RawContainerHandle;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
0: import org.apache.derby.catalog.UUID;
0: 
0: 
0: import java.util.Observable;
0: 
0: import org.apache.derby.iapi.services.io.LimitObjectInput;
0: 
0: /**
0: 	RawTransaction is the form of Transaction used within the raw store. This
0: 	allows the break down of RawStore functionality into (at least) three modules
0: 	(Transactions, Data, Log) without exposing internal information on the
0: 	external interface.
0: 
0: 	<P>
0: 	The transaction will notify any Observer's just before the transaction
0: 	is committed, aborted or a rollback to savepoint occurs. The argument passed
0: 	to the update() method of the Observer's will be one of
0: 	<UL>
0: 	<LI> RawTransaction.COMMIT - transaction is committing
0: 	<LI> RawTransaction.ABORT - transaction is aborting
0: 	<LI> RawTransaction.SAVEPOINTROLLBACK - transaction is being rolled back to a savepoint
0: 	</UL>
0: 	The observer's must perform a value equality check (equals()) on the 
0:     update arg to see why it is being notified.
0: 
0: 	@see java.util.Observer
0: */
0: 
0: public abstract class RawTransaction extends Observable implements Transaction {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	public static final Integer		COMMIT =             new Integer(0);
0: 	public static final Integer		ABORT =              new Integer(1);
0: 	public static final Integer     SAVEPOINT_ROLLBACK = new Integer(2);
0: 	public static final Integer		LOCK_ESCALATE      = new Integer(3);
0: 
0: 	protected StandardException		observerException;
0: 
0: 	/**	
0: 		Get the lock factory to be used during this transaction.
0: 	*/
0: 	public abstract LockFactory getLockFactory();
0: 
0: 	/**	
0: 		Get the data factory to be used during this transaction.
0: 	*/
0: 	public abstract DataFactory getDataFactory();
0: 
0: 	/**
0: 		Get cache statistics for the specified cache
0: 	*/
0: 	public abstract long[] getCacheStats(String cacheName);
0: 
0: 	/**
0: 		Reset the cache statistics for the specified cache
0: 	*/
0: 	public abstract void resetCacheStats(String cacheName);
0: 
0: 	/**
0: 		Get the log buffer to be used during this transaction.
0: 	*/
0: 	public abstract DynamicByteArrayOutputStream getLogBuffer();
0: 
0: 	/**
0: 		Log a compensation operation and then action it in the context of this 
0:         transaction.
0: 		The CompensationOperation is logged in the transaction log file and 
0:         then its doMe method is called to perform the required change.  This 
0:         compensation operation will rollback the change that was done by the 
0:         Loggable Operation at undoInstant. 
0: 
0: 		@param compensation	the Compensation Operation
0: 		@param undoInstant	the LogInstant of the Loggable Operation this 
0: 							compensation operation is going to roll back
0: 		@param in			optional data for the rollback operation
0: 		@param dataLengt	optional data length
0: 
0: 		@see Compensation
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 	*/
0: 	public abstract void logAndUndo(Compensation compensation, LogInstant undoInstant, 
0: 									LimitObjectInput in) 
0: 		throws StandardException;
0: 
0: 	/** Methods to help logging and recovery */
0: 
0: 	/** 
0: 		Set the transaction Ids (Global and internal) of this transaction
0: 	*/
0: 	public abstract void setTransactionId(GlobalTransactionId id, TransactionId shortId);
0: 
0: 	/**
0: 		Set the transactionId (Global and internal) of this transaction using a
0: 		log record that contains the Global id
0: 	*/
0: 	abstract public void setTransactionId(Loggable beginXact, TransactionId shortId);
0: 
0: 		
0: 	/**
0: 		Get the shortId of this transaction.  May return null if transactio
0: 		has no ID.
0: 	*/
0: 	abstract public TransactionId getId();
0: 
0: 	/**
0: 		Get the shortId of this transaction.  May return null if transactio
0: 		has no ID.
0: 	*/
0: 	abstract public GlobalTransactionId getGlobalId();
0: 
0: 	/**
0: 		Add this raw transaction on to the list of update transaction
0: 	*/
0: 	public abstract void addUpdateTransaction(int transactionStatus);
0: 
0: 	/**
0: 		Remove this raw transaction from the list of update transaction
0: 	*/
0: 	public abstract void removeUpdateTransaction();
0: 
0: 	/**
0: 		Change the state of transaction in table to prepare.
0: 	*/
0: 	public abstract void prepareTransaction();
0: 
0: 	/**
0: 		Set the log instant for the first log record written by this 
0:         transaction.
0: 	*/
0: 	abstract public void setFirstLogInstant(LogInstant instant);
0: 
0: 	/**
0: 		Get the log instant for the first log record written by this 
0:         transaction.
0: 	*/
0: 	abstract public LogInstant getFirstLogInstant();
0: 
0: 	/**
0: 		Set the log instant for the last log record written by this transaction. 
0: 	*/
0: 	abstract public void setLastLogInstant(LogInstant instant);
0: 
0: 	/**
0: 		Get the log instant for the last log record written by this transaction. 
0: 		If the transaction is unclear what its last log instant is, 
0: 		than it may return null.
0: 	*/
0: 	abstract public LogInstant getLastLogInstant();
0: 
0: 
0: 	/**
0: 		Check to see if a logical operation is allowed by this transaction, 
0:         throws a TransactionExceotion if it isn't. This implementation allows
0: 		logical operations. Transactions that need to disallow logical 
0:         operations should hide this method.
0: 
0: 		@exception StandardException Standard Cloudscape error policy,
0: 	*/
0: 	public void checkLogicalOperationOk() throws StandardException {
0: 	}
0: 
0: 	/**
0: 		Return true if this transaction should be rolled back first
0: 		in recovery. This implementation returns false. Transactions that
0: 		need to rollback first during recovery should hide this method.
0: 	*/
0: 	public boolean recoveryRollbackFirst() {
0: 		return false;
0: 	}
0: 
0:     /**
0:      * During recovery re-prepare a transaction.
0:      * <p>
0:      * After redo() and undo(), this routine is called on all outstanding 
0:      * in-doubt (prepared) transactions.  This routine re-acquires all 
0:      * logical write locks for operations in the xact, and then modifies
0:      * the transaction table entry to make the transaction look as if it
0:      * had just been prepared following startup after recovery.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     abstract public void reprepare()
0: 		throws StandardException;
0: 
0: 	/**
0: 		Allow an Observer to indicate an exception to the transaction that
0: 		is raised in its update() method.
0: 	*/
0: 	public void setObserverException(StandardException se) {
0: 		if (observerException == null)
0: 			observerException = se;
0: 	}
0: 
0: 	/**
0: 		Start a nested top transaction. A nested top transaction behaves exactly
0: 		like a user transaction. Nested top transaction allow system type work
0: 		to proceed in a separate transaction to the current user transaction
0: 		and be committed independently of the user transaction (usually before
0: 		the user transaction).
0: 		Only one nested top transaction can be active in a context at any one
0:         time.
0: 		After a commit the transaction may be re-used.
0: 
0: 		A nested top transaction conflicts on the logical locks of its "parent"
0:         transaction.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 
0: 	public abstract RawTransaction startNestedTopTransaction() throws StandardException;
0: 
0: 
0: 	/**
0: 		Open a container that may be dropped - use only by logging and recovery.
0: 		During recovery redo, a log record may refer to a container that has
0: 		long been dropped.  This interface is provided so a dropped container
0: 		may be opened.
0: 
0: 		If the container has been dropped and is known to be committed, then
0: 		even if we open the dropped container with forUpdate true, the
0: 		container will be silently opened as read only.  Logging and recovery
0: 		code always check for committed drop status.  Anybody else wanting to
0: 		use this interface must keep this in mind.
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 	*/
0: 	public abstract RawContainerHandle openDroppedContainer
0: 		(ContainerKey containerId, LockingPolicy locking)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Recreate a container during load tran - use only by media recovery.
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 	 */
0: 	public abstract void reCreateContainerForLoadTran
0: 		(long segmentId, long containerId, ByteArray containerInfo)
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 		Add a truncation LWM to the log factory
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public abstract void addTruncationLWM(UUID name, LogInstant instant)
0: 		 throws StandardException;
0: 
0: 
0: 	/**
0: 		Remove a truncation LWM from the log factory
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public abstract void removeTruncationLWM(UUID name) throws StandardException;
0: 
0: 
0: 	/**
0: 		Status that needs to go into the begin transaction log record, if there
0: 		is one, to help with recovery
0: 	*/
0: 	protected abstract int statusForBeginXactLog();
0: 
0: 	/**
0: 		Status that needs to go into the end transaction log record, if there
0: 		is one, to help with recovery
0: 	*/
0: 	protected abstract int statusForEndXactLog();
0: 
0: 	/**	
0: 		Is the transaction in the middle of an abort.
0: 	*/
0: 	public abstract boolean inAbort();
0: 
0: 	/**
0: 		Can this transaction handles post termination work
0: 	*/
0: 	public abstract boolean handlesPostTerminationWork();
0: 
0: 	/**
0: 		Make this transaction aware that it is being used by recovery
0: 	 */
0: 	public abstract void recoveryTransaction();
0: 
0: 	/**
0: 		Allow my users to notigy my observers.
0: 	*/
0: 	public void notifyObservers(Object arg) {
0: 		if (countObservers() != 0) {
0: 			setChanged();
0: 			super.notifyObservers(arg);
0: 		}
0: 	}
0: 
0: 	
0: 	/**	
0: 	 *Retunrs true if the transaction is part of rollforward recovery
0: 	 */
0: 	public abstract boolean inRollForwardRecovery();
0: 
0: 
0: 	/**	
0: 	 * redo a checkpoint during rollforward recovery
0: 	 */
0: 	public abstract void checkpointInRollForwardRecovery(LogInstant cinstant,
0: 														 long redoLWM) 
0: 		throws StandardException;
0: 
0: }
0: 
0: 
============================================================================