1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.ContainerHandle
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.raw;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	A Container contains a contigious address space of pages, the pages
1:eac0369: 	start at page number Container.FIRST_PAGE_NUMBER and are numbered sequentially.
1:eac0369: 	
1:eac0369: 	The page size is set at addContainer() time.
1:eac0369: 
1:eac0369: 
1:eac0369: 	RESOLVE: this style of coding is not currently enforced
1:eac0369: 	If the caller calls getPage (or one of its variants) more than once on the 
1:eac0369:     same page, the caller must call unlatch a corresponding number of times in 
1:eac0369:     order to ensure that the page is latched.  For example:
1:eac0369: 	<p>
1:eac0369: 	<blockquote><pre>
1:eac0369:     Container c;
1:eac0369: 	Page p1 = c.getPage(Container.FIRST_PAGE_NUMBER);
1:eac0369: 	Page p2 = c.getPage(Container.FIRST_PAGE_NUMBER);
1:eac0369: 	p1.unlatch();  -- Page is still latched.
1:eac0369: 	p2.unlatch();  -- Page is now unlatched.
1:eac0369: 	</pre></blockquote>
1:eac0369: 
1:eac0369: 	<p>
1:eac0369: 	There is no restriction on the order in which latching and unlatching is 
1:eac0369:     done.  In the example, p1 could have been unlatched after p2 with no ill 	
1:eac0369:     effects.
1:eac0369: 
1:eac0369: 	<P>	<B>Open container modes</B>
1:eac0369: 	ContainerHandle.MODE are used to open or create the container.
1:eac0369: 	Unlike TableProperties, MODEs are not permanantely associated with the
1:eac0369: 	container, it is effective only for the lifetime of the containerHandle
1:eac0369: 	itself.
1:eac0369: 	<BR>A container may use any of these mode flags when it is opened.
1:eac0369: 	<UL>
1:eac0369: 	<LI>MODE_READONLY - Open the container in read only mode.
1:eac0369: 	<LI>MODE_FORUPDATE - Open the container in update mode, if the underlying 
1:eac0369:     storage does not allow updates
1:eac0369: 	then the container will be opned in read only mode.
1:eac0369: 	<LI>MODE_UNLOGGED - If Unset, any changes to the container are logged.
1:eac0369: 	If set, any user changes to the container are unlogged. It is guaranteed
1:eac0369:     at commit time that all changes made during the transaction will have been 
1:eac0369:     flushed to disk. Using this mode automatically opens the container in 
1:eac0369:     container locking, isolation 3 level. The state of the container following
1:eac0369:     an abort or any type of rollback is unspecified.
1:eac0369: 	<LI>MODE_CREATE_UNLOGGED - If set, not only are user changes to the
1:eac0369: 	container are unlogged, page allocations are also unlogged.  This MODE is
1:eac0369: 	only useful for container is created in the same statement and no change on
1:eac0369: 	the container (other than the create) is ever logged.  The difference
1:eac0369: 	between MODE_UNLOGGED and MODE_CREATE_UNLOGGED is that page allocation is
1:eac0369: 	also unlogged and commit of nested transaction will not cause the container
1:eac0369: 	to be forced from the cache.  Unlike MODE_UNLOGGED, MODE_CREATE_UNLOGGED
1:eac0369: 	does not force the cache.  It is up to the client of raw store to force the
1:eac0369: 	cache at the appropriate time - this allows a statement to create and open
1:eac0369: 	the container serveral times for bulk loading without logging or doing any
1:eac0369: 	synchronous I/O. 
1:eac0369: 	<LI>MODE_LOCK_NOWAIT - if set, then don't wait for the container lock, else
1:eac0369: 	wait for the container lock.  This flag only dictates whether the lock
1:eac0369: 	should be waited for or not.  After the container is successfully opened,
1:eac0369: 	whether this bit is set or not has no effect on the container handle.
1:eac0369: 	</UL>
1:eac0369: 	If neither or both of the {MODE_READONLY, MODE_FORUPDATE} modes are 
1:eac0369:     specified then the behaviour of the container is unspecified.
1:eac0369: 	<BR>
1:eac0369: 	MODE_UNLOGGED must be set for MODE_CREATE_UNLOGGED to be set.
1:eac0369: 	<P>
1:eac0369: 	<B>Temporary Containers</B><BR>
1:eac0369: 	If when creating a container the segment used is 
1:eac0369:     ContainerHandle.TEMPORARY_SEGMENT then the container is a temporary 
1:eac0369:     container. Temporary containers are not logged or locked and do not live 
1:eac0369:     across re-boots of the system. In addition any abort or rollback including
1:eac0369:     rollbacks to savepoints truncate the container if it has been opened for 
1:eac0369:     update since the last commit or abort.  Temporary containers are private 
1:eac0369:     to a transaction and must only be used a single thread within the 
1:eac0369:     transaction at any time, these restrictions are not currently enforced.
1:eac0369: 	<BR>
1:eac0369: 	When opening a temporary container for update access these additional mode
1:eac0369:     flags may be used
1:eac0369: 	<UL>
1:eac0369: 	<LI> MODE_TRUNCATE_ON_COMMIT - At commit/abort time container is truncated.
1:eac0369: 	<LI> MODE_DROP_ON_COMMIT - At commit/abort time the container is dropped.
1:eac0369: 	<LI> MODE_TEMP_IS_KEPT - At commit/abort time the container is kept around.
1:eac0369: 	</UL>
1:eac0369: 	If a temporary container is opened multiple times in the same transaction 
1:eac0369:     with different modes then the most severe mode is used, ie. none &lt; 
1:eac0369:     truncate on commit &lt; drop on commit.
1:eac0369: 	The MODE_UNLOGGED, MODE_CREAT_UNLOGGED flags are ignored when opening a 
1:eac0369:     temporary container, not logged is always assumed.  */
1:eac0369: 
1:eac0369: public interface ContainerHandle 
1:eac0369: {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Used in add container.
1:eac0369: 	*/
1:eac0369: 	public static final int DEFAULT_PAGESIZE = -1;
1:eac0369: 
1:eac0369: 	public static final int DEFAULT_SPARESPACE = -1;
1:eac0369: 
1:eac0369: 	public static final int DEFAULT_ASSIGN_ID = 0;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		See comments above for these modes.
1:eac0369: 	 */
1:eac0369: 	public static final int MODE_DEFAULT               = 0x00000000;
1:eac0369: 	public static final int MODE_UNLOGGED              = 0x00000001;
1:eac0369: 	public static final int MODE_CREATE_UNLOGGED       = 0x00000002;
1:eac0369: 	public static final int MODE_FORUPDATE             = 0x00000004;
1:eac0369: 	public static final int MODE_READONLY	           = 0x00000008;
1:eac0369: 	public static final int MODE_TRUNCATE_ON_COMMIT    = 0x00000010;
1:eac0369: 	public static final int MODE_DROP_ON_COMMIT        = 0x00000020;
1:eac0369: 	public static final int MODE_OPEN_FOR_LOCK_ONLY    = 0x00000040;
1:eac0369: 	public static final int MODE_LOCK_NOWAIT           = 0x00000080;
1:eac0369: 	public static final int MODE_TRUNCATE_ON_ROLLBACK  = 0x00000100; // internal raw store
1:eac0369: 	public static final int MODE_FLUSH_ON_COMMIT       = 0x00000200; // internal raw store
1:eac0369: 	public static final int MODE_NO_ACTIONS_ON_COMMIT  = 0x00000400; // internal raw store
1:eac0369: 	public static final int MODE_TEMP_IS_KEPT		   = 0x00000800; // internal raw store
1:eac0369: 
1:eac0369: 	public static final int MODE_USE_UPDATE_LOCKS	   = 0x00001000; // external access
1:eac0369:     public static final int MODE_SECONDARY_LOCKED      = 0x00002000; // external access
1:eac0369:     public static final int MODE_BASEROW_INSERT_LOCKED = 0x00004000; // external access
1:040d5c5:     public static final int MODE_LOCK_ROW_NOWAIT       = 0x00008000;
1:eac0369: 
1:eac0369: 	public static final int TEMPORARY_SEGMENT = -1;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The first valid page number
1:eac0369: 	*/
1:eac0369: 	public static final long FIRST_PAGE_NUMBER = 1;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		A page number that is guaranteed to be invalid.
1:eac0369: 	*/
1:eac0369: 	public static final long INVALID_PAGE_NUMBER = -1;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my identifier.
1:eac0369: 	*/
1:eac0369: 	public ContainerKey getId();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my unique identifier, this identifier will be unique to each
1:eac0369:         instance of an open container handle.  This id is used by the locking
1:eac0369:         system to group locks to an open container handle.
1:eac0369: 	*/
1:eac0369: 	public Object getUniqueId();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is the container opened for read only or update?
1:eac0369:      *
1:eac0369: 	 * @return true if container is opened for read only, else false.
1:eac0369:      **/
1:eac0369:     boolean isReadOnly();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add an empty page to the container and obtain exclusive access to it.
1:eac0369: 		<P>
1:eac0369: 		Note that the added page may not be the last page in the Container.
1:eac0369: 
1:eac0369: 		Once the Page is no longer required the Page's unlatch() method must 
1:eac0369:         be called.
1:eac0369: 
1:eac0369: 		@return a reference to the page that was added.
1:eac0369: 
1:eac0369: 		@see Page#unlatch
1:eac0369: 
1:eac0369: 		@exception StandardException If a page could not be allocated.
1:eac0369: 	*/
1:eac0369: 	public Page addPage() throws StandardException;
1:eac0369: 
1:eac0369: 
1:bbc927c: 	/**
1:bbc927c: 		Release free space to the OS.
1:bbc927c: 		<P>
1:bbc927c:         As is possible release any free space to the operating system.  This
1:bbc927c:         will usually mean releasing any free pages located at the end of the
1:bbc927c:         file using the java truncate() interface.
1:bbc927c: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:bbc927c: 	*/
1:bbc927c: 	public void compressContainer() throws StandardException;
1:bbc927c: 
1:d376440: 	/**
1:d376440: 	 * Get the reusable recordId sequence number.
1:d376440: 	 * @return version sequence number
1:d376440: 	 * @exception StandardException	Standard Derby error policy
1:d376440: 	 */
1:d376440: 	public long getReusableRecordIdSequenceNumber() throws StandardException;
1:bbc927c: 
1:eac0369: 	/**	
1:eac0369: 		Add an empty page to the container and obtain exclusive access to it.
1:eac0369: 		<P>
1:eac0369: 		If flag == ADD_PAGE_DEFAULT, this call is identical to addPage().
1:eac0369: 		<BR>
1:eac0369: 		If flag == ADD_PAGE_BULK, then this call signifies to the container that
1:eac0369: 		this addPage is part of a large number of additional pages and it is
1:eac0369: 		desirable to do whatever possible to facilitate adding many subsequent pages.
1:eac0369: 		The actual container implementation will decide whether or not to heed
1:eac0369: 		this hint and what to do about it.
1:eac0369: 
1:eac0369: 		@return a reference to the page that was added.
1:eac0369: 
1:eac0369: 		@see Page#unlatch
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 		@exception StandardException If a page could not be allocated.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public Page addPage(int flag) throws StandardException;
1:eac0369: 	public static final int ADD_PAGE_DEFAULT = 0x1;
1:eac0369: 	public static final int ADD_PAGE_BULK = 0x2;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Try to preallocate numPage new pages if possible.
1:eac0369: 	 */
1:eac0369: 	public void preAllocate(int numPage);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove this page from the container and unlatch the page.  <B>Caller
1:eac0369: 		should commit or abort this transaction ASAP because failure to do so
1:eac0369: 		will slow down page allocation of this container. </B>
1:eac0369: 
1:eac0369: 		<BR>The page to be removed must be latched and gotten (or added) by
1:eac0369: 		this ContainerHandle.  The page should not be used again after this
1:eac0369: 		call as if it has been unlatched.  If the call to removePage is
1:eac0369: 		successful, this page is invalid should not be gotten again with
1:eac0369: 		getPage. 
1:eac0369: 
1:eac0369: 		<BR>RemovePage will guarantee to unlatch the page even if a
1:eac0369: 		StandardException is thrown. 
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		<B>Locking Policy</B>
1:eac0369: 		<BR>
1:eac0369: 		The page will not be freed until the transaction that removed the page 
1:eac0369: 		commits.  A special RecordHandle.DEALLOC_PROTECTION_HANDLE lock will be 
1:eac0369: 		gotten for the transaction and which is used to prevent the page from 
1:eac0369: 		being freed.  This lock will be held regardless of the default locking 
1:eac0369: 		policy of the transaction that called removedPage.
1:eac0369: 
1:eac0369: 		@see LockingPolicy
1:eac0369: 		@see RecordHandle
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy 
1:eac0369: 	*/
1:eac0369: 	public void removePage(Page page) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain exclusive access to the page with the given page number.
1:eac0369: 		
1:eac0369: 		Once the Page is no longer required the Page's unlatch() method must 
1:eac0369:         be called.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:eac0369:         caller until its unlatch() method is called.
1:eac0369: 
1:eac0369: 		@return the required Page or null if the page does not exist or is not 
1:eac0369:         valid (i.e, it has been deallocated or freed or never initialized)
1:eac0369: 		Note that an overflow page will be returned since it is a valid page.
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page getPage(long pageNumber)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Identical to getPage but returns null immediately if the desired page
1:eac0369:         is already latched by another Container.
1:eac0369: 
1:eac0369: 		@return the required Page or null if the page does not exist or the page
1:eac0369: 		is already latched.
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public Page getPageNoWait(long pageNumber) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369:         Obtain exclusive access to the page with the given page number.
1:eac0369: 
1:eac0369:         Will only return a valid, non-overflow user page - so can be used by
1:eac0369:         routines in post commit to get pages to attempt deleted row space
1:eac0369:         reclamation.  If for some reason a request is made for an overflow
1:eac0369:         page a null will be returned.
1:eac0369: 
1:eac0369: 		Once the Page is no longer required the Page's unlatch() method must 
1:eac0369:         be called.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:eac0369:         caller until its unlatch() method is called.
1:eac0369: 
1:eac0369: 		@return the required Page or null if the page does not exist or is not 
1:eac0369:         valid (i.e, it has been deallocated, freed, never initialized, or is
1:eac0369:         an allocation page or overflow page)
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page getUserPageNoWait(long pageNumber) throws StandardException;
1:eac0369: 	/**
1:eac0369:         Obtain exclusive access to the page with the given page number.
1:eac0369: 
1:eac0369:         Will only return a valid, non-overflow user page - so can be used by
1:eac0369:         routines in post commit to get pages to attempt deleted row space
1:eac0369:         reclamation.  If for some reason a request is made for an overflow
1:eac0369:         page a null will be returned.
1:eac0369: 
1:eac0369: 		Once the Page is no longer required the Page's unlatch() method must 
1:eac0369:         be called.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:eac0369:         caller until its unlatch() method is called.
1:eac0369: 
1:eac0369: 		@return the required Page or null if the page does not exist or is not 
1:eac0369:         valid (i.e, it has been deallocated, freed, never initialized, or is
1:eac0369:         an allocation page or overflow page)
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public Page getUserPageWait(long pageNumber) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain exclusive access to the current first page of the container.
1:eac0369: 		Only a valid, non overflow page will be returned.
1:eac0369: 		Pages in the container are ordered in an internally defined ordering.
1:eac0369: 		<P>
1:eac0369: 		Note that once this method returns this page may no longer be the 
1:eac0369: 		first page of the container.  I.e, other threads may allocate pages 
1:eac0369: 		prior to this page number while this page is latched.  It is up to
1:eac0369: 		the caller of this routine to synchronize this call with addPage to 
1:eac0369: 		assure that this is the first page.  
1:eac0369: 		<BR>
1:eac0369: 		As long as the client provide the necessary lock to ensure 
1:eac0369: 		that no addPage is called, then this page is guaranteed to be the
1:eac0369: 		first page of the container in some internally defined ordering of
1:eac0369: 		the pages.
1:eac0369: 
1:eac0369: 		@return latched page or null if there is no page in the container
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 
1:eac0369: 		@see ContainerHandle#getPage
1:eac0369: 	*/
1:eac0369: 	public Page getFirstPage() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain exclusive access to the next valid page of the given page number 
1:eac0369: 		in the container. Only a valid, non overflow page will be returned.
1:eac0369: 		Pages in the container are ordered in an internally defined ordering.
1:eac0369: 		<P>
1:eac0369: 		Note that once this method returns this page may no longer be the 
1:eac0369: 		next page of the container.  I.e, other threads may allocate pages 
1:eac0369: 		prior to this page number while this page is latched.  It is up to
1:eac0369: 		the caller of this routine to synchronize this call with addPage to 
1:eac0369: 		assure that this is the first page.  
1:eac0369: 		<BR>
1:eac0369: 		As long as the client provide the necessary lock to ensure 
1:eac0369: 		that no addPage is called, then this page is guaranteed to be the
1:eac0369: 		next page of the container in some internally defined ordering of
1:eac0369: 		the pages.
1:eac0369: 		<BR>
1:eac0369: 		If no pages are added or removed, then an iteration such as:
1:eac0369: 		<PRE>
1:eac0369: 		for (Page p = containerHandle.getFirstPage();
1:eac0369: 			 p != null;
1:eac0369: 			 p = containerHandle.getNextPage(p.getPageNumber()))
1:eac0369: 		<PRE>
1:eac0369: 		will guarentee to iterate thru and latched all the valid pages 
1:eac0369: 		in the container
1:eac0369: 
1:eac0369: 		@param prevNum the pagenumber of the page previous to the page
1:eac0369: 		that is to be gotten.  The page which correspond to prevNum
1:eac0369: 		may or may not be latched by the caller, but it must be gotten 
1:eac0369: 		via a page which was (or currently still is) latched, and the page
1:eac0369: 		number must be gotten while the container must not have been closed 
1:eac0369: 		or dropped or removed in the interim.
1:eac0369: 
1:eac0369: 		In other words, if the user manufactures a page number, or remembers 
1:eac0369: 		the page number from a previous session or a previous openContainer, 
1:eac0369: 		then the behavior of this routine is undefined.
1:eac0369: 
1:eac0369: 		@return latched page or null if there is no next page in the container
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 
1:eac0369: 		@see ContainerHandle#getPage
1:eac0369: 	*/
1:eac0369: 	public Page getNextPage(long prevNum) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a page for insert.  If RawStore thinks it knows where a potentially
1:eac0369: 		suitable page is for insert, it will return it.  If RawStore doesn't
1:eac0369: 		know where a suitable page for insert is, or if there are no allocated
1:eac0369: 		page, then null is returned.  If a page is returned, it will be a
1:eac0369: 		valid, non-overflow page.   A potentially suitable page is one which
1:eac0369: 		has enough space for a minium sized record.
1:eac0369: 
1:eac0369: 		@return a valid, non-overflow page.  Or null if RawStore doesn't know
1:eac0369: 		where to find a good valid, non-overflow page.
1:eac0369: 
1:eac0369: 		@param flag a GET_PAGE_* flag.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy 
1:eac0369: 	*/
1:eac0369: 	public Page getPageForInsert(int flag) 
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:bbc927c: 	public Page getPageForCompress(
1:bbc927c:     int     flag,
1:bbc927c:     long    pageno) 
1:bbc927c: 		 throws StandardException;
1:bbc927c: 
1:eac0369: 	// Try to get a page that is unfilled, 'unfill-ness' is defined by the
1:eac0369: 	// page.  Since unfill-ness is defined by the page, the only thing RawStore
1:eac0369: 	// guarentees about the page is that it has space for a a minimum sized
1:eac0369: 	// record.
1:eac0369: 	//
1:eac0369: 	// If this bit is not set, then getPageForInsert will get the page that was
1:eac0369: 	// last gotten, provided it has space for a minimum sized record.
1:eac0369: 	//
1:eac0369: 	// If for whatever reasons RawStore is unable to come up with such a page,
1:eac0369: 	// null will be returned.
1:eac0369: 	public static final int GET_PAGE_UNFILLED = 0x1;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request the system properties associated with a container. 
1:eac0369:      * <p>
1:eac0369:      * Request the value of properties that are associated with a table.  The
1:eac0369:      * following properties can be requested:
1:eac0369:      *     derby.storage.pageSize 
1:eac0369:      *     derby.storage.pageReservedSpace
1:eac0369:      *     derby.storage.minimumRecordSize
1:eac0369:      * <p>
1:eac0369:      * To get the value of a particular property add it to the property list,
1:eac0369:      * and on return the value of the property will be set to it's current 
1:eac0369:      * value.  For example:
1:eac0369:      *
1:eac0369:      * get_prop(ConglomerateController cc)
1:eac0369:      * {
1:eac0369:      *     Properties prop = new Properties();
1:eac0369:      *     prop.put("derby.storage.pageSize", "");
1:eac0369:      *     cc.getTableProperties(prop);
1:eac0369:      *
1:eac0369:      *     System.out.println(
1:eac0369:      *         "table's page size = " + 
1:eac0369:      *         prop.getProperty("derby.storage.pageSize");
1:eac0369:      * }
1:eac0369:      *
1:eac0369:      * @param prop   Property list to fill in.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     void getContainerProperties(Properties prop)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close me. After using this method the caller must throw away the
1:eac0369: 		reference to the Container object, e.g.
1:eac0369: 		<PRE>
1:eac0369: 			ref.close();
1:eac0369: 			ref = null;
1:eac0369: 		</PRE>
1:eac0369: 		<BR>
1:eac0369: 		The container will be closed automatically at the commit or abort
1:eac0369: 		of the transaction if this method is not called explictly.
1:eac0369: 		<BR>
1:eac0369: 		Any pages that were obtained using me and have not been released
1:eac0369: 		using Page's unlatch method are released, and references to them must be
1:eac0369: 		thrown away.
1:eac0369: 
1:eac0369: 
1:eac0369: 		@see Page#unlatch
1:eac0369: 	*/
1:eac0369: 	public void close();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Cost estimation
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the total estimated number of rows in the container, not including
1:eac0369: 		overflow rows.  This number is a rough estimate and may be grossly off.
1:eac0369: 
1:eac0369: 		@param flag different flavors of row count (reserved for future use)
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public long getEstimatedRowCount(int flag) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the total estimated number of rows in the container.  Often, after
1:eac0369: 		a scan, the client of RawStore has a much better estimate of the number
1:eac0369: 		of rows in the container then what RawStore has.  Use this better
1:eac0369: 		number for future reference.
1:eac0369: 		<BR>
1:eac0369: 		It is OK for a ReadOnly ContainerHandle to set the estimated row count.
1:eac0369: 
1:eac0369: 		@param count the estimated number of rows in the container.
1:eac0369: 		@param flag different flavors of row count (reserved for future use)
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public void setEstimatedRowCount(long count, int flag) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the total estimated number of allocated (not freed, not
1:eac0369: 		deallocated) user pages in the container, including overflow pages.
1:eac0369: 		this number is a rough estimate and may be grossly off.
1:eac0369: 
1:eac0369: 		@param flag different flavors of page count (reserved for future use)
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	public long getEstimatedPageCount(int flag) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Flush all dirty pages of the container to disk.  Used mainly for
1:eac0369: 		UNLOGGED or CREATE_UNLOGGED operation.
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public void flushContainer() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the locking policy for this open container.
1:eac0369: 	*/
1:eac0369: 	public LockingPolicy getLockingPolicy();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the locking policy for this open container
1:eac0369: 	*/
1:eac0369: 	public void setLockingPolicy(LockingPolicy newLockingPolicy);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a record handle that is initialized to the given segment id,
1:eac0369:         container id, page number and record id.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 
1:eac0369: 		@param pageNumber   the page number of the RecordHandle.
1:eac0369: 		@param recordId     the record id of the RecordHandle.
1:eac0369: 
1:eac0369: 		@see RecordHandle
1:eac0369: 	*/
1:eac0369: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
1:eac0369: 		 throws	StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This record probably has shrunk considerably.  Free its reserved space
1:eac0369: 		or compact it.
1:eac0369: 
1:eac0369: 		@param record	The record handle, the record must have been locked execlusively already.
1:3fd26f3: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 	*/
1:eac0369: 	public void compactRecord(RecordHandle record) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return true if this containerHandle refers to a temporary container.
1:3fd26f3: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 	 */
1:eac0369: 	public boolean isTemporaryContainer() throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Get information about space used by the container.
1:eac0369:     **/
1:eac0369:     public SpaceInfo getSpaceInfo() throws StandardException;
1:eac0369: 
1:25f99f5: 	/**
1:25f99f5: 	   Backup the container to the specified path.
1:3fd26f3: 	   @exception StandardException	Standard Derby error policy
1:25f99f5: 	*/
1:25f99f5: 	public void backupContainer(String backupContainerPath) throws StandardException;
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:040d5c5
/////////////////////////////////////////////////////////////////////////
1:     public static final int MODE_LOCK_ROW_NOWAIT       = 0x00008000;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy 
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy 
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby exception policy.
1: 		@exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
0: 	   @exception StandardException	Standard Derby error policy
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:ebb21c4
/////////////////////////////////////////////////////////////////////////
commit:25f99f5
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	   Backup the container to the specified path.
0: 	   @exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void backupContainer(String backupContainerPath) throws StandardException;
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 		Release free space to the OS.
1: 		<P>
1:         As is possible release any free space to the operating system.  This
1:         will usually mean releasing any free pages located at the end of the
1:         file using the java truncate() interface.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void compressContainer() throws StandardException;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 	public Page getPageForCompress(
1:     int     flag,
1:     long    pageno) 
1: 		 throws StandardException;
1: 
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the reusable recordId sequence number.
1: 	 * @return version sequence number
1: 	 * @exception StandardException	Standard Derby error policy
1: 	 */
1: 	public long getReusableRecordIdSequenceNumber() throws StandardException;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.ContainerHandle
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.raw;
1: 
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import java.util.Properties;
1: 
1: /**
1: 	A Container contains a contigious address space of pages, the pages
1: 	start at page number Container.FIRST_PAGE_NUMBER and are numbered sequentially.
1: 	
1: 	The page size is set at addContainer() time.
1: 
1: 
1: 	RESOLVE: this style of coding is not currently enforced
1: 	If the caller calls getPage (or one of its variants) more than once on the 
1:     same page, the caller must call unlatch a corresponding number of times in 
1:     order to ensure that the page is latched.  For example:
1: 	<p>
1: 	<blockquote><pre>
1:     Container c;
1: 	Page p1 = c.getPage(Container.FIRST_PAGE_NUMBER);
1: 	Page p2 = c.getPage(Container.FIRST_PAGE_NUMBER);
1: 	p1.unlatch();  -- Page is still latched.
1: 	p2.unlatch();  -- Page is now unlatched.
1: 	</pre></blockquote>
1: 
1: 	<p>
1: 	There is no restriction on the order in which latching and unlatching is 
1:     done.  In the example, p1 could have been unlatched after p2 with no ill 	
1:     effects.
1: 
1: 	<P>	<B>Open container modes</B>
1: 	ContainerHandle.MODE are used to open or create the container.
1: 	Unlike TableProperties, MODEs are not permanantely associated with the
1: 	container, it is effective only for the lifetime of the containerHandle
1: 	itself.
1: 	<BR>A container may use any of these mode flags when it is opened.
1: 	<UL>
1: 	<LI>MODE_READONLY - Open the container in read only mode.
1: 	<LI>MODE_FORUPDATE - Open the container in update mode, if the underlying 
1:     storage does not allow updates
1: 	then the container will be opned in read only mode.
1: 	<LI>MODE_UNLOGGED - If Unset, any changes to the container are logged.
1: 	If set, any user changes to the container are unlogged. It is guaranteed
1:     at commit time that all changes made during the transaction will have been 
1:     flushed to disk. Using this mode automatically opens the container in 
1:     container locking, isolation 3 level. The state of the container following
1:     an abort or any type of rollback is unspecified.
1: 	<LI>MODE_CREATE_UNLOGGED - If set, not only are user changes to the
1: 	container are unlogged, page allocations are also unlogged.  This MODE is
1: 	only useful for container is created in the same statement and no change on
1: 	the container (other than the create) is ever logged.  The difference
1: 	between MODE_UNLOGGED and MODE_CREATE_UNLOGGED is that page allocation is
1: 	also unlogged and commit of nested transaction will not cause the container
1: 	to be forced from the cache.  Unlike MODE_UNLOGGED, MODE_CREATE_UNLOGGED
1: 	does not force the cache.  It is up to the client of raw store to force the
1: 	cache at the appropriate time - this allows a statement to create and open
1: 	the container serveral times for bulk loading without logging or doing any
1: 	synchronous I/O. 
1: 	<LI>MODE_LOCK_NOWAIT - if set, then don't wait for the container lock, else
1: 	wait for the container lock.  This flag only dictates whether the lock
1: 	should be waited for or not.  After the container is successfully opened,
1: 	whether this bit is set or not has no effect on the container handle.
1: 	</UL>
1: 	If neither or both of the {MODE_READONLY, MODE_FORUPDATE} modes are 
1:     specified then the behaviour of the container is unspecified.
1: 	<BR>
1: 	MODE_UNLOGGED must be set for MODE_CREATE_UNLOGGED to be set.
1: 	<P>
1: 	<B>Temporary Containers</B><BR>
1: 	If when creating a container the segment used is 
1:     ContainerHandle.TEMPORARY_SEGMENT then the container is a temporary 
1:     container. Temporary containers are not logged or locked and do not live 
1:     across re-boots of the system. In addition any abort or rollback including
1:     rollbacks to savepoints truncate the container if it has been opened for 
1:     update since the last commit or abort.  Temporary containers are private 
1:     to a transaction and must only be used a single thread within the 
1:     transaction at any time, these restrictions are not currently enforced.
1: 	<BR>
1: 	When opening a temporary container for update access these additional mode
1:     flags may be used
1: 	<UL>
1: 	<LI> MODE_TRUNCATE_ON_COMMIT - At commit/abort time container is truncated.
1: 	<LI> MODE_DROP_ON_COMMIT - At commit/abort time the container is dropped.
1: 	<LI> MODE_TEMP_IS_KEPT - At commit/abort time the container is kept around.
1: 	</UL>
1: 	If a temporary container is opened multiple times in the same transaction 
1:     with different modes then the most severe mode is used, ie. none &lt; 
1:     truncate on commit &lt; drop on commit.
1: 	The MODE_UNLOGGED, MODE_CREAT_UNLOGGED flags are ignored when opening a 
1:     temporary container, not logged is always assumed.  */
1: 
1: public interface ContainerHandle 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 		Used in add container.
1: 	*/
1: 	public static final int DEFAULT_PAGESIZE = -1;
1: 
1: 	public static final int DEFAULT_SPARESPACE = -1;
1: 
1: 	public static final int DEFAULT_ASSIGN_ID = 0;
1: 
1: 	/**
1: 		See comments above for these modes.
1: 	 */
1: 	public static final int MODE_DEFAULT               = 0x00000000;
1: 	public static final int MODE_UNLOGGED              = 0x00000001;
1: 	public static final int MODE_CREATE_UNLOGGED       = 0x00000002;
1: 	public static final int MODE_FORUPDATE             = 0x00000004;
1: 	public static final int MODE_READONLY	           = 0x00000008;
1: 	public static final int MODE_TRUNCATE_ON_COMMIT    = 0x00000010;
1: 	public static final int MODE_DROP_ON_COMMIT        = 0x00000020;
1: 	public static final int MODE_OPEN_FOR_LOCK_ONLY    = 0x00000040;
1: 	public static final int MODE_LOCK_NOWAIT           = 0x00000080;
1: 	public static final int MODE_TRUNCATE_ON_ROLLBACK  = 0x00000100; // internal raw store
1: 	public static final int MODE_FLUSH_ON_COMMIT       = 0x00000200; // internal raw store
1: 	public static final int MODE_NO_ACTIONS_ON_COMMIT  = 0x00000400; // internal raw store
1: 	public static final int MODE_TEMP_IS_KEPT		   = 0x00000800; // internal raw store
1: 
1: 	public static final int MODE_USE_UPDATE_LOCKS	   = 0x00001000; // external access
1:     public static final int MODE_SECONDARY_LOCKED      = 0x00002000; // external access
1:     public static final int MODE_BASEROW_INSERT_LOCKED = 0x00004000; // external access
1: 
1: 	public static final int TEMPORARY_SEGMENT = -1;
1: 
1: 
1: 	/**
1: 		The first valid page number
1: 	*/
1: 	public static final long FIRST_PAGE_NUMBER = 1;
1: 	
1: 	/**
1: 		A page number that is guaranteed to be invalid.
1: 	*/
1: 	public static final long INVALID_PAGE_NUMBER = -1;
1: 
1: 	/**
1: 		Return my identifier.
1: 	*/
1: 	public ContainerKey getId();
1: 
1: 	/**
1: 		Return my unique identifier, this identifier will be unique to each
1:         instance of an open container handle.  This id is used by the locking
1:         system to group locks to an open container handle.
1: 	*/
1: 	public Object getUniqueId();
1: 
1:     /**
1:      * Is the container opened for read only or update?
1:      *
1: 	 * @return true if container is opened for read only, else false.
1:      **/
1:     boolean isReadOnly();
1: 
1: 	/**
1: 		Add an empty page to the container and obtain exclusive access to it.
1: 		<P>
1: 		Note that the added page may not be the last page in the Container.
1: 
1: 		Once the Page is no longer required the Page's unlatch() method must 
1:         be called.
1: 
1: 		@return a reference to the page that was added.
1: 
1: 		@see Page#unlatch
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 		@exception StandardException If a page could not be allocated.
1: 	*/
1: 	public Page addPage() throws StandardException;
1: 
1: 
1: 	/**	
1: 		Add an empty page to the container and obtain exclusive access to it.
1: 		<P>
1: 		If flag == ADD_PAGE_DEFAULT, this call is identical to addPage().
1: 		<BR>
1: 		If flag == ADD_PAGE_BULK, then this call signifies to the container that
1: 		this addPage is part of a large number of additional pages and it is
1: 		desirable to do whatever possible to facilitate adding many subsequent pages.
1: 		The actual container implementation will decide whether or not to heed
1: 		this hint and what to do about it.
1: 
1: 		@return a reference to the page that was added.
1: 
1: 		@see Page#unlatch
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 		@exception StandardException If a page could not be allocated.
1: 
1: 	*/
1: 	public Page addPage(int flag) throws StandardException;
1: 	public static final int ADD_PAGE_DEFAULT = 0x1;
1: 	public static final int ADD_PAGE_BULK = 0x2;
1: 
1: 
1: 	/**
1: 		Try to preallocate numPage new pages if possible.
1: 	 */
1: 	public void preAllocate(int numPage);
1: 
1: 
1: 	/**
1: 		Remove this page from the container and unlatch the page.  <B>Caller
1: 		should commit or abort this transaction ASAP because failure to do so
1: 		will slow down page allocation of this container. </B>
1: 
1: 		<BR>The page to be removed must be latched and gotten (or added) by
1: 		this ContainerHandle.  The page should not be used again after this
1: 		call as if it has been unlatched.  If the call to removePage is
1: 		successful, this page is invalid should not be gotten again with
1: 		getPage. 
1: 
1: 		<BR>RemovePage will guarantee to unlatch the page even if a
1: 		StandardException is thrown. 
1: 
1: 		<P>
1: 		<B>Locking Policy</B>
1: 		<BR>
1: 		The page will not be freed until the transaction that removed the page 
1: 		commits.  A special RecordHandle.DEALLOC_PROTECTION_HANDLE lock will be 
1: 		gotten for the transaction and which is used to prevent the page from 
1: 		being freed.  This lock will be held regardless of the default locking 
1: 		policy of the transaction that called removedPage.
1: 
1: 		@see LockingPolicy
1: 		@see RecordHandle
1: 
0: 		@exception StandardException Standard Cloudscape error policy 
1: 	*/
1: 	public void removePage(Page page) throws StandardException;
1: 
1: 
1: 	/**
1: 		Obtain exclusive access to the page with the given page number.
1: 		
1: 		Once the Page is no longer required the Page's unlatch() method must 
1:         be called.
1: 
1: 		<P>
1: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:         caller until its unlatch() method is called.
1: 
1: 		@return the required Page or null if the page does not exist or is not 
1:         valid (i.e, it has been deallocated or freed or never initialized)
1: 		Note that an overflow page will be returned since it is a valid page.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public Page getPage(long pageNumber)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Identical to getPage but returns null immediately if the desired page
1:         is already latched by another Container.
1: 
1: 		@return the required Page or null if the page does not exist or the page
1: 		is already latched.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 
1: 	*/
1: 	public Page getPageNoWait(long pageNumber) throws StandardException;
1: 
1: 	/**
1:         Obtain exclusive access to the page with the given page number.
1: 
1:         Will only return a valid, non-overflow user page - so can be used by
1:         routines in post commit to get pages to attempt deleted row space
1:         reclamation.  If for some reason a request is made for an overflow
1:         page a null will be returned.
1: 
1: 		Once the Page is no longer required the Page's unlatch() method must 
1:         be called.
1: 
1: 		<P>
1: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:         caller until its unlatch() method is called.
1: 
1: 		@return the required Page or null if the page does not exist or is not 
1:         valid (i.e, it has been deallocated, freed, never initialized, or is
1:         an allocation page or overflow page)
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public Page getUserPageNoWait(long pageNumber) throws StandardException;
1: 	/**
1:         Obtain exclusive access to the page with the given page number.
1: 
1:         Will only return a valid, non-overflow user page - so can be used by
1:         routines in post commit to get pages to attempt deleted row space
1:         reclamation.  If for some reason a request is made for an overflow
1:         page a null will be returned.
1: 
1: 		Once the Page is no longer required the Page's unlatch() method must 
1:         be called.
1: 
1: 		<P>
1: 		The Page object is guaranteed to remain in-memory and exclusive to the 
1:         caller until its unlatch() method is called.
1: 
1: 		@return the required Page or null if the page does not exist or is not 
1:         valid (i.e, it has been deallocated, freed, never initialized, or is
1:         an allocation page or overflow page)
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public Page getUserPageWait(long pageNumber) throws StandardException;
1: 
1: 	/**
1: 		Obtain exclusive access to the current first page of the container.
1: 		Only a valid, non overflow page will be returned.
1: 		Pages in the container are ordered in an internally defined ordering.
1: 		<P>
1: 		Note that once this method returns this page may no longer be the 
1: 		first page of the container.  I.e, other threads may allocate pages 
1: 		prior to this page number while this page is latched.  It is up to
1: 		the caller of this routine to synchronize this call with addPage to 
1: 		assure that this is the first page.  
1: 		<BR>
1: 		As long as the client provide the necessary lock to ensure 
1: 		that no addPage is called, then this page is guaranteed to be the
1: 		first page of the container in some internally defined ordering of
1: 		the pages.
1: 
1: 		@return latched page or null if there is no page in the container
0: 		@exception StandardException	Standard Cloudscape error policy
1: 
1: 		@see ContainerHandle#getPage
1: 	*/
1: 	public Page getFirstPage() throws StandardException;
1: 
1: 	/**
1: 		Obtain exclusive access to the next valid page of the given page number 
1: 		in the container. Only a valid, non overflow page will be returned.
1: 		Pages in the container are ordered in an internally defined ordering.
1: 		<P>
1: 		Note that once this method returns this page may no longer be the 
1: 		next page of the container.  I.e, other threads may allocate pages 
1: 		prior to this page number while this page is latched.  It is up to
1: 		the caller of this routine to synchronize this call with addPage to 
1: 		assure that this is the first page.  
1: 		<BR>
1: 		As long as the client provide the necessary lock to ensure 
1: 		that no addPage is called, then this page is guaranteed to be the
1: 		next page of the container in some internally defined ordering of
1: 		the pages.
1: 		<BR>
1: 		If no pages are added or removed, then an iteration such as:
1: 		<PRE>
1: 		for (Page p = containerHandle.getFirstPage();
1: 			 p != null;
1: 			 p = containerHandle.getNextPage(p.getPageNumber()))
1: 		<PRE>
1: 		will guarentee to iterate thru and latched all the valid pages 
1: 		in the container
1: 
1: 		@param prevNum the pagenumber of the page previous to the page
1: 		that is to be gotten.  The page which correspond to prevNum
1: 		may or may not be latched by the caller, but it must be gotten 
1: 		via a page which was (or currently still is) latched, and the page
1: 		number must be gotten while the container must not have been closed 
1: 		or dropped or removed in the interim.
1: 
1: 		In other words, if the user manufactures a page number, or remembers 
1: 		the page number from a previous session or a previous openContainer, 
1: 		then the behavior of this routine is undefined.
1: 
1: 		@return latched page or null if there is no next page in the container
0: 		@exception StandardException	Standard Cloudscape error policy
1: 
1: 		@see ContainerHandle#getPage
1: 	*/
1: 	public Page getNextPage(long prevNum) throws StandardException;
1: 
1: 
1: 	/**
1: 		Get a page for insert.  If RawStore thinks it knows where a potentially
1: 		suitable page is for insert, it will return it.  If RawStore doesn't
1: 		know where a suitable page for insert is, or if there are no allocated
1: 		page, then null is returned.  If a page is returned, it will be a
1: 		valid, non-overflow page.   A potentially suitable page is one which
1: 		has enough space for a minium sized record.
1: 
1: 		@return a valid, non-overflow page.  Or null if RawStore doesn't know
1: 		where to find a good valid, non-overflow page.
1: 
1: 		@param flag a GET_PAGE_* flag.
1: 
0: 		@exception StandardException Standard Cloudscape error policy 
1: 	*/
1: 	public Page getPageForInsert(int flag) 
1: 		 throws StandardException;
1: 
1: 	// Try to get a page that is unfilled, 'unfill-ness' is defined by the
1: 	// page.  Since unfill-ness is defined by the page, the only thing RawStore
1: 	// guarentees about the page is that it has space for a a minimum sized
1: 	// record.
1: 	//
1: 	// If this bit is not set, then getPageForInsert will get the page that was
1: 	// last gotten, provided it has space for a minimum sized record.
1: 	//
1: 	// If for whatever reasons RawStore is unable to come up with such a page,
1: 	// null will be returned.
1: 	public static final int GET_PAGE_UNFILLED = 0x1;
1: 
1: 
1: 
1:     /**
1:      * Request the system properties associated with a container. 
1:      * <p>
1:      * Request the value of properties that are associated with a table.  The
1:      * following properties can be requested:
1:      *     derby.storage.pageSize 
1:      *     derby.storage.pageReservedSpace
1:      *     derby.storage.minimumRecordSize
1:      * <p>
1:      * To get the value of a particular property add it to the property list,
1:      * and on return the value of the property will be set to it's current 
1:      * value.  For example:
1:      *
1:      * get_prop(ConglomerateController cc)
1:      * {
1:      *     Properties prop = new Properties();
1:      *     prop.put("derby.storage.pageSize", "");
1:      *     cc.getTableProperties(prop);
1:      *
1:      *     System.out.println(
1:      *         "table's page size = " + 
1:      *         prop.getProperty("derby.storage.pageSize");
1:      * }
1:      *
1:      * @param prop   Property list to fill in.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     void getContainerProperties(Properties prop)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Close me. After using this method the caller must throw away the
1: 		reference to the Container object, e.g.
1: 		<PRE>
1: 			ref.close();
1: 			ref = null;
1: 		</PRE>
1: 		<BR>
1: 		The container will be closed automatically at the commit or abort
1: 		of the transaction if this method is not called explictly.
1: 		<BR>
1: 		Any pages that were obtained using me and have not been released
1: 		using Page's unlatch method are released, and references to them must be
1: 		thrown away.
1: 
1: 
1: 		@see Page#unlatch
0: 		@see Page#fetch
1: 	*/
1: 	public void close();
1: 
1: 	/**
1: 		Cost estimation
1: 	*/
1: 
1: 	/**
1: 		Get the total estimated number of rows in the container, not including
1: 		overflow rows.  This number is a rough estimate and may be grossly off.
1: 
1: 		@param flag different flavors of row count (reserved for future use)
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	 */
1: 	public long getEstimatedRowCount(int flag) throws StandardException;
1: 
1: 	/**
1: 		Set the total estimated number of rows in the container.  Often, after
1: 		a scan, the client of RawStore has a much better estimate of the number
1: 		of rows in the container then what RawStore has.  Use this better
1: 		number for future reference.
1: 		<BR>
1: 		It is OK for a ReadOnly ContainerHandle to set the estimated row count.
1: 
1: 		@param count the estimated number of rows in the container.
1: 		@param flag different flavors of row count (reserved for future use)
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	 */
1: 	public void setEstimatedRowCount(long count, int flag) throws StandardException;
1: 
1: 	/**
1: 		Get the total estimated number of allocated (not freed, not
1: 		deallocated) user pages in the container, including overflow pages.
1: 		this number is a rough estimate and may be grossly off.
1: 
1: 		@param flag different flavors of page count (reserved for future use)
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	 */
1: 	public long getEstimatedPageCount(int flag) throws StandardException;
1: 
1: 
1: 	/**
1: 		Flush all dirty pages of the container to disk.  Used mainly for
1: 		UNLOGGED or CREATE_UNLOGGED operation.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 	public void flushContainer() throws StandardException;
1: 
1: 	/**
1: 		Return the locking policy for this open container.
1: 	*/
1: 	public LockingPolicy getLockingPolicy();
1: 
1: 	/**
1: 		Set the locking policy for this open container
1: 	*/
1: 	public void setLockingPolicy(LockingPolicy newLockingPolicy);
1: 
1: 	/**
1: 		Return a record handle that is initialized to the given segment id,
1:         container id, page number and record id.
1: 
0: 		@exception StandardException Standard cloudscape exception policy.
1: 
1: 		@param pageNumber   the page number of the RecordHandle.
1: 		@param recordId     the record id of the RecordHandle.
1: 
1: 		@see RecordHandle
1: 	*/
1: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
1: 		 throws	StandardException;
1: 
1: 
1: 	/**
1: 		This record probably has shrunk considerably.  Free its reserved space
1: 		or compact it.
1: 
1: 		@param record	The record handle, the record must have been locked execlusively already.
0: 		@exception StandardException Standard cloudscape exception policy.
1: 	*/
1: 	public void compactRecord(RecordHandle record) throws StandardException;
1: 
1: 	/**
1: 		Return true if this containerHandle refers to a temporary container.
0: 		@exception StandardException Standard cloudscape exception policy.
1: 	 */
1: 	public boolean isTemporaryContainer() throws StandardException;
1: 
1:     /**
1:     Get information about space used by the container.
1:     **/
1:     public SpaceInfo getSpaceInfo() throws StandardException;
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw;
0: 
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import java.util.Properties;
0: 
0: /**
0: 	A Container contains a contigious address space of pages, the pages
0: 	start at page number Container.FIRST_PAGE_NUMBER and are numbered sequentially.
0: 	
0: 	The page size is set at addContainer() time.
0: 
0: 
0: 	RESOLVE: this style of coding is not currently enforced
0: 	If the caller calls getPage (or one of its variants) more than once on the 
0:     same page, the caller must call unlatch a corresponding number of times in 
0:     order to ensure that the page is latched.  For example:
0: 	<p>
0: 	<blockquote><pre>
0:     Container c;
0: 	Page p1 = c.getPage(Container.FIRST_PAGE_NUMBER);
0: 	Page p2 = c.getPage(Container.FIRST_PAGE_NUMBER);
0: 	p1.unlatch();  -- Page is still latched.
0: 	p2.unlatch();  -- Page is now unlatched.
0: 	</pre></blockquote>
0: 
0: 	<p>
0: 	There is no restriction on the order in which latching and unlatching is 
0:     done.  In the example, p1 could have been unlatched after p2 with no ill 	
0:     effects.
0: 
0: 	<P>	<B>Open container modes</B>
0: 	ContainerHandle.MODE are used to open or create the container.
0: 	Unlike TableProperties, MODEs are not permanantely associated with the
0: 	container, it is effective only for the lifetime of the containerHandle
0: 	itself.
0: 	<BR>A container may use any of these mode flags when it is opened.
0: 	<UL>
0: 	<LI>MODE_READONLY - Open the container in read only mode.
0: 	<LI>MODE_FORUPDATE - Open the container in update mode, if the underlying 
0:     storage does not allow updates
0: 	then the container will be opned in read only mode.
0: 	<LI>MODE_UNLOGGED - If Unset, any changes to the container are logged.
0: 	If set, any user changes to the container are unlogged. It is guaranteed
0:     at commit time that all changes made during the transaction will have been 
0:     flushed to disk. Using this mode automatically opens the container in 
0:     container locking, isolation 3 level. The state of the container following
0:     an abort or any type of rollback is unspecified.
0: 	<LI>MODE_CREATE_UNLOGGED - If set, not only are user changes to the
0: 	container are unlogged, page allocations are also unlogged.  This MODE is
0: 	only useful for container is created in the same statement and no change on
0: 	the container (other than the create) is ever logged.  The difference
0: 	between MODE_UNLOGGED and MODE_CREATE_UNLOGGED is that page allocation is
0: 	also unlogged and commit of nested transaction will not cause the container
0: 	to be forced from the cache.  Unlike MODE_UNLOGGED, MODE_CREATE_UNLOGGED
0: 	does not force the cache.  It is up to the client of raw store to force the
0: 	cache at the appropriate time - this allows a statement to create and open
0: 	the container serveral times for bulk loading without logging or doing any
0: 	synchronous I/O. 
0: 	<LI>MODE_LOCK_NOWAIT - if set, then don't wait for the container lock, else
0: 	wait for the container lock.  This flag only dictates whether the lock
0: 	should be waited for or not.  After the container is successfully opened,
0: 	whether this bit is set or not has no effect on the container handle.
0: 	</UL>
0: 	If neither or both of the {MODE_READONLY, MODE_FORUPDATE} modes are 
0:     specified then the behaviour of the container is unspecified.
0: 	<BR>
0: 	MODE_UNLOGGED must be set for MODE_CREATE_UNLOGGED to be set.
0: 	<P>
0: 	<B>Temporary Containers</B><BR>
0: 	If when creating a container the segment used is 
0:     ContainerHandle.TEMPORARY_SEGMENT then the container is a temporary 
0:     container. Temporary containers are not logged or locked and do not live 
0:     across re-boots of the system. In addition any abort or rollback including
0:     rollbacks to savepoints truncate the container if it has been opened for 
0:     update since the last commit or abort.  Temporary containers are private 
0:     to a transaction and must only be used a single thread within the 
0:     transaction at any time, these restrictions are not currently enforced.
0: 	<BR>
0: 	When opening a temporary container for update access these additional mode
0:     flags may be used
0: 	<UL>
0: 	<LI> MODE_TRUNCATE_ON_COMMIT - At commit/abort time container is truncated.
0: 	<LI> MODE_DROP_ON_COMMIT - At commit/abort time the container is dropped.
0: 	<LI> MODE_TEMP_IS_KEPT - At commit/abort time the container is kept around.
0: 	</UL>
0: 	If a temporary container is opened multiple times in the same transaction 
0:     with different modes then the most severe mode is used, ie. none &lt; 
0:     truncate on commit &lt; drop on commit.
0: 	The MODE_UNLOGGED, MODE_CREAT_UNLOGGED flags are ignored when opening a 
0:     temporary container, not logged is always assumed.  */
0: 
0: public interface ContainerHandle 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 		Used in add container.
0: 	*/
0: 	public static final int DEFAULT_PAGESIZE = -1;
0: 
0: 	public static final int DEFAULT_SPARESPACE = -1;
0: 
0: 	public static final int DEFAULT_ASSIGN_ID = 0;
0: 
0: 	/**
0: 		See comments above for these modes.
0: 	 */
0: 	public static final int MODE_DEFAULT               = 0x00000000;
0: 	public static final int MODE_UNLOGGED              = 0x00000001;
0: 	public static final int MODE_CREATE_UNLOGGED       = 0x00000002;
0: 	public static final int MODE_FORUPDATE             = 0x00000004;
0: 	public static final int MODE_READONLY	           = 0x00000008;
0: 	public static final int MODE_TRUNCATE_ON_COMMIT    = 0x00000010;
0: 	public static final int MODE_DROP_ON_COMMIT        = 0x00000020;
0: 	public static final int MODE_OPEN_FOR_LOCK_ONLY    = 0x00000040;
0: 	public static final int MODE_LOCK_NOWAIT           = 0x00000080;
0: 	public static final int MODE_TRUNCATE_ON_ROLLBACK  = 0x00000100; // internal raw store
0: 	public static final int MODE_FLUSH_ON_COMMIT       = 0x00000200; // internal raw store
0: 	public static final int MODE_NO_ACTIONS_ON_COMMIT  = 0x00000400; // internal raw store
0: 	public static final int MODE_TEMP_IS_KEPT		   = 0x00000800; // internal raw store
0: 
0: 	public static final int MODE_USE_UPDATE_LOCKS	   = 0x00001000; // external access
0:     public static final int MODE_SECONDARY_LOCKED      = 0x00002000; // external access
0:     public static final int MODE_BASEROW_INSERT_LOCKED = 0x00004000; // external access
0: 
0: 	public static final int TEMPORARY_SEGMENT = -1;
0: 
0: 
0: 	/**
0: 		The first valid page number
0: 	*/
0: 	public static final long FIRST_PAGE_NUMBER = 1;
0: 	
0: 	/**
0: 		A page number that is guaranteed to be invalid.
0: 	*/
0: 	public static final long INVALID_PAGE_NUMBER = -1;
0: 
0: 	/**
0: 		Return my identifier.
0: 	*/
0: 	public ContainerKey getId();
0: 
0: 	/**
0: 		Return my unique identifier, this identifier will be unique to each
0:         instance of an open container handle.  This id is used by the locking
0:         system to group locks to an open container handle.
0: 	*/
0: 	public Object getUniqueId();
0: 
0:     /**
0:      * Is the container opened for read only or update?
0:      *
0: 	 * @return true if container is opened for read only, else false.
0:      **/
0:     boolean isReadOnly();
0: 
0: 	/**
0: 		Add an empty page to the container and obtain exclusive access to it.
0: 		<P>
0: 		Note that the added page may not be the last page in the Container.
0: 
0: 		Once the Page is no longer required the Page's unlatch() method must 
0:         be called.
0: 
0: 		@return a reference to the page that was added.
0: 
0: 		@see Page#unlatch
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 		@exception StandardException If a page could not be allocated.
0: 	*/
0: 	public Page addPage() throws StandardException;
0: 
0: 
0: 	/**	
0: 		Add an empty page to the container and obtain exclusive access to it.
0: 		<P>
0: 		If flag == ADD_PAGE_DEFAULT, this call is identical to addPage().
0: 		<BR>
0: 		If flag == ADD_PAGE_BULK, then this call signifies to the container that
0: 		this addPage is part of a large number of additional pages and it is
0: 		desirable to do whatever possible to facilitate adding many subsequent pages.
0: 		The actual container implementation will decide whether or not to heed
0: 		this hint and what to do about it.
0: 
0: 		@return a reference to the page that was added.
0: 
0: 		@see Page#unlatch
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 		@exception StandardException If a page could not be allocated.
0: 
0: 	*/
0: 	public Page addPage(int flag) throws StandardException;
0: 	public static final int ADD_PAGE_DEFAULT = 0x1;
0: 	public static final int ADD_PAGE_BULK = 0x2;
0: 
0: 
0: 	/**
0: 		Try to preallocate numPage new pages if possible.
0: 	 */
0: 	public void preAllocate(int numPage);
0: 
0: 
0: 	/**
0: 		Remove this page from the container and unlatch the page.  <B>Caller
0: 		should commit or abort this transaction ASAP because failure to do so
0: 		will slow down page allocation of this container. </B>
0: 
0: 		<BR>The page to be removed must be latched and gotten (or added) by
0: 		this ContainerHandle.  The page should not be used again after this
0: 		call as if it has been unlatched.  If the call to removePage is
0: 		successful, this page is invalid should not be gotten again with
0: 		getPage. 
0: 
0: 		<BR>RemovePage will guarantee to unlatch the page even if a
0: 		StandardException is thrown. 
0: 
0: 		<P>
0: 		<B>Locking Policy</B>
0: 		<BR>
0: 		The page will not be freed until the transaction that removed the page 
0: 		commits.  A special RecordHandle.DEALLOC_PROTECTION_HANDLE lock will be 
0: 		gotten for the transaction and which is used to prevent the page from 
0: 		being freed.  This lock will be held regardless of the default locking 
0: 		policy of the transaction that called removedPage.
0: 
0: 		@see LockingPolicy
0: 		@see RecordHandle
0: 
0: 		@exception StandardException Standard Cloudscape error policy 
0: 	*/
0: 	public void removePage(Page page) throws StandardException;
0: 
0: 
0: 	/**
0: 		Obtain exclusive access to the page with the given page number.
0: 		
0: 		Once the Page is no longer required the Page's unlatch() method must 
0:         be called.
0: 
0: 		<P>
0: 		The Page object is guaranteed to remain in-memory and exclusive to the 
0:         caller until its unlatch() method is called.
0: 
0: 		@return the required Page or null if the page does not exist or is not 
0:         valid (i.e, it has been deallocated or freed or never initialized)
0: 		Note that an overflow page will be returned since it is a valid page.
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 	public Page getPage(long pageNumber)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Identical to getPage but returns null immediately if the desired page
0:         is already latched by another Container.
0: 
0: 		@return the required Page or null if the page does not exist or the page
0: 		is already latched.
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 
0: 	*/
0: 	public Page getPageNoWait(long pageNumber) throws StandardException;
0: 
0: 	/**
0:         Obtain exclusive access to the page with the given page number.
0: 
0:         Will only return a valid, non-overflow user page - so can be used by
0:         routines in post commit to get pages to attempt deleted row space
0:         reclamation.  If for some reason a request is made for an overflow
0:         page a null will be returned.
0: 
0: 		Once the Page is no longer required the Page's unlatch() method must 
0:         be called.
0: 
0: 		<P>
0: 		The Page object is guaranteed to remain in-memory and exclusive to the 
0:         caller until its unlatch() method is called.
0: 
0: 		@return the required Page or null if the page does not exist or is not 
0:         valid (i.e, it has been deallocated, freed, never initialized, or is
0:         an allocation page or overflow page)
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 	public Page getUserPageNoWait(long pageNumber) throws StandardException;
0: 	/**
0:         Obtain exclusive access to the page with the given page number.
0: 
0:         Will only return a valid, non-overflow user page - so can be used by
0:         routines in post commit to get pages to attempt deleted row space
0:         reclamation.  If for some reason a request is made for an overflow
0:         page a null will be returned.
0: 
0: 		Once the Page is no longer required the Page's unlatch() method must 
0:         be called.
0: 
0: 		<P>
0: 		The Page object is guaranteed to remain in-memory and exclusive to the 
0:         caller until its unlatch() method is called.
0: 
0: 		@return the required Page or null if the page does not exist or is not 
0:         valid (i.e, it has been deallocated, freed, never initialized, or is
0:         an allocation page or overflow page)
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 	public Page getUserPageWait(long pageNumber) throws StandardException;
0: 
0: 	/**
0: 		Obtain exclusive access to the current first page of the container.
0: 		Only a valid, non overflow page will be returned.
0: 		Pages in the container are ordered in an internally defined ordering.
0: 		<P>
0: 		Note that once this method returns this page may no longer be the 
0: 		first page of the container.  I.e, other threads may allocate pages 
0: 		prior to this page number while this page is latched.  It is up to
0: 		the caller of this routine to synchronize this call with addPage to 
0: 		assure that this is the first page.  
0: 		<BR>
0: 		As long as the client provide the necessary lock to ensure 
0: 		that no addPage is called, then this page is guaranteed to be the
0: 		first page of the container in some internally defined ordering of
0: 		the pages.
0: 
0: 		@return latched page or null if there is no page in the container
0: 		@exception StandardException	Standard Cloudscape error policy
0: 
0: 		@see ContainerHandle#getPage
0: 	*/
0: 	public Page getFirstPage() throws StandardException;
0: 
0: 	/**
0: 		Obtain exclusive access to the next valid page of the given page number 
0: 		in the container. Only a valid, non overflow page will be returned.
0: 		Pages in the container are ordered in an internally defined ordering.
0: 		<P>
0: 		Note that once this method returns this page may no longer be the 
0: 		next page of the container.  I.e, other threads may allocate pages 
0: 		prior to this page number while this page is latched.  It is up to
0: 		the caller of this routine to synchronize this call with addPage to 
0: 		assure that this is the first page.  
0: 		<BR>
0: 		As long as the client provide the necessary lock to ensure 
0: 		that no addPage is called, then this page is guaranteed to be the
0: 		next page of the container in some internally defined ordering of
0: 		the pages.
0: 		<BR>
0: 		If no pages are added or removed, then an iteration such as:
0: 		<PRE>
0: 		for (Page p = containerHandle.getFirstPage();
0: 			 p != null;
0: 			 p = containerHandle.getNextPage(p.getPageNumber()))
0: 		<PRE>
0: 		will guarentee to iterate thru and latched all the valid pages 
0: 		in the container
0: 
0: 		@param prevNum the pagenumber of the page previous to the page
0: 		that is to be gotten.  The page which correspond to prevNum
0: 		may or may not be latched by the caller, but it must be gotten 
0: 		via a page which was (or currently still is) latched, and the page
0: 		number must be gotten while the container must not have been closed 
0: 		or dropped or removed in the interim.
0: 
0: 		In other words, if the user manufactures a page number, or remembers 
0: 		the page number from a previous session or a previous openContainer, 
0: 		then the behavior of this routine is undefined.
0: 
0: 		@return latched page or null if there is no next page in the container
0: 		@exception StandardException	Standard Cloudscape error policy
0: 
0: 		@see ContainerHandle#getPage
0: 	*/
0: 	public Page getNextPage(long prevNum) throws StandardException;
0: 
0: 
0: 	/**
0: 		Get a page for insert.  If RawStore thinks it knows where a potentially
0: 		suitable page is for insert, it will return it.  If RawStore doesn't
0: 		know where a suitable page for insert is, or if there are no allocated
0: 		page, then null is returned.  If a page is returned, it will be a
0: 		valid, non-overflow page.   A potentially suitable page is one which
0: 		has enough space for a minium sized record.
0: 
0: 		@return a valid, non-overflow page.  Or null if RawStore doesn't know
0: 		where to find a good valid, non-overflow page.
0: 
0: 		@param flag a GET_PAGE_* flag.
0: 
0: 		@exception StandardException Standard Cloudscape error policy 
0: 	*/
0: 	public Page getPageForInsert(int flag) 
0: 		 throws StandardException;
0: 
0: 	// Try to get a page that is unfilled, 'unfill-ness' is defined by the
0: 	// page.  Since unfill-ness is defined by the page, the only thing RawStore
0: 	// guarentees about the page is that it has space for a a minimum sized
0: 	// record.
0: 	//
0: 	// If this bit is not set, then getPageForInsert will get the page that was
0: 	// last gotten, provided it has space for a minimum sized record.
0: 	//
0: 	// If for whatever reasons RawStore is unable to come up with such a page,
0: 	// null will be returned.
0: 	public static final int GET_PAGE_UNFILLED = 0x1;
0: 
0: 
0: 
0:     /**
0:      * Request the system properties associated with a container. 
0:      * <p>
0:      * Request the value of properties that are associated with a table.  The
0:      * following properties can be requested:
0:      *     derby.storage.pageSize 
0:      *     derby.storage.pageReservedSpace
0:      *     derby.storage.minimumRecordSize
0:      * <p>
0:      * To get the value of a particular property add it to the property list,
0:      * and on return the value of the property will be set to it's current 
0:      * value.  For example:
0:      *
0:      * get_prop(ConglomerateController cc)
0:      * {
0:      *     Properties prop = new Properties();
0:      *     prop.put("derby.storage.pageSize", "");
0:      *     cc.getTableProperties(prop);
0:      *
0:      *     System.out.println(
0:      *         "table's page size = " + 
0:      *         prop.getProperty("derby.storage.pageSize");
0:      * }
0:      *
0:      * @param prop   Property list to fill in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     void getContainerProperties(Properties prop)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Close me. After using this method the caller must throw away the
0: 		reference to the Container object, e.g.
0: 		<PRE>
0: 			ref.close();
0: 			ref = null;
0: 		</PRE>
0: 		<BR>
0: 		The container will be closed automatically at the commit or abort
0: 		of the transaction if this method is not called explictly.
0: 		<BR>
0: 		Any pages that were obtained using me and have not been released
0: 		using Page's unlatch method are released, and references to them must be
0: 		thrown away.
0: 
0: 
0: 		@see Page#unlatch
0: 		@see Page#fetch
0: 	*/
0: 	public void close();
0: 
0: 	/**
0: 		Cost estimation
0: 	*/
0: 
0: 	/**
0: 		Get the total estimated number of rows in the container, not including
0: 		overflow rows.  This number is a rough estimate and may be grossly off.
0: 
0: 		@param flag different flavors of row count (reserved for future use)
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	 */
0: 	public long getEstimatedRowCount(int flag) throws StandardException;
0: 
0: 	/**
0: 		Set the total estimated number of rows in the container.  Often, after
0: 		a scan, the client of RawStore has a much better estimate of the number
0: 		of rows in the container then what RawStore has.  Use this better
0: 		number for future reference.
0: 		<BR>
0: 		It is OK for a ReadOnly ContainerHandle to set the estimated row count.
0: 
0: 		@param count the estimated number of rows in the container.
0: 		@param flag different flavors of row count (reserved for future use)
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	 */
0: 	public void setEstimatedRowCount(long count, int flag) throws StandardException;
0: 
0: 	/**
0: 		Get the total estimated number of allocated (not freed, not
0: 		deallocated) user pages in the container, including overflow pages.
0: 		this number is a rough estimate and may be grossly off.
0: 
0: 		@param flag different flavors of page count (reserved for future use)
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	 */
0: 	public long getEstimatedPageCount(int flag) throws StandardException;
0: 
0: 
0: 	/**
0: 		Flush all dirty pages of the container to disk.  Used mainly for
0: 		UNLOGGED or CREATE_UNLOGGED operation.
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 	public void flushContainer() throws StandardException;
0: 
0: 	/**
0: 		Return the locking policy for this open container.
0: 	*/
0: 	public LockingPolicy getLockingPolicy();
0: 
0: 	/**
0: 		Set the locking policy for this open container
0: 	*/
0: 	public void setLockingPolicy(LockingPolicy newLockingPolicy);
0: 
0: 	/**
0: 		Return a record handle that is initialized to the given segment id,
0:         container id, page number and record id.
0: 
0: 		@exception StandardException Standard cloudscape exception policy.
0: 
0: 		@param pageNumber   the page number of the RecordHandle.
0: 		@param recordId     the record id of the RecordHandle.
0: 
0: 		@see RecordHandle
0: 	*/
0: 	public RecordHandle makeRecordHandle(long pageNumber, int recordId)
0: 		 throws	StandardException;
0: 
0: 
0: 	/**
0: 		This record probably has shrunk considerably.  Free its reserved space
0: 		or compact it.
0: 
0: 		@param record	The record handle, the record must have been locked execlusively already.
0: 		@exception StandardException Standard cloudscape exception policy.
0: 	*/
0: 	public void compactRecord(RecordHandle record) throws StandardException;
0: 
0: 	/**
0: 		Return true if this containerHandle refers to a temporary container.
0: 		@exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public boolean isTemporaryContainer() throws StandardException;
0: 
0:     /**
0:     Get information about space used by the container.
0:     **/
0:     public SpaceInfo getSpaceInfo() throws StandardException;
0: 
0: }
============================================================================