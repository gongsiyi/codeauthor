7:eac0369: /*
1:125c328: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedBlob
1:125c328: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
6:eac0369:  */
1:345de35: 
16:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1d6c1a5: import org.apache.derby.iapi.jdbc.EngineLOB;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:e093928: import org.apache.derby.iapi.types.RawToBinaryFormatStream;
1:eac0369: import org.apache.derby.iapi.types.Resetable;
1:eac0369: import org.apache.derby.iapi.services.io.InputStreamUtil;
1:3a6f4cf: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:3a6f4cf: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Blob;
1:cd7ef76: import java.io.EOFException;
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:846a533: /**
1:eac0369:     Implements java.sql.Blob (see the JDBC 2.0 spec).
1:eac0369:     A blob sits on top of a BINARY, VARBINARY or LONG VARBINARY column.
1:eac0369:     If its data is small (less than 1 page) it is a byte array taken from
1:eac0369:     the SQLBit class. If it is large (more than 1 page) it is a long column
1:eac0369:     in the database. The long column is accessed as a stream, and is implemented
1:eac0369:     in store as an OverflowInputStream.  The Resetable interface allows sending
1:eac0369:     messages to that stream to initialize itself (reopen its container and
1:eac0369:     lock the corresponding row) and to reset itself to the beginning. 
1:eac0369: 
1:eac0369:     NOTE: In the case that the data is large, it is represented as a stream.
1:eac0369:     This stream is returned to the user in the getBinaryStream() method.
1:eac0369:     This means that we have limited control over the state of the stream,
1:eac0369:     since the user can read bytes from it at any time.  Thus all methods
1:eac0369:     here reset the stream to the beginning before doing any work.
1:eac0369:     CAVEAT: The methods may not behave correctly if a user sets up
1:eac0369:     multiple threads and sucks data from the stream (returned from
1:eac0369:     getBinaryStream()) at the same time as calling the Blob methods.
1:eac0369: 
1:4153b27:   <P><B>Supports</B>
1:4153b27:    <UL>
1:4153b27:    <LI> JSR169 - no subsetting for java.sql.Blob
1:4153b27:    <LI> JDBC 2.0
1:4153b27:    <LI> JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes,
1:4153b27:         new update methods can safely be added into implementation.
1:4153b27:    </UL>
1:4153b27: 
1:eac0369:  */
1:eac0369: 
1:1d6c1a5: final class EmbedBlob extends ConnectionChild implements Blob, EngineLOB
14:eac0369: {
1:b526e7f:     /**
1:b526e7f:      * Tells whether the Blob has been materialized or not.
1:b526e7f:      * <p>
1:b526e7f:      * Materialization happens when the Blob is updated by the user. A
1:b526e7f:      * materialized Blob is represented either in memory or in a temporary file
1:b526e7f:      * on disk, depending on size.
1:b526e7f:      * <p>
1:b526e7f:      * A Blob that has not been materialized is represented by a stream into the
1:b526e7f:      * Derby store, and is read-only.
1:b526e7f:      */
1:b2b30ec:     private boolean         materialized;
1:846a533:     /**
1:846a533:      * The underlying positionable store stream, if any.
1:846a533:      * <p>
1:846a533:      * If {@link #materialized} is {@code true}, the stream is {@code null}.
1:846a533:      */
1:846a533:     private PositionedStoreStream myStream;
1:456b8a1:     
1:b526e7f:     /**
1:b526e7f:      * Locator value for this Blob, used as a handle by the client driver to
1:b526e7f:      * map operations to the correct Blob on the server side.
1:b526e7f:      *
1:b526e7f:      * @see #getLocator()
1:581dc2b:      */
1:b526e7f:     private int locator = 0;
1:b526e7f:     
1:b526e7f:     /**
1:b526e7f:      * Length of the stream representing the Blob.
1:b526e7f:      * <p>
1:846a533:      * Set to -1 when the stream has been {@link #materialized} or
1:b526e7f:      * the length of the stream is not currently known.
1:b526e7f:      */
1:b526e7f:     private long streamLength = -1;
1:581dc2b:     
1:cd7ef76:     /**
1:cd7ef76:      * Position offset for the stream representing the Blob, if any.
1:cd7ef76:      * <p>
1:cd7ef76:      * This offset accounts for the bytes encoding the stream length at the
1:cd7ef76:      * head of the stream. Data byte {@code pos} is at
1:cd7ef76:      * {@code pos + streamPositionOffset} in the underlying stream.
1:cd7ef76:      * Set to {@code Integer.MIN_VALUE} if the Blob isn't represented by a
1:cd7ef76:      * store stream.
1:cd7ef76:      */
1:cd7ef76:     private final int streamPositionOffset;
1:eac0369: 
1:125c328:     //This boolean variable indicates whether the Blob object has
1:125c328:     //been invalidated by calling free() on it
1:125c328:     private boolean isValid = true;
1:eac0369: 
1:b2b30ec:     private LOBStreamControl control;
1:b2b30ec: 
1:8846963:      /**
1:8846963:      * This constructor is used to create a empty Blob object. It is used by the
1:8846963:      * Connection interface method createBlob().
1:8846963:      * 
1:8846963:      * @param blobBytes A byte array containing the data to be stores in the 
1:8846963:      *        Blob.
1:8846963:      *
1:8846963:      * @param con The EmbedConnection object associated with this Blob object.
1:8846963:      *
1:8846963:      */
1:8846963:     
1:b2b30ec:      EmbedBlob(byte [] blobBytes,EmbedConnection con) throws SQLException {
1:8846963:         super(con);
1:2333262:          try {
1:10e4538:              control = new LOBStreamControl (con, blobBytes);
1:b2b30ec:              materialized = true;
1:cd7ef76:              streamPositionOffset = Integer.MIN_VALUE;
1:126b96c:              //add entry in connection so it can be cleared 
1:126b96c:              //when transaction is not valid
1:d96e398:              con.addLOBReference (this);
1:8846963:          }
1:b2b30ec:          catch (IOException e) {
1:b2b30ec:              throw Util.setStreamFailure (e);
1:541361f:          }
1:2333262:          catch (StandardException se) {
1:2333262:             throw Util.generateCsSQLException (se);
1:2333262:          }
1:2333262:      }
1:8846963:      
1:581dc2b:     /*
1:eac0369:       This constructor should only be called by EmbedResultSet.getBlob
1:eac0369:     */
1:eac0369:     protected EmbedBlob(DataValueDescriptor dvd, EmbedConnection con)
1:d349a1f:         throws StandardException, SQLException
1:eac0369:     {
1:b2b30ec:         super(con);
1:eac0369:         // if the underlying column is null, ResultSet.getBlob will return null,
1:eac0369:         // never should get this far
2:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(!dvd.isNull(), "blob is created on top of a null column");
1:541361f: 
1:e093928:         /*
1:e093928:            We support three scenarios at this point:
1:e093928:             a) The Blob value is already represented as bytes in memory.
1:e093928:                This is the case for small Blobs (less than 32 KB).
1:e093928:             b) The Blob value is represented as a resetable stream.
1:e093928:                This is the case for Blobs coming from the store
1:e093928:                (note the comment about SQLBit below).
1:e093928:             c) The Blob value is represented as a wrapped user stream.
1:e093928:                This stream cannot be reset, which means we have to drain the
1:e093928:                stream and store it temporarily until it is either discarded or
1:e093928:                inserted into the database.
1:e093928:          */
1:541361f:         if (dvd.hasStream()) { // Cases b) and c)
1:541361f:             streamPositionOffset = handleStreamValue(dvd.getStream(), con);
1:541361f:         } else { // a) Blob already materialized in memory
1:b2b30ec:             materialized = true;
1:e093928:             streamPositionOffset = Integer.MIN_VALUE;
1:eac0369:             // copy bytes into memory so that blob can live after result set
1:eac0369:             // is closed
1:eac0369:             byte[] dvdBytes = dvd.getBytes();
1:541361f: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(dvdBytes != null,"blob has a null value underneath");
1:cd7ef76:             try {
1:d2b4fdb:                 control = new LOBStreamControl (
1:10e4538:                             getEmbedConnection(), dvdBytes);
1:1c589af:             } catch (IOException e) {
1:d349a1f:                 throw Util.setStreamFailure(e);
1:2333262:             }
1:2333262:         }
1:541361f:         //add entry in connection so it can be cleared 
1:541361f:         //when transaction is not valid
1:541361f:         con.addLOBReference (this);
1:541361f:     }
1:eac0369: 
1:eac0369: 
1:541361f:     /**
1:541361f:      * Constructs a Blob object on top of a stream.
1:541361f:      *
1:541361f:      * @param dvdStream the source stream
1:541361f:      * @param con the connection owning the Blob
1:541361f:      * @return The offset into the stream where the user data begins (used if
1:541361f:      *      resetting the stream).
1:541361f:      * @throws StandardException if accessing the stream fails, or if writing
1:541361f:      *      data to temporary storage fails
1:541361f:      */
1:541361f:     private int handleStreamValue(InputStream dvdStream, EmbedConnection con)
1:d349a1f:             throws StandardException, SQLException {
1:541361f:         int offset = 0;
1:541361f:         // b) Resetable stream
1:541361f:         //    In this case the stream is coming from the Derby store.
1:541361f:         if (dvdStream instanceof Resetable) {
1:b2b30ec:             materialized = false;
1:eac0369: 
1:eac0369:             /*
1:eac0369:              We are expecting this stream to be a FormatIdInputStream with an
1:eac0369:              OverflowInputStream inside. FormatIdInputStream implements
1:eac0369:              Resetable. This should be the case when retrieving
1:eac0369:              data from a long column. However, SQLBit, which is the class
1:eac0369:              implementing the getStream() method for dvd.getStream(), does not
1:eac0369:              guarantee this for us
1:eac0369:              */
1:846a533:             if (SanityManager.DEBUG) {
1:846a533:                 SanityManager.ASSERT(dvdStream instanceof Resetable);
1:846a533:             }
1:846a533:             // Create a position aware stream on top of dvdStream so we can
1:846a533:             // more easily move back and forth in the Blob.
1:b2b30ec:             try {
1:dd2650f:                 myStream = new PositionedStoreStream(dvdStream);
1:cd7ef76:                 // The BinaryToRawStream will read the encoded length bytes.
1:cd7ef76:                 BinaryToRawStream tmpStream =
1:cd7ef76:                         new BinaryToRawStream(myStream, con);
1:541361f:                 offset = (int)myStream.getPosition();
1:cd7ef76:                 // Check up front if the stream length is specified.
1:cd7ef76:                 streamLength = tmpStream.getLength();
1:cd7ef76:                 tmpStream.close();
1:dd2650f:             } catch (StandardException se) {
1:dd2650f:                 if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:dd2650f:                     throw StandardException
1:dd2650f:                             .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:dd2650f:                 } else {
1:dd2650f:                     throw se;
1:dd2650f:                 }
1:cd7ef76:             } catch (IOException ioe) {
1:cd7ef76:                 throw StandardException.newException(
1:dd2650f:                      SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, "BLOB");
1:cd7ef76:             }
1:541361f:         // c) Non-resetable stream
1:541361f:         //    This is most likely a stream coming in from the user, and we
1:541361f:         //    don't have any guarantees on how it behaves.
1:541361f:         } else {
1:e093928:             // The code below will only work for RawToBinaryFormatStream.
1:e093928:             if (SanityManager.DEBUG) {
1:e093928:                 SanityManager.ASSERT(
1:e093928:                         dvdStream instanceof RawToBinaryFormatStream,
1:e093928:                         "Invalid stream type: " + dvdStream.getClass());
1:e093928:             }
1:e093928:             // The source stream isn't resetable, so we have to write it to a
1:e093928:             // temporary location to be able to support the Blob operations.
1:e093928:             materialized = true;
1:541361f:             offset = Integer.MIN_VALUE;
1:e093928:             try {
1:e093928:                 control = new LOBStreamControl(getEmbedConnection());
1:e093928:                 BinaryToRawStream tmpStream =
1:e093928:                         new BinaryToRawStream(dvdStream, con);
1:e093928:                 // Transfer the data.
1:e093928:                 byte[] bytes = new byte[4096]; // 4 KB buffer
1:e093928:                 long pos = 0;
1:e093928:                 while (true) {
1:e093928:                     int read = tmpStream.read(bytes, 0, bytes.length);
1:e093928:                     if (read < 1) {
1:e093928:                         // Reached EOF, or stream is behaving badly.
1:e093928:                         break;
1:e093928:                     }
1:e093928:                     // If the stream is larger than the maximum allowed by
1:e093928:                     // Derby, the call below will thrown an exception.
1:e093928:                     pos = control.write(bytes, 0, read, pos);
1:e093928:                 }
1:e093928:                 tmpStream.close();
1:e093928:             } catch (IOException ioe) {
1:d349a1f:                 throw Util.setStreamFailure(ioe);
1:e093928:             }
1:37ae69e:         }
1:541361f:         return offset;
1:37ae69e:     }
1:eac0369: 
1:cd7ef76:     /**
1:cd7ef76:      * Sets the position of the Blob to {@code logicalPos}, where position 0 is
1:cd7ef76:      * the beginning of the Blob content.
1:cd7ef76:      * <p>
1:cd7ef76:      * The position is only guaranteed to be valid from the time this method is
1:cd7ef76:      * invoked until the synchronization monitor is released, or until the next
1:cd7ef76:      * invokation of this method.
1:cd7ef76:      * <p>
1:cd7ef76:      * The position is logical in the sense that it specifies the requested
1:cd7ef76:      * position in the Blob content. This position might be at a different
1:cd7ef76:      * position in the underlying representation, for instance the Derby store
1:cd7ef76:      * stream prepends the Blob content with a length field.
1:cd7ef76:      *
1:cd7ef76:      * @param logicalPos requested Blob position, 0-based
1:cd7ef76:      * @return The new position, which will be equal to the requested position.
1:cd7ef76:      * @throws IOException if reading/accessing the Blob fails
1:cd7ef76:      * @throws StandardException throws BLOB_POSITION_TOO_LARGE if the requested
1:cd7ef76:      *      position is larger than the Blob length, throws other SQL states if
1:cd7ef76:      *      resetting the stream fails
1:cd7ef76:      */
1:cd7ef76:     //@GuardedBy(getConnectionSynchronization())
1:cd7ef76:     private long setBlobPosition(long logicalPos)
1:eac0369:         throws StandardException, IOException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:cd7ef76:             SanityManager.ASSERT(logicalPos >= 0);
1:cd7ef76:         if (materialized) {
1:cd7ef76:             // Nothing to do here, except checking if the position is valid.
1:cd7ef76:             if (logicalPos >= control.getLength()) {
1:cd7ef76:                 throw StandardException.newException(
1:ce40a31:                         SQLState.BLOB_POSITION_TOO_LARGE, logicalPos);
1:cd7ef76:             }
1:cd7ef76:         } else {
1:cd7ef76:             // Reposition the store stream, account for the length field offset.
1:cd7ef76:             try {
1:cd7ef76:                 this.myStream.reposition(
1:cd7ef76:                         logicalPos + this.streamPositionOffset);
1:cd7ef76:             } catch (EOFException eofe) {
1:cd7ef76:                 throw StandardException.newException(
1:cd7ef76:                         SQLState.BLOB_POSITION_TOO_LARGE, eofe,
1:ce40a31:                         logicalPos);
1:37ae69e:             }
1:b2b30ec:         }
1:cd7ef76:         return logicalPos;
1:b2b30ec:     }
1:eac0369: 
1:eac0369: 
1:cd7ef76:     /**
1:846a533:      * Reads one byte from the Blob at the specified position.
1:846a533:      * <p>
1:846a533:      * Depending on the representation, this might result in a read from a byte
1:846a533:      * array, a temporary file on disk or from a Derby store stream.
1:846a533:      *
1:f8cdf65:      * @return the byte at the current position, or -1 if end of file has been
1:f8cdf65:      * reached
1:846a533:      * @throws IOException if reading from the underlying data representation
1:846a533:      *      fails
1:846a533:      */
1:cd7ef76:     private int read(long pos)
1:cd7ef76:             throws IOException, StandardException {
1:eac0369:         int c;
1:cd7ef76:         if (materialized) {
1:2333262:             if (pos >= control.getLength())
1:2333262:                 return -1;
1:125c328:             else
1:2333262:                 c = control.read (pos);
1:cd7ef76:         } else {
1:cd7ef76:             // Make sure we're at the right position.
1:cd7ef76:             this.myStream.reposition(pos + this.streamPositionOffset);
1:cd7ef76:             // Read one byte from the stream.
1:cd7ef76:             c = this.myStream.read();
1:b2b30ec:         }
1:eac0369:         return c;
1:b2b30ec:     }
1:eac0369: 
1:cd7ef76:   /**
1:eac0369:    * Returns the number of bytes in the <code>BLOB</code> value
1:eac0369:    * designated by this <code>Blob</code> object.
1:eac0369:    * @return length of the <code>BLOB</code> in bytes
1:eac0369:    * @exception SQLException if there is an error accessing the
1:eac0369:    * length of the <code>BLOB</code>
1:eac0369:    */
2:eac0369:     // PT stream part may get pushed to store
1:eac0369:     public long length()
5:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:b2b30ec:         try {
1:b2b30ec:             if (materialized)
1:b2b30ec:                 return control.getLength ();
1:2333262:         }
1:b2b30ec:         catch (IOException e) {
1:b2b30ec:             throw Util.setStreamFailure (e);
1:2333262:         }
1:b526e7f:         if (streamLength != -1)
1:b526e7f:             return streamLength;
1:125c328:         
1:eac0369:         boolean pushStack = false;
1:eac0369:         try
1:eac0369:         {
1:581dc2b:            // we have a stream
1:eac0369:             synchronized (getConnectionSynchronization())
1:eac0369:             {
1:3a6f4cf:                 EmbedConnection ec = getEmbedConnection();
1:3a6f4cf:                 pushStack = !ec.isClosed();
1:eac0369:                 if (pushStack)
1:eac0369:                     setupContextStack();
1:3a6f4cf: 
1:cd7ef76:                 // We have to read the entire stream!
1:cd7ef76:                 myStream.resetStream();
1:cd7ef76:                 BinaryToRawStream tmpStream =
1:cd7ef76:                         new BinaryToRawStream(myStream, this);
1:cd7ef76:                 if (SanityManager.DEBUG) {
1:cd7ef76:                     SanityManager.ASSERT(tmpStream.getLength() == -1);
1:b2b30ec:                 }
1:3a6f4cf: 
1:a1c1356:                 streamLength = InputStreamUtil.skipUntilEOF(tmpStream);
1:a1c1356: 
1:cd7ef76:                 tmpStream.close();
1:581dc2b:                 // Save for future uses.
1:3a6f4cf: 
1:3a6f4cf:                 restoreIntrFlagIfSeen(pushStack, ec);
1:3a6f4cf: 
1:cd7ef76:                 return streamLength;
1:b2b30ec:             }
1:b2b30ec:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369: 			throw handleMyExceptions(t);
1:b2b30ec:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (pushStack)
1:eac0369:                 restoreContextStack();
1:581dc2b:         }
15:eac0369:     }
1:cd7ef76: 
1:581dc2b: 
1:456b8a1:   /**
1:eac0369:    * Returns as an array of bytes part or all of the <code>BLOB</code>
1:eac0369:    * value that this <code>Blob</code> object designates.  The byte
1:eac0369:    * array contains up to <code>length</code> consecutive bytes
1:f433a64:    * starting at position <code>startPos</code>.
1:f433a64:    * The starting position must be between 1 and the length
1:f433a64:    * of the BLOB plus 1. This allows for zero-length BLOB values, from
1:f433a64:    * which only zero-length byte arrays can be returned. 
1:f433a64:    * If a larger length is requested than there are bytes available,
1:f433a64:    * characters from the start position to the end of the BLOB are returned.
1:6b50965:    * @param startPos the ordinal position of the first byte in the
1:eac0369:    * <code>BLOB</code> value to be extracted; the first byte is at
1:eac0369:    * position 1
1:eac0369:    * @param length is the number of consecutive bytes to be copied
1:eac0369:    * @return a byte array containing up to <code>length</code>
1:eac0369:    * consecutive bytes from the <code>BLOB</code> value designated
1:eac0369:    * by this <code>Blob</code> object, starting with the
1:f433a64:    * byte at position <code>startPos</code>.
1:eac0369:    * @exception SQLException if there is an error accessing the
1:eac0369:    * <code>BLOB</code>
1:f433a64:    * NOTE: If the starting position is the length of the BLOB plus 1,
1:f433a64:    * zero bytess are returned regardless of the length requested.
1:eac0369:    */
1:eac0369:     public byte[] getBytes(long startPos, int length)
1:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328:         
1:eac0369:         boolean pushStack = false;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (startPos < 1)
2:eac0369:                 throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_BAD_POSITION, startPos);
1:f433a64:             if (length < 0)
1:eac0369:                 throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_NONPOSITIVE_LENGTH, length);
1:581dc2b: 
1:eac0369:             byte[] result;
1:b2b30ec:             // if the blob is materialized
1:b2b30ec:             if (materialized) {
1:b2b30ec:                  result = new byte [length];
1:2420903:                  int sz = control.read (result, 0, result.length, startPos - 1);
1:3a6f4cf:                  if (sz == -1) {
1:3a6f4cf:                      InterruptStatus.restoreIntrFlagIfSeen();
1:5d54436:                      return new byte [0];
1:3a6f4cf:                  }
1:b2b30ec:                  if (sz < length) {
1:b2b30ec:                      byte [] tmparray = new byte [sz];
1:b2b30ec:                      System.arraycopy (result, 0, tmparray, 0, sz);
1:b2b30ec:                      result = tmparray;
1:b2b30ec:                  }
1:3a6f4cf:                  InterruptStatus.restoreIntrFlagIfSeen();
1:eac0369:             }
1:eac0369:             else // we have a stream
1:eac0369:             {
1:eac0369:                 synchronized (getConnectionSynchronization())
1:eac0369:                 {
1:3a6f4cf:                     EmbedConnection ec = getEmbedConnection();
1:3a6f4cf:                     pushStack = !ec.isClosed();
1:eac0369:                     if (pushStack)
1:eac0369:                         setupContextStack();
1:eac0369: 
1:cd7ef76:                     setBlobPosition(startPos-1);
1:eac0369:                     // read length bytes into a string
1:eac0369:                     result = new byte[length];
1:cd7ef76:                     int n = InputStreamUtil.readLoop(myStream,result,0,length);
1:eac0369:                     /*
1:eac0369:                      According to the spec, if there are only n < length bytes
1:eac0369:                      to return, we should just return these bytes. Rather than
1:eac0369:                      return them in an array of size length, where the trailing
1:eac0369:                      bytes are not initialized, and the user cannot tell how
1:eac0369:                      many bytes were actually returned, we should return an
1:eac0369:                      array of n bytes.
1:eac0369:                      */
1:eac0369:                     if (n < length)
1:eac0369:                     {
1:eac0369:                         byte[] result2 = new byte[n];
1:eac0369:                         System.arraycopy(result,0,result2,0,n);
1:3a6f4cf: 
1:3a6f4cf:                         restoreIntrFlagIfSeen(pushStack, ec);
1:3a6f4cf: 
1:eac0369:                         return result2;
1:eac0369:                     }
1:3a6f4cf: 
1:3a6f4cf:                     restoreIntrFlagIfSeen(pushStack,ec);
1:eac0369:                 }
1:eac0369:             }
1:3a6f4cf: 
1:3a6f4cf: 
1:eac0369:             return result;
1:eac0369:         }
3:eac0369:         catch (StandardException e)
1:eac0369:         {  // if this is a setPosition exception then we ran out of Blob
1:e6936ea:             if (e.getMessageId().equals(SQLState.BLOB_LENGTH_TOO_LONG))
1:eac0369:                 e = StandardException.newException(
1:ce40a31:                     SQLState.BLOB_POSITION_TOO_LARGE, startPos);
3:eac0369:             throw handleMyExceptions(e);
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369: 			throw handleMyExceptions(t);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (pushStack)
1:eac0369:                 restoreContextStack();
1:eac0369:         }
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:4153b27:   /**
1:eac0369:    * Retrieves the <code>BLOB</code> designated by this
1:eac0369:    * <code>Blob</code> instance as a stream.
1:eac0369:    * @return a stream containing the <code>BLOB</code> data
1:eac0369:    * @exception SQLException if there is an error accessing the
1:eac0369:    * <code>BLOB</code>
1:eac0369:    */
1:eac0369:     public java.io.InputStream getBinaryStream()
1:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328:         
1:eac0369:         boolean pushStack = false;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // if we have byte array, not a stream
1:b2b30ec:             if (materialized)
1:eac0369:             {
1:3a6f4cf:                 java.io.InputStream result = control.getInputStream(0);
1:3a6f4cf:                 return result;
1:eac0369:             }
1:2333262:             else
1:eac0369:             { 
1:eac0369:                 // have a stream
1:eac0369: 
1:eac0369:                 synchronized (getConnectionSynchronization())
1:eac0369:                 {
1:3a6f4cf:                     EmbedConnection ec = getEmbedConnection();
1:3a6f4cf:                     pushStack = !ec.isClosed();
1:eac0369:                     if (pushStack)
1:eac0369:                         setupContextStack();
1:eac0369: 
1:846a533:                     // Reset stream, because AutoPositionigStream wants to read
1:846a533:                     // the encoded length bytes.
1:846a533:                     myStream.resetStream();
1:3a6f4cf:                     UpdatableBlobStream result = new UpdatableBlobStream(
1:3a6f4cf:                         this,
1:3a6f4cf:                         new AutoPositioningStream (this, myStream, this));
1:3a6f4cf: 
1:3a6f4cf:                     restoreIntrFlagIfSeen(pushStack, ec);
1:3a6f4cf: 
1:3a6f4cf:                     return result;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369: 			throw handleMyExceptions(t);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (pushStack)
1:eac0369:                 restoreContextStack();
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 
5:eac0369:   /**
1:eac0369:    * Determines the byte position at which the specified byte
1:eac0369:    * <code>pattern</code> begins within the <code>BLOB</code>
1:eac0369:    * value that this <code>Blob</code> object represents.  The
1:dbed020:    * search for <code>pattern</code>. begins at position
1:eac0369:    * <code>start</code>
1:eac0369:    * @param pattern the byte array for which to search
1:eac0369:    * @param start the position at which to begin searching; the
1:eac0369:    *        first position is 1
1:eac0369:    * @return the position at which the pattern appears, else -1.
1:eac0369:    * @exception SQLException if there is an error accessing the
1:eac0369:    * <code>BLOB</code>
1:eac0369:    */
1:eac0369:     public long position(byte[] pattern, long start)
1:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328:         
1:eac0369:         boolean pushStack = false;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (start < 1)
1:eac0369:                 throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_BAD_POSITION, start);
1:eac0369:             if (pattern == null)
1:e6936ea:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
1:eac0369:             if (pattern.length == 0)
1:eac0369:                 return start; // match DB2's SQL LOCATE function
1:3a6f4cf: 
1:eac0369:             synchronized (getConnectionSynchronization())
1:eac0369:             {
1:3a6f4cf:                 EmbedConnection ec = getEmbedConnection();
1:3a6f4cf: 
1:3a6f4cf:                 pushStack = !ec.isClosed();
1:eac0369:                 if (pushStack)
1:eac0369:                     setupContextStack();
1:eac0369: 
1:cd7ef76:                 long pos = setBlobPosition(start -1);
1:eac0369:                 // look for first character
1:eac0369:                 int lookFor = pattern[0];
1:eac0369:                 long curPos;
1:eac0369:                 int c;
1:eac0369:                 while (true)
1:eac0369:                 {
1:cd7ef76:                     c = read(pos++); // Note the position increment.
1:3a6f4cf:                     if (c == -1) { // run out of stream
1:3a6f4cf:                         restoreIntrFlagIfSeen(pushStack, ec);
1:cd7ef76:                         return -1;
1:3a6f4cf:                     }
1:eac0369:                     if (c == lookFor)
1:eac0369:                     {
1:eac0369:                         curPos = pos;
1:3a6f4cf:                         if (checkMatch(pattern, pos)) {
1:3a6f4cf:                             restoreIntrFlagIfSeen(pushStack, ec);
1:eac0369:                             return curPos;
1:3a6f4cf:                         } else
1:cd7ef76:                             pos = setBlobPosition(curPos);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:cd7ef76:         catch (StandardException e) {
1:cd7ef76:             throw handleMyExceptions(e);
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369: 			throw handleMyExceptions(t);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (pushStack)
1:eac0369:                 restoreContextStack();
1:eac0369:         }
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:cd7ef76:      * Checks if the pattern (starting from the second byte) appears inside
1:cd7ef76:      * the Blob content.
1:cd7ef76:      * <p>
1:cd7ef76:      * At this point, the first byte of the pattern must already have been
1:cd7ef76:      * matched, and {@code pos} must be pointing at the second byte to compare.
1:cd7ef76:      *
1:cd7ef76:      * @param pattern the byte array to search for, passed in by the user
1:cd7ef76:      * @param pos the position in the Blob content to start searching from
1:cd7ef76:      * @return {@code true} if a match is found, {@code false} if not.
1:eac0369:      */
1:cd7ef76:     private boolean checkMatch(byte[] pattern, long pos)
1:cd7ef76:             throws IOException, StandardException {
1:eac0369:        // check whether rest matches
1:eac0369:        // might improve performance by reading more
1:eac0369:         for (int i = 1; i < pattern.length; i++)
1:eac0369:         {
1:cd7ef76:             int b = read(pos++);
1:eac0369:             if ((b < 0) || (b != pattern[i]))  // mismatch or stream runs out
1:eac0369:                 return false;
1:eac0369:         }
1:eac0369:         return true;
1:eac0369:     }
1:eac0369: 
1:eac0369:   /**
1:eac0369:    * Determines the byte position in the <code>BLOB</code> value
1:eac0369:    * designated by this <code>Blob</code> object at which
1:eac0369:    * <code>pattern</code> begins.  The search begins at position
1:eac0369:    * <code>start</code>.
1:eac0369:    * @param pattern the <code>Blob</code> object designating
1:eac0369:    * the <code>BLOB</code> value for which to search
1:eac0369:    * @param start the position in the <code>BLOB</code> value
1:eac0369:    *        at which to begin searching; the first position is 1
1:eac0369:    * @return the position at which the pattern begins, else -1
1:eac0369:    * @exception SQLException if there is an error accessing the
1:eac0369:    * <code>BLOB</code>
1:eac0369:    */
1:eac0369:     public long position(Blob pattern, long start)
1:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Blob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328:         
1:eac0369:         boolean pushStack = false;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (start < 1)
1:eac0369:                 throw StandardException.newException(
1:ce40a31:                     SQLState.BLOB_BAD_POSITION, start);
1:eac0369:             if (pattern == null)
1:e6936ea:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
1:eac0369: 
1:eac0369:             synchronized (getConnectionSynchronization())
1:eac0369:             {
1:3a6f4cf:                 EmbedConnection ec = getEmbedConnection();
1:eac0369: 
1:3a6f4cf:                 pushStack = !ec.isClosed();
1:eac0369:                 if (pushStack)
1:eac0369:                     setupContextStack();
1:eac0369: 
1:cd7ef76:                 long pos = setBlobPosition(start-1);
1:eac0369:                 // look for first character
1:eac0369:                 byte[] b;
1:eac0369:                 try
1:94f158a:                 { // pattern is not necessarily a Derby Blob
1:eac0369:                     b = pattern.getBytes(1,1);
1:eac0369:                 }
1:eac0369:                 catch (SQLException e)
1:eac0369:                 {
1:eac0369:                     throw StandardException.newException(SQLState.BLOB_UNABLE_TO_READ_PATTERN);
1:eac0369:                 }
1:3a6f4cf:                 if (b == null || b.length < 1) { // the 'empty' blob
1:3a6f4cf:                     restoreIntrFlagIfSeen(pushStack, ec);
1:eac0369:                     return start; // match DB2's SQL LOCATE function
1:3a6f4cf:                 }
1:eac0369:                 int lookFor = b[0];
1:eac0369:                 int c;
1:eac0369:                 long curPos;
1:eac0369:                 while (true)
1:eac0369:                 {
1:cd7ef76:                     c = read(pos++); // Note the position increment.
1:3a6f4cf:                     if (c == -1) {  // run out of stream
1:3a6f4cf:                         restoreIntrFlagIfSeen(pushStack, ec);
5:eac0369:                         return -1;
1:3a6f4cf:                     }
1:eac0369:                     if (c == lookFor)
1:eac0369:                     {
1:eac0369:                         curPos = pos;
1:3a6f4cf:                         if (checkMatch(pattern, pos)) {
1:3a6f4cf:                             restoreIntrFlagIfSeen(pushStack, ec);
1:eac0369:                             return curPos;
1:3a6f4cf:                         } else
1:cd7ef76:                             pos = setBlobPosition(curPos);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:cd7ef76:         catch (StandardException e) {
1:cd7ef76:             throw handleMyExceptions(e);
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369: 			throw handleMyExceptions(t);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (pushStack)
1:eac0369:                 restoreContextStack();
1:eac0369:         }
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:cd7ef76:      * Checks if the pattern (starting from the second byte) appears inside
1:cd7ef76:      * the Blob content.
1:cd7ef76:      *
1:cd7ef76:      * @param pattern the Blob to search for, passed in by the user
1:cd7ef76:      * @param pos the position in the Blob (this) content to start searching
1:cd7ef76:      * @return {@code true} if a match is found, {@code false} if not.
1:eac0369:      */
1:cd7ef76:     private boolean checkMatch(Blob pattern, long pos)
1:cd7ef76:             throws IOException, StandardException {
1:eac0369:         // check whether rest matches
1:eac0369:         // might improve performance by reading buffer at a time
1:eac0369:         InputStream pStream;
1:eac0369:         try
1:eac0369:         {
1:eac0369:             pStream = pattern.getBinaryStream();
1:eac0369:         }
1:eac0369:         catch (SQLException e)
1:eac0369:         {
1:eac0369:             return false;
1:eac0369:         }
1:eac0369:         if (pStream == null)
1:eac0369:             return false;
1:eac0369:         // throw away first character since we already read it in the calling
1:eac0369:         // method
1:eac0369:         int b1 = pStream.read();
1:eac0369:         if (b1 < 0)
1:eac0369:             return false;
1:eac0369:         while (true)
1:eac0369:         {
1:eac0369:             b1 = pStream.read();
1:eac0369:             if (b1 < 0)  // search blob runs out
1:eac0369:                 return true;
1:cd7ef76:             int b2 = read(pos++);
1:eac0369:             if ((b1 != b2) || (b2 < 0))  // mismatch or stream runs out
1:eac0369:                 return false;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /*
1:eac0369:       Convert exceptions where needed before calling handleException to convert
1:eac0369:       them to SQLExceptions.
1:eac0369:     */
1:eac0369: 	private SQLException handleMyExceptions(Throwable t)
1:eac0369:         throws SQLException
1:eac0369:     {
1:eac0369:         if (t instanceof StandardException)
1:eac0369:         {
1:eac0369:             // container closed means the blob or clob was accessed after commit
1:eac0369:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
1:eac0369:             {
1:eac0369:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         return handleException(t);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:    /*
1:eac0369:     If we have a stream, release the resources associated with it.
1:eac0369:     */
1:eac0369:     protected void finalize()
1:eac0369:     {
1:b2b30ec:         if (!materialized)
1:846a533:             myStream.closeStream();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     Following methods are for the new JDBC 3.0 methods in java.sql.Blob
1:eac0369:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
1:eac0369:     package, so we don't have to have a new class in Local30.
1:eac0369:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
1:eac0369:     so this will work fine in jdbc2.0 configuration.
1:eac0369: 	*/
1:eac0369: 
1:fcf7ef3: 	/////////////////////////////////////////////////////////////////////////
1:fcf7ef3: 	//
1:eac0369: 	//	JDBC 3.0	-	New public methods
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////////
1:fcf7ef3: 
1:eac0369: 	/**
1:0c5c5aa:      * Writes the given array of bytes to the BLOB value that this Blob object
1:0c5c5aa:      * represents, starting at position pos, and returns the number of bytes
1:0c5c5aa:      * written.
1:0c5c5aa:      *
1:0c5c5aa:      * @param pos the position in the BLOB object at which to start writing
1:0c5c5aa:      * @param bytes the array of bytes to be written to the BLOB value that this
1:0c5c5aa:      *       Blob object represents
1:0c5c5aa:      * @return The number of bytes written to the BLOB.
1:0c5c5aa:      * @throws SQLException if writing the bytes to the BLOB fails
1:0c5c5aa:      * @since 1.4
1:0c5c5aa: 	 */
1:b2b30ec: 	public int setBytes(long pos, byte[] bytes) throws SQLException {
1:b2b30ec:             return setBytes(pos, bytes, 0, bytes.length);
1:eac0369: 	}
1:eac0369: 
1:0c5c5aa:     /**
1:0c5c5aa:      * Writes all or part of the given array of byte array to the BLOB value
1:0c5c5aa:      * that this Blob object represents and returns the number of bytes written.
1:0c5c5aa:      * Writing starts at position pos in the BLOB value; len bytes from the
1:0c5c5aa:      * given byte array are written.
1:0c5c5aa:      *
1:0c5c5aa:      * @param pos the position in the BLOB object at which to start writing
1:0c5c5aa:      * @param bytes the array of bytes to be written to the BLOB value that this
1:0c5c5aa:      *       Blob object represents
1:0c5c5aa:      * @param offset the offset into the byte array at which to start reading
1:0c5c5aa:      *       the bytes to be written
1:0c5c5aa:      * @param len the number of bytes to be written to the BLOB value from the
1:0c5c5aa:      *       array of bytes bytes
1:0c5c5aa:      * @return The number of bytes written to the BLOB.
1:0c5c5aa:      * @throws SQLException if writing the bytes to the BLOB fails
1:0c5c5aa:      * @throws IndexOutOfBoundsException if {@code len} is larger than
1:0c5c5aa:      *       {@code bytes.length - offset}
1:0c5c5aa:      * @since 1.4
1:0c5c5aa: 	 */
1:b2b30ec:     public int setBytes(long pos,
1:b2b30ec:             byte[] bytes,
1:b2b30ec:             int offset,
1:b2b30ec:             int len) throws SQLException {
1:b2b30ec:         checkValidity();
1:2d3a136: 
1:2d3a136:         if (pos - 1 > length())
1:2d3a136:             throw Util.generateCsSQLException(SQLState.BLOB_POSITION_TOO_LARGE,
1:ce40a31:                     pos);
1:2d3a136:         if (pos < 1)
1:2d3a136:             throw Util.generateCsSQLException(SQLState.BLOB_BAD_POSITION,
1:ce40a31:                     pos);
1:2d3a136:         
1:2d3a136:         if ((offset < 0) || offset > bytes.length) {
1:2d3a136:             throw Util.generateCsSQLException(SQLState.BLOB_INVALID_OFFSET,
1:ce40a31:                     offset);
1:2d3a136:         }
1:2d3a136:         if (len < 0) {
1:2d3a136:             throw Util.generateCsSQLException(SQLState.BLOB_NONPOSITIVE_LENGTH,
1:ce40a31:                     len);
1:2d3a136:         }
1:2d3a136:         if (len == 0) {
1:2d3a136:             return 0;
1:2d3a136:         }
1:24400cd:         if (len > bytes.length - offset) {
1:2d3a136:             throw Util.generateCsSQLException(SQLState.BLOB_LENGTH_TOO_LONG,
1:ce40a31:                     len);
1:2d3a136:         }
1:2d3a136: 
1:b2b30ec:         try {
1:b2b30ec:             if (materialized) {
1:2d3a136:                 control.write(bytes, offset, len, pos - 1);
1:2d3a136:             } else {
1:2d3a136:                 control = new LOBStreamControl(getEmbedConnection());
1:2d3a136:                 control.copyData(myStream, length());
1:0c5c5aa:                 control.write(bytes, offset, len, pos - 1);
1:b2b30ec:                 myStream.close();
1:b526e7f:                 streamLength = -1;
1:b2b30ec:                 materialized = true;
1:eac0369:             }
1:b2b30ec:             return len;
1:2d3a136:         } catch (IOException e) {
1:2d3a136:             throw Util.setStreamFailure(e);
1:2d3a136:         } catch (StandardException se) {
1:2d3a136:             throw Util.generateCsSQLException(se);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:    /**
3:eac0369:     * JDBC 3.0
5:eac0369:     *
1:eac0369:     * Retrieves a stream that can be used to write to the BLOB value that this
1:eac0369:     * Blob object represents. The stream begins at position pos. 
1:eac0369:     *
3:eac0369:     * @param pos - the position in the BLOB object at which to start writing
1:eac0369:     * @return a java.io.OutputStream object to which data can be written 
3:eac0369:     * @exception SQLException Feature not implemented for now.
1:eac0369: 	*/
1:b2b30ec: 	public java.io.OutputStream setBinaryStream (long pos)
1:b2b30ec:                                     throws SQLException {
1:b2b30ec:             checkValidity ();
1:b2b30ec:             if (pos - 1 > length())
1:b2b30ec:                 throw Util.generateCsSQLException(
1:ce40a31:                     SQLState.BLOB_POSITION_TOO_LARGE, pos);
1:b2b30ec:             if (pos < 1)
1:b2b30ec:                 throw Util.generateCsSQLException(
1:ce40a31:                     SQLState.BLOB_BAD_POSITION, pos);
1:b2b30ec:             try {
1:b2b30ec:                 if (materialized) {
1:b2b30ec:                     return control.getOutputStream (pos - 1);
1:b2b30ec:                 }
1:b2b30ec:                 else {
1:b2b30ec:                     control = new LOBStreamControl (
1:10e4538:                                             getEmbedConnection());
1:b2b30ec:                     control.copyData (myStream, pos - 1);
1:b2b30ec:                     myStream.close ();
1:b526e7f:                     streamLength = -1;
1:b2b30ec:                     materialized = true;
1:b2b30ec:                     return control.getOutputStream(pos - 1);
1:125c328: 
1:b2b30ec:                 }
1:b2b30ec:             }
1:b2b30ec:             catch (IOException e) {
1:b2b30ec:                 throw Util.setStreamFailure (e);
1:b2b30ec:             }
1:2333262:             catch (StandardException se) {
1:2333262:                 throw Util.generateCsSQLException (se);
1:b2b30ec:             }
1:b2b30ec: 	}
1:b2b30ec: 
1:b2b30ec: 	/**
1:eac0369:     * JDBC 3.0
1:eac0369:     *
1:eac0369:     * Truncates the BLOB value that this Blob object represents to be len bytes
1:eac0369:     * in length.
1:eac0369:     *
1:eac0369:     * @param len - the length, in bytes, to which the BLOB value that this Blob
1:eac0369:     * object represents should be truncated
1:eac0369:     * @exception SQLException Feature not implemented for now.
1:eac0369: 	*/
1:eac0369: 	public void truncate(long len)
1:2333262:                                         throws SQLException
1:eac0369: 	{
1:b2b30ec:             if (len > length())
1:b2b30ec:                 throw Util.generateCsSQLException(
1:ce40a31:                     SQLState.BLOB_LENGTH_TOO_LONG, len);
1:b2b30ec:             try {
1:b2b30ec:                 if (materialized) {
1:b2b30ec:                     control.truncate (len);
1:b2b30ec:                 }
1:b2b30ec:                 else {
1:995d374:                     setBlobPosition(0); // copy from the beginning
1:10e4538:                     control = new LOBStreamControl (getEmbedConnection());
1:b2b30ec:                     control.copyData (myStream, len);
1:b2b30ec:                     myStream.close();
1:b526e7f:                     streamLength = -1;
1:b2b30ec:                     materialized = true;
1:b2b30ec:                 }
1:b2b30ec:             }
1:b2b30ec:             catch (IOException e) {
1:b2b30ec:                 throw Util.setStreamFailure (e);
1:b2b30ec:             }
1:2333262:             catch (StandardException se) {
1:2333262:                 throw Util.generateCsSQLException (se);
1:b2b30ec:             }
1:b2b30ec: 	}
1:eac0369: 
1:eac0369:     /////////////////////////////////////////////////////////////////////////
1:eac0369:     //
1:fcf7ef3:     //	JDBC 4.0	-	New public methods
1:fcf7ef3:     //
1:fcf7ef3:     /////////////////////////////////////////////////////////////////////////
1:125c328:     /**
1:125c328:      * This method frees the <code>Blob</code> object and releases the resources that 
1:125c328:      * it holds. The object is invalid once the <code>free</code>
1:125c328:      * method is called. If <code>free</code> is called multiple times, the subsequent
1:125c328:      * calls to <code>free</code> are treated as a no-op.
1:125c328:      * 
1:125c328:      * @throws SQLException if an error occurs releasing
1:125c328:      * the Blob's resources
1:125c328:      */
1:fcf7ef3:     public void free()
1:fcf7ef3:         throws SQLException {
1:125c328:         //calling free() on a already freed object is treated as a no-op
1:125c328:         if (!isValid) return;
1:125c328:         
1:125c328:         //now that free has been called the Blob object is no longer
1:125c328:         //valid
1:125c328:         isValid = false;
1:125c328:         
1:b526e7f:         // Remove entry from connection if a locator has been created.
1:b526e7f:         if (this.locator != 0) {
1:b526e7f:             localConn.removeLOBMapping(locator);
1:fcf7ef3:         }
1:125c328:         //initialialize length to default value -1
1:b526e7f:         streamLength = -1;
1:125c328:         
1:125c328:         //if it is a stream then close it.
1:125c328:         //if a array of bytes then initialize it to null
1:125c328:         //to free up space
1:846a533:         if (!materialized) {
1:846a533:             myStream.closeStream();
1:846a533:             myStream = null;
1:846a533:         } else {
1:b2b30ec:             try {
1:b2b30ec:                 control.free ();
1:b2b30ec:                 control = null;
1:b526e7f:             }
1:b2b30ec:             catch (IOException e) {
1:b2b30ec:                 throw Util.setStreamFailure (e);
1:b2b30ec:             }
1:b2b30ec:         }
1:b2b30ec:     }
1:fcf7ef3:     
1:fcf7ef3:     /**
1:fcf7ef3:      * Returns an <code>InputStream</code> object that contains a partial 
1:fcf7ef3:      * <code>Blob</code> value, starting with the byte specified by pos, 
1:fcf7ef3:      * which is length bytes in length.
1:fcf7ef3:      *
1:fcf7ef3:      * @param pos the offset to the first byte of the partial value to be 
1:fcf7ef3:      *      retrieved. The first byte in the <code>Blob</code> is at 
1:fcf7ef3:      *      position 1
1:fcf7ef3:      * @param length the length in bytes of the partial value to be retrieved
1:fcf7ef3:      * @return through which the partial <code>Blob</code> value can be read. 
1:fcf7ef3:      * @throws SQLException if pos is less than 1 or if pos is greater than 
1:418a799:      *      the number of bytes in the {@code Blob} or if {@code pos + length}
1:418a799:      *      is greater than {@code Blob.length() +1}
1:fcf7ef3:      */
1:fcf7ef3:     public InputStream getBinaryStream(long pos, long length)
1:fcf7ef3:         throws SQLException {
1:78afc5b:         //call checkValidity to exit by throwing a SQLException if
1:78afc5b:         //the Blob object has been freed by calling free() on it
1:78afc5b:         checkValidity();
1:78afc5b:         
1:78afc5b:         if (pos <= 0) {
1:b2b30ec:             throw Util.generateCsSQLException(
1:78afc5b:                     SQLState.BLOB_BAD_POSITION,
1:ce40a31:                     pos);
1:fcf7ef3:         }
1:78afc5b:         if (length < 0) {
1:b2b30ec:             throw Util.generateCsSQLException(
1:78afc5b:                     SQLState.BLOB_NONPOSITIVE_LENGTH,
1:ce40a31:                     length);
1:78afc5b:         }
1:aeb4325:         if (length > (this.length() - (pos -1))) {
3:78afc5b:             throw Util.generateCsSQLException(
1:78afc5b:                     SQLState.POS_AND_LENGTH_GREATER_THAN_LOB,
1:ce40a31:                     pos, length);
1:78afc5b:         }
1:78afc5b:         
1:b2b30ec:         try {
1:a535ea9:             return new UpdatableBlobStream(this,
1:cd727e7:                                             getBinaryStream(),
1:cd727e7:                                             pos-1,
1:cd727e7:                                             length);
1:cd727e7:         } catch (IOException ioe) {
1:cd727e7:             throw Util.setStreamFailure(ioe);
1:cd727e7:         }
1:78afc5b:     }
1:eac0369:     
1:125c328:     /*
1:125c328:      * Checks is isValid is true. If it is not true throws 
1:125c328:      * a SQLException stating that a method has been called on
1:125c328:      * an invalid LOB object
1:125c328:      *
1:125c328:      * throws SQLException if isvalid is not true.
1:125c328:      */
1:125c328:     private void checkValidity() throws SQLException{
1:126b96c:         //check for connection to maintain sqlcode for closed
1:126b96c:         //connection
1:126b96c:         getEmbedConnection().checkIfClosed();
1:125c328:         if(!isValid)
1:125c328:             throw newSQLException(SQLState.LOB_OBJECT_INVALID);
1:125c328:     }
1:3d7af4e:     
1:3d7af4e:     /**
1:3d7af4e:      * Returns if blob data is stored locally (using LOBStreamControl).
1:3d7af4e:      * @return true if materialized else false
1:3d7af4e:      */
1:3d7af4e:     boolean isMaterialized () {
1:3d7af4e:         return materialized;
1:3d7af4e:     }
1:456b8a1: 
1:b2b30ec:     /**
1:456b8a1:      * Return locator for this lob.
1:456b8a1:      * 
1:8bc0bec:      * @return The locator identifying this lob.
1:456b8a1:      */
1:456b8a1:     public int getLocator() {
1:d96e398:         if (locator == 0) {
1:d96e398:             locator = localConn.addLOBMapping(this);
1:d96e398:         }
1:456b8a1:         return locator;
1:456b8a1:     }
1:74bac8e: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:    * search for <code>pattern</code>. begins at position
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         SQLState.BLOB_POSITION_TOO_LARGE, logicalPos);
/////////////////////////////////////////////////////////////////////////
1:                         logicalPos);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_BAD_POSITION, startPos);
1:                     SQLState.BLOB_NONPOSITIVE_LENGTH, length);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_POSITION_TOO_LARGE, startPos);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_BAD_POSITION, start);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_BAD_POSITION, start);
/////////////////////////////////////////////////////////////////////////
1:                     pos);
1:                     pos);
1:                     offset);
1:                     len);
1:                     len);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_POSITION_TOO_LARGE, pos);
1:                     SQLState.BLOB_BAD_POSITION, pos);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_LENGTH_TOO_LONG, len);
/////////////////////////////////////////////////////////////////////////
1:                     pos);
1:                     length);
1:                     pos, length);
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:8846963
/////////////////////////////////////////////////////////////////////////
1:      /**
1:      * This constructor is used to create a empty Blob object. It is used by the
1:      * Connection interface method createBlob().
1:      * 
1:      * @param blobBytes A byte array containing the data to be stores in the 
1:      *        Blob.
1:      *
1:      * @param con The EmbedConnection object associated with this Blob object.
1:      *
1:      */
1:     
0:      EmbedBlob(byte [] blobBytes,EmbedConnection con) {
1:          super(con);
0:          myBytes = blobBytes;
0:          isBytes = true;
0:          myLength = myBytes.length;
1:      }
1:      
commit:125c328
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     //This boolean variable indicates whether the Blob object has
1:     //been invalidated by calling free() on it
1:     private boolean isValid = true;
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This method frees the <code>Blob</code> object and releases the resources that 
1:      * it holds. The object is invalid once the <code>free</code>
1:      * method is called. If <code>free</code> is called multiple times, the subsequent
1:      * calls to <code>free</code> are treated as a no-op.
1:      * 
1:      * @throws SQLException if an error occurs releasing
1:      * the Blob's resources
1:      */
1:         //calling free() on a already freed object is treated as a no-op
1:         if (!isValid) return;
1:         
1:         //now that free has been called the Blob object is no longer
1:         //valid
1:         isValid = false;
1:         
1:         //initialialize length to default value -1
0:         myLength = -1;
1:         
1:         //if it is a stream then close it.
1:         //if a array of bytes then initialize it to null
1:         //to free up space
0:         if (!isBytes)
0:             ((Resetable)myStream).closeStream();
1:         else
0:             myBytes = null;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
1:      * Checks is isValid is true. If it is not true throws 
1:      * a SQLException stating that a method has been called on
1:      * an invalid LOB object
1:      *
1:      * throws SQLException if isvalid is not true.
1:      */
1:     private void checkValidity() throws SQLException{
1:         if(!isValid)
1:             throw newSQLException(SQLState.LOB_OBJECT_INVALID);
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d349a1f
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException, SQLException
/////////////////////////////////////////////////////////////////////////
1:                 throw Util.setStreamFailure(e);
/////////////////////////////////////////////////////////////////////////
1:             throws StandardException, SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 throw Util.setStreamFailure(ioe);
commit:995d374
/////////////////////////////////////////////////////////////////////////
1:                     setBlobPosition(0); // copy from the beginning
commit:24400cd
/////////////////////////////////////////////////////////////////////////
1:         if (len > bytes.length - offset) {
commit:a1c1356
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 streamLength = InputStreamUtil.skipUntilEOF(tmpStream);
1: 
commit:f8cdf65
/////////////////////////////////////////////////////////////////////////
1:      * @return the byte at the current position, or -1 if end of file has been
1:      * reached
commit:d2b4fdb
/////////////////////////////////////////////////////////////////////////
0:              control = new LOBStreamControl (con.getDBName(), blobBytes);
/////////////////////////////////////////////////////////////////////////
1:                 control = new LOBStreamControl (
0:                             getEmbedConnection().getDBName(), dvdBytes);
commit:5d54436
/////////////////////////////////////////////////////////////////////////
0:                  if (sz == -1)
1:                      return new byte [0];
commit:2333262
/////////////////////////////////////////////////////////////////////////
1:          catch (StandardException se) {
1:             throw Util.generateCsSQLException (se);
1:          }
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 if (pos >= control.getLength())
1:                     return -1;
1:                 else
1:                     c = control.read (pos);
1:             }
1:             catch (StandardException se) {
1:                 throw Util.generateCsSQLException (se);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         catch (StandardException se) {
1:             throw Util.generateCsSQLException (se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             catch (StandardException se) {
0:                 throw Util.generateCsSQLException (se);
1:             }
/////////////////////////////////////////////////////////////////////////
1:                                         throws SQLException
/////////////////////////////////////////////////////////////////////////
0:             catch (StandardException se) {
0:                 throw Util.generateCsSQLException (se);
1:             }
commit:2420903
/////////////////////////////////////////////////////////////////////////
0:              control.write (blobBytes, 0, blobBytes.length, 0);
/////////////////////////////////////////////////////////////////////////
0:                 control.write (dvdBytes, 0, dvdBytes.length, pos);
0:                 throw StandardException.newException (
0:                                         SQLState.SET_STREAM_FAILURE, e);
/////////////////////////////////////////////////////////////////////////
1:                  int sz = control.read (result, 0, result.length, startPos - 1);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     SQLState.BLOB_LENGTH_TOO_LONG, new Long(pos));
commit:fcf7ef3
/////////////////////////////////////////////////////////////////////////
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //	JDBC 4.0	-	New public methods
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     public void free()
1:         throws SQLException {
0:         throw Util.notImplemented();
1:     }
1:     
1:     /**
1:      * Returns an <code>InputStream</code> object that contains a partial 
1:      * <code>Blob</code> value, starting with the byte specified by pos, 
1:      * which is length bytes in length.
1:      *
1:      * @param pos the offset to the first byte of the partial value to be 
1:      *      retrieved. The first byte in the <code>Blob</code> is at 
1:      *      position 1
1:      * @param length the length in bytes of the partial value to be retrieved
1:      * @return through which the partial <code>Blob</code> value can be read. 
1:      * @throws SQLException if pos is less than 1 or if pos is greater than 
0:      *      the number of bytes in the <code>Blob</code> or if pos + length is
0:      *      greater than the number of bytes in the <code>Blob</code>
1:      */
1:     public InputStream getBinaryStream(long pos, long length)
1:         throws SQLException {
0:         throw Util.notImplemented();
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:                 EmbedConnection ec = getEmbedConnection();
1:                 pushStack = !ec.isClosed();
/////////////////////////////////////////////////////////////////////////
1: 
1:                 restoreIntrFlagIfSeen(pushStack, ec);
1: 
/////////////////////////////////////////////////////////////////////////
1:                  if (sz == -1) {
1:                      InterruptStatus.restoreIntrFlagIfSeen();
1:                  }
1:                  InterruptStatus.restoreIntrFlagIfSeen();
1:                     EmbedConnection ec = getEmbedConnection();
1:                     pushStack = !ec.isClosed();
/////////////////////////////////////////////////////////////////////////
1: 
1:                         restoreIntrFlagIfSeen(pushStack, ec);
1: 
1: 
1:                     restoreIntrFlagIfSeen(pushStack,ec);
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:                 java.io.InputStream result = control.getInputStream(0);
1:                 return result;
/////////////////////////////////////////////////////////////////////////
1:                     EmbedConnection ec = getEmbedConnection();
1:                     pushStack = !ec.isClosed();
1:                     UpdatableBlobStream result = new UpdatableBlobStream(
1:                         this,
1:                         new AutoPositioningStream (this, myStream, this));
1: 
1:                     restoreIntrFlagIfSeen(pushStack, ec);
1: 
1:                     return result;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 EmbedConnection ec = getEmbedConnection();
1: 
1:                 pushStack = !ec.isClosed();
/////////////////////////////////////////////////////////////////////////
1:                     if (c == -1) { // run out of stream
1:                         restoreIntrFlagIfSeen(pushStack, ec);
1:                     }
1:                         if (checkMatch(pattern, pos)) {
1:                             restoreIntrFlagIfSeen(pushStack, ec);
1:                         } else
/////////////////////////////////////////////////////////////////////////
1: 
1:                 EmbedConnection ec = getEmbedConnection();
1: 
1:                 pushStack = !ec.isClosed();
/////////////////////////////////////////////////////////////////////////
1:                 if (b == null || b.length < 1) { // the 'empty' blob
1:                     restoreIntrFlagIfSeen(pushStack, ec);
1:                 }
1:                     if (c == -1) {  // run out of stream
1:                         restoreIntrFlagIfSeen(pushStack, ec);
1:                     }
1:                         if (checkMatch(pattern, pos)) {
1:                             restoreIntrFlagIfSeen(pushStack, ec);
1:                         } else
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2d3a136
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (pos - 1 > length())
1:             throw Util.generateCsSQLException(SQLState.BLOB_POSITION_TOO_LARGE,
0:                     new Long(pos));
1:         if (pos < 1)
1:             throw Util.generateCsSQLException(SQLState.BLOB_BAD_POSITION,
0:                     new Long(pos));
1:         
1:         if ((offset < 0) || offset > bytes.length) {
1:             throw Util.generateCsSQLException(SQLState.BLOB_INVALID_OFFSET,
0:                     new Long(offset));
1:         }
1:         if (len < 0) {
1:             throw Util.generateCsSQLException(SQLState.BLOB_NONPOSITIVE_LENGTH,
0:                     new Long(len));
1:         }
1:         if (len == 0) {
1:             return 0;
1:         }
0:         if (len + offset > bytes.length) {
1:             throw Util.generateCsSQLException(SQLState.BLOB_LENGTH_TOO_LONG,
0:                     new Long(len));
1:         }
1: 
1:                 control.write(bytes, offset, len, pos - 1);
1:             } else {
1:                 control = new LOBStreamControl(getEmbedConnection());
1:                 control.copyData(myStream, length());
1:         } catch (IOException e) {
1:             throw Util.setStreamFailure(e);
1:         } catch (StandardException se) {
1:             throw Util.generateCsSQLException(se);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:         if (dvd.hasStream()) { // Cases b) and c)
1:             streamPositionOffset = handleStreamValue(dvd.getStream(), con);
1:         } else { // a) Blob already materialized in memory
/////////////////////////////////////////////////////////////////////////
1:         }
1:         //add entry in connection so it can be cleared 
1:         //when transaction is not valid
1:         con.addLOBReference (this);
1:     }
1: 
1: 
1:     /**
1:      * Constructs a Blob object on top of a stream.
1:      *
1:      * @param dvdStream the source stream
1:      * @param con the connection owning the Blob
1:      * @return The offset into the stream where the user data begins (used if
1:      *      resetting the stream).
1:      * @throws StandardException if accessing the stream fails, or if writing
1:      *      data to temporary storage fails
1:      */
1:     private int handleStreamValue(InputStream dvdStream, EmbedConnection con)
0:             throws StandardException {
1:         int offset = 0;
1:         // b) Resetable stream
1:         //    In this case the stream is coming from the Derby store.
1:         if (dvdStream instanceof Resetable) {
/////////////////////////////////////////////////////////////////////////
1:                 offset = (int)myStream.getPosition();
/////////////////////////////////////////////////////////////////////////
1:         // c) Non-resetable stream
1:         //    This is most likely a stream coming in from the user, and we
1:         //    don't have any guarantees on how it behaves.
1:         } else {
/////////////////////////////////////////////////////////////////////////
1:             offset = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:         return offset;
commit:e093928
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.RawToBinaryFormatStream;
/////////////////////////////////////////////////////////////////////////
1:         /*
1:            We support three scenarios at this point:
1:             a) The Blob value is already represented as bytes in memory.
1:                This is the case for small Blobs (less than 32 KB).
1:             b) The Blob value is represented as a resetable stream.
1:                This is the case for Blobs coming from the store
1:                (note the comment about SQLBit below).
1:             c) The Blob value is represented as a wrapped user stream.
1:                This stream cannot be reset, which means we have to drain the
1:                stream and store it temporarily until it is either discarded or
1:                inserted into the database.
1:          */
0:         if (dvdStream == null) { // a) Blob already materialized in memory
/////////////////////////////////////////////////////////////////////////
0:         } else if (dvdStream instanceof Resetable) { // b) Resetable stream
/////////////////////////////////////////////////////////////////////////
0:         } else { // c) Non-resetable stream
1:             // The code below will only work for RawToBinaryFormatStream.
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(
1:                         dvdStream instanceof RawToBinaryFormatStream,
1:                         "Invalid stream type: " + dvdStream.getClass());
1:             }
1:             // The source stream isn't resetable, so we have to write it to a
1:             // temporary location to be able to support the Blob operations.
1:             materialized = true;
1:             streamPositionOffset = Integer.MIN_VALUE;
1:             try {
1:                 control = new LOBStreamControl(getEmbedConnection());
1:                 BinaryToRawStream tmpStream =
1:                         new BinaryToRawStream(dvdStream, con);
1:                 // Transfer the data.
1:                 byte[] bytes = new byte[4096]; // 4 KB buffer
1:                 long pos = 0;
1:                 while (true) {
1:                     int read = tmpStream.read(bytes, 0, bytes.length);
1:                     if (read < 1) {
1:                         // Reached EOF, or stream is behaving badly.
1:                         break;
1:                     }
1:                     // If the stream is larger than the maximum allowed by
1:                     // Derby, the call below will thrown an exception.
1:                     pos = control.write(bytes, 0, read, pos);
1:                 }
1:                 tmpStream.close();
1:             } catch (IOException ioe) {
0:                 throw StandardException.newException (
0:                                         SQLState.SET_STREAM_FAILURE, ioe);
1:             }
commit:418a799
/////////////////////////////////////////////////////////////////////////
1:      *      the number of bytes in the {@code Blob} or if {@code pos + length}
1:      *      is greater than {@code Blob.length() +1}
commit:aeb4325
/////////////////////////////////////////////////////////////////////////
1:         if (length > (this.length() - (pos -1))) {
commit:dd2650f
/////////////////////////////////////////////////////////////////////////
1:                 myStream = new PositionedStoreStream(dvdStream);
/////////////////////////////////////////////////////////////////////////
1:             } catch (StandardException se) {
1:                 if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:                     throw StandardException
1:                             .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:                 } else {
1:                     throw se;
1:                 }
1:                      SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe, "BLOB");
commit:0c5c5aa
/////////////////////////////////////////////////////////////////////////
1:      * Writes the given array of bytes to the BLOB value that this Blob object
1:      * represents, starting at position pos, and returns the number of bytes
1:      * written.
1:      *
1:      * @param pos the position in the BLOB object at which to start writing
1:      * @param bytes the array of bytes to be written to the BLOB value that this
1:      *       Blob object represents
1:      * @return The number of bytes written to the BLOB.
1:      * @throws SQLException if writing the bytes to the BLOB fails
1:      * @since 1.4
1: 	 */
1:     /**
1:      * Writes all or part of the given array of byte array to the BLOB value
1:      * that this Blob object represents and returns the number of bytes written.
1:      * Writing starts at position pos in the BLOB value; len bytes from the
1:      * given byte array are written.
1:      *
1:      * @param pos the position in the BLOB object at which to start writing
1:      * @param bytes the array of bytes to be written to the BLOB value that this
1:      *       Blob object represents
1:      * @param offset the offset into the byte array at which to start reading
1:      *       the bytes to be written
1:      * @param len the number of bytes to be written to the BLOB value from the
1:      *       array of bytes bytes
1:      * @return The number of bytes written to the BLOB.
1:      * @throws SQLException if writing the bytes to the BLOB fails
1:      * @throws IndexOutOfBoundsException if {@code len} is larger than
1:      *       {@code bytes.length - offset}
1:      * @since 1.4
1: 	 */
/////////////////////////////////////////////////////////////////////////
0:                 control.write (bytes, offset, len, pos - 1);
1:                 control.write(bytes, offset, len, pos - 1);
commit:cd7ef76
/////////////////////////////////////////////////////////////////////////
1: import java.io.EOFException;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Position offset for the stream representing the Blob, if any.
1:      * <p>
1:      * This offset accounts for the bytes encoding the stream length at the
1:      * head of the stream. Data byte {@code pos} is at
1:      * {@code pos + streamPositionOffset} in the underlying stream.
1:      * Set to {@code Integer.MIN_VALUE} if the Blob isn't represented by a
1:      * store stream.
1:      */
1:     private final int streamPositionOffset;
/////////////////////////////////////////////////////////////////////////
1:              streamPositionOffset = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
0:             streamPositionOffset = Integer.MIN_VALUE;
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 // The BinaryToRawStream will read the encoded length bytes.
1:                 BinaryToRawStream tmpStream =
1:                         new BinaryToRawStream(myStream, con);
0:                 streamPositionOffset = (int)myStream.getPosition();
1:                 // Check up front if the stream length is specified.
1:                 streamLength = tmpStream.getLength();
1:                 tmpStream.close();
1:             } catch (IOException ioe) {
1:                 throw StandardException.newException(
0:                         SQLState.LANG_STREAMING_COLUMN_I_O_EXCEPTION, ioe);
1:             }
1:     /**
1:      * Sets the position of the Blob to {@code logicalPos}, where position 0 is
1:      * the beginning of the Blob content.
1:      * <p>
1:      * The position is only guaranteed to be valid from the time this method is
1:      * invoked until the synchronization monitor is released, or until the next
1:      * invokation of this method.
1:      * <p>
1:      * The position is logical in the sense that it specifies the requested
1:      * position in the Blob content. This position might be at a different
1:      * position in the underlying representation, for instance the Derby store
1:      * stream prepends the Blob content with a length field.
1:      *
1:      * @param logicalPos requested Blob position, 0-based
1:      * @return The new position, which will be equal to the requested position.
1:      * @throws IOException if reading/accessing the Blob fails
1:      * @throws StandardException throws BLOB_POSITION_TOO_LARGE if the requested
1:      *      position is larger than the Blob length, throws other SQL states if
1:      *      resetting the stream fails
1:      */
1:     //@GuardedBy(getConnectionSynchronization())
1:     private long setBlobPosition(long logicalPos)
1:             SanityManager.ASSERT(logicalPos >= 0);
1:         if (materialized) {
1:             // Nothing to do here, except checking if the position is valid.
1:             if (logicalPos >= control.getLength()) {
1:                 throw StandardException.newException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(logicalPos));
1:             }
1:         } else {
1:             // Reposition the store stream, account for the length field offset.
1:             try {
1:                 this.myStream.reposition(
1:                         logicalPos + this.streamPositionOffset);
1:             } catch (EOFException eofe) {
1:                 throw StandardException.newException(
1:                         SQLState.BLOB_POSITION_TOO_LARGE, eofe,
0:                         new Long(logicalPos));
1:         return logicalPos;
/////////////////////////////////////////////////////////////////////////
1:     private int read(long pos)
1:             throws IOException, StandardException {
1:         if (materialized) {
0:             if (pos >= control.getLength())
1:                 return -1;
0:             else
0:                 c = control.read (pos);
1:         } else {
1:             // Make sure we're at the right position.
1:             this.myStream.reposition(pos + this.streamPositionOffset);
1:             // Read one byte from the stream.
1:             c = this.myStream.read();
/////////////////////////////////////////////////////////////////////////
1:                 // We have to read the entire stream!
1:                 myStream.resetStream();
1:                 BinaryToRawStream tmpStream =
1:                         new BinaryToRawStream(myStream, this);
0:                 streamLength = 0;
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.ASSERT(tmpStream.getLength() == -1);
1: 
0:                     long skipped = tmpStream.skip(Limits.DB2_LOB_MAXWIDTH);
0:                     streamLength += skipped;
0:                         if (tmpStream.read() == -1) {
0:                             streamLength++;
1:                 tmpStream.close();
1:                 return streamLength;
/////////////////////////////////////////////////////////////////////////
1:                     setBlobPosition(startPos-1);
1:                     int n = InputStreamUtil.readLoop(myStream,result,0,length);
/////////////////////////////////////////////////////////////////////////
1:                 long pos = setBlobPosition(start -1);
1:                     c = read(pos++); // Note the position increment.
0:                         if (checkMatch(pattern, pos))
1:                             pos = setBlobPosition(curPos);
1:         catch (StandardException e) {
1:             throw handleMyExceptions(e);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks if the pattern (starting from the second byte) appears inside
1:      * the Blob content.
1:      * <p>
1:      * At this point, the first byte of the pattern must already have been
1:      * matched, and {@code pos} must be pointing at the second byte to compare.
1:      *
1:      * @param pattern the byte array to search for, passed in by the user
1:      * @param pos the position in the Blob content to start searching from
1:      * @return {@code true} if a match is found, {@code false} if not.
1:     private boolean checkMatch(byte[] pattern, long pos)
1:             throws IOException, StandardException {
1:             int b = read(pos++);
/////////////////////////////////////////////////////////////////////////
1:                 long pos = setBlobPosition(start-1);
/////////////////////////////////////////////////////////////////////////
1:                     c = read(pos++); // Note the position increment.
0:                         if (checkMatch(pattern, pos))
1:                             pos = setBlobPosition(curPos);
1:         catch (StandardException e) {
1:             throw handleMyExceptions(e);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Checks if the pattern (starting from the second byte) appears inside
1:      * the Blob content.
1:      *
1:      * @param pattern the Blob to search for, passed in by the user
1:      * @param pos the position in the Blob (this) content to start searching
1:      * @return {@code true} if a match is found, {@code false} if not.
1:     private boolean checkMatch(Blob pattern, long pos)
1:             throws IOException, StandardException {
/////////////////////////////////////////////////////////////////////////
1:             int b2 = read(pos++);
commit:1c589af
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
commit:846a533
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The underlying positionable store stream, if any.
1:      * <p>
1:      * If {@link #materialized} is {@code true}, the stream is {@code null}.
1:      */
1:     private PositionedStoreStream myStream;
/////////////////////////////////////////////////////////////////////////
1:      * Set to -1 when the stream has been {@link #materialized} or
/////////////////////////////////////////////////////////////////////////
0:         InputStream dvdStream = dvd.getStream();
0:         if (dvdStream == null)
/////////////////////////////////////////////////////////////////////////
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(dvdStream instanceof Resetable);
1:             }
1:             // Create a position aware stream on top of dvdStream so we can
1:             // more easily move back and forth in the Blob.
0:             myStream = new PositionedStoreStream(dvdStream);
0:                 myStream.initStream();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Reads one byte from the Blob at the specified position.
1:      * <p>
1:      * Depending on the representation, this might result in a read from a byte
1:      * array, a temporary file on disk or from a Derby store stream.
1:      *
0:      * @param pos the 0-based position in the Blob to read
0:      * @return The byte at the specified position.
1:      * @throws IOException if reading from the underlying data representation
1:      *      fails
1:      */
/////////////////////////////////////////////////////////////////////////
1:                     // Reset stream, because AutoPositionigStream wants to read
1:                     // the encoded length bytes.
1:                     myStream.resetStream();
/////////////////////////////////////////////////////////////////////////
1:             myStream.closeStream();
/////////////////////////////////////////////////////////////////////////
0:                     SQLState.BLOB_LENGTH_TOO_LONG, new Long(len));
/////////////////////////////////////////////////////////////////////////
1:         if (!materialized) {
1:             myStream.closeStream();
1:             myStream = null;
1:         } else {
commit:b526e7f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tells whether the Blob has been materialized or not.
1:      * <p>
1:      * Materialization happens when the Blob is updated by the user. A
1:      * materialized Blob is represented either in memory or in a temporary file
1:      * on disk, depending on size.
1:      * <p>
1:      * A Blob that has not been materialized is represented by a stream into the
1:      * Derby store, and is read-only.
1:      */
1:     /**
1:      * Locator value for this Blob, used as a handle by the client driver to
1:      * map operations to the correct Blob on the server side.
1:      *
1:      * @see #getLocator()
1:     private int locator = 0;
1:     
1:     /**
1:      * Length of the stream representing the Blob.
1:      * <p>
0:      * Set to -1 when the stream has been materialized {@link #materialized} or
1:      * the length of the stream is not currently known.
1:      */
1:     private long streamLength = -1;
/////////////////////////////////////////////////////////////////////////
0:                 } else {
0:                     throw se;
/////////////////////////////////////////////////////////////////////////
1:         if (streamLength != -1)
1:             return streamLength;
/////////////////////////////////////////////////////////////////////////
0:                 if ((streamLength = biStream.getLength()) != -1) {
0:                    return streamLength;
/////////////////////////////////////////////////////////////////////////
0:                 streamLength = pos;
/////////////////////////////////////////////////////////////////////////
1:                 streamLength = -1;
/////////////////////////////////////////////////////////////////////////
1:                     streamLength = -1;
/////////////////////////////////////////////////////////////////////////
1:                     streamLength = -1;
/////////////////////////////////////////////////////////////////////////
1:         // Remove entry from connection if a locator has been created.
1:         if (this.locator != 0) {
1:             localConn.removeLOBMapping(locator);
1:         }
1:         streamLength = -1;
commit:37ae69e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0:                     long skipped = biStream.skip(Limits.DB2_LOB_MAXWIDTH);
0:                     if (SanityManager.DEBUG) {
0:                         SanityManager.ASSERT(skipped >= 0);
1:                     }
0:                     pos += skipped;
0:                     // If skip reports zero bytes skipped, verify EOF.
0:                     if (skipped == 0) {
0:                         if (biStream.read() == -1) {
0:                             break; // Exit the loop, no more data.
0:                         } else {
0:                             pos++;
1:                         }
1:                     }
commit:1d6c1a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineLOB;
/////////////////////////////////////////////////////////////////////////
1: final class EmbedBlob extends ConnectionChild implements Blob, EngineLOB
commit:8bc0bec
/////////////////////////////////////////////////////////////////////////
1:      * @return The locator identifying this lob.
commit:a535ea9
/////////////////////////////////////////////////////////////////////////
0:                     return new UpdatableBlobStream (this, 
/////////////////////////////////////////////////////////////////////////
1:             return new UpdatableBlobStream(this,
commit:168957e
/////////////////////////////////////////////////////////////////////////
0:             //make myStream a position aware stream
0:             myStream = new PositionedStoreStream (myStream);
/////////////////////////////////////////////////////////////////////////
0:                     ((Resetable)myStream).resetStream();
0:                     return new UpdateableBlobStream (this, 
0:                             new AutoPositioningStream (this, myStream, this));
commit:3d7af4e
/////////////////////////////////////////////////////////////////////////
0:                     return new UpdateableBlobStream (this, biStream);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Returns if blob data is stored locally (using LOBStreamControl).
1:      * @return true if materialized else false
1:      */
1:     boolean isMaterialized () {
1:         return materialized;
1:     }
commit:b2b30ec
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
0:     // blob is either materialized or still in stream
1:     private boolean         materialized;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private LOBStreamControl control;
1: 
/////////////////////////////////////////////////////////////////////////
1:      EmbedBlob(byte [] blobBytes,EmbedConnection con) throws SQLException {
1:         super(con);
1:          try {
0:              control = new LOBStreamControl (con.getDBName());
0:              control.write (blobBytes, 0);
1:              materialized = true;
1:          }
1:          catch (IOException e) {
1:              throw Util.setStreamFailure (e);
1:          }
/////////////////////////////////////////////////////////////////////////
1:             materialized = true;
0:             control = new LOBStreamControl (getEmbedConnection().getDBName());
1:             try {
0:                 control.write (dvdBytes, pos);
1:             }
0:             catch (SQLException e) {
0:                 throw StandardException.newException (e.getSQLState());
1:             }
1:             catch (IOException e) {
0:                 throw StandardException.newException (null, e);
1:             }
1:             materialized = false;
/////////////////////////////////////////////////////////////////////////
1:         if (materialized)
1:         else {
/////////////////////////////////////////////////////////////////////////
0:     private int read() throws IOException, SQLException {
1:         if (materialized)
0:             if (pos >= control.getLength())
0:                 c = control.read (pos);
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             if (materialized)
1:                 return control.getLength ();
1:         }
1:         catch (IOException e) {
1:             throw Util.setStreamFailure (e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             // if the blob is materialized
1:             if (materialized) {
1:                  result = new byte [length];
0:                  int sz = control.read (result, startPos - 1);
1:                  if (sz < length) {
1:                      byte [] tmparray = new byte [sz];
1:                      System.arraycopy (result, 0, tmparray, 0, sz);
1:                      result = tmparray;
1:                  }
/////////////////////////////////////////////////////////////////////////
0:             if (materialized)
0:                 return control.getInputStream(0);
/////////////////////////////////////////////////////////////////////////
0:         throws IOException, SQLException {
/////////////////////////////////////////////////////////////////////////
0:         throws IOException, SQLException
/////////////////////////////////////////////////////////////////////////
1:         if (!materialized)
/////////////////////////////////////////////////////////////////////////
1: 	public int setBytes(long pos, byte[] bytes) throws SQLException {
1:             return setBytes(pos, bytes, 0, bytes.length);
1:    /**
/////////////////////////////////////////////////////////////////////////
1:     public int setBytes(long pos,
1:             byte[] bytes,
1:             int offset,
1:             int len) throws SQLException {
1:         checkValidity();
1:         try {
1:             if (materialized) {
1:                 if (pos - 1 > length())
1:                     throw Util.generateCsSQLException(
0:                             SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
1:                 if (pos < 1)
1:                     throw Util.generateCsSQLException(
0:                         SQLState.BLOB_BAD_POSITION, new Long(pos));
0:                 len = (int) control.write (bytes, offset, len, pos - 1);
1:             }
1:             else {
0:                 control = new LOBStreamControl (getEmbedConnection().getDBName());
0:                 control.copyData (myStream, length());
0:                 len = (int) control.write(bytes, offset, len, pos - 1);
1:                 myStream.close();
1:                 materialized = true;
1:             }
1:             return len;
1:         }
1:         catch (IOException e) {
1:             throw Util.setStreamFailure (e);
1:         }
1:     }
1:    /**
/////////////////////////////////////////////////////////////////////////
1: 	public java.io.OutputStream setBinaryStream (long pos)
1:                                     throws SQLException {
1:             checkValidity ();
0:             if (pos - 1 > length())
1:                 throw Util.generateCsSQLException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0:             if (pos < 1)
1:                 throw Util.generateCsSQLException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(pos));
1:             try {
1:                 if (materialized) {
1:                     return control.getOutputStream (pos - 1);
1:                 }
0:                 else {
0:                     if (pos > length())
0:                         throw Util.generateCsSQLException (
0:                                                 SQLState.BLOB_POSITION_TOO_LARGE);
1:                     control = new LOBStreamControl (
0:                                             getEmbedConnection().getDBName());
1:                     control.copyData (myStream, pos - 1);
1:                     myStream.close ();
1:                     materialized = true;
1:                     return control.getOutputStream(pos - 1);
1: 
1:                 }
1:             }
1:             catch (IOException e) {
1:                 throw Util.setStreamFailure (e);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (len > length())
1:                 throw Util.generateCsSQLException(
0:                     SQLState.BLOB_NONPOSITIVE_LENGTH, new Long(pos));
1:             try {
1:                 if (materialized) {
1:                     control.truncate (len);
1:                 }
0:                 else {
0:                     control = new LOBStreamControl (getEmbedConnection().getDBName());
1:                     control.copyData (myStream, len);
1:                     myStream.close();
1:                     materialized = true;
1:                 }
1:             }
0:             catch (IOException e) {
1:                 throw Util.setStreamFailure (e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         if (!materialized)
0:         else {
1:             try {
1:                 control.free ();
1:                 control = null;
1:             }
0:             catch (IOException e) {
0:                 throw Util.setStreamFailure (e);
1:             }
1:         }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:10e4538
/////////////////////////////////////////////////////////////////////////
1:              control = new LOBStreamControl (con, blobBytes);
/////////////////////////////////////////////////////////////////////////
1:                             getEmbedConnection(), dvdBytes);
/////////////////////////////////////////////////////////////////////////
1:                 control = new LOBStreamControl (getEmbedConnection());
/////////////////////////////////////////////////////////////////////////
1:                                             getEmbedConnection());
/////////////////////////////////////////////////////////////////////////
0:                     control = new LOBStreamControl (getEmbedConnection());
commit:456b8a1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineBlob;
/////////////////////////////////////////////////////////////////////////
0: final class EmbedBlob extends ConnectionChild implements Blob, EngineBlob
0:     // locator key for lob. used by Network Server.
0:     private final int             locator;
1:     
/////////////////////////////////////////////////////////////////////////
0:              locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         this.locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return locator for this lob.
1:      * 
0:      * @return
1:      */
1:     public int getLocator() {
1:         return locator;
1:     }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:d96e398
/////////////////////////////////////////////////////////////////////////
0:     private int             locator;
/////////////////////////////////////////////////////////////////////////
1:              con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
0:         con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
0:         //remove entry from connection
0:         localConn.removeLOBMapping(locator);
/////////////////////////////////////////////////////////////////////////
1:         if (locator == 0) {
1:             locator = localConn.addLOBMapping(this);
1:         }
commit:f920469
/////////////////////////////////////////////////////////////////////////
0:     private final int             locator;
/////////////////////////////////////////////////////////////////////////
0:              locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         this.locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:74bac8e
/////////////////////////////////////////////////////////////////////////
0:     private int             locator;
/////////////////////////////////////////////////////////////////////////
0:              con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
0:         con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
0:         //remove entry from connection
0:         localConn.removeLOBMapping(locator);
/////////////////////////////////////////////////////////////////////////
0:         if (locator == 0) {
0:             locator = localConn.addLOBMapping(this);
1:         }
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:cd727e7
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             return new UpdateableBlobStream(this,
1:                                             getBinaryStream(),
1:                                             pos-1,
1:                                             length);
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
1:         }
commit:78afc5b
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Blob object has been freed by calling free() on it
1:         checkValidity();
1:         
1:         if (pos <= 0) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.BLOB_BAD_POSITION,
0:                     new Long(pos));
1:         }
1:         if (length < 0) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.BLOB_NONPOSITIVE_LENGTH,
0:                     new Long(length));
1:         }
0:         if (length > (this.length() - pos)) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.POS_AND_LENGTH_GREATER_THAN_LOB,
0:                     new Long(pos), new Long(length));
1:         }
1:         
0:         return new UpdateableBlobStream(this,
0:                                         getBinaryStream(),
0:                                         pos-1,
0:                                         length);
commit:126b96c
/////////////////////////////////////////////////////////////////////////
1:              //add entry in connection so it can be cleared 
1:              //when transaction is not valid
0:              con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         //add entry in connection so it can be cleared 
0:         //when transaction is not valid
0:         con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
1:         //check for connection to maintain sqlcode for closed
1:         //connection
1:         getEmbedConnection().checkIfClosed();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:                 { // pattern is not necessarily a Derby Blob
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f433a64
/////////////////////////////////////////////////////////////////////////
1:    * starting at position <code>startPos</code>.
1:    * The starting position must be between 1 and the length
1:    * of the BLOB plus 1. This allows for zero-length BLOB values, from
1:    * which only zero-length byte arrays can be returned. 
1:    * If a larger length is requested than there are bytes available,
1:    * characters from the start position to the end of the BLOB are returned.
/////////////////////////////////////////////////////////////////////////
1:    * byte at position <code>startPos</code>.
1:    * NOTE: If the starting position is the length of the BLOB plus 1,
1:    * zero bytess are returned regardless of the length requested.
/////////////////////////////////////////////////////////////////////////
1:             if (length < 0)
/////////////////////////////////////////////////////////////////////////
0:                 // if blob length is less than pos bytes + 1, raise an exception
0:                 if (myBytes.length + 1 < startPos)
commit:e6936ea
/////////////////////////////////////////////////////////////////////////
0:                     throw StandardException.newException(SQLState.BLOB_LENGTH_TOO_LONG);
/////////////////////////////////////////////////////////////////////////
1:             if (e.getMessageId().equals(SQLState.BLOB_LENGTH_TOO_LONG))
/////////////////////////////////////////////////////////////////////////
1:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
/////////////////////////////////////////////////////////////////////////
0:             if (e.getMessageId().equals(SQLState.BLOB_LENGTH_TOO_LONG))
/////////////////////////////////////////////////////////////////////////
1:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
/////////////////////////////////////////////////////////////////////////
0:             if (e.getMessageId().equals(SQLState.BLOB_LENGTH_TOO_LONG))
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:    * @param startPos the ordinal position of the first byte in the
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:581dc2b
/////////////////////////////////////////////////////////////////////////
0:     // blob is either bytes or stream
1:     /*
0:      * Length of the BLOB if known. Set to -1 if
0:      * the current length of the BLOB is not known.
1:      */
0:     private long myLength = -1;
1:     
/////////////////////////////////////////////////////////////////////////
0:             myLength = dvdBytes.length;
/////////////////////////////////////////////////////////////////////////
0:         if (myLength != -1)
0:             return myLength;
1:         
1:            // we have a stream
/////////////////////////////////////////////////////////////////////////
0:                 // If possible get the length from the encoded
0:                 // length at the front of the raw stream.
0:                 if ((myLength = biStream.getLength()) != -1) {
0:                     biStream.close();
0:                    return myLength;
1:                 }
1:                 
0:                 // Otherwise have to read the entire stream!
/////////////////////////////////////////////////////////////////////////
1:                 // Save for future uses.
0:                 myLength = pos;
0:                 biStream.close();
commit:4153b27
/////////////////////////////////////////////////////////////////////////
1: /**
/////////////////////////////////////////////////////////////////////////
1:   <P><B>Supports</B>
1:    <UL>
1:    <LI> JSR169 - no subsetting for java.sql.Blob
1:    <LI> JDBC 2.0
1:    <LI> JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes,
1:         new update methods can safely be added into implementation.
1:    </UL>
1: 
0: final class EmbedBlob extends ConnectionChild implements Blob
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedBlob
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.impl.jdbc.ConnectionChild;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.iapi.services.io.NewByteArrayInputStream;
1: import org.apache.derby.iapi.services.io.InputStreamUtil;
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: import java.sql.SQLException;
1: import java.sql.Blob;
1: import java.io.InputStream;
0: import java.io.EOFException;
1: import java.io.IOException;
1: 
1: /*
1:     Implements java.sql.Blob (see the JDBC 2.0 spec).
1:     A blob sits on top of a BINARY, VARBINARY or LONG VARBINARY column.
1:     If its data is small (less than 1 page) it is a byte array taken from
1:     the SQLBit class. If it is large (more than 1 page) it is a long column
1:     in the database. The long column is accessed as a stream, and is implemented
1:     in store as an OverflowInputStream.  The Resetable interface allows sending
1:     messages to that stream to initialize itself (reopen its container and
1:     lock the corresponding row) and to reset itself to the beginning. 
1: 
1:     NOTE: In the case that the data is large, it is represented as a stream.
1:     This stream is returned to the user in the getBinaryStream() method.
1:     This means that we have limited control over the state of the stream,
1:     since the user can read bytes from it at any time.  Thus all methods
1:     here reset the stream to the beginning before doing any work.
1:     CAVEAT: The methods may not behave correctly if a user sets up
1:     multiple threads and sucks data from the stream (returned from
1:     getBinaryStream()) at the same time as calling the Blob methods.
1: 
1:  */
1: 
0: class EmbedBlob extends ConnectionChild implements Blob
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     // clob is either bytes or stream
0:     private boolean         isBytes;
0:     private InputStream     myStream;
0:     private byte[]          myBytes;
0:     // note: cannot control position of the stream since user can do a getBinaryStream
0:     private long            pos;
0:     // this stream sits on top of myStream
0:     private BinaryToRawStream biStream;
1: 
0:     // buffer for reading in blobs from a stream (long column)
0:     // and trashing them (to set the position of the stream etc.)
0:     private static int BLOB_BUF_SIZE = 4096;
0:     private byte buf[];
1: 
1:     /*
1:       This constructor should only be called by EmbedResultSet.getBlob
1:     */
1:     protected EmbedBlob(DataValueDescriptor dvd, EmbedConnection con)
0:         throws StandardException
1:     {
0:         super(con);
1:         // if the underlying column is null, ResultSet.getBlob will return null,
1:         // never should get this far
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(!dvd.isNull(), "blob is created on top of a null column");
1: 
0:         myStream = dvd.getStream();
0:         if (myStream == null)
1:         {
0:             isBytes = true;
1:             // copy bytes into memory so that blob can live after result set
1:             // is closed
1:             byte[] dvdBytes = dvd.getBytes();
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(dvdBytes != null,"blob has a null value underneath");
1: 
0:             myBytes = new byte[dvdBytes.length];
0:             System.arraycopy(dvdBytes, 0, myBytes, 0, dvdBytes.length);
1:         }
0:         else
1:         {
0:             isBytes = false;
1: 
1:             /*
1:              We are expecting this stream to be a FormatIdInputStream with an
1:              OverflowInputStream inside. FormatIdInputStream implements
1:              Resetable. This should be the case when retrieving
1:              data from a long column. However, SQLBit, which is the class
1:              implementing the getStream() method for dvd.getStream(), does not
1:              guarantee this for us
1:              */
1:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myStream instanceof Resetable);
1: 
0:             ((Resetable)myStream).initStream();
0:             // set up the buffer for trashing the bytes to set the position of the
0:             // stream, only need a buffer when we have a long column
0:             buf = new byte[BLOB_BUF_SIZE];
1:         }
0:         pos = 0;
1:     }
1: 
1: 
1:     /*
0:         Sets the position of the stream to position newPos, where position 0 is
0:         the beginning of the stream.
1: 
0:         @param newPos the position to set to
0:         @exception StandardException (BLOB_SETPOSITION_FAILED) throws this if
0:         the stream runs out before we get to newPos
1:     */
0:     private void setPosition(long newPos)
1:         throws StandardException, IOException
1:     {
1:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(newPos >= 0);
0:         if (isBytes)
0:             pos = newPos;
0:         else
1:         {
0:             // Always resets the stream to the beginning first, because user can
0:             // influence the state of the stream without letting us know.
0:             ((Resetable)myStream).resetStream();
0:             // PT could try to save creating a new object each time
0:             biStream = new BinaryToRawStream(myStream, this);
0:             pos = 0;
0:             while (pos < newPos)
1:             {
0:                 int size = biStream.read(
0:                     buf,0,(int) Math.min((newPos-pos), (long) BLOB_BUF_SIZE));
0:                 if (size <= 0)   // ran out of stream
0:                     throw StandardException.newException(SQLState.BLOB_SETPOSITION_FAILED);
0:                 pos += size;
1:             }
1:         }
1:     }
1: 
1: 
1:     /*
0:         Reads one byte, either from the byte array or else from the stream.
1:     */
0:     private int read()
0:         throws IOException
1:     {
1:         int c;
0:         if (isBytes)
1:         {
0:             if (pos >= myBytes.length)
1:                 return -1;
0:             else
0:                 c = myBytes[(int) pos];
1:         }
0:         else
0:             c = biStream.read();
0:         pos++;
1:         return c;
1:     }
1: 
1:   /**
1:    * Returns the number of bytes in the <code>BLOB</code> value
1:    * designated by this <code>Blob</code> object.
1:    * @return length of the <code>BLOB</code> in bytes
1:    * @exception SQLException if there is an error accessing the
1:    * length of the <code>BLOB</code>
1:    */
1:     // PT stream part may get pushed to store
1:     public long length()
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
0:             if (isBytes)
0:                 return myBytes.length;
0:             // we have a stream
1:             synchronized (getConnectionSynchronization())
1:             {
0:                 pushStack = !getEmbedConnection().isClosed();
1:                 if (pushStack)
1:                     setupContextStack();
1: 
0:                 setPosition(0);
0:                 for (;;)
1:                 {
0:                     int size = biStream.read(buf);
0:                     if (size == -1)
0:                         break;
0:                     pos += size;
1:                 }
0:                 return pos;
1:             }
1:         }
1:         catch (Throwable t)
1:         {
1: 			throw handleMyExceptions(t);
1:         }
1:         finally
1:         {
1:             if (pushStack)
1:                 restoreContextStack();
1:         }
1:     }
1: 
1: 
1:   /**
1:    * Returns as an array of bytes part or all of the <code>BLOB</code>
1:    * value that this <code>Blob</code> object designates.  The byte
1:    * array contains up to <code>length</code> consecutive bytes
0:    * starting at position <code>pos</code>.
0:    * @param pos the ordinal position of the first byte in the
1:    * <code>BLOB</code> value to be extracted; the first byte is at
1:    * position 1
1:    * @param length is the number of consecutive bytes to be copied
1:    * @return a byte array containing up to <code>length</code>
1:    * consecutive bytes from the <code>BLOB</code> value designated
1:    * by this <code>Blob</code> object, starting with the
0:    * byte at position <code>pos</code>.
1:    * @exception SQLException if there is an error accessing the
1:    * <code>BLOB</code>
0:    NOTE: return new byte[0] if startPos is too large
1:    */
1:    // PT stream part may get pushed to store
1: 
1:     public byte[] getBytes(long startPos, int length)
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
1:             if (startPos < 1)
1:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(startPos));
0:             if (length <= 0)
1:                 throw StandardException.newException(
0:                     SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));
1: 
1:             byte[] result;
0:             // if we have a byte array, not a stream
0:             if (isBytes)
1:             {
0:                 // if blob length is less than pos bytes, raise an exception
0:                 if (myBytes.length < startPos)
1:                     throw StandardException.newException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(startPos));
0:                 // cannot go over length of array
0:                 int lengthFromPos = myBytes.length - (int) startPos + 1;
0:                 int actualLength = length > lengthFromPos ? lengthFromPos : length;
0:                 result = new byte[actualLength];
0:                 System.arraycopy(myBytes, ((int) startPos) - 1, result, 0, actualLength);
1:             }
1:             else // we have a stream
1:             {
1:                 synchronized (getConnectionSynchronization())
1:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
1:                     if (pushStack)
1:                         setupContextStack();
1: 
0:                     setPosition(startPos-1);
1:                     // read length bytes into a string
1:                     result = new byte[length];
0:                     int n = InputStreamUtil.readLoop(biStream,result,0,length);
0:                     pos += n;
1:                     /*
1:                      According to the spec, if there are only n < length bytes
1:                      to return, we should just return these bytes. Rather than
1:                      return them in an array of size length, where the trailing
1:                      bytes are not initialized, and the user cannot tell how
1:                      many bytes were actually returned, we should return an
1:                      array of n bytes.
1:                      */
1:                     if (n < length)
1:                     {
1:                         byte[] result2 = new byte[n];
1:                         System.arraycopy(result,0,result2,0,n);
1:                         return result2;
1:                     }
1:                 }
1:             }
1:             return result;
1:         }
1:         catch (StandardException e)
1:         {  // if this is a setPosition exception then we ran out of Blob
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
1:                 e = StandardException.newException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(startPos));
1:             throw handleMyExceptions(e);
1:         }
1:         catch (Throwable t)
1:         {
1: 			throw handleMyExceptions(t);
1:         }
1:         finally
1:         {
1:             if (pushStack)
1:                 restoreContextStack();
1:         }
1: 
1:     }
1: 
1: 
1:   /**
1:    * Retrieves the <code>BLOB</code> designated by this
1:    * <code>Blob</code> instance as a stream.
1:    * @return a stream containing the <code>BLOB</code> data
1:    * @exception SQLException if there is an error accessing the
1:    * <code>BLOB</code>
1:    */
1:     public java.io.InputStream getBinaryStream()
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
1:             // if we have byte array, not a stream
0:             if (isBytes)
1:             {
0:                 return new NewByteArrayInputStream(myBytes);
1:             }
0:             else
1:             { 
1:                 // have a stream
1: 
1:                 synchronized (getConnectionSynchronization())
1:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
1:                     if (pushStack)
1:                         setupContextStack();
1: 
0:                     setPosition(0);
0:                     return biStream;
1:                 }
1:             }
1:         }
1:         catch (Throwable t)
1:         {
1: 			throw handleMyExceptions(t);
1:         }
1:         finally
1:         {
1:             if (pushStack)
1:                 restoreContextStack();
1:         }
1:     }
1: 
1: 
1:   /**
1:    * Determines the byte position at which the specified byte
1:    * <code>pattern</code> begins within the <code>BLOB</code>
1:    * value that this <code>Blob</code> object represents.  The
0:    * search for <code>pattern</code. begins at position
1:    * <code>start</code>
1:    * @param pattern the byte array for which to search
1:    * @param start the position at which to begin searching; the
1:    *        first position is 1
1:    * @return the position at which the pattern appears, else -1.
1:    * @exception SQLException if there is an error accessing the
1:    * <code>BLOB</code>
1:    */
1:     public long position(byte[] pattern, long start)
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
1:             if (start < 1)
1:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
1:             if (pattern == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
1:             if (pattern.length == 0)
1:                 return start; // match DB2's SQL LOCATE function
1: 
1:             synchronized (getConnectionSynchronization())
1:             {
0:                 pushStack = !getEmbedConnection().isClosed();
1:                 if (pushStack)
1:                     setupContextStack();
1: 
0:                 setPosition(start-1);
1:                 // look for first character
1:                 int lookFor = pattern[0];
1:                 long curPos;
1:                 int c;
1:                 while (true)
1:                 {
0:                     c = read();
0:                     if (c == -1)  // run out of stream
1:                         return -1;
1:                     if (c == lookFor)
1:                     {
1:                         curPos = pos;
0:                         if (checkMatch(pattern))
1:                             return curPos;
0:                         else
0:                             setPosition(curPos);
1:                     }
1:                 }
1:             }
1:         }
1:         catch (StandardException e)
0:         {  // if this is a setPosition exception then not found
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
1:                 return -1;
0:             else
1:                 throw handleMyExceptions(e);
1:         }
1:         catch (Throwable t)
1:         {
1: 			throw handleMyExceptions(t);
1:         }
1:         finally
1:         {
1:             if (pushStack)
1:                 restoreContextStack();
1:         }
1: 
1:     }
1: 
1: 
1:     /*
0:      check whether pattern (starting from the second byte) appears inside
0:      posStream (at the current position)
0:      @param posStream the stream to search inside
0:      @param pattern the byte array passed in by the user to search with
0:      @return true if match, false otherwise
1:      */
0:     private boolean checkMatch(byte[] pattern)
0:         throws IOException
1:     {
1:        // check whether rest matches
1:        // might improve performance by reading more
1:         for (int i = 1; i < pattern.length; i++)
1:         {
0:             int b = read();
1:             if ((b < 0) || (b != pattern[i]))  // mismatch or stream runs out
1:                 return false;
1:         }
1:         return true;
1:     }
1: 
1:   /**
1:    * Determines the byte position in the <code>BLOB</code> value
1:    * designated by this <code>Blob</code> object at which
1:    * <code>pattern</code> begins.  The search begins at position
1:    * <code>start</code>.
1:    * @param pattern the <code>Blob</code> object designating
1:    * the <code>BLOB</code> value for which to search
1:    * @param start the position in the <code>BLOB</code> value
1:    *        at which to begin searching; the first position is 1
1:    * @return the position at which the pattern begins, else -1
1:    * @exception SQLException if there is an error accessing the
1:    * <code>BLOB</code>
1:    */
1:     public long position(Blob pattern, long start)
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
1:             if (start < 1)
1:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
1:             if (pattern == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
1:             synchronized (getConnectionSynchronization())
1:             {
0:                 pushStack = !getEmbedConnection().isClosed();
1:                 if (pushStack)
1:                     setupContextStack();
1: 
0:                 setPosition(start-1);
1:                 // look for first character
1:                 byte[] b;
1:                 try
0:                 { // pattern is not necessarily a cloudscape Blob
1:                     b = pattern.getBytes(1,1);
1:                 }
1:                 catch (SQLException e)
1:                 {
1:                     throw StandardException.newException(SQLState.BLOB_UNABLE_TO_READ_PATTERN);
1:                 }
0:                 if (b == null || b.length < 1)  // the 'empty' blob
1:                     return start; // match DB2's SQL LOCATE function
1:                 int lookFor = b[0];
1:                 int c;
1:                 long curPos;
1:                 while (true)
1:                 {
0:                     c = read();
0:                     if (c == -1)  // run out of stream
1:                         return -1;
1:                     if (c == lookFor)
1:                     {
1:                         curPos = pos;
0:                         if (checkMatch(pattern))
1:                             return curPos;
0:                         else
0:                             setPosition(curPos);
1:                     }
1:                 }
1:             }
1:         }
1:         catch (StandardException e)
0:         {  // if this is a setPosition exception then not found
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
1:                 return -1;
0:             else
1:                 throw handleMyExceptions(e);
1:         }
1:         catch (Throwable t)
1:         {
1: 			throw handleMyExceptions(t);
1:         }
1:         finally
1:         {
1:             if (pushStack)
1:                 restoreContextStack();
1:         }
1: 
1:     }
1: 
1: 
1:     /*
0:      check whether pattern (starting from the second byte) appears inside
0:      posStream (at the current position)
0:      @param posStream the stream to search inside
0:      @param pattern the blob passed in by the user to search with
0:      @return true if match, false otherwise
1:      */
0:     private boolean checkMatch(Blob pattern)
0:         throws IOException
1:     {
1:         // check whether rest matches
1:         // might improve performance by reading buffer at a time
1:         InputStream pStream;
1:         try
1:         {
1:             pStream = pattern.getBinaryStream();
1:         }
1:         catch (SQLException e)
1:         {
1:             return false;
1:         }
1:         if (pStream == null)
1:             return false;
1:         // throw away first character since we already read it in the calling
1:         // method
1:         int b1 = pStream.read();
1:         if (b1 < 0)
1:             return false;
1:         while (true)
1:         {
1:             b1 = pStream.read();
1:             if (b1 < 0)  // search blob runs out
1:                 return true;
0:             int b2 = read();
1:             if ((b1 != b2) || (b2 < 0))  // mismatch or stream runs out
1:                 return false;
1:         }
1:     }
1: 
1:     /*
1:       Convert exceptions where needed before calling handleException to convert
1:       them to SQLExceptions.
1:     */
1: 	private SQLException handleMyExceptions(Throwable t)
1:         throws SQLException
1:     {
1:         if (t instanceof StandardException)
1:         {
1:             // container closed means the blob or clob was accessed after commit
1:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
1:             {
1:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:             }
1:         }
1:         return handleException(t);
1: 	}
1: 
1: 
1:    /*
1:     If we have a stream, release the resources associated with it.
1:     */
1:     protected void finalize()
1:     {
0:         if (!isBytes)
0:             ((Resetable)myStream).closeStream();
1:     }
1: 
1: 	/**
1:     Following methods are for the new JDBC 3.0 methods in java.sql.Blob
1:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
1:     package, so we don't have to have a new class in Local30.
1:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
1:     so this will work fine in jdbc2.0 configuration.
1: 	*/
1: 
1: 	/////////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	JDBC 3.0	-	New public methods
1: 	//
1: 	/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1:     * JDBC 3.0
1:     *
0:     * Writes the given array of bytes to the BLOB value that this Blob object
0:     * represents, starting at position pos, and returns the number of bytes written.
1:     *
1:     * @param pos - the position in the BLOB object at which to start writing
0:     * @param bytes - the array of bytes to be written to the BLOB value that this
0:     * Blob object represents
0:     * @return the number of bytes written
1:     * @exception SQLException Feature not implemented for now.
1: 	*/
0: 	public int setBytes(long pos,
0: 					byte[] bytes)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
1: 	}
1: 
1: 	/**
1:     * JDBC 3.0
1:     *
0:     * Writes all or part of the given array of byte array to the BLOB value that
0:     * this Blob object represents and returns the number of bytes written.
0:     * Writing starts at position pos in the BLOB value; len bytes from the given
0:     * byte array are written.
1:     *
1:     * @param pos - the position in the BLOB object at which to start writing
0:     * @param bytes - the array of bytes to be written to the BLOB value that this
0:     * Blob object represents
0:     * @param offset - the offset into the array bytes at which to start reading
0:     * the bytes to be set
0:     * @param len - the number of bytes to be written to the BLOB value from the
0:     * array of bytes bytes
0:     * @return the number of bytes written
1:     * @exception SQLException Feature not implemented for now.
1: 	*/
0: 	public int setBytes(long pos,
0: 					byte[] bytes, int offset,
0: 					int len)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
1: 	}
1: 
1: 	/**
1:     * JDBC 3.0
1:     *
1:     * Retrieves a stream that can be used to write to the BLOB value that this
1:     * Blob object represents. The stream begins at position pos. 
1:     *
1:     * @param pos - the position in the BLOB object at which to start writing
1:     * @return a java.io.OutputStream object to which data can be written 
1:     * @exception SQLException Feature not implemented for now.
1: 	*/
0: 	public java.io.OutputStream setBinaryStream(long pos)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
1: 	}
1: 
1: 	/**
1:     * JDBC 3.0
1:     *
1:     * Truncates the BLOB value that this Blob object represents to be len bytes
1:     * in length.
1:     *
1:     * @param len - the length, in bytes, to which the BLOB value that this Blob
1:     * object represents should be truncated
1:     * @exception SQLException Feature not implemented for now.
1: 	*/
1: 	public void truncate(long len)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
1: 	}
1: 
1: }
1: 
1: 
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b44abbf
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 ((Resetable) myStream).initStream();
0:             } catch (StandardException se) {
0:                 if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
0:                     throw StandardException
0:                             .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
0:                 }
0:             }
0:             // set up the buffer for trashing the bytes to set the position of
0:             // the
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.impl.jdbc.ConnectionChild;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.iapi.services.io.NewByteArrayInputStream;
0: import org.apache.derby.iapi.services.io.InputStreamUtil;
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import java.sql.SQLException;
0: import java.sql.Blob;
0: import java.io.InputStream;
0: import java.io.EOFException;
0: import java.io.IOException;
0: 
0: /*
0:     Implements java.sql.Blob (see the JDBC 2.0 spec).
0:     A blob sits on top of a BINARY, VARBINARY or LONG VARBINARY column.
0:     If its data is small (less than 1 page) it is a byte array taken from
0:     the SQLBit class. If it is large (more than 1 page) it is a long column
0:     in the database. The long column is accessed as a stream, and is implemented
0:     in store as an OverflowInputStream.  The Resetable interface allows sending
0:     messages to that stream to initialize itself (reopen its container and
0:     lock the corresponding row) and to reset itself to the beginning. 
0: 
0:     NOTE: In the case that the data is large, it is represented as a stream.
0:     This stream is returned to the user in the getBinaryStream() method.
0:     This means that we have limited control over the state of the stream,
0:     since the user can read bytes from it at any time.  Thus all methods
0:     here reset the stream to the beginning before doing any work.
0:     CAVEAT: The methods may not behave correctly if a user sets up
0:     multiple threads and sucks data from the stream (returned from
0:     getBinaryStream()) at the same time as calling the Blob methods.
0: 
0:  */
0: 
0: class EmbedBlob extends ConnectionChild implements Blob
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     // clob is either bytes or stream
0:     private boolean         isBytes;
0:     private InputStream     myStream;
0:     private byte[]          myBytes;
0:     // note: cannot control position of the stream since user can do a getBinaryStream
0:     private long            pos;
0:     // this stream sits on top of myStream
0:     private BinaryToRawStream biStream;
0: 
0:     // buffer for reading in blobs from a stream (long column)
0:     // and trashing them (to set the position of the stream etc.)
0:     private static int BLOB_BUF_SIZE = 4096;
0:     private byte buf[];
0: 
0:     /*
0:       This constructor should only be called by EmbedResultSet.getBlob
0:     */
0:     protected EmbedBlob(DataValueDescriptor dvd, EmbedConnection con)
0:         throws StandardException
0:     {
0:         super(con);
0:         // if the underlying column is null, ResultSet.getBlob will return null,
0:         // never should get this far
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(!dvd.isNull(), "blob is created on top of a null column");
0: 
0:         myStream = dvd.getStream();
0:         if (myStream == null)
0:         {
0:             isBytes = true;
0:             // copy bytes into memory so that blob can live after result set
0:             // is closed
0:             byte[] dvdBytes = dvd.getBytes();
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(dvdBytes != null,"blob has a null value underneath");
0: 
0:             myBytes = new byte[dvdBytes.length];
0:             System.arraycopy(dvdBytes, 0, myBytes, 0, dvdBytes.length);
0:         }
0:         else
0:         {
0:             isBytes = false;
0: 
0:             /*
0:              We are expecting this stream to be a FormatIdInputStream with an
0:              OverflowInputStream inside. FormatIdInputStream implements
0:              Resetable. This should be the case when retrieving
0:              data from a long column. However, SQLBit, which is the class
0:              implementing the getStream() method for dvd.getStream(), does not
0:              guarantee this for us
0:              */
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myStream instanceof Resetable);
0: 
0:             ((Resetable)myStream).initStream();
0:             // set up the buffer for trashing the bytes to set the position of the
0:             // stream, only need a buffer when we have a long column
0:             buf = new byte[BLOB_BUF_SIZE];
0:         }
0:         pos = 0;
0:     }
0: 
0: 
0:     /*
0:         Sets the position of the stream to position newPos, where position 0 is
0:         the beginning of the stream.
0: 
0:         @param newPos the position to set to
0:         @exception StandardException (BLOB_SETPOSITION_FAILED) throws this if
0:         the stream runs out before we get to newPos
0:     */
0:     private void setPosition(long newPos)
0:         throws StandardException, IOException
0:     {
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(newPos >= 0);
0:         if (isBytes)
0:             pos = newPos;
0:         else
0:         {
0:             // Always resets the stream to the beginning first, because user can
0:             // influence the state of the stream without letting us know.
0:             ((Resetable)myStream).resetStream();
0:             // PT could try to save creating a new object each time
0:             biStream = new BinaryToRawStream(myStream, this);
0:             pos = 0;
0:             while (pos < newPos)
0:             {
0:                 int size = biStream.read(
0:                     buf,0,(int) Math.min((newPos-pos), (long) BLOB_BUF_SIZE));
0:                 if (size <= 0)   // ran out of stream
0:                     throw StandardException.newException(SQLState.BLOB_SETPOSITION_FAILED);
0:                 pos += size;
0:             }
0:         }
0:     }
0: 
0: 
0:     /*
0:         Reads one byte, either from the byte array or else from the stream.
0:     */
0:     private int read()
0:         throws IOException
0:     {
0:         int c;
0:         if (isBytes)
0:         {
0:             if (pos >= myBytes.length)
0:                 return -1;
0:             else
0:                 c = myBytes[(int) pos];
0:         }
0:         else
0:             c = biStream.read();
0:         pos++;
0:         return c;
0:     }
0: 
0:   /**
0:    * Returns the number of bytes in the <code>BLOB</code> value
0:    * designated by this <code>Blob</code> object.
0:    * @return length of the <code>BLOB</code> in bytes
0:    * @exception SQLException if there is an error accessing the
0:    * length of the <code>BLOB</code>
0:    */
0:     // PT stream part may get pushed to store
0:     public long length()
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (isBytes)
0:                 return myBytes.length;
0:             // we have a stream
0:             synchronized (getConnectionSynchronization())
0:             {
0:                 pushStack = !getEmbedConnection().isClosed();
0:                 if (pushStack)
0:                     setupContextStack();
0: 
0:                 setPosition(0);
0:                 for (;;)
0:                 {
0:                     int size = biStream.read(buf);
0:                     if (size == -1)
0:                         break;
0:                     pos += size;
0:                 }
0:                 return pos;
0:             }
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw handleMyExceptions(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0:     }
0: 
0: 
0:   /**
0:    * Returns as an array of bytes part or all of the <code>BLOB</code>
0:    * value that this <code>Blob</code> object designates.  The byte
0:    * array contains up to <code>length</code> consecutive bytes
0:    * starting at position <code>pos</code>.
0:    * @param pos the ordinal position of the first byte in the
0:    * <code>BLOB</code> value to be extracted; the first byte is at
0:    * position 1
0:    * @param length is the number of consecutive bytes to be copied
0:    * @return a byte array containing up to <code>length</code>
0:    * consecutive bytes from the <code>BLOB</code> value designated
0:    * by this <code>Blob</code> object, starting with the
0:    * byte at position <code>pos</code>.
0:    * @exception SQLException if there is an error accessing the
0:    * <code>BLOB</code>
0:    NOTE: return new byte[0] if startPos is too large
0:    */
0:    // PT stream part may get pushed to store
0: 
0:     public byte[] getBytes(long startPos, int length)
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (startPos < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(startPos));
0:             if (length <= 0)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));
0: 
0:             byte[] result;
0:             // if we have a byte array, not a stream
0:             if (isBytes)
0:             {
0:                 // if blob length is less than pos bytes, raise an exception
0:                 if (myBytes.length < startPos)
0:                     throw StandardException.newException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(startPos));
0:                 // cannot go over length of array
0:                 int lengthFromPos = myBytes.length - (int) startPos + 1;
0:                 int actualLength = length > lengthFromPos ? lengthFromPos : length;
0:                 result = new byte[actualLength];
0:                 System.arraycopy(myBytes, ((int) startPos) - 1, result, 0, actualLength);
0:             }
0:             else // we have a stream
0:             {
0:                 synchronized (getConnectionSynchronization())
0:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
0:                     if (pushStack)
0:                         setupContextStack();
0: 
0:                     setPosition(startPos-1);
0:                     // read length bytes into a string
0:                     result = new byte[length];
0:                     int n = InputStreamUtil.readLoop(biStream,result,0,length);
0:                     pos += n;
0:                     /*
0:                      According to the spec, if there are only n < length bytes
0:                      to return, we should just return these bytes. Rather than
0:                      return them in an array of size length, where the trailing
0:                      bytes are not initialized, and the user cannot tell how
0:                      many bytes were actually returned, we should return an
0:                      array of n bytes.
0:                      */
0:                     if (n < length)
0:                     {
0:                         byte[] result2 = new byte[n];
0:                         System.arraycopy(result,0,result2,0,n);
0:                         return result2;
0:                     }
0:                 }
0:             }
0:             return result;
0:         }
0:         catch (StandardException e)
0:         {  // if this is a setPosition exception then we ran out of Blob
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
0:                 e = StandardException.newException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(startPos));
0:             throw handleMyExceptions(e);
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw handleMyExceptions(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0: 
0:     }
0: 
0: 
0:   /**
0:    * Retrieves the <code>BLOB</code> designated by this
0:    * <code>Blob</code> instance as a stream.
0:    * @return a stream containing the <code>BLOB</code> data
0:    * @exception SQLException if there is an error accessing the
0:    * <code>BLOB</code>
0:    */
0:     public java.io.InputStream getBinaryStream()
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             // if we have byte array, not a stream
0:             if (isBytes)
0:             {
0:                 return new NewByteArrayInputStream(myBytes);
0:             }
0:             else
0:             { 
0:                 // have a stream
0: 
0:                 synchronized (getConnectionSynchronization())
0:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
0:                     if (pushStack)
0:                         setupContextStack();
0: 
0:                     setPosition(0);
0:                     return biStream;
0:                 }
0:             }
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw handleMyExceptions(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0:     }
0: 
0: 
0:   /**
0:    * Determines the byte position at which the specified byte
0:    * <code>pattern</code> begins within the <code>BLOB</code>
0:    * value that this <code>Blob</code> object represents.  The
0:    * search for <code>pattern</code. begins at position
0:    * <code>start</code>
0:    * @param pattern the byte array for which to search
0:    * @param start the position at which to begin searching; the
0:    *        first position is 1
0:    * @return the position at which the pattern appears, else -1.
0:    * @exception SQLException if there is an error accessing the
0:    * <code>BLOB</code>
0:    */
0:     public long position(byte[] pattern, long start)
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (pattern == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
0:             if (pattern.length == 0)
0:                 return start; // match DB2's SQL LOCATE function
0: 
0:             synchronized (getConnectionSynchronization())
0:             {
0:                 pushStack = !getEmbedConnection().isClosed();
0:                 if (pushStack)
0:                     setupContextStack();
0: 
0:                 setPosition(start-1);
0:                 // look for first character
0:                 int lookFor = pattern[0];
0:                 long curPos;
0:                 int c;
0:                 while (true)
0:                 {
0:                     c = read();
0:                     if (c == -1)  // run out of stream
0:                         return -1;
0:                     if (c == lookFor)
0:                     {
0:                         curPos = pos;
0:                         if (checkMatch(pattern))
0:                             return curPos;
0:                         else
0:                             setPosition(curPos);
0:                     }
0:                 }
0:             }
0:         }
0:         catch (StandardException e)
0:         {  // if this is a setPosition exception then not found
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
0:                 return -1;
0:             else
0:                 throw handleMyExceptions(e);
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw handleMyExceptions(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0: 
0:     }
0: 
0: 
0:     /*
0:      check whether pattern (starting from the second byte) appears inside
0:      posStream (at the current position)
0:      @param posStream the stream to search inside
0:      @param pattern the byte array passed in by the user to search with
0:      @return true if match, false otherwise
0:      */
0:     private boolean checkMatch(byte[] pattern)
0:         throws IOException
0:     {
0:        // check whether rest matches
0:        // might improve performance by reading more
0:         for (int i = 1; i < pattern.length; i++)
0:         {
0:             int b = read();
0:             if ((b < 0) || (b != pattern[i]))  // mismatch or stream runs out
0:                 return false;
0:         }
0:         return true;
0:     }
0: 
0:   /**
0:    * Determines the byte position in the <code>BLOB</code> value
0:    * designated by this <code>Blob</code> object at which
0:    * <code>pattern</code> begins.  The search begins at position
0:    * <code>start</code>.
0:    * @param pattern the <code>Blob</code> object designating
0:    * the <code>BLOB</code> value for which to search
0:    * @param start the position in the <code>BLOB</code> value
0:    *        at which to begin searching; the first position is 1
0:    * @return the position at which the pattern begins, else -1
0:    * @exception SQLException if there is an error accessing the
0:    * <code>BLOB</code>
0:    */
0:     public long position(Blob pattern, long start)
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (pattern == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
0:             synchronized (getConnectionSynchronization())
0:             {
0:                 pushStack = !getEmbedConnection().isClosed();
0:                 if (pushStack)
0:                     setupContextStack();
0: 
0:                 setPosition(start-1);
0:                 // look for first character
0:                 byte[] b;
0:                 try
0:                 { // pattern is not necessarily a cloudscape Blob
0:                     b = pattern.getBytes(1,1);
0:                 }
0:                 catch (SQLException e)
0:                 {
0:                     throw StandardException.newException(SQLState.BLOB_UNABLE_TO_READ_PATTERN);
0:                 }
0:                 if (b == null || b.length < 1)  // the 'empty' blob
0:                     return start; // match DB2's SQL LOCATE function
0:                 int lookFor = b[0];
0:                 int c;
0:                 long curPos;
0:                 while (true)
0:                 {
0:                     c = read();
0:                     if (c == -1)  // run out of stream
0:                         return -1;
0:                     if (c == lookFor)
0:                     {
0:                         curPos = pos;
0:                         if (checkMatch(pattern))
0:                             return curPos;
0:                         else
0:                             setPosition(curPos);
0:                     }
0:                 }
0:             }
0:         }
0:         catch (StandardException e)
0:         {  // if this is a setPosition exception then not found
0:             if (e.getMessageId().equals(SQLState.BLOB_SETPOSITION_FAILED))
0:                 return -1;
0:             else
0:                 throw handleMyExceptions(e);
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw handleMyExceptions(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0: 
0:     }
0: 
0: 
0:     /*
0:      check whether pattern (starting from the second byte) appears inside
0:      posStream (at the current position)
0:      @param posStream the stream to search inside
0:      @param pattern the blob passed in by the user to search with
0:      @return true if match, false otherwise
0:      */
0:     private boolean checkMatch(Blob pattern)
0:         throws IOException
0:     {
0:         // check whether rest matches
0:         // might improve performance by reading buffer at a time
0:         InputStream pStream;
0:         try
0:         {
0:             pStream = pattern.getBinaryStream();
0:         }
0:         catch (SQLException e)
0:         {
0:             return false;
0:         }
0:         if (pStream == null)
0:             return false;
0:         // throw away first character since we already read it in the calling
0:         // method
0:         int b1 = pStream.read();
0:         if (b1 < 0)
0:             return false;
0:         while (true)
0:         {
0:             b1 = pStream.read();
0:             if (b1 < 0)  // search blob runs out
0:                 return true;
0:             int b2 = read();
0:             if ((b1 != b2) || (b2 < 0))  // mismatch or stream runs out
0:                 return false;
0:         }
0:     }
0: 
0:     /*
0:       Convert exceptions where needed before calling handleException to convert
0:       them to SQLExceptions.
0:     */
0: 	private SQLException handleMyExceptions(Throwable t)
0:         throws SQLException
0:     {
0:         if (t instanceof StandardException)
0:         {
0:             // container closed means the blob or clob was accessed after commit
0:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
0:             {
0:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
0:             }
0:         }
0:         return handleException(t);
0: 	}
0: 
0: 
0:    /*
0:     If we have a stream, release the resources associated with it.
0:     */
0:     protected void finalize()
0:     {
0:         if (!isBytes)
0:             ((Resetable)myStream).closeStream();
0:     }
0: 
0: 	/**
0:     Following methods are for the new JDBC 3.0 methods in java.sql.Blob
0:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
0:     package, so we don't have to have a new class in Local30.
0:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
0:     so this will work fine in jdbc2.0 configuration.
0: 	*/
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 3.0	-	New public methods
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes the given array of bytes to the BLOB value that this Blob object
0:     * represents, starting at position pos, and returns the number of bytes written.
0:     *
0:     * @param pos - the position in the BLOB object at which to start writing
0:     * @param bytes - the array of bytes to be written to the BLOB value that this
0:     * Blob object represents
0:     * @return the number of bytes written
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setBytes(long pos,
0: 					byte[] bytes)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes all or part of the given array of byte array to the BLOB value that
0:     * this Blob object represents and returns the number of bytes written.
0:     * Writing starts at position pos in the BLOB value; len bytes from the given
0:     * byte array are written.
0:     *
0:     * @param pos - the position in the BLOB object at which to start writing
0:     * @param bytes - the array of bytes to be written to the BLOB value that this
0:     * Blob object represents
0:     * @param offset - the offset into the array bytes at which to start reading
0:     * the bytes to be set
0:     * @param len - the number of bytes to be written to the BLOB value from the
0:     * array of bytes bytes
0:     * @return the number of bytes written
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setBytes(long pos,
0: 					byte[] bytes, int offset,
0: 					int len)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Retrieves a stream that can be used to write to the BLOB value that this
0:     * Blob object represents. The stream begins at position pos. 
0:     *
0:     * @param pos - the position in the BLOB object at which to start writing
0:     * @return a java.io.OutputStream object to which data can be written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public java.io.OutputStream setBinaryStream(long pos)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Truncates the BLOB value that this Blob object represents to be len bytes
0:     * in length.
0:     *
0:     * @param len - the length, in bytes, to which the BLOB value that this Blob
0:     * object represents should be truncated
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public void truncate(long len)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: }
0: 
0: 
0: 
============================================================================