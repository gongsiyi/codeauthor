1:bbc927c: /*
12:bbc927c: 
1:bbc927c:    Derby - Class org.apache.derby.impl.store.access.heap.HeapScan
1:bbc927c: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:bbc927c: 
1:bbc927c:       http://www.apache.org/licenses/LICENSE-2.0
1:bbc927c: 
1:bbc927c:    Unless required by applicable law or agreed to in writing, software
1:bbc927c:    distributed under the License is distributed on an "AS IS" BASIS,
1:bbc927c:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:bbc927c:    See the License for the specific language governing permissions and
1:bbc927c:    limitations under the License.
1:bbc927c: 
1:bbc927c: */
1:bbc927c: 
1:bbc927c: package org.apache.derby.impl.store.access.heap;
1:bbc927c: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:bbc927c: 
1:bbc927c: import org.apache.derby.iapi.error.StandardException;
1:bbc927c: 
1:bbc927c: import org.apache.derby.iapi.store.access.SpaceInfo;
1:bbc927c: 
1:bbc927c: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1:bbc927c: 
1:bbc927c: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:bbc927c: import org.apache.derby.iapi.store.raw.Page;
1:bbc927c: import org.apache.derby.iapi.store.raw.RecordHandle;
1:bbc927c: 
1:bbc927c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:bbc927c: import org.apache.derby.iapi.types.RowLocation;
1:bbc927c: 
1:bbc927c: /**
1:fa09146:  * A heap scan object represents an instance of a scan on a heap conglomerate.
1:fa09146:  */
1:bbc927c: class HeapCompressScan 
1:bbc927c:     extends HeapScan
1:bbc927c: {
1:bbc927c: 
1:bbc927c:     /**************************************************************************
1:bbc927c:      * Constants of HeapScan
1:bbc927c:      **************************************************************************
1:bbc927c:      */
1:bbc927c: 
1:bbc927c:     /**************************************************************************
1:bbc927c:      * Fields of HeapScan
1:bbc927c:      **************************************************************************
1:bbc927c:      */
1:bbc927c:     private long pagenum_to_start_moving_rows = -1;
1:bbc927c: 
1:bbc927c: 
1:bbc927c: 
1:bbc927c:     /**************************************************************************
1:bbc927c:      * Constructors for This class:
1:bbc927c:      **************************************************************************
1:bbc927c:      */
1:bbc927c: 
1:bbc927c: 	/**
1:bbc927c: 	 ** The only constructor for a HeapCompressScan returns a scan in the
1:bbc927c: 	 ** closed state, the caller must call open.
2:bbc927c: 	 **/
1:bbc927c: 	
1:bbc927c: 	public HeapCompressScan()
1:bbc927c: 	{
1:bbc927c: 	}
1:f576b26: 
1:bbc927c:     /**************************************************************************
1:bbc927c:      * Protected override implementation of routines in
1:bbc927c:      *     GenericController class:
1:bbc927c:      **************************************************************************
1:bbc927c:      */
1:bbc927c: 
1:bbc927c:     public int fetchNextGroup(
1:bbc927c:     DataValueDescriptor[][] row_array,
1:bbc927c:     RowLocation[]           old_rowloc_array,
1:bbc927c:     RowLocation[]           new_rowloc_array)
1:bbc927c:         throws StandardException
1:bbc927c: 	{
1:bbc927c:         return(fetchRowsForCompress(
1:bbc927c:                     row_array, old_rowloc_array, new_rowloc_array));
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:bbc927c:      * Fetch the next N rows from the table.
1:bbc927c:      * <p>
1:bbc927c:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c:     private int fetchRowsForCompress(
1:bbc927c:     DataValueDescriptor[][] row_array,
1:bbc927c:     RowLocation[]           oldrowloc_array,
1:bbc927c:     RowLocation[]           newrowloc_array)
1:bbc927c:         throws StandardException
1:bbc927c: 	{
1:bbc927c:         int                     ret_row_count           = 0;
1:bbc927c:         DataValueDescriptor[]   fetch_row               = null;
1:bbc927c: 
1:f576b26:         // only fetch maximum number of rows per "group" as the size of
1:f576b26:         // the array.  If more than one group is available on page, just
1:f576b26:         // leave the scan on the page and the next group will come from
1:f576b26:         // this page also.
1:f576b26:         int                     max_rowcnt = row_array.length;
1:f576b26: 
1:bbc927c:         if (SanityManager.DEBUG)
1:bbc927c:         {
1:bbc927c:             SanityManager.ASSERT(row_array != null);
1:bbc927c:             SanityManager.ASSERT(row_array[0] != null,
1:bbc927c:                     "first array slot in fetchNextGroup() must be non-null.");
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         if (getScanState() == SCAN_INPROGRESS)
1:bbc927c:         {
1:bbc927c:             positionAtResumeScan(scan_position);
1:bbc927c:         }
1:bbc927c:         else if (getScanState() == SCAN_INIT)
1:bbc927c:         {
1:bbc927c:             // For first implementation of defragment use a conservative
1:bbc927c:             // approach, only move rows from the last "number of free pages"
1:bbc927c:             // of the container.  Should always at least be able to empty
1:bbc927c:             // that number of pages.
1:bbc927c:             SpaceInfo info = 
1:bbc927c:                 open_conglom.getContainer().getSpaceInfo();
1:bbc927c: 
1:bbc927c:             pagenum_to_start_moving_rows = info.getNumAllocatedPages();
1:bbc927c: 
1:bbc927c:             positionAtStartForForwardScan(scan_position);
1:bbc927c:         }
1:bbc927c:         else if (getScanState() == SCAN_HOLD_INPROGRESS)
1:bbc927c:         {
1:d376440:             reopenAfterEndTransaction();
1:bbc927c: 
1:bbc927c:             if (SanityManager.DEBUG)
1:bbc927c:             {
1:bbc927c:                 SanityManager.ASSERT(
1:bbc927c:                     scan_position.current_rh != null, this.toString()); 
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             // reposition the scan at the row just before the next one to 
1:bbc927c:             // return.
1:bbc927c:             // This routine handles the mess of repositioning if the row or 
1:bbc927c:             // the page has disappeared. This can happen if a lock was not 
1:bbc927c:             // held on the row while not holding the latch.
1:bbc927c:             open_conglom.latchPageAndRepositionScan(scan_position);
1:bbc927c: 
1:bbc927c:             setScanState(SCAN_INPROGRESS);
1:bbc927c:         }
1:bbc927c:         else if (getScanState() == SCAN_HOLD_INIT)
1:bbc927c:         {
1:d376440:             reopenAfterEndTransaction();
1:bbc927c: 
1:bbc927c:             positionAtStartForForwardScan(scan_position);
1:bbc927c: 
1:bbc927c:         }
1:bbc927c:         else
1:bbc927c:         {
1:bbc927c:             if (SanityManager.DEBUG)
1:bbc927c:                 SanityManager.ASSERT(getScanState() == SCAN_DONE);
1:bbc927c: 
1:bbc927c:             return(0);
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         // At this point:
1:bbc927c:         // scan_position.current_page is latched.  
1:bbc927c:         // scan_position.current_slot is the slot on scan_position.current_page
1:bbc927c:         // just before the "next" record this routine should process.
1:bbc927c: 
1:bbc927c:         // loop through successive pages and successive slots on those
1:bbc927c:         // pages.  Stop when either the last page is reached 
1:bbc927c:         // (scan_position.current_page will be null).  
1:bbc927c:         // Along the way apply qualifiers to skip rows which don't qualify.
1:bbc927c: 
1:bbc927c: 		while (scan_position.current_page != null)
1:bbc927c: 		{
1:bbc927c: 			while ((scan_position.current_slot + 1) < 
1:bbc927c:                     scan_position.current_page.recordCount())
1:bbc927c: 			{
1:f576b26: 
1:bbc927c:                 // Allocate a new row to read the row into.
1:bbc927c:                 if (fetch_row == null)
1:bbc927c:                 {
1:bbc927c:                      // point at allocated row in array if one exists.
1:bbc927c:                     if (row_array[ret_row_count] == null)
1:bbc927c:                     {
1:bbc927c:                         row_array[ret_row_count] = 
1:722a889:                           open_conglom.getRuntimeMem().get_row_for_export(
1:722a889:                               open_conglom.getRawTran());
1:bbc927c:                     }
1:bbc927c: 
1:bbc927c:                     fetch_row = row_array[ret_row_count];
1:bbc927c:                 }
1:bbc927c: 
1:bbc927c:                 // move scan current position forward.
1:bbc927c:                 scan_position.positionAtNextSlot();
1:f576b26:                 int restart_slot = scan_position.current_slot;
1:bbc927c: 
1:bbc927c:                 this.stat_numrows_visited++;
1:bbc927c: 
1:bbc927c:                 if (scan_position.current_page.isDeletedAtSlot(
1:bbc927c:                         scan_position.current_slot))
1:bbc927c:                 {
1:bbc927c:                     // At this point assume table level lock, and that this
1:bbc927c:                     // transcation did not delete the row, so any
1:bbc927c:                     // deleted row must be a committed deleted row which can
1:b1043a6:                     // be purged.  Usually latches on purged pages must
1:b1043a6:                     // be held until end transaction to prevent other 
1:b1043a6:                     // transactions from using space necessary for a possible
1:b1043a6:                     // undo of the purge, but in this case a table level
1:b1043a6:                     // lock is held and will insure correct undo behavior.
1:bbc927c:                     scan_position.current_page.purgeAtSlot(
1:bbc927c:                         scan_position.current_slot, 1, false);
1:bbc927c: 
1:bbc927c:                     // raw store shuffles following rows down, so 
2:bbc927c:                     // postion the scan at previous slot, so next trip
1:bbc927c:                     // through loop will pick up correct row.
1:bbc927c:                     scan_position.positionAtPrevSlot();
1:bbc927c:                     continue;
1:bbc927c:                 }
1:bbc927c: 
1:bbc927c:                 if (scan_position.current_page.getPageNumber() > 
1:bbc927c:                         pagenum_to_start_moving_rows)
1:bbc927c:                 {
1:bbc927c:                     // Give raw store a chance to move the row for compression
1:bbc927c:                     RecordHandle[] old_handle = new RecordHandle[1];
1:bbc927c:                     RecordHandle[] new_handle = new RecordHandle[1];
1:bbc927c:                     long[]         new_pageno = new long[1];
1:bbc927c: 
1:bbc927c:                     if (scan_position.current_page.moveRecordForCompressAtSlot(
1:bbc927c:                             scan_position.current_slot,
1:bbc927c:                             fetch_row,
1:bbc927c:                             old_handle,
1:bbc927c:                             new_handle) == 1)
1:bbc927c:                     {
1:bbc927c:                         // raw store moved the row, so bump the row count but 
1:f576b26:                         // position the scan at previous slot, so next trip
1:bbc927c:                         // through loop will pick up correct row.
1:bbc927c:                         // The subsequent rows will have been moved forward
1:bbc927c:                         // to take place of moved row.
1:bbc927c:                         scan_position.positionAtPrevSlot();
1:bbc927c: 
1:bbc927c:                         ret_row_count++;
1:bbc927c:                         stat_numrows_qualified++;
1:bbc927c: 
1:bbc927c: 
1:bbc927c:                         setRowLocationArray(
1:bbc927c:                             oldrowloc_array, ret_row_count - 1, old_handle[0]);
1:bbc927c:                         setRowLocationArray(
1:bbc927c:                             newrowloc_array, ret_row_count - 1, new_handle[0]);
1:bbc927c: 
1:bbc927c:                         fetch_row = null;
1:bbc927c: 
1:bbc927c:                     }
1:bbc927c:                 }
1:bbc927c: 
1:f576b26:                 // Derby-2549. If ret_row_count reaches the limit of the buffer,
1:f576b26:                 // then return the maximum number and come back into the same 
1:f576b26:                 // method to fetch the remaining rows. In this block we ensure
1:f576b26:                 // that the scan_position is appropriate.
1:f576b26:                 if (ret_row_count >= max_rowcnt)
1:f576b26:                 {
1:f576b26:                     // filled group buffer, exit fetch loop and return to caller
1:f576b26: 
1:f576b26:                     // save current scan position by record handle.
1:f576b26:                     scan_position.current_rh =
1:f576b26:                         scan_position.current_page.getRecordHandleAtSlot(
1:f576b26:                             restart_slot);
1:f576b26: 
1:f576b26:                     scan_position.unlatch();
1:f576b26: 
1:f576b26:                     return(ret_row_count);
1:f576b26:                 }
1:bbc927c: 			}
1:bbc927c: 
1:bbc927c:             this.stat_numpages_visited++;
1:bbc927c: 
1:bbc927c:             if (scan_position.current_page.recordCount() == 0)
1:bbc927c:             {
1:bbc927c:                 // need to set the scan position before removing page
1:bbc927c:                 scan_position.current_pageno = 
1:bbc927c:                     scan_position.current_page.getPageNumber();
1:bbc927c: 
1:bbc927c:                 open_conglom.getContainer().removePage(
1:bbc927c:                     scan_position.current_page);
1:bbc927c: 
1:bbc927c:                 // removePage unlatches the page, and page not available
1:bbc927c:                 // again until after commit.
1:bbc927c:                 scan_position.current_page = null;
1:bbc927c:             }
1:bbc927c:             else
1:bbc927c:             {
1:bbc927c:                 positionAfterThisPage(scan_position);
1:bbc927c:                 scan_position.unlatch();
1:bbc927c:             }
1:bbc927c: 
1:bbc927c: 
1:bbc927c:             if (ret_row_count > 0)
1:bbc927c:             {
1:bbc927c:                 // rows were moved on this page, give caller a chance to
1:bbc927c:                 // process those and free up access to the table.
1:bbc927c:                 return(ret_row_count);
1:bbc927c:             }
1:bbc927c:             else
1:bbc927c:             {
1:bbc927c:                 // no rows were moved so go ahead and commit the transaction
1:bbc927c:                 // to allow other threads a chance at table.  Compress does
1:bbc927c:                 // need to sync as long as transaction either completely 
1:bbc927c:                 // commits or backs out, either is fine.
1:bbc927c:                 /*
1:bbc927c:                 open_conglom.getXactMgr().commitNoSync(
1:bbc927c:                     TransactionController.RELEASE_LOCKS);
3:bbc927c:                 open_conglom.reopen();
1:bbc927c:                 */
1:bbc927c:                 positionAtResumeScan(scan_position);
1:bbc927c: 
1:bbc927c:             }
1:bbc927c: 		}
1:bbc927c: 
1:bbc927c:         // Reached last page of scan.
1:bbc927c:         positionAtDoneScan(scan_position);
1:bbc927c: 
1:bbc927c:         // we need to decrement when we stop scan at the end of the table.
1:bbc927c:         this.stat_numpages_visited--;
1:bbc927c: 
1:bbc927c: 		return(ret_row_count);
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:bbc927c:      * Reposition the scan upon entering the fetchRows loop.
1:bbc927c:      * <p>
1:bbc927c:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
1:bbc927c:      * Do work necessary to look at rows in the current page of the scan.
1:bbc927c:      * <p>
1:bbc927c:      * The default implementation uses a record handle to maintain a scan
1:bbc927c:      * position.  It will get the latch again on the current
1:bbc927c:      * scan position and set the slot to the current record handle.
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c:     protected void positionAtResumeScan(
1:bbc927c:     RowPosition pos)
1:bbc927c: 		throws StandardException
1:bbc927c:     {
1:bbc927c:         // reposition the scan at the row just before the next one to return.
1:bbc927c:         // This routine handles the mess of repositioning if the row or the
1:bbc927c:         // page has disappeared. This can happen if a lock was not held on the
1:bbc927c:         // row while not holding the latch.
1:bbc927c:         open_conglom.latchPageAndRepositionScan(scan_position);
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:bbc927c:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
1:bbc927c:      * <p>
1:bbc927c:      * This routine is called to move the scan from SCAN_INIT to 
1:bbc927c:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
1:bbc927c:      * that scan_position is set such that calling the generic 
1:bbc927c:      * scan loop will reach the first row of the scan.  Note that this
1:bbc927c:      * usually means setting the scan_postion to one before the 1st 
1:bbc927c:      * row to be returned.
1:bbc927c:      * <p>
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c:     protected void positionAtStartForForwardScan(
1:bbc927c:     RowPosition pos)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         if (pos.current_rh == null)
1:bbc927c:         {
1:bbc927c:             // 1st positioning of scan (delayed from openScan).  Do not
1:bbc927c:             // compress the first page, there is no previous page to move
1:bbc927c:             // rows to, and moving the special Heap metadata row from the
1:bbc927c:             // first page would cause problems.  Setting to next page is
1:bbc927c:             // why this scan overrides generic implementation.
1:bbc927c:             pos.current_page = 
1:bbc927c:                 open_conglom.getContainer().getNextPage(
1:bbc927c:                     ContainerHandle.FIRST_PAGE_NUMBER);
1:bbc927c: 
1:bbc927c:             // set up for scan to continue at beginning of page following
1:bbc927c:             // the first page of the container.
1:bbc927c:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
1:bbc927c:         }
1:bbc927c:         else
1:bbc927c:         {
1:bbc927c:             // 1st positioning of scan following a reopenScanByRowLocation
1:bbc927c: 
1:bbc927c:             // reposition the scan at the row just before the next one to 
1:bbc927c:             // return.  This routine handles the mess of repositioning if the 
1:bbc927c:             // row or the page has disappeared. This can happen if a lock was 
1:bbc927c:             // not held on the row while not holding the latch.
1:bbc927c:             open_conglom.latchPageAndRepositionScan(pos);
1:bbc927c: 
1:bbc927c:             // set up for scan to at the specified record handle (position one
1:bbc927c:             // before it so that the loop increment and find it).
1:bbc927c:             pos.current_slot -= 1;
1:bbc927c:         }
1:bbc927c: 
1:bbc927c:         pos.current_rh              = null;
1:bbc927c:         this.stat_numpages_visited  = 1;
1:bbc927c:         this.setScanState(SCAN_INPROGRESS);
1:bbc927c:     }
1:bbc927c: 
1:bbc927c: 
1:bbc927c:     /**************************************************************************
1:bbc927c:      * Private/Protected methods of This class:
1:bbc927c:      **************************************************************************
1:bbc927c:      */
1:bbc927c: 
1:bbc927c:     /**
1:bbc927c:      * Set scan position to just after current page.
1:bbc927c:      * <p>
1:bbc927c:      * Used to set the position of the scan if a record handle is not
1:bbc927c:      * avaliable.  In this case current_rh will be set to null, and 
1:bbc927c:      * current_pageno will be set to the current page number.
1:bbc927c:      * On resume of the scan, the scan will be set to just before the first
1:bbc927c:      * row returned form a getNextPage(current_pageno) call.
1:bbc927c:      * <p>
1:bbc927c:      * A positionAtResumeScan(scan_position) is necessary to continue the
1:bbc927c:      * scan after this call.
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c:     private void positionAfterThisPage(
1:bbc927c:     RowPosition pos)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         pos.current_rh = null;
1:bbc927c:         pos.current_pageno = pos.current_page.getPageNumber();
1:bbc927c:     }
1:bbc927c: 
1:bbc927c: 	/*
1:bbc927c: 	** Methods of ScanManager
1:bbc927c: 	*/
1:bbc927c: 
1:bbc927c: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b1043a6
/////////////////////////////////////////////////////////////////////////
1:                     // be purged.  Usually latches on purged pages must
1:                     // be held until end transaction to prevent other 
1:                     // transactions from using space necessary for a possible
1:                     // undo of the purge, but in this case a table level
1:                     // lock is held and will insure correct undo behavior.
commit:f576b26
/////////////////////////////////////////////////////////////////////////
1:         // only fetch maximum number of rows per "group" as the size of
1:         // the array.  If more than one group is available on page, just
1:         // leave the scan on the page and the next group will come from
1:         // this page also.
1:         int                     max_rowcnt = row_array.length;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                 int restart_slot = scan_position.current_slot;
/////////////////////////////////////////////////////////////////////////
1:                         // position the scan at previous slot, so next trip
/////////////////////////////////////////////////////////////////////////
1: 
1:                 // Derby-2549. If ret_row_count reaches the limit of the buffer,
1:                 // then return the maximum number and come back into the same 
1:                 // method to fetch the remaining rows. In this block we ensure
1:                 // that the scan_position is appropriate.
1:                 if (ret_row_count >= max_rowcnt)
1:                 {
1:                     // filled group buffer, exit fetch loop and return to caller
1: 
1:                     // save current scan position by record handle.
1:                     scan_position.current_rh =
1:                         scan_position.current_page.getRecordHandleAtSlot(
1:                             restart_slot);
1: 
1:                     scan_position.unlatch();
1: 
1:                     return(ret_row_count);
1:                 }
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:                           open_conglom.getRuntimeMem().get_row_for_export(
1:                               open_conglom.getRawTran());
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapScan
1: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: 
1: /**
1: 
0:   A heap scan object represents an instance of an scan on a heap conglomerate.
1: 
1: **/
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.GenericScanController;
1: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import java.util.Hashtable;
0: import java.util.Vector;
1: 
1: class HeapCompressScan 
1:     extends HeapScan
1: {
1: 
1:     /**************************************************************************
1:      * Constants of HeapScan
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Fields of HeapScan
1:      **************************************************************************
1:      */
1:     private long pagenum_to_start_moving_rows = -1;
1: 
1: 
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	 ** The only constructor for a HeapCompressScan returns a scan in the
1: 	 ** closed state, the caller must call open.
1: 	 **/
1: 	
1: 	public HeapCompressScan()
1: 	{
1: 	}
1: 
1:     /**************************************************************************
1:      * Protected override implementation of routines in
1:      *     GenericController class:
1:      **************************************************************************
1:      */
1: 
1:     public int fetchNextGroup(
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           old_rowloc_array,
1:     RowLocation[]           new_rowloc_array)
1:         throws StandardException
1: 	{
1:         return(fetchRowsForCompress(
1:                     row_array, old_rowloc_array, new_rowloc_array));
1:     }
1: 
1:     /**
1:      * Fetch the next N rows from the table.
1:      * <p>
1:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private int fetchRowsForCompress(
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           oldrowloc_array,
1:     RowLocation[]           newrowloc_array)
1:         throws StandardException
1: 	{
1:         int                     ret_row_count           = 0;
1:         DataValueDescriptor[]   fetch_row               = null;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(row_array != null);
1:             SanityManager.ASSERT(row_array[0] != null,
1:                     "first array slot in fetchNextGroup() must be non-null.");
1:         }
1: 
1:         if (getScanState() == SCAN_INPROGRESS)
1:         {
1:             positionAtResumeScan(scan_position);
1:         }
1:         else if (getScanState() == SCAN_INIT)
1:         {
1:             // For first implementation of defragment use a conservative
1:             // approach, only move rows from the last "number of free pages"
1:             // of the container.  Should always at least be able to empty
1:             // that number of pages.
1:             SpaceInfo info = 
1:                 open_conglom.getContainer().getSpaceInfo();
1: 
1:             pagenum_to_start_moving_rows = info.getNumAllocatedPages();
1: 
1:             positionAtStartForForwardScan(scan_position);
1:         }
1:         else if (getScanState() == SCAN_HOLD_INPROGRESS)
1:         {
1:             open_conglom.reopen();
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     scan_position.current_rh != null, this.toString()); 
1:             }
1: 
1:             // reposition the scan at the row just before the next one to 
1:             // return.
1:             // This routine handles the mess of repositioning if the row or 
1:             // the page has disappeared. This can happen if a lock was not 
1:             // held on the row while not holding the latch.
1:             open_conglom.latchPageAndRepositionScan(scan_position);
1: 
1:             setScanState(SCAN_INPROGRESS);
1:         }
1:         else if (getScanState() == SCAN_HOLD_INIT)
1:         {
1:             open_conglom.reopen();
1: 
1:             positionAtStartForForwardScan(scan_position);
1: 
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(getScanState() == SCAN_DONE);
1: 
1:             return(0);
1:         }
1: 
1:         // At this point:
1:         // scan_position.current_page is latched.  
1:         // scan_position.current_slot is the slot on scan_position.current_page
1:         // just before the "next" record this routine should process.
1: 
1:         // loop through successive pages and successive slots on those
1:         // pages.  Stop when either the last page is reached 
1:         // (scan_position.current_page will be null).  
1:         // Along the way apply qualifiers to skip rows which don't qualify.
1: 
1: 		while (scan_position.current_page != null)
1: 		{
1: 			while ((scan_position.current_slot + 1) < 
1:                     scan_position.current_page.recordCount())
1: 			{
1:                 // Allocate a new row to read the row into.
1:                 if (fetch_row == null)
1:                 {
1:                      // point at allocated row in array if one exists.
1:                     if (row_array[ret_row_count] == null)
1:                     {
1:                         row_array[ret_row_count] = 
0:                           open_conglom.getRuntimeMem().get_row_for_export();
1:                     }
1: 
1:                     fetch_row = row_array[ret_row_count];
1:                 }
1: 
1:                 // move scan current position forward.
1:                 scan_position.positionAtNextSlot();
1: 
1:                 this.stat_numrows_visited++;
1: 
1:                 if (scan_position.current_page.isDeletedAtSlot(
1:                         scan_position.current_slot))
1:                 {
1:                     // At this point assume table level lock, and that this
1:                     // transcation did not delete the row, so any
1:                     // deleted row must be a committed deleted row which can
0:                     // be purged.
1:                     scan_position.current_page.purgeAtSlot(
1:                         scan_position.current_slot, 1, false);
1: 
1:                     // raw store shuffles following rows down, so 
1:                     // postion the scan at previous slot, so next trip
1:                     // through loop will pick up correct row.
1:                     scan_position.positionAtPrevSlot();
1:                     continue;
1:                 }
1: 
1:                 if (scan_position.current_page.getPageNumber() > 
1:                         pagenum_to_start_moving_rows)
1:                 {
1:                     // Give raw store a chance to move the row for compression
1:                     RecordHandle[] old_handle = new RecordHandle[1];
1:                     RecordHandle[] new_handle = new RecordHandle[1];
1:                     long[]         new_pageno = new long[1];
1: 
1:                     if (scan_position.current_page.moveRecordForCompressAtSlot(
1:                             scan_position.current_slot,
1:                             fetch_row,
1:                             old_handle,
1:                             new_handle) == 1)
1:                     {
1:                         // raw store moved the row, so bump the row count but 
1:                         // postion the scan at previous slot, so next trip
1:                         // through loop will pick up correct row.
1:                         // The subsequent rows will have been moved forward
1:                         // to take place of moved row.
1:                         scan_position.positionAtPrevSlot();
1: 
1:                         ret_row_count++;
1:                         stat_numrows_qualified++;
1: 
1: 
1:                         setRowLocationArray(
1:                             oldrowloc_array, ret_row_count - 1, old_handle[0]);
1:                         setRowLocationArray(
1:                             newrowloc_array, ret_row_count - 1, new_handle[0]);
1: 
1:                         fetch_row = null;
1: 
1:                     }
1:                 }
1: 			}
1: 
1:             this.stat_numpages_visited++;
1: 
1:             if (scan_position.current_page.recordCount() == 0)
1:             {
1:                 // need to set the scan position before removing page
1:                 scan_position.current_pageno = 
1:                     scan_position.current_page.getPageNumber();
1: 
1:                 open_conglom.getContainer().removePage(
1:                     scan_position.current_page);
1: 
1:                 // removePage unlatches the page, and page not available
1:                 // again until after commit.
1:                 scan_position.current_page = null;
1:             }
1:             else
1:             {
1:                 positionAfterThisPage(scan_position);
1:                 scan_position.unlatch();
1:             }
1: 
1: 
1:             if (ret_row_count > 0)
1:             {
1:                 // rows were moved on this page, give caller a chance to
1:                 // process those and free up access to the table.
1:                 return(ret_row_count);
1:             }
1:             else
1:             {
1:                 // no rows were moved so go ahead and commit the transaction
1:                 // to allow other threads a chance at table.  Compress does
1:                 // need to sync as long as transaction either completely 
1:                 // commits or backs out, either is fine.
1:                 /*
1:                 open_conglom.getXactMgr().commitNoSync(
1:                     TransactionController.RELEASE_LOCKS);
1:                 open_conglom.reopen();
1:                 */
1:                 positionAtResumeScan(scan_position);
1: 
1:             }
1: 		}
1: 
1:         // Reached last page of scan.
1:         positionAtDoneScan(scan_position);
1: 
1:         // we need to decrement when we stop scan at the end of the table.
1:         this.stat_numpages_visited--;
1: 
1: 		return(ret_row_count);
1:     }
1: 
1:     /**
1:      * Reposition the scan upon entering the fetchRows loop.
1:      * <p>
1:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
1:      * Do work necessary to look at rows in the current page of the scan.
1:      * <p>
1:      * The default implementation uses a record handle to maintain a scan
1:      * position.  It will get the latch again on the current
1:      * scan position and set the slot to the current record handle.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtResumeScan(
1:     RowPosition pos)
1: 		throws StandardException
1:     {
1:         // reposition the scan at the row just before the next one to return.
1:         // This routine handles the mess of repositioning if the row or the
1:         // page has disappeared. This can happen if a lock was not held on the
1:         // row while not holding the latch.
1:         open_conglom.latchPageAndRepositionScan(scan_position);
1:     }
1: 
1:     /**
1:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
1:      * <p>
1:      * This routine is called to move the scan from SCAN_INIT to 
1:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
1:      * that scan_position is set such that calling the generic 
1:      * scan loop will reach the first row of the scan.  Note that this
1:      * usually means setting the scan_postion to one before the 1st 
1:      * row to be returned.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected void positionAtStartForForwardScan(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         if (pos.current_rh == null)
1:         {
1:             // 1st positioning of scan (delayed from openScan).  Do not
1:             // compress the first page, there is no previous page to move
1:             // rows to, and moving the special Heap metadata row from the
1:             // first page would cause problems.  Setting to next page is
1:             // why this scan overrides generic implementation.
1:             pos.current_page = 
1:                 open_conglom.getContainer().getNextPage(
1:                     ContainerHandle.FIRST_PAGE_NUMBER);
1: 
1:             // set up for scan to continue at beginning of page following
1:             // the first page of the container.
1:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
1:         }
1:         else
1:         {
1:             // 1st positioning of scan following a reopenScanByRowLocation
1: 
1:             // reposition the scan at the row just before the next one to 
1:             // return.  This routine handles the mess of repositioning if the 
1:             // row or the page has disappeared. This can happen if a lock was 
1:             // not held on the row while not holding the latch.
1:             open_conglom.latchPageAndRepositionScan(pos);
1: 
1:             // set up for scan to at the specified record handle (position one
1:             // before it so that the loop increment and find it).
1:             pos.current_slot -= 1;
1:         }
1: 
1:         pos.current_rh              = null;
1:         this.stat_numpages_visited  = 1;
1:         this.setScanState(SCAN_INPROGRESS);
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Set scan position to just after current page.
1:      * <p>
1:      * Used to set the position of the scan if a record handle is not
1:      * avaliable.  In this case current_rh will be set to null, and 
1:      * current_pageno will be set to the current page number.
1:      * On resume of the scan, the scan will be set to just before the first
1:      * row returned form a getNextPage(current_pageno) call.
1:      * <p>
1:      * A positionAtResumeScan(scan_position) is necessary to continue the
1:      * scan after this call.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private void positionAfterThisPage(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         pos.current_rh = null;
1:         pos.current_pageno = pos.current_page.getPageNumber();
1:     }
1: 
1: 	/*
1: 	** Methods of ScanManager
1: 	*/
1: 
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
0: import org.apache.derby.iapi.types.RowLocation;
0: /**
1:  * A heap scan object represents an instance of a scan on a heap conglomerate.
1:  */
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1:             reopenAfterEndTransaction();
/////////////////////////////////////////////////////////////////////////
1:             reopenAfterEndTransaction();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.impl.store.access.heap.HeapScan
0: 
0:    Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0: */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: 
0: /**
0: 
0:   A heap scan object represents an instance of an scan on a heap conglomerate.
0: 
0: **/
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.GenericScanController;
0: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.util.Hashtable;
0: import java.util.Vector;
0: 
0: class HeapCompressScan 
0:     extends HeapScan
0: {
0: 
0:     /**************************************************************************
0:      * Constants of HeapScan
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Fields of HeapScan
0:      **************************************************************************
0:      */
0:     private long pagenum_to_start_moving_rows = -1;
0: 
0: 
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	 ** The only constructor for a HeapCompressScan returns a scan in the
0: 	 ** closed state, the caller must call open.
0: 	 **/
0: 	
0: 	public HeapCompressScan()
0: 	{
0: 	}
0: 
0:     /**************************************************************************
0:      * Protected override implementation of routines in
0:      *     GenericController class:
0:      **************************************************************************
0:      */
0: 
0:     public int fetchNextGroup(
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           old_rowloc_array,
0:     RowLocation[]           new_rowloc_array)
0:         throws StandardException
0: 	{
0:         return(fetchRowsForCompress(
0:                     row_array, old_rowloc_array, new_rowloc_array));
0:     }
0: 
0:     /**
0:      * Fetch the next N rows from the table.
0:      * <p>
0:      * Utility routine used by both fetchSet() and fetchNextGroup().
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private int fetchRowsForCompress(
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           oldrowloc_array,
0:     RowLocation[]           newrowloc_array)
0:         throws StandardException
0: 	{
0:         int                     ret_row_count           = 0;
0:         DataValueDescriptor[]   fetch_row               = null;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(row_array != null);
0:             SanityManager.ASSERT(row_array[0] != null,
0:                     "first array slot in fetchNextGroup() must be non-null.");
0:         }
0: 
0:         if (getScanState() == SCAN_INPROGRESS)
0:         {
0:             positionAtResumeScan(scan_position);
0:         }
0:         else if (getScanState() == SCAN_INIT)
0:         {
0:             // For first implementation of defragment use a conservative
0:             // approach, only move rows from the last "number of free pages"
0:             // of the container.  Should always at least be able to empty
0:             // that number of pages.
0:             SpaceInfo info = 
0:                 open_conglom.getContainer().getSpaceInfo();
0: 
0:             pagenum_to_start_moving_rows = info.getNumAllocatedPages();
0: 
0:             positionAtStartForForwardScan(scan_position);
0:         }
0:         else if (getScanState() == SCAN_HOLD_INPROGRESS)
0:         {
0:             open_conglom.reopen();
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     scan_position.current_rh != null, this.toString()); 
0:             }
0: 
0:             // reposition the scan at the row just before the next one to 
0:             // return.
0:             // This routine handles the mess of repositioning if the row or 
0:             // the page has disappeared. This can happen if a lock was not 
0:             // held on the row while not holding the latch.
0:             open_conglom.latchPageAndRepositionScan(scan_position);
0: 
0:             setScanState(SCAN_INPROGRESS);
0:         }
0:         else if (getScanState() == SCAN_HOLD_INIT)
0:         {
0:             open_conglom.reopen();
0: 
0:             positionAtStartForForwardScan(scan_position);
0: 
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(getScanState() == SCAN_DONE);
0: 
0:             return(0);
0:         }
0: 
0:         // At this point:
0:         // scan_position.current_page is latched.  
0:         // scan_position.current_slot is the slot on scan_position.current_page
0:         // just before the "next" record this routine should process.
0: 
0:         // loop through successive pages and successive slots on those
0:         // pages.  Stop when either the last page is reached 
0:         // (scan_position.current_page will be null).  
0:         // Along the way apply qualifiers to skip rows which don't qualify.
0: 
0: 		while (scan_position.current_page != null)
0: 		{
0: 			while ((scan_position.current_slot + 1) < 
0:                     scan_position.current_page.recordCount())
0: 			{
0:                 // Allocate a new row to read the row into.
0:                 if (fetch_row == null)
0:                 {
0:                      // point at allocated row in array if one exists.
0:                     if (row_array[ret_row_count] == null)
0:                     {
0:                         row_array[ret_row_count] = 
0:                           open_conglom.getRuntimeMem().get_row_for_export();
0:                     }
0: 
0:                     fetch_row = row_array[ret_row_count];
0:                 }
0: 
0:                 // move scan current position forward.
0:                 scan_position.positionAtNextSlot();
0: 
0:                 this.stat_numrows_visited++;
0: 
0:                 if (scan_position.current_page.isDeletedAtSlot(
0:                         scan_position.current_slot))
0:                 {
0:                     // At this point assume table level lock, and that this
0:                     // transcation did not delete the row, so any
0:                     // deleted row must be a committed deleted row which can
0:                     // be purged.
0:                     scan_position.current_page.purgeAtSlot(
0:                         scan_position.current_slot, 1, false);
0: 
0:                     // raw store shuffles following rows down, so 
0:                     // postion the scan at previous slot, so next trip
0:                     // through loop will pick up correct row.
0:                     scan_position.positionAtPrevSlot();
0:                     continue;
0:                 }
0: 
0:                 if (scan_position.current_page.getPageNumber() > 
0:                         pagenum_to_start_moving_rows)
0:                 {
0:                     // Give raw store a chance to move the row for compression
0:                     RecordHandle[] old_handle = new RecordHandle[1];
0:                     RecordHandle[] new_handle = new RecordHandle[1];
0:                     long[]         new_pageno = new long[1];
0: 
0:                     if (scan_position.current_page.moveRecordForCompressAtSlot(
0:                             scan_position.current_slot,
0:                             fetch_row,
0:                             old_handle,
0:                             new_handle) == 1)
0:                     {
0:                         // raw store moved the row, so bump the row count but 
0:                         // postion the scan at previous slot, so next trip
0:                         // through loop will pick up correct row.
0:                         // The subsequent rows will have been moved forward
0:                         // to take place of moved row.
0:                         scan_position.positionAtPrevSlot();
0: 
0:                         ret_row_count++;
0:                         stat_numrows_qualified++;
0: 
0: 
0:                         setRowLocationArray(
0:                             oldrowloc_array, ret_row_count - 1, old_handle[0]);
0:                         setRowLocationArray(
0:                             newrowloc_array, ret_row_count - 1, new_handle[0]);
0: 
0:                         fetch_row = null;
0: 
0:                     }
0:                 }
0: 			}
0: 
0:             this.stat_numpages_visited++;
0: 
0:             if (scan_position.current_page.recordCount() == 0)
0:             {
0:                 // need to set the scan position before removing page
0:                 scan_position.current_pageno = 
0:                     scan_position.current_page.getPageNumber();
0: 
0:                 open_conglom.getContainer().removePage(
0:                     scan_position.current_page);
0: 
0:                 // removePage unlatches the page, and page not available
0:                 // again until after commit.
0:                 scan_position.current_page = null;
0:             }
0:             else
0:             {
0:                 positionAfterThisPage(scan_position);
0:                 scan_position.unlatch();
0:             }
0: 
0: 
0:             if (ret_row_count > 0)
0:             {
0:                 // rows were moved on this page, give caller a chance to
0:                 // process those and free up access to the table.
0:                 return(ret_row_count);
0:             }
0:             else
0:             {
0:                 // no rows were moved so go ahead and commit the transaction
0:                 // to allow other threads a chance at table.  Compress does
0:                 // need to sync as long as transaction either completely 
0:                 // commits or backs out, either is fine.
0:                 /*
0:                 open_conglom.getXactMgr().commitNoSync(
0:                     TransactionController.RELEASE_LOCKS);
0:                 open_conglom.reopen();
0:                 */
0:                 positionAtResumeScan(scan_position);
0: 
0:             }
0: 		}
0: 
0:         // Reached last page of scan.
0:         positionAtDoneScan(scan_position);
0: 
0:         // we need to decrement when we stop scan at the end of the table.
0:         this.stat_numpages_visited--;
0: 
0: 		return(ret_row_count);
0:     }
0: 
0:     /**
0:      * Reposition the scan upon entering the fetchRows loop.
0:      * <p>
0:      * Called upon entering fetchRows() while in the SCAN_INPROGRESS state.
0:      * Do work necessary to look at rows in the current page of the scan.
0:      * <p>
0:      * The default implementation uses a record handle to maintain a scan
0:      * position.  It will get the latch again on the current
0:      * scan position and set the slot to the current record handle.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtResumeScan(
0:     RowPosition pos)
0: 		throws StandardException
0:     {
0:         // reposition the scan at the row just before the next one to return.
0:         // This routine handles the mess of repositioning if the row or the
0:         // page has disappeared. This can happen if a lock was not held on the
0:         // row while not holding the latch.
0:         open_conglom.latchPageAndRepositionScan(scan_position);
0:     }
0: 
0:     /**
0:      * Move the scan from SCAN_INIT to SCAN_INPROGRESS.
0:      * <p>
0:      * This routine is called to move the scan from SCAN_INIT to 
0:      * SCAN_INPROGRESS.  Upon return from this routine it is expected
0:      * that scan_position is set such that calling the generic 
0:      * scan loop will reach the first row of the scan.  Note that this
0:      * usually means setting the scan_postion to one before the 1st 
0:      * row to be returned.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected void positionAtStartForForwardScan(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         if (pos.current_rh == null)
0:         {
0:             // 1st positioning of scan (delayed from openScan).  Do not
0:             // compress the first page, there is no previous page to move
0:             // rows to, and moving the special Heap metadata row from the
0:             // first page would cause problems.  Setting to next page is
0:             // why this scan overrides generic implementation.
0:             pos.current_page = 
0:                 open_conglom.getContainer().getNextPage(
0:                     ContainerHandle.FIRST_PAGE_NUMBER);
0: 
0:             // set up for scan to continue at beginning of page following
0:             // the first page of the container.
0:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
0:         }
0:         else
0:         {
0:             // 1st positioning of scan following a reopenScanByRowLocation
0: 
0:             // reposition the scan at the row just before the next one to 
0:             // return.  This routine handles the mess of repositioning if the 
0:             // row or the page has disappeared. This can happen if a lock was 
0:             // not held on the row while not holding the latch.
0:             open_conglom.latchPageAndRepositionScan(pos);
0: 
0:             // set up for scan to at the specified record handle (position one
0:             // before it so that the loop increment and find it).
0:             pos.current_slot -= 1;
0:         }
0: 
0:         pos.current_rh              = null;
0:         this.stat_numpages_visited  = 1;
0:         this.setScanState(SCAN_INPROGRESS);
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Set scan position to just after current page.
0:      * <p>
0:      * Used to set the position of the scan if a record handle is not
0:      * avaliable.  In this case current_rh will be set to null, and 
0:      * current_pageno will be set to the current page number.
0:      * On resume of the scan, the scan will be set to just before the first
0:      * row returned form a getNextPage(current_pageno) call.
0:      * <p>
0:      * A positionAtResumeScan(scan_position) is necessary to continue the
0:      * scan after this call.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private void positionAfterThisPage(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         pos.current_rh = null;
0:         pos.current_pageno = pos.current_page.getPageNumber();
0:     }
0: 
0: 	/*
0: 	** Methods of ScanManager
0: 	*/
0: 
0: }
============================================================================