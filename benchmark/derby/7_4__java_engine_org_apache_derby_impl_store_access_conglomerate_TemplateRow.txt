1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.conglomerate.TemplateRow
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
7:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.conglomerate;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:0c91b19: import org.apache.derby.iapi.services.io.ArrayUtil;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:722a889: 
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: 
1:722a889: import org.apache.derby.iapi.store.raw.Transaction;
1:722a889: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:722a889: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.SQLLongint;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: public final class TemplateRow
4:eac0369: {
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors of TemplateRow
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	private TemplateRow() {
4:eac0369: 	}
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369: 
3:eac0369:     /**
1:eac0369:      * Allocate new objects to array based on format id's and column_list.
1:eac0369:      * <p>
5:eac0369:      *
1:8758a25:      * @param num_cols_to_allocate  The number of columns to allocate for array.
1:8758a25:      * @param column_list           description of partial set of columns to 
1:8758a25:      *                              built as described in RowUtil.  If null do 
1:8758a25:      *                              all the columns.
1:8758a25:      * @param format_ids            An array of format ids representing every 
1:8758a25:      *                              column in the table.  column_list describes
1:8758a25:      *                              which of these columns to populate into the 
1:8758a25:      *                              columns array.
1:eac0369:      *
2:eac0369: 	 * @exception  StandardException  Standard exception policy.
2:eac0369:      **/
1:eac0369:     private static DataValueDescriptor[] allocate_objects(
1:722a889:     Transaction         rawtran,
1:8758a25:     int                 num_cols_to_allocate,
1:8758a25:     FormatableBitSet    column_list,
1:722a889:     int[]               format_ids,
1:722a889:     int[]               collation_ids)
2:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         DataValueDescriptor[] ret_row = 
1:eac0369:             new DataValueDescriptor[num_cols_to_allocate];
1:eac0369:         int         num_cols = 
1:eac0369:             (column_list == null ? format_ids.length : column_list.size());
1:eac0369: 
1:722a889:         DataValueFactory dvf = rawtran.getDataValueFactory();
1:722a889: 
1:eac0369:         for (int i = 0; i < num_cols; i++)
1:eac0369:         {
1:eac0369:             // does caller want this column?
1:eac0369:             if ((column_list != null) && (!column_list.get(i)))
1:eac0369:             {
1:eac0369:                 // no - column should be skipped.
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // yes - create the column 
1:eac0369: 
2:eac0369:                 // get empty instance of object identified by the format id.
1:722a889:                 ret_row[i] = dvf.getNull(format_ids[i], collation_ids[i]);
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     DataValueDescriptor o = ret_row[i];
1:eac0369: 
1:eac0369:                     if (o == null)
1:eac0369:                     {
1:eac0369:                         SanityManager.THROWASSERT(
1:722a889:                         "obj from DataValueFactory.newNull(" +
1:722a889:                         format_ids[i] + ", " + collation_ids[i] + ") null." +
1:eac0369:                         ";src column position = "  + i              +
1:eac0369:                         ";dest column position = " + i  + 
1:eac0369:                         ";num_cols = "             + num_cols       +
1:eac0369:                         ";format_ids.length = "    + format_ids.length);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     if ( ! (o instanceof Storable))
1:eac0369:                         SanityManager.THROWASSERT(
1:eac0369:                             "object:(" + o.getClass() +"):(" + o + 
1:eac0369:                             ") not an instanceof Storable");
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_row);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /* Public Methods of This class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Constuctor for creating a template row which stores n SQLLongint's
1:eac0369:     **/
1:eac0369: 	public static DataValueDescriptor[] newU8Row(int nkeys)
1:eac0369: 	{
1:eac0369:         DataValueDescriptor[] columns = new DataValueDescriptor[nkeys];
1:eac0369: 
1:eac0369:         for (int i = 0; i < columns.length; i++)
1:eac0369:         {
1:eac0369:             columns[i] = new SQLLongint(Long.MIN_VALUE);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return columns;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Generate an "empty" row to match the format id specification.
1:eac0369:      * <p>
1:eac0369:      * Generate an array of new'd objects matching the format id specification
1:eac0369:      * passed in.  This routine is mostly used by the btree code to generate
1:eac0369:      * temporary rows needed during operations like split.  It is more
1:eac0369:      * efficient to allocate new objects based on the old object vs. calling
1:eac0369:      * the Monitor.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:8758a25:      * @param template      An array which represents a row as described in
1:8758a25:      *                      RowUtil.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:8758a25: 	 * @return The new row.
1:8758a25:      *
1:eac0369:      * @see RowUtil
1:eac0369:      **/
1:eac0369:     public static DataValueDescriptor[] newRow(
1:eac0369:     DataValueDescriptor[]    template)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         DataValueDescriptor[] columns = 
1:eac0369:             new DataValueDescriptor[template.length];
1:eac0369: 
1:6404cde:         for (int i = template.length; i-- > 0 ;)
1:eac0369:         {
1:6404cde:             // get empty instance of object identified by the format id.
1:6404cde:             columns[i] = template[i].getNewNull();
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return columns;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Generate an "empty" row to match the format id specification.
1:eac0369:      * <p>
1:eac0369:      * Generate an array of new'd objects matching the format id specification
1:eac0369:      * passed in.  This routine is mostly used by the btree code to generate
1:eac0369:      * temporary rows needed during operations like split.
1:eac0369:      * <p>
1:eac0369:      *
2:eac0369: 	 * @return The new row.
1:eac0369:      *
2:eac0369:      * @param format_ids an array of format id's, one per column in row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static DataValueDescriptor[] newRow(
1:722a889:     Transaction          rawtran,
2:eac0369:     FormatableBitSet     column_list,
1:722a889:     int[]                format_ids,
1:722a889:     int[]                collation_ids) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:722a889:         return(
1:722a889:             allocate_objects(
1:722a889:                 rawtran, format_ids.length, column_list, 
1:722a889:                 format_ids, collation_ids));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Generate an "empty" row to match the format id + coluumn specification.
1:eac0369:      * <p>
1:eac0369:      * Generate an array of new'd objects matching the format id specification
1:eac0369:      * passed in, and the column passed in.  The new row is first made up of
1:eac0369:      * columns matching the format ids, and then followed by one other column
1:eac0369:      * matching the column passed in.  This routine is mostly used by the 
1:eac0369:      * btree code to generate temporary branch rows needed during operations 
1:eac0369:      * like split.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The new row.
1:eac0369:      *
1:eac0369:      * @param format_ids an array of format id's, one per column in row.
1:eac0369:      * @param page_ptr   The object to place in the last column of the template.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static DataValueDescriptor[] newBranchRow(
1:722a889:     Transaction         rawtran,
1:eac0369:     int[]               format_ids,
1:722a889:     int[]               collation_ids,
1:eac0369:     DataValueDescriptor page_ptr) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // allocate an object array with the number of columns in the template
1:eac0369:         // row (ie. number of columns in the leaf row) + one column to hold
1:eac0369:         // the page pointer in the branch row.
1:eac0369:         DataValueDescriptor[] columns = 
1:eac0369:             allocate_objects(
1:722a889:                 rawtran,
1:722a889:                 format_ids.length + 1, 
1:722a889:                 (FormatableBitSet) null, format_ids, collation_ids);
1:eac0369: 
1:eac0369:         // tack on the page pointer to the extra column allocated onto the 
1:eac0369:         // end of the row built from a leafrow template.
1:eac0369:         columns[format_ids.length] = page_ptr;
1:eac0369: 
1:eac0369: 		return(columns);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
2:eac0369:      * Check that columns in the row conform to a set of format id's, 
2:eac0369:      * both in number and type.
1:eac0369:      *
2:eac0369: 	 * @return boolean indicating if template matches format id's
1:eac0369:      *
2:eac0369:      * @param format_ids array of format ids which are the types of cols in row
2:eac0369:      * @param row        the array of columns that make up the row.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	static public boolean checkColumnTypes(
1:0c91b19:     DataValueFactory        dvf,
2:eac0369:     int[]                   format_ids, 
1:0c91b19:     int[]                   collation_ids,
2:eac0369:     DataValueDescriptor[]   row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
2:eac0369:         boolean ret_val = true;
1:eac0369: 
1:eac0369:         while (true)
1:eac0369:         {
1:eac0369:             int nCols = row.length;
1:eac0369:             if (format_ids.length != row.length)
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "format_ids[] length (" + format_ids.length +
1:eac0369:                         ") expected to be = row length (" + row.length +  ")");
1:eac0369:                 }
1:eac0369:                 ret_val = false;
1:eac0369:                 break;
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 Object  column;
1:eac0369:                 Object  column_template;
1:eac0369: 
1:eac0369:                 for (int colid = 0; colid < nCols; colid++)
1:eac0369:                 {
1:eac0369:                     column = row[colid];
1:eac0369: 
1:eac0369:                     if (column == null)
1:eac0369:                     {
1:eac0369:                         SanityManager.THROWASSERT(
1:eac0369:                             "column[" + colid + "] is null");
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     column_template = 
1:0c91b19:                         dvf.getNull(format_ids[colid], collation_ids[colid]);
1:eac0369: 
1:eac0369: 
1:eac0369:                     // is this the right check?
1:eac0369:                     if (column.getClass() != column_template.getClass())
1:eac0369:                     {
1:eac0369:                         SanityManager.DEBUG_PRINT(
1:eac0369:                             "check", "row = " +  RowUtil.toString(row));
1:eac0369: 
1:eac0369:                         SanityManager.THROWASSERT(
1:0c91b19:                             "input column["+colid+"] (" + column.getClass() +
1:0c91b19:                             ") did not match expected template class (" +
1:eac0369:                             column_template.getClass() + ")" +
1:0c91b19:                             "\ncolumn value = " + column +
1:0c91b19:                             "\nformat_ids = " + 
1:0c91b19:                                 ArrayUtil.toString(format_ids) +
1:0c91b19:                             "\ncollation  = " + 
1:0c91b19:                                 ArrayUtil.toString(collation_ids));
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             break;
1:eac0369:         }
1:eac0369: 
2:eac0369:         return(ret_val);
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:f9cb888
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a7db9df
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:0c91b19
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.ArrayUtil;
/////////////////////////////////////////////////////////////////////////
1:     DataValueFactory        dvf,
1:     int[]                   collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                         dvf.getNull(format_ids[colid], collation_ids[colid]);
/////////////////////////////////////////////////////////////////////////
1:                             "input column["+colid+"] (" + column.getClass() +
1:                             ") did not match expected template class (" +
1:                             "\ncolumn value = " + column +
1:                             "\nformat_ids = " + 
1:                                 ArrayUtil.toString(format_ids) +
1:                             "\ncollation  = " + 
1:                                 ArrayUtil.toString(collation_ids));
commit:722a889
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueFactory;
/////////////////////////////////////////////////////////////////////////
1:     Transaction         rawtran,
1:     int[]               format_ids,
1:     int[]               collation_ids)
/////////////////////////////////////////////////////////////////////////
1:         DataValueFactory dvf = rawtran.getDataValueFactory();
1: 
/////////////////////////////////////////////////////////////////////////
1:                 ret_row[i] = dvf.getNull(format_ids[i], collation_ids[i]);
/////////////////////////////////////////////////////////////////////////
1:                         "obj from DataValueFactory.newNull(" +
1:                         format_ids[i] + ", " + collation_ids[i] + ") null." +
/////////////////////////////////////////////////////////////////////////
1:     Transaction          rawtran,
1:     int[]                format_ids,
1:     int[]                collation_ids) 
1:         return(
1:             allocate_objects(
1:                 rawtran, format_ids.length, column_list, 
1:                 format_ids, collation_ids));
/////////////////////////////////////////////////////////////////////////
1:     Transaction         rawtran,
1:     int[]               collation_ids,
/////////////////////////////////////////////////////////////////////////
1:                 rawtran,
1:                 format_ids.length + 1, 
1:                 (FormatableBitSet) null, format_ids, collation_ids);
commit:6404cde
/////////////////////////////////////////////////////////////////////////
1:         for (int i = template.length; i-- > 0 ;)
1:             // get empty instance of object identified by the format id.
1:             columns[i] = template[i].getNewNull();
/////////////////////////////////////////////////////////////////////////
0:     FormatableBitSet        validColumns,
commit:8758a25
/////////////////////////////////////////////////////////////////////////
1:      * @param num_cols_to_allocate  The number of columns to allocate for array.
1:      * @param column_list           description of partial set of columns to 
1:      *                              built as described in RowUtil.  If null do 
1:      *                              all the columns.
1:      * @param format_ids            An array of format ids representing every 
1:      *                              column in the table.  column_list describes
1:      *                              which of these columns to populate into the 
1:      *                              columns array.
1:     int                 num_cols_to_allocate,
1:     FormatableBitSet    column_list,
0:     int[]               format_ids)
/////////////////////////////////////////////////////////////////////////
1:      * @param template      An array which represents a row as described in
1:      *                      RowUtil.
1: 	 * @return The new row.
1:      *
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.conglomerate.TemplateRow
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.conglomerate;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.SQLLongint;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: public final class TemplateRow
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/*
1: 	** Constructors of TemplateRow
1: 	*/
1: 
1: 	private TemplateRow() {
1: 	}
1: 
1:     /* Private/Protected methods of This class: */
1: 
1: 
1:     /**
1:      * Allocate new objects to array based on format id's and column_list.
1:      * <p>
1:      *
0:      * @param column_list description of partial set of columns to built as
0:      *                    described in RowUtil.  If null do all the columns.
0:      * @param format_ids  An array of format ids representing every column
0:      *                    in the table.  column_list describes which of these
0:      *                    columns to populate into the columns array.
0:      * @param columns     The array to place the newly allocated objects into.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private static DataValueDescriptor[] allocate_objects(
0:     int         num_cols_to_allocate,
1:     FormatableBitSet     column_list,
0:     int[]       format_ids)
1: 		throws StandardException
1:     {
0:         int         dest_pos = 0;
1: 
1:         DataValueDescriptor[] ret_row = 
1:             new DataValueDescriptor[num_cols_to_allocate];
1:         int         num_cols = 
1:             (column_list == null ? format_ids.length : column_list.size());
1: 
1:         for (int i = 0; i < num_cols; i++)
1:         {
1:             // does caller want this column?
1:             if ((column_list != null) && (!column_list.get(i)))
1:             {
1:                 // no - column should be skipped.
1:             }
1:             else
1:             {
1:                 // yes - create the column 
1: 
1:                 // get empty instance of object identified by the format id.
0:                 ret_row[i] = (DataValueDescriptor) 
0:                     Monitor.newInstanceFromIdentifier(format_ids[i]);
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     DataValueDescriptor o = ret_row[i];
1: 
1:                     if (o == null)
1:                     {
1:                         SanityManager.THROWASSERT(
0:                         "obj from Monitor.newInstanceFromIdentifier() null." +
1:                         ";src column position = "  + i              +
1:                         ";dest column position = " + i  + 
1:                         ";num_cols = "             + num_cols       +
1:                         ";format_ids.length = "    + format_ids.length);
1: 
1:                     }
1: 
1:                     if ( ! (o instanceof Storable))
1:                         SanityManager.THROWASSERT(
1:                             "object:(" + o.getClass() +"):(" + o + 
1:                             ") not an instanceof Storable");
1:                 }
1:             }
1:         }
1: 
1:         return(ret_row);
1:     }
1: 
1:     /* Public Methods of This class: */
1: 
1:     /**
1:     Constuctor for creating a template row which stores n SQLLongint's
1:     **/
1: 	public static DataValueDescriptor[] newU8Row(int nkeys)
1: 	{
1:         DataValueDescriptor[] columns = new DataValueDescriptor[nkeys];
1: 
1:         for (int i = 0; i < columns.length; i++)
1:         {
1:             columns[i] = new SQLLongint(Long.MIN_VALUE);
1:         }
1: 
1: 		return columns;
1: 	}
1: 
1:     /**
1:      * Generate an "empty" row to match the format id specification.
1:      * <p>
1:      * Generate an array of new'd objects matching the format id specification
1:      * passed in.  This routine is mostly used by the btree code to generate
1:      * temporary rows needed during operations like split.  It is more
1:      * efficient to allocate new objects based on the old object vs. calling
1:      * the Monitor.
1:      * <p>
1:      *
1: 	 * @return The new row.
1:      *
0:      * @param column_list   A column list as described in RowUtil. Describes
0:      *                      which columns to pick out of the template and put
0:      *                      into returned newRow.  If null just pick all of
0:      *                      them.
1:      *
1:      * @param format_ids an array of format id's, one per column in row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see RowUtil
1:      **/
1:     public static DataValueDescriptor[] newRow(
1:     DataValueDescriptor[]    template)
1:         throws StandardException
1:     {
1:         DataValueDescriptor[] columns = 
1:             new DataValueDescriptor[template.length];
1: 
0:         try
1:         {
0:             for (int i = template.length; i-- > 0 ;)
1:             {
1:                 // get empty instance of object identified by the format id.
0:                 columns[i] = 
0:                     (DataValueDescriptor) template[i].getClass().newInstance();
1:             }
1:         }
0:         catch (Throwable t)
1:         {
0:             // RESOLVE - Dan is investigating ways to change the monitor
0:             // so that it provides the functionality required here, when
0:             // that happens I will just all the monitor and let any 
0:             // StandardError that come back just go on up.
0:             throw(StandardException.newException(
0:                     SQLState.CONGLOMERATE_TEMPLATE_CREATE_ERROR));
1:         }
1: 
1: 		return columns;
1:     }
1: 
1:     /**
1:      * Generate an "empty" row to match the format id specification.
1:      * <p>
1:      * Generate an array of new'd objects matching the format id specification
1:      * passed in.  This routine is mostly used by the btree code to generate
1:      * temporary rows needed during operations like split.
1:      * <p>
1:      *
1: 	 * @return The new row.
1:      *
1:      * @param format_ids an array of format id's, one per column in row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static DataValueDescriptor[] newRow(
1:     FormatableBitSet     column_list,
0:     int[]        format_ids) 
1:         throws StandardException
1:     {
0:         return(allocate_objects(format_ids.length, column_list, format_ids));
1:     }
1: 
1:     /**
1:      * Generate an "empty" row to match the format id + coluumn specification.
1:      * <p>
1:      * Generate an array of new'd objects matching the format id specification
1:      * passed in, and the column passed in.  The new row is first made up of
1:      * columns matching the format ids, and then followed by one other column
1:      * matching the column passed in.  This routine is mostly used by the 
1:      * btree code to generate temporary branch rows needed during operations 
1:      * like split.
1:      * <p>
1:      *
1: 	 * @return The new row.
1:      *
1:      * @param format_ids an array of format id's, one per column in row.
1:      * @param page_ptr   The object to place in the last column of the template.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static DataValueDescriptor[] newBranchRow(
1:     int[]               format_ids,
1:     DataValueDescriptor page_ptr) 
1:         throws StandardException
1:     {
1:         // allocate an object array with the number of columns in the template
1:         // row (ie. number of columns in the leaf row) + one column to hold
1:         // the page pointer in the branch row.
1:         DataValueDescriptor[] columns = 
1:             allocate_objects(
0:                 format_ids.length + 1, (FormatableBitSet) null, format_ids);
1: 
1:         // tack on the page pointer to the extra column allocated onto the 
1:         // end of the row built from a leafrow template.
1:         columns[format_ids.length] = page_ptr;
1: 
1: 		return(columns);
1:     }
1: 
1:     /**
1:      * Check that columns in the row conform to a set of format id's, 
1:      * both in number and type.
1:      *
1: 	 * @return boolean indicating if template matches format id's
1:      *
1:      * @param format_ids array of format ids which are the types of cols in row
1:      * @param row        the array of columns that make up the row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	static public boolean checkColumnTypes(
1:     int[]                   format_ids, 
1:     DataValueDescriptor[]   row)
1: 		throws StandardException
1: 	{
1:         boolean ret_val = true;
1: 
1:         while (true)
1:         {
1:             int nCols = row.length;
1:             if (format_ids.length != row.length)
1:             {
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "format_ids[] length (" + format_ids.length +
1:                         ") expected to be = row length (" + row.length +  ")");
1:                 }
1:                 ret_val = false;
1:                 break;
1:             }
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 Object  column;
1:                 Object  column_template;
1: 
1:                 for (int colid = 0; colid < nCols; colid++)
1:                 {
1:                     column = row[colid];
1: 
1:                     if (column == null)
1:                     {
1:                         SanityManager.THROWASSERT(
1:                             "column[" + colid + "] is null");
1:                     }
1: 
1:                     column_template = 
0:                         Monitor.newInstanceFromIdentifier(format_ids[colid]);
1: 
1: 
1:                     // is this the right check?
1:                     if (column.getClass() != column_template.getClass())
1:                     {
1:                         SanityManager.DEBUG_PRINT(
1:                             "check", "row = " +  RowUtil.toString(row));
1: 
1:                         SanityManager.THROWASSERT(
0:                             "column["+colid+"] (" + column.getClass() +
0:                             ") expected to be instanceof column_tempate() (" +
1:                             column_template.getClass() + ")" +
0:                             "column = " + column +
0:                             "row[colid] = " + row[colid]);
1:                     }
1:                 }
1:             }
1:             break;
1:         }
1: 
1:         return(ret_val);
1: 	}
1: 
1:     /**
1:      * Check that columns in the row conform to a set of format id's, 
1:      * both in number and type.
1:      *
1: 	 * @return boolean indicating if template matches format id's
1:      *
1:      * @param format_ids array of format ids which are the types of cols in row
1:      * @param row        the array of columns that make up the row.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	static public boolean checkPartialColumnTypes(
1:     int[]                   format_ids, 
0:     FormatableBitSet                 validColumns,
0:     int[]                   fieldStates,
1:     DataValueDescriptor[]   row)
1: 		throws StandardException
1: 	{
1:         boolean ret_val = true;
1: 
1:         return(ret_val);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.conglomerate;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.SQLLongint;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: public final class TemplateRow
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/*
0: 	** Constructors of TemplateRow
0: 	*/
0: 
0: 	private TemplateRow() {
0: 	}
0: 
0:     /* Private/Protected methods of This class: */
0: 
0: 
0:     /**
0:      * Allocate new objects to array based on format id's and column_list.
0:      * <p>
0:      *
0:      * @param column_list description of partial set of columns to built as
0:      *                    described in RowUtil.  If null do all the columns.
0:      * @param format_ids  An array of format ids representing every column
0:      *                    in the table.  column_list describes which of these
0:      *                    columns to populate into the columns array.
0:      * @param columns     The array to place the newly allocated objects into.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private static DataValueDescriptor[] allocate_objects(
0:     int         num_cols_to_allocate,
0:     FormatableBitSet     column_list,
0:     int[]       format_ids)
0: 		throws StandardException
0:     {
0:         int         dest_pos = 0;
0: 
0:         DataValueDescriptor[] ret_row = 
0:             new DataValueDescriptor[num_cols_to_allocate];
0:         int         num_cols = 
0:             (column_list == null ? format_ids.length : column_list.size());
0: 
0:         for (int i = 0; i < num_cols; i++)
0:         {
0:             // does caller want this column?
0:             if ((column_list != null) && (!column_list.get(i)))
0:             {
0:                 // no - column should be skipped.
0:             }
0:             else
0:             {
0:                 // yes - create the column 
0: 
0:                 // get empty instance of object identified by the format id.
0:                 ret_row[i] = (DataValueDescriptor) 
0:                     Monitor.newInstanceFromIdentifier(format_ids[i]);
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     DataValueDescriptor o = ret_row[i];
0: 
0:                     if (o == null)
0:                     {
0:                         SanityManager.THROWASSERT(
0:                         "obj from Monitor.newInstanceFromIdentifier() null." +
0:                         ";src column position = "  + i              +
0:                         ";dest column position = " + i  + 
0:                         ";num_cols = "             + num_cols       +
0:                         ";format_ids.length = "    + format_ids.length);
0: 
0:                     }
0: 
0:                     if ( ! (o instanceof Storable))
0:                         SanityManager.THROWASSERT(
0:                             "object:(" + o.getClass() +"):(" + o + 
0:                             ") not an instanceof Storable");
0:                 }
0:             }
0:         }
0: 
0:         return(ret_row);
0:     }
0: 
0:     /* Public Methods of This class: */
0: 
0:     /**
0:     Constuctor for creating a template row which stores n SQLLongint's
0:     **/
0: 	public static DataValueDescriptor[] newU8Row(int nkeys)
0: 	{
0:         DataValueDescriptor[] columns = new DataValueDescriptor[nkeys];
0: 
0:         for (int i = 0; i < columns.length; i++)
0:         {
0:             columns[i] = new SQLLongint(Long.MIN_VALUE);
0:         }
0: 
0: 		return columns;
0: 	}
0: 
0:     /**
0:      * Generate an "empty" row to match the format id specification.
0:      * <p>
0:      * Generate an array of new'd objects matching the format id specification
0:      * passed in.  This routine is mostly used by the btree code to generate
0:      * temporary rows needed during operations like split.  It is more
0:      * efficient to allocate new objects based on the old object vs. calling
0:      * the Monitor.
0:      * <p>
0:      *
0: 	 * @return The new row.
0:      *
0:      * @param column_list   A column list as described in RowUtil. Describes
0:      *                      which columns to pick out of the template and put
0:      *                      into returned newRow.  If null just pick all of
0:      *                      them.
0:      *
0:      * @param format_ids an array of format id's, one per column in row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see RowUtil
0:      **/
0:     public static DataValueDescriptor[] newRow(
0:     DataValueDescriptor[]    template)
0:         throws StandardException
0:     {
0:         DataValueDescriptor[] columns = 
0:             new DataValueDescriptor[template.length];
0: 
0:         try
0:         {
0:             for (int i = template.length; i-- > 0 ;)
0:             {
0:                 // get empty instance of object identified by the format id.
0:                 columns[i] = 
0:                     (DataValueDescriptor) template[i].getClass().newInstance();
0:             }
0:         }
0:         catch (Throwable t)
0:         {
0:             // RESOLVE - Dan is investigating ways to change the monitor
0:             // so that it provides the functionality required here, when
0:             // that happens I will just all the monitor and let any 
0:             // StandardError that come back just go on up.
0:             throw(StandardException.newException(
0:                     SQLState.CONGLOMERATE_TEMPLATE_CREATE_ERROR));
0:         }
0: 
0: 		return columns;
0:     }
0: 
0:     /**
0:      * Generate an "empty" row to match the format id specification.
0:      * <p>
0:      * Generate an array of new'd objects matching the format id specification
0:      * passed in.  This routine is mostly used by the btree code to generate
0:      * temporary rows needed during operations like split.
0:      * <p>
0:      *
0: 	 * @return The new row.
0:      *
0:      * @param format_ids an array of format id's, one per column in row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static DataValueDescriptor[] newRow(
0:     FormatableBitSet     column_list,
0:     int[]        format_ids) 
0:         throws StandardException
0:     {
0:         return(allocate_objects(format_ids.length, column_list, format_ids));
0:     }
0: 
0:     /**
0:      * Generate an "empty" row to match the format id + coluumn specification.
0:      * <p>
0:      * Generate an array of new'd objects matching the format id specification
0:      * passed in, and the column passed in.  The new row is first made up of
0:      * columns matching the format ids, and then followed by one other column
0:      * matching the column passed in.  This routine is mostly used by the 
0:      * btree code to generate temporary branch rows needed during operations 
0:      * like split.
0:      * <p>
0:      *
0: 	 * @return The new row.
0:      *
0:      * @param format_ids an array of format id's, one per column in row.
0:      * @param page_ptr   The object to place in the last column of the template.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static DataValueDescriptor[] newBranchRow(
0:     int[]               format_ids,
0:     DataValueDescriptor page_ptr) 
0:         throws StandardException
0:     {
0:         // allocate an object array with the number of columns in the template
0:         // row (ie. number of columns in the leaf row) + one column to hold
0:         // the page pointer in the branch row.
0:         DataValueDescriptor[] columns = 
0:             allocate_objects(
0:                 format_ids.length + 1, (FormatableBitSet) null, format_ids);
0: 
0:         // tack on the page pointer to the extra column allocated onto the 
0:         // end of the row built from a leafrow template.
0:         columns[format_ids.length] = page_ptr;
0: 
0: 		return(columns);
0:     }
0: 
0:     /**
0:      * Check that columns in the row conform to a set of format id's, 
0:      * both in number and type.
0:      *
0: 	 * @return boolean indicating if template matches format id's
0:      *
0:      * @param format_ids array of format ids which are the types of cols in row
0:      * @param row        the array of columns that make up the row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	static public boolean checkColumnTypes(
0:     int[]                   format_ids, 
0:     DataValueDescriptor[]   row)
0: 		throws StandardException
0: 	{
0:         boolean ret_val = true;
0: 
0:         while (true)
0:         {
0:             int nCols = row.length;
0:             if (format_ids.length != row.length)
0:             {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "format_ids[] length (" + format_ids.length +
0:                         ") expected to be = row length (" + row.length +  ")");
0:                 }
0:                 ret_val = false;
0:                 break;
0:             }
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 Object  column;
0:                 Object  column_template;
0: 
0:                 for (int colid = 0; colid < nCols; colid++)
0:                 {
0:                     column = row[colid];
0: 
0:                     if (column == null)
0:                     {
0:                         SanityManager.THROWASSERT(
0:                             "column[" + colid + "] is null");
0:                     }
0: 
0:                     column_template = 
0:                         Monitor.newInstanceFromIdentifier(format_ids[colid]);
0: 
0: 
0:                     // is this the right check?
0:                     if (column.getClass() != column_template.getClass())
0:                     {
0:                         SanityManager.DEBUG_PRINT(
0:                             "check", "row = " +  RowUtil.toString(row));
0: 
0:                         SanityManager.THROWASSERT(
0:                             "column["+colid+"] (" + column.getClass() +
0:                             ") expected to be instanceof column_tempate() (" +
0:                             column_template.getClass() + ")" +
0:                             "column = " + column +
0:                             "row[colid] = " + row[colid]);
0:                     }
0:                 }
0:             }
0:             break;
0:         }
0: 
0:         return(ret_val);
0: 	}
0: 
0:     /**
0:      * Check that columns in the row conform to a set of format id's, 
0:      * both in number and type.
0:      *
0: 	 * @return boolean indicating if template matches format id's
0:      *
0:      * @param format_ids array of format ids which are the types of cols in row
0:      * @param row        the array of columns that make up the row.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	static public boolean checkPartialColumnTypes(
0:     int[]                   format_ids, 
0:     FormatableBitSet                 validColumns,
0:     int[]                   fieldStates,
0:     DataValueDescriptor[]   row)
0: 		throws StandardException
0: 	{
0:         boolean ret_val = true;
0: 
0:         return(ret_val);
0: 	}
0: }
============================================================================