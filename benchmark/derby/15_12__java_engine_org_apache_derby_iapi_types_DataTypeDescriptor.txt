7:eac0369: /*
1:b77f82e: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.DataTypeDescriptor
1:a8347d0: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:2afe578: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
12:eac0369:  */
1:baca785: 
1:eac0369: package org.apache.derby.iapi.types;
1:7ecc1f2: 
1:81de188: import java.io.IOException;
1:81de188: import java.io.ObjectInput;
1:81de188: import java.io.ObjectOutput;
1:81de188: import java.sql.Types;
1:dbfbecb: import java.text.RuleBasedCollator;
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:4aef9b0: import org.apache.derby.catalog.types.RowMultiSetImpl;
1:eac0369: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1:959fef2: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
2:eac0369: import org.apache.derby.iapi.error.StandardException;
1:c0c33cd: import org.apache.derby.iapi.reference.Property;
1:81de188: import org.apache.derby.iapi.reference.SQLState;
1:81de188: import org.apache.derby.iapi.services.io.Formatable;
1:81de188: import org.apache.derby.iapi.services.io.StoredFormatIds;
2:eac0369: import org.apache.derby.iapi.services.loader.ClassFactory;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:dbfbecb: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1:7ecc1f2: 
1:5d769a1: /** 
1:2afe578:  * DataTypeDescriptor describes a runtime SQL type.
1:c0c33cd:  * It consists of a catalog type (TypeDescriptor)
1:c0c33cd:  * and runtime attributes. The list of runtime
1:c0c33cd:  * attributes is:
1:c0c33cd:  * <UL>
1:c0c33cd:  * <LI> Collation Derivation
1:c0c33cd:  * </UL>
1:2e83f13:  * <P>
1:2e83f13:  * A DataTypeDescriptor is immutable.
1:eac0369:  */
30:eac0369: 
1:2e83f13: public final class DataTypeDescriptor implements Formatable
4:eac0369: {
1:eac0369: 	/********************************************************
1:eac0369: 	**
1:eac0369: 	**	This class implements Formatable. That means that it
1:eac0369: 	**	can write itself to and from a formatted stream. If
1:eac0369: 	**	you add more fields to this class, make sure that you
1:eac0369: 	**	also write/read them with the writeExternal()/readExternal()
1:eac0369: 	**	methods.
1:eac0369: 	**
1:eac0369: 	**	If, inbetween releases, you add more fields to this class,
1:eac0369: 	**	then you should bump the version number emitted by the getTypeFormatId()
1:eac0369: 	**	method.
1:eac0369: 	**
1:eac0369: 	********************************************************/
1:9ed7c4d:     
1:2e83f13:     /**
1:2e83f13:      * Runtime INTEGER type that is nullable.
1:2e83f13:      */
1:2e83f13:     public static final DataTypeDescriptor INTEGER =
1:2e83f13:         new DataTypeDescriptor(TypeId.INTEGER_ID, true);
1:2e83f13:     
1:2e83f13:     /**
1:2e83f13:      * Runtime INTEGER type that is not nullable.
1:2e83f13:      */
1:2e83f13:     public static final DataTypeDescriptor INTEGER_NOT_NULL =
1:2e83f13:         INTEGER.getNullabilityType(false);
1:2e83f13:     
1:2e83f13:     /**
1:2e83f13:      * Runtime SMALLINT type that is nullable.
1:2e83f13:      */
1:2e83f13:     public static final DataTypeDescriptor SMALLINT =
1:2e83f13:         new DataTypeDescriptor(TypeId.SMALLINT_ID, true);
1:2e83f13:     
1:2e83f13:     /**
1:2e83f13:      * Runtime INTEGER type that is not nullable.
1:2e83f13:      */
1:2e83f13:     public static final DataTypeDescriptor SMALLINT_NOT_NULL =
1:2e83f13:         SMALLINT.getNullabilityType(false);
1:7fd0c6e: 
1:2782d72:     /**
1:2782d72:      * Runtime INTEGER type that is nullable.
1:2782d72:      */
1:2782d72:     public static final DataTypeDescriptor DOUBLE =
1:2782d72:         new DataTypeDescriptor(TypeId.DOUBLE_ID, true);
1:2782d72:     
1:7fd0c6e:     public  static  final   int MIN_VALUE_IDX = 0;
1:7fd0c6e:     public  static  final   int MAX_VALUE_IDX = MIN_VALUE_IDX + 1;
1:7fd0c6e:     public  static  final   int MAX_MIN_ARRAY_SIZE = MAX_VALUE_IDX + 1;
1:2e83f13: 
1:eac0369: 	/*
1:eac0369: 	** Static creators
1:b77f82e: 	*/
1:01b5961: 	/**
1:2afe578: 	 * Get a descriptor that corresponds to a nullable builtin JDBC type.
1:9ed7c4d:      * If a variable length type then the size information will be set 
1:9ed7c4d:      * to the maximum possible.
1:9ed7c4d:      * 
1:9ed7c4d:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:2e83f13:      * 
1:2e83f13:      * For well known types code may also use the pre-defined
1:2e83f13:      * runtime types that are fields of this class, such as INTEGER.
1:9ed7c4d: 	 *
1:eac0369: 	 * @param jdbcType	The int type of the JDBC type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:9ed7c4d: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type
1:a8347d0: 	 */
2:eac0369: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
2:eac0369: 	(
1:eac0369: 		int	jdbcType
2:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true);
7:eac0369: 	}
1:4aef9b0:     
1:4aef9b0:     /**
1:9ed7c4d:      * Get a descriptor that corresponds to a nullable builtin variable
1:9ed7c4d:      * length JDBC type.
1:4aef9b0:      *
1:9ed7c4d:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:4aef9b0:      * 
1:9ed7c4d:      * @param jdbcType  The int type of the JDBC type for which to get
1:9ed7c4d:      *                      a corresponding SQL DataTypeDescriptor
1:f90d449:      *
1:9ed7c4d:      * @return  A new DataTypeDescriptor that corresponds to the Java type.
1:9ed7c4d:      *          A null return value means there is no corresponding SQL type
1:4aef9b0:      */
1:9ed7c4d:     public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1:4aef9b0: 	(
1:eac0369: 		int	jdbcType,
1:eac0369: 		int length
1:4aef9b0: 	)
1:4aef9b0: 	{
1:eac0369: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true, length);
1:4aef9b0: 	}
1:d66ce7b: 	
1:4aef9b0: 	/**
1:b77f82e: 	 * Return a runtime type for a catalog type.
1:9ed7c4d: 	 */
1:b77f82e: 	public static DataTypeDescriptor getType(TypeDescriptor catalogType)
1:7752cf6: 	{
1:b77f82e: 		TypeDescriptorImpl typeDescriptor = (TypeDescriptorImpl) catalogType;
1:fbb0d4f:         
1:fbb0d4f:         TypeId typeId = TypeId.getTypeId(catalogType);
1:fbb0d4f:  
1:baca785: 		DataTypeDescriptor dtd =
1:fbb0d4f:             new DataTypeDescriptor(typeDescriptor, typeId);
1:b25481f:         
1:baca785:         // By definition, any catalog type (column in a table,
1:baca785:         // procedure etc.) is derivation implicit.
1:b25481f:         dtd.collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
1:baca785:         
1:baca785:         return dtd;
1:b77f82e: 	}
1:b77f82e:     
1:d45f7d3:     /**
1:a8347d0:      * Return a nullable catalog type for a JDBC builtin type and length.
1:b77f82e:      */
1:a8347d0:     public static TypeDescriptor getCatalogType(int jdbcType, int length)
1:b77f82e:     {
1:a8347d0:         return getBuiltInDataTypeDescriptor(jdbcType, length).getCatalogType();
1:a8347d0:     }
1:6796671:     /**
1:a8347d0:      * Return a nullable catalog type for a fixed length JDBC builtin type.
1:a8347d0:      */
1:a8347d0:     public static TypeDescriptor getCatalogType(int jdbcType)
1:a8347d0:     {
1:a8347d0:         return getBuiltInDataTypeDescriptor(jdbcType).getCatalogType();
1:a8347d0:     }
1:01b5961:     
1:6796671:     /**
1:01b5961:      * Get a catlog type identical to the passed in type exception
1:01b5961:      * that the collationType is set to the passed in value.
1:01b5961:      * @param catalogType Type to be based upon.
1:01b5961:      * @param collationType Collation type of returned type.
1:01b5961:      * 
1:01b5961:      * @return catalogType if it already has the correct collation,
1:01b5961:      * otherwise a new TypeDescriptor with the correct collation.
1:01b5961:      */
1:01b5961:     public static TypeDescriptor getCatalogType(TypeDescriptor catalogType,
1:01b5961:             int collationType)
1:01b5961:     {
1:01b5961:         if (catalogType.isRowMultiSet())
1:01b5961:             return getRowMultiSetCollation(catalogType, collationType);
1:01b5961:         
1:01b5961:         if (catalogType.getCollationType() == collationType)
1:01b5961:             return catalogType;
1:01b5961:         
1:01b5961:         // Create through a runtime type, derivation will be thrown away.
1:01b5961:         return getType(catalogType).getCollatedType(collationType,
1:01b5961:                 StringDataValue.COLLATION_DERIVATION_IMPLICIT).getCatalogType();
1:92268ac:     }
1:92268ac: 
1:92268ac: 	/**
2:eac0369: 	 * Get a descriptor that corresponds to a builtin JDBC type.
1:2e83f13:      * 
1:2e83f13:      * For well known types code may also use the pre-defined
1:2e83f13:      * runtime types that are fields of this class, such as INTEGER.
1:2e83f13:      * E.g. using DataTypeDescriptor.INTEGER is preferred to
1:2e83f13:      * DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, true)
1:2e83f13:      * (both will return the same immutable object).
1:9ed7c4d: 	 *
1:eac0369: 	 * @param jdbcType	The int type of the JDBC type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:9ed7c4d: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type
1:92268ac: 	 */
1:eac0369: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		int	jdbcType, 
1:eac0369: 		boolean	isNullable
1:eac0369: 	)
1:92268ac: 	{
1:2e83f13:         // Re-use pre-defined types wherever possible.
1:2e83f13:         switch (jdbcType)
1:2e83f13:         {
1:2bb198a:         case Types.INTEGER:
1:2e83f13:             return isNullable ? INTEGER : INTEGER_NOT_NULL;
1:2bb198a:         case Types.SMALLINT:
1:2e83f13:             return isNullable ? SMALLINT : SMALLINT_NOT_NULL;
1:2e83f13:         default:
1:2e83f13:             break;
1:2e83f13:         }
1:92268ac: 
1:2e83f13:         
1:eac0369: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1:eac0369: 		if (typeId == null)
1:a8347d0: 		{
1:d66ce7b: 			return null;
1:01b5961: 		}
1:2e83f13: 
1:eac0369: 		return new DataTypeDescriptor(typeId, isNullable);
1:d66ce7b: 	}
1:9ed7c4d: 	/**
1:eac0369: 	 * Get a descriptor that corresponds to a builtin JDBC type.
1:81de188:      * 
1:9ed7c4d:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:81de188: 	 *
1:eac0369: 	 * @param jdbcType	The int type of the JDBC type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
5:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type
1:81de188: 	 */
1:eac0369: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		int	jdbcType, 
1:eac0369: 		boolean	isNullable,
1:eac0369: 		int maxLength
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1:eac0369: 		if (typeId == null)
1:eac0369: 		{
1:d66ce7b: 			return null;
1:eac0369: 		}
1:d66ce7b: 
1:eac0369: 		return new DataTypeDescriptor(typeId, isNullable, maxLength);
1:eac0369: 	}
1:c0c33cd: 	/**
1:9ed7c4d: 	 * Get a DataTypeServices that corresponds to a nullable builtin SQL type.
1:9ed7c4d:      * 
1:9ed7c4d:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:eac0369: 	 *
1:6b50965: 	 * @param sqlTypeName	The name of the type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1:eac0369: 	 */
1:eac0369: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		String	sqlTypeName
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true);
1:eac0369: 	}
1:c0c33cd: 	/**
2:eac0369: 	 * Get a DataTypeServices that corresponds to a builtin SQL type
1:9ed7c4d:      * 
1:9ed7c4d:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:eac0369: 	 *
1:6b50965: 	 * @param sqlTypeName	The name of the type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1:eac0369: 	 */
1:eac0369: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		String	sqlTypeName,
1:eac0369: 		int length
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true, length);
1:eac0369: 	}
1:b77f82e: 	/**
1:eac0369: 	 * Get a DataTypeServices that corresponds to a Java type
1:eac0369: 	 *
3:eac0369: 	 * @param javaTypeName	The name of the Java type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1:eac0369: 	 */
1:eac0369: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		String	javaTypeName
1:eac0369: 	)
1:2a5922a:         throws StandardException
1:eac0369: 	{
1:eac0369: 			return DataTypeDescriptor.getSQLDataTypeDescriptor(javaTypeName, true);
1:eac0369: 	}
1:32812bd: 
1:a8347d0: 	/**
1:eac0369: 	 * Get a DataTypeServices that corresponds to a Java type
1:eac0369: 	 *
1:eac0369: 	 * @param javaTypeName	The name of the Java type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1:eac0369: 	 */
1:eac0369: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		String	javaTypeName, 
1:eac0369: 		boolean	isNullable
1:eac0369: 	)
1:2a5922a:         throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
1:eac0369: 		if (typeId == null)
1:eac0369: 		{
3:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return new DataTypeDescriptor(typeId, isNullable);
1:eac0369: 	}
1:eac0369: 
1:a8347d0: 	/**
1:eac0369: 	 * Get a DataTypeDescriptor that corresponds to a Java type
1:eac0369: 	 *
1:eac0369: 	 * @param javaTypeName	The name of the Java type for which to get
1:eac0369: 	 *						a corresponding SQL DataTypeDescriptor
1:eac0369: 	 * @param precision	The number of decimal digits
1:eac0369: 	 * @param scale		The number of digits after the decimal point
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum width of a data value
1:eac0369: 	 *			represented by this type.
1:eac0369: 	 *
1:eac0369: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1:eac0369: 	 *			A null return value means there is no corresponding SQL type.
1:eac0369: 	 */
1:eac0369: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1:eac0369: 	(
1:eac0369: 		String	javaTypeName, 
1:eac0369: 		int 	precision,
1:eac0369: 		int 	scale, 
1:eac0369: 		boolean	isNullable, 
1:eac0369: 		int 	maximumWidth
1:eac0369: 	)
1:2a5922a:         throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
1:eac0369: 		if (typeId == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return new DataTypeDescriptor(typeId,
1:eac0369: 											precision,
1:eac0369: 											scale,
2:eac0369: 											isNullable,
3:eac0369: 											maximumWidth);
1:eac0369: 	}
1:32812bd:     
1:32812bd: 	/**
1:d66ce7b: 	 * Get a catalog type that corresponds to a SQL Row Multiset
1:eac0369: 	 *
1:4aef9b0: 	 * @param columnNames   Names of the columns in the Row Muliset
1:8bc0bec: 	 * @param catalogTypes  Types of the columns in the Row Muliset
1:eac0369: 	 *
1:4aef9b0: 	 * @return	A new DataTypeDescriptor describing the SQL Row Multiset
1:4aef9b0: 	 */
1:01b5961:     public static TypeDescriptor getRowMultiSet(String[] columnNames,
1:01b5961:             TypeDescriptor[] catalogTypes)
1:4aef9b0:     {
1:baca785: 		RowMultiSetImpl rms = new RowMultiSetImpl(columnNames, catalogTypes);
1:fbb0d4f:         return new TypeDescriptorImpl(rms, true, -1);
1:4aef9b0: 	}
1:4aef9b0: 
1:b77f82e: 	/*
1:eac0369: 	** Instance fields & methods
1:eac0369: 	*/
1:4aef9b0: 
1:eac0369: 	private TypeDescriptorImpl	typeDescriptor;
1:eac0369: 	private TypeId			typeId;
1:c0c33cd:     
1:baca785:     /**
1:baca785:      * Derivation of this type. All catalog types are
1:baca785:      * by definition implicit.
1:baca785:      */
1:c0c33cd:     private int collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
1:c0c33cd: 
1:eac0369: 
1:81de188: 	/**
1:eac0369: 	 * Public niladic constructor. Needed for Formatable interface to work.
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369:     public	DataTypeDescriptor() {}
1:eac0369: 
1:81de188: 	/**
1:eac0369: 	 * Constructor for use with numeric types
1:eac0369: 	 *
1:f90d449: 	 * @param typeId	The typeId of the type being described
1:f90d449: 	 * @param precision	The number of decimal digits.
1:f90d449: 	 * @param scale		The number of digits after the decimal point.
1:f90d449: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:f90d449: 	 *			it definitely cannot contain NULL.
1:f90d449: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor(TypeId typeId, int precision, int scale,
1:eac0369: 		boolean isNullable, int maximumWidth)
1:01b5961: 	{
1:eac0369: 		this.typeId = typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1:eac0369: 												precision,
1:eac0369: 												scale,
1:eac0369: 												isNullable,
1:eac0369: 												maximumWidth);
1:eac0369: 	}
1:eac0369: 
5:eac0369: 	/**
1:68f9f47: 	 * Constructor to use when the caller doesn't know if it is requesting
1:68f9f47: 	 * numeric or no-numeric DTD. For instance, when dealing with MAX/MIN 
1:68f9f47: 	 * aggregrate operators, AggregateNode.bindExpression could be dealing
1:68f9f47: 	 * with a character string operand or a numeric operand. The result of
1:68f9f47: 	 * MAX/MIN will depend on the type of it's operand. And hence when this
1:68f9f47: 	 * constructor gets called by AggregateNode.bindExpression, we don't know 
1:68f9f47: 	 * what type we are constructing and hence this constructor supports 
1:68f9f47: 	 * arguments for both numeric and non-numeric types.
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The typeId of the type being described
1:eac0369: 	 * @param precision	The number of decimal digits.
1:eac0369: 	 * @param scale		The number of digits after the decimal point.
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:f90d449: 	 * @param collationType The collation type of a string data type
1:f90d449: 	 * @param collationDerivation Collation Derivation of a string data type
1:f90d449: 	 */
1:f90d449: 	public DataTypeDescriptor(TypeId typeId, int precision, int scale,
1:f90d449: 		boolean isNullable, int maximumWidth, int collationType,
1:f90d449: 		int collationDerivation)
1:f90d449: 	{
1:f90d449: 		this.typeId = typeId;
1:f90d449: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1:f90d449: 												precision,
1:f90d449: 												scale,
1:f90d449: 												isNullable,
1:f90d449: 												maximumWidth,
1:c0c33cd: 												collationType);
1:c0c33cd:         this.collationDerivation = collationDerivation;
1:f90d449: 	}
1:f90d449: 
1:f90d449: 	/**
1:eac0369: 	 * Constructor for use with non-numeric types
1:eac0369: 	 *
1:eac0369: 	 * @param typeId	The typeId of the type being described
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable,
1:eac0369: 		int maximumWidth)
1:b25481f: 	{
1:eac0369: 		this.typeId = typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1:eac0369: 												isNullable,
1:eac0369: 												maximumWidth);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable) {
1:eac0369: 
1:eac0369: 		this.typeId = typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1:eac0369: 												typeId.getMaximumPrecision(),
1:eac0369: 												typeId.getMaximumScale(),
1:eac0369: 												isNullable,
1:eac0369: 												typeId.getMaximumMaximumWidth());
1:eac0369: 	}
1:b25481f: 	private DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable)
1:eac0369: 	{
1:3841b98: 		//There might be other places, but one place this method gets called
1:3841b98: 		//from is ResultColumn.init. When the ResultColumn(RC) is for a 
1:3841b98: 		//ColumnDescriptor(CD), the RC's TypeDescriptorImpl(TDI) should get 
1:3841b98: 		//all the attributes of CD's TDI. So, if the CD is for a user table's
1:3841b98: 		//character type column, then this call by RC.init should have CD's 
1:3841b98: 		//collation attributes copied into RC along with other attributes. 
1:eac0369: 		this.typeId = source.typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1:244952e: 												source.getPrecision(),
1:244952e: 												source.getScale(),
1:244952e: 												isNullable,
1:3841b98: 												source.getMaximumWidth(),
1:c0c33cd: 												source.getCollationType()
1:c0c33cd: 												);
1:c0c33cd:         this.collationDerivation = source.getCollationDerivation();
1:eac0369: 	}
1:244952e:     
1:b25481f:     private DataTypeDescriptor(DataTypeDescriptor source,
1:b25481f:             int collationType,
1:b25481f:             int collationDerivation)
1:b25481f:     {
1:b25481f:         //There might be other places, but one place this method gets called
1:b25481f:         //from is ResultColumn.init. When the ResultColumn(RC) is for a 
1:b25481f:         //ColumnDescriptor(CD), the RC's TypeDescriptorImpl(TDI) should get 
1:b25481f:         //all the attributes of CD's TDI. So, if the CD is for a user table's
1:b25481f:         //character type column, then this call by RC.init should have CD's 
1:b25481f:         //collation attributes copied into RC along with other attributes. 
1:b25481f:         this.typeId = source.typeId;
1:b25481f:         typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1:b25481f:                                                 source.getPrecision(),
1:b25481f:                                                 source.getScale(),
1:b25481f:                                                 source.isNullable(),
1:b25481f:                                                 source.getMaximumWidth(),
1:b25481f:                                                 collationType
1:b25481f:                                                 );
1:b25481f:         this.collationDerivation = collationDerivation;
1:b25481f:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for internal uses only.  
1:eac0369: 	 * (This is useful when the precision and scale are potentially wider than
1:eac0369: 	 * those in the source, like when determining the dominant data type.)
1:eac0369: 	 *
1:eac0369: 	 * @param source	The DTSI to copy
1:eac0369: 	 * @param precision	The number of decimal digits.
1:eac0369: 	 * @param scale		The number of digits after the decimal point.
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor(DataTypeDescriptor source, 
1:eac0369: 								int precision,
1:eac0369: 								int scale,
1:eac0369: 								boolean isNullable,
1:eac0369: 								int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = source.typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1:eac0369: 												precision,
1:eac0369: 												scale,
1:eac0369: 												isNullable,
1:244952e: 												maximumWidth,
1:c0c33cd: 												source.getCollationType()
1:c0c33cd: 												);
1:c0c33cd:         this.collationDerivation = source.getCollationDerivation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for internal uses only
1:eac0369: 	 *
1:eac0369: 	 * @param source	The DTSI to copy
1:eac0369: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1:eac0369: 	 *			it definitely cannot contain NULL.
1:eac0369: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable,
1:eac0369: 		int maximumWidth)
1:eac0369: 	{
1:eac0369: 		this.typeId = source.typeId;
1:eac0369: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1:eac0369: 				source.getPrecision(),
1:eac0369: 				source.getScale(),
1:eac0369: 				isNullable,
1:244952e: 				maximumWidth,
1:c0c33cd: 				source.getCollationType()
1:c0c33cd: 				);
1:c0c33cd:         this.collationDerivation = source.getCollationDerivation();
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for use in reconstructing a DataTypeDescriptor from a
1:eac0369: 	 * TypeDescriptorImpl and a TypeId
1:eac0369: 	 *
1:eac0369: 	 * @param source	The TypeDescriptorImpl to construct this DTSI from
1:eac0369: 	 */
1:b77f82e: 	private DataTypeDescriptor(TypeDescriptorImpl source, TypeId typeId)
1:eac0369: 	{
1:eac0369: 		typeDescriptor = source;
1:b77f82e: 		this.typeId = typeId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* DataTypeDescriptor Interface */
1:eac0369: 	public DataValueDescriptor normalize(DataValueDescriptor source,
1:eac0369: 										DataValueDescriptor cachedDest)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (cachedDest != null) {
1:eac0369: 				if (!getTypeId().isUserDefinedTypeId()) {
1:eac0369: 					String t1 = getTypeName();
1:eac0369: 					String t2 = cachedDest.getTypeName();
1:eac0369: 					if (!t1.equals(t2)) {
1:eac0369: 
1:eac0369: 						if (!(((t1.equals("DECIMAL") || t1.equals("NUMERIC"))
1:eac0369: 							&& (t2.equals("DECIMAL") || t2.equals("NUMERIC"))) ||
1:eac0369: 							(t1.startsWith("INT") && t2.startsWith("INT"))))  //INT/INTEGER
1:eac0369: 
1:eac0369: 							SanityManager.THROWASSERT(
1:eac0369: 								"Normalization of " + t2 + " being asked to convert to " + t1);
1:eac0369: 					}
1:eac0369: 				}
1:0b97566:             } else {
1:0b97566:                 SanityManager.THROWASSERT("cachedDest is null");
1:0b97566:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (source.isNull())
1:eac0369: 		{
1:eac0369: 			if (!isNullable())
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NULL_INTO_NON_NULL,"");
1:eac0369: 
1:0b97566:             cachedDest.setToNull();
1:eac0369: 		} else {
1:eac0369: 
1:eac0369: 			int jdbcId = getJDBCTypeId();
1:eac0369: 
1:eac0369: 			cachedDest.normalize(this, source);
1:eac0369: 			//doing the following check after normalize so that normalize method would get called on long varchs and long varbinary
1:eac0369: 			//Need normalize to be called on long varchar for bug 5592 where we need to enforce a lenght limit in db2 mode
1:eac0369: 			if ((jdbcId == Types.LONGVARCHAR) || (jdbcId == Types.LONGVARBINARY)) {
1:eac0369: 				// special case for possible streams
1:eac0369: 				if (source.getClass() == cachedDest.getClass()) 
1:eac0369: 					return source;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		return cachedDest;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the dominant type (DataTypeDescriptor) of the 2.
1:eac0369: 	 * For variable length types, the resulting type will have the
1:eac0369: 	 * biggest max length of the 2.
1:eac0369: 	 * If either side is nullable, then the result will also be nullable.
1:2364fd8: 	 * 
1:2364fd8: 	 * If dealing with character string types, then make sure to set the
1:2364fd8: 	 * collation info on the dominant type. Following algorithm will be used 
1:2364fd8: 	 * for dominant DTD's collation determination. Each of the steps of the 
1:12f2b05: 	 * algorithm have been numbered in the comments below and those same 
1:2364fd8: 	 * numbers are used in the actual algorithm below so it is easier to 
1:2364fd8: 	 * understand and maintain.
1:2364fd8: 	 * 
1:2364fd8: 	 * Step 1
1:2364fd8: 	 * If the DTD for "this" node has the same collation derivation as the 
1:2364fd8: 	 * otherDTS, then check if their collation types match too. If the 
1:2364fd8: 	 * collation types match too, then DTD for dominant type will get the same 
1:2364fd8: 	 * collation derivation and type.
1:2364fd8: 	 *  
1:2364fd8: 	 * Step 2
1:2364fd8: 	 * If the collation derivation for DTD for "this" node and otherDTS do not 
1:2364fd8: 	 * match, then check if one of them has the collation derivation of NONE. 
1:2364fd8: 	 * If that is the case, then dominant DTD will get the collation type and 
1:2364fd8: 	 * derivation of DTD whose collation derivation is not NONE.
1:2364fd8: 	 * 
1:2364fd8: 	 * Step 3
1:2364fd8: 	 * If the collation derivation for DTD for "this" node and otherDTS do not 
1:2364fd8: 	 * match, and none of them have the derivation of NONE then it means that 
1:2364fd8: 	 * we are dealing with collation derivation of IMPLICIT and EXPLICIT and 
1:2364fd8: 	 * hence the dominant DTD should get collation derivation of NONE. This is 
1:2364fd8: 	 * not a possibility in Derby 10.3 because the only 2 possible collation 
1:2364fd8: 	 * derivation supported are IMPLICIT and NONE.
1:2364fd8: 	 * 
1:2364fd8: 	 * Step 4
1:2364fd8: 	 * If the collation derivation for DTD for "this" node and otherDTS match, 
1:2364fd8: 	 * then check if the collation types match too. If not, then the dominant 
1:2364fd8: 	 * DTD should get collation derivation of NONE. 
1:eac0369: 	 *
1:eac0369: 	 * @param otherDTS	DataTypeDescriptor to compare with.
1:eac0369: 	 * @param cf		A ClassFactory
1:eac0369: 	 *
1:eac0369: 	 * @return DataTypeDescriptor  DTS for dominant type
1:eac0369: 	 */
1:eac0369: 	public DataTypeDescriptor getDominantType(DataTypeDescriptor otherDTS, ClassFactory cf)
1:eac0369: 	{
1:eac0369: 		boolean				nullable;
1:eac0369: 		TypeId				thisType;
1:eac0369: 		TypeId				otherType;
1:9ed7c4d: 		DataTypeDescriptor	higherType;
1:eac0369: 		DataTypeDescriptor	lowerType = null;
1:eac0369: 		int					maximumWidth;
1:eac0369: 		int					precision = getPrecision();
1:eac0369: 		int					scale = getScale();
1:2bb198a: 
1:eac0369: 		thisType = getTypeId();
1:eac0369: 		otherType = otherDTS.getTypeId();
1:eac0369: 
1:eac0369: 		/* The result is nullable if either side is nullable */
1:eac0369: 		nullable = isNullable() || otherDTS.isNullable();
1:eac0369: 
1:2bb198a: 		/*
1:eac0369: 		** The result will have the maximum width of both sides
1:eac0369: 		*/
1:eac0369: 		maximumWidth = (getMaximumWidth() > otherDTS.getMaximumWidth())
1:eac0369: 			? getMaximumWidth() : otherDTS.getMaximumWidth();
1:eac0369: 
1:eac0369: 		/* We need 2 separate methods of determining type dominance - 1 if both
1:eac0369: 		 * types are system built-in types and the other if at least 1 is
1:eac0369: 		 * a user type. (typePrecedence is meaningless for user types.)
1:eac0369: 		 */
1:08d6ce2: 		if (!thisType.userType() && !otherType.userType())
1:eac0369: 		{
1:eac0369: 			TypeId  higherTypeId;
1:eac0369: 			TypeId  lowerTypeId;
1:eac0369: 			if (thisType.typePrecedence() > otherType.typePrecedence())
1:eac0369: 			{
1:eac0369: 				higherType = this;
1:eac0369: 				lowerType = otherDTS;
1:eac0369: 				higherTypeId = thisType;
1:eac0369: 				lowerTypeId = otherType;
1:eac0369: 			}
1:2bb198a: 			else
1:eac0369: 			{
1:eac0369: 				higherType = otherDTS;
1:eac0369: 				lowerType = this;
1:eac0369: 				higherTypeId = otherType;
1:eac0369: 				lowerTypeId = thisType;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			//Following is checking if higher type argument is real and other argument is decimal/bigint/integer/smallint,
1:eac0369: 			//then result type should be double
1:eac0369: 			if (higherTypeId.isRealTypeId() && (!lowerTypeId.isRealTypeId()) && lowerTypeId.isNumericTypeId())
1:eac0369: 			{
1:eac0369: 				higherType = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);
1:eac0369: 				higherTypeId = TypeId.getBuiltInTypeId(Types.DOUBLE);
1:eac0369: 			}
1:2bb198a: 			/*
1:eac0369: 			** If we have a DECIMAL/NUMERIC we have to do some
1:eac0369: 			** extra work to make sure the resultant type can
1:eac0369: 			** handle the maximum values for the two input
1:eac0369: 			** types.  We cannot just take the maximum for
1:eac0369: 			** precision.  E.g. we want something like:
1:eac0369: 			**
1:eac0369: 			**		DEC(10,10) and DEC(3,0) => DEC(13,10)
1:eac0369: 			**
1:eac0369: 			** (var)char type needs some conversion handled later.
1:eac0369: 			*/
1:eac0369: 			if (higherTypeId.isDecimalTypeId() && (!lowerTypeId.isStringTypeId()))
1:eac0369: 			{
1:eac0369: 				precision = higherTypeId.getPrecision(this, otherDTS);
1:eac0369: 				if (precision > 31) precision = 31; //db2 silently does this and so do we
1:eac0369: 				scale = higherTypeId.getScale(this, otherDTS);
1:eac0369: 
1:eac0369: 				/* maximumWidth needs to count possible leading '-' and
1:eac0369: 				 * decimal point and leading '0' if scale > 0.  See also
1:eac0369: 				 * sqlgrammar.jj(exactNumericType).  Beetle 3875
1:eac0369: 				 */
1:eac0369: 				maximumWidth = (scale > 0) ? precision + 3 : precision + 1;
1:eac0369: 			}
1:eac0369: 			else if (thisType.typePrecedence() != otherType.typePrecedence())
1:eac0369: 			{
1:eac0369: 				precision = higherType.getPrecision();
1:eac0369: 				scale = higherType.getScale();
1:244952e: 
1:eac0369: 				/* GROSS HACKS:
1:eac0369: 				 * If we are doing an implicit (var)char->(var)bit conversion
1:eac0369: 				 * then the maximum width for the (var)char as a (var)bit
1:eac0369: 				 * is really 16 * its width as a (var)char.  Adjust
1:eac0369: 				 * maximumWidth accordingly.
1:eac0369: 				 * If we are doing an implicit (var)char->decimal conversion
1:eac0369: 				 * then we need to increment the decimal's precision by
1:eac0369: 				 * 2 * the maximum width for the (var)char and the scale
1:eac0369: 				 * by the maximum width for the (var)char. The maximumWidth
1:eac0369: 				 * becomes the new precision + 3.  This is because
1:eac0369: 				 * the (var)char could contain any decimal value from XXXXXX
1:eac0369: 				 * to 0.XXXXX.  (In other words, we don't know which side of the
1:eac0369: 				 * decimal point the characters will be on.)
1:eac0369: 				 */
1:eac0369: 				if (lowerTypeId.isStringTypeId())
1:eac0369: 				{
1:eac0369: 					if (higherTypeId.isBitTypeId() &&
1:eac0369: 						! (higherTypeId.isLongConcatableTypeId()))
1:eac0369: 					{
1:eac0369: 						if (lowerTypeId.isLongConcatableTypeId())
1:eac0369: 						{
1:eac0369: 							if (maximumWidth > (Integer.MAX_VALUE / 16))
1:eac0369: 								maximumWidth = Integer.MAX_VALUE;
1:2d32bab: 							else
1:eac0369: 								maximumWidth *= 16;
1:eac0369: 						}
1:2bb198a: 						else
1:eac0369: 						{
1:eac0369: 							int charMaxWidth;
1:eac0369: 
1:eac0369: 							int fromWidth = lowerType.getMaximumWidth();
1:eac0369: 							if (fromWidth > (Integer.MAX_VALUE / 16))
1:eac0369: 								charMaxWidth = Integer.MAX_VALUE;
1:2bb198a: 							else
1:eac0369: 								charMaxWidth = 16 * fromWidth;
1:eac0369: 
1:eac0369: 							maximumWidth = (maximumWidth >= charMaxWidth) ?
1:eac0369: 												maximumWidth : charMaxWidth;
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:2bb198a: 				/*
1:eac0369: 				 * If we are doing an implicit (var)char->decimal conversion
1:eac0369: 				 * then the resulting decimal's precision could be as high as 
1:eac0369: 				 * 2 * the maximum width (precisely 2mw-1) for the (var)char
1:eac0369: 				 * and the scale could be as high as the maximum width
1:eac0369: 				 * (precisely mw-1) for the (var)char.
1:eac0369: 				 * The maximumWidth becomes the new precision + 3.  This is
1:eac0369: 				 * because the (var)char could contain any decimal value from
1:eac0369: 				 * XXXXXX to 0.XXXXX.  (In other words, we don't know which
1:eac0369: 				 * side of the decimal point the characters will be on.)
1:eac0369: 				 *
1:eac0369: 				 * We don't follow this algorithm for long varchar because the
1:eac0369: 				 * maximum length of a long varchar is maxint, and we don't
1:eac0369: 				 * want to allocate a huge decimal value.  So in this case,
1:eac0369: 				 * the precision, scale, and maximum width all come from
1:eac0369: 				 * the decimal type.
1:eac0369: 				 */
1:eac0369: 				if (lowerTypeId.isStringTypeId() &&
1:eac0369: 					! (lowerTypeId.isLongConcatableTypeId()) &&
1:eac0369: 					higherTypeId.isDecimalTypeId() )
1:eac0369: 				{
1:eac0369: 					int charMaxWidth = lowerType.getMaximumWidth();
1:eac0369: 					int charPrecision;
1:eac0369: 
1:2bb198a: 					/*
1:eac0369: 					** Be careful not to overflow when calculating the
1:eac0369: 					** precision.  Remember that we will be adding
1:eac0369: 					** three to the precision to get the maximum width.
1:eac0369: 					*/
1:eac0369: 					if (charMaxWidth > (Integer.MAX_VALUE - 3) / 2)
1:eac0369: 						charPrecision = Integer.MAX_VALUE - 3;
1:2bb198a: 					else
1:eac0369: 						charPrecision = charMaxWidth * 2;
1:eac0369: 
1:eac0369: 					if (precision < charPrecision)
1:eac0369: 						precision = charPrecision;
1:eac0369: 
1:eac0369: 					if (scale < charMaxWidth)
1:eac0369: 						scale = charMaxWidth;
1:eac0369: 
1:eac0369: 					maximumWidth = precision + 3;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
7:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* At least 1 type is not a system built-in type */
1:eac0369: 			ClassInspector		cu = cf.getClassInspector();
1:eac0369: 
1:eac0369: 			TypeId thisCompType = (TypeId) thisType;
1:eac0369: 			TypeId otherCompType = (TypeId) otherType;
1:eac0369: 
1:eac0369: 			if (cu.assignableTo(thisCompType.getCorrespondingJavaTypeName(),
1:eac0369: 							    otherCompType.getCorrespondingJavaTypeName()))
1:eac0369: 			{
1:eac0369: 				higherType = otherDTS;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
2:d66ce7b: 				if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(
1:eac0369: 							cu.assignableTo(otherCompType.getCorrespondingJavaTypeName(),
1:eac0369: 									thisCompType.getCorrespondingJavaTypeName()),
1:eac0369: 							otherCompType.getCorrespondingJavaTypeName() +
1:eac0369: 							" expected to be assignable to " +
1:eac0369: 							thisCompType.getCorrespondingJavaTypeName());
1:eac0369: 
1:eac0369: 				higherType = this;
1:d66ce7b: 			}
1:eac0369: 			precision = higherType.getPrecision();
1:eac0369: 			scale = higherType.getScale();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		higherType = new DataTypeDescriptor(higherType, 
1:244952e: 				precision, scale, nullable, maximumWidth);
1:eac0369: 
1:2364fd8: 		//Set collation info on the DTD for dominant type if it is string type
1:2364fd8: 		//The algorithm used is explained in this method's javadoc
1:2364fd8: 		if (higherType.getTypeId().isStringTypeId()) {
1:2364fd8: 			if (getCollationDerivation() != otherDTS.getCollationDerivation()) {
1:2364fd8: 				if (getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE) {
1:2364fd8: 					//Step 2
1:9ed7c4d:                     higherType = higherType.getCollatedType(
1:9ed7c4d:                             otherDTS.getCollationType(),
1:9ed7c4d:                             otherDTS.getCollationDerivation());                                      
1:9ed7c4d: 
1:2364fd8: 				} else if (otherDTS.getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE) {
1:2364fd8: 					//Step 2
1:9ed7c4d:                     higherType = higherType.getCollatedType(
1:9ed7c4d:                             getCollationType(),
1:9ed7c4d:                             getCollationDerivation());										
1:2364fd8: 				} else {
1:2364fd8: 					//Step 3
1:9ed7c4d:                     higherType = higherType.getCollatedType(
1:9ed7c4d:                             StringDataValue.COLLATION_TYPE_UCS_BASIC, // ignored
1:9ed7c4d:                             StringDataValue.COLLATION_DERIVATION_NONE);					
1:2364fd8: 				}
1:2364fd8: 			} else if (getCollationType() != otherDTS.getCollationType())
1:2364fd8: 				//Step 4
1:9ed7c4d:                 higherType = higherType.getCollatedType(
1:9ed7c4d:                         StringDataValue.COLLATION_TYPE_UCS_BASIC, // ignored
1:9ed7c4d:                         StringDataValue.COLLATION_DERIVATION_NONE);                 
1:2364fd8: 			else {
1:2364fd8: 				//Step 1
1:9ed7c4d:                 higherType = higherType.getCollatedType(
1:9ed7c4d:                         getCollationType(),
1:9ed7c4d:                         getCollationDerivation());
1:2364fd8: 			}
1:2364fd8: 		}
1:2364fd8: 
1:eac0369: 		return higherType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check whether or not the 2 types (DataTypeDescriptor) have the same type
1:eac0369: 	 * and length.
1:eac0369: 	 * This is useful for UNION when trying to decide whether a NormalizeResultSet
1:eac0369: 	 * is required.
1:eac0369: 	 *
1:eac0369: 	 * @param otherDTS	DataTypeDescriptor to compare with.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean  Whether or not the 2 DTSs have the same type and length.
1:eac0369: 	 */
1:eac0369: 	public boolean isExactTypeAndLengthMatch(DataTypeDescriptor otherDTS)
1:eac0369: 	{
1:eac0369: 		/* Do both sides have the same length? */
1:eac0369: 		if (getMaximumWidth() != otherDTS.getMaximumWidth()) 
1:eac0369: 		{
11:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		if (getScale() != otherDTS.getScale())
1:eac0369: 		{
1:2bb198a: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (getPrecision() != otherDTS.getPrecision())
1:eac0369: 		{	
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		TypeId thisType = getTypeId();
1:eac0369: 		TypeId otherType = otherDTS.getTypeId();
1:eac0369: 
1:eac0369: 		/* Do both sides have the same type? */
1:eac0369: 		if ( ! thisType.equals(otherType))
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
6:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:ba2ee28: 	/**
1:b260d95:      * Shorthand method for getCatalogType().getMaximumWidth().
1:b260d95: 
1:eac0369: 	* @see TypeDescriptor#getMaximumWidth
1:eac0369: 	 */
1:eac0369: 	public int	getMaximumWidth()
1:eac0369: 	{
1:eac0369: 		return typeDescriptor.getMaximumWidth();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the TypeId for the datatype.
1:eac0369: 	 *
1:eac0369: 	 * @return	The TypeId for the datatype.
1:eac0369: 	 */
1:eac0369: 	public TypeId getTypeId()
1:eac0369: 	{
1:eac0369: 		return typeId;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a Null for this type.
1:eac0369: 	*/
1:dbfbecb: 	public DataValueDescriptor getNull() throws StandardException {
1:dbfbecb: 		DataValueDescriptor returnDVD = typeId.getNull();
1:dbfbecb: 		//If we are dealing with default collation, then we have got the
1:dbfbecb: 		//right DVD already. Just return it.
1:dbfbecb: 		if (typeDescriptor.getCollationType() == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1:dbfbecb: 			return returnDVD;			
1:dbfbecb: 		//If we are dealing with territory based collation and returnDVD is 
1:dbfbecb: 		//of type StringDataValue, then we need to return a StringDataValue   
1:dbfbecb: 		//with territory based collation.
1:dbfbecb: 		if (returnDVD instanceof StringDataValue) {
1:dbfbecb: 			try {
1:dbfbecb: 				RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().
1:dbfbecb: 				getCharacterCollator(typeDescriptor.getCollationType());
1:dbfbecb: 				return ((StringDataValue)returnDVD).getValue(rbs);
1:dbfbecb: 			}
1:dbfbecb: 			catch( java.sql.SQLException sqle)
1:dbfbecb: 			{
1:dbfbecb: 				throw StandardException.plainWrapException( sqle);
1:dbfbecb: 			}
1:dbfbecb: 		}
1:dbfbecb: 		else
1:dbfbecb: 			return returnDVD;			
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets the name of this datatype.
1:eac0369: 	 * 
1:eac0369: 	 *
1:eac0369: 	 *  @return	the name of this datatype
1:eac0369: 	 */
1:eac0369: 	public	String		getTypeName()
1:eac0369: 	{
1:90701f7: 		return typeDescriptor.getTypeName();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the jdbc type id for this type.  JDBC type can be
1:eac0369: 	 * found in java.sql.Types. 
1:b260d95:      * Shorthand method for getCatalogType().getJDBCTypeId().
1:eac0369: 	 *
1:eac0369: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
1:eac0369: 	 *
1:eac0369: 	 * @see Types
1:eac0369: 	 */
1:eac0369: 	public int getJDBCTypeId()
1:eac0369: 	{
1:2e83f13: 		return typeDescriptor.getJDBCTypeId();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the number of decimal digits for the datatype, if applicable.
1:b260d95:      * Shorthand method for getCatalogType().getPrecision().
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of decimal digits for the datatype.  Returns
1:eac0369: 	 *		zero for non-numeric datatypes.
1:b260d95:      * @see TypeDescriptor#getPrecision()
1:eac0369: 	 */
1:eac0369: 	public int	getPrecision()
1:eac0369: 	{
1:eac0369: 		return typeDescriptor.getPrecision();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the number of digits to the right of the decimal for
1:eac0369: 	 * the datatype, if applicable.
1:b260d95:      * Shorthand method for getCatalogType().getScale().
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of digits to the right of the decimal for
1:eac0369: 	 *		the datatype.  Returns zero for non-numeric datatypes.
1:b260d95:      * @see TypeDescriptor#getScale()
1:eac0369: 	 */
1:eac0369: 	public int	getScale()
1:eac0369: 	{
1:eac0369: 		return typeDescriptor.getScale();
1:7752cf6: 	}
1:7752cf6: 
1:b260d95: 	/**
1:b260d95:      * Obtain the collation type of the underlying catalog type.
1:b260d95:      * Shorthand method for getCatalogType().getCollationType().
1:b260d95:      * @see TypeDescriptor#getCollationType()
1:b260d95:      */
1:7752cf6: 	public int	getCollationType()
1:7752cf6: 	{
1:7752cf6: 		return typeDescriptor.getCollationType();
1:7752cf6: 	}
1:7752cf6: 
1:eac0369: 	/**
1:5212101:      * Obtain the collation type from a collation property value.
1:5212101: 	 * @return The collation type, or -1 if not recognized.
1:5212101:      */
1:5212101: 	public static int getCollationType(String collationName)
1:5212101: 	{
1:5212101: 		if (collationName.equalsIgnoreCase(Property.UCS_BASIC_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_UCS_BASIC;
1:5212101: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED;
1:5212101: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_PRIMARY_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1:5212101: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_SECONDARY_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_SECONDARY;
1:5212101: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_TERTIARY_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_TERTIARY;
1:5212101: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_IDENTICAL_COLLATION))
1:5212101: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL;
1:5212101: 		else
1:5212101: 			return -1;
1:5212101: 	}
1:5212101: 
1:eac0369:     /**
1:c0c33cd:      * Gets the name of the collation type in this descriptor if the collation
1:c0c33cd:      * derivation is not NONE. If the collation derivation is NONE, then this
1:c0c33cd:      * method will return "NONE".
1:c0c33cd:      * <p>
1:c0c33cd:      * This method is used for generating error messages which will use correct
1:c0c33cd:      * string describing collation type/derivation.
1:c0c33cd:      * 
1:c0c33cd:      *
1:c0c33cd:      *  @return the name of the collation being used in this type.
1:c0c33cd:      */
1:c0c33cd:     public String getCollationName()
1:7752cf6:     {
1:5212101: 		if (getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE)
1:5212101: 			return Property.COLLATION_NONE;
1:5212101: 		else
1:5212101: 			return getCollationName(getCollationType());
1:7752cf6:     }
1:7752cf6: 
1:eac0369:     /**
1:5212101:      * Gets the name of the specified collation type.
1:5212101:      * @param collationType The collation type.
1:5212101:      * @return The name, e g "TERRITORY_BASED:PRIMARY".
1:5212101:      */
1:5212101:     public static String getCollationName(int collationType)
1:5212101:     {
1:5212101: 		switch (collationType) {
1:5212101: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED :
1:5212101: 				return Property.TERRITORY_BASED_COLLATION;
1:5212101: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY :
1:5212101: 				return Property.TERRITORY_BASED_PRIMARY_COLLATION;
1:5212101: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_SECONDARY :
1:5212101: 				return Property.TERRITORY_BASED_SECONDARY_COLLATION;
1:5212101: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_TERTIARY :
1:5212101: 				return Property.TERRITORY_BASED_TERTIARY_COLLATION;
1:5212101: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL :
1:5212101: 				return Property.TERRITORY_BASED_IDENTICAL_COLLATION;
1:5212101: 			default :
1:5212101: 				return Property.UCS_BASIC_COLLATION;
1:5212101: 		}
1:5212101:     }
1:5212101: 
1:5212101:      /**
1:c0c33cd:      * Get the collation derivation for this type. This applies only for
1:c0c33cd:      * character string types. For the other types, this api should be
1:c0c33cd:      * ignored.
1:c0c33cd:      * 
1:c0c33cd:      * SQL spec talks about character string types having collation type and 
1:c0c33cd:      * collation derivation associated with them (SQL spec Section 4.2.2 
1:c0c33cd:      * Comparison of character strings). If collation derivation says explicit 
1:c0c33cd:      * or implicit, then it means that there is a valid collation type 
1:c0c33cd:      * associated with the charcter string type. If the collation derivation is 
1:c0c33cd:      * none, then it means that collation type can't be established for the 
1:c0c33cd:      * character string type.
1:c0c33cd:      * 
1:c0c33cd:      * 1)Collation derivation will be explicit if SQL COLLATE clause has been  
1:c0c33cd:      * used for character string type (this is not a possibility for Derby 10.3 
1:c0c33cd:      * because we are not planning to support SQL COLLATE clause in the 10.3
1:c0c33cd:      * release). 
1:c0c33cd:      * 
1:c0c33cd:      * 2)Collation derivation will be implicit if the collation can be 
1:c0c33cd:      * determined w/o the COLLATE clause eg CREATE TABLE t1(c11 char(4)) then 
1:c0c33cd:      * c11 will have collation of USER character set. Another eg, TRIM(c11) 
1:c0c33cd:      * then the result character string of TRIM operation will have collation 
1:c0c33cd:      * of the operand, c11.
1:c0c33cd:      * 
1:c0c33cd:      * 3)Collation derivation will be none if the aggregate methods are dealing 
1:c0c33cd:      * with character strings with different collations (Section 9.3 Data types 
1:c0c33cd:      * of results of aggregations Syntax Rule 3aii).
1:c0c33cd:      *  
1:9ed7c4d:      * Collation derivation will be initialized to COLLATION_DERIVATION_IMPLICIT
1:9ed7c4d:      * if not explicitly set.
1:c0c33cd:      *  
1:c0c33cd:      * @return Should be COLLATION_DERIVATION_NONE or COLLATION_DERIVATION_IMPLICIT
1:c0c33cd:      * 
1:c0c33cd:      * @see StringDataValue#COLLATION_DERIVATION_NONE
1:c0c33cd:      * @see StringDataValue#COLLATION_DERIVATION_IMPLICIT
1:c0c33cd:      * @see StringDataValue#COLLATION_DERIVATION_EXPLICIT
1:c0c33cd:      */
1:96a630c: 	public int	getCollationDerivation()
1:7752cf6: 	{
1:c0c33cd: 		return collationDerivation;
1:7752cf6: 	}
1:7752cf6: 
1:eac0369: 	/**
1:eac0369: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
1:eac0369: 	 * JDBC supports a return value meaning "nullability unknown" -
1:eac0369: 	 * I assume we will never have columns where the nullability is unknown.
1:b260d95:      * Shorthand method for getCatalogType().isNullable();
1:eac0369: 	 *
1:eac0369: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
1:81de188: 	 */
1:eac0369: 	public boolean	isNullable()
1:c0c33cd: 	{
1:eac0369: 		return typeDescriptor.isNullable();
1:c0c33cd: 	}
1:81de188:     
1:eac0369:     /**
1:32812bd:      * Return a type descriptor identical to the this type
1:32812bd:      * with the exception of its nullability. If the nullablity
1:32812bd:      * required matches the nullability of this then this is returned.
1:32812bd:      * 
1:32812bd:      * @param isNullable True to return a nullable type, false otherwise.
1:32812bd:      */
1:32812bd:     public DataTypeDescriptor getNullabilityType(boolean isNullable)
1:32812bd:     {
1:32812bd:         if (isNullable() == isNullable)
1:32812bd:             return this;
1:32812bd:         
1:32812bd:         return new DataTypeDescriptor(this, isNullable);
1:32812bd:     }
1:b25481f:     
1:b25481f:     /**
1:b25481f:      * Return a type description identical to this type
1:b25481f:      * with the exception that its collation information is
1:01b5961:      * taken from the passed in information. If the type
1:01b5961:      * does not represent a string type then the collation
1:01b5961:      * will be unchanged and this is returned.
1:01b5961:      * 
1:b25481f:     * @return This if collation would be unchanged otherwise a new type.
1:b25481f:      */   
1:b25481f:     public DataTypeDescriptor getCollatedType(int collationType,
1:b25481f:             int collationDerivation)
1:01b5961:     {        
1:01b5961:         if (!typeDescriptor.isStringType())
1:01b5961:             return this;
1:01b5961:         
1:b25481f:         if ((getCollationType() == collationType) &&
1:b25481f:             (getCollationDerivation() == collationDerivation))
1:b25481f:             return this;
1:b25481f:                 
1:b25481f:         return new DataTypeDescriptor(this,
1:f90d449:                 collationType,
1:f90d449:                 collationDerivation);
1:b25481f:     }
1:01b5961:     
1:01b5961:     /**
1:01b5961:      * For a row multi set type return an identical type
1:01b5961:      * with the collation type changed. Note that since
1:01b5961:      * row types are only ever catalog types the
1:01b5961:      * derivation is not used (since derivation is a property
1:01b5961:      * of runtime types).
1:01b5961:      * <BR>
1:01b5961:      * 
1:01b5961:      * 
1:01b5961:      * @param collationType
1:01b5961:      * @return this  will be returned if no changes are required (e.g.
1:01b5961:      * no string types or collation is already correct), otherwise a
1:01b5961:      * new instance is returned (leaving this unchanged).
1:01b5961:      */
1:01b5961:     private static TypeDescriptor getRowMultiSetCollation(
1:01b5961:             TypeDescriptor catalogType, int collationType)
1:01b5961:     {
1:01b5961:         TypeDescriptor[] rowTypes = catalogType.getRowTypes();
1:01b5961:         
1:01b5961:         TypeDescriptor[] newTypes = null;
1:01b5961:         
1:01b5961:         for (int t = 0; t < rowTypes.length; t++)
1:01b5961:         {
1:01b5961:             TypeDescriptor newType = DataTypeDescriptor.getCatalogType(
1:01b5961:                     rowTypes[t], collationType);
1:01b5961:             
1:01b5961:             // Is it the exact same as the old type.
1:01b5961:             if (newType == rowTypes[t])
1:01b5961:                 continue;
1:01b5961:             
1:01b5961:             if (newTypes == null)
1:01b5961:             {
1:01b5961:                 // First different type, simply create a new
1:01b5961:                 // array and copy all the old types across.
1:01b5961:                 // Any new type will overwrite the old type.
1:01b5961:                 newTypes = new TypeDescriptor[rowTypes.length];
1:01b5961:                 System.arraycopy(rowTypes, 0, newTypes, 0, rowTypes.length);
1:01b5961:             }
1:01b5961:             
1:01b5961:             newTypes[t] = newType;
1:01b5961:         }
1:01b5961:         
1:01b5961:         // If no change then we continue to use this instance.
1:01b5961:         if (newTypes == null)
1:01b5961:             return catalogType;
1:01b5961:         
1:01b5961:         return DataTypeDescriptor.getRowMultiSet(
1:01b5961:                 catalogType.getRowColumnNames(),
1:01b5961:                 newTypes);
1:01b5961:     }
1:eac0369: 
1:eac0369: 	/**
1:c0c33cd: 	  Compare if two DataTypeDescriptors are exactly the same
1:c0c33cd: 	  @param other the type to compare to.
1:eac0369: 	  */
1:c0c33cd: 	public boolean equals(Object other)
1:eac0369: 	{
1:c0c33cd:         if (!(other instanceof DataTypeDescriptor))
1:c0c33cd:             return false;
1:c0c33cd:         
1:c0c33cd:         DataTypeDescriptor odtd = (DataTypeDescriptor) other;
1:c0c33cd:         return typeDescriptor.equals(odtd.typeDescriptor)
1:c0c33cd:           && collationDerivation == odtd.collationDerivation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2bb198a: 	 * Check if this type is comparable with the passed type.
1:2bb198a: 	 * 
1:2bb198a: 	 * @param compareWithDTD the type of the instance to compare with this type.
1:dbed020: 	 * @param forEquals True if this is an = or != comparison, false
1:2bb198a: 	 *					otherwise.
1:2bb198a: 	 * @param cf		A ClassFactory
1:2bb198a: 	 * @return true if compareWithDTD is comparable to this type, else false.
1:2bb198a: 	 */
1:2bb198a: 	public boolean	comparable(DataTypeDescriptor compareWithDTD,
1:2bb198a:             boolean forEquals,
1:2bb198a:             ClassFactory cf){
1:2bb198a: 
1:2bb198a: 		TypeId compareWithTypeID = compareWithDTD.getTypeId();
1:2bb198a: 		int compareWithJDBCTypeId = compareWithTypeID.getJDBCTypeId();
1:2bb198a: 
1:2d32bab: 		// Long types cannot be compared. 
1:2d32bab: 		// XML types also fall in this window
1:2d32bab: 		// Says SQL/XML[2003] spec:
1:2d32bab: 		// 4.2.2 XML comparison and assignment
1:2d32bab: 		// "XML values are not comparable."
1:2d32bab: 		// An XML value cannot be compared to any type--
1:2d32bab: 		// not even to other XML values.
1:2bb198a: 		if (compareWithTypeID.isLongConcatableTypeId() || typeId.isLongConcatableTypeId())
1:2bb198a: 			return false;
1:2bb198a: 
1:2bb198a: 		// Ref types cannot be compared
1:2bb198a: 		if (typeId.isRefTypeId() || compareWithTypeID.isRefTypeId())
1:2bb198a: 			return false;
1:2bb198a: 		
1:2bb198a: 		//If this DTD is not user defined type but the DTD to be compared with 
1:2bb198a: 		//is user defined type, then let the other DTD decide what should be the
1:2bb198a: 		//outcome of the comparable method.
1:2bb198a: 		if (!(typeId.isUserDefinedTypeId()) && 
1:2bb198a: 				(compareWithTypeID.isUserDefinedTypeId()))
1:2bb198a: 			return compareWithDTD.comparable(this, forEquals, cf);
1:2d32bab: 
1:07d1108:     	//Numeric types are comparable to numeric types
1:2d32bab: 		if (typeId.isNumericTypeId())
1:07d1108:     		return (compareWithTypeID.isNumericTypeId());
1:2bb198a: 
1:2d32bab: 		//CHAR, VARCHAR and LONGVARCHAR are comparable to strings, boolean, 
1:2d32bab: 		//DATE/TIME/TIMESTAMP and to comparable user types
1:2d32bab: 		if (typeId.isStringTypeId()) {
1:2d32bab:     		if((compareWithTypeID.isDateTimeTimeStampTypeID() ||
1:2d32bab:     				compareWithTypeID.isBooleanTypeId()))
1:2d32bab:     				return true;
1:2d32bab:     		//If both the types are string types, then we need to make sure
1:2d32bab:     		//they have the same collation set on them
1:2d32bab:     		if (compareWithTypeID.isStringTypeId() && typeId.isStringTypeId()) {
1:5d769a1:     			return compareCollationInfo(compareWithDTD);    			
1:2d32bab:     		} else
1:2d32bab:     			return false;//can't be compared			
1:2d32bab: 		}
1:2bb198a: 
1:2d32bab:     	//Are comparable to other bit types and comparable user types
1:2d32bab: 		if (typeId.isBitTypeId()) 
1:2d32bab:         	return (compareWithTypeID.isBitTypeId()); 
1:2d32bab: 		
1:07d1108: 		//Booleans are comparable to Boolean, string, and to 
1:07d1108: 		//comparable user types. As part of the work on DERYB-887,
1:07d1108:         //I removed the comparability of booleans to numerics; I don't
1:07d1108: 		//understand the previous statement about comparable user types.
1:07d1108:         //I suspect that is wrong and should be addressed when we
1:07d1108:         //re-enable UDTs (see DERBY-651).
1:2d32bab: 		if (typeId.isBooleanTypeId())
1:2d32bab:     		return (compareWithTypeID.getSQLTypeName().equals(typeId.getSQLTypeName()) ||
1:07d1108:     				compareWithTypeID.isStringTypeId()); 
1:2bb198a: 
1:2d32bab: 		//Dates are comparable to dates, strings and to comparable
1:2d32bab: 		//user types.
1:2d32bab: 		if (typeId.getJDBCTypeId() == Types.DATE)
1:2d32bab:     		if (compareWithJDBCTypeId == Types.DATE || 
1:2d32bab:     				compareWithTypeID.isStringTypeId())
1:2d32bab:     			return true;
1:2d32bab:     		else
1:2d32bab:     			return false;
1:2bb198a: 
1:2d32bab:     	//Times are comparable to times, strings and to comparable
1:2d32bab: 		//user types.
1:2d32bab: 		if (typeId.getJDBCTypeId() == Types.TIME)
1:2d32bab:     		if (compareWithJDBCTypeId == Types.TIME || 
1:2d32bab:     				compareWithTypeID.isStringTypeId())
1:2d32bab:     			return true;
1:2d32bab:     		else
1:2d32bab:     			return false;
1:2bb198a: 
1:2d32bab:     	//Timestamps are comparable to timestamps, strings and to
1:2d32bab: 		//comparable user types.
1:2d32bab: 		if (typeId.getJDBCTypeId() == Types.TIMESTAMP)
1:2d32bab:     		if (compareWithJDBCTypeId == Types.TIMESTAMP || 
1:2d32bab:     				compareWithTypeID.isStringTypeId())
1:2bb198a:     			return true;
1:2d32bab:     		else
1:2bb198a:     			return false;
1:eac0369: 
1:f2a5622:         // Right now, user defined types are not comparable.
1:f2a5622:         // This removes old logic which we might want
1:f2a5622:         // to revive when we support comparable UDTs. See
1:f2a5622:         // DERBY-4470.
1:f2a5622: 		if (typeId.isUserDefinedTypeId() || typeId.getJDBCTypeId() == Types.OTHER)
1:f2a5622: 		{ return false; }
1:eac0369: 
1:2bb198a: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:ba2ee28: 	 * Compare the collation info on this DTD with the passed DTD. The rules
1:9355b96: 	 * for comparison are as follows (these are as per SQL standard 2003 
1:9355b96: 	 * Section 9.13)
1:9355b96: 	 * 
1:ba2ee28: 	 * 1)If both the DTDs have collation derivation of NONE, then they can't be
1:ba2ee28: 	 * compared and we return false.
1:ba2ee28: 	 * 2)If both the DTDs have same collation derivation (which in Derby's case
1:ba2ee28: 	 * at this point will mean collation derivation of IMPLICIT), then check
1:ba2ee28: 	 * the collation types. If they match, then return true. If they do not 
1:ba2ee28: 	 * match, then they can't be compared and hence return false.
1:9355b96: 	 * 3)If one DTD has collation derivation of IMPLICIT and other DTD has
1:9355b96: 	 * collation derivation of NONE, then 2 DTDs are comparable using the
1:9355b96: 	 * collation type of DTD with collation derivation of IMPLICIT. Derby does
1:9355b96: 	 * not implement this rule currently and it is being traked as DERBY-2678.
1:9355b96: 	 * Derby's current behavior is to throw an exception if both the DTDs 
1:9355b96: 	 * involved in collation operation do not have collation derivation of 
1:9355b96: 	 * IMPLICIT. This behavior is a subset of SQL standard.
1:9355b96: 	 * 4)Derby currently does not support collation derivation of EXPLICIT and
1:9355b96: 	 * hence we do not have the code to enforce rules as mentioned in Section
1:9355b96: 	 * 9.13 of SQL spec for collation derivation of EXPLICIT. When we implement
1:9355b96: 	 * collation derivation of EXPLICIT, we should make sure that we follow the
1:9355b96: 	 * rules as specified in the SQL spec for comparability.
1:ba2ee28: 	 * 
1:ba2ee28: 	 * @param compareWithDTD compare this DTD's collation info
1:ba2ee28: 	 *  
1:ba2ee28: 	 * @return value depends on the algorithm above.
1:ba2ee28: 	 */
1:5d769a1: 	public boolean compareCollationInfo(DataTypeDescriptor compareWithDTD){
1:5d769a1: 		//both the operands can not have the collation derivation of
1:5d769a1: 		//NONE. This is because in that case, we do not know what kind
1:5d769a1: 		//of collation to use for comparison.
1:5d769a1: 		if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
1:5d769a1: 				getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE)
1:5d769a1: 			return false;
1:5d769a1: 		if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
1:5d769a1: 				getCollationType() == compareWithDTD.getCollationType())
1:5d769a1: 			return true;//collation matches
1:5d769a1: 		else
1:5d769a1: 			return false;//collation does not match
1:5d769a1: 		}
1:5d769a1: 		 				
1:eac0369: 	/**
1:eac0369: 	 * Converts this data type descriptor (including length/precision)
1:eac0369: 	 * to a string. E.g.
1:ba2ee28: 	 *
1:eac0369: 	 *			VARCHAR(30)
1:eac0369: 	 *
1:eac0369: 	 *	or
1:eac0369: 	 *
1:eac0369: 	 *			 java.util.Hashtable 
1:eac0369: 	 *
1:eac0369: 	 * @return	String version of datatype, suitable for running through
1:eac0369: 	 *			the Parser.
1:2bb198a: 	 */
1:eac0369: 	public String	getSQLstring()
1:2bb198a: 	{
1:eac0369: 		return typeId.toParsableString( this );
1:2d32bab: 	}
1:2d32bab: 
1:eac0369: 	/**
1:eac0369: 	 * Get the simplified type descriptor that is intended to be stored
1:eac0369: 	 * in the system tables.
1:2bb198a: 	 */
1:2afe578: 	public TypeDescriptor getCatalogType()
1:eac0369: 	{
1:eac0369: 		return typeDescriptor;
1:eac0369: 	}
1:2d32bab: 
1:eac0369: 	/**
1:eac0369: 	 * Get the estimated memory usage for this type descriptor.
1:eac0369: 	 */
1:eac0369: 	public double estimatedMemoryUsage() {
1:eac0369: 		switch (typeId.getTypeFormatId())
1:eac0369: 		{
1:eac0369: 			case StoredFormatIds.LONGVARBIT_TYPE_ID:
1:7f0f775:             //DERBY-6096 Need to estimate usage for BLOB and clob
1:7f0f775:             case StoredFormatIds.BLOB_TYPE_ID:
1:eac0369: 				/* Who knows?  Let's just use some big number */
1:eac0369: 				return 10000.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.BIT_TYPE_ID:
1:eac0369: 				return (double) ( ( ((float) getMaximumWidth()) / 8.0) + 0.5);
1:eac0369: 
1:eac0369: 			case StoredFormatIds.BOOLEAN_TYPE_ID:
1:eac0369: 				return 4.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.CHAR_TYPE_ID:
1:eac0369: 			case StoredFormatIds.VARCHAR_TYPE_ID:
1:eac0369: 				return (double) (2.0 * getMaximumWidth());
1:eac0369: 
1:eac0369: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
1:7f0f775:             //DERBY-6096 Need to estimate usage for BLOB and clob
1:7f0f775:             case StoredFormatIds.CLOB_TYPE_ID:
1:eac0369: 				/* Who knows? Let's just use some big number */
1:eac0369: 				return 10000.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.DECIMAL_TYPE_ID:
1:2bb198a: 				/*
1:eac0369: 				** 0.415 converts from number decimal digits to number of 8-bit digits. 
1:eac0369: 				** Add 1.0 for the sign byte, and 0.5 to force it to round up.
1:eac0369: 				*/
1:eac0369: 				return (double) ( (getPrecision() * 0.415) + 1.5 );
1:eac0369: 
1:eac0369: 			case StoredFormatIds.DOUBLE_TYPE_ID:
1:eac0369: 				return 8.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.INT_TYPE_ID:
1:eac0369: 				return 4.0;
1:eac0369: 
1:3bb140c:             case StoredFormatIds.BIGINT_TYPE_ID:
1:eac0369: 				return 8.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.REAL_TYPE_ID:
1:eac0369: 				return 4.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.SMALLINT_TYPE_ID:
1:eac0369: 				return 2.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.TINYINT_TYPE_ID:
1:eac0369: 				return 1.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.REF_TYPE_ID:
1:eac0369: 				/* I think 12 is the right number */
1:eac0369: 				return 12.0;
1:eac0369: 
1:eac0369: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1:eac0369: 				if (typeId.userType()) {
1:eac0369: 					/* Who knows?  Let's just use some medium-sized number */
1:eac0369: 					return 256.0;
1:eac0369: 				}
1:eac0369: 			case StoredFormatIds.DATE_TYPE_ID:
1:eac0369: 			case StoredFormatIds.TIME_TYPE_ID:
1:eac0369: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
1:eac0369: 				return 12.0; 
1:eac0369: 
1:eac0369: 			default:
1:eac0369: 				return 0.0;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compare JdbcTypeIds to determine if they represent equivalent
1:eac0369: 	 * SQL types. For example Types.NUMERIC and Types.DECIMAL are
1:eac0369: 	 * equivalent
1:eac0369: 	 *
1:3fd26f3: 	 * @param existingType  JDBC type id of Derby data type
1:6b50965: 	 * @param jdbcTypeId   JDBC type id passed in from application.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean true if types are equivalent, false if not
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public static boolean isJDBCTypeEquivalent(int existingType, int jdbcTypeId)
1:eac0369: 	{
1:eac0369: 		// Any type matches itself.
1:eac0369: 		if (existingType == jdbcTypeId)
1:2d32bab: 			return true;
1:eac0369: 
1:eac0369: 		// To a numeric type
1:eac0369: 		if (DataTypeDescriptor.isNumericType(existingType)) {
1:eac0369: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
1:2d32bab: 				return true;
1:eac0369: 
1:eac0369: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1:2bb198a: 				return true;
1:eac0369: 
1:2e5d7c5: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// To character type.
1:eac0369: 		if (DataTypeDescriptor.isCharacterType(existingType)) {
1:eac0369: 
1:eac0369: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1:eac0369: 				return true;
1:eac0369: 
1:eac0369: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
1:eac0369: 				return true;
1:eac0369: 
1:eac0369: 
1:eac0369: 			switch (jdbcTypeId) {
1:2bb198a: 			case Types.DATE:
1:2bb198a: 			case Types.TIME:
1:2bb198a: 			case Types.TIMESTAMP:
1:eac0369: 				return true;
1:eac0369: 			default:
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			
1:2d32bab: 			return false;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// To binary type
1:eac0369: 		if (DataTypeDescriptor.isBinaryType(existingType)) {
1:eac0369: 
1:eac0369: 			if (DataTypeDescriptor.isBinaryType(jdbcTypeId))
1:eac0369: 				return true;
1:eac0369: 
1:2d32bab: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// To DATE, TIME
1:eac0369: 		if (existingType == Types.DATE || existingType == Types.TIME) {
1:eac0369: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1:eac0369: 				return true;
1:eac0369: 
1:eac0369: 			if (jdbcTypeId == Types.TIMESTAMP)
1:eac0369: 				return true;
1:eac0369: 
1:2bb198a: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// To TIMESTAMP
1:eac0369: 		if (existingType == Types.TIMESTAMP) {
1:eac0369: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1:eac0369: 				return true;
1:eac0369: 
1:eac0369: 			if (jdbcTypeId == Types.DATE)
1:eac0369: 				return true;
1:eac0369: 
1:2bb198a: 			return false;
1:eac0369: 		}
1:eac0369: 		
1:f225091: 		// To CLOB
1:f225091: 		if (existingType == Types.CLOB && DataTypeDescriptor.isCharacterType(jdbcTypeId))
1:eac0369: 			return true;
1:eac0369: 
1:2bb198a: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static boolean isNumericType(int jdbcType) {
1:eac0369: 
1:eac0369: 		switch (jdbcType) {
1:2bb198a: 		case Types.BIT:
1:1a4ea31: 		case Types.BOOLEAN:
1:2bb198a: 		case Types.TINYINT:
1:2e83f13: 		case Types.SMALLINT:
1:2e83f13: 		case Types.INTEGER:
1:2bb198a: 		case Types.BIGINT:
1:2bb198a: 		case Types.REAL:
1:eac0369: 		case Types.FLOAT:
1:2bb198a: 		case Types.DOUBLE:
1:2bb198a: 		case Types.DECIMAL:
1:2bb198a: 		case Types.NUMERIC:
1:2bb198a: 			return true;
1:eac0369: 		default:
1:2732872: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:2bb198a: 
1:eac0369: 	/**
1:6796671: 	 * Check whether a JDBC type is one of the character types that are
1:6796671: 	 * compatible with the Java type <code>String</code>.
1:6796671: 	 *
1:6796671: 	 * <p><strong>Note:</strong> <code>CLOB</code> is not compatible with
1:6796671: 	 * <code>String</code>. See tables B-4, B-5 and B-6 in the JDBC 3.0
1:6796671: 	 * Specification.
1:6796671: 	 *
1:6796671: 	 * <p> There are some non-character types that are compatible with
1:6796671: 	 * <code>String</code> (examples: numeric types, binary types and
1:6796671: 	 * time-related types), but they are not covered by this method.
1:6796671: 	 *
1:6796671: 	 * @param jdbcType a JDBC type
1:6796671: 	 * @return <code>true</code> iff <code>jdbcType</code> is a character type
1:6796671: 	 * and compatible with <code>String</code>
1:6796671: 	 * @see java.sql.Types
1:6796671: 	 */
1:eac0369: 	private static boolean isCharacterType(int jdbcType) {
1:eac0369: 
1:eac0369: 		switch (jdbcType) {
1:2bb198a: 		case Types.CHAR:
1:2bb198a: 		case Types.VARCHAR:
1:2bb198a: 		case Types.LONGVARCHAR:
1:2bb198a: 			return true;
1:eac0369: 		default:
1:2bb198a: 			return false;
1:eac0369: 		}
1:eac0369: 	}
1:2bb198a: 
1:eac0369: 	/**
1:6796671: 	 * Check whether a JDBC type is compatible with the Java type
1:6796671: 	 * <code>byte[]</code>.
1:6796671: 	 *
1:6796671: 	 * <p><strong>Note:</strong> <code>BLOB</code> is not compatible with
1:6796671: 	 * <code>byte[]</code>. See tables B-4, B-5 and B-6 in the JDBC 3.0
1:6796671: 	 * Specification.
1:6796671: 	 *
1:6796671: 	 * @param jdbcType a JDBC type
1:6796671: 	 * @return <code>true</code> iff <code>jdbcType</code> is compatible with
1:6796671: 	 * <code>byte[]</code>
1:6796671: 	 * @see java.sql.Types
1:6796671: 	 */
1:eac0369: 	private static boolean isBinaryType(int jdbcType) {
1:eac0369: 		switch (jdbcType) {
1:2bb198a: 		case Types.BINARY:
1:2bb198a: 		case Types.VARBINARY:
1:2bb198a: 		case Types.LONGVARBINARY:
1:2bb198a: 			return true;
1:eac0369: 		default:
1:2bb198a: 			return false;
1:2bb198a: 		}
1:2bb198a: 	}
1:2bb198a: 
1:2bb198a: 	/**
1:d45f7d3: 	 * Determine if an ASCII stream can be inserted into a column or parameter
1:d45f7d3: 	 * of type <code>jdbcType</code>.
1:d45f7d3: 	 *
1:d45f7d3: 	 * @param jdbcType JDBC type of column or parameter
1:d45f7d3: 	 * @return <code>true</code> if an ASCII stream can be inserted;
1:d45f7d3: 	 *         <code>false</code> otherwise
1:d45f7d3: 	 */
1:d45f7d3: 	public static boolean isAsciiStreamAssignable(int jdbcType) {
1:d45f7d3: 		return jdbcType == Types.CLOB || isCharacterType(jdbcType);
1:d45f7d3: 	}
1:d45f7d3: 
1:d45f7d3: 	/**
1:d45f7d3: 	 * Determine if a binary stream can be inserted into a column or parameter
1:d45f7d3: 	 * of type <code>jdbcType</code>.
1:d45f7d3: 	 *
1:d45f7d3: 	 * @param jdbcType JDBC type of column or parameter
1:d45f7d3: 	 * @return <code>true</code> if a binary stream can be inserted;
1:d45f7d3: 	 *         <code>false</code> otherwise
1:d45f7d3: 	 */
1:d45f7d3: 	public static boolean isBinaryStreamAssignable(int jdbcType) {
1:d45f7d3: 		return jdbcType == Types.BLOB || isBinaryType(jdbcType);
1:d45f7d3: 	}
1:d45f7d3: 
1:d45f7d3: 	/**
1:d45f7d3: 	 * Determine if a character stream can be inserted into a column or
1:d45f7d3: 	 * parameter of type <code>jdbcType</code>.
1:d45f7d3: 	 *
1:d45f7d3: 	 * @param jdbcType JDBC type of column or parameter
1:d45f7d3: 	 * @return <code>true</code> if a character stream can be inserted;
1:d45f7d3: 	 *         <code>false</code> otherwise
1:d45f7d3: 	 */
1:d45f7d3: 	public static boolean isCharacterStreamAssignable(int jdbcType) {
1:d45f7d3: 		// currently, we support the same types for ASCII streams and
1:d45f7d3: 		// character streams
1:d45f7d3: 		return isAsciiStreamAssignable(jdbcType);
1:d45f7d3: 	}
1:d45f7d3: 
1:eac0369: 	public String	toString()
1:eac0369: 	{
1:eac0369: 		return typeDescriptor.toString();
1:2bb198a: 	}
1:2bb198a: 
1:eac0369: 	// Formatable methods
1:2bb198a: 
1:eac0369: 	/**
1:eac0369: 	 * Read this object from a stream of stored objects.
1:2bb198a: 	 *
1:eac0369: 	 * @param in read this.
1:2bb198a: 	 *
1:eac0369: 	 * @exception IOException					thrown on error
1:eac0369: 	 * @exception ClassNotFoundException		thrown on error
1:2bb198a: 	 */
1:eac0369: 	public void readExternal( ObjectInput in )
1:eac0369: 		 throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		typeDescriptor = (TypeDescriptorImpl) in.readObject();
1:959fef2: 
1:959fef2:         // Restore typeId from the type descriptor. User-defined types and
1:959fef2:         // built-in types have different methods for getting the type id.
1:959fef2:         if (typeDescriptor.isUserDefinedType()) {
1:959fef2:             try {
1:959fef2:                 typeId = TypeId.getUserDefinedTypeId(
1:959fef2:                     ((UserDefinedTypeIdImpl) typeDescriptor.getTypeId())
1:959fef2:                         .getClassName());
1:959fef2:             } catch (StandardException se) {
1:959fef2:                 throw (IOException)
1:959fef2:                         new IOException(se.getMessage()).initCause(se);
1:959fef2:             }
1:959fef2:         } else {
1:959fef2:             typeId = TypeId.getBuiltInTypeId(this.getTypeName());
1:959fef2:         }
1:2bb198a:         
1:2e83f13:         collationDerivation = in.readInt();
1:eac0369: 	}
1:2bb198a: 
1:eac0369: 	/**
1:eac0369: 	 * Write this object to a stream of stored objects.
1:eac0369: 	 *
1:eac0369: 	 * @param out write bytes here.
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException		thrown on error
1:2bb198a: 	 */
1:eac0369: 	public void writeExternal( ObjectOutput out )
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:2e83f13: 		out.writeObject(typeDescriptor);
1:2e83f13:         out.writeInt(getCollationDerivation());
1:eac0369: 	}
1:2bb198a:  
1:eac0369: 	/**
1:eac0369: 	 * Get the formatID which corresponds to this class.
1:eac0369: 	 *
1:eac0369: 	 *	@return	the formatID of this class
1:2bb198a: 	 */
1:2e83f13: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_DESCRIPTOR_V02_ID; }
1:2bb198a: 
1:eac0369:     /**
1:d25aee0:      * Check to make sure that this type id is something a user can create
1:d25aee0:      * him/herself directly through an SQL CREATE TABLE statement.
1:eac0369:      * 
1:d25aee0:      * This method is used for CREATE TABLE AS ... WITH [NO] DATA binding
1:d25aee0:      * because it's possible for the query to return types which are not
1:d25aee0:      * actually creatable for a user.  DERBY-2605.
1:eac0369:      *
1:d25aee0:      * Three examples are:
1:eac0369:      *
1:d25aee0:      *  JAVA_OBJECT: A user can select columns of various java object types
1:d25aee0:      *   from system tables, but s/he is not allowed to create such a column
1:d25aee0:      *   him/herself.
1:eac0369:      *  
1:d25aee0:      *  DECIMAL: A user can specify a VALUES clause with a constant that
1:d25aee0:      *   has a precision of greater than 31.  Derby can apparently handle
1:d25aee0:      *   such a value internally, but the user is not supposed to be able
1:d25aee0:      *   create such a column him/herself.
1:eac0369:      * 
1:d25aee0:      * @return True if the type associated with this DTD can be created via
1:d25aee0:      *  the CREATE TABLE syntax; false otherwise.
1:eac0369:      */
1:d25aee0:     public boolean isUserCreatableType() throws StandardException
1:eac0369:     {
1:2bb198a:         switch (typeId.getJDBCTypeId())
1:eac0369:         {
1:d25aee0:             case Types.JAVA_OBJECT:
1:2732872:             	return getTypeId().getBaseTypeId().isAnsiUDT();
1:eac0369:             case Types.DECIMAL:
1:d25aee0:                 return
1:d25aee0:                 (getPrecision() <= typeId.getMaximumPrecision()) &&
1:d25aee0:                 (getScale() <= typeId.getMaximumScale()) &&
1:d25aee0:                 (getMaximumWidth() <= typeId.getMaximumMaximumWidth());
1:d25aee0:             default: break;
1:eac0369:         }
1:2bb198a:         return true;
1:eac0369:     }
1:2e83f13: 
1:eac0369:     /**
1:d25aee0:      * Return the SQL type name and, if applicable, scale/precision/length
1:d25aee0:      * for this DataTypeDescriptor.  Note that we want the values from *this*
1:d25aee0:      * object specifically, not the max values defined on this.typeId.
1:eac0369:      */
1:d25aee0:     public String getFullSQLTypeName()
1:eac0369:     {
1:d25aee0:         StringBuffer sbuf = new StringBuffer(typeId.getSQLTypeName());
1:d25aee0:         if (typeId.isDecimalTypeId() || typeId.isNumericTypeId())
1:eac0369:         {
1:d25aee0:             sbuf.append("(");
1:d25aee0:             sbuf.append(getPrecision());
1:d25aee0:             sbuf.append(", ");
1:d25aee0:             sbuf.append(getScale());
1:d25aee0:             sbuf.append(")");
1:eac0369:         }
1:d25aee0:         else if (typeId.variableLength())
1:eac0369:         {
1:d25aee0:             sbuf.append("(");
1:d25aee0:             sbuf.append(getMaximumWidth());
1:d25aee0:             sbuf.append(")");
1:eac0369:         }
1:2e83f13: 
1:d25aee0:         return sbuf.toString();
1:eac0369:     }
1:3b598ee: 
1:3b598ee:     /* Return the typename with the collation name for 
1:3b598ee:      * String types.
1:3b598ee:      */
1:3b598ee:     public String getSQLTypeNameWithCollation() {
1:3b598ee:         String name = typeId.getSQLTypeName();
1:3b598ee:         if (typeId.isStringTypeId()) {
1:3b598ee:             name = name + " (" + getCollationName() + ")";
1:3b598ee:         }
1:3b598ee:         return name;    
1:3b598ee:     }
1:7fd0c6e: 
1:7fd0c6e:     /**
1:7fd0c6e:      * Get the maximum and minimum value for a fixed numeric type.
1:7fd0c6e:      * Throws an unimplemented feature exception for a non-numeric type.
1:7fd0c6e:      */
1:7fd0c6e:     public  long[]  getNumericBounds()
1:7fd0c6e:         throws StandardException
1:7fd0c6e:     {
1:7fd0c6e:         long[]  retval = new long[ MAX_MIN_ARRAY_SIZE ];
1:7fd0c6e: 
1:7fd0c6e:         if ( getTypeId().equals( TypeId.SMALLINT_ID ) )
1:7fd0c6e:         {
1:7fd0c6e:             retval[ MIN_VALUE_IDX ] = Long.valueOf( Short.MIN_VALUE );
1:7fd0c6e:             retval[ MAX_VALUE_IDX ] = Long.valueOf( Short.MAX_VALUE );
1:7fd0c6e:         }
1:7fd0c6e:         else if ( getTypeId().equals( TypeId.INTEGER_ID ) )
1:7fd0c6e:         {
1:7fd0c6e:             retval[ MIN_VALUE_IDX ] = Long.valueOf( Integer.MIN_VALUE );
1:7fd0c6e:             retval[ MAX_VALUE_IDX ] = Long.valueOf( Integer.MAX_VALUE );
1:7fd0c6e:         } else if ( getTypeId().equals( TypeId.BIGINT_ID ) )
1:7fd0c6e:         {
1:7fd0c6e:             // Could only be BIGINT
1:7fd0c6e:             retval[ MIN_VALUE_IDX ] = Long.MIN_VALUE;
1:7fd0c6e:             retval[ MAX_VALUE_IDX ] = Long.MAX_VALUE;
1:7fd0c6e:         }
1:7fd0c6e:         else
1:7fd0c6e:         {
1:7fd0c6e:             throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:7fd0c6e:         }
1:7fd0c6e: 
1:7fd0c6e:         return retval;
1:7fd0c6e:     }
1:7fd0c6e:     
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * @param forEquals True if this is an = or != comparison, false
commit:2782d72
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Runtime INTEGER type that is nullable.
1:      */
1:     public static final DataTypeDescriptor DOUBLE =
1:         new DataTypeDescriptor(TypeId.DOUBLE_ID, true);
1:     
commit:7fd0c6e
/////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  final   int MIN_VALUE_IDX = 0;
1:     public  static  final   int MAX_VALUE_IDX = MIN_VALUE_IDX + 1;
1:     public  static  final   int MAX_MIN_ARRAY_SIZE = MAX_VALUE_IDX + 1;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the maximum and minimum value for a fixed numeric type.
1:      * Throws an unimplemented feature exception for a non-numeric type.
1:      */
1:     public  long[]  getNumericBounds()
1:         throws StandardException
1:     {
1:         long[]  retval = new long[ MAX_MIN_ARRAY_SIZE ];
1: 
1:         if ( getTypeId().equals( TypeId.SMALLINT_ID ) )
1:         {
1:             retval[ MIN_VALUE_IDX ] = Long.valueOf( Short.MIN_VALUE );
1:             retval[ MAX_VALUE_IDX ] = Long.valueOf( Short.MAX_VALUE );
1:         }
1:         else if ( getTypeId().equals( TypeId.INTEGER_ID ) )
1:         {
1:             retval[ MIN_VALUE_IDX ] = Long.valueOf( Integer.MIN_VALUE );
1:             retval[ MAX_VALUE_IDX ] = Long.valueOf( Integer.MAX_VALUE );
1:         } else if ( getTypeId().equals( TypeId.BIGINT_ID ) )
1:         {
1:             // Could only be BIGINT
1:             retval[ MIN_VALUE_IDX ] = Long.MIN_VALUE;
1:             retval[ MAX_VALUE_IDX ] = Long.MAX_VALUE;
1:         }
1:         else
1:         {
1:             throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
1:         }
1: 
1:         return retval;
1:     }
1:     
commit:46e7e7c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Get the descriptor for an internal PASSWORD type.
1:      */
0:     public  static  TypeDescriptor  getPasswordDataTypeDescriptor( boolean isNullable )
1:     {
0:         BaseTypeIdImpl baseTypeID = new BaseTypeIdImpl( StoredFormatIds.PASSWORD_TYPE_ID_IMPL );
1:         
0:         return new TypeDescriptorImpl( baseTypeID, isNullable, TypeId.VARCHAR_MAXWIDTH );
1:     }
1: 
commit:f2a5622
/////////////////////////////////////////////////////////////////////////
1:         // Right now, user defined types are not comparable.
1:         // This removes old logic which we might want
1:         // to revive when we support comparable UDTs. See
1:         // DERBY-4470.
1: 		if (typeId.isUserDefinedTypeId() || typeId.getJDBCTypeId() == Types.OTHER)
1: 		{ return false; }
commit:2a5922a
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
commit:2732872
/////////////////////////////////////////////////////////////////////////
1:                 return false;
1:             	return getTypeId().getBaseTypeId().isAnsiUDT();
commit:07d1108
/////////////////////////////////////////////////////////////////////////
1:     	//Numeric types are comparable to numeric types
1:     		return (compareWithTypeID.isNumericTypeId());
/////////////////////////////////////////////////////////////////////////
1: 		//Booleans are comparable to Boolean, string, and to 
1: 		//comparable user types. As part of the work on DERYB-887,
1:         //I removed the comparability of booleans to numerics; I don't
1: 		//understand the previous statement about comparable user types.
1:         //I suspect that is wrong and should be addressed when we
1:         //re-enable UDTs (see DERBY-651).
1:     				compareWithTypeID.isStringTypeId()); 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.BaseTypeIdImpl;
1: import org.apache.derby.catalog.types.RowMultiSetImpl;
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Get a DataTypeServices that corresponds to a SQL Row Multiset
1: 	 *
1: 	 * @param columnNames   Names of the columns in the Row Muliset
0: 	 * @param types                 Types of the columns in the Row Muliset
1: 	 *
1: 	 * @return	A new DataTypeDescriptor describing the SQL Row Multiset
1: 	 */
0: 	public static DataTypeDescriptor getRowMultiSet
1: 	(
0: 		String[]	                        columnNames,
0: 		DataTypeDescriptor[]	types
1: 	)
1: 	{
0: 		RowMultiSetImpl       rms = new RowMultiSetImpl( columnNames, types );
0: 		TypeId              typeID = new TypeId( StoredFormatIds.ROW_MULTISET_CATALOG_ID, rms );
1: 
0: 		return new DataTypeDescriptor( typeID, true);
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	* @see TypeDescriptor#isRowMultiSet
1: 	 */
0: 	public	boolean isRowMultiSet()
1: 	{
0: 		return getTypeId().isRowMultiSetTypeId();
1: 	}
1: 
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             case StoredFormatIds.BIGINT_TYPE_ID:
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:7f0f775
/////////////////////////////////////////////////////////////////////////
1:             //DERBY-6096 Need to estimate usage for BLOB and clob
1:             case StoredFormatIds.BLOB_TYPE_ID:
/////////////////////////////////////////////////////////////////////////
1:             //DERBY-6096 Need to estimate usage for BLOB and clob
1:             case StoredFormatIds.CLOB_TYPE_ID:
commit:3b598ee
/////////////////////////////////////////////////////////////////////////
1: 
1:     /* Return the typename with the collation name for 
1:      * String types.
1:      */
1:     public String getSQLTypeNameWithCollation() {
1:         String name = typeId.getSQLTypeName();
1:         if (typeId.isStringTypeId()) {
1:             name = name + " (" + getCollationName() + ")";
1:         }
1:         return name;    
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4d09732
/////////////////////////////////////////////////////////////////////////
commit:959fef2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Restore typeId from the type descriptor. User-defined types and
1:         // built-in types have different methods for getting the type id.
1:         if (typeDescriptor.isUserDefinedType()) {
1:             try {
1:                 typeId = TypeId.getUserDefinedTypeId(
1:                     ((UserDefinedTypeIdImpl) typeDescriptor.getTypeId())
1:                         .getClassName());
1:             } catch (StandardException se) {
1:                 throw (IOException)
1:                         new IOException(se.getMessage()).initCause(se);
1:             }
1:         } else {
1:             typeId = TypeId.getBuiltInTypeId(this.getTypeName());
1:         }
commit:5212101
/////////////////////////////////////////////////////////////////////////
1:      * Obtain the collation type from a collation property value.
1: 	 * @return The collation type, or -1 if not recognized.
1:      */
1: 	public static int getCollationType(String collationName)
1: 	{
1: 		if (collationName.equalsIgnoreCase(Property.UCS_BASIC_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_UCS_BASIC;
1: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED;
1: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_PRIMARY_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY;
1: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_SECONDARY_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_SECONDARY;
1: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_TERTIARY_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_TERTIARY;
1: 		else if (collationName.equalsIgnoreCase(Property.TERRITORY_BASED_IDENTICAL_COLLATION))
1: 			return StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL;
1: 		else
1: 			return -1;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE)
1: 			return Property.COLLATION_NONE;
1: 		else
1: 			return getCollationName(getCollationType());
1:      * Gets the name of the specified collation type.
1:      * @param collationType The collation type.
1:      * @return The name, e g "TERRITORY_BASED:PRIMARY".
1:      */
1:     public static String getCollationName(int collationType)
1:     {
1: 		switch (collationType) {
1: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED :
1: 				return Property.TERRITORY_BASED_COLLATION;
1: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_PRIMARY :
1: 				return Property.TERRITORY_BASED_PRIMARY_COLLATION;
1: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_SECONDARY :
1: 				return Property.TERRITORY_BASED_SECONDARY_COLLATION;
1: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_TERTIARY :
1: 				return Property.TERRITORY_BASED_TERTIARY_COLLATION;
1: 			case StringDataValue.COLLATION_TYPE_TERRITORY_BASED_IDENTICAL :
1: 				return Property.TERRITORY_BASED_IDENTICAL_COLLATION;
1: 			default :
1: 				return Property.UCS_BASIC_COLLATION;
1: 		}
1:     }
1: 
1:      /**
commit:0b97566
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:                 SanityManager.THROWASSERT("cachedDest is null");
1:             }
/////////////////////////////////////////////////////////////////////////
1:             cachedDest.setToNull();
commit:d45f7d3
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Determine if an ASCII stream can be inserted into a column or parameter
1: 	 * of type <code>jdbcType</code>.
1: 	 *
1: 	 * @param jdbcType JDBC type of column or parameter
1: 	 * @return <code>true</code> if an ASCII stream can be inserted;
1: 	 *         <code>false</code> otherwise
1: 	 */
1: 	public static boolean isAsciiStreamAssignable(int jdbcType) {
1: 		return jdbcType == Types.CLOB || isCharacterType(jdbcType);
1: 	}
1: 
1: 	/**
1: 	 * Determine if a binary stream can be inserted into a column or parameter
1: 	 * of type <code>jdbcType</code>.
1: 	 *
1: 	 * @param jdbcType JDBC type of column or parameter
1: 	 * @return <code>true</code> if a binary stream can be inserted;
1: 	 *         <code>false</code> otherwise
1: 	 */
1: 	public static boolean isBinaryStreamAssignable(int jdbcType) {
1: 		return jdbcType == Types.BLOB || isBinaryType(jdbcType);
1: 	}
1: 
1: 	/**
1: 	 * Determine if a character stream can be inserted into a column or
1: 	 * parameter of type <code>jdbcType</code>.
1: 	 *
1: 	 * @param jdbcType JDBC type of column or parameter
1: 	 * @return <code>true</code> if a character stream can be inserted;
1: 	 *         <code>false</code> otherwise
1: 	 */
1: 	public static boolean isCharacterStreamAssignable(int jdbcType) {
1: 		// currently, we support the same types for ASCII streams and
1: 		// character streams
1: 		return isAsciiStreamAssignable(jdbcType);
1: 	}
1: 
commit:6796671
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Check whether a JDBC type is one of the character types that are
1: 	 * compatible with the Java type <code>String</code>.
1: 	 *
1: 	 * <p><strong>Note:</strong> <code>CLOB</code> is not compatible with
1: 	 * <code>String</code>. See tables B-4, B-5 and B-6 in the JDBC 3.0
1: 	 * Specification.
1: 	 *
1: 	 * <p> There are some non-character types that are compatible with
1: 	 * <code>String</code> (examples: numeric types, binary types and
1: 	 * time-related types), but they are not covered by this method.
1: 	 *
1: 	 * @param jdbcType a JDBC type
1: 	 * @return <code>true</code> iff <code>jdbcType</code> is a character type
1: 	 * and compatible with <code>String</code>
1: 	 * @see java.sql.Types
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Check whether a JDBC type is compatible with the Java type
1: 	 * <code>byte[]</code>.
1: 	 *
1: 	 * <p><strong>Note:</strong> <code>BLOB</code> is not compatible with
1: 	 * <code>byte[]</code>. See tables B-4, B-5 and B-6 in the JDBC 3.0
1: 	 * Specification.
1: 	 *
1: 	 * @param jdbcType a JDBC type
1: 	 * @return <code>true</code> iff <code>jdbcType</code> is compatible with
1: 	 * <code>byte[]</code>
1: 	 * @see java.sql.Types
1: 	 */
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:90701f7
/////////////////////////////////////////////////////////////////////////
1: 		return typeDescriptor.getTypeName();
/////////////////////////////////////////////////////////////////////////
0:         typeId = TypeId.getBuiltInTypeId(this.getTypeName());
commit:111785f
/////////////////////////////////////////////////////////////////////////
commit:9355b96
/////////////////////////////////////////////////////////////////////////
1: 	 * for comparison are as follows (these are as per SQL standard 2003 
1: 	 * Section 9.13)
1: 	 * 
1: 	 * 3)If one DTD has collation derivation of IMPLICIT and other DTD has
1: 	 * collation derivation of NONE, then 2 DTDs are comparable using the
1: 	 * collation type of DTD with collation derivation of IMPLICIT. Derby does
1: 	 * not implement this rule currently and it is being traked as DERBY-2678.
1: 	 * Derby's current behavior is to throw an exception if both the DTDs 
1: 	 * involved in collation operation do not have collation derivation of 
1: 	 * IMPLICIT. This behavior is a subset of SQL standard.
1: 	 * 4)Derby currently does not support collation derivation of EXPLICIT and
1: 	 * hence we do not have the code to enforce rules as mentioned in Section
1: 	 * 9.13 of SQL spec for collation derivation of EXPLICIT. When we implement
1: 	 * collation derivation of EXPLICIT, we should make sure that we follow the
1: 	 * rules as specified in the SQL spec for comparability.
commit:ba2ee28
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Compare the collation info on this DTD with the passed DTD. The rules
0: 	 * are as follows
1: 	 * 1)If both the DTDs have collation derivation of NONE, then they can't be
1: 	 * compared and we return false.
1: 	 * 2)If both the DTDs have same collation derivation (which in Derby's case
1: 	 * at this point will mean collation derivation of IMPLICIT), then check
1: 	 * the collation types. If they match, then return true. If they do not 
1: 	 * match, then they can't be compared and hence return false.
1: 	 * 
0: 	 * In future, when we do support collation derivation of EXPLICIT, we will
0: 	 * need to change this method so that we follow the correct SQL standard
0: 	 * rules about what should happen if one collation derivation is EXPLICIT
0: 	 * and other is NONE/IMPLICIT.
1: 	 * 
1: 	 * @param compareWithDTD compare this DTD's collation info
1: 	 *  
1: 	 * @return value depends on the algorithm above.
1: 	 */
commit:5d769a1
/////////////////////////////////////////////////////////////////////////
1: /** 
/////////////////////////////////////////////////////////////////////////
1:     			return compareCollationInfo(compareWithDTD);    			
/////////////////////////////////////////////////////////////////////////
1: 	public boolean compareCollationInfo(DataTypeDescriptor compareWithDTD){
1: 		//both the operands can not have the collation derivation of
1: 		//NONE. This is because in that case, we do not know what kind
1: 		//of collation to use for comparison.
1: 		if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
1: 				getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE)
1: 			return false;
1: 		if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
1: 				getCollationType() == compareWithDTD.getCollationType())
1: 			return true;//collation matches
1: 		else
1: 			return false;//collation does not match
1: 		}
1: 		 				
commit:2e5d7c5
/////////////////////////////////////////////////////////////////////////
0:     			//both the operands can not have the collation derivation of 
0:     			//NONE. This is because in that case, we do not know what kind 
0:     			//of collation to use for comparison.
0:     			if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
0:     					getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE)
1:     				return false;
commit:12f2b05
/////////////////////////////////////////////////////////////////////////
1: 	 * algorithm have been numbered in the comments below and those same 
commit:2364fd8
/////////////////////////////////////////////////////////////////////////
1: 	 * 
1: 	 * If dealing with character string types, then make sure to set the
1: 	 * collation info on the dominant type. Following algorithm will be used 
1: 	 * for dominant DTD's collation determination. Each of the steps of the 
0: 	 * algorithem have been numbered in the comments below and those same 
1: 	 * numbers are used in the actual algorithm below so it is easier to 
1: 	 * understand and maintain.
1: 	 * 
1: 	 * Step 1
1: 	 * If the DTD for "this" node has the same collation derivation as the 
1: 	 * otherDTS, then check if their collation types match too. If the 
1: 	 * collation types match too, then DTD for dominant type will get the same 
1: 	 * collation derivation and type.
1: 	 *  
1: 	 * Step 2
1: 	 * If the collation derivation for DTD for "this" node and otherDTS do not 
1: 	 * match, then check if one of them has the collation derivation of NONE. 
1: 	 * If that is the case, then dominant DTD will get the collation type and 
1: 	 * derivation of DTD whose collation derivation is not NONE.
1: 	 * 
1: 	 * Step 3
1: 	 * If the collation derivation for DTD for "this" node and otherDTS do not 
1: 	 * match, and none of them have the derivation of NONE then it means that 
1: 	 * we are dealing with collation derivation of IMPLICIT and EXPLICIT and 
1: 	 * hence the dominant DTD should get collation derivation of NONE. This is 
1: 	 * not a possibility in Derby 10.3 because the only 2 possible collation 
1: 	 * derivation supported are IMPLICIT and NONE.
1: 	 * 
1: 	 * Step 4
1: 	 * If the collation derivation for DTD for "this" node and otherDTS match, 
1: 	 * then check if the collation types match too. If not, then the dominant 
1: 	 * DTD should get collation derivation of NONE. 
/////////////////////////////////////////////////////////////////////////
1: 		//Set collation info on the DTD for dominant type if it is string type
1: 		//The algorithm used is explained in this method's javadoc
1: 		if (higherType.getTypeId().isStringTypeId()) {
1: 			if (getCollationDerivation() != otherDTS.getCollationDerivation()) {
1: 				if (getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE) {
1: 					//Step 2
0: 					higherType.setCollationDerivation(otherDTS.getCollationDerivation());					
0: 					higherType.setCollationType(otherDTS.getCollationType());					
1: 				} else if (otherDTS.getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE) {
1: 					//Step 2
0: 					higherType.setCollationDerivation(getCollationDerivation());					
0: 					higherType.setCollationType(getCollationType());										
1: 				} else {
1: 					//Step 3
0: 					higherType.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_NONE);					
1: 				}
1: 			} else if (getCollationType() != otherDTS.getCollationType())
1: 				//Step 4
0: 				higherType.setCollationDerivation(StringDataValue.COLLATION_DERIVATION_NONE);	
1: 			else {
1: 				//Step 1
0: 				higherType.setCollationDerivation(getCollationDerivation());					
0: 				higherType.setCollationType(getCollationType());									
1: 			}
1: 		}
1: 
commit:68f9f47
/////////////////////////////////////////////////////////////////////////
1: 	 * Constructor to use when the caller doesn't know if it is requesting
1: 	 * numeric or no-numeric DTD. For instance, when dealing with MAX/MIN 
1: 	 * aggregrate operators, AggregateNode.bindExpression could be dealing
1: 	 * with a character string operand or a numeric operand. The result of
1: 	 * MAX/MIN will depend on the type of it's operand. And hence when this
1: 	 * constructor gets called by AggregateNode.bindExpression, we don't know 
1: 	 * what type we are constructing and hence this constructor supports 
1: 	 * arguments for both numeric and non-numeric types.
commit:f90d449
/////////////////////////////////////////////////////////////////////////
0: 	 * Constructor for use with numeric types/non-numeric types. For instance,
0: 	 * when dealing with MAX/MIN aggregrade operators, we do not if we are
0: 	 * working with numeric or non-numeric types. Such a constructor will be
0: 	 * used in those cases. 
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 * @param collationType The collation type of a string data type
1: 	 * @param collationDerivation Collation Derivation of a string data type
1: 	 */
1: 	public DataTypeDescriptor(TypeId typeId, int precision, int scale,
1: 		boolean isNullable, int maximumWidth, int collationType,
1: 		int collationDerivation)
1: 	{
1: 		this.typeId = typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1: 												precision,
1: 												scale,
1: 												isNullable,
1: 												maximumWidth,
1: 												collationType,
1: 												collationDerivation);
1: 	}
1: 
1: 	/**
commit:244952e
/////////////////////////////////////////////////////////////////////////
1: 												maximumWidth,
0: 												source.getCollationType(),
0: 												source.getCollationDerivation());
/////////////////////////////////////////////////////////////////////////
1: 				source.getPrecision(),
1: 				source.getScale(),
1: 				isNullable,
1: 				maximumWidth,
0: 				source.getCollationType(),
0: 				source.getCollationDerivation());
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 				precision, scale, nullable, maximumWidth);
commit:dbfbecb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.ConnectionUtil;
1: import java.text.RuleBasedCollator;
/////////////////////////////////////////////////////////////////////////
1: 	public DataValueDescriptor getNull() throws StandardException {
1: 		DataValueDescriptor returnDVD = typeId.getNull();
1: 		//If we are dealing with default collation, then we have got the
1: 		//right DVD already. Just return it.
1: 		if (typeDescriptor.getCollationType() == StringDataValue.COLLATION_TYPE_UCS_BASIC)
1: 			return returnDVD;			
1: 		//If we are dealing with territory based collation and returnDVD is 
1: 		//of type StringDataValue, then we need to return a StringDataValue   
1: 		//with territory based collation.
1: 		if (returnDVD instanceof StringDataValue) {
1: 			try {
1: 				RuleBasedCollator rbs = ConnectionUtil.getCurrentLCC().getDataValueFactory().
1: 				getCharacterCollator(typeDescriptor.getCollationType());
1: 				return ((StringDataValue)returnDVD).getValue(rbs);
1: 			}
1: 			catch( java.sql.SQLException sqle)
1: 			{
1: 				throw StandardException.plainWrapException( sqle);
1: 			}
1: 		}
1: 		else
1: 			return returnDVD;			
commit:3841b98
/////////////////////////////////////////////////////////////////////////
1: 		//There might be other places, but one place this method gets called
1: 		//from is ResultColumn.init. When the ResultColumn(RC) is for a 
1: 		//ColumnDescriptor(CD), the RC's TypeDescriptorImpl(TDI) should get 
1: 		//all the attributes of CD's TDI. So, if the CD is for a user table's
1: 		//character type column, then this call by RC.init should have CD's 
1: 		//collation attributes copied into RC along with other attributes. 
1: 												source.getMaximumWidth(),
0: 												source.getCollationType(),
0: 												source.getCollationDerivation());
commit:2d32bab
/////////////////////////////////////////////////////////////////////////
1: 		// Long types cannot be compared. 
1: 		// XML types also fall in this window
1: 		// Says SQL/XML[2003] spec:
1: 		// 4.2.2 XML comparison and assignment
1: 		// "XML values are not comparable."
1: 		// An XML value cannot be compared to any type--
1: 		// not even to other XML values.
/////////////////////////////////////////////////////////////////////////
1: 
0:     	//Numeric types are comparable to numeric types, boolean types and to 
0: 		//comparable user types
1: 		if (typeId.isNumericTypeId())
0:     		return (compareWithTypeID.isNumericTypeId() || 
1: 		//CHAR, VARCHAR and LONGVARCHAR are comparable to strings, boolean, 
1: 		//DATE/TIME/TIMESTAMP and to comparable user types
1: 		if (typeId.isStringTypeId()) {
1:     		if((compareWithTypeID.isDateTimeTimeStampTypeID() ||
1:     				compareWithTypeID.isBooleanTypeId()))
1:     				return true;
1:     		//If both the types are string types, then we need to make sure
1:     		//they have the same collation set on them
1:     		if (compareWithTypeID.isStringTypeId() && typeId.isStringTypeId()) {
0:     			if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
0:     					getCollationType() == compareWithDTD.getCollationType())
0:     				return true;//collation matches
1:     			else
0:     				return false;//collation does not match
1:     		} else
1:     			return false;//can't be compared			
1: 		}
1:     	//Are comparable to other bit types and comparable user types
1: 		if (typeId.isBitTypeId()) 
1:         	return (compareWithTypeID.isBitTypeId()); 
1: 		
0: 		//Booleans are comparable to Boolean, string, numeric and to 
0: 		//comparable user types 
1: 		if (typeId.isBooleanTypeId())
1:     		return (compareWithTypeID.getSQLTypeName().equals(typeId.getSQLTypeName()) ||
0:     				compareWithTypeID.isStringTypeId() ||
0:     				compareWithTypeID.isNumericTypeId()); 
1: 		//Dates are comparable to dates, strings and to comparable
1: 		//user types.
1: 		if (typeId.getJDBCTypeId() == Types.DATE)
1:     		if (compareWithJDBCTypeId == Types.DATE || 
1:     				compareWithTypeID.isStringTypeId())
1:     			return true;
1:     		else
1:     			return false;
1:     	//Times are comparable to times, strings and to comparable
1: 		//user types.
1: 		if (typeId.getJDBCTypeId() == Types.TIME)
1:     		if (compareWithJDBCTypeId == Types.TIME || 
1:     				compareWithTypeID.isStringTypeId())
1:     			return true;
1:     		else
1:     			return false;
1:     	//Timestamps are comparable to timestamps, strings and to
1: 		//comparable user types.
1: 		if (typeId.getJDBCTypeId() == Types.TIMESTAMP)
1:     		if (compareWithJDBCTypeId == Types.TIMESTAMP || 
1:     				compareWithTypeID.isStringTypeId())
1:     			return true;
1:     		else
1:     			return false;
0: 		//User types are comparable to other user types only if
0: 		//(for now) they are the same type and are being used to
0: 		//implement some JDBC type.  This is sufficient for
0: 		//date/time types; it may be generalized later for e.g.
0: 		//comparison of any user type with one of its subtypes.
0: 		if (typeId.isUserDefinedTypeId() || typeId.getJDBCTypeId() == Types.OTHER) {
0:         	if (forEquals)
1:         		return true;
0:         	try {
1:         	
0:         		Class thisClass = cf.getClassInspector().getClass(
0: 				typeId.getCorrespondingJavaTypeName());
1:         		
0:         		return java.lang.Comparable.class.isAssignableFrom(thisClass);
0:         	} catch (ClassNotFoundException cnfe) {
1:         		return false;
1:         	}			
commit:2bb198a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC30Translation;
/////////////////////////////////////////////////////////////////////////
1: 	 * Check if this type is comparable with the passed type.
1: 	 * 
1: 	 * @param compareWithDTD the type of the instance to compare with this type.
0: 	 * @param forEquals True if this is an = or <> comparison, false
1: 	 *					otherwise.
1: 	 * @param cf		A ClassFactory
1: 	 * @return true if compareWithDTD is comparable to this type, else false.
1: 	 */
1: 	public boolean	comparable(DataTypeDescriptor compareWithDTD,
1:             boolean forEquals,
1:             ClassFactory cf){
1: 
1: 		TypeId compareWithTypeID = compareWithDTD.getTypeId();
1: 		int compareWithJDBCTypeId = compareWithTypeID.getJDBCTypeId();
1: 
0: 		// Long types cannot be compared
1: 		if (compareWithTypeID.isLongConcatableTypeId() || typeId.isLongConcatableTypeId())
1: 			return false;
1: 
1: 		// Ref types cannot be compared
1: 		if (typeId.isRefTypeId() || compareWithTypeID.isRefTypeId())
1: 			return false;
1: 		
1: 		//If this DTD is not user defined type but the DTD to be compared with 
1: 		//is user defined type, then let the other DTD decide what should be the
1: 		//outcome of the comparable method.
1: 		if (!(typeId.isUserDefinedTypeId()) && 
1: 				(compareWithTypeID.isUserDefinedTypeId()))
1: 			return compareWithDTD.comparable(this, forEquals, cf);
1: 		
1:         switch (typeId.getJDBCTypeId()) 
1: 		{
1:                 case Types.DECIMAL:
1:                 case Types.BIGINT:
1:                 case Types.DOUBLE:
1:                 case Types.INTEGER:
1:                 case Types.NUMERIC:
1:                 case Types.REAL:
1:                 case Types.SMALLINT:
1:                 case Types.TINYINT:
0:                 	// Numeric types are comparable to numeric types, boolean 
0:                 	//types and to comparable user types
0:             		return (compareWithTypeID.isNumericTypeId() ||
0:             		compareWithTypeID.isBooleanTypeId());
1: 
1:                 case Types.CHAR:
1:                 case Types.LONGVARCHAR:
1:                 case Types.VARCHAR:
0:             		// CHAR and VARCHAR are comparable to strings, boolean, 
0:                 	// DATE/TIME/TIMESTAMP and to comparable user types
0:             		if((compareWithTypeID.isDateTimeTimeStampTypeID() ||
0:             				compareWithTypeID.isBooleanTypeId()))
1:             				return true;
0:             		//If both the types are string types, then we need to make
0:             		//sure they have the same collation set on them
0:             		if (compareWithTypeID.isStringTypeId() && typeId.isStringTypeId()) {
0:             			if (getCollationDerivation() == compareWithDTD.getCollationDerivation() &&
0:             					getCollationType() == compareWithDTD.getCollationType())
1:             				return true;
1:             			else
1:             				return false;
0:             		} else
1:             			return false;
1:             		
1: 
1:                 case Types.BIT:
0:                 case JDBC30Translation.SQL_TYPES_BOOLEAN:
0:             		/* Are comparable to Boolean, string, numeric and to 
0:             		 * comparable user types */
0:             		return (compareWithTypeID.getSQLTypeName().equals(typeId.getSQLTypeName()) ||
0:             				compareWithTypeID.isStringTypeId() ||
0:             				compareWithTypeID.isNumericTypeId()); 
1: 
1:                 case Types.DATE:
1:                 	/*
0:                 	 * Dates are comparable to dates, strings and to comparable
0:                 	 * user types.
1:                 	 */
0:             		if (compareWithJDBCTypeId == Types.DATE || 
0:             				compareWithTypeID.isStringTypeId())
1:             			return true;
1:             		else
1:             			return false;
1: 
1:                 case Types.TIME:
1:                 	/*
0:                 	 * Times are comparable to times, strings and to comparable
0:                 	 * user types.
1:                 	 */
0:             		if (compareWithJDBCTypeId == Types.TIME || 
0:             				compareWithTypeID.isStringTypeId())
1:             			return true;
1:             		else
1:             			return false;
1: 
1:                 case Types.TIMESTAMP:
1:                 	/*
0:                 	 * Timestamps are comparable to timestamps, strings and to 
0:                 	 * comparable user types.
1:                 	 */
0:             		if (compareWithJDBCTypeId == Types.TIMESTAMP || 
0:             				compareWithTypeID.isStringTypeId())
1:             			return true;
1:             		else
1:             			return false;
1: 
1:                 case Types.BINARY:
1:                 case Types.LONGVARBINARY:
1:                 case Types.VARBINARY:
0:                 	//Are comparable to other bit types and comparable user types
0:                 	return (compareWithTypeID.isBitTypeId()); 
1: 
0:                 case org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT:
0:                 case Types.OTHER:
1:                 	/*
0:                 	 * User types are comparable to other user types only if
0:                 	 * (for now) they are the same type and are being used to
0:                 	 * implement some JDBC type.  This is sufficient for
0:                 	 * date/time types; it may be generalized later for e.g.
0:                 	 * comparison of any user type with one of its subtypes.
1:                 	 */
0:                 	if (forEquals)
1:                 		return true;
0:                 	try {
1:                 	
0:                 		Class thisClass = cf.getClassInspector().getClass(
0:     					typeId.getCorrespondingJavaTypeName());
1:                 		
0:                 		return java.lang.Comparable.class.isAssignableFrom(thisClass);
0:                 	} catch (ClassNotFoundException cnfe) {
1:                 		return false;
1:                 	}
1: 
0:                 case StoredFormatIds.XML_TYPE_ID:
1:                     /*
0:                      * Tell whether this type (XML) can be compared to the given type.
0:                      * Says SQL/XML[2003] spec:
1:                      *
0:                      * 4.2.2 XML comparison and assignment
0:                      * "XML values are not comparable."
1:                      * 
0:                      * An XML value cannot be compared to any type--
0:                      * not even to other XML values.
1:                      */ 
1:                 	return false;
1: 		}
1: 
1: 		return false;
1: 	}
1: 	
1: 		
1: 	/**
commit:96a630c
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeDescriptor#getCollationType() */
0: 	/** @see TypeDescriptor#setCollationType(int) */
0: 	/** @see TypeDescriptor#getCollationDerivation() */
1: 	public int	getCollationDerivation()
0: 	/** @see TypeDescriptor#setCollationDerivation(int) */
0: 	public void	setCollationDerivation(int collationDerivationValue)
commit:7752cf6
/////////////////////////////////////////////////////////////////////////
0: 	/** @see TypeDescriptor.getCollationType */
1: 	public int	getCollationType()
1: 	{
1: 		return typeDescriptor.getCollationType();
1: 	}
1: 
0: 	/** @see TypeDescriptor.setCollationType */
0: 	public void	setCollationType(int collationTypeValue)
1: 	{
0: 		typeDescriptor.setCollationType(collationTypeValue);
1: 	}
1: 
0: 	/** @see TypeDescriptor.getCollationDerivation */
0: 	public String	getCollationDerivation()
1: 	{
0: 		return typeDescriptor.getCollationDerivation();
1: 	}
1: 
0: 	/** @see TypeDescriptor.setCollationDerivation */
0: 	public void	setCollationDerivation(String collationDerivationValue)
1: 	{
0: 		typeDescriptor.setCollationDerivation(collationDerivationValue);
1: 	}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:fbb0d4f
/////////////////////////////////////////////////////////////////////////
1:         
1:         TypeId typeId = TypeId.getTypeId(catalogType);
1:  
1:             new DataTypeDescriptor(typeDescriptor, typeId);
/////////////////////////////////////////////////////////////////////////
1:         return new TypeDescriptorImpl(rms, true, -1);
/////////////////////////////////////////////////////////////////////////
commit:b260d95
/////////////////////////////////////////////////////////////////////////
1:      * Shorthand method for getCatalogType().getMaximumWidth().
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Shorthand method for getCatalogType().getJDBCTypeId().
/////////////////////////////////////////////////////////////////////////
1:      * Shorthand method for getCatalogType().getPrecision().
1:      * @see TypeDescriptor#getPrecision()
/////////////////////////////////////////////////////////////////////////
1:      * Shorthand method for getCatalogType().getScale().
1:      * @see TypeDescriptor#getScale()
1: 	/**
1:      * Obtain the collation type of the underlying catalog type.
1:      * Shorthand method for getCatalogType().getCollationType().
1:      * @see TypeDescriptor#getCollationType()
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Shorthand method for getCatalogType().isNullable();
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
1: 		case Types.BOOLEAN:
commit:2e83f13
/////////////////////////////////////////////////////////////////////////
1:  * <P>
1:  * A DataTypeDescriptor is immutable.
1: public final class DataTypeDescriptor implements Formatable
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Runtime INTEGER type that is nullable.
1:      */
1:     public static final DataTypeDescriptor INTEGER =
1:         new DataTypeDescriptor(TypeId.INTEGER_ID, true);
1:     
1:     /**
1:      * Runtime INTEGER type that is not nullable.
1:      */
1:     public static final DataTypeDescriptor INTEGER_NOT_NULL =
1:         INTEGER.getNullabilityType(false);
1:     
1:     /**
1:      * Runtime SMALLINT type that is nullable.
1:      */
1:     public static final DataTypeDescriptor SMALLINT =
1:         new DataTypeDescriptor(TypeId.SMALLINT_ID, true);
1:     
1:     /**
1:      * Runtime INTEGER type that is not nullable.
1:      */
1:     public static final DataTypeDescriptor SMALLINT_NOT_NULL =
1:         SMALLINT.getNullabilityType(false);
1:      
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * For well known types code may also use the pre-defined
1:      * runtime types that are fields of this class, such as INTEGER.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * For well known types code may also use the pre-defined
1:      * runtime types that are fields of this class, such as INTEGER.
1:      * E.g. using DataTypeDescriptor.INTEGER is preferred to
1:      * DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, true)
1:      * (both will return the same immutable object).
/////////////////////////////////////////////////////////////////////////
1:         // Re-use pre-defined types wherever possible.
1:         switch (jdbcType)
1:         {
1:         case Types.INTEGER:
1:             return isNullable ? INTEGER : INTEGER_NOT_NULL;
1:         case Types.SMALLINT:
1:             return isNullable ? SMALLINT : SMALLINT_NOT_NULL;
1:         default:
1:             break;
1:         }
1: 
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		return typeDescriptor.getJDBCTypeId();
/////////////////////////////////////////////////////////////////////////
1:         
0:         typeId = TypeId.getBuiltInTypeId(this.getJDBCTypeId());
1:         
1:         collationDerivation = in.readInt();
/////////////////////////////////////////////////////////////////////////
1: 		out.writeObject(typeDescriptor);
1:         out.writeInt(getCollationDerivation());
/////////////////////////////////////////////////////////////////////////
1: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_DESCRIPTOR_V02_ID; }
/////////////////////////////////////////////////////////////////////////
commit:01b5961
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get a catlog type identical to the passed in type exception
1:      * that the collationType is set to the passed in value.
1:      * @param catalogType Type to be based upon.
1:      * @param collationType Collation type of returned type.
1:      * 
1:      * @return catalogType if it already has the correct collation,
1:      * otherwise a new TypeDescriptor with the correct collation.
1:      */
1:     public static TypeDescriptor getCatalogType(TypeDescriptor catalogType,
1:             int collationType)
1:     {
1:         if (catalogType.isRowMultiSet())
1:             return getRowMultiSetCollation(catalogType, collationType);
1:         
1:         if (catalogType.getCollationType() == collationType)
1:             return catalogType;
1:         
1:         // Create through a runtime type, derivation will be thrown away.
1:         return getType(catalogType).getCollatedType(collationType,
1:                 StringDataValue.COLLATION_DERIVATION_IMPLICIT).getCatalogType();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public static TypeDescriptor getRowMultiSet(String[] columnNames,
1:             TypeDescriptor[] catalogTypes)
1:     {
/////////////////////////////////////////////////////////////////////////
1:      * taken from the passed in information. If the type
1:      * does not represent a string type then the collation
1:      * will be unchanged and this is returned.
1:      * 
1:     {        
1:         if (!typeDescriptor.isStringType())
1:             return this;
1:         
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * For a row multi set type return an identical type
1:      * with the collation type changed. Note that since
1:      * row types are only ever catalog types the
1:      * derivation is not used (since derivation is a property
1:      * of runtime types).
1:      * <BR>
1:      * 
1:      * 
1:      * @param collationType
1:      * @return this  will be returned if no changes are required (e.g.
1:      * no string types or collation is already correct), otherwise a
1:      * new instance is returned (leaving this unchanged).
1:      */
1:     private static TypeDescriptor getRowMultiSetCollation(
1:             TypeDescriptor catalogType, int collationType)
1:     {
1:         TypeDescriptor[] rowTypes = catalogType.getRowTypes();
1:         
1:         TypeDescriptor[] newTypes = null;
1:         
1:         for (int t = 0; t < rowTypes.length; t++)
1:         {
1:             TypeDescriptor newType = DataTypeDescriptor.getCatalogType(
1:                     rowTypes[t], collationType);
1:             
1:             // Is it the exact same as the old type.
1:             if (newType == rowTypes[t])
1:                 continue;
1:             
1:             if (newTypes == null)
1:             {
1:                 // First different type, simply create a new
1:                 // array and copy all the old types across.
1:                 // Any new type will overwrite the old type.
1:                 newTypes = new TypeDescriptor[rowTypes.length];
1:                 System.arraycopy(rowTypes, 0, newTypes, 0, rowTypes.length);
1:             }
1:             
1:             newTypes[t] = newType;
1:         }
1:         
1:         // If no change then we continue to use this instance.
1:         if (newTypes == null)
1:             return catalogType;
1:         
1:         return DataTypeDescriptor.getRowMultiSet(
1:                 catalogType.getRowColumnNames(),
1:                 newTypes);
1:     }
commit:d66ce7b
/////////////////////////////////////////////////////////////////////////
1: 	 * Get a catalog type that corresponds to a SQL Row Multiset
0: 	public static TypeDescriptor getRowMultiSet
/////////////////////////////////////////////////////////////////////////
0: 		return new DataTypeDescriptor( typeID, true).getCatalogType();
/////////////////////////////////////////////////////////////////////////
1: 
0:     // TEMP: DERBY-2917 - refactoring type system
0:     public String[] getRowColumnNames() {
1:         if (SanityManager.DEBUG)
0:             SanityManager.THROWASSERT("Row type must always be a catalog type");
1:         return null;
1:     }
1: 
0:     // TEMP: DERBY-2917 - refactoring type system
0:     public TypeDescriptor[] getRowTypes() {
1:         if (SanityManager.DEBUG)
0:             SanityManager.THROWASSERT("Row type must always be a catalog type");
1:         return null;
1:     }
commit:9ed7c4d
/////////////////////////////////////////////////////////////////////////
1:      * If a variable length type then the size information will be set 
1:      * to the maximum possible.
1:      * 
1:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Get a descriptor that corresponds to a nullable builtin variable
1:      * length JDBC type.
1:      *
1:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
1:      * 
1:      * @param jdbcType  The int type of the JDBC type for which to get
1:      *                      a corresponding SQL DataTypeDescriptor
1:      *
1:      * @return  A new DataTypeDescriptor that corresponds to the Java type.
1:      *          A null return value means there is no corresponding SQL type
1:      */
1:     public static DataTypeDescriptor getBuiltInDataTypeDescriptor
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
/////////////////////////////////////////////////////////////////////////
1: 	 * Get a DataTypeServices that corresponds to a nullable builtin SQL type.
1:      * 
1:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * Collation type will be UCS_BASIC and derivation IMPLICIT.
/////////////////////////////////////////////////////////////////////////
1: 		DataTypeDescriptor	higherType;
/////////////////////////////////////////////////////////////////////////
1:                     higherType = higherType.getCollatedType(
1:                             otherDTS.getCollationType(),
1:                             otherDTS.getCollationDerivation());                                      
1: 
1:                     higherType = higherType.getCollatedType(
1:                             getCollationType(),
1:                             getCollationDerivation());										
1:                     higherType = higherType.getCollatedType(
1:                             StringDataValue.COLLATION_TYPE_UCS_BASIC, // ignored
1:                             StringDataValue.COLLATION_DERIVATION_NONE);					
1:                 higherType = higherType.getCollatedType(
1:                         StringDataValue.COLLATION_TYPE_UCS_BASIC, // ignored
1:                         StringDataValue.COLLATION_DERIVATION_NONE);                 
1:                 higherType = higherType.getCollatedType(
1:                         getCollationType(),
1:                         getCollationDerivation());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Collation derivation will be initialized to COLLATION_DERIVATION_IMPLICIT
1:      * if not explicitly set.
/////////////////////////////////////////////////////////////////////////
commit:ae196bc
/////////////////////////////////////////////////////////////////////////
commit:b25481f
/////////////////////////////////////////////////////////////////////////
1:         dtd.collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
/////////////////////////////////////////////////////////////////////////
1: 	private DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable)
/////////////////////////////////////////////////////////////////////////
1:     
1:     private DataTypeDescriptor(DataTypeDescriptor source,
1:             int collationType,
1:             int collationDerivation)
1:     {
1:         //There might be other places, but one place this method gets called
1:         //from is ResultColumn.init. When the ResultColumn(RC) is for a 
1:         //ColumnDescriptor(CD), the RC's TypeDescriptorImpl(TDI) should get 
1:         //all the attributes of CD's TDI. So, if the CD is for a user table's
1:         //character type column, then this call by RC.init should have CD's 
1:         //collation attributes copied into RC along with other attributes. 
1:         this.typeId = source.typeId;
1:         typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1:                                                 source.getPrecision(),
1:                                                 source.getScale(),
1:                                                 source.isNullable(),
1:                                                 source.getMaximumWidth(),
1:                                                 collationType
1:                                                 );
1:         this.collationDerivation = collationDerivation;
1:     }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return a type description identical to this type
1:      * with the exception that its collation information is
0:      * taken from the passed in information.
1:     * @return This if collation would be unchanged otherwise a new type.
1:      */   
1:     public DataTypeDescriptor getCollatedType(int collationType,
1:             int collationDerivation)
1:     {
1:         if ((getCollationType() == collationType) &&
1:             (getCollationDerivation() == collationDerivation))
1:             return this;
1:                 
1:         return new DataTypeDescriptor(this,
0:                 collationType,
0:                 collationDerivation);
1:     }
commit:baca785
/////////////////////////////////////////////////////////////////////////
1: 		DataTypeDescriptor dtd =
0:             new DataTypeDescriptor(typeDescriptor, wrapperTypeId);
1:         
1:         // By definition, any catalog type (column in a table,
1:         // procedure etc.) is derivation implicit.
0:         dtd.setCollationDerivation(
0:                 StringDataValue.COLLATION_DERIVATION_IMPLICIT);
1:         
1:         return dtd;
/////////////////////////////////////////////////////////////////////////
0:         TypeDescriptor[] catalogTypes =
0:             new TypeDescriptor[types.length];
0:         for (int i = 0; i < types.length; i++)
0:             catalogTypes[i] = types[i].getCatalogType();
1: 		RowMultiSetImpl rms = new RowMultiSetImpl(columnNames, catalogTypes);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Derivation of this type. All catalog types are
1:      * by definition implicit.
1:      */
commit:c0c33cd
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Property;
/////////////////////////////////////////////////////////////////////////
1:  * It consists of a catalog type (TypeDescriptor)
1:  * and runtime attributes. The list of runtime
1:  * attributes is:
1:  * <UL>
1:  * <LI> Collation Derivation
1:  * </UL>
/////////////////////////////////////////////////////////////////////////
1:     
0:     /** @see TypeDescriptor#getCollationDerivation() */
1:     private int collationDerivation = StringDataValue.COLLATION_DERIVATION_IMPLICIT;
1: 
/////////////////////////////////////////////////////////////////////////
1: 												collationType);
1:         this.collationDerivation = collationDerivation;
/////////////////////////////////////////////////////////////////////////
1: 												source.getCollationType()
1: 												);
1:         this.collationDerivation = source.getCollationDerivation();
/////////////////////////////////////////////////////////////////////////
1: 												source.getCollationType()
1: 												);
1:         this.collationDerivation = source.getCollationDerivation();
/////////////////////////////////////////////////////////////////////////
1: 				source.getCollationType()
1: 				);
1:         this.collationDerivation = source.getCollationDerivation();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Gets the name of the collation type in this descriptor if the collation
1:      * derivation is not NONE. If the collation derivation is NONE, then this
1:      * method will return "NONE".
1:      * <p>
1:      * This method is used for generating error messages which will use correct
1:      * string describing collation type/derivation.
1:      * 
1:      *
1:      *  @return the name of the collation being used in this type.
1:      */
1:     public String getCollationName()
1:     {
0:         return(
0:                 getCollationDerivation() == StringDataValue.COLLATION_DERIVATION_NONE ?
0:                         Property.COLLATION_NONE :
0:                 getCollationType() == StringDataValue.COLLATION_TYPE_UCS_BASIC ?
0:                         Property.UCS_BASIC_COLLATION :
0:                         Property.TERRITORY_BASED_COLLATION);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the collation derivation for this type. This applies only for
1:      * character string types. For the other types, this api should be
1:      * ignored.
1:      * 
1:      * SQL spec talks about character string types having collation type and 
1:      * collation derivation associated with them (SQL spec Section 4.2.2 
1:      * Comparison of character strings). If collation derivation says explicit 
1:      * or implicit, then it means that there is a valid collation type 
1:      * associated with the charcter string type. If the collation derivation is 
1:      * none, then it means that collation type can't be established for the 
1:      * character string type.
1:      * 
1:      * 1)Collation derivation will be explicit if SQL COLLATE clause has been  
1:      * used for character string type (this is not a possibility for Derby 10.3 
1:      * because we are not planning to support SQL COLLATE clause in the 10.3
1:      * release). 
1:      * 
1:      * 2)Collation derivation will be implicit if the collation can be 
1:      * determined w/o the COLLATE clause eg CREATE TABLE t1(c11 char(4)) then 
1:      * c11 will have collation of USER character set. Another eg, TRIM(c11) 
1:      * then the result character string of TRIM operation will have collation 
1:      * of the operand, c11.
1:      * 
1:      * 3)Collation derivation will be none if the aggregate methods are dealing 
1:      * with character strings with different collations (Section 9.3 Data types 
1:      * of results of aggregations Syntax Rule 3aii).
1:      *  
0:      * Collation derivation will be initialized to COLLATION_DERIVATION_NONE.
1:      *  
1:      * @return Should be COLLATION_DERIVATION_NONE or COLLATION_DERIVATION_IMPLICIT
1:      * 
1:      * @see StringDataValue#COLLATION_DERIVATION_NONE
1:      * @see StringDataValue#COLLATION_DERIVATION_IMPLICIT
1:      * @see StringDataValue#COLLATION_DERIVATION_EXPLICIT
1:      */
1: 		return collationDerivation;
/////////////////////////////////////////////////////////////////////////
0:         collationDerivation = collationDerivationValue;
/////////////////////////////////////////////////////////////////////////
1: 	  Compare if two DataTypeDescriptors are exactly the same
1: 	  @param other the type to compare to.
1: 	public boolean equals(Object other)
1:         if (!(other instanceof DataTypeDescriptor))
1:             return false;
1:         
1:         DataTypeDescriptor odtd = (DataTypeDescriptor) other;
1:         return typeDescriptor.equals(odtd.typeDescriptor)
1:           && collationDerivation == odtd.collationDerivation;
commit:b77f82e
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Return a runtime type for a catalog type.
1: 	 */
1: 	public static DataTypeDescriptor getType(TypeDescriptor catalogType)
1: 	{
1: 		TypeDescriptorImpl typeDescriptor = (TypeDescriptorImpl) catalogType;
0:         BaseTypeIdImpl typeId = typeDescriptor.getTypeId();
1: 
1: 		/*
0: 		** The BaseTypeIdImpl tells what type of TypeId it is supposed to
0: 		** be wrapped in.
1: 		*/
0:         TypeId wrapperTypeId = new TypeId(typeId.wrapperTypeFormatId(), typeId);
0: 		return new DataTypeDescriptor(typeDescriptor, wrapperTypeId);
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	private DataTypeDescriptor(TypeDescriptorImpl source, TypeId typeId)
1: 		this.typeId = typeId;
commit:a8347d0
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return a nullable catalog type for a JDBC builtin type and length.
1:      */
1:     public static TypeDescriptor getCatalogType(int jdbcType, int length)
1:     {
1:         return getBuiltInDataTypeDescriptor(jdbcType, length).getCatalogType();
1:     }
1:     /**
1:      * Return a nullable catalog type for a fixed length JDBC builtin type.
1:      */
1:     public static TypeDescriptor getCatalogType(int jdbcType)
1:     {
1:         return getBuiltInDataTypeDescriptor(jdbcType).getCatalogType();
1:     }
commit:2afe578
/////////////////////////////////////////////////////////////////////////
1:  * DataTypeDescriptor describes a runtime SQL type.
/////////////////////////////////////////////////////////////////////////
1:     
0:     public static final DataTypeDescriptor INTEGER = new DataTypeDescriptor(TypeId.INTEGER_ID, true);
1: 	 * Get a descriptor that corresponds to a nullable builtin JDBC type.
/////////////////////////////////////////////////////////////////////////
1: 	public TypeDescriptor getCatalogType()
commit:32812bd
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Return a type descriptor identical to the this type
1:      * with the exception of its nullability. If the nullablity
1:      * required matches the nullability of this then this is returned.
1:      * 
1:      * @param isNullable True to return a nullable type, false otherwise.
1:      */
1:     public DataTypeDescriptor getNullabilityType(boolean isNullable)
1:     {
1:         if (isNullable() == isNullable)
1:             return this;
1:         
1:         return new DataTypeDescriptor(this, isNullable);
1:     }
commit:81de188
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.sql.Types;
0: import java.text.RuleBasedCollator;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Set the collation type of this TypeDescriptor
0:      * @param collationTypeValue This will be COLLATION_TYPE_UCS_BASIC
0:      * or COLLATION_TYPE_TERRITORY_BASED
1:      * 
0:      * @see StringDataValue#COLLATION_TYPE_UCS_BASIC
0:      * @see StringDataValue#COLLATION_TYPE_TERRITORY_BASED
1:      */
0:     public void	setCollationType(int collationTypeValue)
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Set the collation derivation of this DTD
0:      * @param collationDerivationValue This will be 
0:      * COLLATION_DERIVATION_NONE/COLLATION_DERIVATION_IMPLICIT/COLLATION_DERIVATION_EXPLICIT
0:      * In Derby 10.3, we do not expect to get value COLLATION_DERIVATION_EXPLICIT.
1:      * 
0:      * @see StringDataValue#COLLATION_DERIVATION_NONE
0:      * @see StringDataValue#COLLATION_DERIVATION_IMPLICIT
0:      * @see StringDataValue#COLLATION_DERIVATION_EXPLICIT
1: 
1:      */
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
1: 		if (!thisType.userType() && !otherType.userType())
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.DataTypeDescriptor
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
1: 
0: import java.sql.Types;
1: 
1: /**
0:  * This is an implementation of DataTypeDescriptor from the generic language
0:  * datatype module interface.
1:  *
0:  * @author Jeff Lichtman
0:  * @version 1.0
1:  */
1: 
0: public final class DataTypeDescriptor implements TypeDescriptor, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/********************************************************
1: 	**
1: 	**	This class implements Formatable. That means that it
1: 	**	can write itself to and from a formatted stream. If
1: 	**	you add more fields to this class, make sure that you
1: 	**	also write/read them with the writeExternal()/readExternal()
1: 	**	methods.
1: 	**
1: 	**	If, inbetween releases, you add more fields to this class,
1: 	**	then you should bump the version number emitted by the getTypeFormatId()
1: 	**	method.
1: 	**
1: 	********************************************************/
1: 
1: 	/*
1: 	** Static creators
1: 	*/
1: 	/**
1: 	 * Get a descriptor that corresponds to a builtin JDBC type.
1: 	 *
1: 	 * @param jdbcType	The int type of the JDBC type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type
1: 	 */
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		int	jdbcType
1: 	)
1: 	{
1: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true);
1: 	}
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		int	jdbcType,
1: 		int length
1: 	)
1: 	{
1: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true, length);
1: 	}
1: 
1: 	/**
1: 	 * Get a descriptor that corresponds to a builtin JDBC type.
1: 	 *
1: 	 * @param jdbcType	The int type of the JDBC type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type
1: 	 */
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		int	jdbcType, 
1: 		boolean	isNullable
1: 	)
1: 	{
1: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1: 		if (typeId == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		return new DataTypeDescriptor(typeId, isNullable);
1: 	}
1: 	/**
1: 	 * Get a descriptor that corresponds to a builtin JDBC type.
1: 	 *
1: 	 * @param jdbcType	The int type of the JDBC type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type
1: 	 */
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		int	jdbcType, 
1: 		boolean	isNullable,
1: 		int maxLength
1: 	)
1: 	{
1: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
1: 		if (typeId == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		return new DataTypeDescriptor(typeId, isNullable, maxLength);
1: 	}
1: 	/**
1: 	 * Get a DataTypeServices that corresponds to a builtin SQL type
1: 	 *
1: 	 * @param javaTypeName	The name of the Java type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1: 	 */
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		String	sqlTypeName
1: 	)
1: 	{
1: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true);
1: 	}
1: 	/**
1: 	 * Get a DataTypeServices that corresponds to a builtin SQL type
1: 	 *
1: 	 * @param javaTypeName	The name of the Java type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1: 	 */
1: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
1: 	(
1: 		String	sqlTypeName,
1: 		int length
1: 	)
1: 	{
1: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true, length);
1: 	}
1: 	/**
1: 	 * Get a DataTypeServices that corresponds to a Java type
1: 	 *
1: 	 * @param javaTypeName	The name of the Java type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1: 	 */
1: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1: 	(
1: 		String	javaTypeName
1: 	)
1: 	{
1: 			return DataTypeDescriptor.getSQLDataTypeDescriptor(javaTypeName, true);
1: 	}
1: 
1: 	/**
1: 	 * Get a DataTypeServices that corresponds to a Java type
1: 	 *
1: 	 * @param javaTypeName	The name of the Java type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
1: 	 */
1: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1: 	(
1: 		String	javaTypeName, 
1: 		boolean	isNullable
1: 	)
1: 	{
1: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
1: 		if (typeId == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		return new DataTypeDescriptor(typeId, isNullable);
1: 	}
1: 
1: 	/**
1: 	 * Get a DataTypeDescriptor that corresponds to a Java type
1: 	 *
1: 	 * @param javaTypeName	The name of the Java type for which to get
1: 	 *						a corresponding SQL DataTypeDescriptor
1: 	 * @param precision	The number of decimal digits
1: 	 * @param scale		The number of digits after the decimal point
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum width of a data value
1: 	 *			represented by this type.
1: 	 *
1: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
1: 	 *			A null return value means there is no corresponding SQL type.
1: 	 */
1: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
1: 	(
1: 		String	javaTypeName, 
1: 		int 	precision,
1: 		int 	scale, 
1: 		boolean	isNullable, 
1: 		int 	maximumWidth
1: 	)
1: 	{
1: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
1: 		if (typeId == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		return new DataTypeDescriptor(typeId,
1: 											precision,
1: 											scale,
1: 											isNullable,
1: 											maximumWidth);
1: 	}
1: 	/*
1: 	** Instance fields & methods
1: 	*/
1: 
1: 	private TypeDescriptorImpl	typeDescriptor;
1: 	private TypeId			typeId;
1: 
1: 	/**
1: 	 * Public niladic constructor. Needed for Formatable interface to work.
1: 	 *
1: 	 */
1:     public	DataTypeDescriptor() {}
1: 
1: 	/**
1: 	 * Constructor for use with numeric types
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public DataTypeDescriptor(TypeId typeId, int precision, int scale,
1: 		boolean isNullable, int maximumWidth)
1: 	{
1: 		this.typeId = typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1: 												precision,
1: 												scale,
1: 												isNullable,
1: 												maximumWidth);
1: 	}
1: 
1: 	/**
1: 	 * Constructor for use with non-numeric types
1: 	 *
1: 	 * @param typeId	The typeId of the type being described
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1: 												isNullable,
1: 												maximumWidth);
1: 	}
1: 
1: 
1: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable) {
1: 
1: 		this.typeId = typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
1: 												typeId.getMaximumPrecision(),
1: 												typeId.getMaximumScale(),
1: 												isNullable,
1: 												typeId.getMaximumMaximumWidth());
1: 	}
0: 	public DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable)
1: 	{
1: 		this.typeId = source.typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1: 												source.getPrecision(),
1: 												source.getScale(),
1: 												isNullable,
0: 												source.getMaximumWidth());
1: 	}
1: 
1: 	/**
1: 	 * Constructor for internal uses only.  
1: 	 * (This is useful when the precision and scale are potentially wider than
1: 	 * those in the source, like when determining the dominant data type.)
1: 	 *
1: 	 * @param source	The DTSI to copy
1: 	 * @param precision	The number of decimal digits.
1: 	 * @param scale		The number of digits after the decimal point.
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public DataTypeDescriptor(DataTypeDescriptor source, 
1: 								int precision,
1: 								int scale,
1: 								boolean isNullable,
1: 								int maximumWidth)
1: 	{
1: 		this.typeId = source.typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1: 												precision,
1: 												scale,
1: 												isNullable,
1: 												maximumWidth);
1: 	}
1: 
1: 	/**
1: 	 * Constructor for internal uses only
1: 	 *
1: 	 * @param source	The DTSI to copy
1: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
1: 	 *			it definitely cannot contain NULL.
1: 	 * @param maximumWidth	The maximum number of bytes for this datatype
1: 	 */
1: 	public DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable,
1: 		int maximumWidth)
1: 	{
1: 		this.typeId = source.typeId;
1: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
1: 												isNullable,
1: 												maximumWidth);
1: 	}
1: 
1: 	/**
1: 	 * Constructor for use in reconstructing a DataTypeDescriptor from a
1: 	 * TypeDescriptorImpl and a TypeId
1: 	 *
1: 	 * @param source	The TypeDescriptorImpl to construct this DTSI from
1: 	 */
0: 	public DataTypeDescriptor(TypeDescriptorImpl source, TypeId typeId)
1: 	{
1: 		typeDescriptor = source;
0: 		this.typeId = typeId;;
1: 	}
1: 
1: 	/* DataTypeDescriptor Interface */
1: 	public DataValueDescriptor normalize(DataValueDescriptor source,
1: 										DataValueDescriptor cachedDest)
1: 			throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			if (cachedDest != null) {
1: 				if (!getTypeId().isUserDefinedTypeId()) {
1: 					String t1 = getTypeName();
1: 					String t2 = cachedDest.getTypeName();
1: 					if (!t1.equals(t2)) {
1: 
1: 						if (!(((t1.equals("DECIMAL") || t1.equals("NUMERIC"))
1: 							&& (t2.equals("DECIMAL") || t2.equals("NUMERIC"))) ||
1: 							(t1.startsWith("INT") && t2.startsWith("INT"))))  //INT/INTEGER
1: 
1: 							SanityManager.THROWASSERT(
1: 								"Normalization of " + t2 + " being asked to convert to " + t1);
1: 					}
1: 				}
1: 			}
1: 		}
1: 
1: 		if (source.isNull())
1: 		{
1: 			if (!isNullable())
1: 				throw StandardException.newException(SQLState.LANG_NULL_INTO_NON_NULL,"");
1: 
0: 			if (cachedDest == null)
0: 				cachedDest = getNull();
1: 			else
0: 				cachedDest.setToNull();
1: 		} else {
1: 
0: 			if (cachedDest == null)
0: 				cachedDest = getNull();
1: 
1: 			int jdbcId = getJDBCTypeId();
1: 
1: 			cachedDest.normalize(this, source);
1: 			//doing the following check after normalize so that normalize method would get called on long varchs and long varbinary
1: 			//Need normalize to be called on long varchar for bug 5592 where we need to enforce a lenght limit in db2 mode
1: 			if ((jdbcId == Types.LONGVARCHAR) || (jdbcId == Types.LONGVARBINARY)) {
1: 				// special case for possible streams
1: 				if (source.getClass() == cachedDest.getClass()) 
1: 					return source;
1: 			}
1: 
1: 		}
1: 		return cachedDest;
1: 	}
1: 	
1: 	/**
1: 	 * Get the dominant type (DataTypeDescriptor) of the 2.
1: 	 * For variable length types, the resulting type will have the
1: 	 * biggest max length of the 2.
1: 	 * If either side is nullable, then the result will also be nullable.
1: 	 *
1: 	 * @param otherDTS	DataTypeDescriptor to compare with.
1: 	 * @param cf		A ClassFactory
1: 	 *
1: 	 * @return DataTypeDescriptor  DTS for dominant type
1: 	 *
0: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataTypeDescriptor getDominantType(DataTypeDescriptor otherDTS, ClassFactory cf)
1: 			throws StandardException
1: 	{
1: 		boolean				nullable;
1: 		TypeId				thisType;
1: 		TypeId				otherType;
0: 		DataTypeDescriptor	higherType = null;
1: 		DataTypeDescriptor	lowerType = null;
1: 		int					maximumWidth;
1: 		int					precision = getPrecision();
1: 		int					scale = getScale();
1: 
1: 		thisType = getTypeId();
1: 		otherType = otherDTS.getTypeId();
1: 
1: 		/* The result is nullable if either side is nullable */
1: 		nullable = isNullable() || otherDTS.isNullable();
1: 
1: 		/*
1: 		** The result will have the maximum width of both sides
1: 		*/
1: 		maximumWidth = (getMaximumWidth() > otherDTS.getMaximumWidth())
1: 			? getMaximumWidth() : otherDTS.getMaximumWidth();
1: 
1: 		/* We need 2 separate methods of determining type dominance - 1 if both
1: 		 * types are system built-in types and the other if at least 1 is
1: 		 * a user type. (typePrecedence is meaningless for user types.)
1: 		 */
0: 		if (thisType.systemBuiltIn() && otherType.systemBuiltIn())
1: 		{
1: 			TypeId  higherTypeId;
1: 			TypeId  lowerTypeId;
1: 			if (thisType.typePrecedence() > otherType.typePrecedence())
1: 			{
1: 				higherType = this;
1: 				lowerType = otherDTS;
1: 				higherTypeId = thisType;
1: 				lowerTypeId = otherType;
1: 			}
1: 			else
1: 			{
1: 				higherType = otherDTS;
1: 				lowerType = this;
1: 				higherTypeId = otherType;
1: 				lowerTypeId = thisType;
1: 			}
1: 
1: 			//Following is checking if higher type argument is real and other argument is decimal/bigint/integer/smallint,
1: 			//then result type should be double
1: 			if (higherTypeId.isRealTypeId() && (!lowerTypeId.isRealTypeId()) && lowerTypeId.isNumericTypeId())
1: 			{
1: 				higherType = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);
1: 				higherTypeId = TypeId.getBuiltInTypeId(Types.DOUBLE);
1: 			}
1: 			/*
1: 			** If we have a DECIMAL/NUMERIC we have to do some
1: 			** extra work to make sure the resultant type can
1: 			** handle the maximum values for the two input
1: 			** types.  We cannot just take the maximum for
1: 			** precision.  E.g. we want something like:
1: 			**
1: 			**		DEC(10,10) and DEC(3,0) => DEC(13,10)
1: 			**
1: 			** (var)char type needs some conversion handled later.
1: 			*/
1: 			if (higherTypeId.isDecimalTypeId() && (!lowerTypeId.isStringTypeId()))
1: 			{
1: 				precision = higherTypeId.getPrecision(this, otherDTS);
1: 				if (precision > 31) precision = 31; //db2 silently does this and so do we
1: 				scale = higherTypeId.getScale(this, otherDTS);
1: 
1: 				/* maximumWidth needs to count possible leading '-' and
1: 				 * decimal point and leading '0' if scale > 0.  See also
1: 				 * sqlgrammar.jj(exactNumericType).  Beetle 3875
1: 				 */
1: 				maximumWidth = (scale > 0) ? precision + 3 : precision + 1;
1: 			}
1: 			else if (thisType.typePrecedence() != otherType.typePrecedence())
1: 			{
1: 				precision = higherType.getPrecision();
1: 				scale = higherType.getScale();
1: 
1: 				/* GROSS HACKS:
1: 				 * If we are doing an implicit (var)char->(var)bit conversion
1: 				 * then the maximum width for the (var)char as a (var)bit
1: 				 * is really 16 * its width as a (var)char.  Adjust
1: 				 * maximumWidth accordingly.
1: 				 * If we are doing an implicit (var)char->decimal conversion
1: 				 * then we need to increment the decimal's precision by
1: 				 * 2 * the maximum width for the (var)char and the scale
1: 				 * by the maximum width for the (var)char. The maximumWidth
1: 				 * becomes the new precision + 3.  This is because
1: 				 * the (var)char could contain any decimal value from XXXXXX
1: 				 * to 0.XXXXX.  (In other words, we don't know which side of the
1: 				 * decimal point the characters will be on.)
1: 				 */
1: 				if (lowerTypeId.isStringTypeId())
1: 				{
1: 					if (higherTypeId.isBitTypeId() &&
1: 						! (higherTypeId.isLongConcatableTypeId()))
1: 					{
1: 						if (lowerTypeId.isLongConcatableTypeId())
1: 						{
1: 							if (maximumWidth > (Integer.MAX_VALUE / 16))
1: 								maximumWidth = Integer.MAX_VALUE;
1: 							else
1: 								maximumWidth *= 16;
1: 						}
1: 						else
1: 						{
1: 							int charMaxWidth;
1: 
1: 							int fromWidth = lowerType.getMaximumWidth();
1: 							if (fromWidth > (Integer.MAX_VALUE / 16))
1: 								charMaxWidth = Integer.MAX_VALUE;
1: 							else
1: 								charMaxWidth = 16 * fromWidth;
1: 
1: 							maximumWidth = (maximumWidth >= charMaxWidth) ?
1: 												maximumWidth : charMaxWidth;
1: 						}
1: 					}
1: 				}
1: 
1: 				/*
1: 				 * If we are doing an implicit (var)char->decimal conversion
1: 				 * then the resulting decimal's precision could be as high as 
1: 				 * 2 * the maximum width (precisely 2mw-1) for the (var)char
1: 				 * and the scale could be as high as the maximum width
1: 				 * (precisely mw-1) for the (var)char.
1: 				 * The maximumWidth becomes the new precision + 3.  This is
1: 				 * because the (var)char could contain any decimal value from
1: 				 * XXXXXX to 0.XXXXX.  (In other words, we don't know which
1: 				 * side of the decimal point the characters will be on.)
1: 				 *
1: 				 * We don't follow this algorithm for long varchar because the
1: 				 * maximum length of a long varchar is maxint, and we don't
1: 				 * want to allocate a huge decimal value.  So in this case,
1: 				 * the precision, scale, and maximum width all come from
1: 				 * the decimal type.
1: 				 */
1: 				if (lowerTypeId.isStringTypeId() &&
1: 					! (lowerTypeId.isLongConcatableTypeId()) &&
1: 					higherTypeId.isDecimalTypeId() )
1: 				{
1: 					int charMaxWidth = lowerType.getMaximumWidth();
1: 					int charPrecision;
1: 
1: 					/*
1: 					** Be careful not to overflow when calculating the
1: 					** precision.  Remember that we will be adding
1: 					** three to the precision to get the maximum width.
1: 					*/
1: 					if (charMaxWidth > (Integer.MAX_VALUE - 3) / 2)
1: 						charPrecision = Integer.MAX_VALUE - 3;
1: 					else
1: 						charPrecision = charMaxWidth * 2;
1: 
1: 					if (precision < charPrecision)
1: 						precision = charPrecision;
1: 
1: 					if (scale < charMaxWidth)
1: 						scale = charMaxWidth;
1: 
1: 					maximumWidth = precision + 3;
1: 				}
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/* At least 1 type is not a system built-in type */
1: 			ClassInspector		cu = cf.getClassInspector();
1: 
1: 			TypeId thisCompType = (TypeId) thisType;
1: 			TypeId otherCompType = (TypeId) otherType;
1: 
1: 			if (cu.assignableTo(thisCompType.getCorrespondingJavaTypeName(),
1: 							    otherCompType.getCorrespondingJavaTypeName()))
1: 			{
1: 				higherType = otherDTS;
1: 			}
1: 			else
1: 			{
0: 				if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(
1: 							cu.assignableTo(otherCompType.getCorrespondingJavaTypeName(),
1: 									thisCompType.getCorrespondingJavaTypeName()),
1: 							otherCompType.getCorrespondingJavaTypeName() +
1: 							" expected to be assignable to " +
1: 							thisCompType.getCorrespondingJavaTypeName());
1: 
1: 				higherType = this;
1: 			}
1: 			precision = higherType.getPrecision();
1: 			scale = higherType.getScale();
1: 		}
1: 
1: 		higherType = new DataTypeDescriptor(higherType, 
0: 											  precision, scale, nullable, maximumWidth);
1: 
1: 		return higherType;
1: 	}
1: 
1: 	/**
1: 	 * Check whether or not the 2 types (DataTypeDescriptor) have the same type
1: 	 * and length.
1: 	 * This is useful for UNION when trying to decide whether a NormalizeResultSet
1: 	 * is required.
1: 	 *
1: 	 * @param otherDTS	DataTypeDescriptor to compare with.
1: 	 *
1: 	 * @return boolean  Whether or not the 2 DTSs have the same type and length.
1: 	 */
1: 	public boolean isExactTypeAndLengthMatch(DataTypeDescriptor otherDTS)
1: 	{
1: 		/* Do both sides have the same length? */
1: 		if (getMaximumWidth() != otherDTS.getMaximumWidth()) 
1: 		{
1: 			return false;
1: 		}
1: 		if (getScale() != otherDTS.getScale())
1: 		{
1: 			return false;
1: 		}
1: 
1: 		if (getPrecision() != otherDTS.getPrecision())
1: 		{	
1: 			return false;
1: 		}
1: 
1: 		TypeId thisType = getTypeId();
1: 		TypeId otherType = otherDTS.getTypeId();
1: 
1: 		/* Do both sides have the same type? */
1: 		if ( ! thisType.equals(otherType))
1: 		{
1: 			return false;
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	* @see TypeDescriptor#getMaximumWidth
1: 	 */
1: 	public int	getMaximumWidth()
1: 	{
1: 		return typeDescriptor.getMaximumWidth();
1: 	}
1: 
1: 	/**
1: 	 * Gets the TypeId for the datatype.
1: 	 *
1: 	 * @return	The TypeId for the datatype.
1: 	 */
1: 	public TypeId getTypeId()
1: 	{
1: 		return typeId;
1: 	}
1: 
1: 	/**
1: 		Get a Null for this type.
1: 	*/
0: 	public DataValueDescriptor getNull() {
0: 		return typeId.getNull();
1: 	}
1: 
1: 	/**
1: 	 * Gets the name of this datatype.
1: 	 * 
1: 	 *
1: 	 *  @return	the name of this datatype
1: 	 */
1: 	public	String		getTypeName()
1: 	{
0: 		return typeId.getSQLTypeName();
1: 	}
1: 
1: 	/**
1: 	 * Get the jdbc type id for this type.  JDBC type can be
1: 	 * found in java.sql.Types. 
1: 	 *
1: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
1: 	 *
1: 	 * @see Types
1: 	 */
1: 	public int getJDBCTypeId()
1: 	{
0: 		return typeId.getJDBCTypeId();
1: 	}
1: 
1: 	/**
1: 	 * Returns the number of decimal digits for the datatype, if applicable.
1: 	 *
1: 	 * @return	The number of decimal digits for the datatype.  Returns
1: 	 *		zero for non-numeric datatypes.
1: 	 */
1: 	public int	getPrecision()
1: 	{
1: 		return typeDescriptor.getPrecision();
1: 	}
1: 
1: 	/**
1: 	 * Returns the number of digits to the right of the decimal for
1: 	 * the datatype, if applicable.
1: 	 *
1: 	 * @return	The number of digits to the right of the decimal for
1: 	 *		the datatype.  Returns zero for non-numeric datatypes.
1: 	 */
1: 	public int	getScale()
1: 	{
1: 		return typeDescriptor.getScale();
1: 	}
1: 
1: 	/**
1: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
1: 	 * JDBC supports a return value meaning "nullability unknown" -
1: 	 * I assume we will never have columns where the nullability is unknown.
1: 	 *
1: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
1: 	 */
1: 	public boolean	isNullable()
1: 	{
1: 		return typeDescriptor.isNullable();
1: 	}
1: 
1: 	/**
0: 	 * Set the nullability of the datatype described by this descriptor
1: 	 *
0: 	 * @param nullable	TRUE means set nullability to TRUE, FALSE
0: 	 *			means set it to FALSE
1: 	 *
0: 	 * @return	Nothing
1: 	 */
0: 	public void	setNullability(boolean nullable)
1: 	{
0: 		typeDescriptor.setNullability(nullable);
1: 	}
1: 
1: 	/**
0: 	  Compare if two TypeDescriptors are exactly the same
0: 	  @param typeDescriptor the typeDescriptor to compare to.
1: 	  */
0: 	public boolean equals(Object aTypeDescriptor)
1: 	{
0: 		return typeDescriptor.equals(aTypeDescriptor);
1: 	}
1: 
1: 	/**
1: 	 * Converts this data type descriptor (including length/precision)
1: 	 * to a string. E.g.
1: 	 *
1: 	 *			VARCHAR(30)
1: 	 *
1: 	 *	or
1: 	 *
1: 	 *			 java.util.Hashtable 
1: 	 *
1: 	 * @return	String version of datatype, suitable for running through
1: 	 *			the Parser.
1: 	 */
1: 	public String	getSQLstring()
1: 	{
1: 		return typeId.toParsableString( this );
1: 	}
1: 
1: 	/**
1: 	 * Get the simplified type descriptor that is intended to be stored
1: 	 * in the system tables.
1: 	 */
0: 	public TypeDescriptorImpl getCatalogType()
1: 	{
1: 		return typeDescriptor;
1: 	}
1: 
1: 	/**
1: 	 * Get the estimated memory usage for this type descriptor.
1: 	 */
1: 	public double estimatedMemoryUsage() {
1: 		switch (typeId.getTypeFormatId())
1: 		{
1: 			case StoredFormatIds.LONGVARBIT_TYPE_ID:
1: 				/* Who knows?  Let's just use some big number */
1: 				return 10000.0;
1: 
1: 			case StoredFormatIds.BIT_TYPE_ID:
1: 				return (double) ( ( ((float) getMaximumWidth()) / 8.0) + 0.5);
1: 
1: 			case StoredFormatIds.BOOLEAN_TYPE_ID:
1: 				return 4.0;
1: 
1: 			case StoredFormatIds.CHAR_TYPE_ID:
1: 			case StoredFormatIds.VARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
1: 				return (double) (2.0 * getMaximumWidth());
1: 
1: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
1: 				/* Who knows? Let's just use some big number */
1: 				return 10000.0;
1: 
1: 			case StoredFormatIds.DECIMAL_TYPE_ID:
1: 				/*
1: 				** 0.415 converts from number decimal digits to number of 8-bit digits. 
1: 				** Add 1.0 for the sign byte, and 0.5 to force it to round up.
1: 				*/
1: 				return (double) ( (getPrecision() * 0.415) + 1.5 );
1: 
1: 			case StoredFormatIds.DOUBLE_TYPE_ID:
1: 				return 8.0;
1: 
1: 			case StoredFormatIds.INT_TYPE_ID:
1: 				return 4.0;
1: 
0: 			case StoredFormatIds.LONGINT_TYPE_ID:
1: 				return 8.0;
1: 
1: 			case StoredFormatIds.REAL_TYPE_ID:
1: 				return 4.0;
1: 
1: 			case StoredFormatIds.SMALLINT_TYPE_ID:
1: 				return 2.0;
1: 
1: 			case StoredFormatIds.TINYINT_TYPE_ID:
1: 				return 1.0;
1: 
1: 			case StoredFormatIds.REF_TYPE_ID:
1: 				/* I think 12 is the right number */
1: 				return 12.0;
1: 
1: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
1: 				if (typeId.userType()) {
1: 					/* Who knows?  Let's just use some medium-sized number */
1: 					return 256.0;
1: 				}
1: 			case StoredFormatIds.DATE_TYPE_ID:
1: 			case StoredFormatIds.TIME_TYPE_ID:
1: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
1: 				return 12.0; 
1: 
1: 			default:
1: 				return 0.0;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Compare JdbcTypeIds to determine if they represent equivalent
1: 	 * SQL types. For example Types.NUMERIC and Types.DECIMAL are
1: 	 * equivalent
1: 	 *
0: 	 * @param existingType  JDBC type id of Cloudscape data type
0: 	 * @param jdbcTypeIdB   JDBC type id passed in from application.
1: 	 *
1: 	 * @return boolean true if types are equivalent, false if not
1: 	 */
1: 
1: 	public static boolean isJDBCTypeEquivalent(int existingType, int jdbcTypeId)
1: 	{
1: 		// Any type matches itself.
1: 		if (existingType == jdbcTypeId)
1: 			return true;
1: 
1: 		// To a numeric type
1: 		if (DataTypeDescriptor.isNumericType(existingType)) {
1: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
1: 				return true;
1: 
1: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1: 				return true;
1: 
1: 			return false;
1: 		}
1: 
1: 		// To character type.
1: 		if (DataTypeDescriptor.isCharacterType(existingType)) {
1: 
1: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1: 				return true;
1: 
1: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
1: 				return true;
1: 
1: 
1: 			switch (jdbcTypeId) {
0: 			case Types.DATE:
0: 			case Types.TIME:
0: 			case Types.TIMESTAMP:
1: 				return true;
1: 			default:
1: 				break;
1: 			}
1: 
1: 			
1: 			return false;
1: 
1: 		}
1: 
1: 		// To binary type
1: 		if (DataTypeDescriptor.isBinaryType(existingType)) {
1: 
1: 			if (DataTypeDescriptor.isBinaryType(jdbcTypeId))
1: 				return true;
1: 
1: 			return false;
1: 		}
1: 
1: 		// To DATE, TIME
1: 		if (existingType == Types.DATE || existingType == Types.TIME) {
1: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1: 				return true;
1: 
1: 			if (jdbcTypeId == Types.TIMESTAMP)
1: 				return true;
1: 
1: 			return false;
1: 		}
1: 
1: 		// To TIMESTAMP
1: 		if (existingType == Types.TIMESTAMP) {
1: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
1: 				return true;
1: 
1: 			if (jdbcTypeId == Types.DATE)
1: 				return true;
1: 
1: 			return false;
1: 		}
1: 		
1: 		return false;
1: 	}
1: 
1: 	public static boolean isNumericType(int jdbcType) {
1: 
1: 		switch (jdbcType) {
0: 		case Types.BIT:
0: 		case org.apache.derby.iapi.reference.JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 		case Types.TINYINT:
0: 		case Types.SMALLINT:
0: 		case Types.INTEGER:
0: 		case Types.BIGINT:
0: 		case Types.REAL:
1: 		case Types.FLOAT:
0: 		case Types.DOUBLE:
1: 		case Types.DECIMAL:
0: 		case Types.NUMERIC:
1: 			return true;
1: 		default:
1: 			return false;
1: 		}
1: 	}
1: 
1: 	private static boolean isCharacterType(int jdbcType) {
1: 
1: 		switch (jdbcType) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
1: 			return true;
1: 		default:
1: 			return false;
1: 		}
1: 	}
1: 
1: 	private static boolean isBinaryType(int jdbcType) {
1: 		switch (jdbcType) {
0: 		case Types.BINARY:
0: 		case Types.VARBINARY:
0: 		case Types.LONGVARBINARY:
1: 			return true;
1: 		default:
1: 			return false;
1: 		}
1: 	}
1: 
1: 	public String	toString()
1: 	{
1: 		return typeDescriptor.toString();
1: 	}
1: 
1: 	// Formatable methods
1: 
1: 	/**
1: 	 * Read this object from a stream of stored objects.
1: 	 *
1: 	 * @param in read this.
1: 	 *
1: 	 * @exception IOException					thrown on error
1: 	 * @exception ClassNotFoundException		thrown on error
1: 	 */
1: 	public void readExternal( ObjectInput in )
1: 		 throws IOException, ClassNotFoundException
1: 	{
0: 		/* NOTE: We only write out the generic type id.
0: 		 * typeId will be reset to be the generic type id
0: 		 * when we get read back in since the generic
0: 		 * one is all that is needed at execution time.
1: 		 */
0: 		typeId = (TypeId) in.readObject();
1: 		typeDescriptor = (TypeDescriptorImpl) in.readObject();
1: 	}
1: 
1: 	/**
1: 	 * Write this object to a stream of stored objects.
1: 	 *
1: 	 * @param out write bytes here.
1: 	 *
1: 	 * @exception IOException		thrown on error
1: 	 */
1: 	public void writeExternal( ObjectOutput out )
1: 		 throws IOException
1: 	{
0: 		out.writeObject( typeId );
0: 		out.writeObject( typeDescriptor );
1: 	}
1:  
1: 	/**
1: 	 * Get the formatID which corresponds to this class.
1: 	 *
1: 	 *	@return	the formatID of this class
1: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_SERVICES_IMPL_V01_ID; }
1: }
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8bc0bec
/////////////////////////////////////////////////////////////////////////
1: 	 * @param catalogTypes  Types of the columns in the Row Muliset
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:bc739f7
/////////////////////////////////////////////////////////////////////////
0:         return(typeDescriptor.getCollationName());
commit:ec2b8d1
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Gets the name of this datatype.
0:      * <p>
0:      * Used to generate strings decribing collation type for error messages.
0: 	 * 
0: 	 *
0: 	 *  @return	the name of the collation being used in this type.
0: 	 */
0: 	public String getCollationName()
0: 	{
0:         return(typeDescriptor.getCollationType() == 0 ?
0:                     "UCS_BASIC" : "TERRITORY_BASED");
0: 	}
0: 
author:Army
-------------------------------------------------------------------------------
commit:d25aee0
/////////////////////////////////////////////////////////////////////////
0: 
0:     /**
1:      * Check to make sure that this type id is something a user can create
1:      * him/herself directly through an SQL CREATE TABLE statement.
0:      * 
1:      * This method is used for CREATE TABLE AS ... WITH [NO] DATA binding
1:      * because it's possible for the query to return types which are not
1:      * actually creatable for a user.  DERBY-2605.
0:      *
1:      * Three examples are:
0:      *
0:      *  BOOLEAN: A user can select boolean columns from system tables, but
0:      *   s/he is not allowed to create such a column him/herself.
0:      *
1:      *  JAVA_OBJECT: A user can select columns of various java object types
1:      *   from system tables, but s/he is not allowed to create such a column
1:      *   him/herself.
0:      *  
1:      *  DECIMAL: A user can specify a VALUES clause with a constant that
1:      *   has a precision of greater than 31.  Derby can apparently handle
1:      *   such a value internally, but the user is not supposed to be able
1:      *   create such a column him/herself.
0:      * 
1:      * @return True if the type associated with this DTD can be created via
1:      *  the CREATE TABLE syntax; false otherwise.
0:      */
1:     public boolean isUserCreatableType() throws StandardException
0:     {
0:         switch (typeId.getJDBCTypeId())
0:         {
0:             case Types.BOOLEAN:
1:             case Types.JAVA_OBJECT:
0:             	return false;
0:             case Types.DECIMAL:
1:                 return
1:                 (getPrecision() <= typeId.getMaximumPrecision()) &&
1:                 (getScale() <= typeId.getMaximumScale()) &&
1:                 (getMaximumWidth() <= typeId.getMaximumMaximumWidth());
1:             default: break;
0:         }
0:         return true;
0:     }
0: 
0:     /**
1:      * Return the SQL type name and, if applicable, scale/precision/length
1:      * for this DataTypeDescriptor.  Note that we want the values from *this*
1:      * object specifically, not the max values defined on this.typeId.
0:      */
1:     public String getFullSQLTypeName()
0:     {
1:         StringBuffer sbuf = new StringBuffer(typeId.getSQLTypeName());
1:         if (typeId.isDecimalTypeId() || typeId.isNumericTypeId())
0:         {
1:             sbuf.append("(");
1:             sbuf.append(getPrecision());
1:             sbuf.append(", ");
1:             sbuf.append(getScale());
1:             sbuf.append(")");
0:         }
1:         else if (typeId.variableLength())
0:         {
1:             sbuf.append("(");
1:             sbuf.append(getMaximumWidth());
1:             sbuf.append(")");
0:         }
0: 
1:         return sbuf.toString();
0:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	 * @param existingType  JDBC type id of Derby data type
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:f225091
/////////////////////////////////////////////////////////////////////////
1: 		// To CLOB
1: 		if (existingType == Types.CLOB && DataTypeDescriptor.isCharacterType(jdbcTypeId))
0: 			return true;
0: 
commit:09c8a0d
/////////////////////////////////////////////////////////////////////////
0: 	 * @see TypeDescriptor#getMaximumWidthInBytes
0: 	 */
0: 	public int	getMaximumWidthInBytes()
0: 	{
0: 		return typeDescriptor.getMaximumWidthInBytes();
0: 	}
0: 
0: 	/**
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param sqlTypeName	The name of the type for which to get
/////////////////////////////////////////////////////////////////////////
1: 	 * @param sqlTypeName	The name of the type for which to get
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	  @param aTypeDescriptor the typeDescriptor to compare to.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param jdbcTypeId   JDBC type id passed in from application.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.catalog.TypeDescriptor;
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Formatable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.sql.Types;
0: 
0: /**
0:  * This is an implementation of DataTypeDescriptor from the generic language
0:  * datatype module interface.
0:  *
0:  * @author Jeff Lichtman
0:  * @version 1.0
0:  */
0: 
0: public final class DataTypeDescriptor implements TypeDescriptor, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/********************************************************
0: 	**
0: 	**	This class implements Formatable. That means that it
0: 	**	can write itself to and from a formatted stream. If
0: 	**	you add more fields to this class, make sure that you
0: 	**	also write/read them with the writeExternal()/readExternal()
0: 	**	methods.
0: 	**
0: 	**	If, inbetween releases, you add more fields to this class,
0: 	**	then you should bump the version number emitted by the getTypeFormatId()
0: 	**	method.
0: 	**
0: 	********************************************************/
0: 
0: 	/*
0: 	** Static creators
0: 	*/
0: 	/**
0: 	 * Get a descriptor that corresponds to a builtin JDBC type.
0: 	 *
0: 	 * @param jdbcType	The int type of the JDBC type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type
0: 	 */
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		int	jdbcType
0: 	)
0: 	{
0: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true);
0: 	}
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		int	jdbcType,
0: 		int length
0: 	)
0: 	{
0: 		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(jdbcType, true, length);
0: 	}
0: 
0: 	/**
0: 	 * Get a descriptor that corresponds to a builtin JDBC type.
0: 	 *
0: 	 * @param jdbcType	The int type of the JDBC type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type
0: 	 */
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		int	jdbcType, 
0: 		boolean	isNullable
0: 	)
0: 	{
0: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
0: 		if (typeId == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		return new DataTypeDescriptor(typeId, isNullable);
0: 	}
0: 	/**
0: 	 * Get a descriptor that corresponds to a builtin JDBC type.
0: 	 *
0: 	 * @param jdbcType	The int type of the JDBC type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type
0: 	 */
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		int	jdbcType, 
0: 		boolean	isNullable,
0: 		int maxLength
0: 	)
0: 	{
0: 		TypeId typeId = TypeId.getBuiltInTypeId(jdbcType);
0: 		if (typeId == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		return new DataTypeDescriptor(typeId, isNullable, maxLength);
0: 	}
0: 	/**
0: 	 * Get a DataTypeServices that corresponds to a builtin SQL type
0: 	 *
0: 	 * @param javaTypeName	The name of the Java type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
0: 	 */
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		String	sqlTypeName
0: 	)
0: 	{
0: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true);
0: 	}
0: 	/**
0: 	 * Get a DataTypeServices that corresponds to a builtin SQL type
0: 	 *
0: 	 * @param javaTypeName	The name of the Java type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
0: 	 */
0: 	public static DataTypeDescriptor getBuiltInDataTypeDescriptor
0: 	(
0: 		String	sqlTypeName,
0: 		int length
0: 	)
0: 	{
0: 		return new DataTypeDescriptor(TypeId.getBuiltInTypeId(sqlTypeName), true, length);
0: 	}
0: 	/**
0: 	 * Get a DataTypeServices that corresponds to a Java type
0: 	 *
0: 	 * @param javaTypeName	The name of the Java type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
0: 	 */
0: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
0: 	(
0: 		String	javaTypeName
0: 	)
0: 	{
0: 			return DataTypeDescriptor.getSQLDataTypeDescriptor(javaTypeName, true);
0: 	}
0: 
0: 	/**
0: 	 * Get a DataTypeServices that corresponds to a Java type
0: 	 *
0: 	 * @param javaTypeName	The name of the Java type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type (only for 'char')
0: 	 */
0: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
0: 	(
0: 		String	javaTypeName, 
0: 		boolean	isNullable
0: 	)
0: 	{
0: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
0: 		if (typeId == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		return new DataTypeDescriptor(typeId, isNullable);
0: 	}
0: 
0: 	/**
0: 	 * Get a DataTypeDescriptor that corresponds to a Java type
0: 	 *
0: 	 * @param javaTypeName	The name of the Java type for which to get
0: 	 *						a corresponding SQL DataTypeDescriptor
0: 	 * @param precision	The number of decimal digits
0: 	 * @param scale		The number of digits after the decimal point
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum width of a data value
0: 	 *			represented by this type.
0: 	 *
0: 	 * @return	A new DataTypeDescriptor that corresponds to the Java type.
0: 	 *			A null return value means there is no corresponding SQL type.
0: 	 */
0: 	public static DataTypeDescriptor getSQLDataTypeDescriptor
0: 	(
0: 		String	javaTypeName, 
0: 		int 	precision,
0: 		int 	scale, 
0: 		boolean	isNullable, 
0: 		int 	maximumWidth
0: 	)
0: 	{
0: 		TypeId typeId = TypeId.getSQLTypeForJavaType(javaTypeName);
0: 		if (typeId == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		return new DataTypeDescriptor(typeId,
0: 											precision,
0: 											scale,
0: 											isNullable,
0: 											maximumWidth);
0: 	}
0: 	/*
0: 	** Instance fields & methods
0: 	*/
0: 
0: 	private TypeDescriptorImpl	typeDescriptor;
0: 	private TypeId			typeId;
0: 
0: 	/**
0: 	 * Public niladic constructor. Needed for Formatable interface to work.
0: 	 *
0: 	 */
0:     public	DataTypeDescriptor() {}
0: 
0: 	/**
0: 	 * Constructor for use with numeric types
0: 	 *
0: 	 * @param typeId	The typeId of the type being described
0: 	 * @param precision	The number of decimal digits.
0: 	 * @param scale		The number of digits after the decimal point.
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public DataTypeDescriptor(TypeId typeId, int precision, int scale,
0: 		boolean isNullable, int maximumWidth)
0: 	{
0: 		this.typeId = typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
0: 												precision,
0: 												scale,
0: 												isNullable,
0: 												maximumWidth);
0: 	}
0: 
0: 	/**
0: 	 * Constructor for use with non-numeric types
0: 	 *
0: 	 * @param typeId	The typeId of the type being described
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
0: 												isNullable,
0: 												maximumWidth);
0: 	}
0: 
0: 
0: 	public DataTypeDescriptor(TypeId typeId, boolean isNullable) {
0: 
0: 		this.typeId = typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(typeId.getBaseTypeId(),
0: 												typeId.getMaximumPrecision(),
0: 												typeId.getMaximumScale(),
0: 												isNullable,
0: 												typeId.getMaximumMaximumWidth());
0: 	}
0: 	public DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable)
0: 	{
0: 		this.typeId = source.typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
0: 												source.getPrecision(),
0: 												source.getScale(),
0: 												isNullable,
0: 												source.getMaximumWidth());
0: 	}
0: 
0: 	/**
0: 	 * Constructor for internal uses only.  
0: 	 * (This is useful when the precision and scale are potentially wider than
0: 	 * those in the source, like when determining the dominant data type.)
0: 	 *
0: 	 * @param source	The DTSI to copy
0: 	 * @param precision	The number of decimal digits.
0: 	 * @param scale		The number of digits after the decimal point.
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public DataTypeDescriptor(DataTypeDescriptor source, 
0: 								int precision,
0: 								int scale,
0: 								boolean isNullable,
0: 								int maximumWidth)
0: 	{
0: 		this.typeId = source.typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
0: 												precision,
0: 												scale,
0: 												isNullable,
0: 												maximumWidth);
0: 	}
0: 
0: 	/**
0: 	 * Constructor for internal uses only
0: 	 *
0: 	 * @param source	The DTSI to copy
0: 	 * @param isNullable	TRUE means it could contain NULL, FALSE means
0: 	 *			it definitely cannot contain NULL.
0: 	 * @param maximumWidth	The maximum number of bytes for this datatype
0: 	 */
0: 	public DataTypeDescriptor(DataTypeDescriptor source, boolean isNullable,
0: 		int maximumWidth)
0: 	{
0: 		this.typeId = source.typeId;
0: 		typeDescriptor = new TypeDescriptorImpl(source.typeDescriptor,
0: 												isNullable,
0: 												maximumWidth);
0: 	}
0: 
0: 	/**
0: 	 * Constructor for use in reconstructing a DataTypeDescriptor from a
0: 	 * TypeDescriptorImpl and a TypeId
0: 	 *
0: 	 * @param source	The TypeDescriptorImpl to construct this DTSI from
0: 	 */
0: 	public DataTypeDescriptor(TypeDescriptorImpl source, TypeId typeId)
0: 	{
0: 		typeDescriptor = source;
0: 		this.typeId = typeId;;
0: 	}
0: 
0: 	/* DataTypeDescriptor Interface */
0: 	public DataValueDescriptor normalize(DataValueDescriptor source,
0: 										DataValueDescriptor cachedDest)
0: 			throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			if (cachedDest != null) {
0: 				if (!getTypeId().isUserDefinedTypeId()) {
0: 					String t1 = getTypeName();
0: 					String t2 = cachedDest.getTypeName();
0: 					if (!t1.equals(t2)) {
0: 
0: 						if (!(((t1.equals("DECIMAL") || t1.equals("NUMERIC"))
0: 							&& (t2.equals("DECIMAL") || t2.equals("NUMERIC"))) ||
0: 							(t1.startsWith("INT") && t2.startsWith("INT"))))  //INT/INTEGER
0: 
0: 							SanityManager.THROWASSERT(
0: 								"Normalization of " + t2 + " being asked to convert to " + t1);
0: 					}
0: 				}
0: 			}
0: 		}
0: 
0: 		if (source.isNull())
0: 		{
0: 			if (!isNullable())
0: 				throw StandardException.newException(SQLState.LANG_NULL_INTO_NON_NULL,"");
0: 
0: 			if (cachedDest == null)
0: 				cachedDest = getNull();
0: 			else
0: 				cachedDest.setToNull();
0: 		} else {
0: 
0: 			if (cachedDest == null)
0: 				cachedDest = getNull();
0: 
0: 			int jdbcId = getJDBCTypeId();
0: 
0: 			cachedDest.normalize(this, source);
0: 			//doing the following check after normalize so that normalize method would get called on long varchs and long varbinary
0: 			//Need normalize to be called on long varchar for bug 5592 where we need to enforce a lenght limit in db2 mode
0: 			if ((jdbcId == Types.LONGVARCHAR) || (jdbcId == Types.LONGVARBINARY)) {
0: 				// special case for possible streams
0: 				if (source.getClass() == cachedDest.getClass()) 
0: 					return source;
0: 			}
0: 
0: 		}
0: 		return cachedDest;
0: 	}
0: 	
0: 	/**
0: 	 * Get the dominant type (DataTypeDescriptor) of the 2.
0: 	 * For variable length types, the resulting type will have the
0: 	 * biggest max length of the 2.
0: 	 * If either side is nullable, then the result will also be nullable.
0: 	 *
0: 	 * @param otherDTS	DataTypeDescriptor to compare with.
0: 	 * @param cf		A ClassFactory
0: 	 *
0: 	 * @return DataTypeDescriptor  DTS for dominant type
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataTypeDescriptor getDominantType(DataTypeDescriptor otherDTS, ClassFactory cf)
0: 			throws StandardException
0: 	{
0: 		boolean				nullable;
0: 		TypeId				thisType;
0: 		TypeId				otherType;
0: 		DataTypeDescriptor	higherType = null;
0: 		DataTypeDescriptor	lowerType = null;
0: 		int					maximumWidth;
0: 		int					precision = getPrecision();
0: 		int					scale = getScale();
0: 
0: 		thisType = getTypeId();
0: 		otherType = otherDTS.getTypeId();
0: 
0: 		/* The result is nullable if either side is nullable */
0: 		nullable = isNullable() || otherDTS.isNullable();
0: 
0: 		/*
0: 		** The result will have the maximum width of both sides
0: 		*/
0: 		maximumWidth = (getMaximumWidth() > otherDTS.getMaximumWidth())
0: 			? getMaximumWidth() : otherDTS.getMaximumWidth();
0: 
0: 		/* We need 2 separate methods of determining type dominance - 1 if both
0: 		 * types are system built-in types and the other if at least 1 is
0: 		 * a user type. (typePrecedence is meaningless for user types.)
0: 		 */
0: 		if (thisType.systemBuiltIn() && otherType.systemBuiltIn())
0: 		{
0: 			TypeId  higherTypeId;
0: 			TypeId  lowerTypeId;
0: 			if (thisType.typePrecedence() > otherType.typePrecedence())
0: 			{
0: 				higherType = this;
0: 				lowerType = otherDTS;
0: 				higherTypeId = thisType;
0: 				lowerTypeId = otherType;
0: 			}
0: 			else
0: 			{
0: 				higherType = otherDTS;
0: 				lowerType = this;
0: 				higherTypeId = otherType;
0: 				lowerTypeId = thisType;
0: 			}
0: 
0: 			//Following is checking if higher type argument is real and other argument is decimal/bigint/integer/smallint,
0: 			//then result type should be double
0: 			if (higherTypeId.isRealTypeId() && (!lowerTypeId.isRealTypeId()) && lowerTypeId.isNumericTypeId())
0: 			{
0: 				higherType = DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);
0: 				higherTypeId = TypeId.getBuiltInTypeId(Types.DOUBLE);
0: 			}
0: 			/*
0: 			** If we have a DECIMAL/NUMERIC we have to do some
0: 			** extra work to make sure the resultant type can
0: 			** handle the maximum values for the two input
0: 			** types.  We cannot just take the maximum for
0: 			** precision.  E.g. we want something like:
0: 			**
0: 			**		DEC(10,10) and DEC(3,0) => DEC(13,10)
0: 			**
0: 			** (var)char type needs some conversion handled later.
0: 			*/
0: 			if (higherTypeId.isDecimalTypeId() && (!lowerTypeId.isStringTypeId()))
0: 			{
0: 				precision = higherTypeId.getPrecision(this, otherDTS);
0: 				if (precision > 31) precision = 31; //db2 silently does this and so do we
0: 				scale = higherTypeId.getScale(this, otherDTS);
0: 
0: 				/* maximumWidth needs to count possible leading '-' and
0: 				 * decimal point and leading '0' if scale > 0.  See also
0: 				 * sqlgrammar.jj(exactNumericType).  Beetle 3875
0: 				 */
0: 				maximumWidth = (scale > 0) ? precision + 3 : precision + 1;
0: 			}
0: 			else if (thisType.typePrecedence() != otherType.typePrecedence())
0: 			{
0: 				precision = higherType.getPrecision();
0: 				scale = higherType.getScale();
0: 
0: 				/* GROSS HACKS:
0: 				 * If we are doing an implicit (var)char->(var)bit conversion
0: 				 * then the maximum width for the (var)char as a (var)bit
0: 				 * is really 16 * its width as a (var)char.  Adjust
0: 				 * maximumWidth accordingly.
0: 				 * If we are doing an implicit (var)char->decimal conversion
0: 				 * then we need to increment the decimal's precision by
0: 				 * 2 * the maximum width for the (var)char and the scale
0: 				 * by the maximum width for the (var)char. The maximumWidth
0: 				 * becomes the new precision + 3.  This is because
0: 				 * the (var)char could contain any decimal value from XXXXXX
0: 				 * to 0.XXXXX.  (In other words, we don't know which side of the
0: 				 * decimal point the characters will be on.)
0: 				 */
0: 				if (lowerTypeId.isStringTypeId())
0: 				{
0: 					if (higherTypeId.isBitTypeId() &&
0: 						! (higherTypeId.isLongConcatableTypeId()))
0: 					{
0: 						if (lowerTypeId.isLongConcatableTypeId())
0: 						{
0: 							if (maximumWidth > (Integer.MAX_VALUE / 16))
0: 								maximumWidth = Integer.MAX_VALUE;
0: 							else
0: 								maximumWidth *= 16;
0: 						}
0: 						else
0: 						{
0: 							int charMaxWidth;
0: 
0: 							int fromWidth = lowerType.getMaximumWidth();
0: 							if (fromWidth > (Integer.MAX_VALUE / 16))
0: 								charMaxWidth = Integer.MAX_VALUE;
0: 							else
0: 								charMaxWidth = 16 * fromWidth;
0: 
0: 							maximumWidth = (maximumWidth >= charMaxWidth) ?
0: 												maximumWidth : charMaxWidth;
0: 						}
0: 					}
0: 				}
0: 
0: 				/*
0: 				 * If we are doing an implicit (var)char->decimal conversion
0: 				 * then the resulting decimal's precision could be as high as 
0: 				 * 2 * the maximum width (precisely 2mw-1) for the (var)char
0: 				 * and the scale could be as high as the maximum width
0: 				 * (precisely mw-1) for the (var)char.
0: 				 * The maximumWidth becomes the new precision + 3.  This is
0: 				 * because the (var)char could contain any decimal value from
0: 				 * XXXXXX to 0.XXXXX.  (In other words, we don't know which
0: 				 * side of the decimal point the characters will be on.)
0: 				 *
0: 				 * We don't follow this algorithm for long varchar because the
0: 				 * maximum length of a long varchar is maxint, and we don't
0: 				 * want to allocate a huge decimal value.  So in this case,
0: 				 * the precision, scale, and maximum width all come from
0: 				 * the decimal type.
0: 				 */
0: 				if (lowerTypeId.isStringTypeId() &&
0: 					! (lowerTypeId.isLongConcatableTypeId()) &&
0: 					higherTypeId.isDecimalTypeId() )
0: 				{
0: 					int charMaxWidth = lowerType.getMaximumWidth();
0: 					int charPrecision;
0: 
0: 					/*
0: 					** Be careful not to overflow when calculating the
0: 					** precision.  Remember that we will be adding
0: 					** three to the precision to get the maximum width.
0: 					*/
0: 					if (charMaxWidth > (Integer.MAX_VALUE - 3) / 2)
0: 						charPrecision = Integer.MAX_VALUE - 3;
0: 					else
0: 						charPrecision = charMaxWidth * 2;
0: 
0: 					if (precision < charPrecision)
0: 						precision = charPrecision;
0: 
0: 					if (scale < charMaxWidth)
0: 						scale = charMaxWidth;
0: 
0: 					maximumWidth = precision + 3;
0: 				}
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/* At least 1 type is not a system built-in type */
0: 			ClassInspector		cu = cf.getClassInspector();
0: 
0: 			TypeId thisCompType = (TypeId) thisType;
0: 			TypeId otherCompType = (TypeId) otherType;
0: 
0: 			if (cu.assignableTo(thisCompType.getCorrespondingJavaTypeName(),
0: 							    otherCompType.getCorrespondingJavaTypeName()))
0: 			{
0: 				higherType = otherDTS;
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(
0: 							cu.assignableTo(otherCompType.getCorrespondingJavaTypeName(),
0: 									thisCompType.getCorrespondingJavaTypeName()),
0: 							otherCompType.getCorrespondingJavaTypeName() +
0: 							" expected to be assignable to " +
0: 							thisCompType.getCorrespondingJavaTypeName());
0: 
0: 				higherType = this;
0: 			}
0: 			precision = higherType.getPrecision();
0: 			scale = higherType.getScale();
0: 		}
0: 
0: 		higherType = new DataTypeDescriptor(higherType, 
0: 											  precision, scale, nullable, maximumWidth);
0: 
0: 		return higherType;
0: 	}
0: 
0: 	/**
0: 	 * Check whether or not the 2 types (DataTypeDescriptor) have the same type
0: 	 * and length.
0: 	 * This is useful for UNION when trying to decide whether a NormalizeResultSet
0: 	 * is required.
0: 	 *
0: 	 * @param otherDTS	DataTypeDescriptor to compare with.
0: 	 *
0: 	 * @return boolean  Whether or not the 2 DTSs have the same type and length.
0: 	 */
0: 	public boolean isExactTypeAndLengthMatch(DataTypeDescriptor otherDTS)
0: 	{
0: 		/* Do both sides have the same length? */
0: 		if (getMaximumWidth() != otherDTS.getMaximumWidth()) 
0: 		{
0: 			return false;
0: 		}
0: 		if (getScale() != otherDTS.getScale())
0: 		{
0: 			return false;
0: 		}
0: 
0: 		if (getPrecision() != otherDTS.getPrecision())
0: 		{	
0: 			return false;
0: 		}
0: 
0: 		TypeId thisType = getTypeId();
0: 		TypeId otherType = otherDTS.getTypeId();
0: 
0: 		/* Do both sides have the same type? */
0: 		if ( ! thisType.equals(otherType))
0: 		{
0: 			return false;
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	* @see TypeDescriptor#getMaximumWidth
0: 	 */
0: 	public int	getMaximumWidth()
0: 	{
0: 		return typeDescriptor.getMaximumWidth();
0: 	}
0: 
0: 	/**
0: 	 * Gets the TypeId for the datatype.
0: 	 *
0: 	 * @return	The TypeId for the datatype.
0: 	 */
0: 	public TypeId getTypeId()
0: 	{
0: 		return typeId;
0: 	}
0: 
0: 	/**
0: 		Get a Null for this type.
0: 	*/
0: 	public DataValueDescriptor getNull() {
0: 		return typeId.getNull();
0: 	}
0: 
0: 	/**
0: 	 * Gets the name of this datatype.
0: 	 * 
0: 	 *
0: 	 *  @return	the name of this datatype
0: 	 */
0: 	public	String		getTypeName()
0: 	{
0: 		return typeId.getSQLTypeName();
0: 	}
0: 
0: 	/**
0: 	 * Get the jdbc type id for this type.  JDBC type can be
0: 	 * found in java.sql.Types. 
0: 	 *
0: 	 * @return	a jdbc type, e.g. java.sql.Types.DECIMAL 
0: 	 *
0: 	 * @see Types
0: 	 */
0: 	public int getJDBCTypeId()
0: 	{
0: 		return typeId.getJDBCTypeId();
0: 	}
0: 
0: 	/**
0: 	 * Returns the number of decimal digits for the datatype, if applicable.
0: 	 *
0: 	 * @return	The number of decimal digits for the datatype.  Returns
0: 	 *		zero for non-numeric datatypes.
0: 	 */
0: 	public int	getPrecision()
0: 	{
0: 		return typeDescriptor.getPrecision();
0: 	}
0: 
0: 	/**
0: 	 * Returns the number of digits to the right of the decimal for
0: 	 * the datatype, if applicable.
0: 	 *
0: 	 * @return	The number of digits to the right of the decimal for
0: 	 *		the datatype.  Returns zero for non-numeric datatypes.
0: 	 */
0: 	public int	getScale()
0: 	{
0: 		return typeDescriptor.getScale();
0: 	}
0: 
0: 	/**
0: 	 * Returns TRUE if the datatype can contain NULL, FALSE if not.
0: 	 * JDBC supports a return value meaning "nullability unknown" -
0: 	 * I assume we will never have columns where the nullability is unknown.
0: 	 *
0: 	 * @return	TRUE if the datatype can contain NULL, FALSE if not.
0: 	 */
0: 	public boolean	isNullable()
0: 	{
0: 		return typeDescriptor.isNullable();
0: 	}
0: 
0: 	/**
0: 	 * Set the nullability of the datatype described by this descriptor
0: 	 *
0: 	 * @param nullable	TRUE means set nullability to TRUE, FALSE
0: 	 *			means set it to FALSE
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 	public void	setNullability(boolean nullable)
0: 	{
0: 		typeDescriptor.setNullability(nullable);
0: 	}
0: 
0: 	/**
0: 	  Compare if two TypeDescriptors are exactly the same
0: 	  @param typeDescriptor the typeDescriptor to compare to.
0: 	  */
0: 	public boolean equals(Object aTypeDescriptor)
0: 	{
0: 		return typeDescriptor.equals(aTypeDescriptor);
0: 	}
0: 
0: 	/**
0: 	 * Converts this data type descriptor (including length/precision)
0: 	 * to a string. E.g.
0: 	 *
0: 	 *			VARCHAR(30)
0: 	 *
0: 	 *	or
0: 	 *
0: 	 *			 java.util.Hashtable 
0: 	 *
0: 	 * @return	String version of datatype, suitable for running through
0: 	 *			the Parser.
0: 	 */
0: 	public String	getSQLstring()
0: 	{
0: 		return typeId.toParsableString( this );
0: 	}
0: 
0: 	/**
0: 	 * Get the simplified type descriptor that is intended to be stored
0: 	 * in the system tables.
0: 	 */
0: 	public TypeDescriptorImpl getCatalogType()
0: 	{
0: 		return typeDescriptor;
0: 	}
0: 
0: 	/**
0: 	 * Get the estimated memory usage for this type descriptor.
0: 	 */
0: 	public double estimatedMemoryUsage() {
0: 		switch (typeId.getTypeFormatId())
0: 		{
0: 			case StoredFormatIds.LONGVARBIT_TYPE_ID:
0: 				/* Who knows?  Let's just use some big number */
0: 				return 10000.0;
0: 
0: 			case StoredFormatIds.BIT_TYPE_ID:
0: 				return (double) ( ( ((float) getMaximumWidth()) / 8.0) + 0.5);
0: 
0: 			case StoredFormatIds.BOOLEAN_TYPE_ID:
0: 				return 4.0;
0: 
0: 			case StoredFormatIds.CHAR_TYPE_ID:
0: 			case StoredFormatIds.VARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_CHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID:
0: 				return (double) (2.0 * getMaximumWidth());
0: 
0: 			case StoredFormatIds.LONGVARCHAR_TYPE_ID:
0: 			case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
0: 				/* Who knows? Let's just use some big number */
0: 				return 10000.0;
0: 
0: 			case StoredFormatIds.DECIMAL_TYPE_ID:
0: 				/*
0: 				** 0.415 converts from number decimal digits to number of 8-bit digits. 
0: 				** Add 1.0 for the sign byte, and 0.5 to force it to round up.
0: 				*/
0: 				return (double) ( (getPrecision() * 0.415) + 1.5 );
0: 
0: 			case StoredFormatIds.DOUBLE_TYPE_ID:
0: 				return 8.0;
0: 
0: 			case StoredFormatIds.INT_TYPE_ID:
0: 				return 4.0;
0: 
0: 			case StoredFormatIds.LONGINT_TYPE_ID:
0: 				return 8.0;
0: 
0: 			case StoredFormatIds.REAL_TYPE_ID:
0: 				return 4.0;
0: 
0: 			case StoredFormatIds.SMALLINT_TYPE_ID:
0: 				return 2.0;
0: 
0: 			case StoredFormatIds.TINYINT_TYPE_ID:
0: 				return 1.0;
0: 
0: 			case StoredFormatIds.REF_TYPE_ID:
0: 				/* I think 12 is the right number */
0: 				return 12.0;
0: 
0: 			case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
0: 				if (typeId.userType()) {
0: 					/* Who knows?  Let's just use some medium-sized number */
0: 					return 256.0;
0: 				}
0: 			case StoredFormatIds.DATE_TYPE_ID:
0: 			case StoredFormatIds.TIME_TYPE_ID:
0: 			case StoredFormatIds.TIMESTAMP_TYPE_ID:
0: 				return 12.0; 
0: 
0: 			default:
0: 				return 0.0;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Compare JdbcTypeIds to determine if they represent equivalent
0: 	 * SQL types. For example Types.NUMERIC and Types.DECIMAL are
0: 	 * equivalent
0: 	 *
0: 	 * @param existingType  JDBC type id of Cloudscape data type
0: 	 * @param jdbcTypeIdB   JDBC type id passed in from application.
0: 	 *
0: 	 * @return boolean true if types are equivalent, false if not
0: 	 */
0: 
0: 	public static boolean isJDBCTypeEquivalent(int existingType, int jdbcTypeId)
0: 	{
0: 		// Any type matches itself.
0: 		if (existingType == jdbcTypeId)
0: 			return true;
0: 
0: 		// To a numeric type
0: 		if (DataTypeDescriptor.isNumericType(existingType)) {
0: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
0: 				return true;
0: 
0: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
0: 				return true;
0: 
0: 			return false;
0: 		}
0: 
0: 		// To character type.
0: 		if (DataTypeDescriptor.isCharacterType(existingType)) {
0: 
0: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
0: 				return true;
0: 
0: 			if (DataTypeDescriptor.isNumericType(jdbcTypeId))
0: 				return true;
0: 
0: 
0: 			switch (jdbcTypeId) {
0: 			case Types.DATE:
0: 			case Types.TIME:
0: 			case Types.TIMESTAMP:
0: 				return true;
0: 			default:
0: 				break;
0: 			}
0: 
0: 			
0: 			return false;
0: 
0: 		}
0: 
0: 		// To binary type
0: 		if (DataTypeDescriptor.isBinaryType(existingType)) {
0: 
0: 			if (DataTypeDescriptor.isBinaryType(jdbcTypeId))
0: 				return true;
0: 
0: 			return false;
0: 		}
0: 
0: 		// To DATE, TIME
0: 		if (existingType == Types.DATE || existingType == Types.TIME) {
0: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
0: 				return true;
0: 
0: 			if (jdbcTypeId == Types.TIMESTAMP)
0: 				return true;
0: 
0: 			return false;
0: 		}
0: 
0: 		// To TIMESTAMP
0: 		if (existingType == Types.TIMESTAMP) {
0: 			if (DataTypeDescriptor.isCharacterType(jdbcTypeId))
0: 				return true;
0: 
0: 			if (jdbcTypeId == Types.DATE)
0: 				return true;
0: 
0: 			return false;
0: 		}
0: 		
0: 		return false;
0: 	}
0: 
0: 	public static boolean isNumericType(int jdbcType) {
0: 
0: 		switch (jdbcType) {
0: 		case Types.BIT:
0: 		case org.apache.derby.iapi.reference.JDBC30Translation.SQL_TYPES_BOOLEAN:
0: 		case Types.TINYINT:
0: 		case Types.SMALLINT:
0: 		case Types.INTEGER:
0: 		case Types.BIGINT:
0: 		case Types.REAL:
0: 		case Types.FLOAT:
0: 		case Types.DOUBLE:
0: 		case Types.DECIMAL:
0: 		case Types.NUMERIC:
0: 			return true;
0: 		default:
0: 			return false;
0: 		}
0: 	}
0: 
0: 	private static boolean isCharacterType(int jdbcType) {
0: 
0: 		switch (jdbcType) {
0: 		case Types.CHAR:
0: 		case Types.VARCHAR:
0: 		case Types.LONGVARCHAR:
0: 			return true;
0: 		default:
0: 			return false;
0: 		}
0: 	}
0: 
0: 	private static boolean isBinaryType(int jdbcType) {
0: 		switch (jdbcType) {
0: 		case Types.BINARY:
0: 		case Types.VARBINARY:
0: 		case Types.LONGVARBINARY:
0: 			return true;
0: 		default:
0: 			return false;
0: 		}
0: 	}
0: 
0: 	public String	toString()
0: 	{
0: 		return typeDescriptor.toString();
0: 	}
0: 
0: 	// Formatable methods
0: 
0: 	/**
0: 	 * Read this object from a stream of stored objects.
0: 	 *
0: 	 * @param in read this.
0: 	 *
0: 	 * @exception IOException					thrown on error
0: 	 * @exception ClassNotFoundException		thrown on error
0: 	 */
0: 	public void readExternal( ObjectInput in )
0: 		 throws IOException, ClassNotFoundException
0: 	{
0: 		/* NOTE: We only write out the generic type id.
0: 		 * typeId will be reset to be the generic type id
0: 		 * when we get read back in since the generic
0: 		 * one is all that is needed at execution time.
0: 		 */
0: 		typeId = (TypeId) in.readObject();
0: 		typeDescriptor = (TypeDescriptorImpl) in.readObject();
0: 	}
0: 
0: 	/**
0: 	 * Write this object to a stream of stored objects.
0: 	 *
0: 	 * @param out write bytes here.
0: 	 *
0: 	 * @exception IOException		thrown on error
0: 	 */
0: 	public void writeExternal( ObjectOutput out )
0: 		 throws IOException
0: 	{
0: 		out.writeObject( typeId );
0: 		out.writeObject( typeDescriptor );
0: 	}
0:  
0: 	/**
0: 	 * Get the formatID which corresponds to this class.
0: 	 *
0: 	 *	@return	the formatID of this class
0: 	 */
0: 	public	int	getTypeFormatId()	{ return StoredFormatIds.DATA_TYPE_SERVICES_IMPL_V01_ID; }
0: }
0: 
============================================================================