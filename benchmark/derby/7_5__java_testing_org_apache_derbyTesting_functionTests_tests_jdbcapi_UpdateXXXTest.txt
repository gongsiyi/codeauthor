1:b2bb8cd: /*
2:b2bb8cd:  *
1:b2bb8cd:  * Derby - Class UpdateXXXTest
1:b2bb8cd:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:b2bb8cd:  *
1:b2bb8cd:  *    http://www.apache.org/licenses/LICENSE-2.0
1:b2bb8cd:  *
1:b2bb8cd:  * Unless required by applicable law or agreed to in writing,
1:b2bb8cd:  * software distributed under the License is distributed on an
1:b2bb8cd:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:b2bb8cd:  * either express or implied. See the License for the specific
1:b2bb8cd:  * language governing permissions and limitations under the License.
2:b2bb8cd:  */
1:b2bb8cd: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
9:b2bb8cd: 
1:1ae02c9: import java.math.BigDecimal;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:b2bb8cd: import java.sql.ResultSet;
1:b2bb8cd: import java.sql.SQLException;
1:b2bb8cd: import java.sql.Statement;
1:c3df7cf: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:c3df7cf: 
1:b2bb8cd: 
2:b2bb8cd: /**
1:b2bb8cd:  * Tests updateXXX() methods on updatable resultsets.
1:b2bb8cd:  * This is done by creating a table which has n columns with
1:b2bb8cd:  * different SQL types. Then there is one testcase for each
1:b2bb8cd:  * updateXXX method, which calls updateXXX on all columns.
1:b2bb8cd:  */
1:b2bb8cd: final public class UpdateXXXTest extends BaseJDBCTestCase
2:b2bb8cd: {
1:b2bb8cd:     /**
1:b2bb8cd:      * Constructor
1:b2bb8cd:      * @param name name of testcase. Should be the name of test method.
1:b2bb8cd:      */
1:b2bb8cd:     public UpdateXXXTest(final String name) {
1:b2bb8cd:         super(name);
3:b2bb8cd:     }
1:c3df7cf:     
1:bbdb3fd:     /**
1:bbdb3fd:      * Run in both embedded and client.
1:bbdb3fd:      */
1:c3df7cf:     public static Test suite() {
1:bbdb3fd:         
1:1ae02c9:         BaseTestSuite suite = baseSuite("UpdateXXXTest");
1:c3df7cf:         
1:bbdb3fd:         suite.addTest(
1:bbdb3fd:                 TestConfiguration.clientServerDecorator(
1:bbdb3fd:                         baseSuite("UpdateXXXTest:client")));
1:bbdb3fd:                       
1:bbdb3fd:         return suite;
1:bbdb3fd:     }
1:bbdb3fd:     
1:bbdb3fd:     /**
1:bbdb3fd:      * Base suite of tests that will run in both embedded and client.
1:bbdb3fd:      * @param name Name for the suite.
1:bbdb3fd:      */
1:1ae02c9:     private static BaseTestSuite baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:bbdb3fd:           
1:fc81152:         suite.addTestSuite(UpdateXXXTest.class);
1:d038483:         
1:c3df7cf:         // requires java.math.BigDecimal
1:7a5b1d0:         if (JDBC.vmSupportsJDBC3())
1:fc81152:             suite.addTest(new UpdateXXXTest("jdbc2testUpdateBigDecimal"));
1:c3df7cf:                       
1:d038483:         return suite;
1:c3df7cf:     }
1:c3df7cf: 
1:b2bb8cd:     /**
1:b2bb8cd:      * The setup creates a Connection to the database, and also
1:b2bb8cd:      * creates a table with one row. Then it creates an updatable
1:b2bb8cd:      * ResultSet which is positioned on the row.
1:b2bb8cd:      * @exception Exception any exception will cause test to fail with error.
1:b2bb8cd:      */
1:b2bb8cd:     public void setUp()
2:b2bb8cd:         throws Exception
1:b2bb8cd:     {
1:03a99e2:         Connection con = getConnection();
2:b2bb8cd:         try {
1:ffe3f66:             
1:b2bb8cd:             con.setAutoCommit(false);
1:c3df7cf:             
1:b2bb8cd:             Statement stmt = con.createStatement();
1:b2bb8cd:             String createTableString = "CREATE TABLE " + TABLE_NAME + " (" +
1:b2bb8cd:                 "F01 SMALLINT," + 
1:b2bb8cd:                 "F02 INTEGER," +
1:b2bb8cd:                 "F03 BIGINT," + 
1:b2bb8cd:                 "F04 REAL," +
1:b2bb8cd:                 "F05 FLOAT," +
1:b2bb8cd:                 "F06 DOUBLE," +
1:b2bb8cd:                 "F07 DECIMAL," +
1:b2bb8cd:                 "F08 NUMERIC," +
1:b2bb8cd:                 "F09 CHAR(100)," +
1:b2bb8cd:                 "F10 VARCHAR(256) )";
1:b2bb8cd:             println(createTableString);
1:b2bb8cd:             stmt.executeUpdate(createTableString);
1:b2bb8cd:             PreparedStatement ps = con.prepareStatement
1:b2bb8cd:                 ("insert into " + TABLE_NAME + " values(?,?,?,?,?,?,?,?,?,?)");
1:b2bb8cd:             
1:b2bb8cd:             ps.setShort(1, (short) 1);
1:b2bb8cd:             ps.setInt(2, 1);
1:b2bb8cd:             ps.setLong(3, 1L);
1:b2bb8cd:             ps.setFloat(4, 1.0f);
1:b2bb8cd:             ps.setDouble(5, 1.0);
1:b2bb8cd:             ps.setDouble(6, 1.0);
1:c3df7cf:             
1:c3df7cf:             // Use setString instead of setBigDecimal to
1:c3df7cf:             // allow most of the test cases to run under J2ME
1:c3df7cf:             ps.setString(7, "1");
1:c3df7cf:             ps.setString(8, "1");
1:c3df7cf:             
1:b2bb8cd:             ps.setString(9, "1");
1:b2bb8cd:             ps.setString(10, "1");
1:b2bb8cd:             ps.executeUpdate();
1:b2bb8cd:             
1:4316596:             ps.close();
1:4316596:             stmt.close();
2:b2bb8cd:         } catch (SQLException e) {
2:b2bb8cd:             con.rollback();
1:b2bb8cd:             throw e;
1:b2bb8cd:         }
1:b2bb8cd:     }
1:b2bb8cd:         
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateString on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateString() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateString(i, "2");
1:b2bb8cd:             assertEquals("Expected rs.getDouble(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, (int) rs.getDouble(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:b2bb8cd:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateInt on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateInt() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateInt(i, 2);
1:b2bb8cd:             assertEquals("Expected rs.getInt(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, rs.getInt(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateLong on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateLong() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateLong(i, 2L);
1:b2bb8cd:             assertEquals("Expected rs.getLong(" + i + 
1:b2bb8cd:                          ") to match updated value", 2L, rs.getLong(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateShort on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateShort() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateShort(i, (short) 2);
1:b2bb8cd:             assertEquals("Expected rs.getShort(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, (int) rs.getShort(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd:     
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateFloat on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateFloat() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateFloat(i, 2.0f);
1:b2bb8cd:             assertEquals("Expected rs.getFloat(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, (int) rs.getFloat(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd:     
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateDouble on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateDouble() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         
1:4316596:         rs.next();
1:4316596:     	
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateDouble(i, 2.0);
1:b2bb8cd:             assertEquals("Expected rs.getDouble(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, (int) rs.getDouble(i));
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling update on all columns of the row.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:fc81152:     public void jdbc2testUpdateBigDecimal() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateBigDecimal(i, BigDecimal.valueOf(2L));
1:b2bb8cd:             assertEquals("Expected rs.getBigDecimal(" + i + 
1:b2bb8cd:                          ") to match updated value", 2, 
1:b2bb8cd:                          rs.getBigDecimal(i).intValue());
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreUpdated();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd:     
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling updateObject with a null value on all columns.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateObjectWithNull() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         Object value = null;
1:b2bb8cd:         
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateObject(i, value);
1:b2bb8cd:             assertNull("Expected rs.getObject(" + i + ") to be null", 
1:b2bb8cd:                        rs.getObject(i));
1:b2bb8cd:             assertTrue("Expected rs.wasNull() to return true",
1:b2bb8cd:                        rs.wasNull());
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreNull();
1:4316596:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:4316596: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Tests calling setNull on all columns
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     public void testUpdateNull() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                 ResultSet.CONCUR_UPDATABLE);
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:4316596:         rs.next();
1:4316596: 
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             rs.updateNull(i);
1:b2bb8cd:             assertNull("Expected rs.getObject(" + i + ") to be null", 
1:b2bb8cd:                        rs.getObject(i));
1:b2bb8cd:             assertTrue("Expected rs.wasNull() to return true",
1:b2bb8cd:                        rs.wasNull());
1:b2bb8cd:         }
1:b2bb8cd:         rs.updateRow();
1:4316596:         rs.close();
1:b2bb8cd:         checkColumnsAreNull();
1:b2bb8cd:         
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Checks that the columns in the row are all SQL null.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     private void checkColumnsAreNull() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596: 
1:b2bb8cd:         
1:4316596:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                                  ResultSet.CONCUR_READ_ONLY);
1:4316596:         
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:b2bb8cd:         
2:b2bb8cd:         rs.next();
1:b2bb8cd:         
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             assertNull("Expected column " + i + " to be null", 
1:b2bb8cd:                        rs.getObject(i));
1:b2bb8cd:             assertTrue("Expected wasNull() after reading column " + i +
1:b2bb8cd:                        " to be true when data is SQL Null on column", 
1:b2bb8cd:                        rs.wasNull());
1:b2bb8cd:         }
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd: 
1:b2bb8cd:     /**
1:b2bb8cd:      * Checks that the columns in the row are updated in the database.
1:b2bb8cd:      * Using a new ResultSet to do this check.
1:b2bb8cd:      * @exception SQLException database access error. Causes test to 
1:b2bb8cd:      *                         fail with an error.
1:b2bb8cd:      */
1:b2bb8cd:     private void checkColumnsAreUpdated() 
1:b2bb8cd:         throws SQLException
1:b2bb8cd:     {
1:4316596:          Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:4316596:                                  ResultSet.CONCUR_READ_ONLY);
1:b2bb8cd:         
1:4316596:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:b2bb8cd:         
1:b2bb8cd:         rs.next();
1:b2bb8cd:         for (int i = 1; i <= COLUMNS; i++) {
1:b2bb8cd:             int expectedVal = 2;
1:b2bb8cd:             
1:b2bb8cd:             // Since rs.getInt(i) on CHAR/VARCHAR columns with value 2.0 gives:
1:b2bb8cd:             // "ERROR 22018: Invalid character string format for type int"
1:b2bb8cd:             // we use getDouble(i). We cast it to int, because there is not
1:b2bb8cd:             // assertEquals(..) methods which takes double.
1:b2bb8cd:             int actualVal = (int) rs.getDouble(i); 
1:b2bb8cd:             assertEquals("Unexpected value from rs.getDouble( + " + i + ")",
1:b2bb8cd:                          expectedVal, actualVal);
1:b2bb8cd:         }
1:4316596:         s.close();
1:b2bb8cd:     }
1:b2bb8cd:     
1:b2bb8cd:     /* Table name */
1:b2bb8cd:     private static final String TABLE_NAME = "MultiTypeTable";
1:b2bb8cd: 
1:b2bb8cd:     /* SQL String for the SELECT statement */
1:b2bb8cd:     private static final  String SELECT_STMT = 
1:b2bb8cd:         "SELECT * FROM " + TABLE_NAME;
1:b2bb8cd:                              
1:b2bb8cd:     /* Number of columns in table */
1:b2bb8cd:     private static final int COLUMNS = 10;
1:b2bb8cd: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = baseSuite("UpdateXXXTest");
/////////////////////////////////////////////////////////////////////////
1:     private static BaseTestSuite baseSuite(String name) {
1:         BaseTestSuite suite = new BaseTestSuite(name);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7a5b1d0
/////////////////////////////////////////////////////////////////////////
1:         if (JDBC.vmSupportsJDBC3())
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client())
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4316596
/////////////////////////////////////////////////////////////////////////
1:             ps.close();
1:             stmt.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
1:         rs.close();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         
1:         rs.next();
1:     	
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
1:         rs.next();
1: 
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
1:         
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1: 
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                  ResultSet.CONCUR_READ_ONLY);
1:         
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:          Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                  ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rs = s.executeQuery(SELECT_STMT);
/////////////////////////////////////////////////////////////////////////
1:         s.close();
commit:bbdb3fd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run in both embedded and client.
1:      */
0:             return new TestSuite("empty");
0:         TestSuite suite = baseSuite("UpdateXXXTest");
1:         
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                         baseSuite("UpdateXXXTest:client")));
1:                       
1:         return suite;
1:     }
1:     
1:     /**
1:      * Base suite of tests that will run in both embedded and client.
1:      * @param name Name for the suite.
1:      */
0:     private static TestSuite baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
1:           
/////////////////////////////////////////////////////////////////////////
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("UpdateXXXTest");
commit:03a99e2
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getConnection();
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
commit:fc81152
/////////////////////////////////////////////////////////////////////////
1:         suite.addTestSuite(UpdateXXXTest.class);
1:             suite.addTest(new UpdateXXXTest("jdbc2testUpdateBigDecimal"));
/////////////////////////////////////////////////////////////////////////
1:     public void jdbc2testUpdateBigDecimal() 
/////////////////////////////////////////////////////////////////////////
0:         rs = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
0:         rs = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
commit:ffe3f66
/////////////////////////////////////////////////////////////////////////
0:         Connection con = getXConnection();
1:             
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         rs = getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
0:         rs = getXConnection().createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
commit:d038483
/////////////////////////////////////////////////////////////////////////
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
1:             return suite;
1:         
commit:c3df7cf
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.JDBC;
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         
0:         suite.addTest(new UpdateXXXTest("testUpdateShort"));
0:         suite.addTest(new UpdateXXXTest("testUpdateInt"));
0:         suite.addTest(new UpdateXXXTest("testUpdateLong"));
0:         suite.addTest(new UpdateXXXTest("testUpdateFloat"));
0:         suite.addTest(new UpdateXXXTest("testUpdateDouble"));
0:         suite.addTest(new UpdateXXXTest("testUpdateNull"));
0:         suite.addTest(new UpdateXXXTest("testUpdateObjectWithNull"));
0:         suite.addTest(new UpdateXXXTest("testUpdateString"));
1:         
1:         // requires java.math.BigDecimal
0:         if (JDBC.vmSupportsJDBC2())
0:             suite.addTest(new UpdateXXXTest("testUpdateBigDecimal"));
1:                       
0:         return suite;
1:     }
1:  
/////////////////////////////////////////////////////////////////////////
1:             
1:             // Use setString instead of setBigDecimal to
1:             // allow most of the test cases to run under J2ME
1:             ps.setString(7, "1");
1:             ps.setString(8, "1");
1:             
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:b2bb8cd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class UpdateXXXTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.PreparedStatement;
1: import java.sql.Statement;
0: import java.sql.Connection;
1: 
0: import java.math.BigDecimal;
1: 
1: 
1: /**
1:  * Tests updateXXX() methods on updatable resultsets.
1:  * This is done by creating a table which has n columns with
1:  * different SQL types. Then there is one testcase for each
1:  * updateXXX method, which calls updateXXX on all columns.
1:  */
1: final public class UpdateXXXTest extends BaseJDBCTestCase
1: {
1:     /**
1:      * Constructor
1:      * @param name name of testcase. Should be the name of test method.
1:      */
1:     public UpdateXXXTest(final String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * The setup creates a Connection to the database, and also
1:      * creates a table with one row. Then it creates an updatable
1:      * ResultSet which is positioned on the row.
1:      * @exception Exception any exception will cause test to fail with error.
1:      */
1:     public void setUp()
1:         throws Exception
1:     {
1:         try {
0:             con = getConnection();
1:             con.setAutoCommit(false);
1:             
1:             Statement stmt = con.createStatement();
1:             String createTableString = "CREATE TABLE " + TABLE_NAME + " (" +
1:                 "F01 SMALLINT," + 
1:                 "F02 INTEGER," +
1:                 "F03 BIGINT," + 
1:                 "F04 REAL," +
1:                 "F05 FLOAT," +
1:                 "F06 DOUBLE," +
1:                 "F07 DECIMAL," +
1:                 "F08 NUMERIC," +
1:                 "F09 CHAR(100)," +
1:                 "F10 VARCHAR(256) )";
1:             println(createTableString);
1:             stmt.executeUpdate(createTableString);
1:             PreparedStatement ps = con.prepareStatement
1:                 ("insert into " + TABLE_NAME + " values(?,?,?,?,?,?,?,?,?,?)");
1:             
1:             ps.setShort(1, (short) 1);
1:             ps.setInt(2, 1);
1:             ps.setLong(3, 1L);
1:             ps.setFloat(4, 1.0f);
1:             ps.setDouble(5, 1.0);
1:             ps.setDouble(6, 1.0);
0:             ps.setBigDecimal(7, BigDecimal.valueOf(1L));
0:             ps.setBigDecimal(8, BigDecimal.valueOf(1L));
1:             ps.setString(9, "1");
1:             ps.setString(10, "1");
1:             ps.executeUpdate();
1:             
0:             rs = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:                                      ResultSet.CONCUR_UPDATABLE).
0:                 executeQuery(SELECT_STMT);
1:             rs.next();
1:         } catch (SQLException e) {
1:             con.rollback();
1:             throw e;
1:         }
1:     }
1: 
1:     /**
0:      * Teardown test.
0:      * Rollback connection and close it.
0:      * @exception Exceptions causes the test to fail with error
1:      */
0:     public void tearDown() 
1:         throws Exception 
1:     {
1:         try { 
1:             con.rollback();
0:             con.close();
1:         } catch (SQLException e) {
0:             printStackTrace(e);
1:         }      
1:     }
1:         
1:     /**
1:      * Tests calling updateString on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateString() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateString(i, "2");
1:             assertEquals("Expected rs.getDouble(" + i + 
1:                          ") to match updated value", 2, (int) rs.getDouble(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:         
1:     }
1: 
1:     /**
1:      * Tests calling updateInt on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateInt() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateInt(i, 2);
1:             assertEquals("Expected rs.getInt(" + i + 
1:                          ") to match updated value", 2, rs.getInt(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1: 
1:     /**
1:      * Tests calling updateLong on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateLong() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateLong(i, 2L);
1:             assertEquals("Expected rs.getLong(" + i + 
1:                          ") to match updated value", 2L, rs.getLong(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1: 
1:     /**
1:      * Tests calling updateShort on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateShort() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateShort(i, (short) 2);
1:             assertEquals("Expected rs.getShort(" + i + 
1:                          ") to match updated value", 2, (int) rs.getShort(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1:     
1:     /**
1:      * Tests calling updateFloat on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateFloat() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateFloat(i, 2.0f);
1:             assertEquals("Expected rs.getFloat(" + i + 
1:                          ") to match updated value", 2, (int) rs.getFloat(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1:     
1:     /**
1:      * Tests calling updateDouble on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateDouble() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateDouble(i, 2.0);
1:             assertEquals("Expected rs.getDouble(" + i + 
1:                          ") to match updated value", 2, (int) rs.getDouble(i));
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1: 
1:     /**
1:      * Tests calling update on all columns of the row.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
0:     public void testUpdateBigDecimal() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateBigDecimal(i, BigDecimal.valueOf(2L));
1:             assertEquals("Expected rs.getBigDecimal(" + i + 
1:                          ") to match updated value", 2, 
1:                          rs.getBigDecimal(i).intValue());
1:         }
1:         rs.updateRow();
1:         checkColumnsAreUpdated();
1:     }
1:     
1:     /**
1:      * Tests calling updateObject with a null value on all columns.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateObjectWithNull() 
1:         throws SQLException
1:     {
1:         Object value = null;
1:         
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateObject(i, value);
1:             assertNull("Expected rs.getObject(" + i + ") to be null", 
1:                        rs.getObject(i));
1:             assertTrue("Expected rs.wasNull() to return true",
1:                        rs.wasNull());
1:         }
1:         rs.updateRow();
1:         checkColumnsAreNull();
1:     }
1: 
1:     /**
1:      * Tests calling setNull on all columns
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     public void testUpdateNull() 
1:         throws SQLException
1:     {
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             rs.updateNull(i);
1:             assertNull("Expected rs.getObject(" + i + ") to be null", 
1:                        rs.getObject(i));
1:             assertTrue("Expected rs.wasNull() to return true",
1:                        rs.wasNull());
1:         }
1:         rs.updateRow();
1:         checkColumnsAreNull();
1:     }
1: 
1:     /**
1:      * Checks that the columns in the row are all SQL null.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     private void checkColumnsAreNull() 
1:         throws SQLException
1:     {
0:         rs.close();
1:         
0:         rs = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:                                  ResultSet.CONCUR_READ_ONLY).
0:             executeQuery(SELECT_STMT);
1:         
1:         rs.next();
1:         
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             assertNull("Expected column " + i + " to be null", 
1:                        rs.getObject(i));
1:             assertTrue("Expected wasNull() after reading column " + i +
1:                        " to be true when data is SQL Null on column", 
1:                        rs.wasNull());
1:         }
1:     }
1: 
1:     /**
1:      * Checks that the columns in the row are updated in the database.
1:      * Using a new ResultSet to do this check.
1:      * @exception SQLException database access error. Causes test to 
1:      *                         fail with an error.
1:      */
1:     private void checkColumnsAreUpdated() 
1:         throws SQLException
1:     {
0:         rs.close();
1:         
0:         rs = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
0:                                  ResultSet.CONCUR_READ_ONLY).
0:             executeQuery(SELECT_STMT);
1:         
1:         rs.next();
1:         for (int i = 1; i <= COLUMNS; i++) {
1:             int expectedVal = 2;
1:             
1:             // Since rs.getInt(i) on CHAR/VARCHAR columns with value 2.0 gives:
1:             // "ERROR 22018: Invalid character string format for type int"
1:             // we use getDouble(i). We cast it to int, because there is not
1:             // assertEquals(..) methods which takes double.
1:             int actualVal = (int) rs.getDouble(i); 
1:             assertEquals("Unexpected value from rs.getDouble( + " + i + ")",
1:                          expectedVal, actualVal);
1:         }
1:     }
1:     
0:     /* Updatable ResultSet */
0:     private ResultSet rs = null;
1:     
0:     /* Connection */
0:     private Connection con = null;
1:     
1:     /* Table name */
1:     private static final String TABLE_NAME = "MultiTypeTable";
1: 
1:     /* SQL String for the SELECT statement */
1:     private static final  String SELECT_STMT = 
1:         "SELECT * FROM " + TABLE_NAME;
1:                              
1:     /* Number of columns in table */
1:     private static final int COLUMNS = 10;
1: }
============================================================================