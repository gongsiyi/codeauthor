1:33776ff: /*
1:d506170: 
1:33776ff:    Derby - Class org.apache.derby.client.am.CallableStatement
97:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:70f7692: 
1:69e3d06: import java.io.InputStream;
1:407e52d: import org.apache.derby.client.ClientPooledConnection;
1:daecc5d: import org.apache.derby.shared.common.reference.SQLState;
1:33776ff: 
1:9c14132: import java.io.Reader;
1:69e3d06: import java.math.BigDecimal;
1:69e3d06: import java.net.URL;
1:69e3d06: import java.sql.Array;
1:69e3d06: import java.sql.Blob;
1:69e3d06: import java.sql.CallableStatement;
1:69e3d06: import java.sql.Clob;
1:7d521f5: import java.sql.Date;
1:9a0cdf1: import java.sql.NClob;
1:69e3d06: import java.sql.PreparedStatement;
1:69e3d06: import java.sql.Ref;
1:9a0cdf1: import java.sql.RowId;
1:9c14132: import java.sql.SQLException;
1:9a0cdf1: import java.sql.SQLXML;
1:7d521f5: import java.sql.Time;
1:7d521f5: import java.sql.Timestamp;
1:7d521f5: import java.util.Calendar;
1:69e3d06: import java.util.Map;
1:9c14132: 
1:69e3d06: public class ClientCallableStatement extends ClientPreparedStatement
1:69e3d06:     implements PreparedStatement, CallableStatement,
1:69e3d06:                PreparedStatementCallbackInterface {
1:70f7692:     //---------------------navigational members-----------------------------------
1:33776ff: 
1:70f7692:     //---------------------navigational cheat-links-------------------------------
1:70f7692:     // Cheat-links are for convenience only, and are not part of the conceptual model.
1:70f7692:     // Warning:
1:70f7692:     //   Cheat-links should only be defined for invariant state data.
1:70f7692:     //   That is, the state data is set by the constructor and never changes.
1:33776ff: 
1:70f7692:     public MaterialPreparedStatement materialCallableStatement_ = null;
1:33776ff: 
1:70f7692:     //-----------------------------state------------------------------------------
1:33776ff: 
1:70f7692:     // last retrieved result was a sql NULL, NOT_NULL, or UNSET.
1:70f7692:     private int wasNull_ = WAS_NULL_UNSET;
1:70f7692:     static final private int WAS_NULL = 1;
1:70f7692:     static final private int WAS_NOT_NULL = 2;
1:70f7692:     static final private int WAS_NULL_UNSET = 0;
1:33776ff: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:70f7692: 
1:70f7692:     private void initCallableStatement() {
1:70f7692:         materialCallableStatement_ = null;
1:70f7692:         wasNull_ = WAS_NULL_UNSET;
99:70f7692:     }
1:70f7692: 
1:70f7692:     public void reset(boolean fullReset) throws SqlException {
1:70f7692:         if (fullReset) {
1:70f7692:             connection_.resetPrepareCall(this);
2:70f7692:         } else {
1:70f7692:             super.reset(fullReset);
1:70f7692:         }
1:70f7692:         wasNull_ = WAS_NULL_UNSET;
1:70f7692:     }
1:70f7692: 
1:407e52d:     /**
1:407e52d:      * Common constructor for jdbc 2 callable statements with scroll attributes.
1:407e52d:      * Called by material statement constructor.
1:407e52d:      *
1:407e52d:      * @param agent       The instance of NetAgent associated with this
1:407e52d:      *                    CallableStatement object.
1:407e52d:      * @param connection  The connection object associated with this
1:407e52d:      *                    PreparedStatement Object.
1:407e52d:      * @param sql         A String object that is the SQL statement to be sent 
1:407e52d:      *                    to the database.
1:407e52d:      * @param type        One of the ResultSet type constants
1:407e52d:      * @param concurrency One of the ResultSet concurrency constants
1:407e52d:      * @param holdability One of the ResultSet holdability constants
1:407e52d:      * @param cpc         The PooledConnection object that will be used to 
1:407e52d:      *                    notify the PooledConnection reference of the Error 
1:407e52d:      *                    Occurred and the Close events.
1:407e52d:      * @throws SqlException
1:407e52d:      */
1:69e3d06:     public ClientCallableStatement(Agent agent,
2:69e3d06:                              ClientConnection connection,
3:70f7692:                              String sql,
1:407e52d:                              int type, int concurrency, int holdability,
1:407e52d:                              ClientPooledConnection cpc) throws SqlException {
1:69e3d06:         super(agent,
1:69e3d06:               connection,
1:69e3d06:               sql,
1:69e3d06:               type,
1:69e3d06:               concurrency,
1:69e3d06:               holdability,
1:69e3d06:               ClientStatement.NO_GENERATED_KEYS,
1:69e3d06:               null,
1:69e3d06:               null,
1:69e3d06:               cpc);
3:70f7692:         initCallableStatement();
1:70f7692:     }
1:70f7692: 
3:70f7692:     public void resetCallableStatement(Agent agent,
1:69e3d06:                                        ClientConnection connection,
1:70f7692:                                        String sql,
2:70f7692:                                        int type, int concurrency, int holdability) throws SqlException {
1:69e3d06:         super.resetPreparedStatement(
1:69e3d06:             agent,
1:69e3d06:             connection,
1:69e3d06:             sql,
1:69e3d06:             type,
1:69e3d06:             concurrency,
1:69e3d06:             holdability,
1:69e3d06:             ClientStatement.NO_GENERATED_KEYS,
1:69e3d06:             null,
1:69e3d06:             null);
1:70f7692:         initCallableStatement();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     protected void finalize() throws Throwable {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "finalize");
1:70f7692:         }
1:70f7692:         super.finalize();
1:70f7692:     }
1:70f7692: 
1:70f7692:     //---------------------------entry points-------------------------------------
1:70f7692: 
1:d506170:     public void clearParameters() throws SQLException {
1:d506170:         synchronized (connection_) {
1:d506170:             if (agent_.loggingEnabled()) {
1:70f7692:                 agent_.logWriter_.traceEntry(this, "clearParameters");
1:70f7692:             }
1:70f7692:             super.clearParameters();
1:70f7692:             outputRegistered_ = false; // this variable is only used by Batch
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public void registerOutParameter(int parameterIndex, int jdbcType) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType);
1:d506170:                 }
1:d506170:                 registerOutParameterX(parameterIndex, jdbcType);
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:35d620a: 
1:70f7692:     // also used by Sqlca
1:70f7692:     void registerOutParameterX(int parameterIndex, int jdbcType) throws SqlException {
1:d506170:         super.checkForClosedStatement();
1:70f7692:         int scale = 0; // default scale to 0 for non numeric and non decimal type
2:70f7692:         registerOutParameterX(parameterIndex, jdbcType, scale);
1:d506170:     }
1:35d620a: 
1:d506170:     public void registerOutParameter(int parameterIndex, int jdbcType, int scale) throws SQLException {
1:d506170:         try
1:35d620a:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, scale);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 registerOutParameterX(parameterIndex, jdbcType, scale);
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:70f7692:     private void registerOutParameterX(int parameterIndex, int jdbcType, int scale) throws SqlException {
1:70f7692:         super.checkForValidParameterIndex(parameterIndex);
1:4c2fc4a:         agent_.checkForSupportedDataType( jdbcType );
2:70f7692:         checkForValidScale(scale);
1:70f7692:         outputRegistered_ = true; // this variable is only used by Batch
1:70f7692:         //parameterSetOrRegistered_[parameterIndex - 1] = true;
1:70f7692:         parameterRegistered_[parameterIndex - 1] = true;
1:d506170:     }
1:70f7692: 
1:9206d5b:     /** Derby ignores the typeName argument because UDTs don't need it */
1:d506170:     public void registerOutParameter(int parameterIndex, int jdbcType, String typeName) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:d506170:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, typeName);
1:d506170:         }
1:9206d5b:         registerOutParameter( parameterIndex, jdbcType );
1:d506170:     }
1:70f7692: 
1:d506170:     public boolean wasNull() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceEntry(this, "wasNull");
1:d506170:             }
1:d506170:             boolean result = wasNullX();
1:d506170:             if (agent_.loggingEnabled()) {
1:d506170:                 agent_.logWriter_.traceExit(this, "wasNull", result);
1:d506170:             }
1:d506170:             return result;
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:70f7692:     private boolean wasNullX() throws SqlException {
1:d506170:         super.checkForClosedStatement();
1:70f7692:         if (wasNull_ == WAS_NULL_UNSET) {
1:d506170:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.WASNULL_INVALID));
1:d506170:         }
1:70f7692:         return wasNull_ == WAS_NULL;
1:d506170:     }
1:70f7692: 
1:70f7692:     //--------------------------------getter methods------------------------------
1:70f7692: 
1:d506170:     public boolean getBoolean(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBoolean", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 boolean result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? false : singletonRowData_.getBoolean(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getBoolean", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:d506170:     public byte getByte(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getByte", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 byte result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? 0 : singletonRowData_.getByte(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getByte", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:d506170:     public short getShort(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getShort", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 short result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? 0 : singletonRowData_.getShort(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getShort", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:d506170:     public int getInt(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getInt", parameterIndex);
1:d506170:                 }
1:d506170:                 int result = getIntX(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getInt", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
2:70f7692:     // also used by SQLCA
1:70f7692:     int getIntX(int parameterIndex) throws SqlException {
1:d506170:         super.checkForClosedStatement();
1:d506170:         checkGetterPreconditions(parameterIndex);
1:d506170:         setWasNull(parameterIndex);
1:70f7692:         return wasNullX() ? 0 : singletonRowData_.getInt(parameterIndex);
1:70f7692:     }
1:33776ff: 
1:d506170:     public long getLong(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getLong", parameterIndex);
1:d506170:                 }
1:6de69bd:                 long result = getLongX(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getLong", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:6de69bd:     long getLongX(int parameterIndex) throws SqlException {
1:6de69bd:         super.checkForClosedStatement();
1:6de69bd:         checkGetterPreconditions(parameterIndex);
1:6de69bd:         setWasNull(parameterIndex);
1:6de69bd:         return wasNullX() ? 0 : singletonRowData_.getLong(parameterIndex);
1:6de69bd:     }
1:6de69bd: 
1:d506170:     public float getFloat(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getFloat", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 float result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? 0 : singletonRowData_.getFloat(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getFloat", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:d506170:     public double getDouble(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getDouble", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 double result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? 0 : singletonRowData_.getDouble(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getDouble", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:33776ff: 
1:e24d8ef:     /** @deprecated */
1:69e3d06:     public BigDecimal getBigDecimal(int parameterIndex, int scale)
1:69e3d06:             throws SQLException, ArithmeticException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceDeprecatedEntry(this, "getBigDecimal", parameterIndex, scale);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkForValidScale(scale);
1:69e3d06:                 BigDecimal result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
1:d506170:                 if (result != null) {
1:69e3d06:                     result = result.setScale(scale, BigDecimal.ROUND_DOWN);
1:d506170:                 }
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceDeprecatedExit(this, "getBigDecimal", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:69e3d06:                 BigDecimal result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getBigDecimal", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Date getDate(int parameterIndex, Calendar cal) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:7d521f5:                     agent_.logWriter_.traceEntry(
1:7d521f5:                             this, "getDate", parameterIndex, cal);
1:70f7692:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:7d521f5: 
1:7d521f5:                 if (cal == null) {
1:7d521f5:                     throw new SqlException(agent_.logWriter_,
1:7d521f5:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:7d521f5:                 }
1:7d521f5: 
1:d506170:                 setWasNull(parameterIndex);
1:7d521f5:                 Date result = wasNullX() ?
1:7d521f5:                         null :
1:7d521f5:                         singletonRowData_.getDate(parameterIndex, cal);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getDate", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Date getDate(int parameterIndex) throws SQLException {
1:7d521f5:         return getDate(parameterIndex, Calendar.getInstance());
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Time getTime(int parameterIndex, Calendar cal) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:7d521f5:                     agent_.logWriter_.traceEntry(
1:7d521f5:                             this, "getTime", parameterIndex, cal);
1:7d521f5:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:7d521f5: 
1:7d521f5:                 if (cal == null) {
1:7d521f5:                     throw new SqlException(agent_.logWriter_,
1:7d521f5:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:70f7692:                 }
1:7d521f5: 
1:d506170:                 setWasNull(parameterIndex);
1:7d521f5:                 Time result = wasNullX() ?
1:7d521f5:                         null :
1:7d521f5:                         singletonRowData_.getTime(parameterIndex, cal);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getTime", result);
1:70f7692:                 }
1:d506170:                 return result;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Time getTime(int parameterIndex) throws SQLException {
1:7d521f5:         return getTime(parameterIndex, Calendar.getInstance());
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Timestamp getTimestamp(int parameterIndex, Calendar cal)
1:7d521f5:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:7d521f5:                     agent_.logWriter_.traceEntry(
1:7d521f5:                             this, "getTimestamp", parameterIndex, cal);
1:7d521f5:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:7d521f5: 
1:7d521f5:                 if (cal == null) {
1:7d521f5:                     throw new SqlException(agent_.logWriter_,
1:7d521f5:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:70f7692:                 }
1:7d521f5: 
1:d506170:                 setWasNull(parameterIndex);
1:7d521f5:                 Timestamp result = wasNullX() ?
1:7d521f5:                         null :
1:7d521f5:                         singletonRowData_.getTimestamp(parameterIndex, cal);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getTimestamp", result);
1:70f7692:                 }
1:d506170:                 return result;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:7d521f5:     public Timestamp getTimestamp(int parameterIndex) throws SQLException {
1:7d521f5:         return getTimestamp(parameterIndex, Calendar.getInstance());
1:70f7692:     }
1:33776ff: 
1:d506170:     public String getString(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getString", parameterIndex);
1:d506170:                 }
1:d506170:                 String result = getStringX(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getString", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // also used by SQLCA
1:70f7692:     String getStringX(int parameterIndex) throws SqlException {
1:d506170:         super.checkForClosedStatement();
1:d506170:         checkGetterPreconditions(parameterIndex);
1:d506170:         setWasNull(parameterIndex);
1:70f7692:         return wasNullX() ? null : singletonRowData_.getString(parameterIndex);
1:70f7692:     }
1:33776ff: 
1:d506170:     public byte[] getBytes(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBytes", parameterIndex);
1:d506170:                 }
1:6de69bd:                 byte[] result = getBytesX(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getBytes", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:33776ff: 
1:6de69bd:     byte[] getBytesX(final int parameterIndex) throws SqlException 
1:6de69bd:     {
1:6de69bd:         super.checkForClosedStatement();
1:6de69bd:         checkGetterPreconditions(parameterIndex);
1:6de69bd:         setWasNull(parameterIndex);
1:6de69bd:         return  wasNullX() ? null : singletonRowData_.getBytes(parameterIndex);
1:6de69bd:      }
1:6de69bd: 
1:69e3d06:     public Blob getBlob(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getBlob", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:69e3d06:                 Blob result = wasNullX() ? null :
1:69e3d06:                     singletonRowData_.getBlob(parameterIndex);
1:69e3d06: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getBlob", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public Clob getClob(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:69e3d06:                 Clob result = wasNullX() ? null :
1:69e3d06:                     singletonRowData_.getClob(parameterIndex);
1:69e3d06: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getClob", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public Array getArray(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
4:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getArray", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:69e3d06:                 Array result = wasNullX() ? null :
1:69e3d06:                     singletonRowData_.getArray(parameterIndex);
1:69e3d06: 
1:d506170:                 if (true) {
1:d506170:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
1:d506170:                 }
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getArray", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:69e3d06:     public Ref getRef(int parameterIndex) throws SQLException {
4:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getRef", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:69e3d06:                 Ref result = wasNullX() ? null :
1:69e3d06:                     singletonRowData_.getRef(parameterIndex);
1:69e3d06: 
1:d506170:                 if (true) {
1:d506170:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
1:d506170:                 }
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getRef", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:70f7692:         }
4:d506170:         catch ( SqlException se )
10:d506170:         {
4:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:d506170:     public Object getObject(int parameterIndex) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 Object result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 setWasNull(parameterIndex);
1:d506170:                 result = wasNullX() ? null : singletonRowData_.getObject(parameterIndex);
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getObject", result);
1:d506170:                 }
1:d506170:                 return result;
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:69e3d06:     public Object getObject(int parameterIndex, Map map) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex, map);
1:d506170:                 }
1:d506170:                 super.checkForClosedStatement();
1:d506170:                 Object result;
1:d506170:                 checkGetterPreconditions(parameterIndex);
1:d506170:                 if (true) {
7:d506170:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
1:d506170:                 }
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getObject", result);
1:70f7692:                 }
1:d506170:                 return result;
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------------------JDBC 3.0------------------------------------------
1:70f7692: 
1:d506170:     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, scale);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, typeName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public URL getURL(int parameterIndex) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getURL", parameterIndex);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setURL(String parameterName, URL x) throws SQLException {
1:b94443f:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setURL", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setNull(String parameterName, int sqlType) throws SQLException {
74:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setBoolean(String parameterName, boolean x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setBoolean", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setByte(String parameterName, byte x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setByte", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setShort(String parameterName, short x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setShort", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setInt(String parameterName, int x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setInt", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setLong(String parameterName, long x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setLong", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setFloat(String parameterName, float x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setFloat", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setDouble(String parameterName, double x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setDouble", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setBigDecimal(String parameterName, BigDecimal x)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setString(String parameterName, String x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setString", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setBytes(String parameterName, byte x[]) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setBytes", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setDate(String parameterName, Date x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x);
1:70f7692:         }
1:320777f:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setTime(String parameterName, Time x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setTimestamp(String parameterName, Timestamp x)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setAsciiStream(String parameterName, InputStream x, int length)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterName, x, length);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setBinaryStream(String parameterName, InputStream x, int length)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterName, x, length);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType, scale);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setObject(String parameterName, Object x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setCharacterStream(String parameterName,
1:69e3d06:                                    Reader reader,
1:69e3d06:                                    int length) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterName, reader, length);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setDate(String parameterName, Date x, Calendar calendar)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setTime(String parameterName, Time x, Calendar calendar)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setTimestamp(String parameterName,
1:69e3d06:                              Timestamp x,
1:69e3d06:                              Calendar calendar) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType, typeName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public String getString(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getString", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean getBoolean(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getBoolean", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public byte getByte(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getByte", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public short getShort(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getShort", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getInt(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getInt", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public long getLong(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getLong", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public float getFloat(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getFloat", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public double getDouble(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getDouble", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public byte[] getBytes(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getBytes", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Date getDate(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getDate", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Time getTime(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getTime", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Timestamp getTimestamp(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:d506170:     public Object getObject(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getObject", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public BigDecimal getBigDecimal(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Object getObject(String parameterName, Map map) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getObject", parameterName, map);
1:d506170:             }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Ref getRef(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getRef", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Blob getBlob(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getBlob", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Clob getClob(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getClob", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Array getArray(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getArray", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Date getDate(String parameterName, Calendar calendar)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getDate", parameterName, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Time getTime(String parameterName, Calendar calendar)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getTime", parameterName, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public Timestamp getTimestamp(String parameterName, Calendar calendar)
1:69e3d06:             throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName, calendar);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public URL getURL(String parameterName) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "getURL", parameterName);
1:70f7692:         }
1:e4b2438:         throw jdbcMethodNotImplemented();
1:70f7692:     }
1:70f7692: 
1:9c14132:     //-------------------------- JDBC 4.0 methods --------------------------------
1:9c14132:     
1:9c14132:     public Reader getCharacterStream(int parameterIndex)
1:9c14132:         throws SQLException {
1:35d620a:         try {
1:9c14132:             synchronized (connection_) {
1:9c14132:                 if (agent_.loggingEnabled()) {
1:9c14132:                     agent_.logWriter_.traceEntry(this, "getCharacterStream", parameterIndex);
1:9c14132:                 }
1:9c14132:                 super.checkForClosedStatement();
1:9c14132:                 checkGetterPreconditions(parameterIndex);
1:9c14132:                 setWasNull(parameterIndex);
1:9c14132:                 Reader reader = null;
1:9c14132:                 if (this.wasNull_ == WAS_NOT_NULL) {
1:9c14132:                     reader = singletonRowData_.getCharacterStream(parameterIndex);
1:9c14132:                 }
1:9c14132:                 if (agent_.loggingEnabled()) {
1:9c14132:                     agent_.logWriter_.traceExit(this, "getCharacterStream", reader);
1:9c14132:                 }
1:9c14132:                 return reader;
1:9c14132:             }
1:9c14132:              
1:9c14132:         } catch (SqlException se) {
1:9c14132:             throw se.getSQLException();
1:9c14132:         }
1:9c14132:     }
1:9c14132: 
1:9a0cdf1:     public final void setAsciiStream(String parameterName, InputStream x, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setAsciiStream(String,InputStream,long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public final void setBinaryStream(String parameterName, InputStream x, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setBinaryStream(String,InputStream,long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public final void setCharacterStream(String parameterName, Reader x, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setCharacterStream(String,Reader,long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Reader getCharacterStream(String parameterName)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getCharacterStream(String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Reader getNCharacterStream(int parameterIndex)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getNCharacterStream(int)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public Reader getNCharacterStream(String parameterName)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "getNCharacterStream(String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public String getNString(int parameterIndex)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getNString(int)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public String getNString(String parameterIndex)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getNString(String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public RowId getRowId(int parameterIndex) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getRowId (int)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public RowId getRowId(String parameterName) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getRowId (String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setRowId(String parameterName, RowId x) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setRowId (String, RowId)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setBlob(String parameterName, Blob x)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setBlob(String, Blob)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setClob(String parameterName, Clob x)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setClob(String, Clob)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNString(String parameterName, String value)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNString (String, String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNCharacterStream(String parameterName, Reader value, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setNString (String, Reader, long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNClob(String parameterName, NClob value) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob (String, NClob)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setClob(String parameterName, Reader reader, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setClob (String, Reader, long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setBlob(String parameterName, InputStream inputStream, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setBlob (String, InputStream, long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNClob(String parameterName, Reader reader, long length)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob (String, Reader, long)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public NClob getNClob(int i) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob (int)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public NClob getNClob(String parameterName) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob (String)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setSQLXML (String, SQLXML)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public SQLXML getSQLXML(int parameterIndex) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getSQLXML (int)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public SQLXML getSQLXML(String parametername) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("getSQLXML (String)");
1:9a0cdf1:     }
1:9a0cdf1:     public void setAsciiStream(String parameterName, InputStream x)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setAsciiStream(String,InputStream)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setBinaryStream(String parameterName, InputStream x)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setBinaryStream(String,InputStream)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setBlob(String parameterName, InputStream inputStream)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setBlob(String,InputStream)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setCharacterStream(String parameterName, Reader reader)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setCharacterStream(String,Reader)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setClob(String parameterName, Reader reader)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setClob(String,Reader)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNCharacterStream(String parameterName, Reader value)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented(
1:9a0cdf1:                 "setNCharacterStream(String,Reader)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNClob(String parameterName, Reader reader)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob(String,Reader)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:9a0cdf1:     //
1:9a0cdf1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:9a0cdf1:     //
1:9a0cdf1:     ////////////////////////////////////////////////////////////////////
1:9a0cdf1: 
1:9a0cdf1:     public <T> T getObject( int parameterIndex, Class<T> type )
1:9a0cdf1:         throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         // checkForClosedStatement() should be called by all of the
1:9a0cdf1:         // more specific methods to which we forward this call
1:9a0cdf1: 
1:9a0cdf1:         if ( type == null )
1:9a0cdf1:         {
1:9a0cdf1:             throw mismatchException( "NULL", parameterIndex );
1:9a0cdf1:         }
1:9a0cdf1: 
1:9a0cdf1:         Object   retval;
1:9a0cdf1: 
1:9a0cdf1:         if ( String.class.equals( type ) ) { retval = getString( parameterIndex ); }
1:9a0cdf1:         else if ( BigDecimal.class.equals( type ) ) { retval = getBigDecimal( parameterIndex ); }
1:9a0cdf1:         else if ( Boolean.class.equals( type ) ) { retval = Boolean.valueOf( getBoolean(parameterIndex ) ); }
1:9a0cdf1:         else if ( Byte.class.equals( type ) ) { retval = Byte.valueOf( getByte( parameterIndex ) ); }
1:9a0cdf1:         else if ( Short.class.equals( type ) ) { retval = Short.valueOf( getShort( parameterIndex ) ); }
1:9a0cdf1:         else if ( Integer.class.equals( type ) ) { retval = Integer.valueOf( getInt( parameterIndex ) ); }
1:9a0cdf1:         else if ( Long.class.equals( type ) ) { retval = Long.valueOf( getLong( parameterIndex ) ); }
1:9a0cdf1:         else if ( Float.class.equals( type ) ) { retval = Float.valueOf( getFloat( parameterIndex ) ); }
1:9a0cdf1:         else if ( Double.class.equals( type ) ) { retval = Double.valueOf( getDouble( parameterIndex ) ); }
1:9a0cdf1:         else if ( Date.class.equals( type ) ) { retval = getDate( parameterIndex ); }
1:9a0cdf1:         else if ( Time.class.equals( type ) ) { retval = getTime( parameterIndex ); }
1:9a0cdf1:         else if ( Timestamp.class.equals( type ) ) { retval = getTimestamp( parameterIndex ); }
1:9a0cdf1:         else if ( Blob.class.equals( type ) ) { retval = getBlob( parameterIndex ); }
1:9a0cdf1:         else if ( Clob.class.equals( type ) ) { retval = getClob( parameterIndex ); }
1:9a0cdf1:         else if ( type.isArray() && type.getComponentType().equals( byte.class ) ) { retval = getBytes( parameterIndex ); }
1:9a0cdf1:         else { retval = getObject( parameterIndex ); }
1:9a0cdf1: 
1:9a0cdf1:         if ( wasNull() ) { retval = null; }
1:9a0cdf1: 
1:9a0cdf1:         if ( (retval == null) || (type.isInstance( retval )) ) { return type.cast( retval ); }
1:9a0cdf1: 
1:9a0cdf1:         throw mismatchException( type.getName(), parameterIndex );
1:9a0cdf1:     }
1:9a0cdf1:     private SQLException    mismatchException( String targetTypeName, int parameterIndex )
1:9a0cdf1:         throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         String sourceTypeName = getParameterMetaData().getParameterTypeName( parameterIndex );
1:9a0cdf1:         ClientMessageId cmi = new ClientMessageId( SQLState.LANG_DATA_TYPE_GET_MISMATCH );
1:9a0cdf1:         SqlException se = new SqlException( agent_.logWriter_, cmi, targetTypeName, sourceTypeName );
1:9a0cdf1: 
1:9a0cdf1:         return se.getSQLException();
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public <T> T getObject(String parameterName, Class<T> type)
1:9a0cdf1:         throws SQLException
1:9a0cdf1:     {
1:9a0cdf1:         throw jdbcMethodNotImplemented();
1:9a0cdf1:     }
1:9a0cdf1: 
1:35d620a:     //----------------------------overrides----------------------------------
1:35d620a: 
1:35d620a:     public void completeExecuteCall(Sqlca sqlca, Cursor singletonParams) // no result sets returned
1:35d620a:     {
1:35d620a:         super.completeExecuteCall( sqlca, singletonParams );
1:35d620a: 
3:35d620a:         //
1:35d620a:         // For INOUT parameters, propagate return values back to the input parameter array.
1:35d620a:         // See DERBY-2515.
1:35d620a:         //
1:35d620a: 
1:35d620a:         if ( singletonParams == null ) { return ; }
1:35d620a:         if ( parameterMetaData_ == null ) { return; }
1:35d620a: 
1:35d620a:         int     cursorParamCount = singletonParams.columns_;
1:932c26f:         
1:932c26f:         for ( int i = 0; i < cursorParamCount; i++ )
1:932c26f:         {
1:69e3d06:             if ( parameterMetaData_.sqlxParmmode_[ i ] ==
1:69e3d06:                  ClientParameterMetaData.parameterModeInOut )
1:35d620a:             {
1:932c26f:                 int jdbcParamNumber = i + 1;
1:932c26f:                 Object  returnArg;
1:932c26f:                 
1:932c26f:                 try {
1:932c26f:                     returnArg = singletonParams.isNull_[ i ] ? null : singletonParams.getObject( jdbcParamNumber );
1:932c26f:                 } catch (SqlException se)
1:932c26f:                 {
1:932c26f:                     IllegalArgumentException iae = new IllegalArgumentException( se.getMessage() );
1:932c26f:                     iae.initCause( se );
1:932c26f:                     throw iae;
1:932c26f:                 }
1:932c26f:                 
1:932c26f:                 //
1:932c26f:                 // special case to coerce Integer to Short for SMALLINT
1:932c26f:                 //
1:69e3d06:                 if ( parameterMetaData_.types_[ i ] == ClientTypes.SMALLINT )
1:932c26f:                 {
1:66527ec:                     if (returnArg instanceof Integer)
1:932c26f:                     {
1:66527ec:                         returnArg = ((Integer) returnArg).shortValue();
1:932c26f:                     }
1:932c26f:                 }
1:932c26f:                 
1:932c26f:                 setInput( jdbcParamNumber, returnArg );
1:932c26f:             }   // end if INOUT arg
1:932c26f:         }       // end loop through args
1:35d620a:     }
1:35d620a: 
1:35d620a:     
1:70f7692:     //----------------------------helper methods----------------------------------
1:70f7692: 
1:d8383bd:     /**
1:d8383bd:      * Returns the name of the java.sql interface implemented by this class.
1:d8383bd:      * @return name of java.sql interface
1:d8383bd:      */
1:d8383bd:     protected String getJdbcStatementInterfaceName() {
1:d8383bd:         return "java.sql.CallableStatement";
1:d8383bd:     }
1:d8383bd: 
1:70f7692:     private void checkGetterPreconditions(int parameterIndex) throws SqlException {
1:70f7692:         super.checkForValidParameterIndex(parameterIndex);
1:70f7692:         checkForValidOutParameter(parameterIndex);
1:35d620a:     }
1:70f7692: 
1:70f7692:     private void checkForValidOutParameter(int parameterIndex) throws SqlException {
1:69e3d06:         if (parameterMetaData_ == null ||
1:69e3d06:             parameterMetaData_.sqlxParmmode_[parameterIndex - 1] <
1:69e3d06:                 ClientParameterMetaData.parameterModeInOut) {
1:69e3d06: 
1:d506170:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.PARAM_NOT_OUT_OR_INOUT), 
1:66527ec:                 parameterIndex);
1:35d620a:         }
1:35d620a:     }
1:70f7692: 
1:70f7692:     private void setWasNull(int parameterIndex) {
1:70f7692:         if (singletonRowData_ == null) {
1:70f7692:             wasNull_ = WAS_NULL_UNSET;
1:70f7692:         } else {
1:70f7692:             wasNull_ = singletonRowData_.isNull_[parameterIndex - 1] ? WAS_NULL : WAS_NOT_NULL;
1:35d620a:         }
1:35d620a:     }
1:daecc5d:     
1:0326967:     SQLException jdbcMethodNotImplemented() throws SQLException
1:35d620a:     {
1:d506170:         try
1:35d620a:         {
76:70f7692:             super.checkForClosedStatement();
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:35d620a:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:daecc5d:         return new SqlException(agent_.logWriter_, 
1:e65b4db:             new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).getSQLException();
1:daecc5d:     }
1:70f7692: }
1:70f7692: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.NClob;
1: import java.sql.RowId;
1: import java.sql.SQLXML;
/////////////////////////////////////////////////////////////////////////
1:     public final void setAsciiStream(String parameterName, InputStream x, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setAsciiStream(String,InputStream,long)");
1:     }
1: 
1:     public final void setBinaryStream(String parameterName, InputStream x, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setBinaryStream(String,InputStream,long)");
1:     }
1: 
1:     public final void setCharacterStream(String parameterName, Reader x, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setCharacterStream(String,Reader,long)");
1:     }
1: 
1:     public Reader getCharacterStream(String parameterName)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getCharacterStream(String)");
1:     }
1: 
1:     public Reader getNCharacterStream(int parameterIndex)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getNCharacterStream(int)");
1:     }
1: 
1:     public Reader getNCharacterStream(String parameterName)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "getNCharacterStream(String)");
1:     }
1: 
1:     public String getNString(int parameterIndex)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getNString(int)");
1:     }
1: 
1:     public String getNString(String parameterIndex)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getNString(String)");
1:     }
1: 
1:     public RowId getRowId(int parameterIndex) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getRowId (int)");
1:     }
1: 
1:     public RowId getRowId(String parameterName) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getRowId (String)");
1:     }
1: 
1:     public void setRowId(String parameterName, RowId x) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setRowId (String, RowId)");
1:     }
1: 
1:     public void setBlob(String parameterName, Blob x)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setBlob(String, Blob)");
1:     }
1: 
1:     public void setClob(String parameterName, Clob x)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setClob(String, Clob)");
1:     }
1: 
1:     public void setNString(String parameterName, String value)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNString (String, String)");
1:     }
1: 
1:     public void setNCharacterStream(String parameterName, Reader value, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setNString (String, Reader, long)");
1:     }
1: 
1:     public void setNClob(String parameterName, NClob value) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob (String, NClob)");
1:     }
1: 
1:     public void setClob(String parameterName, Reader reader, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setClob (String, Reader, long)");
1:     }
1: 
1:     public void setBlob(String parameterName, InputStream inputStream, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setBlob (String, InputStream, long)");
1:     }
1: 
1:     public void setNClob(String parameterName, Reader reader, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob (String, Reader, long)");
1:     }
1: 
1:     public NClob getNClob(int i) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob (int)");
1:     }
1: 
1:     public NClob getNClob(String parameterName) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob (String)");
1:     }
1: 
1:     public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setSQLXML (String, SQLXML)");
1:     }
1: 
1:     public SQLXML getSQLXML(int parameterIndex) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getSQLXML (int)");
1:     }
1: 
1:     public SQLXML getSQLXML(String parametername) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("getSQLXML (String)");
1:     }
1:     public void setAsciiStream(String parameterName, InputStream x)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setAsciiStream(String,InputStream)");
1:     }
1: 
1:     public void setBinaryStream(String parameterName, InputStream x)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setBinaryStream(String,InputStream)");
1:     }
1: 
1:     public void setBlob(String parameterName, InputStream inputStream)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setBlob(String,InputStream)");
1:     }
1: 
1:     public void setCharacterStream(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setCharacterStream(String,Reader)");
1:     }
1: 
1:     public void setClob(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setClob(String,Reader)");
1:     }
1: 
1:     public void setNCharacterStream(String parameterName, Reader value)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setNCharacterStream(String,Reader)");
1:     }
1: 
1:     public void setNClob(String parameterName, Reader reader)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob(String,Reader)");
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     public <T> T getObject( int parameterIndex, Class<T> type )
1:         throws SQLException
1:     {
1:         // checkForClosedStatement() should be called by all of the
1:         // more specific methods to which we forward this call
1: 
1:         if ( type == null )
1:         {
1:             throw mismatchException( "NULL", parameterIndex );
1:         }
1: 
1:         Object   retval;
1: 
1:         if ( String.class.equals( type ) ) { retval = getString( parameterIndex ); }
1:         else if ( BigDecimal.class.equals( type ) ) { retval = getBigDecimal( parameterIndex ); }
1:         else if ( Boolean.class.equals( type ) ) { retval = Boolean.valueOf( getBoolean(parameterIndex ) ); }
1:         else if ( Byte.class.equals( type ) ) { retval = Byte.valueOf( getByte( parameterIndex ) ); }
1:         else if ( Short.class.equals( type ) ) { retval = Short.valueOf( getShort( parameterIndex ) ); }
1:         else if ( Integer.class.equals( type ) ) { retval = Integer.valueOf( getInt( parameterIndex ) ); }
1:         else if ( Long.class.equals( type ) ) { retval = Long.valueOf( getLong( parameterIndex ) ); }
1:         else if ( Float.class.equals( type ) ) { retval = Float.valueOf( getFloat( parameterIndex ) ); }
1:         else if ( Double.class.equals( type ) ) { retval = Double.valueOf( getDouble( parameterIndex ) ); }
1:         else if ( Date.class.equals( type ) ) { retval = getDate( parameterIndex ); }
1:         else if ( Time.class.equals( type ) ) { retval = getTime( parameterIndex ); }
1:         else if ( Timestamp.class.equals( type ) ) { retval = getTimestamp( parameterIndex ); }
1:         else if ( Blob.class.equals( type ) ) { retval = getBlob( parameterIndex ); }
1:         else if ( Clob.class.equals( type ) ) { retval = getClob( parameterIndex ); }
1:         else if ( type.isArray() && type.getComponentType().equals( byte.class ) ) { retval = getBytes( parameterIndex ); }
1:         else { retval = getObject( parameterIndex ); }
1: 
1:         if ( wasNull() ) { retval = null; }
1: 
1:         if ( (retval == null) || (type.isInstance( retval )) ) { return type.cast( retval ); }
1: 
1:         throw mismatchException( type.getName(), parameterIndex );
1:     }
1:     private SQLException    mismatchException( String targetTypeName, int parameterIndex )
1:         throws SQLException
1:     {
1:         String sourceTypeName = getParameterMetaData().getParameterTypeName( parameterIndex );
1:         ClientMessageId cmi = new ClientMessageId( SQLState.LANG_DATA_TYPE_GET_MISMATCH );
1:         SqlException se = new SqlException( agent_.logWriter_, cmi, targetTypeName, sourceTypeName );
1: 
1:         return se.getSQLException();
1:     }
1: 
1:     public <T> T getObject(String parameterName, Class<T> type)
1:         throws SQLException
1:     {
1:         throw jdbcMethodNotImplemented();
1:     }
1: 
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                     if (returnArg instanceof Integer)
1:                         returnArg = ((Integer) returnArg).shortValue();
/////////////////////////////////////////////////////////////////////////
1:                 parameterIndex);
commit:2349a90
/////////////////////////////////////////////////////////////////////////
0:     private int guessScaleForDecimalOrNumeric(int parameterIndex) {
commit:7d521f5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:     public Date getDate(int parameterIndex, Calendar cal) throws SQLException {
1:                     agent_.logWriter_.traceEntry(
1:                             this, "getDate", parameterIndex, cal);
1: 
1:                 if (cal == null) {
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:                 }
1: 
1:                 Date result = wasNullX() ?
1:                         null :
1:                         singletonRowData_.getDate(parameterIndex, cal);
/////////////////////////////////////////////////////////////////////////
1:     public Date getDate(int parameterIndex) throws SQLException {
1:         return getDate(parameterIndex, Calendar.getInstance());
1:     public Time getTime(int parameterIndex, Calendar cal) throws SQLException {
1:                     agent_.logWriter_.traceEntry(
1:                             this, "getTime", parameterIndex, cal);
1: 
1:                 if (cal == null) {
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:                 }
1: 
1:                 Time result = wasNullX() ?
1:                         null :
1:                         singletonRowData_.getTime(parameterIndex, cal);
/////////////////////////////////////////////////////////////////////////
1:     public Time getTime(int parameterIndex) throws SQLException {
1:         return getTime(parameterIndex, Calendar.getInstance());
1:     public Timestamp getTimestamp(int parameterIndex, Calendar cal)
1:             throws SQLException {
1:                     agent_.logWriter_.traceEntry(
1:                             this, "getTimestamp", parameterIndex, cal);
1: 
1:                 if (cal == null) {
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.CALENDAR_IS_NULL));
1:                 }
1: 
1:                 Timestamp result = wasNullX() ?
1:                         null :
1:                         singletonRowData_.getTimestamp(parameterIndex, cal);
/////////////////////////////////////////////////////////////////////////
1:     public Timestamp getTimestamp(int parameterIndex) throws SQLException {
1:         return getTimestamp(parameterIndex, Calendar.getInstance());
commit:e24d8ef
/////////////////////////////////////////////////////////////////////////
1:     /** @deprecated */
commit:960054b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:d8383bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the name of the java.sql interface implemented by this class.
1:      * @return name of java.sql interface
1:      */
1:     protected String getJdbcStatementInterfaceName() {
1:         return "java.sql.CallableStatement";
1:     }
1: 
commit:320777f
/////////////////////////////////////////////////////////////////////////
0:             java.sql.Date result = getDate(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:             java.sql.Time result = getTime(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:             java.sql.Timestamp result = getTimestamp(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         throw jdbcMethodNotImplemented();
commit:407e52d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.ClientPooledConnection;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Common constructor for jdbc 2 callable statements with scroll attributes.
1:      * Called by material statement constructor.
1:      *
1:      * @param agent       The instance of NetAgent associated with this
1:      *                    CallableStatement object.
1:      * @param connection  The connection object associated with this
1:      *                    PreparedStatement Object.
1:      * @param sql         A String object that is the SQL statement to be sent 
1:      *                    to the database.
1:      * @param type        One of the ResultSet type constants
1:      * @param concurrency One of the ResultSet concurrency constants
1:      * @param holdability One of the ResultSet holdability constants
1:      * @param cpc         The PooledConnection object that will be used to 
1:      *                    notify the PooledConnection reference of the Error 
1:      *                    Occurred and the Close events.
1:      * @throws SqlException
1:      */
1:                              int type, int concurrency, int holdability,
1:                              ClientPooledConnection cpc) throws SqlException {
0:         super(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, null,cpc);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     SQLException jdbcMethodNotImplemented() throws SQLException
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.math.BigDecimal;
1: import java.net.URL;
1: import java.sql.Array;
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.PreparedStatement;
1: import java.sql.Ref;
1: import java.util.Map;
1: public class ClientCallableStatement extends ClientPreparedStatement
1:     implements PreparedStatement, CallableStatement,
1:                PreparedStatementCallbackInterface {
/////////////////////////////////////////////////////////////////////////
1:     public ClientCallableStatement(Agent agent,
1:                              ClientConnection connection,
1:         super(agent,
1:               connection,
1:               sql,
1:               type,
1:               concurrency,
1:               holdability,
1:               ClientStatement.NO_GENERATED_KEYS,
1:               null,
1:               null,
1:               cpc);
1:                                        ClientConnection connection,
1:         super.resetPreparedStatement(
1:             agent,
1:             connection,
1:             sql,
1:             type,
1:             concurrency,
1:             holdability,
1:             ClientStatement.NO_GENERATED_KEYS,
1:             null,
1:             null);
1:                                        ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
0:                                        ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
1:     protected void finalize() throws Throwable {
/////////////////////////////////////////////////////////////////////////
1:     public BigDecimal getBigDecimal(int parameterIndex, int scale)
1:             throws SQLException, ArithmeticException {
/////////////////////////////////////////////////////////////////////////
1:                 BigDecimal result;
1:                     result = result.setScale(scale, BigDecimal.ROUND_DOWN);
/////////////////////////////////////////////////////////////////////////
1:     public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 BigDecimal result;
/////////////////////////////////////////////////////////////////////////
1:     public Blob getBlob(int parameterIndex) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 Blob result = wasNullX() ? null :
1:                     singletonRowData_.getBlob(parameterIndex);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Clob getClob(int parameterIndex) throws SQLException {
1:                 Clob result = wasNullX() ? null :
1:                     singletonRowData_.getClob(parameterIndex);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Array getArray(int parameterIndex) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 Array result = wasNullX() ? null :
1:                     singletonRowData_.getArray(parameterIndex);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Ref getRef(int parameterIndex) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 Ref result = wasNullX() ? null :
1:                     singletonRowData_.getRef(parameterIndex);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public Object getObject(int parameterIndex, Map map) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public URL getURL(int parameterIndex) throws SQLException {
1:     public void setURL(String parameterName, URL x) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void setBigDecimal(String parameterName, BigDecimal x)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void setDate(String parameterName, Date x) throws SQLException {
1:     public void setTime(String parameterName, Time x) throws SQLException {
1:     public void setTimestamp(String parameterName, Timestamp x)
1:             throws SQLException {
1:     public void setAsciiStream(String parameterName, InputStream x, int length)
1:             throws SQLException {
1:     public void setBinaryStream(String parameterName, InputStream x, int length)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void setCharacterStream(String parameterName,
1:                                    Reader reader,
1:                                    int length) throws SQLException {
1:     public void setDate(String parameterName, Date x, Calendar calendar)
1:             throws SQLException {
1:     public void setTime(String parameterName, Time x, Calendar calendar)
1:             throws SQLException {
1:     public void setTimestamp(String parameterName,
1:                              Timestamp x,
1:                              Calendar calendar) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public Date getDate(String parameterName) throws SQLException {
1:     public Time getTime(String parameterName) throws SQLException {
1:     public Timestamp getTimestamp(String parameterName) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public BigDecimal getBigDecimal(String parameterName) throws SQLException {
1:     public Object getObject(String parameterName, Map map) throws SQLException {
1:     public Ref getRef(String parameterName) throws SQLException {
1:     public Blob getBlob(String parameterName) throws SQLException {
1:     public Clob getClob(String parameterName) throws SQLException {
1:     public Array getArray(String parameterName) throws SQLException {
1:     public Date getDate(String parameterName, Calendar calendar)
1:             throws SQLException {
1:     public Time getTime(String parameterName, Calendar calendar)
1:             throws SQLException {
1:     public Timestamp getTimestamp(String parameterName, Calendar calendar)
1:             throws SQLException {
1:     public URL getURL(String parameterName) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:             if ( parameterMetaData_.sqlxParmmode_[ i ] ==
1:                  ClientParameterMetaData.parameterModeInOut )
/////////////////////////////////////////////////////////////////////////
1:                 if ( parameterMetaData_.types_[ i ] == ClientTypes.SMALLINT )
/////////////////////////////////////////////////////////////////////////
1:         if (parameterMetaData_ == null ||
1:             parameterMetaData_.sqlxParmmode_[parameterIndex - 1] <
1:                 ClientParameterMetaData.parameterModeInOut) {
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4c2fc4a
/////////////////////////////////////////////////////////////////////////
1:         agent_.checkForSupportedDataType( jdbcType );
commit:9206d5b
/////////////////////////////////////////////////////////////////////////
1:     /** Derby ignores the typeName argument because UDTs don't need it */
1:         registerOutParameter( parameterIndex, jdbcType );
commit:932c26f
/////////////////////////////////////////////////////////////////////////
1:         
1:         for ( int i = 0; i < cursorParamCount; i++ )
0:             if ( parameterMetaData_.sqlxParmmode_[ i ] == java.sql.ParameterMetaData.parameterModeInOut )
1:             {
1:                 int jdbcParamNumber = i + 1;
1:                 Object  returnArg;
1:                 
1:                 try {
1:                     returnArg = singletonParams.isNull_[ i ] ? null : singletonParams.getObject( jdbcParamNumber );
1:                 } catch (SqlException se)
1:                 {
1:                     IllegalArgumentException iae = new IllegalArgumentException( se.getMessage() );
1:                     iae.initCause( se );
1:                     throw iae;
1:                 }
1:                 
1:                 //
1:                 // special case to coerce Integer to Short for SMALLINT
1:                 //
0:                 if ( parameterMetaData_.types_[ i ] == Types.SMALLINT )
1:                 {
0:                     if ( (returnArg != null) && (returnArg instanceof Integer) )
1:                     {
0:                         returnArg = new Short( ((Integer) returnArg).shortValue() );
1:                     }
1:                 }
1:                 
1:                 setInput( jdbcParamNumber, returnArg );
1:             }   // end if INOUT arg
1:         }       // end loop through args
commit:35d620a
/////////////////////////////////////////////////////////////////////////
1: 
1:     //----------------------------overrides----------------------------------
1: 
1:     public void completeExecuteCall(Sqlca sqlca, Cursor singletonParams) // no result sets returned
1:     {
1:         super.completeExecuteCall( sqlca, singletonParams );
1: 
1:         //
1:         // For INOUT parameters, propagate return values back to the input parameter array.
1:         // See DERBY-2515.
1:         //
1: 
1:         if ( singletonParams == null ) { return ; }
1:         if ( parameterMetaData_ == null ) { return; }
1: 
1:         int     cursorParamCount = singletonParams.columns_;
1:         try {
0:             for ( int i = 0; i < cursorParamCount; i++ )
1:             {
0:                 if ( parameterMetaData_.sqlxParmmode_[ i ] == java.sql.ParameterMetaData.parameterModeInOut )
1:                 {
0:                     int jdbcParamNumber = i + 1;
0:                     Object  returnArg = singletonParams.isNull_[ i ] ? null : singletonParams.getObject( jdbcParamNumber );
1: 
1:                     //
0:                     // special case to coerce Integer to Short for SMALLINT
1:                     //
0:                     if ( parameterMetaData_.types_[ i ] == Types.SMALLINT )
1:                     {
0:                         if ( (returnArg != null) && (returnArg instanceof Integer) )
1:                         {
0:                             returnArg = new Short( ((Integer) returnArg).shortValue() );
1:                         }
1:                     }
1:                     
0:                     setInput( jdbcParamNumber, returnArg );
1:                 }
1:             }
0:         } catch (Exception se)
1:         {
0:             throw new IllegalArgumentException( se.getMessage() );
1:         }
1:     }
1: 
commit:04f8e95
/////////////////////////////////////////////////////////////////////////
0:     protected SQLException jdbcMethodNotImplemented() throws SQLException
commit:9c14132
/////////////////////////////////////////////////////////////////////////
1: import java.io.Reader;
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     //-------------------------- JDBC 4.0 methods --------------------------------
1:     
1:     public Reader getCharacterStream(int parameterIndex)
1:         throws SQLException {
0:         try {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getCharacterStream", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 Reader reader = null;
1:                 if (this.wasNull_ == WAS_NOT_NULL) {
1:                     reader = singletonRowData_.getCharacterStream(parameterIndex);
1:                 }
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getCharacterStream", reader);
1:                 }
1:                 return reader;
1:             }
1:              
1:         } catch (SqlException se) {
1:             throw se.getSQLException();
1:         }
1:     }
1:     
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
commit:6de69bd
/////////////////////////////////////////////////////////////////////////
1:                 long result = getLongX(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:     long getLongX(int parameterIndex) throws SqlException {
1:         super.checkForClosedStatement();
1:         checkGetterPreconditions(parameterIndex);
1:         setWasNull(parameterIndex);
1:         return wasNullX() ? 0 : singletonRowData_.getLong(parameterIndex);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 byte[] result = getBytesX(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:     byte[] getBytesX(final int parameterIndex) throws SqlException 
1:     {
1:         super.checkForClosedStatement();
1:         checkGetterPreconditions(parameterIndex);
1:         setWasNull(parameterIndex);
1:         return  wasNullX() ? null : singletonRowData_.getBytes(parameterIndex);
1:      }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b52081a
/////////////////////////////////////////////////////////////////////////
0:         super(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, 
0:                 null, null,cpc);
/////////////////////////////////////////////////////////////////////////
0:         super.resetPreparedStatement(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, 
0:                 null,null);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.WASNULL_INVALID));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));                    
1:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.RETURN_PARAM_MUST_BE_INT));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.PARAM_NOT_OUT_OR_INOUT), 
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).getSQLException();
commit:e4b2438
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                         new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
/////////////////////////////////////////////////////////////////////////
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
1:         throw jdbcMethodNotImplemented();
/////////////////////////////////////////////////////////////////////////
0:     private SQLException jdbcMethodNotImplemented() throws SQLException
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).getSQLException();
commit:d506170
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
0:     public boolean execute() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "execute");
1:                 }
0:                 boolean b = executeX();
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "execute", b);
1:                 }
0:                 return b;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.ResultSet executeQuery() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "executeQuery");
1:                 }
0:                 ResultSet resultSet = executeQueryX();
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "executeQuery", resultSet);
1:                 }
0:                 return resultSet;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public int executeUpdate() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "executeUpdate");
1:                 }
0:                 int updateValue = executeUpdateX();
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "executeUpdate", updateValue);
1:                 }
0:                 return updateValue;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void clearParameters() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void registerOutParameter(int parameterIndex, int jdbcType) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType);
1:                 }
1:                 registerOutParameterX(parameterIndex, jdbcType);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void registerOutParameter(int parameterIndex, int jdbcType, int scale) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, scale);
1:                 }
1:                 super.checkForClosedStatement();
1:                 registerOutParameterX(parameterIndex, jdbcType, scale);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void registerOutParameter(int parameterIndex, int jdbcType, String typeName) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, typeName);
1:                 }
1:                 super.checkForClosedStatement();
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public boolean wasNull() throws SQLException {
1:         try
1:         {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "wasNull");
1:             }
1:             boolean result = wasNullX();
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceExit(this, "wasNull", result);
1:             }
1:             return result;
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public boolean getBoolean(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBoolean", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 boolean result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = agent_.crossConverters_.getBooleanFromInt(returnValueFromProcedure_);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getBoolean", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? false : singletonRowData_.getBoolean(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public byte getByte(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getByte", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 byte result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = agent_.crossConverters_.getByteFromInt(returnValueFromProcedure_);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getByte", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? 0 : singletonRowData_.getByte(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public short getShort(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getShort", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 short result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = agent_.crossConverters_.getShortFromInt(returnValueFromProcedure_);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getShort", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? 0 : singletonRowData_.getShort(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public int getInt(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getInt", parameterIndex);
1:                 }
1:                 int result = getIntX(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getInt", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public long getLong(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getLong", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 long result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = (long) returnValueFromProcedure_;
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getLong", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 result = wasNullX() ? 0 : singletonRowData_.getLong(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public float getFloat(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getFloat", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 float result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = (float) returnValueFromProcedure_;
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getFloat", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? 0 : singletonRowData_.getFloat(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public double getDouble(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getDouble", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 double result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = (double) returnValueFromProcedure_;
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getDouble", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? 0 : singletonRowData_.getDouble(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.math.BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException, ArithmeticException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceDeprecatedEntry(this, "getBigDecimal", parameterIndex, scale);
1:                 }
1:                 super.checkForClosedStatement();
1:                 checkForValidScale(scale);
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 java.math.BigDecimal result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = java.math.BigDecimal.valueOf(returnValueFromProcedure_).setScale(scale);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceDeprecatedExit(this, "getBigDecimal", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
1:                 if (result != null) {
0:                     result = result.setScale(scale, java.math.BigDecimal.ROUND_DOWN);
1:                 }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.math.BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 java.math.BigDecimal result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = java.math.BigDecimal.valueOf(returnValueFromProcedure_);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getBigDecimal", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Date getDate(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "getDate", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Date result = wasNullX() ? null : singletonRowData_.getDate(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getDate", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Date getDate(int parameterIndex, java.util.Calendar cal) throws SQLException {
0:                     new MessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.Time getTime(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "getTime", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Time result = wasNullX() ? null : singletonRowData_.getTime(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getTime", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Time getTime(int parameterIndex, java.util.Calendar cal) throws SQLException {
0:                     new MessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "getTimestamp", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Timestamp result = wasNullX() ? null : singletonRowData_.getTimestamp(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getTimestamp", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Timestamp getTimestamp(int parameterIndex, java.util.Calendar cal) throws SQLException {
0:                     new MessageId(SQLState.CALENDAR_IS_NULL)).getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public String getString(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getString", parameterIndex);
1:                 }
1:                 String result = getStringX(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getString", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public byte[] getBytes(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBytes", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 byte[] result = wasNullX() ? null : singletonRowData_.getBytes(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getBytes", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Blob getBlob(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getBlob", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Blob result = wasNullX() ? null : singletonRowData_.getBlob(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getBlob", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Clob getClob(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Clob result = wasNullX() ? null : singletonRowData_.getClob(parameterIndex);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getClob", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Array getArray(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getArray", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));                    
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Array result = wasNullX() ? null : singletonRowData_.getArray(parameterIndex);
1:                 if (true) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
1:                 }
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getArray", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public java.sql.Ref getRef(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getRef", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
0:                 java.sql.Ref result = wasNullX() ? null : singletonRowData_.getRef(parameterIndex);
1:                 if (true) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
1:                 }
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getRef", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public Object getObject(int parameterIndex) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 Object result;
0:                 if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                     result = new Integer(returnValueFromProcedure_);
0:                     this.wasNull_ = this.WAS_NOT_NULL;
1:                     if (agent_.loggingEnabled()) {
1:                         agent_.logWriter_.traceExit(this, "getObject", result);
1:                     }
1:                     return result;
1:                 }
1:                 checkGetterPreconditions(parameterIndex);
1:                 setWasNull(parameterIndex);
1:                 result = wasNullX() ? null : singletonRowData_.getObject(parameterIndex);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public Object getObject(int parameterIndex, java.util.Map map) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getObject", parameterIndex, map);
1:                 }
1:                 super.checkForClosedStatement();
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:                 Object result;
1:                 checkGetterPreconditions(parameterIndex);
1:                 if (true) {
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
1:                 }
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getObject", result);
1:                 }
1:                 return result;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void registerOutParameter(String parameterName, int sqlType) throws SQLException {
1:     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {
1:     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {
0:     public java.net.URL getURL(int parameterIndex) throws SQLException {
0:     public void setURL(String parameterName, java.net.URL x) throws SQLException {
1:     public void setNull(String parameterName, int sqlType) throws SQLException {
1:     public void setBoolean(String parameterName, boolean x) throws SQLException {
1:     public void setByte(String parameterName, byte x) throws SQLException {
1:     public void setShort(String parameterName, short x) throws SQLException {
1:     public void setInt(String parameterName, int x) throws SQLException {
1:     public void setLong(String parameterName, long x) throws SQLException {
1:     public void setFloat(String parameterName, float x) throws SQLException {
1:     public void setDouble(String parameterName, double x) throws SQLException {
0:     public void setBigDecimal(String parameterName, java.math.BigDecimal x) throws SQLException {
1:     public void setString(String parameterName, String x) throws SQLException {
1:     public void setBytes(String parameterName, byte x[]) throws SQLException {
0:     public void setDate(String parameterName, java.sql.Date x) throws SQLException {
0:     public void setTime(String parameterName, java.sql.Time x) throws SQLException {
0:     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {
0:     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
0:     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
1:     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {
1:     public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {
1:     public void setObject(String parameterName, Object x) throws SQLException {
0:     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {
0:     public void setDate(String parameterName, java.sql.Date x, java.util.Calendar calendar) throws SQLException {
0:     public void setTime(String parameterName, java.sql.Time x, java.util.Calendar calendar) throws SQLException {
0:     public void setTimestamp(String parameterName, java.sql.Timestamp x, java.util.Calendar calendar) throws SQLException {
1:     public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
1:     public String getString(String parameterName) throws SQLException {
1:     public boolean getBoolean(String parameterName) throws SQLException {
1:     public byte getByte(String parameterName) throws SQLException {
1:     public short getShort(String parameterName) throws SQLException {
1:     public int getInt(String parameterName) throws SQLException {
1:     public long getLong(String parameterName) throws SQLException {
1:     public float getFloat(String parameterName) throws SQLException {
1:     public double getDouble(String parameterName) throws SQLException {
1:     public byte[] getBytes(String parameterName) throws SQLException {
0:     public java.sql.Date getDate(String parameterName) throws SQLException {
0:     public java.sql.Time getTime(String parameterName) throws SQLException {
0:     public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {
1:     public Object getObject(String parameterName) throws SQLException {
0:     public java.math.BigDecimal getBigDecimal(String parameterName) throws SQLException {
0:     public Object getObject(String parameterName, java.util.Map map) throws SQLException {
1:             }
0:     public java.sql.Ref getRef(String parameterName) throws SQLException {
0:     public java.sql.Blob getBlob(String parameterName) throws SQLException {
0:     public java.sql.Clob getClob(String parameterName) throws SQLException {
0:     public java.sql.Array getArray(String parameterName) throws SQLException {
0:     public java.sql.Date getDate(String parameterName, java.util.Calendar calendar) throws SQLException {
0:     public java.sql.Time getTime(String parameterName, java.util.Calendar calendar) throws SQLException {
0:     public java.sql.Timestamp getTimestamp(String parameterName, java.util.Calendar calendar) throws SQLException {
0:     public java.net.URL getURL(String parameterName) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     private SQLException jdbc3MethodNotSupported() throws SQLException
0:         try
0:         {
1:             super.checkForClosedStatement();
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
1:         }
0:             new MessageId(SQLState.JDBC3_METHOD_NOT_SUPPORTED)).getSQLException();
commit:daecc5d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.WASNULL_INVALID));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.CALENDAR_IS_NULL));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.CALENDAR_IS_NULL));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.CALENDAR_IS_NULL));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));                    
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.INVALID_PARAM_USE_GETINT));
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.JDBC2_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:         throw jdbc3MethodNotSupported();
/////////////////////////////////////////////////////////////////////////
0:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.RETURN_PARAM_MUST_BE_INT));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.PARAM_NOT_OUT_OR_INOUT), 
0:                 new Integer(parameterIndex));
/////////////////////////////////////////////////////////////////////////
1:     
0:     private SqlException jdbc3MethodNotSupported()
0:     {
1:         return new SqlException(agent_.logWriter_, 
0:             new MessageId(SQLState.JDBC3_METHOD_NOT_SUPPORTED));
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b94443f
/////////////////////////////////////////////////////////////////////////
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, typeName);
0:         throw jdbcMethodNotImplemented();
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: 
0:         implements java.sql.PreparedStatement,
0:         java.sql.CallableStatement,
0:         PreparedStatementCallbackInterface {
1:     //---------------------navigational members-----------------------------------
1:     //---------------------navigational cheat-links-------------------------------
1:     // Cheat-links are for convenience only, and are not part of the conceptual model.
1:     // Warning:
1:     //   Cheat-links should only be defined for invariant state data.
1:     //   That is, the state data is set by the constructor and never changes.
1:     public MaterialPreparedStatement materialCallableStatement_ = null;
1:     //-----------------------------state------------------------------------------
1:     // last retrieved result was a sql NULL, NOT_NULL, or UNSET.
1:     private int wasNull_ = WAS_NULL_UNSET;
1:     static final private int WAS_NULL = 1;
1:     static final private int WAS_NOT_NULL = 2;
1:     static final private int WAS_NULL_UNSET = 0;
1:     //---------------------constructors/finalizer---------------------------------
1:     private void initCallableStatement() {
1:         materialCallableStatement_ = null;
1:         wasNull_ = WAS_NULL_UNSET;
1:     public void reset(boolean fullReset) throws SqlException {
1:         if (fullReset) {
1:             connection_.resetPrepareCall(this);
1:         } else {
1:             super.reset(fullReset);
1:         }
1:         wasNull_ = WAS_NULL_UNSET;
0:     // Common constructor for jdbc 2 callable statements with scroll attributes.
0:     // Called by material statement constructor.
0:     public CallableStatement(Agent agent,
0:                              Connection connection,
1:                              String sql,
1:                              int type, int concurrency, int holdability) throws SqlException {
0:         super(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, null);
1:         initCallableStatement();
1:     public void resetCallableStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
1:                                        int type, int concurrency, int holdability) throws SqlException {
0:         super.resetPreparedStatement(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, null);
1:         initCallableStatement();
1:     public void resetCallableStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
0:                                        Section section) throws SqlException {
0:         super.resetPreparedStatement(agent, connection, sql, section);
1:         initCallableStatement();
1:     }
1:     public void resetCallableStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
0:                                        Section section,
0:                                        ColumnMetaData parameterMetaData,
0:                                        ColumnMetaData resultSetMetaData) throws SqlException {
0:         super.resetPreparedStatement(agent, connection, sql, section, parameterMetaData, resultSetMetaData);
1:         initCallableStatement();
1:     }
0:     protected void finalize() throws java.lang.Throwable {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "finalize");
1:         }
1:         super.finalize();
1:     }
1: 
1:     //---------------------------entry points-------------------------------------
1: 
0:     public boolean execute() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "execute");
1:             }
0:             boolean b = executeX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "execute", b);
1:             }
0:             return b;
1:         }
1:     }
1: 
1:     // also used by SQLCA
0:     boolean executeX() throws SqlException {
0:         super.flowExecute(executeMethod__);
0:         return resultSet_ != null;
1:     }
1: 
0:     public java.sql.ResultSet executeQuery() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "executeQuery");
1:             }
0:             ResultSet resultSet = executeQueryX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "executeQuery", resultSet);
1:             }
0:             return resultSet;
1:         }
1:     }
1: 
0:     // also used by DBMD methods
0:     ResultSet executeQueryX() throws SqlException {
0:         super.flowExecute(executeQueryMethod__);
0:         super.checkExecuteQueryPostConditions("java.sql.CallableStatement");
0:         return resultSet_;
1:     }
1: 
0:     public int executeUpdate() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "executeUpdate");
1:             }
0:             int updateValue = executeUpdateX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "executeUpdate", updateValue);
1:             }
0:             return updateValue;
1:         }
1:     }
1: 
0:     int executeUpdateX() throws SqlException {
0:         super.flowExecute(executeUpdateMethod__);
1: 
0:         super.checkExecuteUpdatePostConditions("java.sql.CallableStatement");
0:         // make sure update count >= 0 even if derby don't support update count for call
0:         //return (updateCount_ < 0) ? 0 : updateCount_;
0:         return updateCount_;
1:     }
1: 
1: 
0:     public void clearParameters() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "clearParameters");
1:             }
1:             super.clearParameters();
1:             outputRegistered_ = false; // this variable is only used by Batch
1:         }
1:     }
1: 
0:     public void registerOutParameter(int parameterIndex, int jdbcType) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType);
1:             }
0:             registerOutParameterX(parameterIndex, jdbcType);
1:         }
1:     }
1: 
1:     // also used by Sqlca
1:     void registerOutParameterX(int parameterIndex, int jdbcType) throws SqlException {
1:         super.checkForClosedStatement();
1:         int scale = 0; // default scale to 0 for non numeric and non decimal type
1:         registerOutParameterX(parameterIndex, jdbcType, scale);
1:     }
1: 
0:     private int guessScaleForDecimalOrNumeric(int parameterIndex) throws SqlException {
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:         // Types.DECIMAL with no supplied scale will use the scale supplied by the setter method if input BigDecimal is not null
0:         if (parameterMetaData_.types_[parameterIndex - 1] == Types.DECIMAL &&
0:                 parameters_[parameterIndex - 1] != null) {
0:             return parameterMetaData_.sqlScale_[parameterIndex - 1];
1:         }
0:         return 8; // default to scale of 8 if not specified
1:     }
1: 
0:     public void registerOutParameter(int parameterIndex, int jdbcType, int scale) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, scale);
1:             }
1:             super.checkForClosedStatement();
1:             registerOutParameterX(parameterIndex, jdbcType, scale);
1:         }
1:     }
1: 
1:     private void registerOutParameterX(int parameterIndex, int jdbcType, int scale) throws SqlException {
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex, jdbcType);
0:         // if the parameter is the return clause of the call statement
0:         if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:             return;
1:         }
1:         super.checkForValidParameterIndex(parameterIndex);
1:         checkForValidScale(scale);
1:         outputRegistered_ = true; // this variable is only used by Batch
1:         //parameterSetOrRegistered_[parameterIndex - 1] = true;
1:         parameterRegistered_[parameterIndex - 1] = true;
1:     }
1: 
0:     public void registerOutParameter(int parameterIndex, int jdbcType, String typeName) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterIndex, jdbcType, typeName);
1:             }
1:             super.checkForClosedStatement();
1:         }
1:     }
1: 
0:     public boolean wasNull() throws SqlException {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "wasNull");
1:         }
0:         boolean result = wasNullX();
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceExit(this, "wasNull", result);
1:         }
1:     private boolean wasNullX() throws SqlException {
1:         super.checkForClosedStatement();
1:         if (wasNull_ == WAS_NULL_UNSET) {
0:             throw new SqlException(agent_.logWriter_, "Invalid operation: wasNull() called with no data retrieved.");
1:         }
1:         return wasNull_ == WAS_NULL;
1:     //--------------------------------getter methods------------------------------
1: 
0:     public boolean getBoolean(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBoolean", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             boolean result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = agent_.crossConverters_.getBooleanFromInt(returnValueFromProcedure_);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getBoolean", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? false : singletonRowData_.getBoolean(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBoolean", result);
1:             }
0:             return result;
1:         }
0:     public byte getByte(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getByte", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             byte result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = agent_.crossConverters_.getByteFromInt(returnValueFromProcedure_);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getByte", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? 0 : singletonRowData_.getByte(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getByte", result);
1:             }
0:             return result;
1:         }
0:     public short getShort(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getShort", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             short result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = agent_.crossConverters_.getShortFromInt(returnValueFromProcedure_);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getShort", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? 0 : singletonRowData_.getShort(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getShort", result);
1:             }
0:             return result;
1:         }
0:     public int getInt(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getInt", parameterIndex);
1:             }
0:             int result = getIntX(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getInt", result);
1:             }
0:             return result;
1:         }
1:     // also used by SQLCA
1:     int getIntX(int parameterIndex) throws SqlException {
1:         super.checkForClosedStatement();
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:         if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:             this.wasNull_ = this.WAS_NOT_NULL;
0:             return returnValueFromProcedure_;
1:         }
0:         checkGetterPreconditions(parameterIndex);
0:         setWasNull(parameterIndex);
1:         return wasNullX() ? 0 : singletonRowData_.getInt(parameterIndex);
0:     public long getLong(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getLong", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             long result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = (long) returnValueFromProcedure_;
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getLong", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? 0 : singletonRowData_.getLong(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getLong", result);
1:             }
0:             return result;
1:         }
0:     public float getFloat(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getFloat", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             float result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = (float) returnValueFromProcedure_;
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getFloat", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? 0 : singletonRowData_.getFloat(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getFloat", result);
1:             }
0:             return result;
1:         }
0:     public double getDouble(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getDouble", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             double result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = (double) returnValueFromProcedure_;
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getDouble", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? 0 : singletonRowData_.getDouble(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getDouble", result);
1:             }
0:             return result;
1:         }
0:     public java.math.BigDecimal getBigDecimal(int parameterIndex, int scale) throws SqlException, ArithmeticException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceDeprecatedEntry(this, "getBigDecimal", parameterIndex, scale);
1:             }
1:             super.checkForClosedStatement();
1:             checkForValidScale(scale);
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             java.math.BigDecimal result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = java.math.BigDecimal.valueOf(returnValueFromProcedure_).setScale(scale);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceDeprecatedExit(this, "getBigDecimal", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
0:             if (result != null) {
0:                 result = result.setScale(scale, java.math.BigDecimal.ROUND_DOWN);
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceDeprecatedExit(this, "getBigDecimal", result);
1:             }
0:             return result;
1:         }
0:     public java.math.BigDecimal getBigDecimal(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             java.math.BigDecimal result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = java.math.BigDecimal.valueOf(returnValueFromProcedure_);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getBigDecimal", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? null : singletonRowData_.getBigDecimal(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBigDecimal", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Date getDate(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getDate", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Date result = wasNullX() ? null : singletonRowData_.getDate(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getDate", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Date getDate(int parameterIndex, java.util.Calendar cal) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getDate", parameterIndex, cal);
1:             }
0:             if (cal == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.sql.Date result = getDate(parameterIndex);
0:             if (result != null) {
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(result);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(result);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 result.setTime(result.getTime() - timeZoneOffset);
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getDate", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Time getTime(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTime", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Time result = wasNullX() ? null : singletonRowData_.getTime(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getTime", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Time getTime(int parameterIndex, java.util.Calendar cal) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTime", parameterIndex, cal);
1:             }
0:             if (cal == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.sql.Time result = getTime(parameterIndex);
0:             if (result != null) {
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(result);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(result);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 result.setTime(result.getTime() - timeZoneOffset);
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getTime", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Timestamp getTimestamp(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTimestamp", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Timestamp result = wasNullX() ? null : singletonRowData_.getTimestamp(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getTimestamp", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Timestamp getTimestamp(int parameterIndex, java.util.Calendar cal) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getTimestamp", parameterIndex, cal);
1:             }
0:             if (cal == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.sql.Timestamp result = getTimestamp(parameterIndex);
0:             if (result != null) {
0:                 int nano = result.getNanos();
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(result);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(result);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 result.setTime(result.getTime() - timeZoneOffset);
0:                 result.setNanos(nano);
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getTimestamp", result);
1:             }
0:             return result;
1:         }
0:     public String getString(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getString", parameterIndex);
1:             }
0:             String result = getStringX(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getString", result);
1:             }
0:             return result;
1:         }
1:     // also used by SQLCA
1:     String getStringX(int parameterIndex) throws SqlException {
1:         super.checkForClosedStatement();
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:         if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:             this.wasNull_ = this.WAS_NOT_NULL;
0:             return Integer.toString(returnValueFromProcedure_);
1:         }
0:         checkGetterPreconditions(parameterIndex);
0:         setWasNull(parameterIndex);
1:         return wasNullX() ? null : singletonRowData_.getString(parameterIndex);
0:     public byte[] getBytes(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBytes", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             byte[] result = wasNullX() ? null : singletonRowData_.getBytes(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBytes", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Blob getBlob(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getBlob", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Blob result = wasNullX() ? null : singletonRowData_.getBlob(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getBlob", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Clob getClob(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getClob", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Clob result = wasNullX() ? null : singletonRowData_.getClob(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getClob", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Array getArray(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getArray", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Array result = wasNullX() ? null : singletonRowData_.getArray(parameterIndex);
0:             if (true) {
0:                 throw new SqlException(agent_.logWriter_, "jdbc 2 method is not yet implemented");
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getArray", result);
1:             }
0:             return result;
1:         }
0:     public java.sql.Ref getRef(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getRef", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             java.sql.Ref result = wasNullX() ? null : singletonRowData_.getRef(parameterIndex);
0:             if (true) {
0:                 throw new SqlException(agent_.logWriter_, "jdbc 2 method is not yet implemented");
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getRef", result);
1:             }
0:             return result;
1:         }
1:     }
0:     public Object getObject(int parameterIndex) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getObject", parameterIndex);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             Object result;
0:             if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:                 result = new Integer(returnValueFromProcedure_);
0:                 this.wasNull_ = this.WAS_NOT_NULL;
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceExit(this, "getObject", result);
1:                 }
0:                 return result;
1:             }
0:             checkGetterPreconditions(parameterIndex);
0:             setWasNull(parameterIndex);
0:             result = wasNullX() ? null : singletonRowData_.getObject(parameterIndex);
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getObject", result);
1:             }
0:             return result;
1:         }
1:     }
0:     public Object getObject(int parameterIndex, java.util.Map map) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getObject", parameterIndex, map);
1:             }
1:             super.checkForClosedStatement();
0:             parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:             Object result;
0:             checkGetterPreconditions(parameterIndex);
0:             if (true) {
0:                 throw new SqlException(agent_.logWriter_, "jdbc 2 method is not yet implemented.");
1:             }
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getObject", result);
1:             }
0:             return result;
1:         }
1:     }
1: 
1:     //--------------------------JDBC 3.0------------------------------------------
1: 
0:     public void registerOutParameter(String parameterName, int sqlType) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void registerOutParameter(String parameterName, int sqlType, int scale) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, scale);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "registerOutParameter", parameterName, sqlType, typeName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.net.URL getURL(int parameterIndex) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getURL", parameterIndex);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setURL(String parameterName, java.net.URL x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setURL", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setNull(String parameterName, int sqlType) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setBoolean(String parameterName, boolean x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setBoolean", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setByte(String parameterName, byte x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setByte", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setShort(String parameterName, short x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setShort", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setInt(String parameterName, int x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setInt", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setLong(String parameterName, long x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setLong", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setFloat(String parameterName, float x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setFloat", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setDouble(String parameterName, double x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setDouble", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setBigDecimal(String parameterName, java.math.BigDecimal x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setString(String parameterName, String x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setString", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setBytes(String parameterName, byte x[]) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setBytes", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setDate(String parameterName, java.sql.Date x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setTime(String parameterName, java.sql.Time x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterName, x, length);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterName, x, length);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType, scale);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setObject(String parameterName, Object x, int targetSqlType) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x, targetSqlType);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setObject(String parameterName, Object x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setObject", parameterName, x);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterName, reader, length);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setDate(String parameterName, java.sql.Date x, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setDate", parameterName, x, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setTime(String parameterName, java.sql.Time x, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setTime", parameterName, x, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setTimestamp(String parameterName, java.sql.Timestamp x, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setTimestamp", parameterName, x, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public void setNull(String parameterName, int sqlType, String typeName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setNull", parameterName, sqlType, typeName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public String getString(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getString", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public boolean getBoolean(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getBoolean", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public byte getByte(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getByte", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public short getShort(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getShort", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public int getInt(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getInt", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public long getLong(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getLong", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public float getFloat(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getFloat", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public double getDouble(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getDouble", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public byte[] getBytes(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getBytes", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Date getDate(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getDate", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Time getTime(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getTime", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Timestamp getTimestamp(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public Object getObject(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getObject", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.math.BigDecimal getBigDecimal(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getBigDecimal", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public Object getObject(String parameterName, java.util.Map map) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getObject", parameterName, map);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Ref getRef(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getRef", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Blob getBlob(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getBlob", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Clob getClob(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getClob", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Array getArray(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getArray", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Date getDate(String parameterName, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getDate", parameterName, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Time getTime(String parameterName, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getTime", parameterName, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.Timestamp getTimestamp(String parameterName, java.util.Calendar calendar) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getTimestamp", parameterName, calendar);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.net.URL getURL(String parameterName) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "getURL", parameterName);
1:         }
1:         super.checkForClosedStatement();
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
1:     //----------------------------helper methods----------------------------------
1: 
0:     private int checkForEscapedCallWithResult(int parameterIndex) throws SqlException {
0:         if (escapedProcedureCallWithResult_) {
0:             parameterIndex--;
1:         }
0:         return parameterIndex;
1:     }
1: 
0:     private int checkForEscapedCallWithResult(int parameterIndex, int jdbcType) throws SqlException {
0:         if (escapedProcedureCallWithResult_) {
0:             if (parameterIndex == 1 && jdbcType != java.sql.Types.INTEGER) {
0:                 throw new SqlException(agent_.logWriter_, "Parameter 1 is the return caluse of the stored procedure call, it can only be registered as an integer type");
1:             } else {
0:                 parameterIndex--;
1:             }
1:         }
0:         return parameterIndex;
1:     }
1: 
1:     private void checkGetterPreconditions(int parameterIndex) throws SqlException {
1:         super.checkForValidParameterIndex(parameterIndex);
1:         checkForValidOutParameter(parameterIndex);
1:     }
1: 
1:     private void checkForValidOutParameter(int parameterIndex) throws SqlException {
0:         if (parameterMetaData_ == null || parameterMetaData_.sqlxParmmode_[parameterIndex - 1] < java.sql.ParameterMetaData.parameterModeInOut) {
0:             throw new SqlException(agent_.logWriter_, "Invalid argument: parameter index " + parameterIndex +
0:                     " is not an OUT or INOUT parameter.");
1:         }
1:     }
1: 
1:     private void setWasNull(int parameterIndex) {
1:         if (singletonRowData_ == null) {
1:             wasNull_ = WAS_NULL_UNSET;
1:         } else {
1:             wasNull_ = singletonRowData_.isNull_[parameterIndex - 1] ? WAS_NULL : WAS_NOT_NULL;
1:         }
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.CallableStatement
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
0: import org.apache.derby.client.am.Section;
1: 
0: public class CallableStatement extends PreparedStatement
0:                                implements java.sql.PreparedStatement,
0: 					  java.sql.CallableStatement,
0:                                           PreparedStatementCallbackInterface
0: {
0:   //---------------------navigational members-----------------------------------
1: 
0:   //---------------------navigational cheat-links-------------------------------
0:   // Cheat-links are for convenience only, and are not part of the conceptual model.
0:   // Warning:
0:   //   Cheat-links should only be defined for invariant state data.
0:   //   That is, the state data is set by the constructor and never changes.
1: 
0:   public MaterialPreparedStatement materialCallableStatement_ = null;
1: 
0:   //-----------------------------state------------------------------------------
1: 
0:   // last retrieved result was a sql NULL, NOT_NULL, or UNSET.
0:   private int wasNull_ = WAS_NULL_UNSET;
0:   static final private int WAS_NULL = 1;
0:   static final private int WAS_NOT_NULL = 2;
0:   static final private int WAS_NULL_UNSET = 0;
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   private void initCallableStatement ()
0:   {
0:     materialCallableStatement_ = null;
0:     wasNull_ = WAS_NULL_UNSET;
0:   }
1: 
0:   public void reset (boolean fullReset) throws SqlException
0:   {
0:     if (fullReset)
0:       connection_.resetPrepareCall (this);
0:     else
0:      super.reset (fullReset);
0:     wasNull_ = WAS_NULL_UNSET;
0:   }
1: 
0:   // Common constructor for jdbc 2 callable statements with scroll attributes.
0:   // Called by material statement constructor.
0:   public CallableStatement (Agent agent,
0:                             Connection connection,
0:                             String sql,
0:                             int type, int concurrency, int holdability) throws SqlException
0:   {
0:     super (agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, null);
0:     initCallableStatement();
0:   }
1: 
0:   public void resetCallableStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       int type, int concurrency, int holdability) throws SqlException
0:   {
0:     super.resetPreparedStatement(agent, connection, sql, type, concurrency, holdability, java.sql.Statement.NO_GENERATED_KEYS, null);
0:     initCallableStatement();
0:   }
1: 
0:   public void resetCallableStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       Section section) throws SqlException
0:   {
0:     super.resetPreparedStatement(agent, connection, sql, section);
0:     initCallableStatement();
0:   }
1: 
1: 
0:   public void resetCallableStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       Section section,
0:                                       ColumnMetaData parameterMetaData,
0:                                       ColumnMetaData resultSetMetaData) throws SqlException
0:   {
0:     super.resetPreparedStatement(agent, connection, sql, section, parameterMetaData, resultSetMetaData);
0:     initCallableStatement();
0:   }
1: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "finalize");
0:     super.finalize();
0:   }
1: 
0:   //---------------------------entry points-------------------------------------
1: 
0:   public boolean execute () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute");
0:       boolean b = executeX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "execute", b);
0:       return b;
0:     }
0:   }
1: 
0:   // also used by SQLCA
0:   boolean executeX () throws SqlException
0:   {
0:     super.flowExecute (executeMethod__);
0:     return resultSet_ != null;
0:   }
1: 
0:   public java.sql.ResultSet executeQuery () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeQuery");
0:       ResultSet resultSet = executeQueryX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "executeQuery", resultSet);
0:       return resultSet;
0:     }
0:   }
1: 
0:   // also used by DBMD methods
0:   ResultSet executeQueryX () throws SqlException
0:   {
0:     super.flowExecute (executeQueryMethod__);
0:     super.checkExecuteQueryPostConditions ("java.sql.CallableStatement");
0:     return resultSet_;
0:   }
1: 
0:   public int executeUpdate () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate");
0:       int updateValue = executeUpdateX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "executeUpdate", updateValue);
0:       return updateValue;
0:     }
0:   }
1: 
0:   int executeUpdateX () throws SqlException
0:   {
0:     super.flowExecute (executeUpdateMethod__);
1: 
0:     super.checkExecuteUpdatePostConditions ("java.sql.CallableStatement");
0:     // make sure update count >= 0 even if derby don't support update count for call
0:     //return (updateCount_ < 0) ? 0 : updateCount_;
0:     return updateCount_;
0:   }
1: 
1: 
0:   public void clearParameters () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "clearParameters");
0:       super.clearParameters();
0:       outputRegistered_ = false; // this variable is only used by Batch
0:     }
0:   }
1: 
0:   public void registerOutParameter (int parameterIndex, int jdbcType) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterIndex, jdbcType);
0:       registerOutParameterX (parameterIndex, jdbcType);
0:     }
0:   }
1: 
0:   // also used by Sqlca
0:   void registerOutParameterX (int parameterIndex, int jdbcType) throws SqlException
0:   {
0:       super.checkForClosedStatement();
0:       int scale = 0; // default scale to 0 for non numeric and non decimal type
0:       registerOutParameterX (parameterIndex, jdbcType, scale);
0:     }
1: 
0:   private int guessScaleForDecimalOrNumeric (int parameterIndex) throws SqlException
0:   {
0:     parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:     // Types.DECIMAL with no supplied scale will use the scale supplied by the setter method if input BigDecimal is not null
0:     if (parameterMetaData_.types_[parameterIndex - 1] == Types.DECIMAL &&
0:         parameters_[parameterIndex - 1] != null) {
0:       return parameterMetaData_.sqlScale_[parameterIndex - 1];
0:     }
0:     return 8; // default to scale of 8 if not specified
0:   }
1: 
0:   public void registerOutParameter (int parameterIndex, int jdbcType, int scale) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterIndex, jdbcType, scale);
0:       super.checkForClosedStatement();
0:       registerOutParameterX (parameterIndex, jdbcType, scale);
0:     }
0:   }
1: 
0:   private void registerOutParameterX (int parameterIndex, int jdbcType, int scale) throws SqlException
0:   {
0:     parameterIndex = checkForEscapedCallWithResult (parameterIndex, jdbcType);
0:     // if the parameter is the return clause of the call statement
0:     if (parameterIndex == 0 && escapedProcedureCallWithResult_) return;
0:     super.checkForValidParameterIndex (parameterIndex);
0:     checkForValidScale (scale);
0:     outputRegistered_ = true; // this variable is only used by Batch
0:     //parameterSetOrRegistered_[parameterIndex - 1] = true;
0:     parameterRegistered_[parameterIndex - 1] = true;
0:   }
1: 
0:   public void registerOutParameter  (int parameterIndex, int jdbcType, String typeName) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterIndex, jdbcType, typeName);
0:       super.checkForClosedStatement();
0:     }
0:   }
1: 
0:   public boolean wasNull () throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "wasNull");
0:     boolean result = wasNullX();
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "wasNull", result);
0:     return result;
0:   }
1: 
0:   private boolean wasNullX () throws SqlException
0:   {
0:     super.checkForClosedStatement ();
0:     if (wasNull_ == WAS_NULL_UNSET)
0:       throw new SqlException (agent_.logWriter_, "Invalid operation: wasNull() called with no data retrieved.");
0:     return wasNull_ == WAS_NULL;
0:   }
1: 
0:   //--------------------------------getter methods------------------------------
1: 
0:   public boolean getBoolean (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBoolean", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       boolean result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = agent_.crossConverters_.getBooleanFromInt (returnValueFromProcedure_);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBoolean", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? false : singletonRowData_.getBoolean (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBoolean", result);
0:       return result;
0:     }
0:   }
1: 
0:   public byte getByte (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getByte", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       byte result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = agent_.crossConverters_.getByteFromInt (returnValueFromProcedure_);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getByte", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? 0 : singletonRowData_.getByte (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getByte", result);
0:       return result;
0:     }
0:   }
1: 
0:   public short getShort (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getShort", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       short result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = agent_.crossConverters_.getShortFromInt (returnValueFromProcedure_);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getShort", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? 0 : singletonRowData_.getShort (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getShort", result);
0:       return result;
0:     }
0:   }
1: 
0:   public int getInt (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getInt", parameterIndex);
0:       int result = getIntX (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getInt", result);
0:       return result;
0:     }
0:   }
1: 
0:   // also used by SQLCA
0:   int getIntX (int parameterIndex) throws SqlException
0:   {
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:       return returnValueFromProcedure_;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:     return wasNullX() ? 0 : singletonRowData_.getInt (parameterIndex);
0:   }
1: 
0:   public long getLong (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getLong", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       long result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = (long) returnValueFromProcedure_;
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getLong", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? 0 : singletonRowData_.getLong (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getLong", result);
0:       return result;
0:     }
0:   }
1: 
0:   public float getFloat (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getFloat", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       float result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = (float) returnValueFromProcedure_;
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getFloat", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? 0 : singletonRowData_.getFloat (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getFloat", result);
0:       return result;
0:     }
0:   }
1: 
0:   public double getDouble (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDouble", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       double result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = (double) returnValueFromProcedure_;
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getDouble", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? 0 : singletonRowData_.getDouble (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getDouble", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.math.BigDecimal getBigDecimal (int parameterIndex, int scale) throws SqlException, ArithmeticException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceDeprecatedEntry (this, "getBigDecimal", parameterIndex, scale);
0:       super.checkForClosedStatement();
0:       checkForValidScale (scale);
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       java.math.BigDecimal result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = java.math.BigDecimal.valueOf (returnValueFromProcedure_).setScale (scale);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceDeprecatedExit (this, "getBigDecimal", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? null : singletonRowData_.getBigDecimal (parameterIndex);
0:       if (result != null) {
0:         result = result.setScale (scale, java.math.BigDecimal.ROUND_DOWN);
0:       }
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceDeprecatedExit (this, "getBigDecimal", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.math.BigDecimal getBigDecimal (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBigDecimal", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       java.math.BigDecimal result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = java.math.BigDecimal.valueOf (returnValueFromProcedure_);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBigDecimal", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? null : singletonRowData_.getBigDecimal (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBigDecimal", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Date getDate (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDate", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Date result = wasNullX() ? null : singletonRowData_.getDate (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getDate", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Date getDate (int parameterIndex, java.util.Calendar cal) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDate", parameterIndex, cal);
0:       if (cal == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.sql.Date result = getDate (parameterIndex);
0:       if (result != null) {
0:         java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:         targetCalendar.clear();
0:         targetCalendar.setTime(result);
0:         java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:         defaultCalendar.clear();
0:         defaultCalendar.setTime(result);
0:         long timeZoneOffset =
0:           targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:           targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:         result.setTime (result.getTime() - timeZoneOffset);
0:        }
0:        if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getDate", result);
0:        return result;
0:     }
0:   }
1: 
0:   public java.sql.Time getTime (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTime", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Time result = wasNullX() ? null : singletonRowData_.getTime (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTime", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Time getTime (int parameterIndex, java.util.Calendar cal) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTime", parameterIndex, cal);
0:       if (cal == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.sql.Time result = getTime(parameterIndex);
0:       if (result != null) {
0:         java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:         targetCalendar.clear();
0:         targetCalendar.setTime(result);
0:         java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:         defaultCalendar.clear();
0:         defaultCalendar.setTime(result);
0:         long timeZoneOffset =
0:           targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:           targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:         result.setTime (result.getTime() - timeZoneOffset);
0:       }
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTime", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Timestamp getTimestamp (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTimestamp", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Timestamp result = wasNullX() ? null : singletonRowData_.getTimestamp (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTimestamp", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Timestamp getTimestamp (int parameterIndex, java.util.Calendar cal) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTimestamp", parameterIndex, cal);
0:       if (cal == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.sql.Timestamp result = getTimestamp (parameterIndex);
0:       if (result != null) {
0:         int nano = result.getNanos();
0:         java.util.Calendar targetCalendar = java.util.Calendar.getInstance(cal.getTimeZone());
0:         targetCalendar.clear();
0:         targetCalendar.setTime(result);
0:         java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:         defaultCalendar.clear();
0:         defaultCalendar.setTime(result);
0:         long timeZoneOffset =
0:           targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:           targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:         result.setTime (result.getTime() - timeZoneOffset);
0:         result.setNanos (nano);
0:       }
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getTimestamp", result);
0:       return result;
0:     }
0:   }
1: 
0:   public String getString (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getString", parameterIndex);
0:       String result = getStringX (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getString", result);
0:       return result;
0:     }
0:   }
1: 
0:   // also used by SQLCA
0:   String getStringX (int parameterIndex) throws SqlException
0:   {
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:       return Integer.toString (returnValueFromProcedure_);
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:     return wasNullX() ? null : singletonRowData_.getString (parameterIndex);
0:   }
1: 
0:   public byte[] getBytes (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBytes", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       byte[] result = wasNullX() ? null : singletonRowData_.getBytes (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBytes", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Blob getBlob (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBlob", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Blob result = wasNullX() ? null : singletonRowData_.getBlob (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getBlob", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Clob getClob (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getClob", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Clob result = wasNullX() ? null : singletonRowData_.getClob (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getClob", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Array getArray (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getArray", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Array result = wasNullX() ? null : singletonRowData_.getArray (parameterIndex);
0:       if (true) throw new SqlException (agent_.logWriter_, "jdbc 2 method is not yet implemented");
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getArray", result);
0:       return result;
0:     }
0:   }
1: 
0:   public java.sql.Ref getRef (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getRef", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_)
0:         throw new SqlException (agent_.logWriter_, "Invalid method call: parameter 1 is an integer OUT parameter returned by the stored procedure, use getInt call.");
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       java.sql.Ref result = wasNullX() ? null : singletonRowData_.getRef (parameterIndex);
0:       if (true) throw new SqlException (agent_.logWriter_, "jdbc 2 method is not yet implemented");
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getRef", result);
0:       return result;
0:     }
0:   }
1: 
0:   public Object getObject (int parameterIndex) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getObject", parameterIndex);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       Object result;
0:       if (parameterIndex == 0 && escapedProcedureCallWithResult_) {
0:         result = new Integer (returnValueFromProcedure_);
0:         this.wasNull_ = this.WAS_NOT_NULL;
0:         if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getObject", result);
0:         return result;
0:       }
0:       checkGetterPreconditions (parameterIndex);
0:       setWasNull (parameterIndex);
0:       result = wasNullX() ? null : singletonRowData_.getObject (parameterIndex);
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getObject", result);
0:       return result;
0:     }
0:   }
1: 
0:   public Object getObject (int parameterIndex, java.util.Map map) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getObject", parameterIndex, map);
0:       super.checkForClosedStatement();
0:       parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:       Object result;
0:       checkGetterPreconditions (parameterIndex);
0:       if (true) throw new SqlException (agent_.logWriter_, "jdbc 2 method is not yet implemented.");
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getObject", result);
0:       return result;
0:     }
0:   }
1: 
0:   //--------------------------JDBC 3.0------------------------------------------
1: 
0:   public void registerOutParameter (String parameterName, int sqlType) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterName, sqlType);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void registerOutParameter (String parameterName, int sqlType, int scale) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterName, sqlType, scale);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void registerOutParameter (String parameterName, int sqlType, String typeName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "registerOutParameter", parameterName, sqlType, typeName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.net.URL getURL (int parameterIndex) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getURL", parameterIndex);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setURL (String parameterName, java.net.URL x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setURL", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setNull (String parameterName, int sqlType) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setNull", parameterName, sqlType);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setBoolean (String parameterName, boolean x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBoolean", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setByte (String parameterName, byte x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setByte", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setShort (String parameterName, short x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setShort", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setInt (String parameterName, int x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setInt", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setLong (String parameterName, long x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setLong", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setFloat (String parameterName, float x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setFloat", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setDouble (String parameterName, double x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDouble", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setBigDecimal (String parameterName, java.math.BigDecimal x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBigDecimal", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setString (String parameterName, String x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setString", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setBytes (String parameterName, byte x[]) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBytes", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setDate (String parameterName, java.sql.Date x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDate", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setTime (String parameterName, java.sql.Time x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTime", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setTimestamp (String parameterName, java.sql.Timestamp x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTimestamp", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setAsciiStream (String parameterName, java.io.InputStream x, int length) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setAsciiStream", parameterName, x, length);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setBinaryStream (String parameterName, java.io.InputStream x, int length) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBinaryStream", parameterName, x, length);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setObject (String parameterName, Object x, int targetSqlType, int scale) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterName, x, targetSqlType, scale);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setObject (String parameterName, Object x, int targetSqlType) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterName, x, targetSqlType);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setObject (String parameterName, Object x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterName, x);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setCharacterStream (String parameterName, java.io.Reader reader, int length) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setCharacterStream", parameterName, reader, length);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setDate (String parameterName, java.sql.Date x, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDate", parameterName, x, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setTime (String parameterName, java.sql.Time x, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTime", parameterName, x, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setTimestamp (String parameterName, java.sql.Timestamp x, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTimestamp", parameterName, x, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public void setNull (String parameterName, int sqlType, String typeName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setNull", parameterName, sqlType, typeName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public String getString (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getString", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public boolean getBoolean (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBoolean", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public byte getByte (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getByte", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public short getShort (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getShort", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public int getInt (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getInt", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public long getLong (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getLong", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public float getFloat (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getFloat", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public double getDouble (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDouble", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public byte[] getBytes (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBytes", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Date getDate (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDate", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Time getTime (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTime", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Timestamp getTimestamp (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTimestamp", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public Object getObject (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getObject", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.math.BigDecimal getBigDecimal (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBigDecimal", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public Object  getObject (String parameterName, java.util.Map map) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getObject", parameterName, map);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Ref getRef (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getRef", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Blob getBlob (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getBlob", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Clob getClob (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getClob", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Array getArray (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getArray", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Date getDate (String parameterName, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getDate", parameterName, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Time getTime (String parameterName, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTime", parameterName, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.Timestamp getTimestamp (String parameterName, java.util.Calendar calendar) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getTimestamp", parameterName, calendar);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.net.URL getURL (String parameterName) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getURL", parameterName);
0:     super.checkForClosedStatement();
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   //----------------------------helper methods----------------------------------
1: 
0:   private int checkForEscapedCallWithResult (int parameterIndex) throws SqlException
0:   {
0:     if (escapedProcedureCallWithResult_)
0:       parameterIndex--;
0:     return parameterIndex;
0:   }
1: 
0:   private int checkForEscapedCallWithResult (int parameterIndex, int jdbcType) throws SqlException
0:   {
0:     if (escapedProcedureCallWithResult_) {
0:       if (parameterIndex == 1 && jdbcType != java.sql.Types.INTEGER)
0:         throw new SqlException (agent_.logWriter_, "Parameter 1 is the return caluse of the stored procedure call, it can only be registered as an integer type");
0:       else
0:         parameterIndex--;
0:     }
0:     return parameterIndex;
0:   }
1: 
0:   private void checkGetterPreconditions (int parameterIndex) throws SqlException
0:   {
0:     super.checkForValidParameterIndex (parameterIndex);
0:     checkForValidOutParameter (parameterIndex);
0:   }
1: 
0:   private void checkForValidOutParameter (int parameterIndex) throws SqlException
0:   {
0:     if (parameterMetaData_ == null || parameterMetaData_.sqlxParmmode_[parameterIndex - 1] < java.sql.ParameterMetaData.parameterModeInOut)
0:       throw new SqlException (agent_.logWriter_, "Invalid argument: parameter index " + parameterIndex +
0:                               " is not an OUT or INOUT parameter.");
0:   }
1: 
0:   private void setWasNull (int parameterIndex)
0:   {
0:     if (singletonRowData_ == null)
0:       wasNull_ = WAS_NULL_UNSET;
0:     else
0:       wasNull_ = singletonRowData_.isNull_[parameterIndex - 1] ? WAS_NULL : WAS_NOT_NULL ;
0:   }
0: }
1: 
============================================================================