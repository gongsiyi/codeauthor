1:eac0369: /*
1:28e234d: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.dictionary.IndexRowGenerator
1:7ecc1f2: 
1:2e658c2:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2e658c2:    contributor license agreements.  See the NOTICE file distributed with
1:2e658c2:    this work for additional information regarding copyright ownership.
1:2e658c2:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2e658c2:    (the "License"); you may not use this file except in compliance with
1:2e658c2:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
5:eac0369:  */
18:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.dictionary;
1:f767f68: 
1:48d2629: import java.io.IOException;
1:48d2629: import java.io.ObjectInput;
1:48d2629: import java.io.ObjectOutput;
1:a0dbbd7: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.IndexDescriptor;
1:eac0369: import org.apache.derby.catalog.types.IndexDescriptorImpl;
1:48d2629: import org.apache.derby.iapi.error.StandardException;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:48d2629: import org.apache.derby.iapi.services.context.ContextService;
1:48d2629: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:48d2629: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:48d2629: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:48d2629: import org.apache.derby.iapi.sql.execute.ExecRow;
1:48d2629: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1:48d2629: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:f767f68: import org.apache.derby.iapi.types.RowLocation;
1:f767f68: import org.apache.derby.iapi.types.StringDataValue;
1:963d9f4: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: 
5:eac0369: /**
1:eac0369:  * This class extends IndexDescriptor for internal use by the
1:eac0369:  * DataDictionary.
1:0c5bc3a:  * <p>
1:0c5bc3a:  * For a description of how deferrable and non-deferrable constraints
1:0c5bc3a:  * are backed differently, including the meaning of the
1:0c5bc3a:  * boolean attributes used here, see {@link
1:0c5bc3a:  * org.apache.derby.catalog.IndexDescriptor}.
1:eac0369:  */
1:eac0369: public class IndexRowGenerator implements IndexDescriptor, Formatable
1:28e234d: {
1:48d2629: 	private IndexDescriptor	id;
1:eac0369: 	private ExecutionFactory ef;
1:28e234d: 
1:28e234d:     /**
1:28e234d:      * Constructor for an IndexRowGeneratorImpl
1:28e234d:      * 
1:28e234d:      * @param indexType		The type of index
1:28e234d:      * @param isUnique		True means the index is unique
1:28e234d:      * @param isUniqueWithDuplicateNulls means the index is almost unique
1:28e234d:      *                              i.e. unique only for non null keys
1:0c5bc3a:      * @param isUniqueDeferrable    True means the index represents a PRIMARY
1:0c5bc3a:      *                              KEY or a UNIQUE NOT NULL constraint which
1:0c5bc3a:      *                              is deferrable.
1:0c5bc3a:      * @param hasDeferrableChecking True if the index is used to back a
1:0c5bc3a:      *                              deferrable constraint
1:28e234d:      * @param baseColumnPositions	An array of column positions in the base
1:28e234d:      * 								table.  Each index column corresponds to a
1:28e234d:      * 								column position in the base table.
1:28e234d:      * @param isAscending	An array of booleans telling asc/desc on each
1:28e234d:      * 						column.
1:28e234d:      * @param numberOfOrderedColumns	In the future, it will be possible
1:28e234d:      * 									to store non-ordered columns in an
1:28e234d:      * 									index.  These will be useful for
1:28e234d:      * 									covered queries.
1:28e234d:      */
1:28e234d: 	public IndexRowGenerator(String indexType,
1:28e234d: 								boolean isUnique,
1:28e234d: 								boolean isUniqueWithDuplicateNulls,
1:0c5bc3a:                                 boolean isUniqueDeferrable,
1:0c5bc3a:                                 boolean hasDeferrableChecking,
1:28e234d: 								int[] baseColumnPositions,
1:28e234d: 								boolean[] isAscending,
1:28e234d: 								int numberOfOrderedColumns)
9:eac0369: 	{
1:eac0369: 		id = new IndexDescriptorImpl(indexType,
1:eac0369: 									isUnique,
1:28e234d: 									isUniqueWithDuplicateNulls,
1:0c5bc3a:                                     isUniqueDeferrable,
1:0c5bc3a:                                     hasDeferrableChecking,
1:28e234d: 									baseColumnPositions,
1:28e234d: 									isAscending,
1:28e234d: 									numberOfOrderedColumns);
1:eac0369: 
1:28e234d: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:28e234d: 			SanityManager.ASSERT(baseColumnPositions != null,
1:28e234d: 				"baseColumnPositions are null");
1:28e234d: 		}
1:28e234d: 	}
1:eac0369: 
1:28e234d: 	/**
2:eac0369: 	 * Constructor for an IndexRowGeneratorImpl
6:eac0369: 	 *
1:eac0369: 	 * @param indexDescriptor		An IndexDescriptor to delegate calls to
1:28e234d: 	 */
1:eac0369: 	public IndexRowGenerator(IndexDescriptor indexDescriptor)
1:28e234d: 	{
1:eac0369: 		id = indexDescriptor;
9:eac0369: 	}
1:eac0369: 
1:f767f68: 	/**
1:eac0369: 	 * Get a template for the index row, to be used with getIndexRow.
1:eac0369: 	 *
1:eac0369: 	 * @return	A row template for the index row.
1:eac0369: 	 */
1:eac0369: 	public ExecIndexRow getIndexRowTemplate()
1:eac0369: 	{
1:eac0369: 		return getExecutionFactory().getIndexableRow(
1:eac0369: 										id.baseColumnPositions().length + 1);
1:eac0369: 	}
1:eac0369: 
1:963d9f4:     /**
1:963d9f4:      * Get a NULL Index Row for this index. This is useful to create objects
1:963d9f4:      * that need to be passed to ScanController.
1:963d9f4:      *
1:963d9f4:      * @param columnList ColumnDescriptors describing the base table.
1:963d9f4:      * @param rowLocation   empty row location.
1:963d9f4:      *
1:963d9f4:      * @exception StandardException thrown on error.
1:963d9f4:      */
1:963d9f4:     public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,
1:963d9f4:     		RowLocation rowLocation)
1:963d9f4:     throws StandardException
1:963d9f4:     {
1:963d9f4:             int[] baseColumnPositions = id.baseColumnPositions();
1:963d9f4:             ExecIndexRow indexRow = getIndexRowTemplate();
1:963d9f4: 
1:963d9f4:             for (int i = 0; i < baseColumnPositions.length; i++)
1:963d9f4:             {
1:963d9f4:                     DataTypeDescriptor dtd =
1:963d9f4:                             columnList.elementAt(baseColumnPositions[i] - 1).getType();
1:963d9f4:                     indexRow.setColumn(i + 1, dtd.getNull());
1:963d9f4:             }
1:963d9f4: 
1:963d9f4:             indexRow.setColumn(baseColumnPositions.length + 1, rowLocation);
1:963d9f4:             return indexRow;
1:963d9f4:     }
1:963d9f4: 
1:eac0369: 	/**
1:eac0369: 	 * Get an index row for this index given a row from the base table
1:eac0369: 	 * and the RowLocation of the base row.  This method can be used
1:eac0369: 	 * to get the new index row for inserts, and the old and new index
1:eac0369: 	 * rows for deletes and updates.  For updates, the result row has
1:eac0369: 	 * all the old column values followed by all of the new column values,
1:eac0369: 	 * so you must form a row using the new column values to pass to
1:eac0369: 	 * this method to get the new index row.
1:eac0369: 	 *
1:eac0369: 	 * @param baseRow	A row in the base table
1:eac0369: 	 * @param rowLocation	The RowLocation of the row in the base table
1:eac0369: 	 * @param indexRow	A template for the index row.  It must have the
1:eac0369: 	 *					correct number of columns.
1:eac0369: 	 * @param bitSet	If non-null, then baseRow is a partial row and the
1:eac0369: 	 *					set bits in bitSet represents the column mapping for
1:eac0369: 	 *					the partial row to the complete base row. <B> WARNING:
1:eac0369: 	 *					</B> ONE based!!!
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void getIndexRow(ExecRow baseRow,
1:eac0369: 							RowLocation rowLocation,
1:eac0369: 							ExecIndexRow indexRow,
1:eac0369: 							FormatableBitSet bitSet)
2:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Set the columns in the index row that are based on columns in
1:eac0369: 		** the base row.
1:eac0369: 		*/
3:eac0369: 		int[] baseColumnPositions = id.baseColumnPositions();
1:eac0369: 		int colCount = baseColumnPositions.length;
1:eac0369: 
1:eac0369: 		if (bitSet == null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Set the columns in the index row that are based on columns in
1:eac0369: 			** the base row.
1:eac0369: 			*/
1:eac0369: 			for (int i = 0; i < colCount ; i++)
1:eac0369: 			{
1:eac0369: 				indexRow.setColumn(i + 1,
1:eac0369: 						baseRow.getColumn(baseColumnPositions[i]));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
2:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(!bitSet.get(0), "element zero of the bitSet passed into getIndexRow() is not false, bitSet should be 1 based");
1:eac0369: 			}
1:eac0369:  
1:eac0369: 			/*
1:eac0369: 			** Set the columns in the index row that are based on columns in
1:eac0369: 			** the base row.
1:eac0369: 			*/
1:eac0369: 			for (int i = 0; i < colCount; i++)
1:eac0369: 			{
1:eac0369: 				int fullColumnNumber = baseColumnPositions[i];
1:eac0369: 				int partialColumnNumber = 0;
1:eac0369: 				for (int index = 1; index <= fullColumnNumber; index++)
1:eac0369: 				{
1:eac0369: 					if (bitSet.get(index))
1:eac0369: 					{
1:eac0369: 						partialColumnNumber++;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				indexRow.setColumn(i + 1,
1:eac0369: 							baseRow.getColumn(partialColumnNumber));
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Set the row location in the last column of the index row */
1:eac0369: 		indexRow.setColumn(colCount + 1, rowLocation);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:f767f68:      * Return an array of collation ids for this table.
1:f767f68:      * <p>
1:f767f68:      * Return an array of collation ids, one for each column in the
1:f767f68:      * columnDescriptorList.  This is useful for passing collation id info
1:f767f68:      * down to store, for instance in createConglomerate() to create
1:f767f68:      * the index.
1:f767f68:      *
1:f767f68:      * This is only expected to get called during ddl, so object allocation
1:f767f68:      * is ok. 
1:f767f68:      *
1:f767f68: 	 * @param columnList ColumnDescriptors describing the base table.
1:f767f68:      *
1:f767f68: 	 * @exception  StandardException  Standard exception policy.
1:f767f68:      **/
1:f767f68:     public int[] getColumnCollationIds(ColumnDescriptorList columnList)
1:f767f68: 		throws StandardException
1:f767f68:     {
1:f767f68:         int[] base_cols     = id.baseColumnPositions();
1:f767f68:         int[] collation_ids = new int[base_cols.length + 1];
1:f767f68: 
1:f767f68: 		for (int i = 0; i < base_cols.length; i++)
1:f767f68: 		{
1:f767f68:             collation_ids[i] =
1:f767f68: 				columnList.elementAt(
1:f767f68:                     base_cols[i] - 1).getType().getCollationType();
1:f767f68: 		}
1:f767f68: 
1:f767f68:         // row location column at end is always basic collation type.
1:f767f68:         collation_ids[collation_ids.length - 1] = 
1:f767f68:             StringDataValue.COLLATION_TYPE_UCS_BASIC; 
1:f767f68: 
1:f767f68: 		return(collation_ids);
1:f767f68:     }
1:f767f68: 
1:eac0369: 		 
1:eac0369: 	/**
1:eac0369: 	 * Get the IndexDescriptor that this IndexRowGenerator is based on.
1:eac0369: 	 */
1:eac0369: 	public IndexDescriptor getIndexDescriptor()
1:eac0369: 	{
1:eac0369: 		return id;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** Zero-argument constructor for Formatable interface */
1:eac0369: 	public IndexRowGenerator()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:435735b:      * @see IndexDescriptor#isUniqueWithDuplicateNulls
1:eac0369:      */
1:28e234d: 	public boolean isUniqueWithDuplicateNulls()
1:28e234d: 	{
1:28e234d: 		return id.isUniqueWithDuplicateNulls();
1:28e234d: 	}
1:0c5bc3a: 
1:0c5bc3a:     public boolean hasDeferrableChecking()
1:0c5bc3a:     {
1:0c5bc3a:         return id.hasDeferrableChecking();
1:0c5bc3a:     }
1:0c5bc3a: 
1:0c5bc3a: 
1:0c5bc3a:     public boolean isUniqueDeferrable()
1:0c5bc3a:     {
1:0c5bc3a:         return id.isUniqueDeferrable();
1:0c5bc3a:     }
1:0c5bc3a: 
1:0c5bc3a: 
1:eac0369: 	/** @see IndexDescriptor#isUnique */
1:eac0369: 	public boolean isUnique()
1:eac0369: 	{
1:eac0369: 		return id.isUnique();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#baseColumnPositions */
1:eac0369: 	public int[] baseColumnPositions()
1:eac0369: 	{
1:eac0369: 		return id.baseColumnPositions();
1:eac0369: 	}
1:eac0369: 
2:eac0369: 	/** @see IndexDescriptor#getKeyColumnPosition */
1:eac0369: 	public int getKeyColumnPosition(int heapColumnPosition)
1:eac0369: 	{
2:eac0369: 		return id.getKeyColumnPosition(heapColumnPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#numberOfOrderedColumns */
1:eac0369: 	public int numberOfOrderedColumns()
1:eac0369: 	{
1:eac0369: 		return id.numberOfOrderedColumns();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#indexType */
1:eac0369: 	public String indexType()
1:eac0369: 	{
1:eac0369: 		return id.indexType();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		return id.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isAscending */
1:eac0369: 	public boolean			isAscending(Integer keyColumnPosition)
1:eac0369: 	{
1:eac0369: 		return id.isAscending(keyColumnPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isDescending */
1:eac0369: 	public boolean			isDescending(Integer keyColumnPosition)
1:eac0369: 	{
1:eac0369: 		return id.isDescending(keyColumnPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#isAscending */
1:eac0369: 	public boolean[]		isAscending()
1:eac0369: 	{
1:eac0369: 		return id.isAscending();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setBaseColumnPositions */
1:eac0369: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
1:eac0369: 	{
1:eac0369: 		id.setBaseColumnPositions(baseColumnPositions);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setIsAscending */
1:eac0369: 	public void		setIsAscending(boolean[] isAscending)
1:eac0369: 	{
1:eac0369: 		id.setIsAscending(isAscending);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
1:eac0369: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
1:eac0369: 	{
1:eac0369: 		id.setNumberOfOrderedColumns(numberOfOrderedColumns);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Test for value equality
1:eac0369: 	 *
1:eac0369: 	 * @param other		The other indexrowgenerator to compare this one with
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this indexrowgenerator has the same value as other
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public boolean equals(Object other)
1:eac0369: 	{
1:eac0369: 		return id.equals(other);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  @see java.lang.Object#hashCode
1:eac0369: 	  */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		return id.hashCode();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private ExecutionFactory getExecutionFactory()
1:eac0369: 	{
1:eac0369: 		if (ef == null)
1:eac0369: 		{
1:eac0369: 			ExecutionContext	ec;
1:eac0369: 
1:eac0369: 			ec = (ExecutionContext)
1:a0dbbd7: 					getContext(ExecutionContext.CONTEXT_ID);
1:eac0369: 			ef = ec.getExecutionFactory();
1:eac0369: 		}
1:eac0369: 		return ef;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// EXTERNALIZABLE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on read error
1:eac0369: 	 * @exception ClassNotFoundException	Thrown on read error
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
1:eac0369: 	{
1:eac0369: 		id = (IndexDescriptor)in.readObject();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on write error
1:eac0369: 	 */
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException
1:eac0369: 	{
1:eac0369: 		out.writeObject(id);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* TypedFormat interface */
1:eac0369: 	public int getTypeFormatId()
1:eac0369: 	{
1:eac0369: 		return StoredFormatIds.INDEX_ROW_GENERATOR_V01_ID;
1:eac0369: 	}
1:a0dbbd7: 
1:eac0369:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContext( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContext( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContext( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1: 					getContext(ExecutionContext.CONTEXT_ID);
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContext( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContext( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContext( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:5c04fbc
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:  * <p>
1:  * For a description of how deferrable and non-deferrable constraints
1:  * are backed differently, including the meaning of the
1:  * boolean attributes used here, see {@link
1:  * org.apache.derby.catalog.IndexDescriptor}.
/////////////////////////////////////////////////////////////////////////
1:      * @param isUniqueDeferrable    True means the index represents a PRIMARY
1:      *                              KEY or a UNIQUE NOT NULL constraint which
1:      *                              is deferrable.
1:      * @param hasDeferrableChecking True if the index is used to back a
1:      *                              deferrable constraint
/////////////////////////////////////////////////////////////////////////
1:                                 boolean isUniqueDeferrable,
1:                                 boolean hasDeferrableChecking,
/////////////////////////////////////////////////////////////////////////
1:                                     isUniqueDeferrable,
1:                                     hasDeferrableChecking,
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean hasDeferrableChecking()
1:     {
1:         return id.hasDeferrableChecking();
1:     }
1: 
1: 
1:     public boolean isUniqueDeferrable()
1:     {
1:         return id.isUniqueDeferrable();
1:     }
1: 
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get a NULL Index Row for this index. This is useful to create objects
1:      * that need to be passed to ScanController.
1:      *
1:      * @param columnList ColumnDescriptors describing the base table.
1:      * @param rowLocation   empty row location.
1:      *
1:      * @exception StandardException thrown on error.
1:      */
1:     public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,
1:     		RowLocation rowLocation)
1:     throws StandardException
1:     {
1:             int[] baseColumnPositions = id.baseColumnPositions();
1:             ExecIndexRow indexRow = getIndexRowTemplate();
1: 
1:             for (int i = 0; i < baseColumnPositions.length; i++)
1:             {
1:                     DataTypeDescriptor dtd =
1:                             columnList.elementAt(baseColumnPositions[i] - 1).getType();
1:                     indexRow.setColumn(i + 1, dtd.getNull());
1:             }
1: 
1:             indexRow.setColumn(baseColumnPositions.length + 1, rowLocation);
1:             return indexRow;
1:     }
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:435735b
/////////////////////////////////////////////////////////////////////////
1:      * @see IndexDescriptor#isUniqueWithDuplicateNulls
commit:28e234d
/////////////////////////////////////////////////////////////////////////
0: 		id = new IndexDescriptorImpl(
0:                         indexType,
0:                         isUnique, //default uniqueWithDuplicateNulls to false
0:                         false,
1:                         baseColumnPositions,
1:                         isAscending,
1:                         numberOfOrderedColumns);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(baseColumnPositions != null,
1: 				"baseColumnPositions are null");
1: 		}
1: 	}
1:         
1:     /**
1:      * Constructor for an IndexRowGeneratorImpl
1:      * 
1:      * @param indexType		The type of index
1:      * @param isUnique		True means the index is unique
1:      * @param isUniqueWithDuplicateNulls means the index is almost unique
1:      *                              i.e. unique only for non null keys
1:      * @param baseColumnPositions	An array of column positions in the base
1:      * 								table.  Each index column corresponds to a
1:      * 								column position in the base table.
1:      * @param isAscending	An array of booleans telling asc/desc on each
1:      * 						column.
1:      * @param numberOfOrderedColumns	In the future, it will be possible
1:      * 									to store non-ordered columns in an
1:      * 									index.  These will be useful for
1:      * 									covered queries.
1:      */
1: 	public IndexRowGenerator(String indexType,
1: 								boolean isUnique,
1: 								boolean isUniqueWithDuplicateNulls,
1: 								int[] baseColumnPositions,
1: 								boolean[] isAscending,
1: 								int numberOfOrderedColumns)
1: 	{
1: 									isUniqueWithDuplicateNulls,
/////////////////////////////////////////////////////////////////////////
1: 	/**
0:      * @see IndexDescriptor#isisUniqueWithDuplicateNulls
1:      */
1: 	public boolean isUniqueWithDuplicateNulls()
1: 	{
1: 		return id.isUniqueWithDuplicateNulls();
1: 	}
commit:f767f68
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return an array of collation ids for this table.
1:      * <p>
1:      * Return an array of collation ids, one for each column in the
1:      * columnDescriptorList.  This is useful for passing collation id info
1:      * down to store, for instance in createConglomerate() to create
1:      * the index.
1:      *
1:      * This is only expected to get called during ddl, so object allocation
1:      * is ok. 
1:      *
1: 	 * @param columnList ColumnDescriptors describing the base table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public int[] getColumnCollationIds(ColumnDescriptorList columnList)
1: 		throws StandardException
1:     {
1:         int[] base_cols     = id.baseColumnPositions();
1:         int[] collation_ids = new int[base_cols.length + 1];
1: 
1: 		for (int i = 0; i < base_cols.length; i++)
1: 		{
1:             collation_ids[i] =
1: 				columnList.elementAt(
1:                     base_cols[i] - 1).getType().getCollationType();
1: 		}
1: 
1:         // row location column at end is always basic collation type.
1:         collation_ids[collation_ids.length - 1] = 
1:             StringDataValue.COLLATION_TYPE_UCS_BASIC; 
1: 
1: 		return(collation_ids);
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:48d2629
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1: 	private IndexDescriptor	id;
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.dictionary.IndexRowGenerator
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.dictionary;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.catalog.IndexDescriptor;
1: import org.apache.derby.catalog.types.IndexDescriptorImpl;
1: 
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.io.IOException;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: /**
1:  * This class extends IndexDescriptor for internal use by the
1:  * DataDictionary.
1:  */
1: public class IndexRowGenerator implements IndexDescriptor, Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	IndexDescriptor	id;
1: 	private ExecutionFactory ef;
1: 
1: 	/**
1: 	 * Constructor for an IndexRowGeneratorImpl
1: 	 *
0: 	 * @param indexType		The type of index
0: 	 * @param isUnique		True means the index is unique
0: 	 * @param baseColumnPositions	An array of column positions in the base
0: 	 *								table.  Each index column corresponds to a
0: 	 *								column position in the base table.
0: 	 * @param isAscending	An array of booleans telling asc/desc on each
0: 	 *						column.
0: 	 * @param numberOfOrderedColumns	In the future, it will be possible
0: 	 *									to store non-ordered columns in an
0: 	 *									index.  These will be useful for
0: 	 *									covered queries.
1: 	 */
0: 	public IndexRowGenerator(String indexType,
0: 								boolean isUnique,
0: 								int[] baseColumnPositions,
0: 								boolean[] isAscending,
0: 								int numberOfOrderedColumns)
1: 	{
1: 		id = new IndexDescriptorImpl(indexType,
1: 									isUnique,
0: 									baseColumnPositions,
0: 									isAscending,
0: 									numberOfOrderedColumns);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(baseColumnPositions != null,
0: 				"baseColumnPositions are null");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Constructor for an IndexRowGeneratorImpl
1: 	 *
1: 	 * @param indexDescriptor		An IndexDescriptor to delegate calls to
1: 	 */
1: 	public IndexRowGenerator(IndexDescriptor indexDescriptor)
1: 	{
1: 		id = indexDescriptor;
1: 	}
1: 
1: 	/**
1: 	 * Get a template for the index row, to be used with getIndexRow.
1: 	 *
1: 	 * @return	A row template for the index row.
1: 	 */
1: 	public ExecIndexRow getIndexRowTemplate()
1: 	{
1: 		return getExecutionFactory().getIndexableRow(
1: 										id.baseColumnPositions().length + 1);
1: 	}
1: 
1: 	/**
1: 	 * Get an index row for this index given a row from the base table
1: 	 * and the RowLocation of the base row.  This method can be used
1: 	 * to get the new index row for inserts, and the old and new index
1: 	 * rows for deletes and updates.  For updates, the result row has
1: 	 * all the old column values followed by all of the new column values,
1: 	 * so you must form a row using the new column values to pass to
1: 	 * this method to get the new index row.
1: 	 *
1: 	 * @param baseRow	A row in the base table
1: 	 * @param rowLocation	The RowLocation of the row in the base table
1: 	 * @param indexRow	A template for the index row.  It must have the
1: 	 *					correct number of columns.
1: 	 * @param bitSet	If non-null, then baseRow is a partial row and the
1: 	 *					set bits in bitSet represents the column mapping for
1: 	 *					the partial row to the complete base row. <B> WARNING:
1: 	 *					</B> ONE based!!!
1: 	 *
0: 	 * @return	An index row conforming to this index description containing
0: 	 *			the column values from the base row and the given row location.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void getIndexRow(ExecRow baseRow,
1: 							RowLocation rowLocation,
1: 							ExecIndexRow indexRow,
1: 							FormatableBitSet bitSet)
1: 						throws StandardException
1: 	{
1: 		/*
1: 		** Set the columns in the index row that are based on columns in
1: 		** the base row.
1: 		*/
1: 		int[] baseColumnPositions = id.baseColumnPositions();
1: 		int colCount = baseColumnPositions.length;
1: 
1: 		if (bitSet == null)
1: 		{
1: 			/*
1: 			** Set the columns in the index row that are based on columns in
1: 			** the base row.
1: 			*/
1: 			for (int i = 0; i < colCount ; i++)
1: 			{
1: 				indexRow.setColumn(i + 1,
1: 						baseRow.getColumn(baseColumnPositions[i]));
1: 			}
1: 		}
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(!bitSet.get(0), "element zero of the bitSet passed into getIndexRow() is not false, bitSet should be 1 based");
1: 			}
1:  
1: 			/*
1: 			** Set the columns in the index row that are based on columns in
1: 			** the base row.
1: 			*/
1: 			for (int i = 0; i < colCount; i++)
1: 			{
1: 				int fullColumnNumber = baseColumnPositions[i];
1: 				int partialColumnNumber = 0;
1: 				for (int index = 1; index <= fullColumnNumber; index++)
1: 				{
1: 					if (bitSet.get(index))
1: 					{
1: 						partialColumnNumber++;
1: 					}
1: 				}
1: 				indexRow.setColumn(i + 1,
1: 							baseRow.getColumn(partialColumnNumber));
1: 			}
1: 		}
1: 
1: 		/* Set the row location in the last column of the index row */
1: 		indexRow.setColumn(colCount + 1, rowLocation);
1: 	}
1: 
1: 	/**
0: 	 * Get a NULL Index Row for this index. This is useful to create objects 
0: 	 * that need to be passed to ScanController.
1: 	 *
0: 	 * @param columnrList ColumnDescriptors describing the base table.
0: 	 * @param rowLocation	empty row location.
1: 	 *
0: 	 * @exception StandardException thrown on error.
1: 	 */
0: 	public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,
0: 										RowLocation rowLocation)
1: 				throws StandardException				
1: 	{
1: 		int[] baseColumnPositions = id.baseColumnPositions();
0: 		int i;
0: 		ExecIndexRow indexRow = getIndexRowTemplate();
1: 
0: 		for (i = 0; i < baseColumnPositions.length; i++)
1: 		{
0: 			DataTypeDescriptor dtd =
0: 				columnList.elementAt(baseColumnPositions[i] - 1).getType();
0: 			indexRow.setColumn(i + 1, dtd.getNull());
1: 		}
1: 
0: 		indexRow.setColumn(i + 1, rowLocation);
0: 		return indexRow;
1: 	}
1: 
1: 	/**
0: 	 * Return true iff a change to a set of columns changes the index for this
0: 	 * IndexRowGenerator.
1: 	 *
0: 	 * @param changedColumnIds - holds the 1 based column ids for the changed
0: 	 *		columns.
0: 	 * @return	true iff a change to one of the columns in changedColumnIds
0: 	 *          effects this index. 
1: 	 */
0: 	public boolean indexChanged(int[] changedColumnIds)
1: 	{
1: 		int[] baseColumnPositions = id.baseColumnPositions();
1: 
0: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
1: 		{
0: 			for (int iy = 0; iy < baseColumnPositions.length; iy++)
1: 			{
0: 				if (changedColumnIds[ix] == baseColumnPositions[iy])
0: 					return true;
1: 			}
1: 		}
0: 		return false;
1: 	}
1: 
1: 		 
1: 	/**
1: 	 * Get the IndexDescriptor that this IndexRowGenerator is based on.
1: 	 */
1: 	public IndexDescriptor getIndexDescriptor()
1: 	{
1: 		return id;
1: 	}
1: 
1: 	/** Zero-argument constructor for Formatable interface */
1: 	public IndexRowGenerator()
1: 	{
1: 	}
1: 
1: 	/** @see IndexDescriptor#isUnique */
1: 	public boolean isUnique()
1: 	{
1: 		return id.isUnique();
1: 	}
1: 
1: 	/** @see IndexDescriptor#baseColumnPositions */
1: 	public int[] baseColumnPositions()
1: 	{
1: 		return id.baseColumnPositions();
1: 	}
1: 
1: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public Integer getKeyColumnPosition(Integer heapColumnPosition)
1: 	{
1: 		return id.getKeyColumnPosition(heapColumnPosition);
1: 	}
1: 
1: 	/** @see IndexDescriptor#getKeyColumnPosition */
1: 	public int getKeyColumnPosition(int heapColumnPosition)
1: 	{
1: 		return id.getKeyColumnPosition(heapColumnPosition);
1: 	}
1: 
1: 	/** @see IndexDescriptor#numberOfOrderedColumns */
1: 	public int numberOfOrderedColumns()
1: 	{
1: 		return id.numberOfOrderedColumns();
1: 	}
1: 
1: 	/** @see IndexDescriptor#indexType */
1: 	public String indexType()
1: 	{
1: 		return id.indexType();
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		return id.toString();
1: 	}
1: 
1: 	/** @see IndexDescriptor#isAscending */
1: 	public boolean			isAscending(Integer keyColumnPosition)
1: 	{
1: 		return id.isAscending(keyColumnPosition);
1: 	}
1: 
1: 	/** @see IndexDescriptor#isDescending */
1: 	public boolean			isDescending(Integer keyColumnPosition)
1: 	{
1: 		return id.isDescending(keyColumnPosition);
1: 	}
1: 
1: 	/** @see IndexDescriptor#isAscending */
1: 	public boolean[]		isAscending()
1: 	{
1: 		return id.isAscending();
1: 	}
1: 
1: 	/** @see IndexDescriptor#setBaseColumnPositions */
1: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
1: 	{
1: 		id.setBaseColumnPositions(baseColumnPositions);
1: 	}
1: 
1: 	/** @see IndexDescriptor#setIsAscending */
1: 	public void		setIsAscending(boolean[] isAscending)
1: 	{
1: 		id.setIsAscending(isAscending);
1: 	}
1: 
1: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
1: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
1: 	{
1: 		id.setNumberOfOrderedColumns(numberOfOrderedColumns);
1: 	}
1: 
1: 	/**
1: 	 * Test for value equality
1: 	 *
1: 	 * @param other		The other indexrowgenerator to compare this one with
1: 	 *
1: 	 * @return	true if this indexrowgenerator has the same value as other
1: 	 */
1: 
1: 	public boolean equals(Object other)
1: 	{
1: 		return id.equals(other);
1: 	}
1: 
1: 	/**
1: 	  @see java.lang.Object#hashCode
1: 	  */
1: 	public int hashCode()
1: 	{
1: 		return id.hashCode();
1: 	}
1: 
1: 	private ExecutionFactory getExecutionFactory()
1: 	{
1: 		if (ef == null)
1: 		{
1: 			ExecutionContext	ec;
1: 
1: 			ec = (ExecutionContext)
0: 					ContextService.getContext(ExecutionContext.CONTEXT_ID);
1: 			ef = ec.getExecutionFactory();
1: 		}
1: 		return ef;
1: 	}
1: 
1: 	////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// EXTERNALIZABLE
1: 	//
1: 	////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on read error
1: 	 * @exception ClassNotFoundException	Thrown on read error
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
1: 	{
1: 		id = (IndexDescriptor)in.readObject();
1: 	}
1: 
1: 	/**
1: 	 *
1: 	 * @exception IOException	Thrown on write error
1: 	 */
1: 	public void writeExternal(ObjectOutput out) throws IOException
1: 	{
1: 		out.writeObject(id);
1: 	}
1: 
1: 	/* TypedFormat interface */
1: 	public int getTypeFormatId()
1: 	{
1: 		return StoredFormatIds.INDEX_ROW_GENERATOR_V01_ID;
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2e658c2
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param columnList ColumnDescriptors describing the base table.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.dictionary
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.dictionary;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.catalog.IndexDescriptor;
0: import org.apache.derby.catalog.types.IndexDescriptorImpl;
0: 
0: import java.io.ObjectInput;
0: import java.io.ObjectOutput;
0: import java.io.IOException;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: /**
0:  * This class extends IndexDescriptor for internal use by the
0:  * DataDictionary.
0:  */
0: public class IndexRowGenerator implements IndexDescriptor, Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	IndexDescriptor	id;
0: 	private ExecutionFactory ef;
0: 
0: 	/**
0: 	 * Constructor for an IndexRowGeneratorImpl
0: 	 *
0: 	 * @param indexType		The type of index
0: 	 * @param isUnique		True means the index is unique
0: 	 * @param baseColumnPositions	An array of column positions in the base
0: 	 *								table.  Each index column corresponds to a
0: 	 *								column position in the base table.
0: 	 * @param isAscending	An array of booleans telling asc/desc on each
0: 	 *						column.
0: 	 * @param numberOfOrderedColumns	In the future, it will be possible
0: 	 *									to store non-ordered columns in an
0: 	 *									index.  These will be useful for
0: 	 *									covered queries.
0: 	 */
0: 	public IndexRowGenerator(String indexType,
0: 								boolean isUnique,
0: 								int[] baseColumnPositions,
0: 								boolean[] isAscending,
0: 								int numberOfOrderedColumns)
0: 	{
0: 		id = new IndexDescriptorImpl(indexType,
0: 									isUnique,
0: 									baseColumnPositions,
0: 									isAscending,
0: 									numberOfOrderedColumns);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(baseColumnPositions != null,
0: 				"baseColumnPositions are null");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Constructor for an IndexRowGeneratorImpl
0: 	 *
0: 	 * @param indexDescriptor		An IndexDescriptor to delegate calls to
0: 	 */
0: 	public IndexRowGenerator(IndexDescriptor indexDescriptor)
0: 	{
0: 		id = indexDescriptor;
0: 	}
0: 
0: 	/**
0: 	 * Get a template for the index row, to be used with getIndexRow.
0: 	 *
0: 	 * @return	A row template for the index row.
0: 	 */
0: 	public ExecIndexRow getIndexRowTemplate()
0: 	{
0: 		return getExecutionFactory().getIndexableRow(
0: 										id.baseColumnPositions().length + 1);
0: 	}
0: 
0: 	/**
0: 	 * Get an index row for this index given a row from the base table
0: 	 * and the RowLocation of the base row.  This method can be used
0: 	 * to get the new index row for inserts, and the old and new index
0: 	 * rows for deletes and updates.  For updates, the result row has
0: 	 * all the old column values followed by all of the new column values,
0: 	 * so you must form a row using the new column values to pass to
0: 	 * this method to get the new index row.
0: 	 *
0: 	 * @param baseRow	A row in the base table
0: 	 * @param rowLocation	The RowLocation of the row in the base table
0: 	 * @param indexRow	A template for the index row.  It must have the
0: 	 *					correct number of columns.
0: 	 * @param bitSet	If non-null, then baseRow is a partial row and the
0: 	 *					set bits in bitSet represents the column mapping for
0: 	 *					the partial row to the complete base row. <B> WARNING:
0: 	 *					</B> ONE based!!!
0: 	 *
0: 	 * @return	An index row conforming to this index description containing
0: 	 *			the column values from the base row and the given row location.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void getIndexRow(ExecRow baseRow,
0: 							RowLocation rowLocation,
0: 							ExecIndexRow indexRow,
0: 							FormatableBitSet bitSet)
0: 						throws StandardException
0: 	{
0: 		/*
0: 		** Set the columns in the index row that are based on columns in
0: 		** the base row.
0: 		*/
0: 		int[] baseColumnPositions = id.baseColumnPositions();
0: 		int colCount = baseColumnPositions.length;
0: 
0: 		if (bitSet == null)
0: 		{
0: 			/*
0: 			** Set the columns in the index row that are based on columns in
0: 			** the base row.
0: 			*/
0: 			for (int i = 0; i < colCount ; i++)
0: 			{
0: 				indexRow.setColumn(i + 1,
0: 						baseRow.getColumn(baseColumnPositions[i]));
0: 			}
0: 		}
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(!bitSet.get(0), "element zero of the bitSet passed into getIndexRow() is not false, bitSet should be 1 based");
0: 			}
0:  
0: 			/*
0: 			** Set the columns in the index row that are based on columns in
0: 			** the base row.
0: 			*/
0: 			for (int i = 0; i < colCount; i++)
0: 			{
0: 				int fullColumnNumber = baseColumnPositions[i];
0: 				int partialColumnNumber = 0;
0: 				for (int index = 1; index <= fullColumnNumber; index++)
0: 				{
0: 					if (bitSet.get(index))
0: 					{
0: 						partialColumnNumber++;
0: 					}
0: 				}
0: 				indexRow.setColumn(i + 1,
0: 							baseRow.getColumn(partialColumnNumber));
0: 			}
0: 		}
0: 
0: 		/* Set the row location in the last column of the index row */
0: 		indexRow.setColumn(colCount + 1, rowLocation);
0: 	}
0: 
0: 	/**
0: 	 * Get a NULL Index Row for this index. This is useful to create objects 
0: 	 * that need to be passed to ScanController.
0: 	 *
0: 	 * @param columnrList ColumnDescriptors describing the base table.
0: 	 * @param rowLocation	empty row location.
0: 	 *
0: 	 * @exception StandardException thrown on error.
0: 	 */
0: 	public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,
0: 										RowLocation rowLocation)
0: 				throws StandardException				
0: 	{
0: 		int[] baseColumnPositions = id.baseColumnPositions();
0: 		int i;
0: 		ExecIndexRow indexRow = getIndexRowTemplate();
0: 
0: 		for (i = 0; i < baseColumnPositions.length; i++)
0: 		{
0: 			DataTypeDescriptor dtd =
0: 				columnList.elementAt(baseColumnPositions[i] - 1).getType();
0: 			indexRow.setColumn(i + 1, dtd.getNull());
0: 		}
0: 
0: 		indexRow.setColumn(i + 1, rowLocation);
0: 		return indexRow;
0: 	}
0: 
0: 	/**
0: 	 * Return true iff a change to a set of columns changes the index for this
0: 	 * IndexRowGenerator.
0: 	 *
0: 	 * @param changedColumnIds - holds the 1 based column ids for the changed
0: 	 *		columns.
0: 	 * @return	true iff a change to one of the columns in changedColumnIds
0: 	 *          effects this index. 
0: 	 */
0: 	public boolean indexChanged(int[] changedColumnIds)
0: 	{
0: 		int[] baseColumnPositions = id.baseColumnPositions();
0: 
0: 		for (int ix = 0; ix < changedColumnIds.length; ix++)
0: 		{
0: 			for (int iy = 0; iy < baseColumnPositions.length; iy++)
0: 			{
0: 				if (changedColumnIds[ix] == baseColumnPositions[iy])
0: 					return true;
0: 			}
0: 		}
0: 		return false;
0: 	}
0: 
0: 		 
0: 	/**
0: 	 * Get the IndexDescriptor that this IndexRowGenerator is based on.
0: 	 */
0: 	public IndexDescriptor getIndexDescriptor()
0: 	{
0: 		return id;
0: 	}
0: 
0: 	/** Zero-argument constructor for Formatable interface */
0: 	public IndexRowGenerator()
0: 	{
0: 	}
0: 
0: 	/** @see IndexDescriptor#isUnique */
0: 	public boolean isUnique()
0: 	{
0: 		return id.isUnique();
0: 	}
0: 
0: 	/** @see IndexDescriptor#baseColumnPositions */
0: 	public int[] baseColumnPositions()
0: 	{
0: 		return id.baseColumnPositions();
0: 	}
0: 
0: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public Integer getKeyColumnPosition(Integer heapColumnPosition)
0: 	{
0: 		return id.getKeyColumnPosition(heapColumnPosition);
0: 	}
0: 
0: 	/** @see IndexDescriptor#getKeyColumnPosition */
0: 	public int getKeyColumnPosition(int heapColumnPosition)
0: 	{
0: 		return id.getKeyColumnPosition(heapColumnPosition);
0: 	}
0: 
0: 	/** @see IndexDescriptor#numberOfOrderedColumns */
0: 	public int numberOfOrderedColumns()
0: 	{
0: 		return id.numberOfOrderedColumns();
0: 	}
0: 
0: 	/** @see IndexDescriptor#indexType */
0: 	public String indexType()
0: 	{
0: 		return id.indexType();
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		return id.toString();
0: 	}
0: 
0: 	/** @see IndexDescriptor#isAscending */
0: 	public boolean			isAscending(Integer keyColumnPosition)
0: 	{
0: 		return id.isAscending(keyColumnPosition);
0: 	}
0: 
0: 	/** @see IndexDescriptor#isDescending */
0: 	public boolean			isDescending(Integer keyColumnPosition)
0: 	{
0: 		return id.isDescending(keyColumnPosition);
0: 	}
0: 
0: 	/** @see IndexDescriptor#isAscending */
0: 	public boolean[]		isAscending()
0: 	{
0: 		return id.isAscending();
0: 	}
0: 
0: 	/** @see IndexDescriptor#setBaseColumnPositions */
0: 	public void		setBaseColumnPositions(int[] baseColumnPositions)
0: 	{
0: 		id.setBaseColumnPositions(baseColumnPositions);
0: 	}
0: 
0: 	/** @see IndexDescriptor#setIsAscending */
0: 	public void		setIsAscending(boolean[] isAscending)
0: 	{
0: 		id.setIsAscending(isAscending);
0: 	}
0: 
0: 	/** @see IndexDescriptor#setNumberOfOrderedColumns */
0: 	public void		setNumberOfOrderedColumns(int numberOfOrderedColumns)
0: 	{
0: 		id.setNumberOfOrderedColumns(numberOfOrderedColumns);
0: 	}
0: 
0: 	/**
0: 	 * Test for value equality
0: 	 *
0: 	 * @param other		The other indexrowgenerator to compare this one with
0: 	 *
0: 	 * @return	true if this indexrowgenerator has the same value as other
0: 	 */
0: 
0: 	public boolean equals(Object other)
0: 	{
0: 		return id.equals(other);
0: 	}
0: 
0: 	/**
0: 	  @see java.lang.Object#hashCode
0: 	  */
0: 	public int hashCode()
0: 	{
0: 		return id.hashCode();
0: 	}
0: 
0: 	private ExecutionFactory getExecutionFactory()
0: 	{
0: 		if (ef == null)
0: 		{
0: 			ExecutionContext	ec;
0: 
0: 			ec = (ExecutionContext)
0: 					ContextService.getContext(ExecutionContext.CONTEXT_ID);
0: 			ef = ec.getExecutionFactory();
0: 		}
0: 		return ef;
0: 	}
0: 
0: 	////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// EXTERNALIZABLE
0: 	//
0: 	////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on read error
0: 	 * @exception ClassNotFoundException	Thrown on read error
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
0: 	{
0: 		id = (IndexDescriptor)in.readObject();
0: 	}
0: 
0: 	/**
0: 	 *
0: 	 * @exception IOException	Thrown on write error
0: 	 */
0: 	public void writeExternal(ObjectOutput out) throws IOException
0: 	{
0: 		out.writeObject(id);
0: 	}
0: 
0: 	/* TypedFormat interface */
0: 	public int getTypeFormatId()
0: 	{
0: 		return StoredFormatIds.INDEX_ROW_GENERATOR_V01_ID;
0: 	}
0: 
0: }
============================================================================