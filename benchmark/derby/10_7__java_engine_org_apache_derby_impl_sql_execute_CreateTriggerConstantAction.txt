2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.CreateTriggerConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
7:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:6bd3847: import org.apache.derby.iapi.services.property.PropertyUtil;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1:6bd3847: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:cc67949: import org.apache.derby.iapi.sql.depend.Provider;
1:cc67949: import org.apache.derby.iapi.sql.depend.ProviderInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:eac0369: import java.sql.Timestamp;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * This class  describes actions that are ALWAYS performed for a
1:eac0369:  * CREATE TRIGGER Statement at Execution time.  
1:eac0369:  *
1:eac0369:  */
1:eac0369: class CreateTriggerConstantAction extends DDLSingleTableConstantAction
2:eac0369: {
1:eac0369: 
1:eac0369: 	private String					triggerName;
1:eac0369: 	private String					triggerSchemaName;
1:eac0369: 	private TableDescriptor			triggerTable;		// null after readExternal
1:eac0369: 	private UUID					triggerTableId;		// set in readExternal
1:eac0369: 	private int						eventMask;
1:eac0369: 	private boolean					isBefore;
1:eac0369: 	private boolean					isRow;
1:eac0369: 	private boolean					isEnabled;
1:eac0369: 	private boolean					referencingOld;
1:eac0369: 	private boolean					referencingNew;
1:eac0369: 	private UUID					whenSPSId;
1:eac0369: 	private String					whenText;
1:eac0369: 	private UUID					actionSPSId;
1:eac0369: 	private String					actionText;
1:d9878ca:     private final String            originalWhenText;
1:eac0369: 	private String					originalActionText;
1:eac0369: 	private String					oldReferencingName;
1:eac0369: 	private String					newReferencingName;
1:eac0369: 	private UUID					spsCompSchemaId;
1:eac0369: 	private int[]					referencedCols;
1:a6f9586: 	private int[]					referencedColsInTriggerAction;
1:cc67949:     private final ProviderInfo[]    providerInfo;
1:eac0369: 
1:eac0369: 	// CONSTRUCTORS
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
1:eac0369: 	 *
1:eac0369: 	 * @param triggerSchemaName	name for the schema that trigger lives in.
1:eac0369: 	 * @param triggerName	Name of trigger
1:eac0369: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
1:eac0369: 	 * @param isBefore		is this a before (as opposed to after) trigger 
1:eac0369: 	 * @param isRow			is this a row trigger or statement trigger
1:eac0369: 	 * @param isEnabled		is this trigger enabled or disabled
1:eac0369: 	 * @param triggerTable	the table upon which this trigger is defined
1:eac0369: 	 * @param whenSPSId		the sps id for the when clause (may be null)
1:eac0369: 	 * @param whenText		the text of the when clause (may be null)
1:eac0369: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1:eac0369: 	 * @param actionText	the text of the trigger action
1:eac0369: 	 * @param spsCompSchemaId	the compilation schema for the action and when
1:eac0369: 	 *							spses.   If null, will be set to the current default
1:eac0369: 	 *							schema
1:eac0369: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1:a6f9586: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1:a6f9586: 	 *						action reference through old/new transition variables
1:a6f9586: 	 *						(may be null)
1:d9878ca:      * @param originalWhenText The original user text of the WHEN clause (may be null)
1:eac0369: 	 * @param originalActionText The original user text of the trigger action
1:eac0369: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1:eac0369: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1:eac0369: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERENCING clause
1:eac0369: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERENCING clause
1:cc67949:      * @param providerInfo  array of providers that the trigger depends on
1:eac0369: 	 */
1:eac0369: 	CreateTriggerConstantAction
1:eac0369: 	(
1:eac0369: 		String				triggerSchemaName,
1:eac0369: 		String				triggerName,
1:eac0369: 		int					eventMask,
1:eac0369: 		boolean				isBefore,
1:eac0369: 		boolean 			isRow,
1:eac0369: 		boolean 			isEnabled,
1:eac0369: 		TableDescriptor		triggerTable,
1:eac0369: 		UUID				whenSPSId,
1:eac0369: 		String				whenText,
1:eac0369: 		UUID				actionSPSId,
1:eac0369: 		String				actionText,
1:eac0369: 		UUID				spsCompSchemaId,
1:eac0369: 		int[]				referencedCols,
1:a6f9586: 		int[]				referencedColsInTriggerAction,
1:d9878ca:         String              originalWhenText,
1:eac0369: 		String				originalActionText,
1:eac0369: 		boolean				referencingOld,
1:eac0369: 		boolean				referencingNew,
1:eac0369: 		String				oldReferencingName,
1:cc67949:         String              newReferencingName,
1:cc67949:         ProviderInfo[]      providerInfo
1:eac0369: 	)
1:eac0369: 	{
1:eac0369: 		super(triggerTable.getUUID());
1:eac0369: 		this.triggerName = triggerName;
1:eac0369: 		this.triggerSchemaName = triggerSchemaName;
1:eac0369: 		this.triggerTable = triggerTable;
1:eac0369: 		this.eventMask = eventMask;
1:eac0369: 		this.isBefore = isBefore;
1:eac0369: 		this.isRow = isRow;
1:eac0369: 		this.isEnabled = isEnabled;
1:eac0369: 		this.whenSPSId = whenSPSId;
1:eac0369: 		this.whenText = whenText;
1:eac0369: 		this.actionSPSId = actionSPSId;
1:eac0369: 		this.actionText = actionText;
1:eac0369: 		this.spsCompSchemaId = spsCompSchemaId;
1:eac0369: 		this.referencedCols = referencedCols;
1:a6f9586: 		this.referencedColsInTriggerAction = referencedColsInTriggerAction;
1:eac0369: 		this.originalActionText = originalActionText;
1:d9878ca:         this.originalWhenText = originalWhenText;
1:eac0369: 		this.referencingOld = referencingOld;
1:eac0369: 		this.referencingNew = referencingNew;
1:eac0369: 		this.oldReferencingName = oldReferencingName;
1:eac0369: 		this.newReferencingName = newReferencingName;
1:cc67949:         this.providerInfo = providerInfo;
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(triggerSchemaName != null, "triggerSchemaName sd is null");
1:eac0369: 			SanityManager.ASSERT(triggerName != null, "trigger name is null");
1:eac0369: 			SanityManager.ASSERT(triggerTable != null, "triggerTable is null");
1:eac0369: 			SanityManager.ASSERT(actionText != null, "actionText is null");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This is the guts of the Execution-time logic for CREATE TRIGGER.
1:eac0369: 	 *
1:eac0369: 	 * @see ConstantAction#executeConstantAction
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:eac0369: 	public void	executeConstantAction(Activation activation)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		SPSDescriptor				whenspsd = null;
1:eac0369: 		SPSDescriptor				actionspsd;
1:eac0369: 
1:eac0369: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1:eac0369: 		DataDictionary dd = lcc.getDataDictionary();
1:eac0369: 		DependencyManager dm = dd.getDependencyManager();
1:eac0369: 		TransactionController tc = lcc.getTransactionExecute();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Indicate that we are about to modify the data dictionary.
1:eac0369: 		** 
1:eac0369: 		** We tell the data dictionary we're done writing at the end of
1:eac0369: 		** the transaction.
1:eac0369: 		*/
1:eac0369: 		dd.startWriting(lcc);
1:eac0369: 
1:eac0369: 		SchemaDescriptor triggerSd = getSchemaDescriptorForCreate(dd, activation, triggerSchemaName);
1:eac0369: 
1:94f95a4: 		if (spsCompSchemaId == null) {
1:94f95a4: 			SchemaDescriptor def = lcc.getDefaultSchema();
1:94f95a4: 			if (def.getUUID() == null) {
1:94f95a4: 				// Descriptor for default schema is stale,
1:94f95a4: 				// look it up in the dictionary
1:94f95a4: 				def = dd.getSchemaDescriptor(def.getDescriptorName(), tc, 
1:94f95a4: 											 false);
1:eac0369: 			}
1:16c8b88: 			
1:16c8b88: 			/* 
1:16c8b88: 			** It is possible for spsCompSchemaId to be null.  For instance, 
1:16c8b88: 			** the current schema may not have been physically created yet but 
1:16c8b88: 			** it exists "virtually".  In this case, its UUID will have the 
1:16c8b88: 			** value of null meaning that it is not persistent.  e.g.:   
1:16c8b88: 			**
1:16c8b88: 			** CONNECT 'db;create=true' user 'ernie';
1:16c8b88: 			** CREATE TABLE bert.t1 (i INT);
1:16c8b88: 			** CREATE TRIGGER bert.tr1 AFTER INSERT ON bert.t1 
1:16c8b88: 			**    FOR EACH STATEMENT MODE DB2SQL 
1:16c8b88: 			**    SELECT * FROM SYS.SYSTABLES;
1:16c8b88: 			**
1:16c8b88: 			** Note that in the above case, the trigger action statement have a 
1:16c8b88: 			** null compilation schema.  A compilation schema with null value 
1:16c8b88: 			** indicates that the trigger action statement text does not have 
1:16c8b88: 			** any dependencies with the CURRENT SCHEMA.  This means:
1:16c8b88: 			**
1:16c8b88: 			** o  It is safe to compile this statement in any schema since 
1:16c8b88: 			**    there is no dependency with the CURRENT SCHEMA. i.e.: All 
1:16c8b88: 			**    relevent identifiers are qualified with a specific schema.
1:16c8b88: 			**
1:16c8b88: 			** o  The statement cache mechanism can utilize this piece of 
1:16c8b88: 			**    information to enable better statement plan sharing across 
1:16c8b88: 			**    connections in different schemas; thus, avoiding unnecessary 
1:16c8b88: 			**    statement compilation.
1:16c8b88: 			*/ 
1:16c8b88: 			if (def != null)
1:16c8b88: 				spsCompSchemaId = def.getUUID();
3:94f95a4: 		}
1:eac0369: 
1:eac0369: 		String tabName;
1:eac0369: 		if (triggerTable != null)
1:eac0369: 		{
1:eac0369: 			triggerTableId = triggerTable.getUUID();
1:eac0369: 			tabName = triggerTable.getName();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 			tabName = "with UUID " + triggerTableId;
1:eac0369: 
1:eac0369: 		/* We need to get table descriptor again.  We simply can't trust the
1:eac0369: 		 * one we got at compile time, the lock on system table was released
1:eac0369: 		 * when compile was done, and the table might well have been dropped.
1:eac0369: 		 */
1:eac0369: 		triggerTable = dd.getTableDescriptor(triggerTableId);
1:eac0369: 		if (triggerTable == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1:eac0369: 								tabName);
1:eac0369: 		}
1:eac0369: 		/* Lock the table for DDL.  Otherwise during our execution, the table
1:eac0369: 		 * might be changed, even dropped.  Beetle 4269
1:eac0369: 		 */
1:eac0369: 		lockTableForDDL(tc, triggerTable.getHeapConglomerateId(), true);
1:eac0369: 		/* get triggerTable again for correctness, in case it's changed before
1:eac0369: 		 * the lock is aquired
1:eac0369: 		 */
1:eac0369: 		triggerTable = dd.getTableDescriptor(triggerTableId);
1:eac0369: 		if (triggerTable == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(
1:eac0369: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1:eac0369: 								tabName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Send an invalidate on the table from which
1:eac0369: 		** the triggering event emanates.  This it
1:eac0369: 		** to make sure that DML statements on this table
1:eac0369: 		** will be recompiled.  Do this before we create
1:eac0369: 		** our trigger spses lest we invalidate them just
1:eac0369: 		** after creating them.
1:eac0369: 		*/
1:eac0369: 		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Lets get our trigger id up front, we'll use it when
1:eac0369: 	 	** we create our spses.
1:eac0369: 		*/
1:eac0369: 		UUID tmpTriggerId = dd.getUUIDFactory().createUUID();
1:eac0369: 
1:dd2accd: 		actionSPSId = (actionSPSId == null) ? 
1:dd2accd: 			dd.getUUIDFactory().createUUID() : actionSPSId;
1:1725dd1: 
1:1725dd1:         if (whenSPSId == null && whenText != null) {
1:1725dd1:             whenSPSId = dd.getUUIDFactory().createUUID();
1:1725dd1:         }
1:dd2accd:  
1:eac0369: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
1:eac0369: 
1:eac0369: 		/*
1:dd2accd: 		** Create the trigger descriptor first so the trigger action
1:dd2accd: 		** compilation can pick up the relevant trigger especially in 
1:dd2accd: 		** the case of self triggering.
1:eac0369: 		*/
1:dd2accd: 		TriggerDescriptor triggerd =
1:eac0369: 				ddg.newTriggerDescriptor(
1:eac0369: 									triggerSd,
1:eac0369: 									tmpTriggerId,
1:eac0369: 									triggerName,
1:eac0369: 									eventMask,
1:eac0369: 									isBefore,
1:eac0369: 									isRow,
1:eac0369: 									isEnabled,
1:eac0369: 									triggerTable,
1:1725dd1:                                     whenSPSId,
1:dd2accd: 									actionSPSId,
1:6bd3847:                                     makeCreationTimestamp(dd),
1:eac0369: 									referencedCols,
1:a6f9586: 									referencedColsInTriggerAction,
1:eac0369: 									originalActionText,
1:eac0369: 									referencingOld,
1:eac0369: 									referencingNew,
1:eac0369: 									oldReferencingName,
1:d9878ca:                                     newReferencingName,
1:d9878ca:                                     originalWhenText);
1:eac0369: 
1:eac0369: 
1:eac0369: 		dd.addDescriptor(triggerd, triggerSd,
1:eac0369: 								DataDictionary.SYSTRIGGERS_CATALOG_NUM, false,
1:eac0369: 								tc);
1:dd2accd: 
1:eac0369: 
1:dd2accd: 		/*	
1:dd2accd: 		** If we have a WHEN action we create it now.
1:dd2accd: 		*/
1:dd2accd: 		if (whenText != null)
1:dd2accd: 		{
1:d9878ca:             // The WHEN clause is just a search condition and not a full
1:d9878ca:             // SQL statement. Turn in into a VALUES statement.
1:d9878ca:             String whenValuesStmt = "VALUES " + whenText;
1:dd2accd: 			whenspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
1:d9878ca:                 whenSPSId, spsCompSchemaId, whenValuesStmt, true, triggerTable);
1:dd2accd: 		}
1:dd2accd: 
1:dd2accd: 		/*
1:dd2accd: 		** Create the trigger action
1:dd2accd: 		*/
1:dd2accd: 		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
1:dd2accd: 						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);
1:dd2accd: 		
1:eac0369: 		/*
1:eac0369: 		** Make underlying spses dependent on the trigger.
1:eac0369: 		*/
1:eac0369: 		if (whenspsd != null)
1:eac0369: 		{
1:eac0369: 			dm.addDependency(triggerd, whenspsd, lcc.getContextManager());
1:eac0369: 		}
1:eac0369: 		dm.addDependency(triggerd, actionspsd, lcc.getContextManager());
1:eac0369: 		dm.addDependency(triggerd, triggerTable, lcc.getContextManager());
1:cc67949: 
1:cc67949:         // Make the TriggerDescriptor dependent on all objects referenced
1:cc67949:         // from the triggered statement or the WHEN clause.
1:cc67949:         for (ProviderInfo info : providerInfo) {
1:cc67949:             Provider provider = (Provider) info.getDependableFinder()
1:cc67949:                     .getDependable(dd, info.getObjectId());
1:cc67949:             dm.addDependency(triggerd, provider, lcc.getContextManager());
1:cc67949:         }
1:cc67949: 
1:2d2e717: 		//store trigger's dependency on various privileges in the dependeny system
1:2d2e717: 		storeViewTriggerDependenciesOnPrivileges(activation, triggerd);		
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Create an sps that is used by the trigger.
1:eac0369: 	*/
1:eac0369: 	private SPSDescriptor createSPS
1:eac0369: 	(
1:eac0369: 		LanguageConnectionContext	lcc,
1:eac0369: 		DataDescriptorGenerator 	ddg,
1:eac0369: 		DataDictionary				dd,
1:eac0369: 		TransactionController		tc,
1:eac0369: 		UUID						triggerId,
1:eac0369: 		SchemaDescriptor			sd,
1:eac0369: 		UUID						spsId,
1:eac0369: 		UUID						compSchemaId,
1:eac0369: 		String						text,
1:eac0369: 		boolean						isWhen,
1:eac0369: 		TableDescriptor				triggerTable
1:eac0369: 	) throws StandardException	
1:eac0369: 	{
1:eac0369: 		if (text == null)
1:eac0369: 		{
1:eac0369: 			return null; 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Note: the format of this string is very important.
1:eac0369: 		** Dont change it arbitrarily -- see sps code.
1:eac0369: 		*/
1:eac0369: 		String spsName = "TRIGGER" + 
1:eac0369: 						(isWhen ? "WHEN_" : "ACTN_") + 
1:eac0369: 						triggerId + "_" + triggerTable.getUUID().toString();
1:eac0369: 
1:eac0369: 		SPSDescriptor spsd = new SPSDescriptor(dd, spsName,
1:eac0369: 									(spsId == null) ?
1:eac0369: 										dd.getUUIDFactory().createUUID() :
1:eac0369: 										spsId,
1:eac0369: 									sd.getUUID(),
1:eac0369: 									compSchemaId == null ?
1:eac0369: 										lcc.getDefaultSchema().getUUID() :
1:eac0369: 										compSchemaId,
1:eac0369: 									SPSDescriptor.SPS_TYPE_TRIGGER,
1:eac0369: 									true,				// it is valid
1:eac0369: 									text,				// the text
1:eac0369: 									true );	// no defaults
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Prepared the stored prepared statement
1:eac0369: 		** and release the activation class -- we
1:eac0369: 		** know we aren't going to execute statement
1:eac0369: 		** after create it, so for now we are finished.
1:eac0369: 		*/
1:eac0369: 		spsd.prepareAndRelease(lcc, triggerTable);
1:eac0369: 
1:eac0369: 
1:8106edc: 		dd.addSPSDescriptor(spsd, tc);
1:eac0369: 
1:eac0369: 		return spsd;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		return constructToString("CREATE TRIGGER ", triggerName);		
1:eac0369: 	}
1:6bd3847: 
1:6bd3847:     /**
1:6bd3847:      * Construct the creation timestamp for the trigger. DERBY-5866: Also make
1:6bd3847:      * sure the creation timestamp is higher than any timestamp on an existing
1:6bd3847:      * trigger on the same table. Otherwise, the triggers may not fire in the
1:6bd3847:      * correct order.
1:6bd3847:      */
1:6bd3847:     private Timestamp makeCreationTimestamp(DataDictionary dd)
1:6bd3847:             throws StandardException {
1:6bd3847:         Timestamp now = new Timestamp(System.currentTimeMillis());
1:6bd3847: 
1:6bd3847:         // Allow overriding the timestamp in debug mode for testing of
1:6bd3847:         // specific scenarios.
1:6bd3847:         if (SanityManager.DEBUG) {
1:6bd3847:             String val = PropertyUtil.getSystemProperty(
1:6bd3847:                     "derby.debug.overrideTriggerCreationTimestamp");
1:6bd3847:             if (val != null) {
1:6bd3847:                 now.setTime(Long.parseLong(val));
1:6bd3847:             }
1:6bd3847:         }
1:6bd3847: 
1:6bd3847:         TriggerDescriptorList tdl = dd.getTriggerDescriptors(triggerTable);
1:6bd3847:         int numTriggers = tdl.size();
1:6bd3847: 
1:6bd3847:         if (numTriggers == 0) {
1:6bd3847:             // This is the first trigger on the table, so no need to check
1:6bd3847:             // if there are any higher timestamps.
1:6bd3847:             return now;
1:6bd3847:         }
1:6bd3847: 
1:6bd3847:         // Get the timestamp of the most recent existing trigger on the table.
1:6bd3847:         Timestamp highest = tdl.get(numTriggers - 1).getCreationTimestamp();
1:6bd3847: 
1:6bd3847:         if (now.after(highest)) {
1:6bd3847:             // The current timestamp is higher than the most recent existing
1:6bd3847:             // trigger on the table, so it is OK.
1:6bd3847:             return now;
1:6bd3847:         }
1:6bd3847: 
1:6bd3847:         // Otherwise, there is an existing trigger on the table with a
1:6bd3847:         // timestamp that is at least as high as the current timestamp. Adjust
1:6bd3847:         // the current timestamp so that it is one millisecond higher than the
1:6bd3847:         // timestamp of the existing trigger. This ensures that the triggers
1:6bd3847:         // will fire in the same order as they were created.
1:6bd3847: 
1:6bd3847:         now.setTime(highest.getTime() + 1);
1:6bd3847: 
1:6bd3847:         return now;
1:6bd3847:     }
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6bd3847
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.property.PropertyUtil;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptorList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                                     makeCreationTimestamp(dd),
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Construct the creation timestamp for the trigger. DERBY-5866: Also make
1:      * sure the creation timestamp is higher than any timestamp on an existing
1:      * trigger on the same table. Otherwise, the triggers may not fire in the
1:      * correct order.
1:      */
1:     private Timestamp makeCreationTimestamp(DataDictionary dd)
1:             throws StandardException {
1:         Timestamp now = new Timestamp(System.currentTimeMillis());
1: 
1:         // Allow overriding the timestamp in debug mode for testing of
1:         // specific scenarios.
1:         if (SanityManager.DEBUG) {
1:             String val = PropertyUtil.getSystemProperty(
1:                     "derby.debug.overrideTriggerCreationTimestamp");
1:             if (val != null) {
1:                 now.setTime(Long.parseLong(val));
1:             }
1:         }
1: 
1:         TriggerDescriptorList tdl = dd.getTriggerDescriptors(triggerTable);
1:         int numTriggers = tdl.size();
1: 
1:         if (numTriggers == 0) {
1:             // This is the first trigger on the table, so no need to check
1:             // if there are any higher timestamps.
1:             return now;
1:         }
1: 
1:         // Get the timestamp of the most recent existing trigger on the table.
1:         Timestamp highest = tdl.get(numTriggers - 1).getCreationTimestamp();
1: 
1:         if (now.after(highest)) {
1:             // The current timestamp is higher than the most recent existing
1:             // trigger on the table, so it is OK.
1:             return now;
1:         }
1: 
1:         // Otherwise, there is an existing trigger on the table with a
1:         // timestamp that is at least as high as the current timestamp. Adjust
1:         // the current timestamp so that it is one millisecond higher than the
1:         // timestamp of the existing trigger. This ensures that the triggers
1:         // will fire in the same order as they were created.
1: 
1:         now.setTime(highest.getTime() + 1);
1: 
1:         return now;
1:     }
commit:cc67949
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.depend.ProviderInfo;
/////////////////////////////////////////////////////////////////////////
1:     private final ProviderInfo[]    providerInfo;
/////////////////////////////////////////////////////////////////////////
1:      * @param providerInfo  array of providers that the trigger depends on
/////////////////////////////////////////////////////////////////////////
1:         String              newReferencingName,
1:         ProviderInfo[]      providerInfo
/////////////////////////////////////////////////////////////////////////
1:         this.providerInfo = providerInfo;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Make the TriggerDescriptor dependent on all objects referenced
1:         // from the triggered statement or the WHEN clause.
1:         for (ProviderInfo info : providerInfo) {
1:             Provider provider = (Provider) info.getDependableFinder()
1:                     .getDependable(dd, info.getObjectId());
1:             dm.addDependency(triggerd, provider, lcc.getContextManager());
1:         }
1: 
commit:d9878ca
/////////////////////////////////////////////////////////////////////////
1:     private final String            originalWhenText;
/////////////////////////////////////////////////////////////////////////
1:      * @param originalWhenText The original user text of the WHEN clause (may be null)
/////////////////////////////////////////////////////////////////////////
1:         String              originalWhenText,
/////////////////////////////////////////////////////////////////////////
1:         this.originalWhenText = originalWhenText;
/////////////////////////////////////////////////////////////////////////
1:                                     newReferencingName,
1:                                     originalWhenText);
/////////////////////////////////////////////////////////////////////////
1:             // The WHEN clause is just a search condition and not a full
1:             // SQL statement. Turn in into a VALUES statement.
1:             String whenValuesStmt = "VALUES " + whenText;
1:                 whenSPSId, spsCompSchemaId, whenValuesStmt, true, triggerTable);
commit:1725dd1
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (whenSPSId == null && whenText != null) {
1:             whenSPSId = dd.getUUIDFactory().createUUID();
1:         }
/////////////////////////////////////////////////////////////////////////
1:                                     whenSPSId,
commit:8106edc
/////////////////////////////////////////////////////////////////////////
1: 		dd.addSPSDescriptor(spsd, tc);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:16c8b88
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			/* 
1: 			** It is possible for spsCompSchemaId to be null.  For instance, 
1: 			** the current schema may not have been physically created yet but 
1: 			** it exists "virtually".  In this case, its UUID will have the 
1: 			** value of null meaning that it is not persistent.  e.g.:   
1: 			**
1: 			** CONNECT 'db;create=true' user 'ernie';
1: 			** CREATE TABLE bert.t1 (i INT);
1: 			** CREATE TRIGGER bert.tr1 AFTER INSERT ON bert.t1 
1: 			**    FOR EACH STATEMENT MODE DB2SQL 
1: 			**    SELECT * FROM SYS.SYSTABLES;
1: 			**
1: 			** Note that in the above case, the trigger action statement have a 
1: 			** null compilation schema.  A compilation schema with null value 
1: 			** indicates that the trigger action statement text does not have 
1: 			** any dependencies with the CURRENT SCHEMA.  This means:
1: 			**
1: 			** o  It is safe to compile this statement in any schema since 
1: 			**    there is no dependency with the CURRENT SCHEMA. i.e.: All 
1: 			**    relevent identifiers are qualified with a specific schema.
1: 			**
1: 			** o  The statement cache mechanism can utilize this piece of 
1: 			**    information to enable better statement plan sharing across 
1: 			**    connections in different schemas; thus, avoiding unnecessary 
1: 			**    statement compilation.
1: 			*/ 
1: 			if (def != null)
1: 				spsCompSchemaId = def.getUUID();
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:95971f2
/////////////////////////////////////////////////////////////////////////
commit:a6f9586
/////////////////////////////////////////////////////////////////////////
1: 	private int[]					referencedColsInTriggerAction;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param referencedColsInTriggerAction	what columns does the trigger 
1: 	 *						action reference through old/new transition variables
1: 	 *						(may be null)
/////////////////////////////////////////////////////////////////////////
1: 		int[]				referencedColsInTriggerAction,
/////////////////////////////////////////////////////////////////////////
1: 		this.referencedColsInTriggerAction = referencedColsInTriggerAction;
/////////////////////////////////////////////////////////////////////////
1: 									referencedColsInTriggerAction,
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:dd2accd
/////////////////////////////////////////////////////////////////////////
1: 		actionSPSId = (actionSPSId == null) ? 
1: 			dd.getUUIDFactory().createUUID() : actionSPSId;
1:  
1: 		** Create the trigger descriptor first so the trigger action
1: 		** compilation can pick up the relevant trigger especially in 
1: 		** the case of self triggering.
1: 		TriggerDescriptor triggerd =
/////////////////////////////////////////////////////////////////////////
1: 									actionSPSId,
/////////////////////////////////////////////////////////////////////////
1: 
1: 		/*	
1: 		** If we have a WHEN action we create it now.
1: 		*/
1: 		if (whenText != null)
1: 		{
1: 			whenspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
0: 						whenSPSId, spsCompSchemaId, whenText, true, triggerTable);
1: 		}
1: 
1: 		/*
1: 		** Create the trigger action
1: 		*/
1: 		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
1: 						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);
1: 		
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ddd8800
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		//store trigger's dependency on various privileges in the dependeny system
1: 		storeViewTriggerDependenciesOnPrivileges(activation, triggerd);		
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.CreateTriggerConstantAction
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.context.ContextService;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: import java.sql.Timestamp;
1: 
1: /**
1:  * This class  describes actions that are ALWAYS performed for a
1:  * CREATE TRIGGER Statement at Execution time.  
1:  *
0:  *	@author Jamie
1:  */
1: class CreateTriggerConstantAction extends DDLSingleTableConstantAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1: 	private String					triggerName;
1: 	private String					triggerSchemaName;
1: 	private TableDescriptor			triggerTable;		// null after readExternal
1: 	private UUID					triggerTableId;		// set in readExternal
1: 	private int						eventMask;
1: 	private boolean					isBefore;
1: 	private boolean					isRow;
1: 	private boolean					isEnabled;
1: 	private boolean					referencingOld;
1: 	private boolean					referencingNew;
1: 	private UUID					whenSPSId;
1: 	private String					whenText;
1: 	private UUID					actionSPSId;
1: 	private String					actionText;
1: 	private String					originalActionText;
1: 	private String					oldReferencingName;
1: 	private String					newReferencingName;
1: 	private UUID					spsCompSchemaId;
0: 	private Timestamp				creationTimestamp;
1: 	private int[]					referencedCols;
1: 
1: 	// CONSTRUCTORS
1: 
1: 	/**
1: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
1: 	 *
1: 	 * @param triggerSchemaName	name for the schema that trigger lives in.
1: 	 * @param triggerName	Name of trigger
1: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
1: 	 * @param isBefore		is this a before (as opposed to after) trigger 
1: 	 * @param isRow			is this a row trigger or statement trigger
1: 	 * @param isEnabled		is this trigger enabled or disabled
1: 	 * @param triggerTable	the table upon which this trigger is defined
1: 	 * @param whenSPSId		the sps id for the when clause (may be null)
1: 	 * @param whenText		the text of the when clause (may be null)
1: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
1: 	 * @param actionText	the text of the trigger action
1: 	 * @param spsCompSchemaId	the compilation schema for the action and when
1: 	 *							spses.   If null, will be set to the current default
1: 	 *							schema
0: 	 * @param creationTimestamp	when was this trigger created?  if null, will be
0: 	 *						set to the time that executeConstantAction() is invoked
1: 	 * @param referencedCols	what columns does this trigger reference (may be null)
1: 	 * @param originalActionText The original user text of the trigger action
1: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
1: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
1: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERENCING clause
1: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERENCING clause
1: 	 */
1: 	CreateTriggerConstantAction
1: 	(
1: 		String				triggerSchemaName,
1: 		String				triggerName,
1: 		int					eventMask,
1: 		boolean				isBefore,
1: 		boolean 			isRow,
1: 		boolean 			isEnabled,
1: 		TableDescriptor		triggerTable,
1: 		UUID				whenSPSId,
1: 		String				whenText,
1: 		UUID				actionSPSId,
1: 		String				actionText,
1: 		UUID				spsCompSchemaId,
0: 		Timestamp			creationTimestamp,
1: 		int[]				referencedCols,
1: 		String				originalActionText,
1: 		boolean				referencingOld,
1: 		boolean				referencingNew,
1: 		String				oldReferencingName,
0: 		String				newReferencingName
1: 	)
1: 	{
1: 		super(triggerTable.getUUID());
1: 		this.triggerName = triggerName;
1: 		this.triggerSchemaName = triggerSchemaName;
1: 		this.triggerTable = triggerTable;
1: 		this.eventMask = eventMask;
1: 		this.isBefore = isBefore;
1: 		this.isRow = isRow;
1: 		this.isEnabled = isEnabled;
1: 		this.whenSPSId = whenSPSId;
1: 		this.whenText = whenText;
1: 		this.actionSPSId = actionSPSId;
1: 		this.actionText = actionText;
1: 		this.spsCompSchemaId = spsCompSchemaId;
0: 		this.creationTimestamp = creationTimestamp;
1: 		this.referencedCols = referencedCols;
1: 		this.originalActionText = originalActionText;
1: 		this.referencingOld = referencingOld;
1: 		this.referencingNew = referencingNew;
1: 		this.oldReferencingName = oldReferencingName;
1: 		this.newReferencingName = newReferencingName;
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(triggerSchemaName != null, "triggerSchemaName sd is null");
1: 			SanityManager.ASSERT(triggerName != null, "trigger name is null");
1: 			SanityManager.ASSERT(triggerTable != null, "triggerTable is null");
1: 			SanityManager.ASSERT(actionText != null, "actionText is null");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * This is the guts of the Execution-time logic for CREATE TRIGGER.
1: 	 *
1: 	 * @see ConstantAction#executeConstantAction
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	public void	executeConstantAction(Activation activation)
1: 						throws StandardException
1: 	{
1: 		SPSDescriptor				whenspsd = null;
1: 		SPSDescriptor				actionspsd;
1: 
1: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 		DependencyManager dm = dd.getDependencyManager();
1: 		TransactionController tc = lcc.getTransactionExecute();
1: 
1: 		/*
1: 		** Indicate that we are about to modify the data dictionary.
1: 		** 
1: 		** We tell the data dictionary we're done writing at the end of
1: 		** the transaction.
1: 		*/
1: 		dd.startWriting(lcc);
1: 
1: 		SchemaDescriptor triggerSd = getSchemaDescriptorForCreate(dd, activation, triggerSchemaName);
1: 
1: 		String tabName;
1: 		if (triggerTable != null)
1: 		{
1: 			triggerTableId = triggerTable.getUUID();
1: 			tabName = triggerTable.getName();
1: 		}
1: 		else
1: 			tabName = "with UUID " + triggerTableId;
1: 
1: 		/* We need to get table descriptor again.  We simply can't trust the
1: 		 * one we got at compile time, the lock on system table was released
1: 		 * when compile was done, and the table might well have been dropped.
1: 		 */
1: 		triggerTable = dd.getTableDescriptor(triggerTableId);
1: 		if (triggerTable == null)
1: 		{
1: 			throw StandardException.newException(
1: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1: 								tabName);
1: 		}
1: 		/* Lock the table for DDL.  Otherwise during our execution, the table
1: 		 * might be changed, even dropped.  Beetle 4269
1: 		 */
1: 		lockTableForDDL(tc, triggerTable.getHeapConglomerateId(), true);
1: 		/* get triggerTable again for correctness, in case it's changed before
1: 		 * the lock is aquired
1: 		 */
1: 		triggerTable = dd.getTableDescriptor(triggerTableId);
1: 		if (triggerTable == null)
1: 		{
1: 			throw StandardException.newException(
1: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1: 								tabName);
1: 		}
1: 
1: 		/*
1: 		** Send an invalidate on the table from which
1: 		** the triggering event emanates.  This it
1: 		** to make sure that DML statements on this table
1: 		** will be recompiled.  Do this before we create
1: 		** our trigger spses lest we invalidate them just
1: 		** after creating them.
1: 		*/
1: 		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);
1: 
1: 		/*
1: 		** Lets get our trigger id up front, we'll use it when
1: 	 	** we create our spses.
1: 		*/
1: 		UUID tmpTriggerId = dd.getUUIDFactory().createUUID();
1: 
1: 		/*	
0: 		** If we have a WHEN action we create it now.
1: 		*/ 
1: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
0: 		if (whenText != null)
1: 		{
0: 			whenspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
0: 						whenSPSId, spsCompSchemaId, whenText, true, triggerTable);
1: 		}
1: 
1: 		/*
0: 		** Create the trigger action
1: 		*/
0: 		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
0: 						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);
1: 		
0: 		TriggerDescriptor triggerd = 
1: 				ddg.newTriggerDescriptor(
1: 									triggerSd,
1: 									tmpTriggerId,
1: 									triggerName,
1: 									eventMask,
1: 									isBefore,
1: 									isRow,
1: 									isEnabled,
1: 									triggerTable,
0: 									whenspsd == null ? null : whenspsd.getUUID(),
0: 									actionspsd.getUUID(),
0: 									creationTimestamp == null ? new Timestamp(System.currentTimeMillis()) : creationTimestamp,
1: 									referencedCols,
1: 									originalActionText,
1: 									referencingOld,
1: 									referencingNew,
1: 									oldReferencingName,
0: 									newReferencingName);
1: 
1: 
1: 		dd.addDescriptor(triggerd, triggerSd,
1: 								DataDictionary.SYSTRIGGERS_CATALOG_NUM, false,
1: 								tc);
1: 
1: 		/*
1: 		** Make underlying spses dependent on the trigger.
1: 		*/
1: 		if (whenspsd != null)
1: 		{
1: 			dm.addDependency(triggerd, whenspsd, lcc.getContextManager());
1: 		}
1: 		dm.addDependency(triggerd, actionspsd, lcc.getContextManager());
1: 		dm.addDependency(triggerd, triggerTable, lcc.getContextManager());
0: 		dm.addDependency(actionspsd, triggerTable, lcc.getContextManager());
1: 	}
1: 
1: 
1: 	/*
1: 	** Create an sps that is used by the trigger.
1: 	*/
1: 	private SPSDescriptor createSPS
1: 	(
1: 		LanguageConnectionContext	lcc,
1: 		DataDescriptorGenerator 	ddg,
1: 		DataDictionary				dd,
1: 		TransactionController		tc,
1: 		UUID						triggerId,
1: 		SchemaDescriptor			sd,
1: 		UUID						spsId,
1: 		UUID						compSchemaId,
1: 		String						text,
1: 		boolean						isWhen,
1: 		TableDescriptor				triggerTable
1: 	) throws StandardException	
1: 	{
1: 		if (text == null)
1: 		{
1: 			return null; 
1: 		}
1: 
1: 		/*
1: 		** Note: the format of this string is very important.
1: 		** Dont change it arbitrarily -- see sps code.
1: 		*/
1: 		String spsName = "TRIGGER" + 
1: 						(isWhen ? "WHEN_" : "ACTN_") + 
1: 						triggerId + "_" + triggerTable.getUUID().toString();
1: 
1: 		SPSDescriptor spsd = new SPSDescriptor(dd, spsName,
1: 									(spsId == null) ?
1: 										dd.getUUIDFactory().createUUID() :
1: 										spsId,
1: 									sd.getUUID(),
1: 									compSchemaId == null ?
1: 										lcc.getDefaultSchema().getUUID() :
1: 										compSchemaId,
1: 									SPSDescriptor.SPS_TYPE_TRIGGER,
1: 									true,				// it is valid
1: 									text,				// the text
0: 									(String)null,		// no using clause
0: 									(Object[])null,
1: 									true );	// no defaults
1: 
1: 		/*
1: 		** Prepared the stored prepared statement
1: 		** and release the activation class -- we
1: 		** know we aren't going to execute statement
1: 		** after create it, so for now we are finished.
1: 		*/
1: 		spsd.prepareAndRelease(lcc, triggerTable);
1: 
1: 
0: 		dd.addSPSDescriptor(spsd, tc, true);
1: 
1: 		return spsd;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		return constructToString("CREATE TRIGGER ", triggerName);		
1: 	}
1: }
1: 
1: 
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:94f95a4
/////////////////////////////////////////////////////////////////////////
1: 		if (spsCompSchemaId == null) {
1: 			SchemaDescriptor def = lcc.getDefaultSchema();
1: 			if (def.getUUID() == null) {
1: 				// Descriptor for default schema is stale,
1: 				// look it up in the dictionary
1: 				def = dd.getSchemaDescriptor(def.getDescriptorName(), tc, 
1: 											 false);
1: 			}
0: 			spsCompSchemaId = def.getUUID();
1: 		}
0: 		if (SanityManager.DEBUG) { 
0: 			SanityManager.ASSERT(spsCompSchemaId != null,
0: 								 "spsCompSchemaId is null"); 
1: 		}
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SPSDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TriggerDescriptor;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.sql.Timestamp;
0: 
0: /**
0:  * This class  describes actions that are ALWAYS performed for a
0:  * CREATE TRIGGER Statement at Execution time.  
0:  *
0:  *	@author Jamie
0:  */
0: class CreateTriggerConstantAction extends DDLSingleTableConstantAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 
0: 	private String					triggerName;
0: 	private String					triggerSchemaName;
0: 	private TableDescriptor			triggerTable;		// null after readExternal
0: 	private UUID					triggerTableId;		// set in readExternal
0: 	private int						eventMask;
0: 	private boolean					isBefore;
0: 	private boolean					isRow;
0: 	private boolean					isEnabled;
0: 	private boolean					referencingOld;
0: 	private boolean					referencingNew;
0: 	private UUID					whenSPSId;
0: 	private String					whenText;
0: 	private UUID					actionSPSId;
0: 	private String					actionText;
0: 	private String					originalActionText;
0: 	private String					oldReferencingName;
0: 	private String					newReferencingName;
0: 	private UUID					spsCompSchemaId;
0: 	private Timestamp				creationTimestamp;
0: 	private int[]					referencedCols;
0: 
0: 	// CONSTRUCTORS
0: 
0: 	/**
0: 	 *	Make the ConstantAction for a CREATE TRIGGER statement.
0: 	 *
0: 	 * @param triggerSchemaName	name for the schema that trigger lives in.
0: 	 * @param triggerName	Name of trigger
0: 	 * @param eventMask		TriggerDescriptor.TRIGGER_EVENT_XXXX
0: 	 * @param isBefore		is this a before (as opposed to after) trigger 
0: 	 * @param isRow			is this a row trigger or statement trigger
0: 	 * @param isEnabled		is this trigger enabled or disabled
0: 	 * @param triggerTable	the table upon which this trigger is defined
0: 	 * @param whenSPSId		the sps id for the when clause (may be null)
0: 	 * @param whenText		the text of the when clause (may be null)
0: 	 * @param actionSPSId	the spsid for the trigger action (may be null)
0: 	 * @param actionText	the text of the trigger action
0: 	 * @param spsCompSchemaId	the compilation schema for the action and when
0: 	 *							spses.   If null, will be set to the current default
0: 	 *							schema
0: 	 * @param creationTimestamp	when was this trigger created?  if null, will be
0: 	 *						set to the time that executeConstantAction() is invoked
0: 	 * @param referencedCols	what columns does this trigger reference (may be null)
0: 	 * @param originalActionText The original user text of the trigger action
0: 	 * @param referencingOld whether or not OLD appears in REFERENCING clause
0: 	 * @param referencingNew whether or not NEW appears in REFERENCING clause
0: 	 * @param oldReferencingName old referencing table name, if any, that appears in REFERENCING clause
0: 	 * @param newReferencingName new referencing table name, if any, that appears in REFERENCING clause
0: 	 */
0: 	CreateTriggerConstantAction
0: 	(
0: 		String				triggerSchemaName,
0: 		String				triggerName,
0: 		int					eventMask,
0: 		boolean				isBefore,
0: 		boolean 			isRow,
0: 		boolean 			isEnabled,
0: 		TableDescriptor		triggerTable,
0: 		UUID				whenSPSId,
0: 		String				whenText,
0: 		UUID				actionSPSId,
0: 		String				actionText,
0: 		UUID				spsCompSchemaId,
0: 		Timestamp			creationTimestamp,
0: 		int[]				referencedCols,
0: 		String				originalActionText,
0: 		boolean				referencingOld,
0: 		boolean				referencingNew,
0: 		String				oldReferencingName,
0: 		String				newReferencingName
0: 	)
0: 	{
0: 		super(triggerTable.getUUID());
0: 		this.triggerName = triggerName;
0: 		this.triggerSchemaName = triggerSchemaName;
0: 		this.triggerTable = triggerTable;
0: 		this.eventMask = eventMask;
0: 		this.isBefore = isBefore;
0: 		this.isRow = isRow;
0: 		this.isEnabled = isEnabled;
0: 		this.whenSPSId = whenSPSId;
0: 		this.whenText = whenText;
0: 		this.actionSPSId = actionSPSId;
0: 		this.actionText = actionText;
0: 		this.spsCompSchemaId = spsCompSchemaId;
0: 		this.creationTimestamp = creationTimestamp;
0: 		this.referencedCols = referencedCols;
0: 		this.originalActionText = originalActionText;
0: 		this.referencingOld = referencingOld;
0: 		this.referencingNew = referencingNew;
0: 		this.oldReferencingName = oldReferencingName;
0: 		this.newReferencingName = newReferencingName;
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(triggerSchemaName != null, "triggerSchemaName sd is null");
0: 			SanityManager.ASSERT(triggerName != null, "trigger name is null");
0: 			SanityManager.ASSERT(triggerTable != null, "triggerTable is null");
0: 			SanityManager.ASSERT(actionText != null, "actionText is null");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * This is the guts of the Execution-time logic for CREATE TRIGGER.
0: 	 *
0: 	 * @see ConstantAction#executeConstantAction
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void	executeConstantAction(Activation activation)
0: 						throws StandardException
0: 	{
0: 		SPSDescriptor				whenspsd = null;
0: 		SPSDescriptor				actionspsd;
0: 
0: 		LanguageConnectionContext lcc = activation.getLanguageConnectionContext();
0: 		DataDictionary dd = lcc.getDataDictionary();
0: 		DependencyManager dm = dd.getDependencyManager();
0: 		TransactionController tc = lcc.getTransactionExecute();
0: 
0: 		/*
0: 		** Indicate that we are about to modify the data dictionary.
0: 		** 
0: 		** We tell the data dictionary we're done writing at the end of
0: 		** the transaction.
0: 		*/
0: 		dd.startWriting(lcc);
0: 
0: 		SchemaDescriptor triggerSd = getSchemaDescriptorForCreate(dd, activation, triggerSchemaName);
0: 
0: 		String tabName;
0: 		if (triggerTable != null)
0: 		{
0: 			triggerTableId = triggerTable.getUUID();
0: 			tabName = triggerTable.getName();
0: 		}
0: 		else
0: 			tabName = "with UUID " + triggerTableId;
0: 
0: 		/* We need to get table descriptor again.  We simply can't trust the
0: 		 * one we got at compile time, the lock on system table was released
0: 		 * when compile was done, and the table might well have been dropped.
0: 		 */
0: 		triggerTable = dd.getTableDescriptor(triggerTableId);
0: 		if (triggerTable == null)
0: 		{
0: 			throw StandardException.newException(
0: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
0: 								tabName);
0: 		}
0: 		/* Lock the table for DDL.  Otherwise during our execution, the table
0: 		 * might be changed, even dropped.  Beetle 4269
0: 		 */
0: 		lockTableForDDL(tc, triggerTable.getHeapConglomerateId(), true);
0: 		/* get triggerTable again for correctness, in case it's changed before
0: 		 * the lock is aquired
0: 		 */
0: 		triggerTable = dd.getTableDescriptor(triggerTableId);
0: 		if (triggerTable == null)
0: 		{
0: 			throw StandardException.newException(
0: 								SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
0: 								tabName);
0: 		}
0: 
0: 		/*
0: 		** Send an invalidate on the table from which
0: 		** the triggering event emanates.  This it
0: 		** to make sure that DML statements on this table
0: 		** will be recompiled.  Do this before we create
0: 		** our trigger spses lest we invalidate them just
0: 		** after creating them.
0: 		*/
0: 		dm.invalidateFor(triggerTable, DependencyManager.CREATE_TRIGGER, lcc);
0: 
0: 		/*
0: 		** Lets get our trigger id up front, we'll use it when
0: 	 	** we create our spses.
0: 		*/
0: 		UUID tmpTriggerId = dd.getUUIDFactory().createUUID();
0: 
0: 		/*	
0: 		** If we have a WHEN action we create it now.
0: 		*/ 
0: 		DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();
0: 		if (whenText != null)
0: 		{
0: 			whenspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
0: 						whenSPSId, spsCompSchemaId, whenText, true, triggerTable);
0: 		}
0: 
0: 		/*
0: 		** Create the trigger action
0: 		*/
0: 		actionspsd = createSPS(lcc, ddg, dd, tc, tmpTriggerId, triggerSd,
0: 						actionSPSId, spsCompSchemaId, actionText, false, triggerTable);
0: 		
0: 		TriggerDescriptor triggerd = 
0: 				ddg.newTriggerDescriptor(
0: 									triggerSd,
0: 									tmpTriggerId,
0: 									triggerName,
0: 									eventMask,
0: 									isBefore,
0: 									isRow,
0: 									isEnabled,
0: 									triggerTable,
0: 									whenspsd == null ? null : whenspsd.getUUID(),
0: 									actionspsd.getUUID(),
0: 									creationTimestamp == null ? new Timestamp(System.currentTimeMillis()) : creationTimestamp,
0: 									referencedCols,
0: 									originalActionText,
0: 									referencingOld,
0: 									referencingNew,
0: 									oldReferencingName,
0: 									newReferencingName);
0: 
0: 
0: 		dd.addDescriptor(triggerd, triggerSd,
0: 								DataDictionary.SYSTRIGGERS_CATALOG_NUM, false,
0: 								tc);
0: 
0: 		/*
0: 		** Make underlying spses dependent on the trigger.
0: 		*/
0: 		if (whenspsd != null)
0: 		{
0: 			dm.addDependency(triggerd, whenspsd, lcc.getContextManager());
0: 		}
0: 		dm.addDependency(triggerd, actionspsd, lcc.getContextManager());
0: 		dm.addDependency(triggerd, triggerTable, lcc.getContextManager());
0: 		dm.addDependency(actionspsd, triggerTable, lcc.getContextManager());
0: 	}
0: 
0: 
0: 	/*
0: 	** Create an sps that is used by the trigger.
0: 	*/
0: 	private SPSDescriptor createSPS
0: 	(
0: 		LanguageConnectionContext	lcc,
0: 		DataDescriptorGenerator 	ddg,
0: 		DataDictionary				dd,
0: 		TransactionController		tc,
0: 		UUID						triggerId,
0: 		SchemaDescriptor			sd,
0: 		UUID						spsId,
0: 		UUID						compSchemaId,
0: 		String						text,
0: 		boolean						isWhen,
0: 		TableDescriptor				triggerTable
0: 	) throws StandardException	
0: 	{
0: 		if (text == null)
0: 		{
0: 			return null; 
0: 		}
0: 
0: 		/*
0: 		** Note: the format of this string is very important.
0: 		** Dont change it arbitrarily -- see sps code.
0: 		*/
0: 		String spsName = "TRIGGER" + 
0: 						(isWhen ? "WHEN_" : "ACTN_") + 
0: 						triggerId + "_" + triggerTable.getUUID().toString();
0: 
0: 		SPSDescriptor spsd = new SPSDescriptor(dd, spsName,
0: 									(spsId == null) ?
0: 										dd.getUUIDFactory().createUUID() :
0: 										spsId,
0: 									sd.getUUID(),
0: 									compSchemaId == null ?
0: 										lcc.getDefaultSchema().getUUID() :
0: 										compSchemaId,
0: 									SPSDescriptor.SPS_TYPE_TRIGGER,
0: 									true,				// it is valid
0: 									text,				// the text
0: 									(String)null,		// no using clause
0: 									(Object[])null,
0: 									true );	// no defaults
0: 
0: 		/*
0: 		** Prepared the stored prepared statement
0: 		** and release the activation class -- we
0: 		** know we aren't going to execute statement
0: 		** after create it, so for now we are finished.
0: 		*/
0: 		spsd.prepareAndRelease(lcc, triggerTable);
0: 
0: 
0: 		dd.addSPSDescriptor(spsd, tc, true);
0: 
0: 		return spsd;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		return constructToString("CREATE TRIGGER ", triggerName);		
0: 	}
0: }
0: 
0: 
============================================================================