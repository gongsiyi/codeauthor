1:4359236: /*
18:4359236:  
1:4359236:  Derby - Class org.apache.derby.impl.drda.DRDAStatement
1:4359236: 
1:59e5225:  Licensed to the Apache Software Foundation (ASF) under one or more
1:59e5225:  contributor license agreements.  See the NOTICE file distributed with
1:59e5225:  this work for additional information regarding copyright ownership.
1:59e5225:  The ASF licenses this file to You under the Apache License, Version 2.0
1:59e5225:  (the "License"); you may not use this file except in compliance with
1:59e5225:  the License.  You may obtain a copy of the License at
1:4359236: 
1:4359236:  http://www.apache.org/licenses/LICENSE-2.0
1:4359236: 
1:4359236:  Unless required by applicable law or agreed to in writing, software
1:4359236:  distributed under the License is distributed on an "AS IS" BASIS,
1:4359236:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4359236:  See the License for the specific language governing permissions and
1:4359236:  limitations under the License.
1:4359236: 
15:4359236:  */
1:4359236: package org.apache.derby.impl.drda;
1:4359236: 
1:db4c995: import java.io.BufferedInputStream;
1:4359236: import java.io.IOException;
1:4359236: import java.io.InputStream;
1:504e429: import java.io.Reader;
1:f3ab04f: import java.sql.Blob;
1:db4c995: import java.sql.CallableStatement;
1:f3ab04f: import java.sql.Clob;
1:db4c995: import java.sql.ResultSet;
1:4359236: import java.sql.SQLException;
1:504e429: import org.apache.derby.iapi.jdbc.EngineResultSet;
1:90731d5: import org.apache.derby.iapi.reference.DRDAConstants;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:4359236: import org.apache.derby.impl.jdbc.Util;
1:4359236: 
15:4359236: /**
28:4359236:  * 
1:4359236:  * EXTDTAObjectHolder provides Externalized Large Object representation that
1:4359236:  * does not hold locks until the end of the transaction (DERBY-255)
1:4359236:  * 
1:4359236:  * It serves as a holder for lob data and is only valid as long as the original
1:4359236:  * result set from which it came is on the same row.  
1:4359236:  * 
1:4359236:  *  
1:4359236:  */
1:7df5ffe: class EXTDTAInputStream extends InputStream {
1:504e429: 
1:f3ab04f:     private InputStream binaryInputStream = null;
1:504e429:  
1:94df7fb:     /** DRDA Type of column/parameter */
1:504e429:     int ndrdaType;
1:4359236: 
1:94df7fb:     //
1:94df7fb:     // Used when this class wraps a ResultSet
1:94df7fb:     //
1:4359236:     
1:504e429:     /** ResultSet that contains the stream*/
1:504e429:     EngineResultSet rs;
1:504e429:     /** Column index starting with 1 */
1:504e429:     int columnNumber;
1:504e429: 
1:94df7fb:     //
1:94df7fb:     // Used when this class wraps a CallableStatement
1:94df7fb:     //
1:94df7fb:     private Clob _clob;
1:94df7fb:     private Blob _blob;
1:4f996a4:     
1:4359236:       
1:4359236:     
1:4f996a4:     private EXTDTAInputStream(ResultSet rs,
1:4f996a4:                   int columnNumber,
1:4f996a4:                   int ndrdaType) 
1:504e429:     {
1:4f996a4:     
1:504e429:         this.rs = (EngineResultSet) rs;
1:504e429:         this.columnNumber = columnNumber;
1:504e429:         this.ndrdaType = ndrdaType;
1:504e429:     }
1:504e429: 
1:4f996a4:     private EXTDTAInputStream(Clob clob, int ndrdaType ) 
1:4359236:     {
1:94df7fb:         _clob = clob;
1:94df7fb:         this.ndrdaType = ndrdaType;
1:504e429:     }
1:504e429: 
1:4f996a4:     private EXTDTAInputStream(Blob blob, int ndrdaType ) 
1:4359236:     {
1:94df7fb:         _blob = blob;
1:94df7fb:         this.ndrdaType = ndrdaType;
19:4359236:     }
1:504e429: 
1:4359236:     
1:4f996a4:     /**
1:4f996a4:      * Create a new EXTDTAInputStream.  Before read the stream must be 
1:504e429:      * initialized by the user with {@link #initInputStream()} 
1:4f996a4:      * 
1:4f996a4:      * @see DDMWriter#writeScalarStream
1:504e429:      * @see #initInputStream()
1:4f996a4:      * 
1:4f996a4:      * @param rs
1:4f996a4:      *            result set from which to retrieve the lob
1:4f996a4:      * @param column
1:4f996a4:      *            column number
1:4f996a4:      * @param drdaType
1:4f996a4:      *            FD:OCA type of object one of
1:db9a013:      *             DRDAConstants.DRDA_TYPE_NLOBBYTES
1:db9a013:      *             DRDAConstants.DRDA_TYPE_LOBBYTES
1:db9a013:      *             DRDAConstants.DRDA_TYPE_NLOBCMIXED
1:4f996a4:      *             DRDAConstants.DRDA_TYPE_LOBCMIXED
1:4f996a4:      * 
1:4f996a4:      * @return null if the value is null or a new EXTDTAInputStream corresponding to 
1:4f996a4:      *          rs.getBinaryStream(column) value and associated length
1:4f996a4:      * 
1:4f996a4:      * @throws SQLException
1:4f996a4:      */
1:4f996a4:     public static EXTDTAInputStream getEXTDTAStream(ResultSet rs, int column, int drdaType) 
1:4f996a4:         {
1:db9a013: 
1:4f996a4:         int ndrdaType = drdaType | 1; //nullable drdaType
1:4f996a4:             
1:4f996a4:         return new EXTDTAInputStream(rs,
1:4f996a4:                          column,
1:4f996a4:                          ndrdaType);
1:4f996a4:         
1:4f996a4:     }
1:4f996a4: 
1:4f996a4:     /**
1:4f996a4:      * Create a new EXTDTAInputStream from a CallableStatement.
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @param cs
1:4f996a4:      *            CallableStatement from which to retrieve the lob
1:4f996a4:      * @param column
1:4f996a4:      *            column number
1:4f996a4:      * @param drdaType
1:4f996a4:      *            FD:OCA type of object one of
1:db9a013:      *             DRDAConstants.DRDA_TYPE_NLOBBYTES
1:db9a013:      *             DRDAConstants.DRDA_TYPE_LOBBYTES
1:db9a013:      *             DRDAConstants.DRDA_TYPE_NLOBCMIXED
1:4f996a4:      *             DRDAConstants.DRDA_TYPE_LOBCMIXED
1:4f996a4:      */
1:4f996a4:     public static EXTDTAInputStream getEXTDTAStream(CallableStatement cs, int column, int drdaType)
1:504e429:         throws SQLException
1:4f996a4:     {
1:db9a013: 
1:4f996a4:         int ndrdaType = drdaType | 1; //nullable drdaType
1:4f996a4: 
1:94df7fb:         switch ( ndrdaType )
1:504e429:         {
1:94df7fb:         case DRDAConstants.DRDA_TYPE_NLOBBYTES:
1:f1ec775:             Blob    blob = cs.getBlob( column );
1:f1ec775:             if ( blob ==  null ) { return null; }
1:f1ec775:             return new EXTDTAInputStream( blob, ndrdaType );
1:94df7fb:         case DRDAConstants.DRDA_TYPE_NLOBCMIXED:
1:f1ec775:             Clob    clob = cs.getClob( column );
1:f1ec775:             if ( clob == null ) { return null; }
1:f1ec775:             return new EXTDTAInputStream( clob, ndrdaType );
1:94df7fb:         default:
1:94df7fb:             badDRDAType( ndrdaType );
1:4f996a4:             return null;
1:4f996a4:         }
1:504e429:     }
1:4f996a4: 
1:4f996a4:     
1:4359236:     
1:4f996a4:     /**
1:4f996a4:      * Requires {@link #initInputStream()} be called before we can read from the stream
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#read()
1:4f996a4:      */
1:4f996a4:     public int read() throws IOException {
1:504e429:                        
1:4f996a4:         return binaryInputStream.read();
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#available()
1:4f996a4:      */
1:4f996a4:     public int available() throws IOException {
1:4f996a4:         return binaryInputStream.available();
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#close()
1:4f996a4:      */
1:4f996a4:     public void close() throws IOException {
1:4f996a4:         
1:4f996a4:         if (binaryInputStream != null)
1:db9a013:             binaryInputStream.close();
1:4f996a4:         binaryInputStream = null;
1:4f996a4:         
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.lang.Object#equals(java.lang.Object)
1:4f996a4:      */
1:4f996a4:     public boolean equals(Object arg0) {
1:4f996a4:         return binaryInputStream.equals(arg0);
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.lang.Object#hashCode()
1:4f996a4:      */
1:4f996a4:     public int hashCode() {
1:4f996a4:         return binaryInputStream.hashCode();
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#mark(int)
1:4f996a4:      */
1:4f996a4:     public void mark(int arg0) {
1:4f996a4:         binaryInputStream.mark(arg0);
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#markSupported()
1:4f996a4:      */
1:4f996a4:     public boolean markSupported() {
1:4f996a4:         return binaryInputStream.markSupported();
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#read(byte[])
1:4f996a4:      */
1:4f996a4:     public int read(byte[] arg0) throws IOException {
1:4f996a4:         return binaryInputStream.read(arg0);
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#read(byte[], int, int)
1:4f996a4:      */
1:4f996a4:     public int read(byte[] arg0, int arg1, int arg2) throws IOException {
1:4f996a4:         return binaryInputStream.read(arg0, arg1, arg2);
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#reset()
1:4f996a4:      */
1:4f996a4:     public void reset() throws IOException {
1:4f996a4:         binaryInputStream.reset();
1:4f996a4:     }
1:4359236: 
1:4f996a4:     /**
1:4f996a4:      * 
1:4f996a4:      * 
1:4f996a4:      * @see java.io.InputStream#skip(long)
1:4f996a4:      */
1:4f996a4:     public long skip(long arg0) throws IOException {
1:4f996a4:         if (arg0 < 0L) {
1:4f996a4:             return 0L;
1:4f996a4:         }
1:4f996a4:         return binaryInputStream.skip(arg0);
1:4f996a4:     }
1:4359236: 
1:4359236: 
1:94df7fb:     protected boolean isEmptyStream() throws SQLException
1:94df7fb:     {
1:94df7fb:         return (length() == 0);
1:4359236:     }
1:94df7fb:     private long length() throws SQLException
1:94df7fb:     {
1:94df7fb:         if ( rs != null ) { return rs.getLength(columnNumber); }
1:94df7fb:         else if ( _clob != null ) { return _clob.length(); }
1:94df7fb:         else { return _blob.length(); }
1:4359236:     }
1:4359236:     
1:4359236:     
1:4359236:     /**
1:f3ab04f:      * This method takes information of ResultSet and 
1:504e429:      * initializes the binaryInputStream variable of this object with not empty stream 
1:504e429:      * by calling getBinaryStream or getCharacterStream() as appropriate.
1:504e429:      * The Reader returned from getCharacterStream() will be encoded in binarystream.
1:4359236:      *
1:4359236:      *
1:4359236:      */
1:504e429:     public  void initInputStream()
1:4f996a4:     throws SQLException
1:4f996a4:     {
1:4359236: 
1:4f996a4:     InputStream is = null;
1:4f996a4:     Reader r = null;
1:4f996a4:     // BLOBS
1:4f996a4:     if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
1:db9a013:     {
1:4f996a4:         is = getBinaryStream();
1:4f996a4:         if (is == null) { return; }
1:4f996a4:     }
1:4f996a4:         // CLOBS
1:4f996a4:     else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
1:db9a013:     {
1:4f996a4:         try {
1:4f996a4:             
1:4f996a4:             r = getCharacterStream();
1:4f996a4:                 
1:db9a013:             if(r == null){
2:504e429:                     return;
1:4f996a4:             }
1:504e429: 
1:4f996a4:             is = new ReEncodedInputStream(r);
1:4f996a4:             
1:4f996a4:             }catch (java.io.UnsupportedEncodingException e) {
1:4f996a4:             throw Util.javaException(e);
1:4f996a4:             
1:4f996a4:             }catch (IOException e){
1:4f996a4:             throw Util.javaException(e);
1:4f996a4:             
1:4f996a4:             }
1:4f996a4:             
1:4f996a4:         }
1:94df7fb:         else { badDRDAType( ndrdaType ); }
1:4f996a4:     if (! is.markSupported()) {
1:4f996a4:         is = new BufferedInputStream(is);
1:4f996a4:         }
1:4f996a4:         
1:db9a013:     this.binaryInputStream=is;
1:504e429:     }
1:94df7fb:     private InputStream getBinaryStream() throws SQLException
1:504e429:     {
1:94df7fb:         if ( rs != null ) { return rs.getBinaryStream(this.columnNumber); }
1:94df7fb:         else { return _blob.getBinaryStream(); }
1:4359236:     }
1:94df7fb:     private Reader getCharacterStream() throws SQLException
1:4359236:     {
1:94df7fb:         if ( rs != null ) { return rs.getCharacterStream(this.columnNumber); }
1:94df7fb:         else { return _clob.getCharacterStream(); }
1:4359236:     }
1:94df7fb:     private static void badDRDAType( int drdaType )
1:4359236:     {
1:364aaa0:         if (SanityManager.DEBUG)
1:364aaa0:         {
1:94df7fb:             SanityManager.THROWASSERT("NDRDAType: " + drdaType +
1:4359236:                                       " not valid EXTDTA object type");
1:504e429:         }
1:364aaa0:     }
1:504e429:     
1:504e429:         
1:f3ab04f:     protected void finalize() throws Throwable{
1:4f996a4:     close();
1:4f996a4:     }
1:504e429: 
1:504e429:     /**
1:504e429:      * Is the value null?  Null status is obtained from the underlying 
1:94df7fb:      * EngineResultSet or LOB, so that it can be determined before the stream
1:504e429:      * is retrieved.
1:504e429:      * 
1:504e429:      * @return true if this value is null
1:504e429:      * 
1:504e429:      */
1:504e429:     public boolean isNull() throws SQLException
1:504e429:     {
1:94df7fb:         if ( rs != null ) { return rs.isNull(columnNumber); }
1:94df7fb:         else { return (_clob == null) && (_blob == null); }
1:504e429:     }
1:4359236: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:db9a013
/////////////////////////////////////////////////////////////////////////
1:      *             DRDAConstants.DRDA_TYPE_NLOBBYTES
1:      *             DRDAConstants.DRDA_TYPE_LOBBYTES
1:      *             DRDAConstants.DRDA_TYPE_NLOBCMIXED
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      *             DRDAConstants.DRDA_TYPE_NLOBBYTES
1:      *             DRDAConstants.DRDA_TYPE_LOBBYTES
1:      *             DRDAConstants.DRDA_TYPE_NLOBCMIXED
1: 
/////////////////////////////////////////////////////////////////////////
1:             binaryInputStream.close();
/////////////////////////////////////////////////////////////////////////
1:     {
1:     {
1:             if(r == null){
/////////////////////////////////////////////////////////////////////////
1:     this.binaryInputStream=is;
commit:db4c995
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
1: import java.sql.CallableStatement;
1: import java.sql.ResultSet;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:4f996a4
/////////////////////////////////////////////////////////////////////////
1:     
1:     private EXTDTAInputStream(ResultSet rs,
1:                   int columnNumber,
1:                   int ndrdaType) 
1:     
1:     private EXTDTAInputStream(Clob clob, int ndrdaType ) 
1:     private EXTDTAInputStream(Blob blob, int ndrdaType ) 
1:     /**
1:      * Create a new EXTDTAInputStream.  Before read the stream must be 
1:      * 
1:      * @see DDMWriter#writeScalarStream
1:      * 
1:      * @param rs
1:      *            result set from which to retrieve the lob
1:      * @param column
1:      *            column number
1:      * @param drdaType
1:      *            FD:OCA type of object one of
0:      *                DRDAConstants.DRDA_TYPE_NLOBBYTES
0:      *                DRDAConstants.DRDA_TYPE_LOBBYTES
0:      *                DRDAConstants.DRDA_TYPE_NLOBCMIXED
1:      *             DRDAConstants.DRDA_TYPE_LOBCMIXED
1:      * 
1:      * @return null if the value is null or a new EXTDTAInputStream corresponding to 
1:      *          rs.getBinaryStream(column) value and associated length
1:      * 
1:      * @throws SQLException
1:      */
1:     public static EXTDTAInputStream getEXTDTAStream(ResultSet rs, int column, int drdaType) 
1:         {
1:          
1:         int ndrdaType = drdaType | 1; //nullable drdaType
1:             
1:         return new EXTDTAInputStream(rs,
1:                          column,
1:                          ndrdaType);
1:         
1:     }
1:     /**
1:      * Create a new EXTDTAInputStream from a CallableStatement.
1:      * 
1:      * 
1:      * @param cs
1:      *            CallableStatement from which to retrieve the lob
1:      * @param column
1:      *            column number
1:      * @param drdaType
1:      *            FD:OCA type of object one of
0:      *                DRDAConstants.DRDA_TYPE_NLOBBYTES
0:      *                DRDAConstants.DRDA_TYPE_LOBBYTES
0:      *                DRDAConstants.DRDA_TYPE_NLOBCMIXED
1:      *             DRDAConstants.DRDA_TYPE_LOBCMIXED
1:      */
1:     public static EXTDTAInputStream getEXTDTAStream(CallableStatement cs, int column, int drdaType)
1:          
1:         int ndrdaType = drdaType | 1; //nullable drdaType
/////////////////////////////////////////////////////////////////////////
1:             return null;
1:     }
1:     
1:     
1:     /**
1:      * Requires {@link #initInputStream()} be called before we can read from the stream
1:      * 
1:      * @see java.io.InputStream#read()
1:      */
1:     public int read() throws IOException {
1:         return binaryInputStream.read();
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#available()
1:      */
1:     public int available() throws IOException {
1:         return binaryInputStream.available();
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#close()
1:      */
1:     public void close() throws IOException {
1:         
1:         if (binaryInputStream != null)
0:             binaryInputStream.close();    
1:         binaryInputStream = null;
1:         
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.lang.Object#equals(java.lang.Object)
1:      */
1:     public boolean equals(Object arg0) {
1:         return binaryInputStream.equals(arg0);
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.lang.Object#hashCode()
1:      */
1:     public int hashCode() {
1:         return binaryInputStream.hashCode();
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#mark(int)
1:      */
1:     public void mark(int arg0) {
1:         binaryInputStream.mark(arg0);
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#markSupported()
1:      */
1:     public boolean markSupported() {
1:         return binaryInputStream.markSupported();
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#read(byte[])
1:      */
1:     public int read(byte[] arg0) throws IOException {
1:         return binaryInputStream.read(arg0);
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#read(byte[], int, int)
1:      */
1:     public int read(byte[] arg0, int arg1, int arg2) throws IOException {
1:         return binaryInputStream.read(arg0, arg1, arg2);
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#reset()
1:      */
1:     public void reset() throws IOException {
1:         binaryInputStream.reset();
1:     }
1:     /**
1:      * 
1:      * 
1:      * @see java.io.InputStream#skip(long)
1:      */
1:     public long skip(long arg0) throws IOException {
1:         if (arg0 < 0L) {
1:             return 0L;
1:         }
1:         return binaryInputStream.skip(arg0);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     throws SQLException
1:     InputStream is = null;
1:     Reader r = null;
1:     // BLOBS
1:     if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
1:     {             
1:         is = getBinaryStream();
1:         if (is == null) { return; }
1:     }
1:         // CLOBS
1:     else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
1:     {    
1:         try {
1:             
1:             r = getCharacterStream();
1:                 
0:             if(r == null){                
1:             }
1:             is = new ReEncodedInputStream(r);
1:             
1:             }catch (java.io.UnsupportedEncodingException e) {
1:             throw Util.javaException(e);
1:             
1:             }catch (IOException e){
1:             throw Util.javaException(e);
1:             
1:             }
1:             
1:         }
1:     if (! is.markSupported()) {
1:         is = new BufferedInputStream(is);
1:         }
1:         
0:      this.binaryInputStream=is;
/////////////////////////////////////////////////////////////////////////
1:     close();
1:     }
commit:504e429
/////////////////////////////////////////////////////////////////////////
1: import java.io.Reader;
1: import org.apache.derby.iapi.jdbc.EngineResultSet;
/////////////////////////////////////////////////////////////////////////
1:  
1:     
1:     /** ResultSet that contains the stream*/
1:     EngineResultSet rs;
1:     /** Column index starting with 1 */
1:     int columnNumber;
0:     /** DRDA Type of column */
1:     int ndrdaType;
1:       
1:         this.rs = (EngineResultSet) rs;
1:         this.columnNumber = columnNumber;
1:         this.ndrdaType = ndrdaType;
1:     }
0: 	 * Create a new EXTDTAInputStream.  Before read the stream must be 
1:      * initialized by the user with {@link #initInputStream()} 
0: 	 * @see DDMWriter#writeScalarStream
1:      * @see #initInputStream()
/////////////////////////////////////////////////////////////////////////
1: 		{
1:  	    
0: 	 * Requires {@link #initInputStream()} be called before we can read from the stream
1:                        
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:     protected boolean isEmptyStream() throws SQLException{
0:             return (rs.getLength(columnNumber) == 0);
1:         
1:         }
1:      * initializes the binaryInputStream variable of this object with not empty stream 
1:      * by calling getBinaryStream or getCharacterStream() as appropriate.
1:      * The Reader returned from getCharacterStream() will be encoded in binarystream.
1:     public  void initInputStream()
1: 	throws SQLException
0: 	Reader r = null;
0: 	// BLOBS
0: 	if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
1: 	{ 	    	
0: 	    is = this.rs.getBinaryStream(this.columnNumber);
0: 	    if (is == null) 
1:               return;
1: 	}
0: 	else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
1: 	{	
0: 	    try {
1: 	        
0: 	        r = this.rs.getCharacterStream(this.columnNumber);
1: 		    	
0: 	        if(r == null){	            
1:                     return;
1: 	        }
0: 			is = new ReEncodedInputStream(r);
0: 			throw Util.javaException(e);
0: 			throw Util.javaException(e);
/////////////////////////////////////////////////////////////////////////
0: 	if (! is.markSupported()) {
1: 	    }
1: 	    
0:  	this.binaryInputStream=is;
1:         
1:     /**
1:      * Is the value null?  Null status is obtained from the underlying 
0:      * EngineResultSet, so that it can be determined before the stream
1:      * is retrieved.
1:      * 
1:      * @return true if this value is null
1:      * 
1:      */
1:     public boolean isNull() throws SQLException
1:     {
0:         return this.rs.isNull(columnNumber);
1:      
1:     }
commit:364aaa0
/////////////////////////////////////////////////////////////////////////
1: 			if (SanityManager.DEBUG)
1: 			{
1: 			}
commit:4359236
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:  Derby - Class org.apache.derby.impl.drda.DRDAStatement
1: 
0:  Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:  Licensed under the Apache License, Version 2.0 (the "License");
0:  you may not use this file except in compliance with the License.
0:  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: package org.apache.derby.impl.drda;
1: 
0: import java.io.ByteArrayInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
0: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.impl.jdbc.Util;
1: 
1: /**
0:  * @author marsden
1:  * 
1:  * EXTDTAObjectHolder provides Externalized Large Object representation that
1:  * does not hold locks until the end of the transaction (DERBY-255)
1:  * 
1:  * It serves as a holder for lob data and is only valid as long as the original
1:  * result set from which it came is on the same row.  
1:  * 
1:  *  
1:  */
0: public class EXTDTAInputStream extends InputStream {
1: 
0: 	long dataLength = 0; // length of the stream;
1: 
0: 	InputStream binaryInputStream = null;
1: 
0: 	int columnNumber;
1: 
0: 	ResultSet dataResultSet = null;
1: 	
1: 	
1: 	/**
0: 	 * @param dataLength
0: 	 * @param binaryInputStream
1: 	 */
0: 	private EXTDTAInputStream( int dataLength, InputStream binaryInputStream) {
1: 		
0: 		this.dataLength = dataLength;
0: 		this.binaryInputStream = binaryInputStream;
1: 	}
1: 
1: 	/**
0: 	 * Retrieve stream from the ResultSet and column specified.  Create an
0: 	 * input stream and length for the large object being retrieved. Do not hold
0: 	 * locks until end of transaction. DERBY-255.
1: 	 * 
1: 	 * 
0: 	 * @see DDMWriter.writeScalarStream
1: 	 * 
0: 	 * @param rs
0: 	 *            result set from which to retrieve the lob
0: 	 * @param column
0: 	 *            column number
0: 	 * @param drdaType
0: 	 *            FD:OCA type of object one of
0: 	 * 			   FdocaConstants.DRDA_TYPE_NLOBBYTES
0: 	 * 			   FdocaConstants.DRDA_TYPE_LOBBYTES
0: 	 * 			   FdocaConstants.DRDA_TYPE_NLOBCMIXED
0: 	 *  		   FdocaConstants.DRDA_TYPE_LOBCMIXED
1: 	 * 
0: 	 * @returns null if the value is null or a new EXTDTAInputStream corresponding to 
0: 	 *  		rs.getBinaryStream(column) value and associated length
1: 	 * 
0: 	 * @throws SQLException
1: 	 */
0: 	public static EXTDTAInputStream getEXTDTAStream(ResultSet rs, int column, int drdaType) 
0: 			throws SQLException {
1: 		
0: 		EXTDTAInputStream extdtaStream = null;
0: 		int length = 0;
0: 		byte[] bytes = null;
1: 		
0: 		int ndrdaType = drdaType | 1; //nullable drdaType
0: 		// BLOBS
0: 		if (ndrdaType == FdocaConstants.DRDA_TYPE_NLOBBYTES) 
1: 		{
0: 			//TODO: Change to just use rs.getBinaryStream() by 
0: 			// eliminating the need for a length parameter in
0: 			//DDMWriter.writeScalarStream and therefore eliminating the need for dataLength in this class
0: 			bytes = rs.getBytes(column);
1: 			
1: 		}
0: 		// CLOBS
0: 		else if (ndrdaType ==  FdocaConstants.DRDA_TYPE_NLOBCMIXED)
1: 		{	
0: 			//TODO: Change to use getCharacterStream and change the read method
0: 			// to stream the data after length is no longer needed in DDMWRiter.writeScalarStream
0: 			String s  = rs.getString(column);
0: 			try {
0: 				if (s != null)
0: 					bytes = s.getBytes(NetworkServerControlImpl.DEFAULT_ENCODING);
1: 			}
0: 			catch (java.io.UnsupportedEncodingException e) {
0: 				throw new SQLException (e.getMessage());
1: 			}
1: 		}
0: 		else
1: 		{
0: 			SanityManager.THROWASSERT("DRDAType: " + drdaType +
1: 						" not valid EXTDTA object type");
1: 		}
1: 		
0: 		if (bytes != null)
1: 		{
0: 			length = bytes.length;
0: 			InputStream is = new ByteArrayInputStream(bytes);
0: 			extdtaStream =  new EXTDTAInputStream(length, is);
1: 		}
1: 		
0: 		return extdtaStream;
1: 	}
1: 
1: 	
1: 	/**
0: 	 * Get the length of the InputStream 
0: 	 * This method is currently not used because there seems to be no way to 
0: 	 * reset the she stream.
1: 	 *   
0: 	 * @param binaryInputStream
0: 	 *            an InputStream whose length needs to be calclulated
0: 	 * @return length of stream
1: 	 */
0: 	private static long getInputStreamLength(InputStream binaryInputStream)
0: 			throws SQLException {
0: 		long length = 0;
0: 		if (binaryInputStream == null)
0: 			return length;
1: 		
0: 		try {
0: 			for (;;) {
0: 				int avail = binaryInputStream.available();
0: 				binaryInputStream.skip(avail);
0: 				if (avail == 0)
0: 					break;
0: 				length += avail;
1: 				
1: 			}
0: 			//binaryInputStream.close();
0: 		} catch (IOException ioe) {
0: 			throw Util.javaException(ioe);
1: 		}
1: 
0: 		return length;
1: 
1: 	}
1: 	
1: 	
1: 	
1: 	/**
0: 	 * Return the length of the binary stream which was calculated when
0: 	 * EXTDTAObject was created.
1: 	 * 
0: 	 * @return the length of the stream once converted to an InputStream
1: 	 */
0: 	public long length() throws SQLException {
0: 		return dataLength;
1: 		
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#read()
1: 	 */
0: 	public int read() throws IOException {
0: 		return binaryInputStream.read();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#available()
1: 	 */
0: 	public int available() throws IOException {
0: 		return binaryInputStream.available();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#close()
1: 	 */
0: 	public void close() throws IOException {
0: 		if (binaryInputStream != null)
0: 			binaryInputStream.close();	
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.lang.Object#equals(java.lang.Object)
1: 	 */
0: 	public boolean equals(Object arg0) {
0: 		return binaryInputStream.equals(arg0);
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.lang.Object#hashCode()
1: 	 */
0: 	public int hashCode() {
0: 		return binaryInputStream.hashCode();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#mark(int)
1: 	 */
0: 	public void mark(int arg0) {
0: 		binaryInputStream.mark(arg0);
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#markSupported()
1: 	 */
0: 	public boolean markSupported() {
0: 		return binaryInputStream.markSupported();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#read(byte[])
1: 	 */
0: 	public int read(byte[] arg0) throws IOException {
0: 		return binaryInputStream.read(arg0);
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#read(byte[], int, int)
1: 	 */
0: 	public int read(byte[] arg0, int arg1, int arg2) throws IOException {
0: 		return binaryInputStream.read(arg0, arg1, arg2);
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#reset()
1: 	 */
0: 	public void reset() throws IOException {
0: 		binaryInputStream.reset();
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * 
0: 	 * @see java.io.InputStream#skip(long)
1: 	 */
0: 	public long skip(long arg0) throws IOException {
0: 		return binaryInputStream.skip(arg0);
1: 	}
1: 
1: 
1: }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:f1ec775
/////////////////////////////////////////////////////////////////////////
1:             Blob    blob = cs.getBlob( column );
1:             if ( blob ==  null ) { return null; }
1:             return new EXTDTAInputStream( blob, ndrdaType );
1:             Clob    clob = cs.getClob( column );
1:             if ( clob == null ) { return null; }
1:             return new EXTDTAInputStream( clob, ndrdaType );
commit:94df7fb
/////////////////////////////////////////////////////////////////////////
0: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:     /** DRDA Type of column/parameter */
0:     int ndrdaType;
0: 
1:     //
1:     // Used when this class wraps a ResultSet
1:     //
0: 
1:     //
1:     // Used when this class wraps a CallableStatement
1:     //
1:     private Clob _clob;
1:     private Blob _blob;
0:     
/////////////////////////////////////////////////////////////////////////
0: 	private EXTDTAInputStream(Clob clob, int ndrdaType ) 
1:     {
1:         _clob = clob;
1:         this.ndrdaType = ndrdaType;
0:     }
0: 
0: 	private EXTDTAInputStream(Blob blob, int ndrdaType ) 
1:     {
1:         _blob = blob;
1:         this.ndrdaType = ndrdaType;
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Create a new EXTDTAInputStream from a CallableStatement.
0: 	 * 
0: 	 * 
0: 	 * @param cs
0: 	 *            CallableStatement from which to retrieve the lob
0: 	 * @param column
0: 	 *            column number
0: 	 * @param drdaType
0: 	 *            FD:OCA type of object one of
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_LOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBCMIXED
0: 	 *  		   DRDAConstants.DRDA_TYPE_LOBCMIXED
0: 	 */
0: 	public static EXTDTAInputStream getEXTDTAStream(CallableStatement cs, int column, int drdaType)
0:         throws SQLException
0:     {
0:  	    
0: 		int ndrdaType = drdaType | 1; //nullable drdaType
0: 
1:         switch ( ndrdaType )
0:         {
1:         case DRDAConstants.DRDA_TYPE_NLOBBYTES:
0:             return new EXTDTAInputStream( cs.getBlob( column ), ndrdaType );
1:         case DRDAConstants.DRDA_TYPE_NLOBCMIXED:
0:             return new EXTDTAInputStream( cs.getClob( column ), ndrdaType );
1:         default:
1:             badDRDAType( ndrdaType );
0: 			return null;
0:         }
0: 	}
0: 
/////////////////////////////////////////////////////////////////////////
1:     protected boolean isEmptyStream() throws SQLException
0:     {
1:         return (length() == 0);
0:     }
1:     private long length() throws SQLException
0:     {
1:         if ( rs != null ) { return rs.getLength(columnNumber); }
1:         else if ( _clob != null ) { return _clob.length(); }
1:         else { return _blob.length(); }
0:     }
/////////////////////////////////////////////////////////////////////////
0: 	    is = getBinaryStream();
0: 	    if (is == null) { return; }
0: 	        r = getCharacterStream();
/////////////////////////////////////////////////////////////////////////
1:         else { badDRDAType( ndrdaType ); }
1:     private InputStream getBinaryStream() throws SQLException
0:     {
1:         if ( rs != null ) { return rs.getBinaryStream(this.columnNumber); }
1:         else { return _blob.getBinaryStream(); }
0:     }
1:     private Reader getCharacterStream() throws SQLException
0:     {
1:         if ( rs != null ) { return rs.getCharacterStream(this.columnNumber); }
1:         else { return _clob.getCharacterStream(); }
0:     }
1:     private static void badDRDAType( int drdaType )
0:     {
0:         if (SanityManager.DEBUG)
0:         {
1:             SanityManager.THROWASSERT("NDRDAType: " + drdaType +
0:                                       " not valid EXTDTA object type");
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
1:      * EngineResultSet or LOB, so that it can be determined before the stream
/////////////////////////////////////////////////////////////////////////
1:         if ( rs != null ) { return rs.isNull(columnNumber); }
1:         else { return (_clob == null) && (_blob == null); }
commit:9ec13b2
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:71d73dd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		if (arg0 < 0L) {
0: 			return 0L;
0: 		}
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59e5225
/////////////////////////////////////////////////////////////////////////
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:977561c
/////////////////////////////////////////////////////////////////////////
0:  Derby - Class org.apache.derby.impl.drda.DRDAStatement
0:  Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
0:  Licensed under the Apache License, Version 2.0 (the "License");
0:  you may not use this file except in compliance with the License.
0:  You may obtain a copy of the License at
0:  http://www.apache.org/licenses/LICENSE-2.0
0:  Unless required by applicable law or agreed to in writing, software
0:  distributed under the License is distributed on an "AS IS" BASIS,
0:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:  See the License for the specific language governing permissions and
0:  limitations under the License.
0:  */
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	
0: 	private EXTDTAInputStream(ResultSet rs,
0: 				  int columnNumber,
0: 				  int ndrdaType) 
0: 	    throws SQLException, IOException
0:     {
0: 	
0: 	    this.dataResultSet = rs;
0: 	    this.isEmptyStream = ! initInputStream(rs,
0: 						   columnNumber,
0: 						   ndrdaType);
0: 		
0: 	}
0: 	/**
0: 	 * Retrieve stream from the ResultSet and column specified.  Create an
0: 	 * input stream for the large object being retrieved. Do not hold
0: 	 * locks until end of transaction. DERBY-255.
0: 	 * 
0: 	 * 
0: 	 * See DDMWriter.writeScalarStream
0: 	 * 
0: 	 * @param rs
0: 	 *            result set from which to retrieve the lob
0: 	 * @param column
0: 	 *            column number
0: 	 * @param drdaType
0: 	 *            FD:OCA type of object one of
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_LOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBCMIXED
0: 	 *  		   DRDAConstants.DRDA_TYPE_LOBCMIXED
0: 	 * 
0: 	 * @return null if the value is null or a new EXTDTAInputStream corresponding to 
0: 	 *  		rs.getBinaryStream(column) value and associated length
0: 	 * 
0: 	 * @throws SQLException
0: 	 */
0: 	public static EXTDTAInputStream getEXTDTAStream(ResultSet rs, int column, int drdaType) 
0: 			throws SQLException {
0:  	    try{
0: 		int ndrdaType = drdaType | 1; //nullable drdaType
0: 			
0: 		return new EXTDTAInputStream(rs,
0: 					     column,
0: 					     ndrdaType);
0: 		
0:  	    }catch(IOException e){
0:  		throw new SQLException(e.getMessage());
0: 		}
0: 		
0: 	}
0: 	
0: 	/**
0: 	 * Get the length of the InputStream 
0: 	 * This method is currently not used because there seems to be no way to 
0: 	 * reset the she stream.
0: 	 *   
0: 	 * @param binaryInputStream
0: 	 *            an InputStream whose length needs to be calclulated
0: 	 * @return length of stream
0: 	 */
0: 	private static long getInputStreamLength(InputStream binaryInputStream)
0: 			throws SQLException {
0: 		long length = 0;
0: 		if (binaryInputStream == null)
0: 			return length;
0: 		
0: 		try {
0: 			for (;;) {
0: 				int avail = binaryInputStream.available();
0: 				binaryInputStream.skip(avail);
0: 				if (avail == 0)
0: 					break;
0: 				length += avail;
0: 				
0: 			}
0: 			//binaryInputStream.close();
0: 		} catch (IOException ioe) {
0: 			throw Util.javaException(ioe);
0: 		}
0: 		return length;
0: 	}
0: 	
0: 	
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#read()
0: 	 */
0: 	public int read() throws IOException {
0: 		return binaryInputStream.read();
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#available()
0: 	 */
0: 	public int available() throws IOException {
0: 		return binaryInputStream.available();
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#close()
0: 	 */
0: 	public void close() throws IOException {
0: 	    
0: 	    try{
0: 		if (binaryInputStream != null)
0: 			binaryInputStream.close();	
0: 		binaryInputStream = null;
0: 	    }finally{
0: 		
0: 		blob = null;
0: 		clob = null;
0: 		dataResultSet = null;
0: 	    }
0: 	    
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.lang.Object#equals(java.lang.Object)
0: 	 */
0: 	public boolean equals(Object arg0) {
0: 		return binaryInputStream.equals(arg0);
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.lang.Object#hashCode()
0: 	 */
0: 	public int hashCode() {
0: 		return binaryInputStream.hashCode();
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#mark(int)
0: 	 */
0: 	public void mark(int arg0) {
0: 		binaryInputStream.mark(arg0);
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#markSupported()
0: 	 */
0: 	public boolean markSupported() {
0: 		return binaryInputStream.markSupported();
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#read(byte[])
0: 	 */
0: 	public int read(byte[] arg0) throws IOException {
0: 		return binaryInputStream.read(arg0);
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#read(byte[], int, int)
0: 	 */
0: 	public int read(byte[] arg0, int arg1, int arg2) throws IOException {
0: 		return binaryInputStream.read(arg0, arg1, arg2);
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#reset()
0: 	 */
0: 	public void reset() throws IOException {
0: 		binaryInputStream.reset();
0: 	}
0: 	/**
0: 	 * 
0: 	 * 
0: 	 * @see java.io.InputStream#skip(long)
0: 	 */
0: 	public long skip(long arg0) throws IOException {
0: 		return binaryInputStream.skip(arg0);
0: 	}
0: 	return isEmptyStream;
/////////////////////////////////////////////////////////////////////////
0: 				    int column,
0: 				    int ndrdaType)
0: 	throws SQLException,
0: 	       IOException
0:     {
0: 	InputStream is = null;
0: 	try{
0: 	    // BLOBS
0: 	    if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
0: 		{
0: 		    blob = rs.getBlob(column);
0: 		    if(blob == null){
0: 			return false;
0: 		    }
0: 		    
0: 		    is = blob.getBinaryStream();
0: 		    
0: 		}
0: 	    // CLOBS
0: 	    else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
0: 		{	
0: 		    try {
0: 			clob = rs.getClob(column);
0: 			
0: 			if(clob == null){
0: 			    return false;
0: 			}
0: 			is = new ReEncodedInputStream(clob.getCharacterStream());
0: 			
0: 		    }catch (java.io.UnsupportedEncodingException e) {
0: 			throw new SQLException (e.getMessage());
0: 			
0: 		    }catch (IOException e){
0: 			throw new SQLException (e.getMessage());
0: 			
0: 		    }
0: 		    
0: 		}
0: 	    else
0: 		{
0: 		    if (SanityManager.DEBUG)
0: 			{
0: 			    SanityManager.THROWASSERT("NDRDAType: " + ndrdaType +
0: 						      " not valid EXTDTA object type");
0: 			}
0: 		}
0: 	    
0: 	    boolean exist = is.read() > -1;
0: 	    
0: 	    is.close();
0: 	    is = null;
0: 	    
0: 	    if(exist){
0: 		openInputStreamAgain();
0: 	    }
0: 	    return exist;
0: 	    
0: 	}catch(IllegalStateException e){
0: 	    throw Util.javaException(e);
0: 	}finally{
0: 	    if(is != null)
0: 		is.close();
0: 	    
0: 	}
0: 	
/////////////////////////////////////////////////////////////////////////
0: 	
0: 	if(this.binaryInputStream != null){
0: 	    return;
0: 	}
0: 		
0: 	InputStream is = null;
0: 	try{
0: 	    
0: 	    if(SanityManager.DEBUG){
0: 		SanityManager.ASSERT( ( blob != null && clob == null ) ||
0: 				      ( clob != null && blob == null ),
0: 				      "One of blob or clob must be non-null.");
0: 	    }
0: 	    if(blob != null){
0: 		is = blob.getBinaryStream();
0: 		
0: 	    }else if(clob != null){
0: 		is = new ReEncodedInputStream(clob.getCharacterStream());
0: 	    }
0: 	    
0: 	}catch(IOException e){
0: 	    throw new IllegalStateException(e.getMessage());
0: 	}
0: 	
0: 	if(! is.markSupported() ){
0: 	    is = new BufferedInputStream(is);
0: 	}
0: 	this.binaryInputStream = is;
0: 	close();
0: 	}
commit:d2989b7
/////////////////////////////////////////////////////////////////////////
0:         
0:         
0:                               int columnNumber,
0:                               int ndrdaType) 
0:         throws SQLException, IOException {
0:         
0:         this.dataResultSet = rs;
0:         this.isEmptyStream = ! initInputStream(rs,
0:                                                columnNumber,
0:                                                ndrdaType);
0:                 
/////////////////////////////////////////////////////////////////////////
0:      *                     DRDAConstants.DRDA_TYPE_NLOBBYTES
0:      *                     DRDAConstants.DRDA_TYPE_LOBBYTES
0:      *                     DRDAConstants.DRDA_TYPE_NLOBCMIXED
0:      *                     DRDAConstants.DRDA_TYPE_LOBCMIXED
0:      *                  rs.getBinaryStream(column) value and associated length
0:         throws SQLException {
0:         try{
0:             int ndrdaType = drdaType | 1; //nullable drdaType
0:                         
0:             return new EXTDTAInputStream(rs,
0:                                          column,
0:                                          ndrdaType);
0:                 
0:         }catch(IOException e){
0:             throw new SQLException(e.getMessage());
0:         }
0:                 
0:         
/////////////////////////////////////////////////////////////////////////
0:         throws SQLException {
0:         long length = 0;
0:         if (binaryInputStream == null)
0:             return length;
0:                 
0:         try {
0:             for (;;) {
0:                 int avail = binaryInputStream.available();
0:                 binaryInputStream.skip(avail);
0:                 if (avail == 0)
0:                     break;
0:                 length += avail;
0:                                 
0:             }
0:             //binaryInputStream.close();
0:         } catch (IOException ioe) {
0:             throw Util.javaException(ioe);
0:         }
0:         return length;
0:         
0:         
0:         return binaryInputStream.read();
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.available();
/////////////////////////////////////////////////////////////////////////
0:             
0:         try{
0:             if (binaryInputStream != null)
0:                 binaryInputStream.close();      
0:             binaryInputStream = null;
0:         }finally{
0:                 
0:             blob = null;
0:             clob = null;
0:             dataResultSet = null;
0:         }
0:             
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.equals(arg0);
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.hashCode();
/////////////////////////////////////////////////////////////////////////
0:         binaryInputStream.mark(arg0);
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.markSupported();
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.read(arg0);
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.read(arg0, arg1, arg2);
/////////////////////////////////////////////////////////////////////////
0:         binaryInputStream.reset();
/////////////////////////////////////////////////////////////////////////
0:         return binaryInputStream.skip(arg0);
0:         return isEmptyStream;
/////////////////////////////////////////////////////////////////////////
0:                                     int column,
0:                                     int ndrdaType)
0:         throws SQLException,
0:                IOException {
0:         InputStream is = null;
0:         try{
0:             // BLOBS
0:             if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) {
0:                 blob = rs.getBlob(column);
0:                 if(blob == null){
0:                     return false;
0:                 }
0:                     
0:                 is = blob.getBinaryStream();
0:                     
0:             } else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED) {  
0:                 try {
0:                     clob = rs.getClob(column);
0:                         
0:                     if(clob == null){
0:                         return false;
0:                     }
0:                     is = new ReEncodedInputStream(clob.getCharacterStream());
0:                         
0:                 }catch (java.io.UnsupportedEncodingException e) {
0:                     throw new SQLException (e.getMessage());
0:                         
0:                 }catch (IOException e){
0:                     throw new SQLException (e.getMessage());
0:                         
0:                 }
0:                     
0:             } else {
0:                 if (SanityManager.DEBUG) {
0:                     SanityManager.THROWASSERT("NDRDAType: " + ndrdaType +
0:                                               " not valid EXTDTA object type");
0:                 }
0:             }
0:             
0:             boolean exist = is.read() > -1;
0:             
0:             is.close();
0:             is = null;
0:             
0:             if(exist){
0:                 openInputStreamAgain();
0:             }
0:             return exist;
0:             
0:         }catch(IllegalStateException e){
0:             throw Util.javaException(e);
0:         }finally{
0:             if(is != null)
0:                 is.close();
0:             
0:         }
0:         
/////////////////////////////////////////////////////////////////////////
0:         
0:         if(this.binaryInputStream != null){
0:             return;
0:         }
0:                 
0:         InputStream is = null;
0:         try{
0:             
0:             if(SanityManager.DEBUG){
0:                 SanityManager.ASSERT( ( blob != null && clob == null ) ||
0:                                       ( clob != null && blob == null ),
0:                                       "One of blob or clob must be non-null.");
0:             }
0:             if(blob != null){
0:                 is = blob.getBinaryStream();
0:                 
0:             }else if(clob != null){
0:                 is = new ReEncodedInputStream(clob.getCharacterStream());
0:             }
0:             
0:         }catch(IOException e){
0:             throw new IllegalStateException(e.getMessage());
0:         }
0:         
0:         if(! is.markSupported() ){
0:             is = new BufferedInputStream(is);
0:         }
0:         this.binaryInputStream = is;
0:         close();
commit:9ab36fe
/////////////////////////////////////////////////////////////////////////
0: Derby - Class org.apache.derby.impl.drda.DRDAStatement
0: Copyright 2002, 2004 The Apache Software Foundation or its licensors, as applicable.
0: Licensed under the Apache License, Version 2.0 (the "License");
0: you may not use this file except in compliance with the License.
0: You may obtain a copy of the License at
0: http://www.apache.org/licenses/LICENSE-2.0
0: Unless required by applicable law or agreed to in writing, software
0: distributed under the License is distributed on an "AS IS" BASIS,
0: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: See the License for the specific language governing permissions and
0: limitations under the License.
0: */
/////////////////////////////////////////////////////////////////////////
0:     private EXTDTAInputStream(ResultSet rs,
0: 			      int columnNumber,
0: 			      int ndrdaType) 
0: 	throws SQLException, IOException
0: 	this.dataResultSet = rs;
0: 	this.isEmptyStream = ! initInputStream(rs,
0: 					       columnNumber,
0: 					       ndrdaType);
0:     }
0:     /**
0:      * Retrieve stream from the ResultSet and column specified.  Create an
0:      * input stream for the large object being retrieved. Do not hold
0:      * locks until end of transaction. DERBY-255.
0:      * 
0:      * 
0:      * See DDMWriter.writeScalarStream
0:      * 
0:      * @param rs
0:      *            result set from which to retrieve the lob
0:      * @param column
0:      *            column number
0:      * @param drdaType
0:      *            FD:OCA type of object one of
0:      * 			   DRDAConstants.DRDA_TYPE_NLOBBYTES
0:      * 			   DRDAConstants.DRDA_TYPE_LOBBYTES
0:      * 			   DRDAConstants.DRDA_TYPE_NLOBCMIXED
0:      *  		   DRDAConstants.DRDA_TYPE_LOBCMIXED
0:      * 
0:      * @return null if the value is null or a new EXTDTAInputStream corresponding to 
0:      *  		rs.getBinaryStream(column) value and associated length
0:      * 
0:      * @throws SQLException
0:      */
0:     public static EXTDTAInputStream getEXTDTAStream(ResultSet rs, int column, int drdaType) 
0: 	throws SQLException {
0: 	try{
0: 	    int ndrdaType = drdaType | 1; //nullable drdaType
0: 	    return new EXTDTAInputStream(rs,
0: 					 column,
0: 					 ndrdaType);
0: 	}catch(IOException e){
0: 	    throw new SQLException(e.getMessage());
0: 		
0:     }
0:     /**
0:      * Get the length of the InputStream 
0:      * This method is currently not used because there seems to be no way to 
0:      * reset the she stream.
0:      *   
0:      * @param binaryInputStream
0:      *            an InputStream whose length needs to be calclulated
0:      * @return length of stream
0:      */
0:     private static long getInputStreamLength(InputStream binaryInputStream)
0: 	throws SQLException {
0: 	long length = 0;
0: 	if (binaryInputStream == null)
0: 	    return length;
0: 	try {
0: 	    for (;;) {
0: 		int avail = binaryInputStream.available();
0: 		binaryInputStream.skip(avail);
0: 		if (avail == 0)
0: 		    break;
0: 		length += avail;
0: 	    //binaryInputStream.close();
0: 	} catch (IOException ioe) {
0: 	    throw Util.javaException(ioe);
0: 	}
0: 
0: 	return length;
0: 
0:     }
0: 	
0: 	
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#read()
0:      */
0:     public int read() throws IOException {
0: 	return binaryInputStream.read();
0:     }
0: 
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#available()
0:      */
0:     public int available() throws IOException {
0: 	return binaryInputStream.available();
0:     }
0: 
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#close()
0:      */
0:     public void close() throws IOException {
0: 	try{
0: 	    if (binaryInputStream != null)
0: 		binaryInputStream.close();	
0: 	    binaryInputStream = null;
0: 	}finally{
0: 		
0: 	    blob = null;
0: 	    clob = null;
0: 	    dataResultSet = null;
0: 	    
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.lang.Object#equals(java.lang.Object)
0:      */
0:     public boolean equals(Object arg0) {
0: 	return binaryInputStream.equals(arg0);
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.lang.Object#hashCode()
0:      */
0:     public int hashCode() {
0: 	return binaryInputStream.hashCode();
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#mark(int)
0:      */
0:     public void mark(int arg0) {
0: 	binaryInputStream.mark(arg0);
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#markSupported()
0:      */
0:     public boolean markSupported() {
0: 	return binaryInputStream.markSupported();
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#read(byte[])
0:      */
0:     public int read(byte[] arg0) throws IOException {
0: 	return binaryInputStream.read(arg0);
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#read(byte[], int, int)
0:      */
0:     public int read(byte[] arg0, int arg1, int arg2) throws IOException {
0: 	return binaryInputStream.read(arg0, arg1, arg2);
0:     }
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#reset()
0:      */
0:     public void reset() throws IOException {
0: 	binaryInputStream.reset();
0:     }
0: 
0:     /**
0:      * 
0:      * 
0:      * @see java.io.InputStream#skip(long)
0:      */
0:     public long skip(long arg0) throws IOException {
0: 	return binaryInputStream.skip(arg0);
0:     }
/////////////////////////////////////////////////////////////////////////
0:     }
commit:f3ab04f
/////////////////////////////////////////////////////////////////////////
0: import java.io.BufferedInputStream;
1: import java.sql.Blob;
1: import java.sql.Clob;
0: import java.io.UnsupportedEncodingException;
0: 
/////////////////////////////////////////////////////////////////////////
1:     private InputStream binaryInputStream = null;
0:     private boolean isEmptyStream;
0:     private ResultSet dataResultSet = null;
0:     private Blob blob = null;
0:     private Clob clob = null;
0: 	private EXTDTAInputStream(ResultSet rs,
0: 				  int columnNumber,
0: 				  int ndrdaType) 
0: 	    throws SQLException, IOException
0:     {
0: 	
0: 	    this.dataResultSet = rs;
0: 	    this.isEmptyStream = ! initInputStream(rs,
0: 						   columnNumber,
0: 						   ndrdaType);
0:     
0:     
0: 	 * input stream for the large object being retrieved. Do not hold
/////////////////////////////////////////////////////////////////////////
0:  	    try{
0: 		return new EXTDTAInputStream(rs,
0: 					     column,
0: 					     ndrdaType);
0: 		
0:  	    }catch(IOException e){
0:  		throw new SQLException(e.getMessage());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	    
0: 	    try{
0: 		binaryInputStream = null;
0: 
0: 	    }finally{
0: 		
0: 		blob = null;
0: 		clob = null;
0: 		dataResultSet = null;
0: 	    }
0: 	    
/////////////////////////////////////////////////////////////////////////
0:     protected boolean isEmptyStream(){
0: 	return isEmptyStream;
0:     }
0:     
0:     
0:     /**
1:      * This method takes information of ResultSet and 
0:      * initialize binaryInputStream variable of this object with not empty stream and return true.
0:      * If the stream was empty, this method remain binaryInputStream null and return false.
0:      *
0:      * @param rs        ResultSet object to get stream from.
0:      * @param column    index number of column in ResultSet to get stream.
0:      * @param ndrdaType describe type column to get stream.
0:      *
0:      * @return          true if the stream was not empty, false if the stream was empty.
0:      *
0:      */
0:     private boolean initInputStream(ResultSet rs,
0: 				    int column,
0: 				    int ndrdaType)
0: 	throws SQLException,
0: 	       IOException
0:     {
0: 
0: 	InputStream is = null;
0: 	try{
0: 	    // BLOBS
0: 	    if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
0: 		{
0: 		    blob = rs.getBlob(column);
0: 		    if(blob == null){
0: 			return false;
0: 		    }
0: 		    
0: 		    is = blob.getBinaryStream();
0: 		    
0: 		}
0: 	    // CLOBS
0: 	    else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
0: 		{	
0: 		    try {
0: 			clob = rs.getClob(column);
0: 			
0: 			if(clob == null){
0: 			    return false;
0: 			}
0: 
0: 			is = new ReEncodedInputStream(clob.getCharacterStream());
0: 			
0: 		    }catch (java.io.UnsupportedEncodingException e) {
0: 			throw new SQLException (e.getMessage());
0: 			
0: 		    }catch (IOException e){
0: 			throw new SQLException (e.getMessage());
0: 			
0: 		    }
0: 		    
0: 		}
0: 	    else
0: 		{
0: 		    if (SanityManager.DEBUG)
0: 			{
0: 			    SanityManager.THROWASSERT("NDRDAType: " + ndrdaType +
0: 						      " not valid EXTDTA object type");
0: 			}
0: 		}
0: 	    
0: 	    boolean exist = is.read() > -1;
0: 	    
0: 	    is.close();
0: 	    is = null;
0: 	    
0: 	    if(exist){
0: 		openInputStreamAgain();
0: 	    }
0: 
0: 	    return exist;
0: 	    
0: 	}catch(IllegalStateException e){
0: 	    throw Util.javaException(e);
0: 
0: 	}finally{
0: 	    if(is != null)
0: 		is.close();
0: 	    
0: 	}
0: 	
0:     }
0:     
0:     
0:     /**
0:      *
0:      * This method is called from initInputStream and 
0:      * opens inputstream again to stream actually.
0:      *
0:      */
0:     private void openInputStreamAgain() throws IllegalStateException,SQLException {
0: 	
0: 	if(this.binaryInputStream != null){
0: 	    return;
0: 	}
0: 		
0: 	InputStream is = null;
0: 	try{
0: 	    
0: 	    if(SanityManager.DEBUG){
0: 		SanityManager.ASSERT( ( blob != null && clob == null ) ||
0: 				      ( clob != null && blob == null ),
0: 				      "One of blob or clob must be non-null.");
0: 	    }
0: 
0: 	    if(blob != null){
0: 		is = blob.getBinaryStream();
0: 		
0: 	    }else if(clob != null){
0: 		is = new ReEncodedInputStream(clob.getCharacterStream());
0: 	    }
0: 	    
0: 	}catch(IOException e){
0: 	    throw new IllegalStateException(e.getMessage());
0: 	}
0: 	
0: 	if(! is.markSupported() ){
0: 	    is = new BufferedInputStream(is);
0: 	}
0: 
0: 	this.binaryInputStream = is;
0: 
0:     }
0:     
0:     
1:     protected void finalize() throws Throwable{
0: 	close();
0: 	}
0: 
0: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7df5ffe
/////////////////////////////////////////////////////////////////////////
1: class EXTDTAInputStream extends InputStream {
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
/////////////////////////////////////////////////////////////////////////
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_LOBBYTES
0: 	 * 			   DRDAConstants.DRDA_TYPE_NLOBCMIXED
0: 	 *  		   DRDAConstants.DRDA_TYPE_LOBCMIXED
/////////////////////////////////////////////////////////////////////////
0: 		if (ndrdaType == DRDAConstants.DRDA_TYPE_NLOBBYTES) 
/////////////////////////////////////////////////////////////////////////
0: 		else if (ndrdaType ==  DRDAConstants.DRDA_TYPE_NLOBCMIXED)
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * See DDMWriter.writeScalarStream
/////////////////////////////////////////////////////////////////////////
0: 	 * @return null if the value is null or a new EXTDTAInputStream corresponding to 
============================================================================