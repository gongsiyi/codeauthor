4:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.MethodCallNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
67:eac0369: 
13:eac0369:  */
1:4d80643: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:4d80643: 
1:eac0369: import java.lang.reflect.Member;
1:232d09a: import java.lang.reflect.Modifier;
1:e33b8d8: import java.sql.ParameterMetaData;
1:a2d0847: import java.sql.ResultSet;
1:9eb1bd1: import java.util.List;
1:4d80643: import java.util.StringTokenizer;
1:3bb140c: import org.apache.derby.catalog.TypeDescriptor;
1:3bb140c: import org.apache.derby.catalog.types.RoutineAliasInfo;
1:3bb140c: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1:3bb140c: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:8c39c1c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.LocalField;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1:3bb140c: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.store.access.Qualifier;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.JSQLType;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:d039ced: 
1:4aef9b0: /**
1:eac0369:  * A MethodCallNode represents a Java method call.  Method calls can be done
1:eac0369:  * through DML (as expressions) or through the CALL statement.
15:eac0369:  *
1:eac0369:  */
1:7b398e9: 
1:894b205: abstract class MethodCallNode extends JavaValueNode
25:eac0369: {
1:f52a50f: 	/*
1:eac0369: 	** Name of the method.
1:eac0369: 	*/
1:894b205: 	 String	methodName;
1:7b398e9: 
1:eac0369:     /** The name of the class containing the method. May not be known until bindExpression() has been called.
1:eac0369:      * @see #bindExpression
1:eac0369:      * @see #getJavaClassName()
1:eac0369:      */
1:894b205:     String javaClassName;
1:4aef9b0: 	
8:eac0369: 	/**
1:eac0369: 		For a procedure or function call
1:eac0369: 	*/
1:eac0369: 	RoutineAliasInfo routineInfo;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		True if this is an internal call, just used to set up a generated method call.
1:eac0369: 	*/
1:eac0369: 	boolean internalCall;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		For resolution of procedure INOUT/OUT parameters to the primitive
1:eac0369: 		form, such as int[]. May be null.
1:eac0369: 	*/
1:eac0369: 	private String[] procedurePrimitiveArrayType;
1:eac0369: 
1:eac0369: 	// bound signature of arguments, stated in universal types (JSQLType)
1:eac0369: 	protected JSQLType[]				signature;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Parameters to the method, if any.  No elements if no parameters.
1:eac0369: 	*/
1:eac0369: 	protected JavaValueNode[]	methodParms;
1:eac0369: 
1:eac0369: 	/* The method call */
1:eac0369: 	protected Member method;
1:eac0369: 
1:eac0369: 	protected String actualMethodReturnType;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The parameter types for the resolved method.
1:eac0369: 	*/
1:eac0369: 	String[] methodParameterTypes;
1:eac0369: 
1:3bb140c:     MethodCallNode(String methodName, ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:         this.methodName = methodName;
1:3bb140c:     }
1:7b398e9: 
1:3bb140c:     String getMethodName()
1:7b398e9: 	{
1:eac0369: 		return  methodName;
1:7b398e9: 	}
1:7b398e9: 
1:7b398e9:     /**
1:29007f0:      * <p>
1:29007f0:      * Get the schema-qualified name of the the routine. Is non-null only for
1:29007f0:      * StaticMethodCallNodes.
1:29007f0:      * </p>
1:29007f0:      */
1:29007f0:     TableName getFullName()
1:29007f0: 	{
1:29007f0: 		return  null;
1:29007f0: 	}
1:29007f0: 
1:29007f0:     /**
1:eac0369:      * @return the name of the class that contains the method, null if not known. It may not be known
1:eac0369:      *         until this node has been bound.
1:7b398e9:      */
1:eac0369:     public String getJavaClassName()
1:7b398e9:     {
1:eac0369:         return javaClassName;
1:7b398e9:     }
1:7b398e9: 
1:7b398e9:     /**
1:a2d0847:      * @return get the Java method or constructor determined during the bind() phase.
1:a2d0847:      */
1:a2d0847:     public Member getResolvedMethod()
1:a2d0847:     {
1:a2d0847:         return method;
1:a2d0847:     }
1:a2d0847: 
1:a2d0847:     /**
1:4aef9b0:      * Get the details on the invoked routines.
1:4aef9b0:      */
1:4aef9b0:     public RoutineAliasInfo getRoutineInfo()
1:4aef9b0:     {
1:4aef9b0:         return routineInfo;
1:7b398e9:     }
1:7b398e9: 
1:4d80643: 	/**
1:eac0369: 	 * Add the parameter list
1:7b398e9: 	 *
1:9eb1bd1: 	 * @param parameterList		A list of the parameters
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void addParms(List<ValueNode> parameterList) throws StandardException
1:eac0369: 	{
1:eac0369: 		methodParms = new JavaValueNode[parameterList.size()];
1:7b398e9: 
1:eac0369: 		int	plSize = parameterList.size();
1:eac0369: 		for (int index = 0; index < plSize; index++)
1:eac0369: 		{
1:3bb140c:             ValueNode qt = parameterList.get(index);
1:7b398e9: 
1:eac0369: 			/*
1:3905037: 			** Since we need the parameter to be in Java domain format, put a
1:3bb140c:             ** SQLToJavaValueNode on top of the ValueNode parameter node.
1:eac0369: 			*/
1:3bb140c:             JavaValueNode jqt =
1:3bb140c:                 new SQLToJavaValueNode(qt, getContextManager());
1:7b398e9: 
1:3bb140c:             methodParms[index] = jqt;
1:4aef9b0: 		}
35:eac0369: 	}
1:7b398e9: 
1:eac0369: 	/**
1:4aef9b0: 	  *	Get the resolved Classes of our parameters
1:4aef9b0: 	  *
1:4aef9b0: 	  *	@return	the Classes of our parameters
1:4aef9b0: 	  */
1:de00d25:     Class<?>[]  getMethodParameterClasses()
1:4aef9b0: 	{ 
1:4aef9b0: 		ClassInspector ci = getClassFactory().getClassInspector();
1:7b398e9: 
1:e1f49ca:         Class<?>[]  parmTypeClasses = new Class<?>[methodParms.length];
1:e1f49ca: 
1:4aef9b0: 		for (int i = 0; i < methodParms.length; i++)
1:4aef9b0: 		{
1:4aef9b0: 			String className = methodParameterTypes[i];
1:4aef9b0: 			try
1:4aef9b0: 			{
1:4aef9b0: 				parmTypeClasses[i] = ci.getClass(className);
1:4aef9b0: 			}
1:4aef9b0: 			catch (ClassNotFoundException cnfe)
1:4aef9b0: 			{
1:4aef9b0: 				/* We should never get this exception since we verified 
1:4aef9b0: 				 * that the classes existed at bind time.  Just return null.
1:4aef9b0: 				 */
1:4aef9b0: 				if (SanityManager.DEBUG)
1:4aef9b0: 				{
1:4aef9b0: 					SanityManager.THROWASSERT("Unexpected exception", cnfe);
1:4aef9b0: 				}
1:4aef9b0: 				return null;
1:4aef9b0: 			}
1:4aef9b0: 		}
1:4aef9b0: 
1:4aef9b0: 		return parmTypeClasses;
1:4aef9b0: 	}
1:4aef9b0: 
1:4aef9b0: 	/**
1:4aef9b0: 	 * Build a JBitSet of all of the tables that we are
1:4aef9b0: 	 * correlated with.
1:4aef9b0: 	 *
1:4aef9b0: 	 * @param correlationMap	The JBitSet of the tables that we are correlated with.
1:4aef9b0: 	 */
1:4aef9b0: 	void getCorrelationTables(JBitSet correlationMap)
1:4aef9b0: 		throws StandardException
1:4aef9b0: 	{
1:a6d25cd:         CollectNodesVisitor<ColumnReference> getCRs =
1:a6d25cd:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:3bbcfab: 		accept(getCRs);
1:a6d25cd:         for (ColumnReference ref : getCRs.getList())
1:4aef9b0: 		{
1:4aef9b0: 			if (ref.getCorrelated())
1:4aef9b0: 			{
1:4aef9b0: 				correlationMap.set(ref.getTableNumber());
1:4aef9b0: 			}
1:4aef9b0: 		}
1:4aef9b0: 	}
1:4aef9b0: 
1:4aef9b0: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:f52a50f: 	{
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			int	parm;
1:4aef9b0: 
1:eac0369: 			super.printSubNodes(depth);
2:eac0369: 			if (methodParms != null)
1:eac0369: 			{
1:eac0369: 				for (parm = 0; parm < methodParms.length; parm++)
1:eac0369: 				{
2:eac0369: 					if (methodParms[parm] != null)
1:eac0369: 					{
1:eac0369: 						printLabel(depth, "methodParms[" + parm + "] :");
1:eac0369: 						methodParms[parm].treePrint(depth + 1);
1:f52a50f: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:4d80643: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return "methodName: " +
1:eac0369: 					(methodName != null ? methodName : "null") + "\n" +
1:eac0369: 					super.toString();
1:eac0369: 		}
1:f52a50f: 		else
1:f52a50f: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this expression.  This means binding the sub-expressions,
1:eac0369: 	 * as well as figuring out what the return type is for this expression.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList		The FROM list for the query this
1:eac0369: 	 *				expression is in, for binding columns.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	final void bindParameters(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Bind the parameters */
1:eac0369: 		if (methodParms != null)
1:eac0369: 		{
1:eac0369: 			int		count = methodParms.length;
1:eac0369: 
1:eac0369: 			// with a procedure call the signature
1:eac0369: 			// is preformed in StaticMethodCall from
1:eac0369: 			// the procedures signature.
1:eac0369: 			if (signature == null) 
1:eac0369: 				signature = new JSQLType[ count ];
1:eac0369: 
1:eac0369: 			for (int parm = 0; parm < count; parm++)
1:eac0369: 			{
1:eac0369: 				if (methodParms[parm] != null)
1:eac0369: 				{
1:eac0369: 					methodParms[parm] =
1:eac0369: 						methodParms[parm].bindExpression(
1:09c2697:                             fromList, subqueryList, aggregates);
1:eac0369: 
1:eac0369: 					if (routineInfo == null)
1:eac0369: 						signature[ parm ] = methodParms[ parm ].getJSQLType();
1:eac0369:                     
1:5b0cb06:                     SelectNode.checkNoWindowFunctions(methodParms[parm], "method argument");
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not all of the parameters to this node are
1:eac0369: 	 * QUERY_INVARIANT or CONSTANT.  This is useful for VTIs - a VTI is a candidate
1:eac0369: 	 * for materialization if all of its parameters are QUERY_INVARIANT or CONSTANT
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not all of the parameters to this node are QUERY_INVARIANT or CONSTANT
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:eac0369: 	 protected boolean areParametersQueryInvariant() throws StandardException
1:eac0369: 	 {
1:eac0369: 		return (getVariantTypeOfParams() == Qualifier.QUERY_INVARIANT);
1:eac0369: 	 }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Build parameters for error message and throw the exception when there
1:eac0369: 	 * is no matching signature found.
1:eac0369: 	 *
1:eac0369: 	 * @param receiverTypeName	Type name for receiver
1:eac0369: 	 * @param parmTypeNames		Type names for parameters as object types
1:eac0369: 	 * @param primParmTypeNames	Type names for parameters as primitive types
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	void throwNoMethodFound(String receiverTypeName,
1:eac0369: 									  String[] parmTypeNames,
1:eac0369: 									  String[] primParmTypeNames)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Put the parameter type names into a single string */
1:3bb140c:         StringBuilder   parmTypes = new StringBuilder();
1:ba70926:         int     paramCount = signature.length;
1:ba70926: 		for (int i = 0; i < paramCount; i++)
1:eac0369: 		{
1:ba70926: 			if (i != 0) { parmTypes.append(", "); }
1:ba70926:             boolean isVararg = isVararg( i );
1:ba70926: 
1:eac0369: 			/* RESOLVE - shouldn't be using hard coded strings for output */
1:ba70926:             String  parmType = parmTypeNames[ i ];
1:ba70926:             if ( parmTypeNames [i ].length() == 0 ) { parmType = "UNTYPED"; }
1:ba70926:             else if ( isVararg ) { parmType = getVarargTypeName( parmType ); }
1:ba70926: 
1:ba70926:             parmTypes.append( parmType );
1:ba70926: 
1:eac0369: 			if ((primParmTypeNames != null) &&
1:eac0369: 				! primParmTypeNames[i].equals(parmTypeNames[i]))  // has primitive
1:ba70926:             {
1:ba70926:                 String  primTypeName = primParmTypeNames[ i ];
1:ba70926:                 if ( isVararg ) { primTypeName = getVarargTypeName( primTypeName ); }
1:ba70926: 				parmTypes.append("(" + primTypeName + ")");
1:ba70926:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(SQLState.LANG_NO_METHOD_FOUND, 
1:eac0369: 												receiverTypeName,
2:f52a50f: 												methodName,
1:eac0369: 											 	parmTypes);
1:eac0369: 	}
1:eac0369: 
1:ba70926:     /** Turn an array type name into the corresponding vararg type name */
1:ba70926:     private String  getVarargTypeName( String arrayTypeName )
1:ba70926:     {
1:ba70926:         return stripOneArrayLevel( arrayTypeName ) + "...";
1:ba70926:     }
1:ba70926: 
1:eac0369: 	/**
1:eac0369: 	 * Preprocess an expression tree.  We do a number of transformations
1:eac0369: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:eac0369: 	 * subquery flattening.
1:eac0369: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:eac0369: 	 * @param	numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param	outerFromList		FromList from outer query block
1:eac0369: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:eac0369: 	 * @param	outerPredicateList	PredicateList from outer query block
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:f52a50f: 	 */
1:9f2ed7d:     void preprocess(int numTables,
1:eac0369: 							FromList outerFromList,
1:eac0369: 							SubqueryList outerSubqueryList,
1:eac0369: 							PredicateList outerPredicateList) 
1:eac0369: 					throws StandardException
1:f52a50f: 	{
1:eac0369: 		int	parm;
1:eac0369: 
1:eac0369: 		/* Preprocess the parameters */
1:eac0369: 		if (methodParms != null)
1:eac0369: 		{
1:eac0369: 			for (parm = 0; parm < methodParms.length; parm++)
1:eac0369: 			{
1:eac0369: 				if (methodParms[parm] != null)
1:eac0369: 				{
1:eac0369: 					methodParms[parm].preprocess(numTables,
1:eac0369: 												 outerFromList,
1:eac0369: 												 outerSubqueryList,
1:eac0369: 												 outerPredicateList);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Categorize this predicate.  Initially, this means
1:eac0369: 	 * building a bit map of the referenced tables for each predicate.
1:eac0369: 	 * If the source of this ColumnReference (at the next underlying level) 
1:eac0369: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1:eac0369: 	 * will not be pushed down.
1:eac0369: 	 *
1:eac0369: 	 * For example, in:
1:eac0369: 	 *		select * from (select 1 from s) a (x) where x = 1
1:eac0369: 	 * we will not push down x = 1.
1:eac0369: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1:eac0369: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1:eac0369: 	 * that tree into the pushed predicate, and that tree could contain
1:eac0369: 	 * subqueries and method calls.
1:eac0369: 	 * RESOLVE - revisit this issue once we have views.
1:eac0369: 	 *
1:eac0369: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1:eac0369: 	 * @param simplePredsOnly	Whether or not to consider method
1:eac0369: 	 *							calls, field references and conditional nodes
1:eac0369: 	 *							when building bit map
1:eac0369: 	 *
1:eac0369: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1:eac0369: 	 *						or a VirtualColumnNode.
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We stop here when only considering simple predicates
1:eac0369: 		 *  as we don't consider method calls when looking
1:eac0369: 		 * for null invariant predicates.
1:eac0369: 		 */
1:eac0369: 		if (simplePredsOnly)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean pushable = true;
1:eac0369: 		int		param;
1:eac0369: 
1:eac0369: 		if (methodParms != null)
1:eac0369: 		{
2:eac0369: 			for (param = 0; param < methodParms.length; param++)
1:eac0369: 			{
1:eac0369: 				if (methodParms[param] != null)
1:eac0369: 				{
1:eac0369: 					pushable = methodParms[param].categorize(referencedTabs, simplePredsOnly) &&
1:eac0369: 							   pushable;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We need to push down method call.  Then the predicate can be used for start/stop
1:eac0369: 		 * key for index scan.  The fact that method call's cost is not predictable and can
1:eac0369: 		 * be expensive doesn't mean we shouldn't push it down. Beetle 4826.
1:eac0369: 		 */
1:eac0369: 		return pushable;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:eac0369: 	 *
1:eac0369: 	 * @return JavaValueNode			The remapped expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:9f2ed7d:     JavaValueNode remapColumnReferencesToExpressions()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int	param;
1:eac0369: 
1:eac0369: 		if (methodParms != null)
1:eac0369: 		{
1:eac0369: 			for (param = 0; param < methodParms.length; param++)
1:eac0369: 			{
1:eac0369: 				if (methodParms[param] != null)
1:eac0369: 				{
1:eac0369: 					methodParms[param] =
1:eac0369: 						methodParms[param].remapColumnReferencesToExpressions();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:232d09a:     /** Return true if the routine has varargs */
1:232d09a:     public  boolean hasVarargs()
1:232d09a:     {
1:232d09a:         return (routineInfo == null ) ? false : routineInfo.hasVarargs();
1:ba70926:     }
1:ba70926: 
1:ba70926:     /** Get the index of the first vararg if this is a varargs method */
1:ba70926:     public  int getFirstVarargIdx() { return signature.length - 1; }
1:ba70926: 
1:ba70926:     /** Return true if the parameter is a vararg */
1:ba70926:     public  boolean isVararg( int parameterNumber )
1:ba70926:     {
1:ba70926:         if ( !hasVarargs() ) { return false; }
1:ba70926:         else
1:ba70926:         {
1:ba70926:             return ( parameterNumber >= getFirstVarargIdx() );
1:ba70926:         }
1:ba70926:     }
1:232d09a: 
1:eac0369: 	/**
1:eac0369: 	 * Generate the parameters to the given method call
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @return	Count of arguments to the method.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public	int generateParameters(ExpressionClassBuilder acb,
1:eac0369: 											MethodBuilder mb)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		int				param;
1:7b398e9: 
1:232d09a:         int                 nonVarargCount = hasVarargs() ? routineInfo.getParameterCount() - 1 : methodParms.length;
1:232d09a:         int                 totalArgCount = hasVarargs() ? nonVarargCount + 1 : nonVarargCount;
1:eac0369: 
1:eac0369: 		/* Generate the code for each user parameter, generating the appropriate
1:eac0369: 		 * cast when the passed type needs to get widened to the expected type.
1:eac0369: 		 */
1:232d09a: 		for ( param = 0; param < nonVarargCount; param++ )
1:eac0369: 		{
1:232d09a:             generateAndCastOneParameter( acb, mb, param, methodParameterTypes[ param ] );
1:232d09a: 		}
1:7b398e9: 
1:232d09a:         if ( hasVarargs() ) { generateVarargs( acb, mb ); }
1:232d09a: 
1:232d09a: 		return totalArgCount;
1:eac0369: 	}
1:7b398e9: 
1:232d09a:     /**
1:232d09a:      * <p>
1:232d09a:      * Generate and cast one parameter, pushing the result onto the stack.
1:232d09a:      * </p>
1:232d09a:      */
1:232d09a:     private void    generateAndCastOneParameter
1:232d09a:         ( ExpressionClassBuilder acb, MethodBuilder mb, int param, String parameterType )
1:232d09a:         throws StandardException
1:232d09a:     {
1:232d09a: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1:232d09a: 
1:232d09a:         generateOneParameter( acb, mb, param );
1:232d09a: 
1:232d09a:         // type from the SQL-J expression
1:232d09a:         String argumentType = getParameterTypeName( methodParms[param] );
1:232d09a: 
1:232d09a:         if (!parameterType.equals(argumentType))
1:232d09a:         {
1:8c39c1c:             //
1:8c39c1c:             // This handles the conversion from primitive to wrapper type. See DERBY-6511.
1:8c39c1c:             // If the parameter type is the wrapper form of the primitive argument type,
1:8c39c1c:             // then call the "valueOf" static method of the wrapper type in order to convert
1:8c39c1c:             // the argument into a wrapper object. So, for instance, this converts a primitive "int"
1:8c39c1c:             // into a "java.lang.Integer".
1:8c39c1c:             //
1:8c39c1c:             if (
1:8c39c1c:                 ClassInspector.primitiveType( argumentType ) &&
1:8c39c1c:                 parameterType.equals( JSQLType.getWrapperClassName( JSQLType.getPrimitiveID( argumentType ) ) )
1:8c39c1c:                 )
1:8c39c1c:             {
1:8c39c1c:                 // short must be converted to int
1:8c39c1c:                 if ( "short".equals( argumentType ) )
1:8c39c1c:                 {
1:8c39c1c:                     mb.cast( "int" );
1:8c39c1c:                 }
1:8c39c1c:                 
1:8c39c1c:                 mb.callMethod
1:8c39c1c:                     (
1:8c39c1c:                      VMOpcode.INVOKESTATIC,
1:8c39c1c:                      parameterType,
1:8c39c1c:                      "valueOf",
1:8c39c1c:                      parameterType,
1:8c39c1c:                      1
1:8c39c1c:                      );
1:8c39c1c:             }
1:232d09a:             // since we reached here through method resolution
1:232d09a:             // casts are only required for primitive types.
1:232d09a:             // In any other case the expression type must be assignable
1:232d09a:             // to the parameter type.
1:8c39c1c:             else if (ClassInspector.primitiveType(parameterType))
1:232d09a:             {
1:232d09a:                 mb.cast(parameterType);
1:232d09a:             } else
1:232d09a:             {
1:232d09a:                 // for a procedure
1:232d09a:                 if (routineInfo != null)
1:232d09a:                 {
1:232d09a:                     return; // probably should be only for INOUT/OUT parameters.
1:232d09a:                 }
1:232d09a: 
1:232d09a:                 if (SanityManager.DEBUG)
1:232d09a:                 {
1:232d09a:                     SanityManager.ASSERT(classInspector.assignableTo(argumentType, parameterType),
1:232d09a:                                          "Argument type " + argumentType + " is not assignable to parameter " + parameterType);
1:232d09a:                 }
1:232d09a: 
1:232d09a:                 /*
1:232d09a:                 ** Set the parameter type in case the argument type is narrower
1:232d09a:                 ** than the parameter type.
1:232d09a:                 */
1:232d09a:                 mb.upCast(parameterType);
1:232d09a:             }
1:232d09a:         }
1:232d09a:     }
1:232d09a: 
1:232d09a:     /**
1:232d09a:      * <p>
1:232d09a:      * Generate the trailing routine arguments into a varargs array and
1:232d09a:      * push that array onto the stack.
1:232d09a:      * </p>
1:232d09a:      */
1:232d09a:     private void    generateVarargs
1:232d09a:         ( ExpressionClassBuilder acb, MethodBuilder mb )
1:232d09a:         throws StandardException
1:232d09a:     {
1:232d09a:         // the vararg is the last declared arg of the Java method. it is always
1:232d09a:         // an array type. right now we only support vararg static methods.
1:232d09a:         // if we have to support vararg constructors in the future, then this code
1:232d09a:         // will need adjustment.
1:ba70926:         int         firstVarargIdx = getFirstVarargIdx();
1:ba70926:         String      arrayType = methodParameterTypes[ firstVarargIdx ];
1:ba70926:         String      cellType = stripOneArrayLevel( arrayType );
1:ba70926:         String      varargType = cellType;
1:ba70926: 
1:ba70926:         // must strip another array level off of out and in/out parameters
1:ba70926:         if ( routineInfo != null )
1:ba70926:         {
1:e33b8d8:             if ( routineInfo.getParameterModes()[ firstVarargIdx ] != (ParameterMetaData.parameterModeIn) )
1:ba70926:             {
1:ba70926:                 varargType = stripOneArrayLevel( varargType );
1:ba70926:             }
1:ba70926:         }
1:ba70926: 
1:232d09a:         int         varargCount = methodParms.length - firstVarargIdx;
1:232d09a:         if ( varargCount < 0 ) { varargCount = 0; }
1:232d09a: 
1:232d09a:         // allocate an array to hold the varargs
1:ba70926: 		LocalField arrayField = acb.newFieldDeclaration( Modifier.PRIVATE, arrayType );
1:232d09a: 		MethodBuilder cb = acb.getConstructor();
1:ba70926: 		cb.pushNewArray( cellType, varargCount );
1:232d09a: 		cb.setField( arrayField );
1:232d09a: 
1:232d09a:         // now put the arguments into the array
1:232d09a:         for ( int i = 0; i < varargCount; i++ )
1:232d09a:         {
1:232d09a: 			mb.getField( arrayField ); // push the array onto the stack
1:232d09a:             // evaluate the parameter and push it onto the stack
1:ba70926:             generateAndCastOneParameter( acb, mb, i + firstVarargIdx, cellType );
1:232d09a:             mb.setArrayElement( i ); // move the parameter into the array, pop the stack
1:232d09a:         }
1:232d09a:         
1:232d09a:         // push the array onto the stack. it is the last parameter to the varargs routine.
1:232d09a:         mb.getField( arrayField );
1:232d09a:     }
1:232d09a: 
1:232d09a:     /**
1:232d09a:      * <p>
1:232d09a:      * Get the offset into the routine arguments corresponding to the index
1:232d09a:      * of the invocation parameter. The two indexes may be different in the case of
1:232d09a:      * varargs methods. There may be more invocation args than declared routine args.
1:232d09a:      * For a varargs routine, all of the trailing invocation parameters correspond to the
1:232d09a:      * last argument declared by the CREATE FUNCTION/PROCEDURE statement.
1:232d09a:      * </p>
1:232d09a:      */
1:232d09a:     protected   int getRoutineArgIdx( int invocationArgIdx )
1:232d09a:     {
1:232d09a:         if ( routineInfo == null ) { return invocationArgIdx; }
1:ba70926:         else { return getRoutineArgIdx( routineInfo, invocationArgIdx ); }
1:ba70926:     }
1:ba70926:     protected   int getRoutineArgIdx( RoutineAliasInfo rai, int invocationArgIdx )
1:ba70926:     {
1:ba70926:         if ( !rai.hasVarargs() ) { return invocationArgIdx; }
1:232d09a: 
1:232d09a:         // ok, this is a varargs routine
1:ba70926:         int         firstVarargIdx = rai.getParameterCount() - 1;
1:232d09a: 
1:232d09a:         return (firstVarargIdx < invocationArgIdx) ? firstVarargIdx : invocationArgIdx;
1:232d09a:     }
1:232d09a:     
1:232d09a: 
1:eac0369: 	static	public	String	getParameterTypeName( JavaValueNode param )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		String	argumentType;
1:232d09a: 
1:eac0369: 		// RESOLVE - shouldn't this logic be inside JavaValueNode ??
1:eac0369: 		// I.e. once the value is primitive then its java type name is its
1:eac0369: 		// primitive type name.
1:eac0369: 		if (param.isPrimitiveType()) { argumentType = param.getPrimitiveTypeName(); }
1:eac0369: 		else { argumentType = param.getJavaTypeName(); }
1:7b398e9: 
1:eac0369: 		return	argumentType;
1:eac0369: 	}
1:4d80643: 
1:eac0369: 	/**
1:eac0369: 	 * Generate one parameter to the given method call. This method is overriden by
1:eac0369: 	 * RepStaticMethodCallNode.
1:eac0369: 	 *
1:eac0369: 	 * @param acb				The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb the method the expression will go into
1:eac0369: 	 * @param parameterNumber	Identifies which parameter to generate. 0 based.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:9f2ed7d:     void generateOneParameter(ExpressionClassBuilder acb,
1:eac0369: 											MethodBuilder mb,
1:eac0369: 											int parameterNumber )
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		methodParms[parameterNumber].generateExpression(acb, mb);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the appropriate type information for a null passed as a parameter.
1:eac0369: 	 * This method is called after method resolution, when a signature was
1:eac0369: 	 * successfully matched.
1:eac0369: 	 *
1:eac0369: 	 * @param parmTypeNames	String[] with the java type names for the parameters
1:eac0369: 	 *        as declared by the method
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void    setNullParameterInfo(String[] parmTypeNames)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < methodParms.length; i++)
1:eac0369: 		{
1:eac0369: 			/* null parameters are represented by a java type name of "" */
1:eac0369: 			if (methodParms[i].getJavaTypeName().equals(""))
1:eac0369: 			{		
1:eac0369: 				/* Set the type information in the null constant node */
1:eac0369: 				DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(parmTypeNames[i]);
1:d5bc20f: 				((SQLToJavaValueNode)methodParms[i]).value.setType(dts);
1:eac0369: 
1:eac0369: 				/* Set the correct java type name */
1:eac0369: 				methodParms[i].setJavaTypeName(parmTypeNames[i]);
1:eac0369: 				signature[i] = methodParms[i].getJSQLType();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:232d09a: 	protected void resolveMethodCall
1:232d09a:         (
1:232d09a:          String javaClassName,
1:232d09a:          boolean staticMethod
1:232d09a:          ) 
1:232d09a:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// only allow direct method calls through routines and internal SQL.
1:eac0369: 		if (routineInfo == null && !internalCall)
1:eac0369: 		{
1:eac0369: 			// See if we are being executed in an internal context
1:eac0369: 			if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0) {
1:eac0369: 				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,  javaClassName + (staticMethod ? "::" : ".") + methodName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		int			count = signature.length;
1:eac0369: 
1:68573fc: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1:eac0369: 
1:eac0369: 		
1:4d80643: 		String[]		parmTypeNames;
1:eac0369: 		String[]		primParmTypeNames = null;
1:eac0369: 		boolean[]		isParam = getIsParam();
1:eac0369: 
1:232d09a: 		boolean hasDynamicResultSets = hasVarargs() ?
1:232d09a:             false :
1:232d09a:             (routineInfo != null) && (count != 0) && (count != methodParms.length);
1:eac0369: 
1:eac0369:         /*
1:f52a50f:         ** Find the matching method that is public.
1:f52a50f:         */
1:232d09a:         int signatureOffset = methodName.indexOf('(');
1:4d80643:         	
1:232d09a:         // support Java signatures by checking if the method name contains a '('
1:232d09a:         if (signatureOffset != -1) {
1:232d09a:             parmTypeNames = parseValidateSignature(methodName, signatureOffset, hasDynamicResultSets);
1:232d09a:             methodName = methodName.substring(0, signatureOffset);
1:232d09a:             
1:232d09a:             // If the signature is specified then Derby resolves to exactly
1:232d09a:             // that method. Setting this flag to false disables the method
1:232d09a:             // resolution from automatically optionally repeating the last
1:232d09a:             // parameter as needed.
1:232d09a:             hasDynamicResultSets = false;
1:232d09a:         }
1:232d09a:         else
1:232d09a:         {
1:232d09a:             parmTypeNames = getObjectSignature();
1:232d09a:         }
1:232d09a: 
1:232d09a:         // the actual type of the trailing Java varargs arg is an array
1:232d09a:         if ( hasVarargs() )
1:232d09a:         {
1:232d09a:             parmTypeNames[ count - 1 ] = parmTypeNames[ count - 1 ] + "[]";
1:232d09a:         }
1:232d09a: 
1:4d80643:         try
1:232d09a:         {
1:232d09a:             method = classInspector.findPublicMethod
1:232d09a:                 (
1:232d09a:                  javaClassName,
1:232d09a:                  methodName,
1:232d09a:                  parmTypeNames,
1:232d09a:                  null,
1:232d09a:                  isParam,
1:232d09a:                  staticMethod,
1:232d09a:                  hasDynamicResultSets,
1:232d09a:                  hasVarargs()
1:232d09a:                  );
1:4d80643: 
1:232d09a:             // DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
1:232d09a:             // and these are the only types that can map to a primitive or an object type according
1:232d09a:             // to SQL part 13. So we never have a second chance match.
1:232d09a:             // Also if the DDL specified a signature, then no alternate resolution
1:232d09a:             if (signatureOffset == -1 && routineInfo == null) {
1:eac0369: 
1:232d09a:                 /* If no match, then retry with combinations of object and
1:232d09a:                  * primitive types.
1:232d09a:                  */
1:232d09a:                 if (method == null)
1:232d09a:                 {
1:232d09a:                     primParmTypeNames = getPrimitiveSignature(false);
1:eac0369: 
1:232d09a:                     method = classInspector.findPublicMethod
1:232d09a:                         (
1:232d09a:                          javaClassName,
1:232d09a:                          methodName,
1:232d09a:                          parmTypeNames,
1:232d09a:                          primParmTypeNames,
1:232d09a:                          isParam,
1:232d09a:                          staticMethod,
1:232d09a:                          hasDynamicResultSets,
1:232d09a:                          hasVarargs()
1:232d09a:                          );
1:232d09a:                 }
1:4d80643:             }
1:f52a50f:         }
1:f52a50f:         catch (ClassNotFoundException e)
1:4d80643:         {
1:f52a50f:             /*
1:f52a50f:             ** If one of the classes couldn't be found, just act like the
1:f52a50f:             ** method couldn't be found.  The error lists all the class names,
1:f52a50f:             ** which should give the user enough info to diagnose the problem.
1:f52a50f:             */
1:f52a50f:             method = null;
1:f52a50f:         }
1:eac0369: 		/* Throw exception if no matching signature found */
1:f52a50f: 		if (method == null)
1:eac0369: 		{
1:eac0369: 			throwNoMethodFound(javaClassName, parmTypeNames, primParmTypeNames);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		String	typeName = classInspector.getType(method);
1:eac0369: 		actualMethodReturnType = typeName;
1:eac0369: 
1:f52a50f: 		if (routineInfo == null) {
1:eac0369: 
1:eac0369: 			/* void methods are only okay for CALL Statements */
1:eac0369: 			if (typeName.equals("void"))
1:f52a50f: 			{
1:eac0369: 				if (!forCallStatement)
1:eac0369: 					throw StandardException.newException(SQLState.LANG_VOID_METHOD_CALL);
1:f52a50f: 			}
1:f52a50f: 		}
3:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			String promoteName = null;
1:d039ced: 			TypeDescriptorImpl returnType = (TypeDescriptorImpl) routineInfo.getReturnType();
1:eac0369: 			String requiredType;
1:eac0369: 			if (returnType == null)
1:eac0369: 			{
1:eac0369: 				// must have a void method for a procedure call.
1:eac0369: 				requiredType = "void";
1:f52a50f: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
1:eac0369: 
1:4aef9b0: 				if (
1:4aef9b0: 				    returnType.isRowMultiSet() &&
1:4aef9b0: 				    ( routineInfo.getParameterStyle() == RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET )
1:4aef9b0: 				)
1:4aef9b0: 				{
1:a2d0847: 				    requiredType = ResultSet.class.getName();
1:eac0369: 				}
1:d039ced:                 else if ( returnType.getTypeId().userType() )
1:d039ced:                 {
1:d039ced:                     requiredType = ((UserDefinedTypeIdImpl) returnType.getTypeId()).getClassName();
1:d039ced:                 }
1:4aef9b0: 				else
1:4aef9b0: 				{
1:057ae46: 			 		requiredType = returnTypeId.getCorrespondingJavaTypeName();
1:eac0369: 
1:057ae46: 					if (!requiredType.equals(typeName)) {
1:057ae46: 						switch (returnType.getJDBCTypeId()) {
1:a584888: 						case java.sql.Types.BOOLEAN:
1:057ae46: 						case java.sql.Types.SMALLINT:
1:057ae46: 						case java.sql.Types.INTEGER:
1:057ae46: 						case java.sql.Types.BIGINT:
1:057ae46: 						case java.sql.Types.REAL:
1:057ae46: 						case java.sql.Types.DOUBLE:
1:057ae46: 							TypeCompiler tc = getTypeCompiler(returnTypeId);
1:057ae46: 							requiredType = tc.getCorrespondingPrimitiveTypeName();
1:057ae46: 							if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1:057ae46: 							{
1:057ae46: 								promoteName = returnTypeId.getCorrespondingJavaTypeName();
1:057ae46: 							}
1:057ae46: 							break;
1:057ae46: 						}
1:057ae46: 					}
1:4aef9b0: 				}
1:eac0369: 			}
1:eac0369: 
1:a2d0847:             boolean foundCorrectType;
1:a2d0847:             if ( ResultSet.class.getName().equals( requiredType )  )
1:a2d0847:             {
1:a2d0847:                 // allow subtypes of ResultSet too
1:a2d0847:                 try {
1:e1f49ca:                     Class<?> actualType = classInspector.getClass( typeName );
1:a2d0847: 
1:a2d0847:                     foundCorrectType = ResultSet.class.isAssignableFrom( actualType );
1:a2d0847:                 }
1:a2d0847:                 catch (ClassNotFoundException cnfe) { foundCorrectType = false; }
1:a2d0847:             }
1:a2d0847:             else{ foundCorrectType = requiredType.equals(typeName); }
1:a2d0847: 
1:a2d0847: 			if (!foundCorrectType)
1:4aef9b0: 			{
1:eac0369: 				throwNoMethodFound(requiredType + " " + javaClassName, parmTypeNames, primParmTypeNames);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// for a returns null on null input with a primitive
1:eac0369: 			// type we need to promote to an object so we can return null.
1:eac0369: 			if (promoteName != null)
1:eac0369: 				typeName = promoteName;
1:72abc72: 			//propogate collation type from RoutineAliasInfo to
1:72abc72: 			// MethodCallNode DERBY-2972
1:72abc72:                         if (routineInfo.getReturnType() != null)
1:72abc72:                             setCollationType(routineInfo.getReturnType().getCollationType());     
1:72abc72:                 }
1:eac0369: 	 	setJavaTypeName( typeName );
1:72abc72:                 
1:eac0369: 		methodParameterTypes = classInspector.getParameterTypes(method);
1:eac0369: 
1:ba70926:         String methodParameter = null;
1:ba70926:         
1:eac0369: 		for (int i = 0; i < methodParameterTypes.length; i++)
1:eac0369: 		{
1:ba70926: 			methodParameter = methodParameterTypes[i];
1:eac0369: 
3:eac0369: 			if (routineInfo != null) {
1:eac0369: 				if (i < routineInfo.getParameterCount()) {
1:ba70926: 					int parameterMode = routineInfo.getParameterModes()[ getRoutineArgIdx( i ) ];
1:eac0369: 
1:eac0369: 					switch (parameterMode) {
1:e33b8d8:                     case (ParameterMetaData.parameterModeIn):
1:4aef9b0: 						break;
1:e33b8d8:                     case (ParameterMetaData.parameterModeInOut):
1:eac0369: 						// we need to see if the type of the array is
1:eac0369: 						// primitive, not the array itself.
1:ba70926: 						methodParameter = stripOneArrayLevel( methodParameter );
5:eac0369: 						break;
1:eac0369: 
1:e33b8d8:                     case (ParameterMetaData.parameterModeOut):
1:eac0369: 						// value is not obtained *from* parameter.
1:eac0369: 						continue;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:ba70926:             //
1:ba70926:             // Strip off the array type if this is a varargs arg. We are only interested in
1:ba70926:             // whether we need to cast to the cell type.
1:ba70926:             //
1:ba70926:             if ( hasVarargs() && (i >= getFirstVarargIdx()) )
1:ba70926:             {
1:ba70926:                 methodParameter = stripOneArrayLevel( methodParameter );
1:ba70926:             }
1:ba70926: 
1:4d80643: 			if (ClassInspector.primitiveType(methodParameter))
1:ba70926:             {
1:ba70926:                 // varargs may be omitted, so there may not be an invocation argument
1:ba70926:                 // corresponding to the vararg
1:ba70926:                 if ( i < methodParms.length )
1:ba70926:                 {
1:ba70926:                     methodParms[i].castToPrimitive(true);
1:ba70926:                 }
1:ba70926:             }
1:eac0369: 		}
1:eac0369: 
1:ba70926:         // the last routine parameter may have been a varargs. if so,
1:ba70926:         // casting may be needed on the trailing varargs
1:ba70926:         if ( hasVarargs() )
1:ba70926:         {
1:ba70926:             int     firstVarargIdx = getFirstVarargIdx();
1:ba70926:             int     trailingVarargCount = methodParms.length - firstVarargIdx;
1:ba70926: 
1:ba70926:             // the first vararg was handled in the preceding loop
1:ba70926:             for ( int i = 1; i < trailingVarargCount; i++ )
1:ba70926:             {
1:ba70926:                 if (ClassInspector.primitiveType(methodParameter))
1:ba70926:                 {
1:ba70926:                     methodParms[ i + firstVarargIdx ].castToPrimitive(true);
1:ba70926:                 }
1:ba70926:             }
1:ba70926:         }
1:ba70926: 
1:eac0369: 		/* Set type info for any null parameters */
1:eac0369: 		if ( someParametersAreNull() )
1:eac0369: 		{
1:eac0369: 			setNullParameterInfo(methodParameterTypes);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369:     
1:eac0369: 		/* bug 4450 - if the callable statement is ? = call form, generate the metadata
1:eac0369: 		infor for the return parameter. We don't really need that info in order to
1:eac0369: 		execute the callable statement. But with jdbc3.0, this information should be
1:eac0369: 		made available for return parameter through ParameterMetaData class.
1:eac0369: 		Parser sets a flag in compilercontext if ? = call. If the flag is set,
1:eac0369: 		we generate the metadata info for the return parameter and reset the flag
1:eac0369: 		in the compilercontext for future call statements*/
1:eac0369: 		DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(typeName);
1:eac0369: 		if (getCompilerContext().getReturnParameterFlag()) {
1:b49cc55:             getParameterTypes()[0] = dts;
1:ba70926: 		}
1:eac0369:     }
1:ba70926: 
1:ba70926:     /** Strip the trailing [] from a type name */
1:ba70926:     protected String  stripOneArrayLevel( String typeName )
1:ba70926:     {
1:ba70926:         return typeName.substring( 0, typeName.length() - 2 );
1:ba70926:     }
1:eac0369: 	
1:eac0369: 	/**
1:4d80643: 	 * Parse the user supplied signature for a method and validate
1:4d80643: 	 * it, need to match the number of parameters passed in and match
1:4d80643: 	 * the valid types for the parameter.
1:4d80643: 	 * @param offset Character offset of first paren
1:4d80643: 	 * @param hasDynamicResultSets Can ResultSet[] parameters be specified.
1:4d80643: 	 * @return The valid array of types for resolution.
1:4d80643: 	 * @throws StandardException
1:4d80643: 	 */
1:4d80643: 	private String[] parseValidateSignature(String externalName, int offset,
1:4d80643: 			boolean hasDynamicResultSets)
1:4d80643: 		throws StandardException
1:4d80643: 	{
1:4d80643: 		int siglen = externalName.length();
1:4d80643: 
1:4d80643: 		// Ensure the opening paren is not the last
1:4d80643: 		// character and that the last character is a close paren
1:4d80643: 		if (((offset + 1) == siglen)
1:4d80643: 			|| (externalName.charAt(siglen - 1) != ')'))
1:4d80643: 			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:4d80643: 		
1:4d80643:         StringTokenizer st = new StringTokenizer(externalName.substring(offset + 1, siglen - 1), ",", true);
1:4d80643:         
1:4d80643:         String[] signatureTypes = new String[signature.length];
1:4d80643:         int count;
1:4d80643:         boolean seenClass = false;
1:4d80643:         for (count = 0; st.hasMoreTokens();)
1:4d80643:         {
1:4d80643:            	String type = st.nextToken().trim();
1:4d80643:  
1:4d80643:            	// check sequence is <class><comma>class> etc.
1:4d80643:            	if (",".equals(type))
1:4d80643:            	{
1:4d80643:            		if (!seenClass)
1:4d80643:            			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:4d80643:            		seenClass = false;
1:4d80643:            		continue;
1:4d80643:            	}
1:4d80643:            	else
1:4d80643:            	{
1:4d80643:            		if (type.length() == 0)
1:4d80643:            			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:4d80643:            		seenClass = true;
1:4d80643:            		count++;
1:4d80643:            	}
1:4d80643:            	           	           	           
1:4d80643:            	if (count > signature.length)
1:4d80643:         	{
1:4d80643:         		if (hasDynamicResultSets)
1:4d80643:         		{
1:4d80643:         			// Allow any number of dynamic result set holders
1:4d80643:         			// but they must match the exact type.
1:4d80643:         			String rsType = signature[signature.length - 1].getSQLType().
1:4d80643: 						getTypeId().getCorrespondingJavaTypeName();
1:4d80643:         			
1:4d80643:         			if (!type.equals(rsType))
1:4d80643:         				throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1:4d80643:                 				type, rsType);
1:4d80643: 
1:4d80643:         			if (signatureTypes.length == signature.length)
1:4d80643:         			{
1:4d80643:         				// expand once
1:4d80643:         				String[] sigs = new String[st.countTokens()];
1:4d80643:         				System.arraycopy(signatureTypes, 0, sigs, 0, signatureTypes.length);
1:4d80643:         				signatureTypes = sigs;
1:4d80643:         			}
1:4d80643:         			
1:4d80643:             		signatureTypes[count - 1] = type;
1:4d80643:             		continue;
1:4d80643:        			
1:4d80643:         		}
1:4d80643:     			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
1:4d80643:         				Integer.toString(count),
1:4d80643:         				Integer.toString(signature.length)); // too many types
1:4d80643:         	}
1:4d80643: 
1:4d80643:         	       	
1:4d80643:         	TypeId	paramTypeId = signature[count - 1].getSQLType().getTypeId();
1:4d80643:         	        	
1:4d80643:         	// Does it match the object name
1:4d80643:         	if (type.equals(paramTypeId.getCorrespondingJavaTypeName()))
1:4d80643:         	{
1:4d80643:         		signatureTypes[count - 1] = type;
1:4d80643:         		continue;
1:4d80643:         	}
1:4d80643:       	
1:4d80643:         	// how about the primitive name
1:4d80643: 			if ((paramTypeId.isNumericTypeId() && !paramTypeId.isDecimalTypeId())
1:4d80643: 					|| paramTypeId.isBooleanTypeId())
1:4d80643: 			{
1:4d80643: 				TypeCompiler tc = getTypeCompiler(paramTypeId);
1:4d80643: 				if (type.equals(tc.getCorrespondingPrimitiveTypeName()))
1:4d80643: 				{
1:4d80643: 		       		signatureTypes[count - 1] = type;
1:4d80643: 	        		continue;					
1:4d80643: 				}
1:4d80643: 			}
1:4d80643:         	throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1:4d80643:         				type, paramTypeId.getSQLTypeName()); // type conversion error
1:4d80643:         }
1:4d80643:         
1:4d80643:         // Did signature end with trailing comma?
1:4d80643:         if (count != 0 && !seenClass)
1:4d80643:         	throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:4d80643:         
1:4d80643:         if (count < signatureTypes.length)
1:4d80643:         {
1:4d80643:         	if (hasDynamicResultSets)
1:4d80643:         	{
1:4d80643:         		// we can tolerate a count of one less than the
1:4d80643:         		// expected count, which means the procedure is declared
1:4d80643:         		// to have dynamic result sets, but the explict signature
1:4d80643:         		// doesn't have any ResultSet[] types.
1:4d80643:         		// So accept, and procedure will automatically have 0
1:4d80643:         		// dynamic results at runtime
1:4d80643:         		if (count == (signature.length - 1))
1:4d80643:         		{
1:4d80643:         			String[] sigs = new String[count];
1:4d80643:         			System.arraycopy(signatureTypes, 0, sigs, 0, count);
1:4d80643:         			return sigs;
1:4d80643:         		}
1:4d80643:         	}
1:4d80643: 			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
1:4d80643:     				Integer.toString(count),
1:4d80643:     				Integer.toString(signature.length)); // too few types
1:4d80643:         }
1:4d80643: 
1:4d80643:         return signatureTypes;
1:4d80643: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Return true if some parameters are null, false otherwise.
1:eac0369: 	  */
1:eac0369: 	protected	boolean	someParametersAreNull()
1:eac0369: 	{
1:eac0369: 		int		count = signature.length;
1:eac0369: 		
1:eac0369: 		for ( int ictr = 0; ictr < count; ictr++ )
1:eac0369: 		{
1:eac0369: 			if ( signature[ictr] == null )
1:eac0369: 			{
1:eac0369: 				return true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Build an array of names of the argument types. These types are biased toward
1:eac0369: 	  *	Java objects. That is, if an argument is of SQLType, then we map it to the
1:eac0369: 	  *	corresponding Java synonym class (e.g., SQLINT is mapped to 'java.lang.Integer').
1:eac0369: 	  *
1:eac0369: 	  *
1:eac0369: 	  *	@return	array of type names
1:eac0369: 	  *
1:eac0369: 	  * @exception StandardException		Thrown on error
1:eac0369: 	  */
1:eac0369: 	protected	String[]	getObjectSignature( )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int		count = signature.length;
1:eac0369: 		String	parmTypeNames[] = new String[ count ];
1:eac0369: 
1:c8603c4:         TypeCompilerFactory tcf = (routineInfo == null ) ? null : getCompilerContext().getTypeCompilerFactory();
1:c8603c4: 
1:c8603c4: 		for ( int i = 0; i < count; i++ ) { parmTypeNames[i] = getObjectTypeName( signature[ i ], tcf ); }
1:eac0369: 
1:eac0369: 		return parmTypeNames;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Build an array of booleans denoting whether or not a given method
1:eac0369: 	 * parameter is a ?.
1:eac0369: 	 *
1:eac0369: 	 * @return array of booleans denoting wheter or not a given method
1:eac0369: 	 * parameter is a ?.
1:eac0369: 	 */
1:eac0369: 	protected boolean[] getIsParam()
1:eac0369: 	{
1:eac0369: 		if (methodParms == null)
1:eac0369: 		{
1:eac0369: 			return new boolean[0];
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		boolean[] isParam = new boolean[methodParms.length];
1:eac0369: 
1:eac0369: 		for (int index = 0; index < methodParms.length; index++)
1:eac0369: 		{
1:eac0369: 			if (methodParms[index] instanceof SQLToJavaValueNode)
1:eac0369: 			{
1:eac0369: 				SQLToJavaValueNode stjvn = (SQLToJavaValueNode) methodParms[index];
1:d5bc20f: 				if (stjvn.value.requiresTypeFromContext())
1:eac0369: 				{
1:eac0369: 					isParam[index] = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return isParam;
1:eac0369: 	}
1:eac0369: 
1:e1f49ca:     @SuppressWarnings("fallthrough")
1:c8603c4: 	static  String	getObjectTypeName( JSQLType jsqlType, TypeCompilerFactory tcf )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if ( jsqlType != null )
1:eac0369: 		{
2:eac0369: 			switch( jsqlType.getCategory() )
1:eac0369: 			{
1:eac0369: 			    case JSQLType.SQLTYPE: 
1:eac0369: 
2:eac0369: 					TypeId	ctid = mapToTypeID( jsqlType );
1:eac0369: 
1:eac0369: 					if ( ctid == null ) { return null; }
1:eac0369: 					else {
1:f52a50f: 						// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
1:f52a50f: 						// and these are the only types that can map to a primitive or an object type according
2:eac0369: 						// to SQL part 13. So always map to the primitive type. We can not use the getPrimitiveSignature()
2:eac0369: 						// as it (incorrectly but historically always has) maps a DECIMAL to a double. 
1:eac0369: 
1:eac0369: 						switch (ctid.getJDBCTypeId()) {
1:4bad559: 						case java.sql.Types.BOOLEAN:
1:4aef9b0: 						case java.sql.Types.SMALLINT:
1:4aef9b0: 						case java.sql.Types.INTEGER:
1:4aef9b0: 						case java.sql.Types.BIGINT:
1:4aef9b0: 						case java.sql.Types.REAL:
1:4aef9b0: 						case java.sql.Types.DOUBLE:
1:c8603c4: 							if (tcf != null) {
1:c8603c4: 								return tcf.getTypeCompiler( ctid ).getCorrespondingPrimitiveTypeName();
1:eac0369: 							}
1:eac0369: 							// fall through
1:4aef9b0: 						default:
1:eac0369: 							return ctid.getCorrespondingJavaTypeName();
1:4aef9b0: 						}
1:4aef9b0: 					}
1:eac0369: 
1:eac0369: 		        case JSQLType.JAVA_CLASS: return jsqlType.getJavaClassName();
1:eac0369: 
1:23ecfcf: 		        case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( jsqlType.getPrimitiveKind() );
1:eac0369: 
3:eac0369: 		        default:
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
2:eac0369: 					{ SanityManager.THROWASSERT( "Unknown JSQLType: " + jsqlType ); }
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return "";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	String[]	getPrimitiveSignature( boolean castToPrimitiveAsNecessary )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int					count = signature.length;
1:eac0369: 		String[] 			primParmTypeNames = new String[ count ];
1:3bb140c:         JSQLType            jsqlTyp;
1:eac0369: 
1:eac0369: 		for (int i = 0; i < count; i++)
1:eac0369: 		{
1:3bb140c:             jsqlTyp = signature[ i ];
1:eac0369: 
1:3bb140c:             if ( jsqlTyp == null ) { primParmTypeNames[i] = ""; }
1:eac0369: 			else
1:eac0369: 			{
1:3bb140c:                 switch( jsqlTyp.getCategory() )
1:eac0369: 			    {
1:eac0369: 			        case JSQLType.SQLTYPE:
1:eac0369: 
1:eac0369: 						if ((procedurePrimitiveArrayType != null)
1:eac0369: 							&& (i < procedurePrimitiveArrayType.length)
1:eac0369: 							&& (procedurePrimitiveArrayType[i] != null)) {
1:eac0369: 
1:eac0369: 							primParmTypeNames[i] = procedurePrimitiveArrayType[i];
1:eac0369: 
2:eac0369: 						} else {
1:eac0369: 
1:eac0369: 
1:3bb140c:                             TypeId  ctid = mapToTypeID( jsqlTyp );
1:eac0369: 
1:509ccb9: 							if ((ctid.isNumericTypeId() && !ctid.isDecimalTypeId()) || ctid.isBooleanTypeId())
1:eac0369: 							{
2:eac0369: 								TypeCompiler tc = getTypeCompiler(ctid);
1:eac0369: 								primParmTypeNames[i] = tc.getCorrespondingPrimitiveTypeName();
1:eac0369: 								if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
1:eac0369: 							}
1:eac0369: 							else { primParmTypeNames[i] = ctid.getCorrespondingJavaTypeName(); }
1:eac0369: 						}
1:eac0369: 
1:4aef9b0: 						break;
1:eac0369: 
1:eac0369: 		            case JSQLType.JAVA_CLASS:
1:eac0369: 
1:3bb140c:                         primParmTypeNames[i] = jsqlTyp.getJavaClassName();
1:eac0369: 						break;
1:eac0369: 
1:eac0369: 		            case JSQLType.JAVA_PRIMITIVE:
1:eac0369: 
1:3bb140c:                         primParmTypeNames[i] = JSQLType.getPrimitiveName(
1:3bb140c:                             jsqlTyp.getPrimitiveKind());
1:3bb140c: 
1:eac0369: 						if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
1:eac0369: 						break;
1:eac0369: 
1:eac0369: 		            default:
1:eac0369: 
1:3bb140c:                         if (SanityManager.DEBUG) {
1:3bb140c:                             SanityManager.THROWASSERT(
1:3bb140c:                                 "Unknown JSQLType: " + jsqlTyp );
1:3bb140c:                         }
1:eac0369: 
1:eac0369: 				}	// end switch
1:eac0369: 
1:eac0369: 			}		// end if
1:eac0369: 
1:eac0369: 		}			// end for
1:eac0369: 
1:eac0369: 		return primParmTypeNames;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the variant type for the underlying expression.
1:eac0369: 	 * The variant type can be:
1:eac0369: 	 *		VARIANT				- variant within a scan
1:eac0369: 	 *							  (non-static field access)
1:eac0369: 	 *		SCAN_INVARIANT		- invariant within a scan
1:eac0369: 	 *							  (column references from outer tables)
1:eac0369: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1:eac0369: 	 *							  (constant expressions)
1:eac0369: 	 *
1:eac0369: 	 * @return	The variant type for the underlying expression.
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     int getOrderableVariantType() throws StandardException
1:eac0369: 	{
1:eac0369: 		// beetle 4880. We return the most variant type of the parameters. If no
1:eac0369: 		// params then query-invariant. This makes more sense, and we can evaluate
1:eac0369: 		// only once per query (good for performance) because method call could be
1:eac0369: 		// expensive.  And if we push down method qualifier to store, language
1:eac0369: 		// can pre-evaluate the method call.  This avoids letting store evaluate
1:eac0369: 		// the method while holding page latch, causing deadlock.
1:eac0369: 
1:eac0369: 		return getVariantTypeOfParams();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int getVariantTypeOfParams() throws StandardException
1:eac0369: 	{
1:eac0369: 		int variance = Qualifier.QUERY_INVARIANT;
1:eac0369: 
1:eac0369: 		if (methodParms != null)
1:eac0369: 		{
2:eac0369: 			for (int parm = 0; parm < methodParms.length; parm++)
1:eac0369: 			{
1:eac0369: 				if (methodParms[parm] != null)
1:eac0369: 				{
1:eac0369: 					int paramVariantType =
1:eac0369: 						methodParms[parm].getOrderableVariantType();
1:eac0369: 					if (paramVariantType < variance)	//return the most variant type
1:eac0369: 						variance = paramVariantType;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					variance = Qualifier.VARIANT;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return variance;
1:eac0369: 	}
1:eac0369: 
1:30fa79b:     /**
1:30fa79b:      * Override method in ancestor.
1:30fa79b:      */
1:3bb140c:     @Override
1:9f2ed7d:     DataTypeDescriptor getDataType() throws StandardException
1:30fa79b:     {
1:30fa79b:         if ( routineInfo != null )
1:30fa79b:         {
1:30fa79b:             TypeDescriptor td = routineInfo.getReturnType();
1:30fa79b: 
1:30fa79b:             if ( td != null ) { return DataTypeDescriptor.getType( td ); }
1:30fa79b:         }
1:30fa79b: 
1:30fa79b:         return super.getDataType();
1:30fa79b:     }
1:30fa79b: 
1:eac0369: 
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	//	ACCESSORS
1:eac0369: 	//
1:eac0369: 	/////////////////////////////////////////////////////////////////////
1:eac0369: 	/**
1:eac0369: 	 * Get the method parameters.
1:eac0369: 	 * 
1:eac0369: 	 * @return	The method parameters
1:eac0369: 	 */
1:3bb140c:     JavaValueNode[] getMethodParms()
1:eac0369: 	{
1:eac0369: 		return methodParms;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:7b398e9: 	 * @exception StandardException on error
1:7b398e9: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:7b398e9: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:7b398e9: 
1:eac0369: 		for (int parm = 0; 
1:eac0369: 			!v.stopTraversal() && parm < methodParms.length; 
1:eac0369: 			parm++)
1:eac0369: 		{
1:eac0369: 			if (methodParms[parm] != null)
1:eac0369: 			{
1:eac0369: 				methodParms[parm] = (JavaValueNode)methodParms[parm].accept(v);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:5b0cb06
/////////////////////////////////////////////////////////////////////////
1:                     SelectNode.checkNoWindowFunctions(methodParms[parm], "method argument");
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
0:     public  Class<?>[]  getMethodParameterClasses()
1:         Class<?>[]  parmTypeClasses = new Class<?>[methodParms.length];
1: 
/////////////////////////////////////////////////////////////////////////
1:                     Class<?> actualType = classInspector.getClass( typeName );
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("fallthrough")
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: import org.apache.derby.catalog.types.TypeDescriptorImpl;
1: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.TypeCompiler;
1: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: import org.apache.derby.iapi.types.JSQLType;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1:     MethodCallNode(String methodName, ContextManager cm) {
1:         super(cm);
1:         this.methodName = methodName;
1:     }
1:     String getMethodName()
/////////////////////////////////////////////////////////////////////////
1:     void addParms(List<ValueNode> parameterList) throws StandardException
1:             ValueNode qt = parameterList.get(index);
1:             ** SQLToJavaValueNode on top of the ValueNode parameter node.
1:             JavaValueNode jqt =
1:                 new SQLToJavaValueNode(qt, getContextManager());
1:             methodParms[index] = jqt;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder   parmTypes = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:     void    setNullParameterInfo(String[] parmTypeNames)
/////////////////////////////////////////////////////////////////////////
1:         JSQLType            jsqlTyp;
1:             jsqlTyp = signature[ i ];
1:             if ( jsqlTyp == null ) { primParmTypeNames[i] = ""; }
1:                 switch( jsqlTyp.getCategory() )
/////////////////////////////////////////////////////////////////////////
1:                             TypeId  ctid = mapToTypeID( jsqlTyp );
/////////////////////////////////////////////////////////////////////////
1:                         primParmTypeNames[i] = jsqlTyp.getJavaClassName();
1:                         primParmTypeNames[i] = JSQLType.getPrimitiveName(
1:                             jsqlTyp.getPrimitiveKind());
1: 
1:                         if (SanityManager.DEBUG) {
1:                             SanityManager.THROWASSERT(
1:                                 "Unknown JSQLType: " + jsqlTyp );
1:                         }
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     JavaValueNode[] getMethodParms()
/////////////////////////////////////////////////////////////////////////
1:     @Override
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:de00d25
/////////////////////////////////////////////////////////////////////////
1:     Class<?>[]  getMethodParameterClasses()
commit:8c39c1c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // This handles the conversion from primitive to wrapper type. See DERBY-6511.
1:             // If the parameter type is the wrapper form of the primitive argument type,
1:             // then call the "valueOf" static method of the wrapper type in order to convert
1:             // the argument into a wrapper object. So, for instance, this converts a primitive "int"
1:             // into a "java.lang.Integer".
1:             //
1:             if (
1:                 ClassInspector.primitiveType( argumentType ) &&
1:                 parameterType.equals( JSQLType.getWrapperClassName( JSQLType.getPrimitiveID( argumentType ) ) )
1:                 )
1:             {
1:                 // short must be converted to int
1:                 if ( "short".equals( argumentType ) )
1:                 {
1:                     mb.cast( "int" );
1:                 }
1:                 
1:                 mb.callMethod
1:                     (
1:                      VMOpcode.INVOKESTATIC,
1:                      parameterType,
1:                      "valueOf",
1:                      parameterType,
1:                      1
1:                      );
1:             }
1:             else if (ClassInspector.primitiveType(parameterType))
commit:29007f0
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * Get the schema-qualified name of the the routine. Is non-null only for
1:      * StaticMethodCallNodes.
1:      * </p>
1:      */
1:     TableName getFullName()
1: 	{
1: 		return  null;
1: 	}
1: 
1:     /**
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:ba70926
/////////////////////////////////////////////////////////////////////////
0:         boolean hasVarargs = hasVarargs();
1:         int     firstVarargIdx = getFirstVarargIdx();
1:         int     paramCount = signature.length;
1: 		for (int i = 0; i < paramCount; i++)
1: 			if (i != 0) { parmTypes.append(", "); }
1:             boolean isVararg = isVararg( i );
1: 
1:             String  parmType = parmTypeNames[ i ];
1:             if ( parmTypeNames [i ].length() == 0 ) { parmType = "UNTYPED"; }
1:             else if ( isVararg ) { parmType = getVarargTypeName( parmType ); }
1: 
1:             parmTypes.append( parmType );
1: 
1:             {
1:                 String  primTypeName = primParmTypeNames[ i ];
1:                 if ( isVararg ) { primTypeName = getVarargTypeName( primTypeName ); }
1: 				parmTypes.append("(" + primTypeName + ")");
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /** Turn an array type name into the corresponding vararg type name */
1:     private String  getVarargTypeName( String arrayTypeName )
1:     {
1:         return stripOneArrayLevel( arrayTypeName ) + "...";
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /** Get the index of the first vararg if this is a varargs method */
1:     public  int getFirstVarargIdx() { return signature.length - 1; }
1: 
1:     /** Return true if the parameter is a vararg */
1:     public  boolean isVararg( int parameterNumber )
1:     {
1:         if ( !hasVarargs() ) { return false; }
1:         else
1:         {
1:             return ( parameterNumber >= getFirstVarargIdx() );
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         int         firstVarargIdx = getFirstVarargIdx();
1:         String      arrayType = methodParameterTypes[ firstVarargIdx ];
1:         String      cellType = stripOneArrayLevel( arrayType );
1:         String      varargType = cellType;
1: 
1:         // must strip another array level off of out and in/out parameters
1:         if ( routineInfo != null )
1:         {
0:             if ( routineInfo.getParameterModes()[ firstVarargIdx ] != JDBC30Translation.PARAMETER_MODE_IN )
1:             {
1:                 varargType = stripOneArrayLevel( varargType );
1:             }
1:         }
1: 
1: 		LocalField arrayField = acb.newFieldDeclaration( Modifier.PRIVATE, arrayType );
1: 		cb.pushNewArray( cellType, varargCount );
/////////////////////////////////////////////////////////////////////////
1:             generateAndCastOneParameter( acb, mb, i + firstVarargIdx, cellType );
/////////////////////////////////////////////////////////////////////////
1:         else { return getRoutineArgIdx( routineInfo, invocationArgIdx ); }
1:     }
1:     protected   int getRoutineArgIdx( RoutineAliasInfo rai, int invocationArgIdx )
1:     {
1:         if ( !rai.hasVarargs() ) { return invocationArgIdx; }
1:         int         firstVarargIdx = rai.getParameterCount() - 1;
/////////////////////////////////////////////////////////////////////////
1:         String methodParameter = null;
1:         
1: 			methodParameter = methodParameterTypes[i];
1: 					int parameterMode = routineInfo.getParameterModes()[ getRoutineArgIdx( i ) ];
/////////////////////////////////////////////////////////////////////////
1: 						methodParameter = stripOneArrayLevel( methodParameter );
/////////////////////////////////////////////////////////////////////////
1:             //
1:             // Strip off the array type if this is a varargs arg. We are only interested in
1:             // whether we need to cast to the cell type.
1:             //
1:             if ( hasVarargs() && (i >= getFirstVarargIdx()) )
1:             {
1:                 methodParameter = stripOneArrayLevel( methodParameter );
1:             }
1: 
1:             {
1:                 // varargs may be omitted, so there may not be an invocation argument
1:                 // corresponding to the vararg
1:                 if ( i < methodParms.length )
1:                 {
1:                     methodParms[i].castToPrimitive(true);
1:                 }
1:             }
1:         // the last routine parameter may have been a varargs. if so,
1:         // casting may be needed on the trailing varargs
1:         if ( hasVarargs() )
1:         {
0:             int     firstVarargIdx = getFirstVarargIdx();
1:             int     trailingVarargCount = methodParms.length - firstVarargIdx;
1: 
1:             // the first vararg was handled in the preceding loop
1:             for ( int i = 1; i < trailingVarargCount; i++ )
1:             {
1:                 if (ClassInspector.primitiveType(methodParameter))
1:                 {
1:                     methodParms[ i + firstVarargIdx ].castToPrimitive(true);
1:                 }
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /** Strip the trailing [] from a type name */
1:     protected String  stripOneArrayLevel( String typeName )
1:     {
1:         return typeName.substring( 0, typeName.length() - 2 );
1:     }
commit:232d09a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.compiler.LocalField;
/////////////////////////////////////////////////////////////////////////
0: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if the routine has varargs */
1:     public  boolean hasVarargs()
1:     {
1:         return (routineInfo == null ) ? false : routineInfo.hasVarargs();
1:     }   
1: 
/////////////////////////////////////////////////////////////////////////
1:         int                 nonVarargCount = hasVarargs() ? routineInfo.getParameterCount() - 1 : methodParms.length;
1:         int                 totalArgCount = hasVarargs() ? nonVarargCount + 1 : nonVarargCount;
1: 		for ( param = 0; param < nonVarargCount; param++ )
1:             generateAndCastOneParameter( acb, mb, param, methodParameterTypes[ param ] );
1:         if ( hasVarargs() ) { generateVarargs( acb, mb ); }
1: 
1: 		return totalArgCount;
1:     /**
1:      * <p>
1:      * Generate and cast one parameter, pushing the result onto the stack.
1:      * </p>
1:      */
1:     private void    generateAndCastOneParameter
1:         ( ExpressionClassBuilder acb, MethodBuilder mb, int param, String parameterType )
1:         throws StandardException
1:     {
1: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
1:         generateOneParameter( acb, mb, param );
1: 
1:         // type from the SQL-J expression
1:         String argumentType = getParameterTypeName( methodParms[param] );
1: 
1:         if (!parameterType.equals(argumentType))
1:         {
1:             // since we reached here through method resolution
1:             // casts are only required for primitive types.
1:             // In any other case the expression type must be assignable
1:             // to the parameter type.
0:             if (ClassInspector.primitiveType(parameterType))
1:             {
1:                 mb.cast(parameterType);
1:             } else
1:             {
1:                 // for a procedure
1:                 if (routineInfo != null)
1:                 {
1:                     return; // probably should be only for INOUT/OUT parameters.
1:                 }
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT(classInspector.assignableTo(argumentType, parameterType),
1:                                          "Argument type " + argumentType + " is not assignable to parameter " + parameterType);
1:                 }
1: 
1:                 /*
1:                 ** Set the parameter type in case the argument type is narrower
1:                 ** than the parameter type.
1:                 */
1:                 mb.upCast(parameterType);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Generate the trailing routine arguments into a varargs array and
1:      * push that array onto the stack.
1:      * </p>
1:      */
1:     private void    generateVarargs
1:         ( ExpressionClassBuilder acb, MethodBuilder mb )
1:         throws StandardException
1:     {
1:         // the vararg is the last declared arg of the Java method. it is always
1:         // an array type. right now we only support vararg static methods.
1:         // if we have to support vararg constructors in the future, then this code
1:         // will need adjustment.
0:         Class[]     parameterTypes = ((Method) method).getParameterTypes();
0:         int         firstVarargIdx = parameterTypes.length - 1;
0:         Class       varargType = parameterTypes[ firstVarargIdx ].getComponentType();
1:         
1:         int         varargCount = methodParms.length - firstVarargIdx;
1:         if ( varargCount < 0 ) { varargCount = 0; }
1: 
1:         // allocate an array to hold the varargs
0: 		LocalField arrayField = acb.newFieldDeclaration( Modifier.PRIVATE, varargType.getName() + "[]" );
1: 		MethodBuilder cb = acb.getConstructor();
0: 		cb.pushNewArray( varargType.getName(), varargCount );
1: 		cb.setField( arrayField );
1: 
1:         // now put the arguments into the array
1:         for ( int i = 0; i < varargCount; i++ )
1:         {
1: 			mb.getField( arrayField ); // push the array onto the stack
1:             // evaluate the parameter and push it onto the stack
0:             generateAndCastOneParameter( acb, mb, i + firstVarargIdx, methodParameterTypes[ firstVarargIdx ] );
1:             mb.setArrayElement( i ); // move the parameter into the array, pop the stack
1:         }
1:         
1:         // push the array onto the stack. it is the last parameter to the varargs routine.
1:         mb.getField( arrayField );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the offset into the routine arguments corresponding to the index
1:      * of the invocation parameter. The two indexes may be different in the case of
1:      * varargs methods. There may be more invocation args than declared routine args.
1:      * For a varargs routine, all of the trailing invocation parameters correspond to the
1:      * last argument declared by the CREATE FUNCTION/PROCEDURE statement.
1:      * </p>
1:      */
1:     protected   int getRoutineArgIdx( int invocationArgIdx )
1:     {
1:         if ( routineInfo == null ) { return invocationArgIdx; }
0:         if ( !routineInfo.hasVarargs() ) { return invocationArgIdx; }
1: 
1:         // ok, this is a varargs routine
0:         int         firstVarargIdx = routineInfo.getParameterCount() - 1;
1: 
1:         return (firstVarargIdx < invocationArgIdx) ? firstVarargIdx : invocationArgIdx;
1:     }
1:     
1: 
/////////////////////////////////////////////////////////////////////////
1: 	protected void resolveMethodCall
1:         (
1:          String javaClassName,
1:          boolean staticMethod
1:          ) 
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		boolean hasDynamicResultSets = hasVarargs() ?
1:             false :
1:             (routineInfo != null) && (count != 0) && (count != methodParms.length);
1:         int signatureOffset = methodName.indexOf('(');
1:         // support Java signatures by checking if the method name contains a '('
1:         if (signatureOffset != -1) {
1:             parmTypeNames = parseValidateSignature(methodName, signatureOffset, hasDynamicResultSets);
1:             methodName = methodName.substring(0, signatureOffset);
1:             
1:             // If the signature is specified then Derby resolves to exactly
1:             // that method. Setting this flag to false disables the method
1:             // resolution from automatically optionally repeating the last
1:             // parameter as needed.
1:             hasDynamicResultSets = false;
1:         }
1:         else
1:         {
1:             parmTypeNames = getObjectSignature();
1:         }
1: 
1:         // the actual type of the trailing Java varargs arg is an array
1:         if ( hasVarargs() )
1:         {
1:             parmTypeNames[ count - 1 ] = parmTypeNames[ count - 1 ] + "[]";
1:         }
1: 
1:         {
1:             method = classInspector.findPublicMethod
1:                 (
1:                  javaClassName,
1:                  methodName,
1:                  parmTypeNames,
1:                  null,
1:                  isParam,
1:                  staticMethod,
1:                  hasDynamicResultSets,
1:                  hasVarargs()
1:                  );
1:             // DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
1:             // and these are the only types that can map to a primitive or an object type according
1:             // to SQL part 13. So we never have a second chance match.
1:             // Also if the DDL specified a signature, then no alternate resolution
1:             if (signatureOffset == -1 && routineInfo == null) {
1:                 /* If no match, then retry with combinations of object and
1:                  * primitive types.
1:                  */
1:                 if (method == null)
1:                 {
1:                     primParmTypeNames = getPrimitiveSignature(false);
1:                     method = classInspector.findPublicMethod
1:                         (
1:                          javaClassName,
1:                          methodName,
1:                          parmTypeNames,
1:                          primParmTypeNames,
1:                          isParam,
1:                          staticMethod,
1:                          hasDynamicResultSets,
1:                          hasVarargs()
1:                          );
1:             }
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.TypeCompilerFactory;
/////////////////////////////////////////////////////////////////////////
1:         TypeCompilerFactory tcf = (routineInfo == null ) ? null : getCompilerContext().getTypeCompilerFactory();
1: 
1: 		for ( int i = 0; i < count; i++ ) { parmTypeNames[i] = getObjectTypeName( signature[ i ], tcf ); }
/////////////////////////////////////////////////////////////////////////
1: 	static  String	getObjectTypeName( JSQLType jsqlType, TypeCompilerFactory tcf )
/////////////////////////////////////////////////////////////////////////
1: 							if (tcf != null) {
1: 								return tcf.getTypeCompiler( ctid ).getCorrespondingPrimitiveTypeName();
commit:75a4806
/////////////////////////////////////////////////////////////////////////
commit:4bad559
/////////////////////////////////////////////////////////////////////////
1: 						case java.sql.Types.BOOLEAN:
commit:a584888
/////////////////////////////////////////////////////////////////////////
1: 						case java.sql.Types.BOOLEAN:
commit:30fa79b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Override method in ancestor.
1:      */
0:     public DataTypeDescriptor getDataType() throws StandardException
1:     {
1:         if ( routineInfo != null )
1:         {
1:             TypeDescriptor td = routineInfo.getReturnType();
1: 
1:             if ( td != null ) { return DataTypeDescriptor.getType( td ); }
1:         }
1: 
1:         return super.getDataType();
1:     }
1: 
commit:d039ced
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.catalog.types.TypeDescriptorImpl;
0: import org.apache.derby.catalog.types.UserDefinedTypeIdImpl;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			TypeDescriptorImpl returnType = (TypeDescriptorImpl) routineInfo.getReturnType();
/////////////////////////////////////////////////////////////////////////
1:                 else if ( returnType.getTypeId().userType() )
1:                 {
1:                     requiredType = ((UserDefinedTypeIdImpl) returnType.getTypeId()).getClassName();
1:                 }
commit:a2d0847
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:      * @return get the Java method or constructor determined during the bind() phase.
1:      */
1:     public Member getResolvedMethod()
1:     {
1:         return method;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 				    requiredType = ResultSet.class.getName();
/////////////////////////////////////////////////////////////////////////
1:             boolean foundCorrectType;
1:             if ( ResultSet.class.getName().equals( requiredType )  )
1:             {
1:                 // allow subtypes of ResultSet too
1:                 try {
0:                     Class actualType = classInspector.getClass( typeName );
1: 
1:                     foundCorrectType = ResultSet.class.isAssignableFrom( actualType );
1:                 }
1:                 catch (ClassNotFoundException cnfe) { foundCorrectType = false; }
1:             }
1:             else{ foundCorrectType = requiredType.equals(typeName); }
1: 
1: 			if (!foundCorrectType)
commit:68573fc
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		String[] expectedTypes = methodParameterTypes;
1: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 			// type of the method
0: 			String parameterType = expectedTypes[param];
/////////////////////////////////////////////////////////////////////////
0: 		return methodParms.length;
/////////////////////////////////////////////////////////////////////////
commit:057ae46
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			 		requiredType = returnTypeId.getCorrespondingJavaTypeName();
1: 					if (!requiredType.equals(typeName)) {
1: 						switch (returnType.getJDBCTypeId()) {
1: 						case java.sql.Types.SMALLINT:
1: 						case java.sql.Types.INTEGER:
1: 						case java.sql.Types.BIGINT:
1: 						case java.sql.Types.REAL:
1: 						case java.sql.Types.DOUBLE:
1: 							TypeCompiler tc = getTypeCompiler(returnTypeId);
1: 							requiredType = tc.getCorrespondingPrimitiveTypeName();
1: 							if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1: 							{
1: 								promoteName = returnTypeId.getCorrespondingJavaTypeName();
1: 							}
1: 							break;
1: 						}
1: 					}
commit:3bbcfab
/////////////////////////////////////////////////////////////////////////
1: 		accept(getCRs);
commit:7b398e9
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.compiler.LocalField;
/////////////////////////////////////////////////////////////////////////
0: import java.sql.ResultSet;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		String[]    expectedTypes = methodParameterTypes;
0:         String      varargsType = getVarargsType();
0:         int         numPushedArgs = methodParms.length;
0:         int         firstVararg = -1;
0:         LocalField  varargsArrayField = null;
0:         if ( varargsType != null )
1:         {
0:             numPushedArgs = expectedTypes.length;
0:             firstVararg = numPushedArgs - 1;
0:             varargsArrayField = acb.newFieldDeclaration(Modifier.PRIVATE, varargsType + "[]" );
1: 
0:             mb.pushNewArray( varargsType, methodParms.length - firstVararg );
0:             mb.setField( varargsArrayField );  
1:         }
1: 
0:         ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
0:             boolean     isVararg = (varargsType != null) && (param >= firstVararg);
1:             
0:             // if this is a varargs method/constructor, then the trailing
0:             // arguments must be stuffed into a single array argument
0:             if ( isVararg ) { mb.getField( varargsArrayField ); }
1:             
0: 			// type of the method. check if it is a varargs method/constrctor
0: 			// and if we have moved on to the varargs.
0: 			String parameterType;
0:             if ( isVararg )
0:             { parameterType = varargsType; }
0:             else { parameterType = expectedTypes[param]; }
1:             
/////////////////////////////////////////////////////////////////////////
0:             if ( isVararg ) { mb.setArrayElement( param - firstVararg ); }
0:         if ( varargsType != null ) { mb.getField( varargsArrayField ); }
1: 
0: 		return numPushedArgs;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Get the type name of the method/constructor's final varargs argument if
0: 	 * the method/constructor has a varargs signature. Returns null if the
0: 	 * method/constructor does not have a varargs signature.
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	private String  getVarargsType() 
1:     {
0:         Class   varargsTypeClass = ClassInspector.getVarargsType( method );
1: 
0:         if ( varargsTypeClass == null ) { return null; }
0:         else { return varargsTypeClass.getName(); }
1:     }
1: 
1: 	/**
0: 	 * Get the number of compiled ResultSets added to the end of the method
0: 	 * signature.
1: 	 */
0: 	protected int getCompiledResultSetCount()
1: 	{
0:         Class   varargsType = ClassInspector.getVarargsType( method );
1: 
0:         if ( (varargsType != null) && !ResultSet.class.equals( varargsType ) ) { return 0; }
1:         
0:         return methodParameterTypes.length - methodParms.length;		
1: 	}
1: 
1: 
1: 
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
0: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the details on the invoked routines.
1:      */
1:     public RoutineAliasInfo getRoutineInfo()
1:     {
1:         return routineInfo;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	  *	Get the resolved Classes of our parameters
1: 	  *
1: 	  *	@return	the Classes of our parameters
1: 	  */
0: 	public	Class[]	getMethodParameterClasses() 
1: 	{ 
1: 		ClassInspector ci = getClassFactory().getClassInspector();
1: 
0: 		Class[]	parmTypeClasses = new Class[methodParms.length];
1: 		for (int i = 0; i < methodParms.length; i++)
1: 		{
1: 			String className = methodParameterTypes[i];
1: 			try
1: 			{
1: 				parmTypeClasses[i] = ci.getClass(className);
1: 			}
1: 			catch (ClassNotFoundException cnfe)
1: 			{
1: 				/* We should never get this exception since we verified 
1: 				 * that the classes existed at bind time.  Just return null.
1: 				 */
1: 				if (SanityManager.DEBUG)
1: 				{
1: 					SanityManager.THROWASSERT("Unexpected exception", cnfe);
1: 				}
1: 				return null;
1: 			}
1: 		}
1: 
1: 		return parmTypeClasses;
1: 	}
1: 
1: 	/**
1: 	 * Build a JBitSet of all of the tables that we are
1: 	 * correlated with.
1: 	 *
1: 	 * @param correlationMap	The JBitSet of the tables that we are correlated with.
1: 	 */
1: 	void getCorrelationTables(JBitSet correlationMap)
1: 		throws StandardException
1: 	{
0: 		CollectNodesVisitor getCRs = new CollectNodesVisitor(ColumnReference.class);
0: 		super.accept(getCRs);
0: 		Vector colRefs = getCRs.getList();
0: 		for (Enumeration e = colRefs.elements(); e.hasMoreElements(); )
1: 		{
0: 			ColumnReference ref = (ColumnReference)e.nextElement();
1: 			if (ref.getCorrelated())
1: 			{
1: 				correlationMap.set(ref.getTableNumber());
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 				if (
1: 				    returnType.isRowMultiSet() &&
1: 				    ( routineInfo.getParameterStyle() == RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET )
1: 				)
1: 				{
0: 				    requiredType = "java.sql.ResultSet";
1: 				else
1: 				{
0: 				    switch (returnType.getJDBCTypeId()) {
1: 				    case java.sql.Types.SMALLINT:
1: 				    case java.sql.Types.INTEGER:
1: 				    case java.sql.Types.BIGINT:
1: 				    case java.sql.Types.REAL:
1: 				    case java.sql.Types.DOUBLE:
0: 				    	TypeCompiler tc = getTypeCompiler(returnTypeId);
0: 				    	requiredType = tc.getCorrespondingPrimitiveTypeName();
0: 				    	if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1: 				    	{
0: 				    		promoteName = returnTypeId.getCorrespondingJavaTypeName();
1: 				    	}
1: 				    	break;
1: 				    default:
0: 				    	requiredType = returnTypeId.getCorrespondingJavaTypeName();
1: 				    	break;
1: 				    }
1: 				}
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:             if ( routineInfo.getParameterModes()[ firstVarargIdx ] != (ParameterMetaData.parameterModeIn) )
/////////////////////////////////////////////////////////////////////////
1:                     case (ParameterMetaData.parameterModeIn):
1:                     case (ParameterMetaData.parameterModeInOut):
1:                     case (ParameterMetaData.parameterModeOut):
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<ColumnReference> getCRs =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:         for (ColumnReference ref : getCRs.getList())
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     void preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
/////////////////////////////////////////////////////////////////////////
1:     JavaValueNode remapColumnReferencesToExpressions()
/////////////////////////////////////////////////////////////////////////
1:     void generateOneParameter(ExpressionClassBuilder acb,
/////////////////////////////////////////////////////////////////////////
1:     int getOrderableVariantType() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     DataTypeDescriptor getDataType() throws StandardException
commit:b49cc55
/////////////////////////////////////////////////////////////////////////
1:             getParameterTypes()[0] = dts;
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:                             fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		List aggregateVector)
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
0: 		for (Iterator it = getCRs.getList().iterator(); it.hasNext(); )
0: 			ColumnReference ref = (ColumnReference) it.next();
commit:9eb1bd1
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param parameterList		A list of the parameters
0: 	public void addParms(List parameterList) throws StandardException
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0: 				qt = (QueryTreeNode) getNodeFactory().getNode(
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 			qt = (QueryTreeNode) parameterList.get(index);
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
commit:23ecfcf
/////////////////////////////////////////////////////////////////////////
1: 		        case JSQLType.JAVA_PRIMITIVE: return JSQLType.getPrimitiveName( jsqlType.getPrimitiveKind() );
/////////////////////////////////////////////////////////////////////////
0: 						primParmTypeNames[i] = JSQLType.getPrimitiveName( jsqlType.getPrimitiveKind() );
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:72abc72
/////////////////////////////////////////////////////////////////////////
1: 			//propogate collation type from RoutineAliasInfo to
1: 			// MethodCallNode DERBY-2972
1:                         if (routineInfo.getReturnType() != null)
1:                             setCollationType(routineInfo.getReturnType().getCollationType());     
1:                 }
1:                 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:7754964
/////////////////////////////////////////////////////////////////////////
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 		//collation of ? operand should be same as the current schema
0: 		dts.setCollationDerivation(
0: 				StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 		dts.setCollationType(
0: 				getLanguageConnectionContext().getDefaultSchema()
0: 						.getCollationType());
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d999928
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 				if (ClassInspector.primitiveType(parameterType)) {
commit:4493d69
/////////////////////////////////////////////////////////////////////////
commit:3905037
/////////////////////////////////////////////////////////////////////////
1: 			** Since we need the parameter to be in Java domain format, put a
0: 			** SQLToJavaValueNode on top of the parameter node if it is a 
0: 			** SQLValueNode. But if the parameter is already in Java domain 
0: 			** format, then we don't need to do anything.
0: 				qt = (SQLToJavaValueNode) getNodeFactory().getNode(
0: 						C_NodeTypes.SQL_TO_JAVA_VALUE_NODE, 
0: 						qt, 
0: 						getContextManager());
/////////////////////////////////////////////////////////////////////////
commit:894b205
/////////////////////////////////////////////////////////////////////////
1: abstract class MethodCallNode extends JavaValueNode
1: 	 String	methodName;
1:     String javaClassName;
commit:4d80643
/////////////////////////////////////////////////////////////////////////
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		String[]		parmTypeNames;
/////////////////////////////////////////////////////////////////////////
1: 
0:         	int signatureOffset = methodName.indexOf('(');
1:         	
0:             if (signatureOffset != -1) {
0:                	parmTypeNames = parseValidateSignature(methodName, signatureOffset, hasDynamicResultSets);
0:                methodName = methodName.substring(0, signatureOffset);
1:                
0:                // If the signature is specified then Derby resolves to exactly
0:                // that method. Setting this flag to false disables the method
0:                // resolution from automatically optionally repeating the last
0:                // parameter as needed.
0:                hasDynamicResultSets = false;
1:               	 
0:             	parmTypeNames = getObjectSignature();
1:             }
1:         try
1:         {                      	
/////////////////////////////////////////////////////////////////////////
0:                 // Also if the DDL specified a signature, then no alternate resolution
0:                 if (signatureOffset == -1 && routineInfo == null) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (ClassInspector.primitiveType(methodParameter))
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Parse the user supplied signature for a method and validate
1: 	 * it, need to match the number of parameters passed in and match
1: 	 * the valid types for the parameter.
0: 	 * @param signature complete external name with signature
1: 	 * @param offset Character offset of first paren
1: 	 * @param hasDynamicResultSets Can ResultSet[] parameters be specified.
1: 	 * @return The valid array of types for resolution.
1: 	 * @throws StandardException
1: 	 */
1: 	private String[] parseValidateSignature(String externalName, int offset,
1: 			boolean hasDynamicResultSets)
1: 		throws StandardException
1: 	{
1: 		int siglen = externalName.length();
1: 
1: 		// Ensure the opening paren is not the last
1: 		// character and that the last character is a close paren
1: 		if (((offset + 1) == siglen)
1: 			|| (externalName.charAt(siglen - 1) != ')'))
1: 			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1: 		
1:         StringTokenizer st = new StringTokenizer(externalName.substring(offset + 1, siglen - 1), ",", true);
1:         
1:         String[] signatureTypes = new String[signature.length];
1:         int count;
1:         boolean seenClass = false;
1:         for (count = 0; st.hasMoreTokens();)
1:         {
1:            	String type = st.nextToken().trim();
1:  
1:            	// check sequence is <class><comma>class> etc.
1:            	if (",".equals(type))
1:            	{
1:            		if (!seenClass)
1:            			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:            		seenClass = false;
1:            		continue;
1:            	}
1:            	else
1:            	{
1:            		if (type.length() == 0)
1:            			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:            		seenClass = true;
1:            		count++;
1:            	}
1:            	           	           	           
1:            	if (count > signature.length)
1:         	{
1:         		if (hasDynamicResultSets)
1:         		{
1:         			// Allow any number of dynamic result set holders
1:         			// but they must match the exact type.
1:         			String rsType = signature[signature.length - 1].getSQLType().
1: 						getTypeId().getCorrespondingJavaTypeName();
1:         			
1:         			if (!type.equals(rsType))
1:         				throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1:                 				type, rsType);
1: 
1:         			if (signatureTypes.length == signature.length)
1:         			{
1:         				// expand once
1:         				String[] sigs = new String[st.countTokens()];
1:         				System.arraycopy(signatureTypes, 0, sigs, 0, signatureTypes.length);
1:         				signatureTypes = sigs;
1:         			}
1:         			
1:             		signatureTypes[count - 1] = type;
1:             		continue;
1:        			
1:         		}
1:     			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
1:         				Integer.toString(count),
1:         				Integer.toString(signature.length)); // too many types
1:         	}
1: 
1:         	       	
1:         	TypeId	paramTypeId = signature[count - 1].getSQLType().getTypeId();
1:         	        	
1:         	// Does it match the object name
1:         	if (type.equals(paramTypeId.getCorrespondingJavaTypeName()))
1:         	{
1:         		signatureTypes[count - 1] = type;
1:         		continue;
1:         	}
1:       	
1:         	// how about the primitive name
1: 			if ((paramTypeId.isNumericTypeId() && !paramTypeId.isDecimalTypeId())
1: 					|| paramTypeId.isBooleanTypeId())
1: 			{
1: 				TypeCompiler tc = getTypeCompiler(paramTypeId);
1: 				if (type.equals(tc.getCorrespondingPrimitiveTypeName()))
1: 				{
1: 		       		signatureTypes[count - 1] = type;
1: 	        		continue;					
1: 				}
1: 			}
1:         	throw StandardException.newException(SQLState.LANG_DATA_TYPE_GET_MISMATCH, 
1:         				type, paramTypeId.getSQLTypeName()); // type conversion error
1:         }
1:         
1:         // Did signature end with trailing comma?
1:         if (count != 0 && !seenClass)
1:         	throw StandardException.newException(SQLState.SQLJ_SIGNATURE_INVALID); // invalid
1:         
1:         if (count < signatureTypes.length)
1:         {
1:         	if (hasDynamicResultSets)
1:         	{
1:         		// we can tolerate a count of one less than the
1:         		// expected count, which means the procedure is declared
1:         		// to have dynamic result sets, but the explict signature
1:         		// doesn't have any ResultSet[] types.
1:         		// So accept, and procedure will automatically have 0
1:         		// dynamic results at runtime
1:         		if (count == (signature.length - 1))
1:         		{
1:         			String[] sigs = new String[count];
1:         			System.arraycopy(signatureTypes, 0, sigs, 0, count);
1:         			return sigs;
1:         		}
1:         	}
1: 			throw StandardException.newException(SQLState.SQLJ_SIGNATURE_PARAMETER_COUNT, 
1:     				Integer.toString(count),
1:     				Integer.toString(signature.length)); // too few types
1:         }
1: 
1:         return signatureTypes;
1: 	}
commit:f52a50f
/////////////////////////////////////////////////////////////////////////
1:         /*
1:         ** Find the matching method that is public.
1:         */
0:         try
1:         {
0:             // support Java signatures by checking if the method name contains a '('
0:             if (methodName.indexOf('(') != -1) {
0:                 method = classInspector.findPublicMethod(javaClassName, methodName, staticMethod);
0:                 methodName = method.getName();
1:             }
1:             else
1:             {
0:                 /* First try with built-in types and mappings */
0:                 method = classInspector.findPublicMethod(javaClassName,
1:                                                     methodName,
0:                                                     parmTypeNames,
0:                                                     null,
0:                                                     isParam,
0:                                                     staticMethod,
0:                                                     hasDynamicResultSets);
1:                 // DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
1:                 // and these are the only types that can map to a primitive or an object type according
0:                 // to SQL part 13. So we never have a second chance match.
1:                 if (routineInfo == null) {
0:                     /* If no match, then retry with combinations of object and
0:                      * primitive types.
1:                      */
1:                     if (method == null)
1:                     {
0:                         primParmTypeNames = getPrimitiveSignature(false);
0:                         method = classInspector.findPublicMethod(javaClassName,
1:                                                     methodName,
0:                                                     parmTypeNames,
0:                                                     primParmTypeNames,
0:                                                     isParam,
0:                                                     staticMethod,
0:                                                     hasDynamicResultSets);
1:                     }
1:                 }
1:             }
1:         }
1:         catch (ClassNotFoundException e)
1:         {
1:             /*
1:             ** If one of the classes couldn't be found, just act like the
1:             ** method couldn't be found.  The error lists all the class names,
1:             ** which should give the user enough info to diagnose the problem.
1:             */
1:             method = null;
1:         }
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
1: 							if ((ctid.isNumericTypeId() && !ctid.isDecimalTypeId()) || ctid.isBooleanTypeId())
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.MethodCallNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.JSQLType;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: 
0: import java.lang.reflect.Modifier;
1: import java.lang.reflect.Member;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * A MethodCallNode represents a Java method call.  Method calls can be done
1:  * through DML (as expressions) or through the CALL statement.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class MethodCallNode extends JavaValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** Name of the method.
1: 	*/
0: 	protected String	methodName;
1: 
1:     /** The name of the class containing the method. May not be known until bindExpression() has been called.
1:      * @see #bindExpression
1:      * @see #getJavaClassName()
1:      */
0:     protected String javaClassName;
1: 	
1: 	/**
1: 		For a procedure or function call
1: 	*/
1: 	RoutineAliasInfo routineInfo;
1: 
1: 
1: 	/**
1: 		True if this is an internal call, just used to set up a generated method call.
1: 	*/
1: 	boolean internalCall;
1: 
1: 	/**
1: 		For resolution of procedure INOUT/OUT parameters to the primitive
1: 		form, such as int[]. May be null.
1: 	*/
1: 	private String[] procedurePrimitiveArrayType;
1: 
1: 	// bound signature of arguments, stated in universal types (JSQLType)
1: 	protected JSQLType[]				signature;
1: 
1: 	/*
1: 	** Parameters to the method, if any.  No elements if no parameters.
1: 	*/
1: 	protected JavaValueNode[]	methodParms;
1: 
1: 	/* The method call */
1: 	protected Member method;
1: 
1: 	protected String actualMethodReturnType;
1: 
1: 	/**
0: 	  *	Gets the signature of JSQLTypes needed to propagate a work unit from
0: 	  *	target to source.
1: 	  *
0: 	  *	@return	the JSQLType signature
1: 	  */
0: 	public	JSQLType[]	getSignature()
1: 	{
0: 		return	signature;
1: 	}
1: 
1: 	/**
1: 		The parameter types for the resolved method.
1: 	*/
1: 	String[] methodParameterTypes;
1: 
1: 	/**
0: 	 * Initializer for a MethodCallNode
1: 	 *
0: 	 * @param	methodName	The name of the method to call
1: 	 */
0: 	public void init(Object methodName)
1: 	{
0: 		this.methodName = (String) methodName;
1: 	}
1: 
0: 	public String getMethodName()
1: 	{
1: 		return  methodName;
1: 	}
1: 
1:     /**
1:      * @return the name of the class that contains the method, null if not known. It may not be known
1:      *         until this node has been bound.
1:      */
1:     public String getJavaClassName()
1:     {
1:         return javaClassName;
1:     }
1:     
1: 	/**
0: 	 * Set the clause that this node appears in.
1: 	 *
0: 	 * @param clause	The clause that this node appears in.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setClause(int clause)
1: 	{
0: 		super.setClause(clause);
1: 		if (methodParms != null)
1: 		{
1: 			for (int parm = 0; parm < methodParms.length; parm++)
1: 			{
1: 				if (methodParms[parm] != null)
1: 				{
0: 					methodParms[parm].setClause(clause);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * Add the parameter list.
0: 	 * (This flavor is useful when transforming a non-static method call node
0: 	 * to a static method call node.)
1: 	 *
0: 	 * @param methodParms		JavaValueNode[]
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void addParms(JavaValueNode[] methodParms)
1: 	{
0: 		this.methodParms = methodParms;
1: 	}
1: 
1: 	/**
1: 	 * Add the parameter list
1: 	 *
0: 	 * @param parameterList		A Vector of the parameters
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void addParms(Vector parameterList) throws StandardException
1: 	{
1: 		methodParms = new JavaValueNode[parameterList.size()];
1: 
1: 		int	plSize = parameterList.size();
1: 		for (int index = 0; index < plSize; index++)
1: 		{
0: 			QueryTreeNode	qt;
1: 
0: 			qt = (QueryTreeNode) parameterList.elementAt(index);
1: 
1: 
1: 
1: 			/*
0: 			** If the parameter is a SQL ValueNode, there are two
0: 			** possibilities.  Either it is a JavaValueNode with
0: 			** a JavaToSQLValueNode on top of it, or it is a plain
0: 			** SQL ValueNode.  In the former case, just get rid of
0: 			** the JavaToSQLValueNode.  In the latter case, put a
0: 			** SQLToJavaValueNode on top of it.  In general, we
0: 			** want to avoid converting the same value back and forth
0: 			** between the SQL and Java domains.
1: 			*/
0: 			if ( ! (qt instanceof JavaValueNode))
1: 			{
0: 				if (qt instanceof JavaToSQLValueNode)
1: 				{
0: 					qt = ((JavaToSQLValueNode) qt).getJavaValueNode();
1: 				}
1: 				else
1: 				{
0: 					qt = (SQLToJavaValueNode) getNodeFactory().
0: 							getNode(
0: 								C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 								qt,
0: 								getContextManager());
1: 				}
1: 			}
1: 
0: 			methodParms[index] = (JavaValueNode) qt;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			int	parm;
1: 
1: 			super.printSubNodes(depth);
1: 			if (methodParms != null)
1: 			{
1: 				for (parm = 0; parm < methodParms.length; parm++)
1: 				{
1: 					if (methodParms[parm] != null)
1: 					{
1: 						printLabel(depth, "methodParms[" + parm + "] :");
1: 						methodParms[parm].treePrint(depth + 1);
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "methodName: " +
1: 					(methodName != null ? methodName : "null") + "\n" +
1: 					super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this expression.  This means binding the sub-expressions,
1: 	 * as well as figuring out what the return type is for this expression.
1: 	 *
1: 	 * @param fromList		The FROM list for the query this
1: 	 *				expression is in, for binding columns.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
1: 	 *
0: 	 * @return	this
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	final void bindParameters(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
1: 			throws StandardException
1: 	{
1: 		/* Bind the parameters */
1: 		if (methodParms != null)
1: 		{
1: 			int		count = methodParms.length;
1: 
1: 			// with a procedure call the signature
1: 			// is preformed in StaticMethodCall from
1: 			// the procedures signature.
1: 			if (signature == null) 
1: 				signature = new JSQLType[ count ];
1: 
1: 			for (int parm = 0; parm < count; parm++)
1: 			{
1: 				if (methodParms[parm] != null)
1: 				{
1: 					methodParms[parm] =
1: 						methodParms[parm].bindExpression(
0: 							fromList, subqueryList, aggregateVector);
1: 
1: 					if (routineInfo == null)
1: 						signature[ parm ] = methodParms[ parm ].getJSQLType();
1:                     
0:                     // prohibit LOB columns/types
0:                     if (signature[parm] != null) {
0:                         String type = signature[parm].getSQLType().getTypeId().getSQLTypeName();
0:                         if (type.equals("BLOB") || type.equals("CLOB") || type.equals("NCLOB")) {
0:                             throw StandardException.newException(SQLState.LOB_AS_METHOD_ARGUMENT_OR_RECEIVER);
1:                         }
1:                     }
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not all of the parameters to this node are
1: 	 * QUERY_INVARIANT or CONSTANT.  This is useful for VTIs - a VTI is a candidate
1: 	 * for materialization if all of its parameters are QUERY_INVARIANT or CONSTANT
1: 	 *
1: 	 * @return Whether or not all of the parameters to this node are QUERY_INVARIANT or CONSTANT
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	 protected boolean areParametersQueryInvariant() throws StandardException
1: 	 {
1: 		return (getVariantTypeOfParams() == Qualifier.QUERY_INVARIANT);
1: 	 }
1: 
1: 	/**
1: 	 * Build parameters for error message and throw the exception when there
1: 	 * is no matching signature found.
1: 	 *
1: 	 * @param receiverTypeName	Type name for receiver
1: 	 * @param parmTypeNames		Type names for parameters as object types
1: 	 * @param primParmTypeNames	Type names for parameters as primitive types
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void throwNoMethodFound(String receiverTypeName,
1: 									  String[] parmTypeNames,
1: 									  String[] primParmTypeNames)
1: 		throws StandardException
1: 	{
1: 		/* Put the parameter type names into a single string */
0: 		StringBuffer	parmTypes = new StringBuffer();
0: 		for (int i = 0; i < parmTypeNames.length; i++)
1: 		{
0: 			if (i != 0)
0: 				parmTypes.append(", ");
1: 			/* RESOLVE - shouldn't be using hard coded strings for output */
0: 			parmTypes.append( (parmTypeNames[i].length() != 0 ?
0: 								parmTypeNames[i] :
0: 								"UNTYPED"));
1: 			if ((primParmTypeNames != null) &&
1: 				! primParmTypeNames[i].equals(parmTypeNames[i]))  // has primitive
0: 				parmTypes.append("(" + primParmTypeNames[i] + ")");
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.LANG_NO_METHOD_FOUND, 
1: 												receiverTypeName,
0: 												methodName,
1: 											 	parmTypes);
1: 	}
1: 
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
0: 	 * @return	Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void preprocess(int numTables,
1: 							FromList outerFromList,
1: 							SubqueryList outerSubqueryList,
1: 							PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		int	parm;
1: 
1: 		/* Preprocess the parameters */
1: 		if (methodParms != null)
1: 		{
1: 			for (parm = 0; parm < methodParms.length; parm++)
1: 			{
1: 				if (methodParms[parm] != null)
1: 				{
1: 					methodParms[parm].preprocess(numTables,
1: 												 outerFromList,
1: 												 outerSubqueryList,
1: 												 outerPredicateList);
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Categorize this predicate.  Initially, this means
1: 	 * building a bit map of the referenced tables for each predicate.
1: 	 * If the source of this ColumnReference (at the next underlying level) 
1: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
1: 	 * will not be pushed down.
1: 	 *
1: 	 * For example, in:
1: 	 *		select * from (select 1 from s) a (x) where x = 1
1: 	 * we will not push down x = 1.
1: 	 * NOTE: It would be easy to handle the case of a constant, but if the
1: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
1: 	 * that tree into the pushed predicate, and that tree could contain
1: 	 * subqueries and method calls.
1: 	 * RESOLVE - revisit this issue once we have views.
1: 	 *
1: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
1: 	 * @param simplePredsOnly	Whether or not to consider method
1: 	 *							calls, field references and conditional nodes
1: 	 *							when building bit map
1: 	 *
1: 	 * @return boolean		Whether or not source.expression is a ColumnReference
1: 	 *						or a VirtualColumnNode.
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1: 		throws StandardException
1: 	{
1: 		/* We stop here when only considering simple predicates
1: 		 *  as we don't consider method calls when looking
1: 		 * for null invariant predicates.
1: 		 */
1: 		if (simplePredsOnly)
1: 		{
1: 			return false;
1: 		}
1: 
1: 		boolean pushable = true;
1: 		int		param;
1: 
1: 		if (methodParms != null)
1: 		{
1: 			for (param = 0; param < methodParms.length; param++)
1: 			{
1: 				if (methodParms[param] != null)
1: 				{
1: 					pushable = methodParms[param].categorize(referencedTabs, simplePredsOnly) &&
1: 							   pushable;
1: 				}
1: 			}
1: 		}
1: 
1: 		/* We need to push down method call.  Then the predicate can be used for start/stop
1: 		 * key for index scan.  The fact that method call's cost is not predictable and can
1: 		 * be expensive doesn't mean we shouldn't push it down. Beetle 4826.
1: 		 */
1: 		return pushable;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
1: 	 * @return JavaValueNode			The remapped expression tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
1: 		throws StandardException
1: 	{
1: 		int	param;
1: 
1: 		if (methodParms != null)
1: 		{
1: 			for (param = 0; param < methodParms.length; param++)
1: 			{
1: 				if (methodParms[param] != null)
1: 				{
1: 					methodParms[param] =
1: 						methodParms[param].remapColumnReferencesToExpressions();
1: 				}
1: 			}
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Generate the parameters to the given method call
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb the method  the expression will go into
1: 	 *
1: 	 * @return	Count of arguments to the method.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public	int generateParameters(ExpressionClassBuilder acb,
1: 											MethodBuilder mb)
1: 			throws StandardException
1: 	{
1: 		int				param;
1: 
0: 		String[] expectedTypes = methodParameterTypes;
1: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
1: 		/* Generate the code for each user parameter, generating the appropriate
1: 		 * cast when the passed type needs to get widened to the expected type.
1: 		 */
1: 		for (param = 0; param < methodParms.length; param++)
1: 		{
0: 			generateOneParameter( acb, mb, param );
1: 
0: 			// type from the SQL-J expression
0: 			String argumentType = getParameterTypeName( methodParms[param] );
1: 
0: 			// type of the method
0: 			String parameterType = expectedTypes[param];
1: 
0: 			if (!parameterType.equals(argumentType))
1: 			{
0: 				// since we reached here through method resolution
0: 				// casts are only required for primitive types.
0: 				// In any other case the expression type must be assignable
0: 				// to the parameter type.
0: 				if (classInspector.primitiveType(parameterType)) {
1: 
0: 					mb.cast(parameterType);
1: 
1: 				} else {
1: 
0: 					// for a prodcedure
1: 					if (routineInfo != null) {
0: 						continue; // probably should be only for INOUT/OUT parameters.
1: 					}
1: 
0: 					if (SanityManager.DEBUG) {
0: 						SanityManager.ASSERT(classInspector.assignableTo(argumentType, parameterType),
0: 							"Argument type " + argumentType + " is not assignable to parameter " + parameterType);
1: 					}
1: 
1: 					/*
0: 					** Set the parameter type in case the argument type is narrower
0: 					** than the parameter type.
1: 					*/
0: 					mb.upCast(parameterType);
1: 
1: 				}
1: 			}
1: 
1: 		}
1: 
0: 		return methodParms.length;
1: 	}
1: 
1: 	static	public	String	getParameterTypeName( JavaValueNode param )
1: 		throws StandardException
1: 	{
1: 		String	argumentType;
1: 
1: 		// RESOLVE - shouldn't this logic be inside JavaValueNode ??
1: 		// I.e. once the value is primitive then its java type name is its
1: 		// primitive type name.
1: 		if (param.isPrimitiveType()) { argumentType = param.getPrimitiveTypeName(); }
1: 		else { argumentType = param.getJavaTypeName(); }
1: 
1: 		return	argumentType;
1: 	}
1: 
1: 	/**
1: 	 * Generate one parameter to the given method call. This method is overriden by
1: 	 * RepStaticMethodCallNode.
1: 	 *
1: 	 * @param acb				The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb the method the expression will go into
1: 	 * @param parameterNumber	Identifies which parameter to generate. 0 based.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public	void generateOneParameter(ExpressionClassBuilder acb,
1: 											MethodBuilder mb,
1: 											int parameterNumber )
1: 			throws StandardException
1: 	{
1: 		methodParms[parameterNumber].generateExpression(acb, mb);
1: 	}
1: 
1: 	/**
1: 	 * Set the appropriate type information for a null passed as a parameter.
1: 	 * This method is called after method resolution, when a signature was
1: 	 * successfully matched.
1: 	 *
1: 	 * @param parmTypeNames	String[] with the java type names for the parameters
1: 	 *        as declared by the method
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void	setNullParameterInfo(String[] parmTypeNames)
1: 			throws StandardException
1: 	{
1: 		for (int i = 0; i < methodParms.length; i++)
1: 		{
1: 			/* null parameters are represented by a java type name of "" */
1: 			if (methodParms[i].getJavaTypeName().equals(""))
1: 			{		
1: 				/* Set the type information in the null constant node */
1: 				DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(parmTypeNames[i]);
0: 				((SQLToJavaValueNode)methodParms[i]).value.setDescriptor(
0: 																	dts);
1: 
1: 				/* Set the correct java type name */
1: 				methodParms[i].setJavaTypeName(parmTypeNames[i]);
1: 				signature[i] = methodParms[i].getJSQLType();
1: 			}
1: 		}
1: 	}
1: 
0: 	protected void resolveMethodCall(String javaClassName,
0: 									 boolean staticMethod) 
1: 				throws StandardException
1: 	{
1: 		// only allow direct method calls through routines and internal SQL.
1: 		if (routineInfo == null && !internalCall)
1: 		{
1: 			// See if we are being executed in an internal context
1: 			if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0) {
1: 				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,  javaClassName + (staticMethod ? "::" : ".") + methodName);
1: 			}
1: 		}
1: 
1: 		int			count = signature.length;
1: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
1: 
0: 		String[]		parmTypeNames = getObjectSignature();
1: 		String[]		primParmTypeNames = null;
1: 		boolean[]		isParam = getIsParam();
1: 
0: 		boolean hasDynamicResultSets = (routineInfo != null) && (count != 0) && (count != methodParms.length);
1: 
1: 		/*
0: 		** Find the matching method that is public.
1: 		*/
0: 		try
1: 		{
0: 			/* First try with built-in types and mappings */
0: 			method = classInspector.findPublicMethod(javaClassName,
0: 												methodName,
0: 												parmTypeNames,
0: 												null,
0: 												isParam,
0: 												staticMethod,
0: 												hasDynamicResultSets);
1: 
1: 
0: 			// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 			// and these are the only types that can map to a primitive or an object type according
0: 			// to SQL part 13. So we never have a second chance match.
0: 			if (routineInfo == null) {
1: 
0: 				/* If no match, then retry with combinations of object and 
0: 				 * primitive types.
1: 				 */
0: 				if (method == null)
1: 				{
0: 					primParmTypeNames = getPrimitiveSignature(false);
1: 
0: 					method = classInspector.findPublicMethod(javaClassName,
0: 												methodName,
0: 												parmTypeNames,
0: 												primParmTypeNames,
0: 												isParam,
0: 												staticMethod,
0: 												hasDynamicResultSets);
1: 				}
1: 			}
1: 		}
0: 		catch (ClassNotFoundException e)
1: 		{
1: 			/*
0: 			** If one of the classes couldn't be found, just act like the
0: 			** method couldn't be found.  The error lists all the class names,
0: 			** which should give the user enough info to diagnose the problem.
1: 			*/
0: 			method = null;
1: 		}
1: 
1: 		/* Throw exception if no matching signature found */
0: 		if (method == null)
1: 		{
1: 			throwNoMethodFound(javaClassName, parmTypeNames, primParmTypeNames);
1: 		}
1: 
1: 		String	typeName = classInspector.getType(method);
1: 		actualMethodReturnType = typeName;
1: 
0: 		if (routineInfo == null) {
1: 
1: 			/* void methods are only okay for CALL Statements */
1: 			if (typeName.equals("void"))
1: 			{
1: 				if (!forCallStatement)
1: 					throw StandardException.newException(SQLState.LANG_VOID_METHOD_CALL);
1: 			}
1: 		}
1: 		else
1: 		{
1: 			String promoteName = null;
0: 			TypeDescriptor returnType = routineInfo.getReturnType();
1: 			String requiredType;
1: 			if (returnType == null)
1: 			{
1: 				// must have a void method for a procedure call.
1: 				requiredType = "void";
1: 			}
1: 			else
1: 			{
1: 
1: 
0: 				// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 				// and these are the only types that can map to a primitive or an object type according
1: 				// to SQL part 13. So always map to the primitive type. We can not use the getPrimitiveSignature()
1: 				// as it (incorrectly but historically always has) maps a DECIMAL to a double. 
1: 
1: 				
1: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
0: 				switch (returnType.getJDBCTypeId()) {
0: 				case java.sql.Types.SMALLINT:
0: 				case java.sql.Types.INTEGER:
0: 				case java.sql.Types.BIGINT:
0: 				case java.sql.Types.REAL:
0: 				case java.sql.Types.DOUBLE:
0: 					TypeCompiler tc = getTypeCompiler(returnTypeId);
0: 					requiredType = tc.getCorrespondingPrimitiveTypeName();
0: 					if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
1: 					{
0: 						promoteName = returnTypeId.getCorrespondingJavaTypeName();
1: 					}
1: 
1: 					break;
1: 				default:
0: 					requiredType = returnTypeId.getCorrespondingJavaTypeName();
1: 					break;
1: 				}
1: 
1: 			}
1: 
0: 			if (!requiredType.equals(typeName))
1: 			{
1: 				throwNoMethodFound(requiredType + " " + javaClassName, parmTypeNames, primParmTypeNames);
1: 			}
1: 
1: 			// for a returns null on null input with a primitive
1: 			// type we need to promote to an object so we can return null.
1: 			if (promoteName != null)
1: 				typeName = promoteName;
1: 		}
1: 	 	setJavaTypeName( typeName );
1: 
1: 		methodParameterTypes = classInspector.getParameterTypes(method);
1: 
1: 		for (int i = 0; i < methodParameterTypes.length; i++)
1: 		{
0: 			String methodParameter = methodParameterTypes[i];
1: 
1: 			if (routineInfo != null) {
1: 				if (i < routineInfo.getParameterCount()) {
0: 					int parameterMode = routineInfo.getParameterModes()[i];
1: 
1: 					switch (parameterMode) {
0: 					case JDBC30Translation.PARAMETER_MODE_IN:
1: 						break;
0: 					case JDBC30Translation.PARAMETER_MODE_IN_OUT:
1: 						// we need to see if the type of the array is
1: 						// primitive, not the array itself.
0: 						methodParameter = methodParameter.substring(0, methodParameter.length() - 2);
1: 						break;
1: 
0: 					case JDBC30Translation.PARAMETER_MODE_OUT:
1: 						// value is not obtained *from* parameter.
1: 						continue;
1: 					}
1: 				}
1: 			}
1: 
0: 			if (classInspector.primitiveType(methodParameter))
0: 				methodParms[i].castToPrimitive(true);
1: 		}
1: 
1: 		/* Set type info for any null parameters */
1: 		if ( someParametersAreNull() )
1: 		{
1: 			setNullParameterInfo(methodParameterTypes);
1: 		}
1: 
1: 
1:     
1: 		/* bug 4450 - if the callable statement is ? = call form, generate the metadata
1: 		infor for the return parameter. We don't really need that info in order to
1: 		execute the callable statement. But with jdbc3.0, this information should be
1: 		made available for return parameter through ParameterMetaData class.
1: 		Parser sets a flag in compilercontext if ? = call. If the flag is set,
1: 		we generate the metadata info for the return parameter and reset the flag
1: 		in the compilercontext for future call statements*/
1: 		DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(typeName);
1: 		if (getCompilerContext().getReturnParameterFlag()) {
0: 			getCompilerContext().getParameterTypes()[0] = dts;
1: 		}
1:   }
1: 
1: 	/**
1: 	  *	Return true if some parameters are null, false otherwise.
1: 	  */
1: 	protected	boolean	someParametersAreNull()
1: 	{
1: 		int		count = signature.length;
1: 		
1: 		for ( int ictr = 0; ictr < count; ictr++ )
1: 		{
1: 			if ( signature[ictr] == null )
1: 			{
1: 				return true;
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	  *	Build an array of names of the argument types. These types are biased toward
1: 	  *	Java objects. That is, if an argument is of SQLType, then we map it to the
1: 	  *	corresponding Java synonym class (e.g., SQLINT is mapped to 'java.lang.Integer').
1: 	  *
1: 	  *
1: 	  *	@return	array of type names
1: 	  *
1: 	  * @exception StandardException		Thrown on error
1: 	  */
1: 	protected	String[]	getObjectSignature( )
1: 		throws StandardException
1: 	{
1: 		int		count = signature.length;
1: 		String	parmTypeNames[] = new String[ count ];
1: 
0: 		for ( int i = 0; i < count; i++ ) { parmTypeNames[i] = getObjectTypeName( signature[ i ] ); }
1: 
1: 		return parmTypeNames;
1: 	}
1: 
1: 	/**
1: 	 * Build an array of booleans denoting whether or not a given method
1: 	 * parameter is a ?.
1: 	 *
1: 	 * @return array of booleans denoting wheter or not a given method
1: 	 * parameter is a ?.
1: 	 */
1: 	protected boolean[] getIsParam()
1: 	{
1: 		if (methodParms == null)
1: 		{
1: 			return new boolean[0];
1: 		}
1: 		
1: 		boolean[] isParam = new boolean[methodParms.length];
1: 
1: 		for (int index = 0; index < methodParms.length; index++)
1: 		{
1: 			if (methodParms[index] instanceof SQLToJavaValueNode)
1: 			{
1: 				SQLToJavaValueNode stjvn = (SQLToJavaValueNode) methodParms[index];
0: 				if (stjvn.value.isParameterNode())
1: 				{
1: 					isParam[index] = true;
1: 				}
1: 			}
1: 		}
1: 
1: 		return isParam;
1: 	}
1: 
0: 	private	String	getObjectTypeName( JSQLType jsqlType )
1: 		throws StandardException
1: 	{
1: 		if ( jsqlType != null )
1: 		{
1: 			switch( jsqlType.getCategory() )
1: 			{
1: 			    case JSQLType.SQLTYPE: 
1: 
1: 					TypeId	ctid = mapToTypeID( jsqlType );
1: 
1: 					if ( ctid == null ) { return null; }
1: 					else {
0: 						// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 						// and these are the only types that can map to a primitive or an object type according
1: 						// to SQL part 13. So always map to the primitive type. We can not use the getPrimitiveSignature()
1: 						// as it (incorrectly but historically always has) maps a DECIMAL to a double. 
1: 
1: 						switch (ctid.getJDBCTypeId()) {
0: 						case java.sql.Types.SMALLINT:
0: 						case java.sql.Types.INTEGER:
0: 						case java.sql.Types.BIGINT:
0: 						case java.sql.Types.REAL:
0: 						case java.sql.Types.DOUBLE:
1: 							if (routineInfo != null) {
1: 								TypeCompiler tc = getTypeCompiler(ctid);
0: 								return tc.getCorrespondingPrimitiveTypeName();
1: 							}
1: 							// fall through
1: 						default:
1: 							return ctid.getCorrespondingJavaTypeName();
1: 						}
1: 					}
1: 
1: 		        case JSQLType.JAVA_CLASS: return jsqlType.getJavaClassName();
1: 
0: 		        case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ jsqlType.getPrimitiveKind() ];
1: 
1: 		        default:
1: 
1: 					if (SanityManager.DEBUG)
1: 					{ SanityManager.THROWASSERT( "Unknown JSQLType: " + jsqlType ); }
1: 
1: 			}
1: 		}
1: 
1: 		return "";
1: 	}
1: 
1: 	String[]	getPrimitiveSignature( boolean castToPrimitiveAsNecessary )
1: 		throws StandardException
1: 	{
1: 		int					count = signature.length;
1: 		String[] 			primParmTypeNames = new String[ count ];
0: 		JSQLType			jsqlType;
1: 
1: 		for (int i = 0; i < count; i++)
1: 		{
0: 			jsqlType = signature[ i ];
1: 
0: 			if ( jsqlType == null ) { primParmTypeNames[i] = ""; }
1: 			else
1: 			{
1: 				switch( jsqlType.getCategory() )
1: 			    {
1: 			        case JSQLType.SQLTYPE:
1: 
1: 						if ((procedurePrimitiveArrayType != null)
1: 							&& (i < procedurePrimitiveArrayType.length)
1: 							&& (procedurePrimitiveArrayType[i] != null)) {
1: 
1: 							primParmTypeNames[i] = procedurePrimitiveArrayType[i];
1: 
1: 						} else {
1: 
1: 
1: 							TypeId	ctid = mapToTypeID( jsqlType );
1: 
0: 							if (ctid.isNumericTypeId() || ctid.isBooleanTypeId())
1: 							{
1: 								TypeCompiler tc = getTypeCompiler(ctid);
1: 								primParmTypeNames[i] = tc.getCorrespondingPrimitiveTypeName();
1: 								if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
1: 							}
1: 							else { primParmTypeNames[i] = ctid.getCorrespondingJavaTypeName(); }
1: 						}
1: 
1: 						break;
1: 
1: 		            case JSQLType.JAVA_CLASS:
1: 
0: 						primParmTypeNames[i] = jsqlType.getJavaClassName();
1: 						break;
1: 
1: 		            case JSQLType.JAVA_PRIMITIVE:
1: 
0: 						primParmTypeNames[i] = JSQLType.primitiveNames[ jsqlType.getPrimitiveKind() ];
1: 						if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
1: 						break;
1: 
1: 		            default:
1: 
1: 						if (SanityManager.DEBUG)
1: 							{ SanityManager.THROWASSERT( "Unknown JSQLType: " + jsqlType ); }
1: 
1: 				}	// end switch
1: 
1: 			}		// end if
1: 
1: 		}			// end for
1: 
1: 		return primParmTypeNames;
1: 	}
1: 
1: 	/**
1: 	 * Return the variant type for the underlying expression.
1: 	 * The variant type can be:
1: 	 *		VARIANT				- variant within a scan
1: 	 *							  (non-static field access)
1: 	 *		SCAN_INVARIANT		- invariant within a scan
1: 	 *							  (column references from outer tables)
1: 	 *		QUERY_INVARIANT		- invariant within the life of a query
1: 	 *							  (constant expressions)
1: 	 *
1: 	 * @return	The variant type for the underlying expression.
1: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
1: 	{
1: 		// beetle 4880. We return the most variant type of the parameters. If no
1: 		// params then query-invariant. This makes more sense, and we can evaluate
1: 		// only once per query (good for performance) because method call could be
1: 		// expensive.  And if we push down method qualifier to store, language
1: 		// can pre-evaluate the method call.  This avoids letting store evaluate
1: 		// the method while holding page latch, causing deadlock.
1: 
1: 		return getVariantTypeOfParams();
1: 	}
1: 
1: 	private int getVariantTypeOfParams() throws StandardException
1: 	{
1: 		int variance = Qualifier.QUERY_INVARIANT;
1: 
1: 		if (methodParms != null)
1: 		{
1: 			for (int parm = 0; parm < methodParms.length; parm++)
1: 			{
1: 				if (methodParms[parm] != null)
1: 				{
1: 					int paramVariantType =
1: 						methodParms[parm].getOrderableVariantType();
1: 					if (paramVariantType < variance)	//return the most variant type
1: 						variance = paramVariantType;
1: 				}
1: 				else
1: 				{
1: 					variance = Qualifier.VARIANT;
1: 				}
1: 			}
1: 		}
1: 
1: 		return variance;
1: 	}
1: 
1: 
1: 	/////////////////////////////////////////////////////////////////////
1: 	//
1: 	//	ACCESSORS
1: 	//
1: 	/////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Get the method parameters.
1: 	 * 
1: 	 * @return	The method parameters
1: 	 */
0: 	public JavaValueNode[]	getMethodParms()
1: 	{
1: 		return methodParms;
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
0: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		Visitable		returnNode = v.visit(this);
1: 
0: 		if (v.skipChildren(this))
1: 		{
0: 			return returnNode;
1: 		}
1: 
1: 		for (int parm = 0; 
1: 			!v.stopTraversal() && parm < methodParms.length; 
1: 			parm++)
1: 		{
1: 			if (methodParms[parm] != null)
1: 			{
1: 				methodParms[parm] = (JavaValueNode)methodParms[parm].accept(v);
1: 			}
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 				((SQLToJavaValueNode)methodParms[i]).value.setType(dts);
/////////////////////////////////////////////////////////////////////////
1: 				if (stjvn.value.requiresTypeFromContext())
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.JSQLType;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.sql.compile.TypeCompiler;
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
0: 
0: import java.lang.reflect.Modifier;
0: import java.lang.reflect.Member;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * A MethodCallNode represents a Java method call.  Method calls can be done
0:  * through DML (as expressions) or through the CALL statement.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class MethodCallNode extends JavaValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** Name of the method.
0: 	*/
0: 	protected String	methodName;
0: 
0:     /** The name of the class containing the method. May not be known until bindExpression() has been called.
0:      * @see #bindExpression
0:      * @see #getJavaClassName()
0:      */
0:     protected String javaClassName;
0: 	
0: 	/**
0: 		For a procedure or function call
0: 	*/
0: 	RoutineAliasInfo routineInfo;
0: 
0: 
0: 	/**
0: 		True if this is an internal call, just used to set up a generated method call.
0: 	*/
0: 	boolean internalCall;
0: 
0: 	/**
0: 		For resolution of procedure INOUT/OUT parameters to the primitive
0: 		form, such as int[]. May be null.
0: 	*/
0: 	private String[] procedurePrimitiveArrayType;
0: 
0: 	// bound signature of arguments, stated in universal types (JSQLType)
0: 	protected JSQLType[]				signature;
0: 
0: 	/*
0: 	** Parameters to the method, if any.  No elements if no parameters.
0: 	*/
0: 	protected JavaValueNode[]	methodParms;
0: 
0: 	/* The method call */
0: 	protected Member method;
0: 
0: 	protected String actualMethodReturnType;
0: 
0: 	/**
0: 	  *	Gets the signature of JSQLTypes needed to propagate a work unit from
0: 	  *	target to source.
0: 	  *
0: 	  *	@return	the JSQLType signature
0: 	  */
0: 	public	JSQLType[]	getSignature()
0: 	{
0: 		return	signature;
0: 	}
0: 
0: 	/**
0: 		The parameter types for the resolved method.
0: 	*/
0: 	String[] methodParameterTypes;
0: 
0: 	/**
0: 	 * Initializer for a MethodCallNode
0: 	 *
0: 	 * @param	methodName	The name of the method to call
0: 	 */
0: 	public void init(Object methodName)
0: 	{
0: 		this.methodName = (String) methodName;
0: 	}
0: 
0: 	public String getMethodName()
0: 	{
0: 		return  methodName;
0: 	}
0: 
0:     /**
0:      * @return the name of the class that contains the method, null if not known. It may not be known
0:      *         until this node has been bound.
0:      */
0:     public String getJavaClassName()
0:     {
0:         return javaClassName;
0:     }
0:     
0: 	/**
0: 	 * Set the clause that this node appears in.
0: 	 *
0: 	 * @param clause	The clause that this node appears in.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setClause(int clause)
0: 	{
0: 		super.setClause(clause);
0: 		if (methodParms != null)
0: 		{
0: 			for (int parm = 0; parm < methodParms.length; parm++)
0: 			{
0: 				if (methodParms[parm] != null)
0: 				{
0: 					methodParms[parm].setClause(clause);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Add the parameter list.
0: 	 * (This flavor is useful when transforming a non-static method call node
0: 	 * to a static method call node.)
0: 	 *
0: 	 * @param methodParms		JavaValueNode[]
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void addParms(JavaValueNode[] methodParms)
0: 	{
0: 		this.methodParms = methodParms;
0: 	}
0: 
0: 	/**
0: 	 * Add the parameter list
0: 	 *
0: 	 * @param parameterList		A Vector of the parameters
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void addParms(Vector parameterList) throws StandardException
0: 	{
0: 		methodParms = new JavaValueNode[parameterList.size()];
0: 
0: 		int	plSize = parameterList.size();
0: 		for (int index = 0; index < plSize; index++)
0: 		{
0: 			QueryTreeNode	qt;
0: 
0: 			qt = (QueryTreeNode) parameterList.elementAt(index);
0: 
0: 
0: 
0: 			/*
0: 			** If the parameter is a SQL ValueNode, there are two
0: 			** possibilities.  Either it is a JavaValueNode with
0: 			** a JavaToSQLValueNode on top of it, or it is a plain
0: 			** SQL ValueNode.  In the former case, just get rid of
0: 			** the JavaToSQLValueNode.  In the latter case, put a
0: 			** SQLToJavaValueNode on top of it.  In general, we
0: 			** want to avoid converting the same value back and forth
0: 			** between the SQL and Java domains.
0: 			*/
0: 			if ( ! (qt instanceof JavaValueNode))
0: 			{
0: 				if (qt instanceof JavaToSQLValueNode)
0: 				{
0: 					qt = ((JavaToSQLValueNode) qt).getJavaValueNode();
0: 				}
0: 				else
0: 				{
0: 					qt = (SQLToJavaValueNode) getNodeFactory().
0: 							getNode(
0: 								C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
0: 								qt,
0: 								getContextManager());
0: 				}
0: 			}
0: 
0: 			methodParms[index] = (JavaValueNode) qt;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			int	parm;
0: 
0: 			super.printSubNodes(depth);
0: 			if (methodParms != null)
0: 			{
0: 				for (parm = 0; parm < methodParms.length; parm++)
0: 				{
0: 					if (methodParms[parm] != null)
0: 					{
0: 						printLabel(depth, "methodParms[" + parm + "] :");
0: 						methodParms[parm].treePrint(depth + 1);
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "methodName: " +
0: 					(methodName != null ? methodName : "null") + "\n" +
0: 					super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this expression.  This means binding the sub-expressions,
0: 	 * as well as figuring out what the return type is for this expression.
0: 	 *
0: 	 * @param fromList		The FROM list for the query this
0: 	 *				expression is in, for binding columns.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
0: 	 *
0: 	 * @return	this
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	final void bindParameters(
0: 		FromList fromList, SubqueryList subqueryList,
0: 		Vector	aggregateVector) 
0: 			throws StandardException
0: 	{
0: 		/* Bind the parameters */
0: 		if (methodParms != null)
0: 		{
0: 			int		count = methodParms.length;
0: 
0: 			// with a procedure call the signature
0: 			// is preformed in StaticMethodCall from
0: 			// the procedures signature.
0: 			if (signature == null) 
0: 				signature = new JSQLType[ count ];
0: 
0: 			for (int parm = 0; parm < count; parm++)
0: 			{
0: 				if (methodParms[parm] != null)
0: 				{
0: 					methodParms[parm] =
0: 						methodParms[parm].bindExpression(
0: 							fromList, subqueryList, aggregateVector);
0: 
0: 					if (routineInfo == null)
0: 						signature[ parm ] = methodParms[ parm ].getJSQLType();
0:                     
0:                     // prohibit LOB columns/types
0:                     if (signature[parm] != null) {
0:                         String type = signature[parm].getSQLType().getTypeId().getSQLTypeName();
0:                         if (type.equals("BLOB") || type.equals("CLOB") || type.equals("NCLOB")) {
0:                             throw StandardException.newException(SQLState.LOB_AS_METHOD_ARGUMENT_OR_RECEIVER);
0:                         }
0:                     }
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not all of the parameters to this node are
0: 	 * QUERY_INVARIANT or CONSTANT.  This is useful for VTIs - a VTI is a candidate
0: 	 * for materialization if all of its parameters are QUERY_INVARIANT or CONSTANT
0: 	 *
0: 	 * @return Whether or not all of the parameters to this node are QUERY_INVARIANT or CONSTANT
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	 protected boolean areParametersQueryInvariant() throws StandardException
0: 	 {
0: 		return (getVariantTypeOfParams() == Qualifier.QUERY_INVARIANT);
0: 	 }
0: 
0: 	/**
0: 	 * Build parameters for error message and throw the exception when there
0: 	 * is no matching signature found.
0: 	 *
0: 	 * @param receiverTypeName	Type name for receiver
0: 	 * @param parmTypeNames		Type names for parameters as object types
0: 	 * @param primParmTypeNames	Type names for parameters as primitive types
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void throwNoMethodFound(String receiverTypeName,
0: 									  String[] parmTypeNames,
0: 									  String[] primParmTypeNames)
0: 		throws StandardException
0: 	{
0: 		/* Put the parameter type names into a single string */
0: 		StringBuffer	parmTypes = new StringBuffer();
0: 		for (int i = 0; i < parmTypeNames.length; i++)
0: 		{
0: 			if (i != 0)
0: 				parmTypes.append(", ");
0: 			/* RESOLVE - shouldn't be using hard coded strings for output */
0: 			parmTypes.append( (parmTypeNames[i].length() != 0 ?
0: 								parmTypeNames[i] :
0: 								"UNTYPED"));
0: 			if ((primParmTypeNames != null) &&
0: 				! primParmTypeNames[i].equals(parmTypeNames[i]))  // has primitive
0: 				parmTypes.append("(" + primParmTypeNames[i] + ")");
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.LANG_NO_METHOD_FOUND, 
0: 												receiverTypeName,
0: 												methodName,
0: 											 	parmTypes);
0: 	}
0: 
0: 	/**
0: 	 * Preprocess an expression tree.  We do a number of transformations
0: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
0: 	 * subquery flattening.
0: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
0: 	 *
0: 	 * @param	numTables			Number of tables in the DML Statement
0: 	 * @param	outerFromList		FromList from outer query block
0: 	 * @param	outerSubqueryList	SubqueryList from outer query block
0: 	 * @param	outerPredicateList	PredicateList from outer query block
0: 	 *
0: 	 * @return	Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void preprocess(int numTables,
0: 							FromList outerFromList,
0: 							SubqueryList outerSubqueryList,
0: 							PredicateList outerPredicateList) 
0: 					throws StandardException
0: 	{
0: 		int	parm;
0: 
0: 		/* Preprocess the parameters */
0: 		if (methodParms != null)
0: 		{
0: 			for (parm = 0; parm < methodParms.length; parm++)
0: 			{
0: 				if (methodParms[parm] != null)
0: 				{
0: 					methodParms[parm].preprocess(numTables,
0: 												 outerFromList,
0: 												 outerSubqueryList,
0: 												 outerPredicateList);
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Categorize this predicate.  Initially, this means
0: 	 * building a bit map of the referenced tables for each predicate.
0: 	 * If the source of this ColumnReference (at the next underlying level) 
0: 	 * is not a ColumnReference or a VirtualColumnNode then this predicate
0: 	 * will not be pushed down.
0: 	 *
0: 	 * For example, in:
0: 	 *		select * from (select 1 from s) a (x) where x = 1
0: 	 * we will not push down x = 1.
0: 	 * NOTE: It would be easy to handle the case of a constant, but if the
0: 	 * inner SELECT returns an arbitrary expression, then we would have to copy
0: 	 * that tree into the pushed predicate, and that tree could contain
0: 	 * subqueries and method calls.
0: 	 * RESOLVE - revisit this issue once we have views.
0: 	 *
0: 	 * @param referencedTabs	JBitSet with bit map of referenced FromTables
0: 	 * @param simplePredsOnly	Whether or not to consider method
0: 	 *							calls, field references and conditional nodes
0: 	 *							when building bit map
0: 	 *
0: 	 * @return boolean		Whether or not source.expression is a ColumnReference
0: 	 *						or a VirtualColumnNode.
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
0: 		throws StandardException
0: 	{
0: 		/* We stop here when only considering simple predicates
0: 		 *  as we don't consider method calls when looking
0: 		 * for null invariant predicates.
0: 		 */
0: 		if (simplePredsOnly)
0: 		{
0: 			return false;
0: 		}
0: 
0: 		boolean pushable = true;
0: 		int		param;
0: 
0: 		if (methodParms != null)
0: 		{
0: 			for (param = 0; param < methodParms.length; param++)
0: 			{
0: 				if (methodParms[param] != null)
0: 				{
0: 					pushable = methodParms[param].categorize(referencedTabs, simplePredsOnly) &&
0: 							   pushable;
0: 				}
0: 			}
0: 		}
0: 
0: 		/* We need to push down method call.  Then the predicate can be used for start/stop
0: 		 * key for index scan.  The fact that method call's cost is not predictable and can
0: 		 * be expensive doesn't mean we shouldn't push it down. Beetle 4826.
0: 		 */
0: 		return pushable;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return JavaValueNode			The remapped expression tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public JavaValueNode remapColumnReferencesToExpressions()
0: 		throws StandardException
0: 	{
0: 		int	param;
0: 
0: 		if (methodParms != null)
0: 		{
0: 			for (param = 0; param < methodParms.length; param++)
0: 			{
0: 				if (methodParms[param] != null)
0: 				{
0: 					methodParms[param] =
0: 						methodParms[param].remapColumnReferencesToExpressions();
0: 				}
0: 			}
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Generate the parameters to the given method call
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb the method  the expression will go into
0: 	 *
0: 	 * @return	Count of arguments to the method.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public	int generateParameters(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 			throws StandardException
0: 	{
0: 		int				param;
0: 
0: 		String[] expectedTypes = methodParameterTypes;
0: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 
0: 		/* Generate the code for each user parameter, generating the appropriate
0: 		 * cast when the passed type needs to get widened to the expected type.
0: 		 */
0: 		for (param = 0; param < methodParms.length; param++)
0: 		{
0: 			generateOneParameter( acb, mb, param );
0: 
0: 			// type from the SQL-J expression
0: 			String argumentType = getParameterTypeName( methodParms[param] );
0: 
0: 			// type of the method
0: 			String parameterType = expectedTypes[param];
0: 
0: 			if (!parameterType.equals(argumentType))
0: 			{
0: 				// since we reached here through method resolution
0: 				// casts are only required for primitive types.
0: 				// In any other case the expression type must be assignable
0: 				// to the parameter type.
0: 				if (classInspector.primitiveType(parameterType)) {
0: 
0: 					mb.cast(parameterType);
0: 
0: 				} else {
0: 
0: 					// for a prodcedure
0: 					if (routineInfo != null) {
0: 						continue; // probably should be only for INOUT/OUT parameters.
0: 					}
0: 
0: 					if (SanityManager.DEBUG) {
0: 						SanityManager.ASSERT(classInspector.assignableTo(argumentType, parameterType),
0: 							"Argument type " + argumentType + " is not assignable to parameter " + parameterType);
0: 					}
0: 
0: 					/*
0: 					** Set the parameter type in case the argument type is narrower
0: 					** than the parameter type.
0: 					*/
0: 					mb.upCast(parameterType);
0: 
0: 				}
0: 			}
0: 
0: 		}
0: 
0: 		return methodParms.length;
0: 	}
0: 
0: 	static	public	String	getParameterTypeName( JavaValueNode param )
0: 		throws StandardException
0: 	{
0: 		String	argumentType;
0: 
0: 		// RESOLVE - shouldn't this logic be inside JavaValueNode ??
0: 		// I.e. once the value is primitive then its java type name is its
0: 		// primitive type name.
0: 		if (param.isPrimitiveType()) { argumentType = param.getPrimitiveTypeName(); }
0: 		else { argumentType = param.getJavaTypeName(); }
0: 
0: 		return	argumentType;
0: 	}
0: 
0: 	/**
0: 	 * Generate one parameter to the given method call. This method is overriden by
0: 	 * RepStaticMethodCallNode.
0: 	 *
0: 	 * @param acb				The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb the method the expression will go into
0: 	 * @param parameterNumber	Identifies which parameter to generate. 0 based.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public	void generateOneParameter(ExpressionClassBuilder acb,
0: 											MethodBuilder mb,
0: 											int parameterNumber )
0: 			throws StandardException
0: 	{
0: 		methodParms[parameterNumber].generateExpression(acb, mb);
0: 	}
0: 
0: 	/**
0: 	 * Set the appropriate type information for a null passed as a parameter.
0: 	 * This method is called after method resolution, when a signature was
0: 	 * successfully matched.
0: 	 *
0: 	 * @param parmTypeNames	String[] with the java type names for the parameters
0: 	 *        as declared by the method
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	setNullParameterInfo(String[] parmTypeNames)
0: 			throws StandardException
0: 	{
0: 		for (int i = 0; i < methodParms.length; i++)
0: 		{
0: 			/* null parameters are represented by a java type name of "" */
0: 			if (methodParms[i].getJavaTypeName().equals(""))
0: 			{		
0: 				/* Set the type information in the null constant node */
0: 				DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(parmTypeNames[i]);
0: 				((SQLToJavaValueNode)methodParms[i]).value.setDescriptor(
0: 																	dts);
0: 
0: 				/* Set the correct java type name */
0: 				methodParms[i].setJavaTypeName(parmTypeNames[i]);
0: 				signature[i] = methodParms[i].getJSQLType();
0: 			}
0: 		}
0: 	}
0: 
0: 	protected void resolveMethodCall(String javaClassName,
0: 									 boolean staticMethod) 
0: 				throws StandardException
0: 	{
0: 		// only allow direct method calls through routines and internal SQL.
0: 		if (routineInfo == null && !internalCall)
0: 		{
0: 			// See if we are being executed in an internal context
0: 			if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0) {
0: 				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,  javaClassName + (staticMethod ? "::" : ".") + methodName);
0: 			}
0: 		}
0: 
0: 		int			count = signature.length;
0: 
0: 		ClassInspector classInspector = getClassFactory().getClassInspector();
0: 
0: 		String[]		parmTypeNames = getObjectSignature();
0: 		String[]		primParmTypeNames = null;
0: 		boolean[]		isParam = getIsParam();
0: 
0: 		boolean hasDynamicResultSets = (routineInfo != null) && (count != 0) && (count != methodParms.length);
0: 
0: 		/*
0: 		** Find the matching method that is public.
0: 		*/
0: 		try
0: 		{
0: 			/* First try with built-in types and mappings */
0: 			method = classInspector.findPublicMethod(javaClassName,
0: 												methodName,
0: 												parmTypeNames,
0: 												null,
0: 												isParam,
0: 												staticMethod,
0: 												hasDynamicResultSets);
0: 
0: 
0: 			// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 			// and these are the only types that can map to a primitive or an object type according
0: 			// to SQL part 13. So we never have a second chance match.
0: 			if (routineInfo == null) {
0: 
0: 				/* If no match, then retry with combinations of object and 
0: 				 * primitive types.
0: 				 */
0: 				if (method == null)
0: 				{
0: 					primParmTypeNames = getPrimitiveSignature(false);
0: 
0: 					method = classInspector.findPublicMethod(javaClassName,
0: 												methodName,
0: 												parmTypeNames,
0: 												primParmTypeNames,
0: 												isParam,
0: 												staticMethod,
0: 												hasDynamicResultSets);
0: 				}
0: 			}
0: 		}
0: 		catch (ClassNotFoundException e)
0: 		{
0: 			/*
0: 			** If one of the classes couldn't be found, just act like the
0: 			** method couldn't be found.  The error lists all the class names,
0: 			** which should give the user enough info to diagnose the problem.
0: 			*/
0: 			method = null;
0: 		}
0: 
0: 		/* Throw exception if no matching signature found */
0: 		if (method == null)
0: 		{
0: 			throwNoMethodFound(javaClassName, parmTypeNames, primParmTypeNames);
0: 		}
0: 
0: 		String	typeName = classInspector.getType(method);
0: 		actualMethodReturnType = typeName;
0: 
0: 		if (routineInfo == null) {
0: 
0: 			/* void methods are only okay for CALL Statements */
0: 			if (typeName.equals("void"))
0: 			{
0: 				if (!forCallStatement)
0: 					throw StandardException.newException(SQLState.LANG_VOID_METHOD_CALL);
0: 			}
0: 		}
0: 		else
0: 		{
0: 			String promoteName = null;
0: 			TypeDescriptor returnType = routineInfo.getReturnType();
0: 			String requiredType;
0: 			if (returnType == null)
0: 			{
0: 				// must have a void method for a procedure call.
0: 				requiredType = "void";
0: 			}
0: 			else
0: 			{
0: 
0: 
0: 				// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 				// and these are the only types that can map to a primitive or an object type according
0: 				// to SQL part 13. So always map to the primitive type. We can not use the getPrimitiveSignature()
0: 				// as it (incorrectly but historically always has) maps a DECIMAL to a double. 
0: 
0: 				
0: 				TypeId returnTypeId = TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
0: 				switch (returnType.getJDBCTypeId()) {
0: 				case java.sql.Types.SMALLINT:
0: 				case java.sql.Types.INTEGER:
0: 				case java.sql.Types.BIGINT:
0: 				case java.sql.Types.REAL:
0: 				case java.sql.Types.DOUBLE:
0: 					TypeCompiler tc = getTypeCompiler(returnTypeId);
0: 					requiredType = tc.getCorrespondingPrimitiveTypeName();
0: 					if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)
0: 					{
0: 						promoteName = returnTypeId.getCorrespondingJavaTypeName();
0: 					}
0: 
0: 					break;
0: 				default:
0: 					requiredType = returnTypeId.getCorrespondingJavaTypeName();
0: 					break;
0: 				}
0: 
0: 			}
0: 
0: 			if (!requiredType.equals(typeName))
0: 			{
0: 				throwNoMethodFound(requiredType + " " + javaClassName, parmTypeNames, primParmTypeNames);
0: 			}
0: 
0: 			// for a returns null on null input with a primitive
0: 			// type we need to promote to an object so we can return null.
0: 			if (promoteName != null)
0: 				typeName = promoteName;
0: 		}
0: 	 	setJavaTypeName( typeName );
0: 
0: 		methodParameterTypes = classInspector.getParameterTypes(method);
0: 
0: 		for (int i = 0; i < methodParameterTypes.length; i++)
0: 		{
0: 			String methodParameter = methodParameterTypes[i];
0: 
0: 			if (routineInfo != null) {
0: 				if (i < routineInfo.getParameterCount()) {
0: 					int parameterMode = routineInfo.getParameterModes()[i];
0: 
0: 					switch (parameterMode) {
0: 					case JDBC30Translation.PARAMETER_MODE_IN:
0: 						break;
0: 					case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 						// we need to see if the type of the array is
0: 						// primitive, not the array itself.
0: 						methodParameter = methodParameter.substring(0, methodParameter.length() - 2);
0: 						break;
0: 
0: 					case JDBC30Translation.PARAMETER_MODE_OUT:
0: 						// value is not obtained *from* parameter.
0: 						continue;
0: 					}
0: 				}
0: 			}
0: 
0: 			if (classInspector.primitiveType(methodParameter))
0: 				methodParms[i].castToPrimitive(true);
0: 		}
0: 
0: 		/* Set type info for any null parameters */
0: 		if ( someParametersAreNull() )
0: 		{
0: 			setNullParameterInfo(methodParameterTypes);
0: 		}
0: 
0: 
0:     
0: 		/* bug 4450 - if the callable statement is ? = call form, generate the metadata
0: 		infor for the return parameter. We don't really need that info in order to
0: 		execute the callable statement. But with jdbc3.0, this information should be
0: 		made available for return parameter through ParameterMetaData class.
0: 		Parser sets a flag in compilercontext if ? = call. If the flag is set,
0: 		we generate the metadata info for the return parameter and reset the flag
0: 		in the compilercontext for future call statements*/
0: 		DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(typeName);
0: 		if (getCompilerContext().getReturnParameterFlag()) {
0: 			getCompilerContext().getParameterTypes()[0] = dts;
0: 		}
0:   }
0: 
0: 	/**
0: 	  *	Return true if some parameters are null, false otherwise.
0: 	  */
0: 	protected	boolean	someParametersAreNull()
0: 	{
0: 		int		count = signature.length;
0: 		
0: 		for ( int ictr = 0; ictr < count; ictr++ )
0: 		{
0: 			if ( signature[ictr] == null )
0: 			{
0: 				return true;
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	  *	Build an array of names of the argument types. These types are biased toward
0: 	  *	Java objects. That is, if an argument is of SQLType, then we map it to the
0: 	  *	corresponding Java synonym class (e.g., SQLINT is mapped to 'java.lang.Integer').
0: 	  *
0: 	  *
0: 	  *	@return	array of type names
0: 	  *
0: 	  * @exception StandardException		Thrown on error
0: 	  */
0: 	protected	String[]	getObjectSignature( )
0: 		throws StandardException
0: 	{
0: 		int		count = signature.length;
0: 		String	parmTypeNames[] = new String[ count ];
0: 
0: 		for ( int i = 0; i < count; i++ ) { parmTypeNames[i] = getObjectTypeName( signature[ i ] ); }
0: 
0: 		return parmTypeNames;
0: 	}
0: 
0: 	/**
0: 	 * Build an array of booleans denoting whether or not a given method
0: 	 * parameter is a ?.
0: 	 *
0: 	 * @return array of booleans denoting wheter or not a given method
0: 	 * parameter is a ?.
0: 	 */
0: 	protected boolean[] getIsParam()
0: 	{
0: 		if (methodParms == null)
0: 		{
0: 			return new boolean[0];
0: 		}
0: 		
0: 		boolean[] isParam = new boolean[methodParms.length];
0: 
0: 		for (int index = 0; index < methodParms.length; index++)
0: 		{
0: 			if (methodParms[index] instanceof SQLToJavaValueNode)
0: 			{
0: 				SQLToJavaValueNode stjvn = (SQLToJavaValueNode) methodParms[index];
0: 				if (stjvn.value.isParameterNode())
0: 				{
0: 					isParam[index] = true;
0: 				}
0: 			}
0: 		}
0: 
0: 		return isParam;
0: 	}
0: 
0: 	private	String	getObjectTypeName( JSQLType jsqlType )
0: 		throws StandardException
0: 	{
0: 		if ( jsqlType != null )
0: 		{
0: 			switch( jsqlType.getCategory() )
0: 			{
0: 			    case JSQLType.SQLTYPE: 
0: 
0: 					TypeId	ctid = mapToTypeID( jsqlType );
0: 
0: 					if ( ctid == null ) { return null; }
0: 					else {
0: 						// DB2 LUW does not support Java object types for SMALLINT, INTEGER, BIGINT, REAL, DOUBLE
0: 						// and these are the only types that can map to a primitive or an object type according
0: 						// to SQL part 13. So always map to the primitive type. We can not use the getPrimitiveSignature()
0: 						// as it (incorrectly but historically always has) maps a DECIMAL to a double. 
0: 
0: 						switch (ctid.getJDBCTypeId()) {
0: 						case java.sql.Types.SMALLINT:
0: 						case java.sql.Types.INTEGER:
0: 						case java.sql.Types.BIGINT:
0: 						case java.sql.Types.REAL:
0: 						case java.sql.Types.DOUBLE:
0: 							if (routineInfo != null) {
0: 								TypeCompiler tc = getTypeCompiler(ctid);
0: 								return tc.getCorrespondingPrimitiveTypeName();
0: 							}
0: 							// fall through
0: 						default:
0: 							return ctid.getCorrespondingJavaTypeName();
0: 						}
0: 					}
0: 
0: 		        case JSQLType.JAVA_CLASS: return jsqlType.getJavaClassName();
0: 
0: 		        case JSQLType.JAVA_PRIMITIVE: return JSQLType.primitiveNames[ jsqlType.getPrimitiveKind() ];
0: 
0: 		        default:
0: 
0: 					if (SanityManager.DEBUG)
0: 					{ SanityManager.THROWASSERT( "Unknown JSQLType: " + jsqlType ); }
0: 
0: 			}
0: 		}
0: 
0: 		return "";
0: 	}
0: 
0: 	String[]	getPrimitiveSignature( boolean castToPrimitiveAsNecessary )
0: 		throws StandardException
0: 	{
0: 		int					count = signature.length;
0: 		String[] 			primParmTypeNames = new String[ count ];
0: 		JSQLType			jsqlType;
0: 
0: 		for (int i = 0; i < count; i++)
0: 		{
0: 			jsqlType = signature[ i ];
0: 
0: 			if ( jsqlType == null ) { primParmTypeNames[i] = ""; }
0: 			else
0: 			{
0: 				switch( jsqlType.getCategory() )
0: 			    {
0: 			        case JSQLType.SQLTYPE:
0: 
0: 						if ((procedurePrimitiveArrayType != null)
0: 							&& (i < procedurePrimitiveArrayType.length)
0: 							&& (procedurePrimitiveArrayType[i] != null)) {
0: 
0: 							primParmTypeNames[i] = procedurePrimitiveArrayType[i];
0: 
0: 						} else {
0: 
0: 
0: 							TypeId	ctid = mapToTypeID( jsqlType );
0: 
0: 							if (ctid.isNumericTypeId() || ctid.isBooleanTypeId())
0: 							{
0: 								TypeCompiler tc = getTypeCompiler(ctid);
0: 								primParmTypeNames[i] = tc.getCorrespondingPrimitiveTypeName();
0: 								if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
0: 							}
0: 							else { primParmTypeNames[i] = ctid.getCorrespondingJavaTypeName(); }
0: 						}
0: 
0: 						break;
0: 
0: 		            case JSQLType.JAVA_CLASS:
0: 
0: 						primParmTypeNames[i] = jsqlType.getJavaClassName();
0: 						break;
0: 
0: 		            case JSQLType.JAVA_PRIMITIVE:
0: 
0: 						primParmTypeNames[i] = JSQLType.primitiveNames[ jsqlType.getPrimitiveKind() ];
0: 						if ( castToPrimitiveAsNecessary) { methodParms[i].castToPrimitive(true); }
0: 						break;
0: 
0: 		            default:
0: 
0: 						if (SanityManager.DEBUG)
0: 							{ SanityManager.THROWASSERT( "Unknown JSQLType: " + jsqlType ); }
0: 
0: 				}	// end switch
0: 
0: 			}		// end if
0: 
0: 		}			// end for
0: 
0: 		return primParmTypeNames;
0: 	}
0: 
0: 	/**
0: 	 * Return the variant type for the underlying expression.
0: 	 * The variant type can be:
0: 	 *		VARIANT				- variant within a scan
0: 	 *							  (non-static field access)
0: 	 *		SCAN_INVARIANT		- invariant within a scan
0: 	 *							  (column references from outer tables)
0: 	 *		QUERY_INVARIANT		- invariant within the life of a query
0: 	 *							  (constant expressions)
0: 	 *
0: 	 * @return	The variant type for the underlying expression.
0: 	 */
0: 	protected int getOrderableVariantType() throws StandardException
0: 	{
0: 		// beetle 4880. We return the most variant type of the parameters. If no
0: 		// params then query-invariant. This makes more sense, and we can evaluate
0: 		// only once per query (good for performance) because method call could be
0: 		// expensive.  And if we push down method qualifier to store, language
0: 		// can pre-evaluate the method call.  This avoids letting store evaluate
0: 		// the method while holding page latch, causing deadlock.
0: 
0: 		return getVariantTypeOfParams();
0: 	}
0: 
0: 	private int getVariantTypeOfParams() throws StandardException
0: 	{
0: 		int variance = Qualifier.QUERY_INVARIANT;
0: 
0: 		if (methodParms != null)
0: 		{
0: 			for (int parm = 0; parm < methodParms.length; parm++)
0: 			{
0: 				if (methodParms[parm] != null)
0: 				{
0: 					int paramVariantType =
0: 						methodParms[parm].getOrderableVariantType();
0: 					if (paramVariantType < variance)	//return the most variant type
0: 						variance = paramVariantType;
0: 				}
0: 				else
0: 				{
0: 					variance = Qualifier.VARIANT;
0: 				}
0: 			}
0: 		}
0: 
0: 		return variance;
0: 	}
0: 
0: 
0: 	/////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	ACCESSORS
0: 	//
0: 	/////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Get the method parameters.
0: 	 * 
0: 	 * @return	The method parameters
0: 	 */
0: 	public JavaValueNode[]	getMethodParms()
0: 	{
0: 		return methodParms;
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		Visitable		returnNode = v.visit(this);
0: 
0: 		if (v.skipChildren(this))
0: 		{
0: 			return returnNode;
0: 		}
0: 
0: 		for (int parm = 0; 
0: 			!v.stopTraversal() && parm < methodParms.length; 
0: 			parm++)
0: 		{
0: 			if (methodParms[parm] != null)
0: 			{
0: 				methodParms[parm] = (JavaValueNode)methodParms[parm].accept(v);
0: 			}
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================