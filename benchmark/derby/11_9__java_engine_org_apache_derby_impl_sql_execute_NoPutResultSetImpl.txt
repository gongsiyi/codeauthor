1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.NoPutResultSetImpl
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
19:eac0369: 
6:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b31849d: import org.apache.derby.iapi.reference.SQLState;
1:b31849d: import org.apache.derby.iapi.services.i18n.MessageService;
1:b31849d: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:a660147: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:a660147: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.ResultDescription;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:b31849d: import org.apache.derby.iapi.sql.execute.ExecRow;
1:48a9884: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:48a9884: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1:48a9884: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:48a9884: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
1:b31849d: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:b31849d: import org.apache.derby.iapi.sql.execute.TargetResultSet;
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.RowSource;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:e81e52c: import org.apache.derby.iapi.types.LocatedRow;
1:eac0369: import org.apache.derby.iapi.types.Orderable;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: 
6:eac0369: /**
1:eac0369:  * Abstract ResultSet with built in Activation support for operations that
1:eac0369:  * return rows but do not allow the caller to put data on output pipes. This
1:eac0369:  * implementation of ResultSet is meant to be overridden by subtypes in the
1:eac0369:  * execution engine. Its primary users will be DML operations that do not put
1:eac0369:  * data on output pipes, but simply return it due to being result sets
1:eac0369:  * themselves.
1:eac0369:  * <p>
1:eac0369:  * This abstract class does not define the entire ResultSet
1:eac0369:  * interface, but leaves the 'get' half of the interface
1:eac0369:  * for subtypes to implement. It is package-visible only,
1:eac0369:  * with its methods being public for exposure by its subtypes.
1:eac0369:  * <p>
1:eac0369:  */
1:eac0369: abstract class NoPutResultSetImpl
1:eac0369: extends BasicNoPutResultSetImpl
4:eac0369: {
1:eac0369: 	/* Set in constructor and not modified */
1:eac0369: 	public final int				resultSetNumber;
1:eac0369: 
1:eac0369: 	// fields used when being called as a RowSource
1:eac0369: 	private boolean needsRowLocation;
1:af1c18c:     private boolean needsRowLocationForDeferredCheckConstraints;
1:af1c18c:     protected ExecRow clonedExecRow;
1:eac0369: 	protected TargetResultSet	targetResultSet;
1:eac0369: 
1:eac0369: 	/* beetle 4464. compact flags into array of key column positions that we do check/skip nulls,
1:eac0369: 	 * so that we burn less cycles for each row, column.
1:eac0369: 	 */
1:eac0369: 	protected int[] checkNullCols;
1:eac0369: 	protected int cncLen;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Constructor
6:eac0369: 	 *
1:eac0369: 	 *	@param	activation			The activation
1:eac0369: 	 *	@param	resultSetNumber		The resultSetNumber
1:eac0369: 	 *  @param	optimizerEstimatedRowCount	The optimizer's estimated number
1:eac0369: 	 *										of rows.
1:eac0369: 	 *  @param	optimizerEstimatedCost		The optimizer's estimated cost
1:eac0369: 	 */
1:eac0369: 	NoPutResultSetImpl(Activation activation,
1:eac0369: 						int resultSetNumber,
1:eac0369: 						double optimizerEstimatedRowCount,
1:eac0369: 						double optimizerEstimatedCost)
1:eac0369: 	{
1:c69c8b0: 		super(null,
1:c69c8b0: 				activation,
1:eac0369: 				optimizerEstimatedRowCount,
1:eac0369: 				optimizerEstimatedCost);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(activation!=null, "activation expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(resultSetNumber >= 0, "resultSetNumber expected to be >= 0");
5:eac0369: 		}
1:eac0369: 		this.resultSetNumber = resultSetNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// NoPutResultSet interface
1:eac0369: 
1:2700e3d: 	/**
1:c69c8b0:      * Returns the description of the table's rows
1:c69c8b0: 	 */
1:c69c8b0: 	public ResultDescription getResultDescription() {
1:c69c8b0: 	    return activation.getResultDescription();
1:c69c8b0: 	}
1:c69c8b0: 
1:c69c8b0: 	/**
1:eac0369: 		Return my cursor name for JDBC. Can be null.
1:eac0369: 	*/
1:eac0369: 	public String getCursorName() {
1:eac0369: 
1:eac0369: 		String cursorName = activation.getCursorName();
1:eac0369: 		if ((cursorName == null) && isForUpdate()) {
1:eac0369: 
1:eac0369: 			activation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());
1:eac0369: 
1:eac0369: 			cursorName = activation.getCursorName();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return cursorName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see NoPutResultSet#resultSetNumber() */
1:eac0369: 	public int resultSetNumber() {
1:eac0369: 		return resultSetNumber;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close needs to invalidate any dependent statements, if this is a cursor.
1:eac0369: 		Must be called by any subclasses that override close().
1:eac0369: 		@exception StandardException on error
1:eac0369: 	*/
1:eac0369: 	public void close() throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!isOpen)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		/* If this is the top ResultSet then we must
1:eac0369: 		 * close all of the open subqueries for the
1:eac0369: 		 * entire query.
1:eac0369: 		 */
1:eac0369: 		if (isTopResultSet)
1:eac0369: 		{
1:eac0369: 			/*
1:a660147: 			** If run time statistics tracing is turned on, then now is the
1:a660147: 			** time to dump out the information.
1:eac0369: 			*/
1:a660147: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1:48a9884: 			
1:48a9884:                 // only if statistics is switched on, collect & derive them
1:b4885a6:                 if (lcc.getRunTimeStatisticsMode() &&
1:b4885a6:                     !lcc.getStatementContext().getStatementWasInvalidated())
1:48a9884: 				{   
1:48a9884:                     endExecutionTime = getCurrentTimeMillis();
1:53ce71e: 
1:48a9884:                     // get the ResultSetStatisticsFactory, which gathers RuntimeStatistics
1:48a9884:                     ExecutionFactory ef = lcc.getLanguageConnectionFactory().getExecutionFactory();
1:48a9884:                     ResultSetStatisticsFactory rssf;
1:48a9884:                     rssf = ef.getResultSetStatisticsFactory();
1:48a9884:   
1:48a9884:                     // get the RuntimeStatisticsImpl object which is the wrapper for all 
1:48a9884:                     // gathered statistics about all the different resultsets
1:48a9884:                     RunTimeStatistics rsImpl = rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray); 
1:48a9884:   
1:48a9884:                     // save the RTW (wrapper)object in the lcc
1:48a9884:                     lcc.setRunTimeStatisticsObject(rsImpl);
1:48a9884:                     
1:48a9884:                     // now explain gathered statistics, using an appropriate visitor
1:48a9884:                     XPLAINVisitor visitor = ef.getXPLAINFactory().getXPLAINVisitor();
1:48a9884:                     visitor.doXPLAIN(rsImpl,activation);
1:48a9884:   				}
1:eac0369: 
1:eac0369: 			int staLength = (subqueryTrackingArray == null) ? 0 :
1:eac0369: 								subqueryTrackingArray.length;
1:eac0369: 
1:eac0369: 			for (int index = 0; index < staLength; index++)
1:eac0369: 			{
1:eac0369: 				if (subqueryTrackingArray[index] == null)
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 				if (subqueryTrackingArray[index].isClosed())
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 				subqueryTrackingArray[index].close();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		isOpen = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see NoPutResultSet#setTargetResultSet */
1:eac0369: 	public void setTargetResultSet(TargetResultSet trs)
1:eac0369: 	{
1:eac0369: 		targetResultSet = trs;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see NoPutResultSet#setNeedsRowLocation */
1:eac0369: 	public void setNeedsRowLocation(boolean needsRowLocation)
1:eac0369: 	{
1:eac0369: 		this.needsRowLocation = needsRowLocation;
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public void setHasDeferrableChecks() {
1:af1c18c:         this.needsRowLocationForDeferredCheckConstraints = true;
1:af1c18c:     }
1:af1c18c: 
1:eac0369: 	// RowSource interface
1:eac0369: 	
1:eac0369: 	/** 
1:eac0369: 	 * @see RowSource#getValidColumns
1:eac0369: 	 */
1:eac0369: 	public FormatableBitSet getValidColumns()
1:eac0369: 	{
1:eac0369: 		// All columns are valid
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** 
1:eac0369: 	 * @see RowSource#getNextRowFromRowSource
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor[] getNextRowFromRowSource()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow execRow = getNextRowCore();
1:eac0369:  		if (execRow != null)
1:eac0369: 		{
1:eac0369: 			/* Let the target preprocess the row.  For now, this
1:eac0369: 			 * means doing an in place clone on any indexed columns
1:eac0369: 			 * to optimize cloning and so that we don't try to drain
1:eac0369: 			 * a stream multiple times.  This is where we also
1:eac0369: 			 * enforce any check constraints.
1:eac0369: 			 */
1:eac0369: 			clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
1:eac0369: 
1:eac0369: 			return execRow.getRowArray();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RowSource#needsToClone
1:eac0369: 	 */
1:eac0369: 	public boolean needsToClone()
1:eac0369: 	{
1:eac0369: 		return(true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see RowSource#closeRowSource
1:eac0369: 	 */
1:eac0369: 	public void closeRowSource()
1:eac0369: 	{
1:eac0369: 		// Do nothing here - actual work will be done in close()
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// RowLocationRetRowSource interface
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RowLocationRetRowSource#needsRowLocation
1:eac0369: 	 */
1:eac0369: 	public boolean needsRowLocation()
1:eac0369: 	{
1:eac0369: 		return needsRowLocation;
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public boolean needsRowLocationForDeferredCheckConstraints()
1:af1c18c:     {
1:af1c18c:         return needsRowLocationForDeferredCheckConstraints;
1:af1c18c:     }
1:af1c18c: 
1:af1c18c:     /**
1:eac0369: 	 * @see RowLocationRetRowSource#rowLocation
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void rowLocation(RowLocation rl)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		targetResultSet.changedRow(clonedExecRow, rl);
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public void offendingRowLocation(
1:af1c18c:             RowLocation rl, long containdId) throws StandardException {
1:eac0369: 
1:af1c18c:         targetResultSet.offendingRowLocation(rl, containdId);
1:af1c18c:     }
1:eac0369: 	// class implementation
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clear the Orderable cache for each qualifier.
1:eac0369: 	 * (This should be done each time a scan/conglomerate with
1:eac0369: 	 * qualifiers is reopened.)
1:eac0369: 	 *
1:eac0369: 	 * @param qualifiers	The Qualifiers to clear
1:eac0369: 	 */
1:eac0369: 	protected void clearOrderableCache(Qualifier[][] qualifiers) throws StandardException
1:eac0369: 	{
1:eac0369: 		// Clear the Qualifiers's Orderable cache 
1:eac0369: 		if (qualifiers != null)
1:eac0369: 		{
1:eac0369: 			Qualifier qual;
1:eac0369: 			for (int term = 0; term < qualifiers.length; term++)
1:eac0369: 			{
1:eac0369: 				for (int index = 0; index < qualifiers[term].length; index++)
1:eac0369: 				{
1:eac0369: 					qual = qualifiers[term][index];
1:eac0369: 					qual.clearOrderableCache();
1:eac0369: 					/* beetle 4880 performance enhancement and avoid deadlock while pushing
1:eac0369: 					 * down method call to store: pre-evaluate.
1:eac0369: 					 */
1:eac0369: 					if (((GenericQualifier) qual).variantType != Qualifier.VARIANT)
1:eac0369: 						qual.getOrderable();		// ignore return value
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the current row to the row passed in.
1:eac0369: 	 *
1:eac0369: 	 * @param row the new current row
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public final void setCurrentRow(ExecRow row)
1:eac0369: 	{
1:eac0369: 		activation.setCurrentRow(row, resultSetNumber);
1:2700e3d: 		currentRow = row;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Clear the current row
1:eac0369: 	 *
1:eac0369: 	 */
1:69a192a: 	public void clearCurrentRow()
1:eac0369: 	{
1:9634cd2: 		currentRow = null;
1:eac0369: 		activation.clearCurrentRow(resultSetNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * This method will be overriden in the inherited Classes
1:eac0369: 	 * if it is true
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if we should skip the scan due to nulls in the start
1:eac0369: 	 * or stop position when the predicate on the column(s) in question
1:eac0369: 	 * do not implement ordered null semantics. beetle 4464, we also compact
1:eac0369: 	 * the areNullsOrdered flags into checkNullCols here.
1:eac0369: 	 *
1:eac0369: 	 * @param startPosition	An index row for the start position
1:eac0369: 	 * @param stopPosition	An index row for the stop position
1:eac0369: 	 *
1:eac0369: 	 * @return	true means not to do the scan
1:eac0369: 	 */
1:eac0369: 	protected boolean skipScan(ExecIndexRow startPosition, ExecIndexRow stopPosition)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int nStartCols = (startPosition == null) ? 0 : startPosition.nColumns();
1:eac0369: 		int nStopCols = (stopPosition == null) ? 0 : stopPosition.nColumns();
1:eac0369: 
1:eac0369: 		/* Two facts 1) for start and stop key column positions, one has to be the prefix
1:eac0369: 		 * of the other, 2) startPosition.areNullsOrdered(i) can't be different from
1:eac0369: 		 * stopPosition.areNullsOrdered(i) unless the case "c > null and c < 5", (where c is
1:eac0369: 		 * non-nullable), in which we skip the scan anyway.
1:eac0369: 		 * So we can just use the longer one to get checkNullCols.
1:eac0369: 		 */
1:eac0369: 		boolean startKeyLonger = false;
1:eac0369: 		int size = nStopCols;
1:eac0369: 		if (nStartCols > nStopCols)
1:eac0369: 		{
1:eac0369: 			startKeyLonger = true;
1:eac0369: 			size = nStartCols;
1:eac0369: 		}
1:eac0369: 		if (size == 0)
1:eac0369: 			return false;
1:eac0369: 		if ((checkNullCols == null) || (checkNullCols.length < size))
1:eac0369: 			checkNullCols = new int[size];
1:eac0369: 		cncLen = 0;
1:eac0369: 
1:eac0369: 		boolean returnValue = false;
1:eac0369: 		for (int position = 0; position < nStartCols; position++)
1:eac0369: 		{
1:eac0369: 			if ( ! startPosition.areNullsOrdered(position))
1:eac0369: 			{
1:eac0369: 				if (startKeyLonger)
1:eac0369: 					checkNullCols[cncLen++] = position + 1;
1:eac0369: 				if (startPosition.getColumn(position + 1).isNull())
1:eac0369: 				{
1:eac0369: 					returnValue =  true;
1:eac0369: 					if (! startKeyLonger)
1:eac0369: 						break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (startKeyLonger && returnValue)
1:eac0369: 			return true;
1:eac0369: 		for (int position = 0; position < nStopCols; position++)
1:eac0369: 		{
1:eac0369: 			if ( ! stopPosition.areNullsOrdered(position))
1:eac0369: 			{
1:eac0369: 				if (! startKeyLonger)
1:eac0369: 					checkNullCols[cncLen++] = position + 1;
1:eac0369: 				if (returnValue)
1:eac0369: 					continue;
1:eac0369: 				if (stopPosition.getColumn(position + 1).isNull())
1:eac0369: 				{
1:eac0369: 					returnValue =  true;
1:eac0369: 					if (startKeyLonger)
1:eac0369: 						break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return returnValue;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if we should skip the scan due to nulls in the row
1:eac0369: 	 * when the start or stop positioners on the columns containing
1:eac0369: 	 * null do not implement ordered null semantics.
1:eac0369: 	 *
1:eac0369: 	 * @param row	An index row
1:eac0369: 	 *
1:eac0369: 	 * @return	true means skip the row because it has null
1:eac0369: 	 */
1:eac0369: 	protected boolean skipRow(ExecRow row)  throws StandardException
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < cncLen; i++)
1:eac0369: 		{
1:eac0369: 			if (row.getColumn(checkNullCols[i]).isNull())
1:eac0369: 				return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return a 2-d array of Qualifiers as a String
1:eac0369: 	 */
1:eac0369: 	public static String printQualifiers(Qualifier[][] qualifiers)
1:eac0369: 	{
1:eac0369: 		String idt = "";
1:eac0369: 
1:eac0369: 		String output = "";
1:eac0369: 		if (qualifiers == null)
1:eac0369: 		{
1:eac0369: 			return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
1:eac0369: 		}
1:eac0369: 
1:eac0369:         for (int term = 0; term < qualifiers.length; term++)
1:eac0369:         {
1:eac0369:             for (int i = 0; i < qualifiers[term].length; i++)
1:eac0369:             {
1:eac0369:                 Qualifier qual = qualifiers[term][i];
1:eac0369: 
1:eac0369:                 output = idt + output +
1:eac0369:                     MessageService.getTextMessage(
1:eac0369:                         SQLState.LANG_COLUMN_ID_ARRAY,
1:eac0369:                             String.valueOf(term), String.valueOf(i)) +
1:eac0369:                         ": " + qual.getColumnId() + "\n";
1:eac0369:                     
1:eac0369:                 int operator = qual.getOperator();
1:eac0369:                 String opString = null;
1:eac0369:                 switch (operator)
1:eac0369:                 {
1:eac0369:                   case Orderable.ORDER_OP_EQUALS:
1:eac0369:                     opString = "=";
1:eac0369:                     break;
1:eac0369: 
1:eac0369:                   case Orderable.ORDER_OP_LESSOREQUALS:
1:eac0369:                     opString = "<=";
1:eac0369:                     break;
1:eac0369: 
1:eac0369:                   case Orderable.ORDER_OP_LESSTHAN:
1:eac0369:                     opString = "<";
1:eac0369:                     break;
1:eac0369: 
1:eac0369:                   default:
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         SanityManager.THROWASSERT("Unknown operator " + operator);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     // NOTE: This does not have to be internationalized, because
1:eac0369:                     // this code should never be reached.
1:eac0369:                     opString = "unknown value (" + operator + ")";
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 output = output +
1:eac0369:                     idt + MessageService.getTextMessage(SQLState.LANG_OPERATOR) +
1:eac0369:                             ": " + opString + "\n" +
1:eac0369:                     idt +
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_ORDERED_NULLS) +
1:eac0369:                         ": " + qual.getOrderedNulls() + "\n" +
1:eac0369:                     idt +
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_UNKNOWN_RETURN_VALUE) +
1:eac0369:                         ": " + qual.getUnknownRV() + "\n" +
1:eac0369:                     idt +
1:eac0369:                         MessageService.getTextMessage(
1:eac0369:                             SQLState.LANG_NEGATE_COMPARISON_RESULT) +
1:eac0369:                         ": " + qual.negateCompareResult() + "\n";
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		return output;
1:eac0369: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:7d0f620: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:2700e3d: 		// Only ResultSets of type Scroll Insensitive implement
1:2700e3d: 		// detectability, so for other result sets this method
1:2700e3d: 		// is a no-op
1:2700e3d: 	}
1:2700e3d: 
1:e81e52c: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException {
1:2700e3d: 		// Only ResultSets of type Scroll Insensitive implement
1:2700e3d: 		// detectability, so for other result sets this method
1:2700e3d: 		// is a no-op
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#positionScanAtRowLocation
1:2700e3d: 	 *
1:2700e3d: 	 * This method is result sets used for scroll insensitive updatable 
1:2700e3d: 	 * result sets for other result set it is a no-op.
1:2700e3d: 	 */
1:2700e3d: 	public void positionScanAtRowLocation(RowLocation rl) 
1:2700e3d: 		throws StandardException 
1:2700e3d: 	{
1:2700e3d: 		// Only ResultSets of type Scroll Insensitive implement
1:2700e3d: 		// detectability, so for other result sets this method
1:2700e3d: 		// is a no-op
1:2700e3d: 	}
1:2700e3d: 
1:eac0369:     /**
1:e81e52c:      * Get all of the columns out of a value stored in a BackingStoreHashtable.
1:e81e52c:      */
1:e81e52c:     protected DataValueDescriptor[]   unpackHashValue( Object hashValue )
1:e81e52c:     {
1:e81e52c:         if ( hashValue == null ) { return null; }
1:e81e52c:         else if ( hashValue instanceof DataValueDescriptor[] ) { return (DataValueDescriptor[]) hashValue; }
1:e81e52c:         else { return ((LocatedRow) hashValue).flatten(); }
1:e81e52c:     }
1:2700e3d: 
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     private boolean needsRowLocationForDeferredCheckConstraints;
1:     protected ExecRow clonedExecRow;
/////////////////////////////////////////////////////////////////////////
1:     public void setHasDeferrableChecks() {
1:         this.needsRowLocationForDeferredCheckConstraints = true;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public boolean needsRowLocationForDeferredCheckConstraints()
1:     {
1:         return needsRowLocationForDeferredCheckConstraints;
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public void offendingRowLocation(
1:             RowLocation rl, long containdId) throws StandardException {
1:         targetResultSet.offendingRowLocation(rl, containdId);
1:     }
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	public void updateRow(ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
commit:69a192a
/////////////////////////////////////////////////////////////////////////
1: 	public void clearCurrentRow()
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.LocatedRow;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get all of the columns out of a value stored in a BackingStoreHashtable.
1:      */
1:     protected DataValueDescriptor[]   unpackHashValue( Object hashValue )
1:     {
1:         if ( hashValue == null ) { return null; }
1:         else if ( hashValue instanceof DataValueDescriptor[] ) { return (DataValueDescriptor[]) hashValue; }
1:         else { return ((LocatedRow) hashValue).flatten(); }
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
/////////////////////////////////////////////////////////////////////////
1: 			
1:                 // only if statistics is switched on, collect & derive them
0:                 if (lcc.getRunTimeStatisticsMode())
1: 				{   
1:                     endExecutionTime = getCurrentTimeMillis();
1:                     // get the ResultSetStatisticsFactory, which gathers RuntimeStatistics
1:                     ExecutionFactory ef = lcc.getLanguageConnectionFactory().getExecutionFactory();
1:                     ResultSetStatisticsFactory rssf;
1:                     rssf = ef.getResultSetStatisticsFactory();
1:   
1:                     // get the RuntimeStatisticsImpl object which is the wrapper for all 
1:                     // gathered statistics about all the different resultsets
1:                     RunTimeStatistics rsImpl = rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray); 
1:   
1:                     // save the RTW (wrapper)object in the lcc
1:                     lcc.setRunTimeStatisticsObject(rsImpl);
1:                     
1:                     // now explain gathered statistics, using an appropriate visitor
1:                     XPLAINVisitor visitor = ef.getXPLAINFactory().getXPLAINVisitor();
1:                     visitor.doXPLAIN(rsImpl,activation);
1:   				}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b4885a6
/////////////////////////////////////////////////////////////////////////
1:                 if (lcc.getRunTimeStatisticsMode() &&
1:                     !lcc.getStatementContext().getStatementWasInvalidated())
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 		super(null,
1: 				activation,
/////////////////////////////////////////////////////////////////////////
1:      * Returns the description of the table's rows
1: 	 */
1: 	public ResultDescription getResultDescription() {
1: 	    return activation.getResultDescription();
1: 	}
1: 
1: 	/**
commit:fbf1381
/////////////////////////////////////////////////////////////////////////
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 		currentRow = row;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * @see NoPutResultSet#updateRow
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
0: 	public void updateRow(ExecRow row) throws StandardException {
1: 		// Only ResultSets of type Scroll Insensitive implement
1: 		// detectability, so for other result sets this method
1: 		// is a no-op
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException {
1: 		// Only ResultSets of type Scroll Insensitive implement
1: 		// detectability, so for other result sets this method
1: 		// is a no-op
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#positionScanAtRowLocation
1: 	 *
1: 	 * This method is result sets used for scroll insensitive updatable 
1: 	 * result sets for other result set it is a no-op.
1: 	 */
1: 	public void positionScanAtRowLocation(RowLocation rl) 
1: 		throws StandardException 
1: 	{
1: 		// Only ResultSets of type Scroll Insensitive implement
1: 		// detectability, so for other result sets this method
1: 		// is a no-op
1: 	}
1: 
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:53ce71e
/////////////////////////////////////////////////////////////////////////
1:                 
0: 					lcc.getLanguageConnectionFactory().getExecutionFactory().getResultSetStatisticsFactory().getRunTimeStatistics(activation, this, subqueryTrackingArray));
commit:24e3f7e
/////////////////////////////////////////////////////////////////////////
commit:4358952
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:4ef8621
/////////////////////////////////////////////////////////////////////////
0: 		super(activation,
/////////////////////////////////////////////////////////////////////////
0: 	public final ResultDescription getResultDescription() {
commit:b31849d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.TargetResultSet;
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.NoPutResultSetImpl
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
0: import org.apache.derby.iapi.sql.execute.TargetResultSet;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1: import org.apache.derby.iapi.store.access.RowSource;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.Orderable;
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import java.sql.Timestamp;
1: 
1: 
1: /**
1:  * Abstract ResultSet with built in Activation support for operations that
1:  * return rows but do not allow the caller to put data on output pipes. This
1:  * implementation of ResultSet is meant to be overridden by subtypes in the
1:  * execution engine. Its primary users will be DML operations that do not put
1:  * data on output pipes, but simply return it due to being result sets
1:  * themselves.
1:  * <p>
1:  * This abstract class does not define the entire ResultSet
1:  * interface, but leaves the 'get' half of the interface
1:  * for subtypes to implement. It is package-visible only,
1:  * with its methods being public for exposure by its subtypes.
1:  * <p>
1:  */
1: abstract class NoPutResultSetImpl
1: extends BasicNoPutResultSetImpl
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/* Set in constructor and not modified */
1: 	public final int				resultSetNumber;
1: 
0: 	/* fields used for formating run time statistics output */
0: 	protected String indent;
0: 	protected String subIndent;
0: 	protected int sourceDepth;
1: 
1: 	// fields used when being called as a RowSource
1: 	private boolean needsRowLocation;
0: 	protected ExecRow clonedExecRow;
0: 	GeneratedMethod	checkGM;
0: 	long			heapConglomerate;
1: 	protected TargetResultSet	targetResultSet;
1: 
1: 	/* beetle 4464. compact flags into array of key column positions that we do check/skip nulls,
1: 	 * so that we burn less cycles for each row, column.
1: 	 */
1: 	protected int[] checkNullCols;
1: 	protected int cncLen;
1: 
1: 	/**
1: 	 *  Constructor
1: 	 *
1: 	 *	@param	activation			The activation
1: 	 *	@param	resultSetNumber		The resultSetNumber
1: 	 *  @param	optimizerEstimatedRowCount	The optimizer's estimated number
1: 	 *										of rows.
1: 	 *  @param	optimizerEstimatedCost		The optimizer's estimated cost
1: 	 */
1: 	NoPutResultSetImpl(Activation activation,
1: 						int resultSetNumber,
1: 						double optimizerEstimatedRowCount,
1: 						double optimizerEstimatedCost)
1: 	{
0: 		super(null,
0: 				activation,
1: 				optimizerEstimatedRowCount,
1: 				optimizerEstimatedCost);
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(activation!=null, "activation expected to be non-null");
1: 			SanityManager.ASSERT(resultSetNumber >= 0, "resultSetNumber expected to be >= 0");
1: 		}
1: 		this.resultSetNumber = resultSetNumber;
1: 	}
1: 
1: 	// NoPutResultSet interface
1: 
1: 	/**
0:      * Returns the description of the table's rows
1: 	 */
0: 	public ResultDescription getResultDescription() {
0: 	    return activation.getResultDescription();
1: 	}
1: 
1: 	/**
1: 		Return my cursor name for JDBC. Can be null.
1: 	*/
1: 	public String getCursorName() {
1: 
1: 		String cursorName = activation.getCursorName();
1: 		if ((cursorName == null) && isForUpdate()) {
1: 
1: 			activation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());
1: 
1: 			cursorName = activation.getCursorName();
1: 		}
1: 
1: 		return cursorName;
1: 	}
1: 
1: 	/** @see NoPutResultSet#resultSetNumber() */
1: 	public int resultSetNumber() {
1: 		return resultSetNumber;
1: 	}
1: 
1: 	/**
1: 		Close needs to invalidate any dependent statements, if this is a cursor.
1: 		Must be called by any subclasses that override close().
1: 		@exception StandardException on error
1: 	*/
1: 	public void close() throws StandardException
1: 	{
1: 		if (!isOpen)
1: 			return;
1: 
1: 		/* If this is the top ResultSet then we must
1: 		 * close all of the open subqueries for the
1: 		 * entire query.
1: 		 */
1: 		if (isTopResultSet)
1: 		{
1: 			int staLength = (subqueryTrackingArray == null) ? 0 :
1: 								subqueryTrackingArray.length;
1: 
1: 			for (int index = 0; index < staLength; index++)
1: 			{
1: 				if (subqueryTrackingArray[index] == null)
1: 				{
1: 					continue;
1: 				}
1: 				if (subqueryTrackingArray[index].isClosed())
1: 				{
1: 					continue;
1: 				}
1: 				subqueryTrackingArray[index].close();
1: 			}
1: 		}
1: 
1: 		/*
0: 		** If we are the activation's top result set, make it forget about
0: 		** us, because we're closed now.
1: 		*/
0: 		if (activation.getResultSet() == this)
1: 		{
0: 			activation.clearResultSet();
1: 		}
1: 
1: 		isOpen = false;
1: 
1: 	}
1: 
1: 	/** @see NoPutResultSet#setTargetResultSet */
1: 	public void setTargetResultSet(TargetResultSet trs)
1: 	{
1: 		targetResultSet = trs;
1: 	}
1: 
1: 	/** @see NoPutResultSet#setNeedsRowLocation */
1: 	public void setNeedsRowLocation(boolean needsRowLocation)
1: 	{
1: 		this.needsRowLocation = needsRowLocation;
1: 	}
1: 
1: 	// RowSource interface
1: 	
1: 	/** 
1: 	 * @see RowSource#getValidColumns
1: 	 */
1: 	public FormatableBitSet getValidColumns()
1: 	{
1: 		// All columns are valid
1: 		return null;
1: 	}
1: 	
1: 	/** 
1: 	 * @see RowSource#getNextRowFromRowSource
1: 	 * @exception StandardException on error
1: 	 */
1: 	public DataValueDescriptor[] getNextRowFromRowSource()
1: 		throws StandardException
1: 	{
1: 		ExecRow execRow = getNextRowCore();
1:  		if (execRow != null)
1: 		{
1: 			/* Let the target preprocess the row.  For now, this
1: 			 * means doing an in place clone on any indexed columns
1: 			 * to optimize cloning and so that we don't try to drain
1: 			 * a stream multiple times.  This is where we also
1: 			 * enforce any check constraints.
1: 			 */
1: 			clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
1: 
1: 			return execRow.getRowArray();
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * @see RowSource#needsToClone
1: 	 */
1: 	public boolean needsToClone()
1: 	{
1: 		return(true);
1: 	}
1: 
1: 	/** 
1: 	 * @see RowSource#closeRowSource
1: 	 */
1: 	public void closeRowSource()
1: 	{
1: 		// Do nothing here - actual work will be done in close()
1: 	}
1: 
1: 
1: 	// RowLocationRetRowSource interface
1: 
1: 	/**
1: 	 * @see RowLocationRetRowSource#needsRowLocation
1: 	 */
1: 	public boolean needsRowLocation()
1: 	{
1: 		return needsRowLocation;
1: 	}
1: 
1: 	/**
1: 	 * @see RowLocationRetRowSource#rowLocation
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void rowLocation(RowLocation rl)
1: 		throws StandardException
1: 	{
1: 		targetResultSet.changedRow(clonedExecRow, rl);
1: 	}
1: 
1: 
1: 	// class implementation
1: 
1: 	/**
1: 	 * Clear the Orderable cache for each qualifier.
1: 	 * (This should be done each time a scan/conglomerate with
1: 	 * qualifiers is reopened.)
1: 	 *
1: 	 * @param qualifiers	The Qualifiers to clear
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	protected void clearOrderableCache(Qualifier[][] qualifiers) throws StandardException
1: 	{
1: 		// Clear the Qualifiers's Orderable cache 
1: 		if (qualifiers != null)
1: 		{
1: 			Qualifier qual;
1: 			for (int term = 0; term < qualifiers.length; term++)
1: 			{
1: 				for (int index = 0; index < qualifiers[term].length; index++)
1: 				{
1: 					qual = qualifiers[term][index];
1: 					qual.clearOrderableCache();
1: 					/* beetle 4880 performance enhancement and avoid deadlock while pushing
1: 					 * down method call to store: pre-evaluate.
1: 					 */
1: 					if (((GenericQualifier) qual).variantType != Qualifier.VARIANT)
1: 						qual.getOrderable();		// ignore return value
1: 				}
1: 			}
1: 		}
1: 	}
1: 
0: 	/* Support methods for RowSource interface.
0: 	 * These methods are used for enabling check constraint enforcement and
0: 	 * replication logging for published tables when we are a RowSource.
1: 	 */
1: 
1: 	/**
0: 	 * Set the GeneratedMethod for enforcing check constraints
1: 	 * 
0: 	 * @param checkGM	The GeneratedMethod for enforcing any check constraints.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	protected void setCheckConstraints(GeneratedMethod checkGM)
1: 	{
0: 		this.checkGM = checkGM;
1: 	}
1: 
1: 	/**
0: 	 * Set the heap conglomerate number (used in enforcing check constraints)
1: 	 * 
0: 	 * @param heapConglomerate	The heap conglomerate number.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	protected void setHeapConglomerate(long heapConglomerate)
1: 	{
0: 		this.heapConglomerate = heapConglomerate;
1: 	}
1: 
1: 	/**
1: 	 * Set the current row to the row passed in.
1: 	 *
1: 	 * @param row the new current row
1: 	 *
1: 	 */
1: 	public final void setCurrentRow(ExecRow row)
1: 	{
1: 		activation.setCurrentRow(row, resultSetNumber);
1: 	}
1: 
1: 	/**
1: 	 * Clear the current row
1: 	 *
1: 	 */
0: 	public final void clearCurrentRow()
1: 	{
1: 		activation.clearCurrentRow(resultSetNumber);
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * This method will be overriden in the inherited Classes
1: 	 * if it is true
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return true if we should skip the scan due to nulls in the start
1: 	 * or stop position when the predicate on the column(s) in question
1: 	 * do not implement ordered null semantics. beetle 4464, we also compact
1: 	 * the areNullsOrdered flags into checkNullCols here.
1: 	 *
1: 	 * @param startPosition	An index row for the start position
1: 	 * @param stopPosition	An index row for the stop position
1: 	 *
1: 	 * @return	true means not to do the scan
1: 	 */
1: 	protected boolean skipScan(ExecIndexRow startPosition, ExecIndexRow stopPosition)
1: 		throws StandardException
1: 	{
1: 		int nStartCols = (startPosition == null) ? 0 : startPosition.nColumns();
1: 		int nStopCols = (stopPosition == null) ? 0 : stopPosition.nColumns();
1: 
1: 		/* Two facts 1) for start and stop key column positions, one has to be the prefix
1: 		 * of the other, 2) startPosition.areNullsOrdered(i) can't be different from
1: 		 * stopPosition.areNullsOrdered(i) unless the case "c > null and c < 5", (where c is
1: 		 * non-nullable), in which we skip the scan anyway.
1: 		 * So we can just use the longer one to get checkNullCols.
1: 		 */
1: 		boolean startKeyLonger = false;
1: 		int size = nStopCols;
1: 		if (nStartCols > nStopCols)
1: 		{
1: 			startKeyLonger = true;
1: 			size = nStartCols;
1: 		}
1: 		if (size == 0)
1: 			return false;
1: 		if ((checkNullCols == null) || (checkNullCols.length < size))
1: 			checkNullCols = new int[size];
1: 		cncLen = 0;
1: 
1: 		boolean returnValue = false;
1: 		for (int position = 0; position < nStartCols; position++)
1: 		{
1: 			if ( ! startPosition.areNullsOrdered(position))
1: 			{
1: 				if (startKeyLonger)
1: 					checkNullCols[cncLen++] = position + 1;
1: 				if (startPosition.getColumn(position + 1).isNull())
1: 				{
1: 					returnValue =  true;
1: 					if (! startKeyLonger)
1: 						break;
1: 				}
1: 			}
1: 		}
1: 		if (startKeyLonger && returnValue)
1: 			return true;
1: 		for (int position = 0; position < nStopCols; position++)
1: 		{
1: 			if ( ! stopPosition.areNullsOrdered(position))
1: 			{
1: 				if (! startKeyLonger)
1: 					checkNullCols[cncLen++] = position + 1;
1: 				if (returnValue)
1: 					continue;
1: 				if (stopPosition.getColumn(position + 1).isNull())
1: 				{
1: 					returnValue =  true;
1: 					if (startKeyLonger)
1: 						break;
1: 				}
1: 			}
1: 		}
1: 
1: 		return returnValue;
1: 	}
1: 
1: 	/**
1: 	 * Return true if we should skip the scan due to nulls in the row
1: 	 * when the start or stop positioners on the columns containing
1: 	 * null do not implement ordered null semantics.
1: 	 *
1: 	 * @param row	An index row
1: 	 *
1: 	 * @return	true means skip the row because it has null
1: 	 */
1: 	protected boolean skipRow(ExecRow row)  throws StandardException
1: 	{
1: 		for (int i = 0; i < cncLen; i++)
1: 		{
1: 			if (row.getColumn(checkNullCols[i]).isNull())
1: 				return true;
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return a 2-d array of Qualifiers as a String
1: 	 */
1: 	public static String printQualifiers(Qualifier[][] qualifiers)
1: 	{
1: 		String idt = "";
1: 
1: 		String output = "";
1: 		if (qualifiers == null)
1: 		{
1: 			return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
1: 		}
1: 
1:         for (int term = 0; term < qualifiers.length; term++)
1:         {
1:             for (int i = 0; i < qualifiers[term].length; i++)
1:             {
1:                 Qualifier qual = qualifiers[term][i];
1: 
1:                 output = idt + output +
1:                     MessageService.getTextMessage(
1:                         SQLState.LANG_COLUMN_ID_ARRAY,
1:                             String.valueOf(term), String.valueOf(i)) +
1:                         ": " + qual.getColumnId() + "\n";
1:                     
1:                 int operator = qual.getOperator();
1:                 String opString = null;
1:                 switch (operator)
1:                 {
1:                   case Orderable.ORDER_OP_EQUALS:
1:                     opString = "=";
1:                     break;
1: 
1:                   case Orderable.ORDER_OP_LESSOREQUALS:
1:                     opString = "<=";
1:                     break;
1: 
1:                   case Orderable.ORDER_OP_LESSTHAN:
1:                     opString = "<";
1:                     break;
1: 
1:                   default:
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.THROWASSERT("Unknown operator " + operator);
1:                     }
1: 
1:                     // NOTE: This does not have to be internationalized, because
1:                     // this code should never be reached.
1:                     opString = "unknown value (" + operator + ")";
1:                     break;
1:                 }
1:                 output = output +
1:                     idt + MessageService.getTextMessage(SQLState.LANG_OPERATOR) +
1:                             ": " + opString + "\n" +
1:                     idt +
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_ORDERED_NULLS) +
1:                         ": " + qual.getOrderedNulls() + "\n" +
1:                     idt +
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_UNKNOWN_RETURN_VALUE) +
1:                         ": " + qual.getUnknownRV() + "\n" +
1:                     idt +
1:                         MessageService.getTextMessage(
1:                             SQLState.LANG_NEGATE_COMPARISON_RESULT) +
1:                         ": " + qual.negateCompareResult() + "\n";
1:             }
1:         }
1: 
1: 		return output;
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a660147
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
0: 			/*
1: 			** If run time statistics tracing is turned on, then now is the
1: 			** time to dump out the information.
0: 			*/
1: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 			if (lcc.getRunTimeStatisticsMode())
0: 			{
0: 				endExecutionTime = getCurrentTimeMillis();
0: 
0: 				lcc.setRunTimeStatisticsObject(
0: 					lcc.getExecutionContext().getResultSetStatisticsFactory().getRunTimeStatistics(activation, this, subqueryTrackingArray));
0: 
0: 				HeaderPrintWriter istream = lcc.getLogQueryPlan() ? Monitor.getStream() : null;
0: 				if (istream != null)
0: 				{
0: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 											  lcc.getTransactionExecute().getTransactionIdString() +
0: 											  "), " +
0: 											  LanguageConnectionContext.lccStr +
0: 											  lcc.getInstanceNumber() +
0: 											  "), " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementText() + " ******* " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementExecutionPlanText());
0: 				}
0: 			}
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
1: 		currentRow = null;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
0: import org.apache.derby.iapi.sql.execute.TargetResultSet;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.RowSource;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import java.sql.Timestamp;
0: 
0: 
0: /**
0:  * Abstract ResultSet with built in Activation support for operations that
0:  * return rows but do not allow the caller to put data on output pipes. This
0:  * implementation of ResultSet is meant to be overridden by subtypes in the
0:  * execution engine. Its primary users will be DML operations that do not put
0:  * data on output pipes, but simply return it due to being result sets
0:  * themselves.
0:  * <p>
0:  * This abstract class does not define the entire ResultSet
0:  * interface, but leaves the 'get' half of the interface
0:  * for subtypes to implement. It is package-visible only,
0:  * with its methods being public for exposure by its subtypes.
0:  * <p>
0:  */
0: abstract class NoPutResultSetImpl
0: extends BasicNoPutResultSetImpl
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* Set in constructor and not modified */
0: 	public final int				resultSetNumber;
0: 
0: 	/* fields used for formating run time statistics output */
0: 	protected String indent;
0: 	protected String subIndent;
0: 	protected int sourceDepth;
0: 
0: 	// fields used when being called as a RowSource
0: 	private boolean needsRowLocation;
0: 	protected ExecRow clonedExecRow;
0: 	GeneratedMethod	checkGM;
0: 	long			heapConglomerate;
0: 	protected TargetResultSet	targetResultSet;
0: 
0: 	/* beetle 4464. compact flags into array of key column positions that we do check/skip nulls,
0: 	 * so that we burn less cycles for each row, column.
0: 	 */
0: 	protected int[] checkNullCols;
0: 	protected int cncLen;
0: 
0: 	/**
0: 	 *  Constructor
0: 	 *
0: 	 *	@param	activation			The activation
0: 	 *	@param	resultSetNumber		The resultSetNumber
0: 	 *  @param	optimizerEstimatedRowCount	The optimizer's estimated number
0: 	 *										of rows.
0: 	 *  @param	optimizerEstimatedCost		The optimizer's estimated cost
0: 	 */
0: 	NoPutResultSetImpl(Activation activation,
0: 						int resultSetNumber,
0: 						double optimizerEstimatedRowCount,
0: 						double optimizerEstimatedCost)
0: 	{
0: 		super(null,
0: 				activation,
0: 				optimizerEstimatedRowCount,
0: 				optimizerEstimatedCost);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(activation!=null, "activation expected to be non-null");
0: 			SanityManager.ASSERT(resultSetNumber >= 0, "resultSetNumber expected to be >= 0");
0: 		}
0: 		this.resultSetNumber = resultSetNumber;
0: 	}
0: 
0: 	// NoPutResultSet interface
0: 
0: 	/**
0:      * Returns the description of the table's rows
0: 	 */
0: 	public ResultDescription getResultDescription() {
0: 	    return activation.getResultDescription();
0: 	}
0: 
0: 	/**
0: 		Return my cursor name for JDBC. Can be null.
0: 	*/
0: 	public String getCursorName() {
0: 
0: 		String cursorName = activation.getCursorName();
0: 		if ((cursorName == null) && isForUpdate()) {
0: 
0: 			activation.setCursorName(activation.getLanguageConnectionContext().getUniqueCursorName());
0: 
0: 			cursorName = activation.getCursorName();
0: 		}
0: 
0: 		return cursorName;
0: 	}
0: 
0: 	/** @see NoPutResultSet#resultSetNumber() */
0: 	public int resultSetNumber() {
0: 		return resultSetNumber;
0: 	}
0: 
0: 	/**
0: 		Close needs to invalidate any dependent statements, if this is a cursor.
0: 		Must be called by any subclasses that override close().
0: 		@exception StandardException on error
0: 	*/
0: 	public void close() throws StandardException
0: 	{
0: 		if (!isOpen)
0: 			return;
0: 
0: 		/* If this is the top ResultSet then we must
0: 		 * close all of the open subqueries for the
0: 		 * entire query.
0: 		 */
0: 		if (isTopResultSet)
0: 		{
0: 			int staLength = (subqueryTrackingArray == null) ? 0 :
0: 								subqueryTrackingArray.length;
0: 
0: 			for (int index = 0; index < staLength; index++)
0: 			{
0: 				if (subqueryTrackingArray[index] == null)
0: 				{
0: 					continue;
0: 				}
0: 				if (subqueryTrackingArray[index].isClosed())
0: 				{
0: 					continue;
0: 				}
0: 				subqueryTrackingArray[index].close();
0: 			}
0: 		}
0: 
0: 		/*
0: 		** If we are the activation's top result set, make it forget about
0: 		** us, because we're closed now.
0: 		*/
0: 		if (activation.getResultSet() == this)
0: 		{
0: 			activation.clearResultSet();
0: 		}
0: 
0: 		isOpen = false;
0: 
0: 	}
0: 
0: 	/** @see NoPutResultSet#setTargetResultSet */
0: 	public void setTargetResultSet(TargetResultSet trs)
0: 	{
0: 		targetResultSet = trs;
0: 	}
0: 
0: 	/** @see NoPutResultSet#setNeedsRowLocation */
0: 	public void setNeedsRowLocation(boolean needsRowLocation)
0: 	{
0: 		this.needsRowLocation = needsRowLocation;
0: 	}
0: 
0: 	// RowSource interface
0: 	
0: 	/** 
0: 	 * @see RowSource#getValidColumns
0: 	 */
0: 	public FormatableBitSet getValidColumns()
0: 	{
0: 		// All columns are valid
0: 		return null;
0: 	}
0: 	
0: 	/** 
0: 	 * @see RowSource#getNextRowFromRowSource
0: 	 * @exception StandardException on error
0: 	 */
0: 	public DataValueDescriptor[] getNextRowFromRowSource()
0: 		throws StandardException
0: 	{
0: 		ExecRow execRow = getNextRowCore();
0:  		if (execRow != null)
0: 		{
0: 			/* Let the target preprocess the row.  For now, this
0: 			 * means doing an in place clone on any indexed columns
0: 			 * to optimize cloning and so that we don't try to drain
0: 			 * a stream multiple times.  This is where we also
0: 			 * enforce any check constraints.
0: 			 */
0: 			clonedExecRow = targetResultSet.preprocessSourceRow(execRow);
0: 
0: 			return execRow.getRowArray();
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * @see RowSource#needsToClone
0: 	 */
0: 	public boolean needsToClone()
0: 	{
0: 		return(true);
0: 	}
0: 
0: 	/** 
0: 	 * @see RowSource#closeRowSource
0: 	 */
0: 	public void closeRowSource()
0: 	{
0: 		// Do nothing here - actual work will be done in close()
0: 	}
0: 
0: 
0: 	// RowLocationRetRowSource interface
0: 
0: 	/**
0: 	 * @see RowLocationRetRowSource#needsRowLocation
0: 	 */
0: 	public boolean needsRowLocation()
0: 	{
0: 		return needsRowLocation;
0: 	}
0: 
0: 	/**
0: 	 * @see RowLocationRetRowSource#rowLocation
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void rowLocation(RowLocation rl)
0: 		throws StandardException
0: 	{
0: 		targetResultSet.changedRow(clonedExecRow, rl);
0: 	}
0: 
0: 
0: 	// class implementation
0: 
0: 	/**
0: 	 * Clear the Orderable cache for each qualifier.
0: 	 * (This should be done each time a scan/conglomerate with
0: 	 * qualifiers is reopened.)
0: 	 *
0: 	 * @param qualifiers	The Qualifiers to clear
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	protected void clearOrderableCache(Qualifier[][] qualifiers) throws StandardException
0: 	{
0: 		// Clear the Qualifiers's Orderable cache 
0: 		if (qualifiers != null)
0: 		{
0: 			Qualifier qual;
0: 			for (int term = 0; term < qualifiers.length; term++)
0: 			{
0: 				for (int index = 0; index < qualifiers[term].length; index++)
0: 				{
0: 					qual = qualifiers[term][index];
0: 					qual.clearOrderableCache();
0: 					/* beetle 4880 performance enhancement and avoid deadlock while pushing
0: 					 * down method call to store: pre-evaluate.
0: 					 */
0: 					if (((GenericQualifier) qual).variantType != Qualifier.VARIANT)
0: 						qual.getOrderable();		// ignore return value
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/* Support methods for RowSource interface.
0: 	 * These methods are used for enabling check constraint enforcement and
0: 	 * replication logging for published tables when we are a RowSource.
0: 	 */
0: 
0: 	/**
0: 	 * Set the GeneratedMethod for enforcing check constraints
0: 	 * 
0: 	 * @param checkGM	The GeneratedMethod for enforcing any check constraints.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	protected void setCheckConstraints(GeneratedMethod checkGM)
0: 	{
0: 		this.checkGM = checkGM;
0: 	}
0: 
0: 	/**
0: 	 * Set the heap conglomerate number (used in enforcing check constraints)
0: 	 * 
0: 	 * @param heapConglomerate	The heap conglomerate number.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	protected void setHeapConglomerate(long heapConglomerate)
0: 	{
0: 		this.heapConglomerate = heapConglomerate;
0: 	}
0: 
0: 	/**
0: 	 * Set the current row to the row passed in.
0: 	 *
0: 	 * @param row the new current row
0: 	 *
0: 	 */
0: 	public final void setCurrentRow(ExecRow row)
0: 	{
0: 		activation.setCurrentRow(row, resultSetNumber);
0: 	}
0: 
0: 	/**
0: 	 * Clear the current row
0: 	 *
0: 	 */
0: 	public final void clearCurrentRow()
0: 	{
0: 		activation.clearCurrentRow(resultSetNumber);
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * This method will be overriden in the inherited Classes
0: 	 * if it is true
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return true if we should skip the scan due to nulls in the start
0: 	 * or stop position when the predicate on the column(s) in question
0: 	 * do not implement ordered null semantics. beetle 4464, we also compact
0: 	 * the areNullsOrdered flags into checkNullCols here.
0: 	 *
0: 	 * @param startPosition	An index row for the start position
0: 	 * @param stopPosition	An index row for the stop position
0: 	 *
0: 	 * @return	true means not to do the scan
0: 	 */
0: 	protected boolean skipScan(ExecIndexRow startPosition, ExecIndexRow stopPosition)
0: 		throws StandardException
0: 	{
0: 		int nStartCols = (startPosition == null) ? 0 : startPosition.nColumns();
0: 		int nStopCols = (stopPosition == null) ? 0 : stopPosition.nColumns();
0: 
0: 		/* Two facts 1) for start and stop key column positions, one has to be the prefix
0: 		 * of the other, 2) startPosition.areNullsOrdered(i) can't be different from
0: 		 * stopPosition.areNullsOrdered(i) unless the case "c > null and c < 5", (where c is
0: 		 * non-nullable), in which we skip the scan anyway.
0: 		 * So we can just use the longer one to get checkNullCols.
0: 		 */
0: 		boolean startKeyLonger = false;
0: 		int size = nStopCols;
0: 		if (nStartCols > nStopCols)
0: 		{
0: 			startKeyLonger = true;
0: 			size = nStartCols;
0: 		}
0: 		if (size == 0)
0: 			return false;
0: 		if ((checkNullCols == null) || (checkNullCols.length < size))
0: 			checkNullCols = new int[size];
0: 		cncLen = 0;
0: 
0: 		boolean returnValue = false;
0: 		for (int position = 0; position < nStartCols; position++)
0: 		{
0: 			if ( ! startPosition.areNullsOrdered(position))
0: 			{
0: 				if (startKeyLonger)
0: 					checkNullCols[cncLen++] = position + 1;
0: 				if (startPosition.getColumn(position + 1).isNull())
0: 				{
0: 					returnValue =  true;
0: 					if (! startKeyLonger)
0: 						break;
0: 				}
0: 			}
0: 		}
0: 		if (startKeyLonger && returnValue)
0: 			return true;
0: 		for (int position = 0; position < nStopCols; position++)
0: 		{
0: 			if ( ! stopPosition.areNullsOrdered(position))
0: 			{
0: 				if (! startKeyLonger)
0: 					checkNullCols[cncLen++] = position + 1;
0: 				if (returnValue)
0: 					continue;
0: 				if (stopPosition.getColumn(position + 1).isNull())
0: 				{
0: 					returnValue =  true;
0: 					if (startKeyLonger)
0: 						break;
0: 				}
0: 			}
0: 		}
0: 
0: 		return returnValue;
0: 	}
0: 
0: 	/**
0: 	 * Return true if we should skip the scan due to nulls in the row
0: 	 * when the start or stop positioners on the columns containing
0: 	 * null do not implement ordered null semantics.
0: 	 *
0: 	 * @param row	An index row
0: 	 *
0: 	 * @return	true means skip the row because it has null
0: 	 */
0: 	protected boolean skipRow(ExecRow row)  throws StandardException
0: 	{
0: 		for (int i = 0; i < cncLen; i++)
0: 		{
0: 			if (row.getColumn(checkNullCols[i]).isNull())
0: 				return true;
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return a 2-d array of Qualifiers as a String
0: 	 */
0: 	public static String printQualifiers(Qualifier[][] qualifiers)
0: 	{
0: 		String idt = "";
0: 
0: 		String output = "";
0: 		if (qualifiers == null)
0: 		{
0: 			return idt + MessageService.getTextMessage(SQLState.LANG_NONE);
0: 		}
0: 
0:         for (int term = 0; term < qualifiers.length; term++)
0:         {
0:             for (int i = 0; i < qualifiers[term].length; i++)
0:             {
0:                 Qualifier qual = qualifiers[term][i];
0: 
0:                 output = idt + output +
0:                     MessageService.getTextMessage(
0:                         SQLState.LANG_COLUMN_ID_ARRAY,
0:                             String.valueOf(term), String.valueOf(i)) +
0:                         ": " + qual.getColumnId() + "\n";
0:                     
0:                 int operator = qual.getOperator();
0:                 String opString = null;
0:                 switch (operator)
0:                 {
0:                   case Orderable.ORDER_OP_EQUALS:
0:                     opString = "=";
0:                     break;
0: 
0:                   case Orderable.ORDER_OP_LESSOREQUALS:
0:                     opString = "<=";
0:                     break;
0: 
0:                   case Orderable.ORDER_OP_LESSTHAN:
0:                     opString = "<";
0:                     break;
0: 
0:                   default:
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         SanityManager.THROWASSERT("Unknown operator " + operator);
0:                     }
0: 
0:                     // NOTE: This does not have to be internationalized, because
0:                     // this code should never be reached.
0:                     opString = "unknown value (" + operator + ")";
0:                     break;
0:                 }
0:                 output = output +
0:                     idt + MessageService.getTextMessage(SQLState.LANG_OPERATOR) +
0:                             ": " + opString + "\n" +
0:                     idt +
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_ORDERED_NULLS) +
0:                         ": " + qual.getOrderedNulls() + "\n" +
0:                     idt +
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_UNKNOWN_RETURN_VALUE) +
0:                         ": " + qual.getUnknownRV() + "\n" +
0:                     idt +
0:                         MessageService.getTextMessage(
0:                             SQLState.LANG_NEGATE_COMPARISON_RESULT) +
0:                         ": " + qual.negateCompareResult() + "\n";
0:             }
0:         }
0: 
0: 		return output;
0: 	}
0: }
============================================================================